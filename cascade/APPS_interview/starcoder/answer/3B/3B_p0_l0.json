[
    {
        "number": 0,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    accordion = []\n    stack = []\n    i = 0\n\n    while i < len(s):\n        if s[i] == '[':\n            stack.append(i)\n        elif s[i] == ']':\n            if not stack:\n                return -1\n            j = stack.pop()\n            accordion.append(s[j:i+1])\n        i += 1\n\n    if not stack:\n        return max(len(a) for a in accordion)\n    else:\n        return -1"
    },
    {
        "number": 1,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    max_sum = 0\n    max_num = 0\n\n    for i in range(1, x + 1):\n        digits_sum = sum(int(digit) for digit in str(i))\n        if digits_sum > max_sum:\n            max_sum = digits_sum\n            max_num = i\n\n    return str(max_num)"
    },
    {
        "number": 2,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_years = [100, 4000, 5000, 10000, 40000, 50000, 100000, 400000, 500000, 1000000, 4000000, 5000000, 10000000, 40000000, 50000000, 100000000, 400000000, 500000000, 1000000000, 4000000000, 5000000000, 10000000000, 40000000000, 50000000000, 100000000000, 400000000000, 500000000000, 1000000000000, 4000000000000, 5000000000000, 10000000000000, 40000000000000, 50000000000000, 100000000000000, 400000000000000, 500000000000000, 1000000000000000, 4000000000000000, 5000000000000000, 10000000000000000, 40000000000000000, 50000000000000000, 100000000000000000, 400000000000000000, 500000000000000000, 1000000000000000000, 4000000000000000000, 5000000000000000000, 10000000000000000000, 40000000000000000000, 50000000000000000000, 100000000000000000000, 400000000000000000000, 500000000000000000000, 1000000000000000000000, 4000000000000000000000, 5000000000000000000000, 10000000000000000000000, 40000000000000000000000, 50000000000000000000000, 100000000000000000000000, 400000000000000000000000, 500000000000000000000000, 100"
    },
    {
        "number": 3,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    painters = []\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        painters.append((l, r))\n\n    painters.sort(key=lambda x: x[0])\n\n    max_painted = 0\n    for painter in painters:\n        if painter[0] > 1:\n            max_painted += painter[0] - 1\n        else:\n            max_painted += painter[0]\n\n    return str(max_painted)"
    },
    {
        "number": 4,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, hh, mm = map(int, stdin.split())\n    y = 1\n    while True:\n        if str(x * y).count('7') > 0:\n            return str(y)\n        y += 1"
    },
    {
        "number": 5,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pos, l, r = map(int, stdin.split())\n    a, b = min(pos - l, r - pos), max(pos - l, r - pos)\n    return str(min(a + b, n - a - b))"
    },
    {
        "number": 6,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n, x = map(int, stdin.split()[1:])\n        heads = x\n        types = []\n        for _ in range(n):\n            d, h = map(int, stdin.split()[1:])\n            types.append((d, h))\n        types.sort(key=lambda x: (-x[0], x[1]))\n        for i in range(len(types)):\n            d, h = types[i]\n            if heads >= d:\n                heads -= d\n                if heads >= h:\n                    heads += h\n                else:\n                    heads = 0\n            else:\n                break\n        if heads == 0:\n            print(-1)\n        else:\n            print(i + 1)\n    return \"\""
    },
    {
        "number": 7,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = 0\n    grains = 0\n    sparrows = 0\n    while grains < n:\n        days += 1\n        grains += m\n        sparrows += 1\n        if grains >= n:\n            break\n    return str(days)"
    },
    {
        "number": 8,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tiles = stdin.split()\n    suited_tiles = [t for t in tiles if t[0].isdigit()]\n    suited_tiles.sort()\n    mentsu_count = 0\n    for i in range(len(suited_tiles) - 1):\n        if suited_tiles[i][0] == suited_tiles[i + 1][0]:\n            mentsu_count += 1\n    return str(mentsu_count)"
    },
    {
        "number": 9,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[1:])\n    sofas = []\n    for _ in range(int(stdin.split()[0])):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        sofas.append((x1, y1, x2, y2))\n    cnt_l, cnt_r, cnt_t, cnt_b = map(int, stdin.split()[1:])\n\n    def is_valid(x, y, cnt_l, cnt_r, cnt_t, cnt_b):\n        for i in range(cnt_l):\n            if sofas[i][0] == x and sofas[i][1] == y:\n                return False\n        for i in range(cnt_r):\n            if sofas[i][2] == x and sofas[i][3] == y:\n                return False\n        for i in range(cnt_t):\n            if sofas[i][0] == x and sofas[i][1] == y:\n                return False\n        for i in range(cnt_b):\n            if sofas[i][2] == x and sofas[i][3] == y:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j, cnt_l, cnt_r, cnt_t, cnt_b):\n                print(i + 1)\n                return\n\n    print(-1)\n    return \"\"\n"
    },
    {
        "number": 10,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_days_off = 0\n    max_days_off = 0\n\n    for i in range(1, n + 1):\n        if i % 5 == 0:\n            min_days_off += 1\n            max_days_off += 1\n        else:\n            min_days_off += 1\n\n    return str(min_days_off) + \" \" + str(max_days_off)"
    },
    {
        "number": 11,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, p, q = map(int, stdin.split())\n    red_tiles = [True] * (n + 1)\n    blue_tiles = [True] * (n + 1)\n\n    for i in range(1, n + 1):\n        if i % a == 0 and red_tiles[i]:\n            red_tiles[i] = False\n        if i % b == 0 and blue_tiles[i]:\n            blue_tiles[i] = False\n\n    red_chocolates = 0\n    blue_chocolates = 0\n\n    for i in range(1, n + 1):\n        if red_tiles[i]:\n            red_chocolates += p\n        if blue_tiles[i]:\n            blue_chocolates += q\n\n    return str(max(red_chocolates, blue_chocolates))"
    },
    {
        "number": 12,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trophies = list(stdin.split()[1])\n    golden_trophies = [i for i, t in enumerate(trophies) if t == 'G']\n    silver_trophies = [i for i, t in enumerate(trophies) if t == 'S']\n\n    def swap_trophies(i, j):\n        trophies[i], trophies[j] = trophies[j], trophies[i]\n        golden_trophies[i], golden_trophies[j] = golden_trophies[j], golden_trophies[i]\n        silver_trophies[i], silver_trophies[j] = silver_trophies[j], silver_trophies[i]\n\n    def max_beauty(i, j):\n        if i == j:\n            return 0\n        if i < j:\n            return max(max_beauty(i + 1, j), max_beauty(i, j - 1)) + 1\n        else:\n            return max(max_beauty(i, j - 1), max_beauty(i + 1, j)) + 1\n\n    max_beauty_without_swaps = max(max_beauty(0, len(golden_trophies) - 1), max_beauty(0, len(silver_trophies) - 1))\n    max_beauty_with_swaps = max(max_beauty(0, len(golden_trophies) - 1), max_beauty(0, len(silver_trophies) - 1))\n\n    for i in range(len(golden_trophies)):\n        for j in range(i + 1, len(golden_trophies)):\n            if golden_trophies[i] < golden_trophies[j]:\n                swap_trophies(i, j)\n                max_beauty_with_swaps = max(max_beauty_with_swaps, max_beauty(0, len(golden_trophies) - 1))\n                swap_trophies(i, j)\n\n    for i in range(len(silver_trophies)):\n        for j in range(i + 1, len(silver_trophies)):\n            if silver_trophies[i] < silver_trophies[j]:\n                swap_trophies(i, j)\n                max_beauty_with_swaps = max(max_beauty_with_swaps, max_beauty(0, len(silver_trophies) - 1))\n                swap_trophies(i, j)\n\n    return str(max_beauty_without_swaps) if max_beauty_without_swaps > max_beauty_with_swaps else str(max_beauty_with_swaps)"
    },
    {
        "number": 13,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    main_courses = list(map(int, stdin.split()))\n    courses = []\n    for i in range(n):\n        t = list(map(int, stdin.split()))\n        courses.append(t)\n\n    def dfs(course, visited, order):\n        if course in visited:\n            return False\n        visited.add(course)\n        for t in courses[course]:\n            if not dfs(t, visited, order):\n                return False\n        order.append(course)\n        return True\n\n    visited = set()\n    order = []\n    for i in range(n):\n        if not dfs(i, visited, order):\n            return -1\n\n    if len(order) < k:\n        return -1\n\n    m = len(order)\n    result = []\n    for i in range(m):\n        result.append(order[i])\n\n    return f\"{m}\\n{' '.join(map(str, result))}\""
    },
    {
        "number": 14,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def is_stack_sortable(a: list, s: list, b: list) -> bool:\n        while a:\n            a.pop(0)\n            s.append(a.pop(0))\n        while s:\n            s.pop()\n            b.append(s.pop())\n        return b == sorted(b, reverse=True)\n\n    def lexicographically_maximal_permutation(p: list) -> str:\n        for i in range(len(p)):\n            for j in range(i + 1, len(p)):\n                if p[i] > p[j]:\n                    return \" \".join(map(str, p))\n        return \" \".join(map(str, p))\n\n    if is_stack_sortable(p[:k], [], []):\n        return lexicographically_maximal_permutation(p[:k])\n    else:\n        return -1\n"
    },
    {
        "number": 15,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    s = [a]\n    for i in range(1, 1000001):\n        s.append(s[-1] + c)\n        if s[-1] == b:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 16,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, cnt_3, cnt_4 = map(int, stdin.split())\n    if cnt_1 + cnt_2 + cnt_3 + cnt_4 == 0:\n        return \"1\"\n\n    def is_regular(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n            elif c == \"+\":\n                if not stack or stack[-1]!= \"1\":\n                    return False\n        return not stack\n\n    def dfs(s: str, index: int, order: list) -> bool:\n        if index == len(order):\n            return is_regular(s)\n\n        if order[index] == 1:\n            return dfs(s + \"1\", index + 1, order)\n\n        if order[index] == 2:\n            return dfs(s + \"()\", index + 1, order)\n\n        if order[index] == 3:\n            return dfs(s + \"((\", index + 1, order)\n\n        if order[index] == 4:\n            return dfs(s + \"))(\", index + 1, order)\n\n        return False\n\n    order = [1, 2, 3, 4]\n    for i in range(1, 5):\n        if cnt_i > 0:\n            order[i - 1] = 1\n            cnt_i -= 1\n        if cnt_i > 0:\n            order[i - 1] = 2\n            cnt_i -= 1\n        if cnt_i > 0:\n            order[i - 1] = 3\n            cnt_i -= 1\n        if cnt_i > 0:\n            order[i - 1] = 4\n            cnt_i -= 1\n\n    return \"1\" if dfs(\"\", 0, order) else \"0\"\n"
    },
    {
        "number": 17,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, t = map(int, stdin.split())\n    standing_spectators = 0\n    for i in range(1, n + 1):\n        if i <= k:\n            standing_spectators += 1\n        else:\n            standing_spectators -= 1\n        if standing_spectators == t:\n            return str(standing_spectators)\n    return str(standing_spectators)"
    },
    {
        "number": 18,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = \"\"\n    u = \"\"\n\n    for char in s:\n        if len(t) < 10**5:\n            t += char\n        else:\n            u += char\n\n    return u"
    },
    {
        "number": 19,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        n = int(stdin.split()[1])\n        pairs = []\n        for _ in range(n):\n            p, c = map(int, stdin.split()[2:])\n            pairs.append((p, c))\n        pairs.sort()\n        if pairs[0][0] == 0 and pairs[0][1] == 0:\n            print(\"NO\")\n        else:\n            for i in range(1, n):\n                if pairs[i][0] > pairs[i - 1][0]:\n                    print(\"YES\")\n                    break\n            else:\n                print(\"NO\")\n    return \"\""
    },
    {
        "number": 20,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split(':'))\n    if hh == mm:\n        return '0'\n    elif hh % 2 == 0 and mm % 2 == 0:\n        return '0'\n    elif hh % 2 == 0 and mm % 2 == 1:\n        return '1'\n    elif hh % 2 == 1 and mm % 2 == 0:\n        return '1'\n    elif hh % 2 == 1 and mm % 2 == 1:\n        return '2'"
    },
    {
        "number": 21,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    min_element = min(a)\n    max_element = max(a)\n\n    if min_element == max_element:\n        return \"0\"\n\n    min_index = a.index(min_element)\n    max_index = a.index(max_element)\n\n    if min_index > max_index:\n        min_index, max_index = max_index, min_index\n\n    min_distance = abs(min_index - max_index)\n    max_distance = abs(max_index - min_index)\n\n    if min_distance == max_distance:\n        return str(min_distance)\n\n    if min_distance > max_distance:\n        return str(min_distance)\n    else:\n        return str(max_distance)"
    },
    {
        "number": 22,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    for i in range(n // 2):\n        if s[i]!= s[n - i - 1]:\n            return \"NIE\"\n    return \"TAK\""
    },
    {
        "number": 23,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0:\n        return \"0\"\n    if a > b:\n        return \"0\"\n\n    def backtrack(start, current, result):\n        if current > b:\n            return\n        if current == b:\n            result.append(current)\n            return\n        for i in range(start, 10):\n            if i == 0 and current == 0:\n                continue\n            backtrack(i + 1, current * 10 + i, result)\n\n    result = []\n    backtrack(1, a, result)\n    return \"\".join(map(str, result))"
    },
    {
        "number": 24,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(line.strip()) for line in stdin.split('\\n')]\n    n = len(matrix)\n    m = len(matrix[0])\n\n    def count_cross(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 2, row + 3):\n            for j in range(col - 2, col + 3):\n                if 0 <= i < n and 0 <= j < m and matrix[i][j] == 'X':\n                    count += 1\n        return count\n\n    def count_nought(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 2, row + 3):\n            for j in range(col - 2, col + 3):\n                if 0 <= i < n and 0 <= j < m and matrix[i][j] == 'O':\n                    count += 1\n        return count\n\n    def count_empty(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 2, row + 3):\n            for j in range(col - 2, col + 3):\n                if 0 <= i < n and 0 <= j < m and matrix[i][j] == '.':\n                    count += 1\n        return count\n\n    def is_valid(row: int, col: int) -> bool:\n        return 0 <= row < n and 0 <= col < m and matrix[row][col] == '.'\n\n    def is_winning_line(row: int, col: int) -> bool:\n        return (\n            count_cross(row, col) == 5 or\n            count_nought(row, col) == 5 or\n            count_cross(row, col) == count_nought(row, col)\n        )\n\n    def is_winning_cell(row: int, col: int) -> bool:\n        return (\n            count_cross(row, col) == 5 or\n            count_nought(row, col) == 5\n        )\n\n    def is_winning_row(row: int) -> bool:\n        return any(is_winning_line(row, col) for col in range(m))\n\n    def is_winning_col(col: int) -> bool:\n        return any(is_winning_line(row, col) for row in range(n))\n\n    def is_winning_diagonal() -> bool:\n        return (\n            count_cross(0, 0) == 5 or\n            count_nought(0, 0) == 5 or\n            count_cross(n - 1, m - 1) == 5 or\n            count_nought(n - 1, m - 1) == 5\n        )\n\n    def is_winning_cell_or_diagonal() -> bool:\n        return is_winning_cell(0, 0) or is_winning_diagonal()\n\n    def is_winning_cell_or_diagonal_or_row(row: int) -> bool:\n        return is_winning_cell(row, 0) or is_winning_diagonal() or is_winning_row(row)\n\n    def is_winning_cell_or_diagonal_or_row_or_col(col: int) -> bool:\n        return is_winning_cell(0, col) or is_winning_diagonal() or is_winning_row(0) or is_winning_col(col)\n\n    def is_winning_cell_or_diagonal_or_row_or_col_or_corner(row: int, col: int) -> bool:\n        return (\n            is_winning_cell(row, col) or\n            is_winning_diagonal() or\n            is_winning_row(row) or\n            is_winning_col(col) or\n            (row == 0 and col == 0) or\n            (row == n - 1 and col == m - 1)\n        )\n\n    def is_winning_cell_or_diagonal_or_row_or_col_or_corner_or_edge(row: int, col: int) -> bool:\n        return (\n            is_winning_cell(row, col) or\n            is_winning_diagonal() or\n            is_winning_row(row) or\n            is_winning_col(col) or\n            (row == 0 and col == 0) or\n            (row == n - 1 and col == m - 1) or\n            (row == 0 and col"
    },
    {
        "number": 25,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        matrix[i][i] = 1\n    for i in range(k):\n        for j in range(n):\n            if matrix[j][j] == 0:\n                for k in range(j + 1, n):\n                    if matrix[j][k] == 0:\n                        matrix[j][k] = 1\n                        matrix[k][j] = 1\n                        break\n                else:\n                    return -1\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 0:\n                matrix[i][j] = 1\n                matrix[j][i] = 1\n                break\n    return '\\n'.join([' '.join(map(str, row)) for row in matrix])"
    },
    {
        "number": 26,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(float, stdin.split())\n    a = [x**y**z, x**z**y, (x**y)**z, (x**z)**y, y**x**z, y**z**x, (y**x)**z, (y**z)**x, z**x**y, z**y**x, (z**x)**y, (z**y)**x]\n    m = max(a)\n    c = a.index(m)\n    if c == 1:\n        return f\"x^y^z\"\n    elif c == 2:\n        return f\"(x^y)^z\"\n    elif c == 3:\n        return f\"x^z^y\"\n    elif c == 4:\n        return f\"(x^z)^y\"\n    elif c == 5:\n        return f\"y^x^z\"\n    elif c == 6:\n        return f\"y^z^x\"\n    elif c == 7:\n        return f\"(y^x)^z\"\n    elif c == 8:\n        return f\"(y^z)^x\"\n    elif c == 9:\n        return f\"z^x^y\"\n    elif c == 10:\n        return f\"z^y^x\"\n    elif c == 11:\n        return f\"(z^x)^y\"\n    elif c == 12:\n        return f\"(z^y)^x\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 27,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    operations = 0\n    for i in range(n):\n        operations += 1\n        if i == n - 1:\n            operations += 1\n    return str(operations)"
    },
    {
        "number": 28,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    files = []\n    for _ in range(n):\n        name, type_ = stdin.split()\n        files.append((name, int(type_)))\n    files.sort(key=lambda x: x[1])\n    examples = [file for file in files if file[1] == 0][:5]\n    regular = [file for file in files if file[1] == 1]\n    script = []\n    for i, file in enumerate(examples):\n        script.append(f\"move {file[0]} {i + 1}\\n\")\n    for file in regular:\n        script.append(f\"move {file[0]} {len(examples) + 1 + regular.index(file)}\\n\")\n    return \"\".join(script)"
    },
    {
        "number": 29,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ticket = list(map(int, stdin))\n    lucky = True\n    for i in range(3):\n        if ticket[i]!= ticket[-i-1]:\n            lucky = False\n            break\n    if lucky:\n        return \"0\"\n    else:\n        min_replacements = 0\n        for i in range(3):\n            if ticket[i] == 0:\n                min_replacements += 1\n        return str(min_replacements)"
    },
    {
        "number": 30,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, x = map(int, stdin.split())\n    traps = 0\n    for i in range(m):\n        if i % x == 0:\n            traps += 1\n    return str(traps)"
    },
    {
        "number": 31,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    days = 2**n\n    a = 1\n    b = 1\n    while gcd(a, b)!= 1:\n        a = (a * days) % (10**6 + 3)\n        b = (b * days) % (10**6 + 3)\n    a = (a * days) % (10**6 + 3)\n    b = (b * days) % (10**6 + 3)\n    if a >= b:\n        a, b = b, a\n    a = (a * k) % (10**6 + 3)\n    b = (b * k) % (10**6 + 3)\n    if a >= b:\n        a, b = b, a\n    return f\"{a} {b}\"\n\ndef"
    },
    {
        "number": 32,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    parts = []\n    for i in range(n):\n        parts.append(tuple(map(int, stdin.split()[i+1].split())))\n    parts.sort(key=lambda x: x[0])\n    \n    north = True\n    for part in parts:\n        if north:\n            if part[1] == 10000:\n                north = False\n            elif part[1] == 20000:\n                return \"NO\"\n        else:\n            if part[1] == 1000:\n                north = True\n            elif part[1] == 20000:\n                return \"NO\"\n    \n    return \"YES\""
    },
    {
        "number": 33,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, b1, a2, b2, l, r = map(int, stdin.split())\n    count = 0\n    for i in range(l, r + 1):\n        if a1 * i + b1 == a2 * i + b2:\n            count += 1\n    return str(count)"
    },
    {
        "number": 34,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n\n    def is_valid(pieces: int) -> bool:\n        return pieces >= a and pieces <= b\n\n    def min_pieces_on_plate(pieces: int) -> int:\n        return max(1, pieces // a)\n\n    def max_pieces_on_plate(pieces: int) -> int:\n        return min(pieces // b + 1, n)\n\n    def min_pieces_on_plates(pieces: int) -> int:\n        return min(min_pieces_on_plate(pieces), max_pieces_on_plate(pieces))\n\n    def max_pieces_on_plates(pieces: int) -> int:\n        return max(min_pieces_on_plates(pieces), min_pieces_on_plate(pieces))\n\n    def max_pieces(pieces: int) -> int:\n        return max(max_pieces_on_plates(pieces), max_pieces_on_plate(pieces))\n\n    return str(max_pieces(a + b))\n"
    },
    {
        "number": 35,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(row) for row in stdin.split('\\n')]\n\n    # Check if the field has three equal in width and height stripes\n    for i in range(n):\n        for j in range(m):\n            if field[i][j]!= field[i][j + 1] or field[i][j]!= field[i + 1][j]:\n                return \"NO\"\n\n    # Check if the field has three colors and each color is used in exactly one stripe\n    colors = set()\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] not in colors:\n                colors.add(field[i][j])\n            else:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 36,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x, y = 0, 0\n    for i in range(n):\n        dx, dy = 0, 1\n        if i % 2 == 0:\n            dx, dy = 1, 0\n        x += dx\n        y += dy\n    return f\"{x} {y}\""
    },
    {
        "number": 37,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a + b <= c:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 38,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    barriers = list(map(int, stdin.split()))\n    barriers.sort()\n\n    def check_track(start: int, track: list) -> bool:\n        for i in range(n):\n            if track[i] - start!= barriers[i]:\n                return False\n        return True\n\n    for i in range(L):\n        if check_track(i, barriers):\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 39,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    palindromes = set()\n    longest_palindrome = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                palindromes.add(substring)\n                longest_palindrome = max(longest_palindrome, len(substring))\n\n    if longest_palindrome == 0:\n        return \"0\"\n    else:\n        return str(longest_palindrome)"
    },
    {
        "number": 40,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ratings = [list(map(int, stdin.split()[i:i+2])) for i in range(0, n*2, 2)]\n    ratings.sort(key=lambda x: x[0])\n    \n    rated = False\n    for i in range(n):\n        if ratings[i][0]!= ratings[i+1][0]:\n            rated = True\n            break\n    \n    if rated:\n        return \"rated\"\n    else:\n        return \"unrated\""
    },
    {
        "number": 41,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    d = [0] * n\n    for i in range(n):\n        min_j = i\n        for j in range(i + 1, n):\n            if a[j] == 0:\n                min_j = j\n                break\n        d[i] = min_j - i\n\n    return \" \".join(map(str, d))\n"
    },
    {
        "number": 42,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = bin(int(s, 2))[2:].zfill(n)\n    t = s + s\n    count = 0\n    for i in range(2 ** n):\n        if t[i:].find(s)!= -1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 43,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vectors = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.split()[i].split())\n        vectors.append((x, y))\n\n    min_angle = float('inf')\n    result = None\n    for i in range(n):\n        for j in range(i + 1, n):\n            angle = angle_between_vectors(vectors[i], vectors[j])\n            if angle < min_angle:\n                min_angle = angle\n                result = (i + 1, j + 1)\n\n    return''.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 44,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k, a, b, t = map(int, stdin.split())\n    time = 0\n    car_time = 0\n    foot_time = 0\n\n    while time < d:\n        if time + a <= k:\n            time += a\n            car_time += a\n        else:\n            time += k\n            car_time += k\n            foot_time += (time - k) // b + 1\n            time = k + (time - k) % b\n\n    return str(car_time + foot_time + t)"
    },
    {
        "number": 45,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n % k!= 0:\n        return -1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_divisible(num, div):\n        return num % div == 0\n\n    def is_strictly_increasing(seq):\n        for i in range(len(seq) - 1):\n            if seq[i] >= seq[i + 1]:\n                return False\n        return True\n\n    def is_valid_sequence(seq):\n        return is_strictly_increasing(seq) and all(is_divisible(sum(seq), gcd(seq[0], seq[1])))\n\n    def generate_sequence(n, k):\n        seq = [1]\n        while len(seq) < k:\n            seq.append(seq[-1] + 1)\n        return seq\n\n    def find_max_divisor(seq):\n        max_divisor = seq[0]\n        for num in seq:\n            max_divisor = max(max_divisor, gcd(num, max_divisor))\n        return max_divisor\n\n    def find_sequence(n, k):\n        seq = generate_sequence(n, k)\n        max_divisor = find_max_divisor(seq)\n        if not is_valid_sequence(seq):\n            return -1\n\n        for num in seq:\n            if is_divisible(num, max_divisor):\n                return seq\n\n        return -1\n\n    result = find_sequence(n, k)\n    if result == -1:\n        return -1\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 46,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            if (x + y) % 5 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 47,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_beauty(subarray):\n        return max(sum(subarray[i:j+1]) * x for i in range(len(subarray)) for j in range(i, len(subarray)))\n\n    max_beauty_without_x = max(max_beauty(subarray) for subarray in itertools.combinations(a, r=1))\n    max_beauty_with_x = max(max_beauty(subarray) for subarray in itertools.combinations(a, r=1) if x in subarray)\n\n    return str(max(max_beauty_without_x, max_beauty_with_x))"
    },
    {
        "number": 48,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    table = [[i * j for i in range(1, n + 1)] for j in range(1, m + 1)]\n    table.sort(reverse=True)\n    return str(table[k - 1])"
    },
    {
        "number": 49,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    sequence = \"123456789101112131415161718192021222324252627282930313233343536\"\n    return sequence[k - 1]"
    },
    {
        "number": 50,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def buy(i: int, price: int) -> int:\n        if i == n:\n            return 0\n        return max(buy(i + 1, price), r // price)\n\n    def sell(i: int, price: int) -> int:\n        if i == m:\n            return 0\n        return max(sell(i + 1, price), r // price)\n\n    return str(max(buy(0, s[0]), sell(0, b[0])))"
    },
    {
        "number": 52,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return -1\n    teams = n // 2\n    if teams == 1:\n        return str(teams)\n    else:\n        teams_per_game = 2\n        games_per_team = 1\n        while games_per_team < n:\n            games_per_team += teams_per_game\n            teams_per_game += 1\n        return str(teams_per_game)"
    },
    {
        "number": 53,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_antipalindromic(s: str) -> bool:\n        for i in range(n):\n            if s[i] == s[n - i - 1]:\n                return False\n        return True\n\n    def max_beauty(s: str) -> int:\n        max_beauty = 0\n        for i in range(n):\n            if s[i] == s[n - i - 1]:\n                max_beauty += b[i]\n        return max_beauty\n\n    def max_beauty_permutation(s: str) -> int:\n        max_beauty = 0\n        for i in range(n):\n            if s[i] == s[n - i - 1]:\n                max_beauty += b[i]\n        return max_beauty\n\n    def max_beauty_permutation_helper(s: str, index: int, beauty: int) -> int:\n        if index == n:\n            return beauty\n\n        if s[index] == s[n - index - 1]:\n            return max_beauty_permutation_helper(s, index + 1, beauty + b[index])\n\n        return max_beauty_permutation_helper(s, index + 1, beauty)\n\n    max_beauty_t = max_beauty_permutation_helper(s, 0, 0)\n    max_beauty_s = max_beauty(s)\n\n    return str(max(max_beauty_t, max_beauty_s))\n"
    },
    {
        "number": 54,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m = map(int, stdin.split())\n    if w < 2 or m < 1:\n        return 'NO'\n    if m % w == 0:\n        return 'YES'\n    return 'NO'"
    },
    {
        "number": 55,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"Yes\\n\" + \" \".join(map(str, range(k)))\n\n    def binary_search(x: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if 2 ** mid <= x:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def find_sequence(y: int) -> str:\n        sequence = []\n        for i in range(k):\n            x = 2 ** i\n            if x <= y:\n                sequence.append(x)\n        return sequence\n\n    def is_lexicographically_largest(a: list, b: list) -> bool:\n        for i in range(k):\n            if a[i] < b[i]:\n                return True\n            elif a[i] > b[i]:\n                return False\n        return True\n\n    def lexicographically_largest(sequences: list) -> str:\n        for sequence in sequences:\n            if is_lexicographically_largest(sequence, sequence):\n                return \" \".join(map(str, sequence))\n        return \"No\"\n\n    def find_lexicographically_largest(sequences: list) -> str:\n        min_y = float('inf')\n        for sequence in sequences:\n            y = binary_search(sum(sequence))\n            if y < min_y:\n                min_y = y\n        return lexicographically_largest(sequences)\n\n    sequences = []\n    for i in range(1, n + 1):\n        sequence = find_sequence(i)\n        if sequence:\n            sequences.append(sequence)\n\n    if not sequences:\n        return \"No\"\n\n    return \"Yes\\n\" + find_lexicographically_largest(sequences)\n"
    },
    {
        "number": 56,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    glasses = [1] * (n + 1)\n    for i in range(1, n + 1):\n        glasses[i] = glasses[i - 1] * 2\n    glasses[n] = glasses[n - 1] * 2\n    glasses.reverse()\n    count = 0\n    for i in range(t):\n        for j in range(n):\n            if glasses[j] == 0:\n                count += 1\n                glasses[j] = glasses[j + 1]\n            else:\n                glasses[j] -= 1\n                if glasses[j] == 0:\n                    count += 1\n                    glasses[j] = glasses[j + 1]\n                else:\n                    glasses[j] -= 1\n                    if glasses[j] == 0:\n                        count += 1\n                        glasses[j] = glasses[j + 1]\n    return str(count)"
    },
    {
        "number": 57,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            area += abs(points[i][0] - points[j][0]) * abs(points[i][1] - points[j][1])\n    if area > 0:\n        return str(area)\n    else:\n        return \"-1\""
    },
    {
        "number": 58,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    bars = n // 2\n    return str(bars)"
    },
    {
        "number": 59,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:n+1]))\n    forbidden = list(map(int, stdin.split()[n+1:]))\n\n    def is_sorted(arr):\n        return all(arr[i] <= arr[i+1] for i in range(len(arr)-1))\n\n    def is_valid_swap(i, j, forbidden):\n        return i!= j and forbidden[i] == 0 and forbidden[j] == 0\n\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def is_sorted_with_swaps(arr, forbidden):\n        for i in range(len(arr)-1):\n            if not is_valid_swap(i, i+1, forbidden):\n                return False\n            swap(arr, i, i+1)\n            if not is_sorted(arr):\n                return False\n            swap(arr, i, i+1)\n        return True\n\n    if is_sorted(a):\n        return \"YES\"\n    elif is_sorted_with_swaps(a, forbidden):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 60,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    row, seat = map(int, stdin.split())\n    if seat == 'a':\n        return str(row * 10 + 1)\n    elif seat == 'b':\n        return str(row * 10 + 2)\n    elif seat == 'c':\n        return str(row * 10 + 3)\n    elif seat == 'd':\n        return str(row * 10 + 4)\n    elif seat == 'e':\n        return str(row * 10 + 5)\n    elif seat == 'f':\n        return str(row * 10 + 6)\n    else:\n        return \"Invalid seat\""
    },
    {
        "number": 61,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b_x = map(int, stdin.split())\n    x = [int(digit) for digit in stdin.split()[1:]]\n    m, b_y = map(int, stdin.split()[3].split())\n    y = [int(digit) for digit in stdin.split()[4]]\n\n    if b_x == b_y:\n        if x < y:\n            return '<'\n        elif x > y:\n            return '>'\n        else:\n            return '='\n    else:\n        x_base = b_x\n        y_base = b_y\n\n        if b_x > b_y:\n            x_base, y_base = y_base, x_base\n            x, y = y, x\n\n        x = [x_base ** i for i, digit in enumerate(x)]\n        y = [y_base ** i for i, digit in enumerate(y)]\n\n        for i in range(len(x)):\n            if x[i] < y[i]:\n                return '<'\n            elif x[i] > y[i]:\n                return '>'\n            else:\n                continue\n\n        if x < y:\n            return '<'\n        else:\n            return '>'"
    },
    {
        "number": 62,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def bitland(a: list, i: int, x: int) -> None:\n        a[i] -= x\n        for j in range(i + 1, n):\n            a[j] -= x\n\n    def bitaryo(a: list, i: int, x: int) -> None:\n        a[i] -= x\n        for j in range(i + 1, n):\n            a[j] -= x\n\n    def play_game(a: list) -> str:\n        bitland_wins = 0\n        bitaryo_wins = 0\n        for i in range(n):\n            if a[i] > 0:\n                bitland_wins += 1\n            if a[i] < 0:\n                bitaryo_wins += 1\n\n        if bitland_wins > bitaryo_wins:\n            return \"BitLGM\"\n        elif bitaryo_wins > bitland_wins:\n            return \"BitAryo\"\n        else:\n            return \"Tie\"\n\n    winner = play_game(a)\n    return winner"
    },
    {
        "number": 63,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def backtrack(x, y, index):\n        if index == n:\n            return 1\n\n        if x > 0 and a[index] % k == 0:\n            return backtrack(x - 1, y, index + 1) + backtrack(x, y, index + 1)\n\n        if y > 0 and a[n - index - 1] % k == 0:\n            return backtrack(x, y - 1, index + 1) + backtrack(x, y, index + 1)\n\n        return backtrack(x, y, index + 1)\n\n    return str(backtrack(n, 0, 0))"
    },
    {
        "number": 64,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    colors = set(s)\n    if len(colors)!= n:\n        return \"NO\"\n    if k > n:\n        return \"YES\"\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 65,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    a.sort()\n    min1 = a[0]\n    min2 = a[1]\n    min1_count = 0\n    min2_count = 0\n\n    for i in range(2, n):\n        if a[i] == min1:\n            min1_count += 1\n        elif a[i] == min2:\n            min2_count += 1\n\n        if min1_count == 2 and min2_count == 2:\n            break\n\n        if min1_count < 2:\n            min1 = a[i]\n            min1_count = 1\n        elif min2_count < 2:\n            min2 = a[i]\n            min2_count = 1\n\n    return str(abs(min1 - min2))"
    },
    {
        "number": 66,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, w, b = map(int, stdin.split())\n    p = 1\n    q = 1\n    while p * q <= t:\n        p += 1\n        q += 1\n    p -= 1\n    q -= 1\n    if p * q == t:\n        return f\"{p}/{q}\"\n    else:\n        return \"1/1\""
    },
    {
        "number": 67,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    if x == y == z == 0:\n        return \"0\"\n    elif x == y == 0:\n        return \"+\"\n    elif x == 0 == y == z:\n        return \"-\"\n    else:\n        return \"?\""
    },
    {
        "number": 68,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    operations = stdin.split()[1:]\n    min_length = float('inf')\n    max_id = -1\n    min_id = -1\n\n    for i, op in enumerate(operations):\n        if op == 'U':\n            y += 1\n        elif op == 'D':\n            y -= 1\n        elif op == 'L':\n            x -= 1\n        elif op == 'R':\n            x += 1\n\n        if x == 0 and y == 0:\n            max_id = i\n            break\n\n        if i == len(operations) - 1:\n            min_id = i\n\n    if max_id == -1:\n        return -1\n\n    min_length = max_id - min_id + 1\n\n    return str(min_length)"
    },
    {
        "number": 69,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        n, x = map(int, stdin.split()[1:])\n        s = stdin.split()[2]\n        s = ''.join(map(str, list(map(int, s))))\n        t = s + s + s + s + s\n        cnt = [0] * 2\n        for i in range(n):\n            if s[i] == '0':\n                cnt[0] += 1\n            else:\n                cnt[1] += 1\n            if cnt[0] - cnt[1] == x:\n                print(i + 1)\n                break\n        else:\n            print(-1)"
    },
    {
        "number": 70,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n % 10**k == 0:\n        return str(n // 10**k)\n\n    def is_divisible(num: int) -> bool:\n        return num % 10**k == 0\n\n    def remove_digits(num: int, w: int) -> int:\n        while w > 0:\n            num = num // 10\n            w -= 1\n        return num\n\n    def find_min_w(num: int) -> int:\n        w = 0\n        while num % 10 == 0:\n            num //= 10\n            w += 1\n        return w\n\n    def find_min_w_with_digit(num: int) -> int:\n        w = 0\n        while num % 10 == 0:\n            num //= 10\n            w += 1\n        if num == 0:\n            return w\n        return w + 1\n\n    def find_min_w_without_digit(num: int) -> int:\n        w = 0\n        while num % 10 == 0:\n            num //= 10\n            w += 1\n        if num == 0:\n            return w\n        return w - 1\n\n    min_w = find_min_w(n)\n    if is_divisible(n):\n        return str(min_w)\n\n    if min_w == 0:\n        min_w = 1\n\n    if is_divisible(n // 10**min_w):\n        return str(min_w)\n\n    min_w_with_digit = find_min_w_with_digit(n)\n    if is_divisible(n // 10**min_w_with_digit):\n        return str(min_w_with_digit)\n\n    min_w_without_digit = find_min_w_without_digit(n)\n    if is_divisible(n // 10**min_w_without_digit):\n        return str(min_w_without_digit)\n\n    return str(min_w)"
    },
    {
        "number": 71,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, x, y = map(int, stdin.split())\n    max_questions = 0\n    min_questions = 1000000000000000000\n    teacher_asked = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == x and j == y:\n                teacher_asked += 1\n                max_questions = max(max_questions, teacher_asked)\n                min_questions = min(min_questions, teacher_asked)\n            else:\n                teacher_asked = 0\n\n    return str(max_questions) + \" \" + str(min_questions) + \" \" + str(teacher_asked)"
    },
    {
        "number": 72,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    kuro_ribbon = stdin.split()[1]\n    shiro_ribbon = stdin.split()[2]\n    katie_ribbon = stdin.split()[3]\n\n    def count_subribbons(ribbon: str) -> int:\n        count = 0\n        for i in range(len(ribbon) - 1):\n            if ribbon[i] == ribbon[i + 1]:\n                count += 1\n        return count\n\n    def max_beauty(ribbon: str) -> int:\n        return max(count_subribbons(ribbon), count_subribbons(ribbon[::-1]))\n\n    def find_winner(ribbons: list[str]) -> str:\n        max_beauty_cat = \"\"\n        max_beauty_cat_beauty = 0\n        for ribbon in ribbons:\n            beauty = max_beauty(ribbon)\n            if beauty > max_beauty_cat_beauty:\n                max_beauty_cat = ribbon\n                max_beauty_cat_beauty = beauty\n        return max_beauty_cat\n\n    kuro_beauty = max_beauty(kuro_ribbon)\n    shiro_beauty = max_beauty(shiro_ribbon)\n    katie_beauty = max_beauty(katie_ribbon)\n\n    if kuro_beauty > shiro_beauty and kuro_beauty > katie_beauty:\n        return \"Kuro\"\n    elif shiro_beauty > kuro_beauty and shiro_beauty > katie_beauty:\n        return \"Shiro\"\n    else:\n        return \"Katie\"\n\n\ndef"
    },
    {
        "number": 73,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, v_0, v_1, a, l = map(int, stdin.split())\n    days = 0\n    pages_read = 0\n    while pages_read < c:\n        if pages_read + a <= v_1:\n            pages_read += a\n        else:\n            days += 1\n            pages_read = v_1\n    return str(days)"
    },
    {
        "number": 74,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \"Invalid input\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def sum_of_primes(k: int) -> int:\n        primes = [i for i in range(2, n + 1) if is_prime(i)]\n        return sum(primes[:k])\n\n    k = 1\n    while k <= 3 and sum_of_primes(k) < n:\n        k += 1\n\n    if k > 3:\n        return \"Invalid input\"\n\n    primes = [i for i in range(2, n + 1) if is_prime(i)]\n    primes = primes[:k]\n    return f\"{k}\\n{primes[0]}\\n{primes[1]}\\n{primes[2]}\"\n"
    },
    {
        "number": 75,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    field = [list(row) for row in stdin.split()[1:]]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            cx, cy = queue.pop(0)\n            if (cx, cy) in visited:\n                continue\n            visited.add((cx, cy))\n            if cx == n - 1 and cy == m - 1:\n                return True\n            if cx > 0 and field[cx - 1][cy] == \"*\" and (cx, cy) not in visited:\n                queue.append((cx - 1, cy))\n            if cy > 0 and field[cx][cy - 1] == \"*\" and (cx, cy - 1) not in visited:\n                queue.append((cx, cy - 1))\n            if cx < n - 1 and field[cx + 1][cy] == \"*\" and (cx + 1, cy) not in visited:\n                queue.append((cx + 1, cy))\n            if cy < m - 1 and field[cx][cy + 1] == \"*\" and (cx, cy + 1) not in visited:\n                queue.append((cx, cy + 1))\n        return False\n\n    for x in range(n):\n        for y in range(m):\n            if field[x][y] == \"*\" and bfs(x, y):\n                return \"YES\", str(x), str(y)\n\n    return \"NO\""
    },
    {
        "number": 76,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    if n % m!= 0:\n        return \"0\"\n\n    total_boxes = n // m\n    total_burles = total_boxes * (a + b)\n\n    return str(total_burles)"
    },
    {
        "number": 77,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    odd_sum = float('-inf')\n    max_sum = float('-inf')\n    best_subseq = []\n\n    for i in range(1, n):\n        if a[i] % 2 == 1:\n            odd_sum += a[i]\n            if odd_sum > max_sum:\n                max_sum = odd_sum\n                best_subseq = [a[i]]\n            elif odd_sum == max_sum:\n                best_subseq.append(a[i])\n\n    return str(max_sum)"
    },
    {
        "number": 78,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, stdin.split())\n        songs.append((t, g))\n\n    def is_valid(playlist):\n        for i in range(len(playlist) - 1):\n            if playlist[i][1] == playlist[i + 1][1]:\n                return False\n        return True\n\n    def count_sequences(playlist):\n        if len(playlist) == 1:\n            return 1\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_sequences(playlist[:i] + playlist[i + 1:])\n        return count\n\n    def count_valid_sequences(playlist):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_valid_sequences(playlist[:i] + playlist[i + 1:])\n        if is_valid(playlist):\n            count += 1\n        return count\n\n    def count_sequences_with_duration(playlist, duration):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][0] + playlist[i + 1][0] <= duration:\n                count += count_sequences_with_duration(playlist[:i] + playlist[i + 1:], duration - playlist[i][0])\n        return count\n\n    def count_valid_sequences_with_duration(playlist, duration):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][0] + playlist[i + 1][0] <= duration:\n                count += count_valid_sequences_with_duration(playlist[:i] + playlist[i + 1:], duration - playlist[i][0])\n        if is_valid(playlist) and playlist[0][0] + playlist[-1][0] <= duration:\n            count += 1\n        return count\n\n    def count_sequences_with_genre(playlist, genre):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_sequences_with_genre(playlist[:i] + playlist[i + 1:], genre)\n        return count\n\n    def count_valid_sequences_with_genre(playlist, genre):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_valid_sequences_with_genre(playlist[:i] + playlist[i + 1:], genre)\n        if is_valid(playlist) and playlist[0][1] == genre:\n            count += 1\n        return count\n\n    def count_sequences_with_genre_and_duration(playlist, genre, duration):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_sequences_with_genre_and_duration(playlist[:i] + playlist[i + 1:], genre, duration)\n        return count\n\n    def count_valid_sequences_with_genre_and_duration(playlist, genre, duration):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_valid_sequences_with_genre_and_duration(playlist[:i] + playlist[i + 1:], genre, duration)\n        if is_valid(playlist) and playlist[0][1] == genre and playlist[0][0] + playlist[-1][0] <= duration:\n            count += 1\n        return count\n\n    def count_sequences_with_genre_and_duration_and_index(playlist, genre, duration, index):\n        count = 0\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                count += count_sequences_with_genre_and_duration_and_index(playlist[:i] + playlist[i + 1:], genre, duration, index)\n        return count\n\n    def count_valid_sequences_with_genre_and_duration_and_index(playlist, genre, duration, index):\n        count = 0\n        for i in range(len(playlist)"
    },
    {
        "number": 79,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    a = []\n    x = 0\n    while len(a) < m:\n        x = random.randint(1, m)\n        a.append(x)\n    gcd = 1\n    for i in range(len(a)):\n        if gcd == 1:\n            break\n        gcd = gcd_iterative(gcd, a[i])\n    if gcd == 1:\n        return \"1\"\n    else:\n        p = gcd\n        q = 1\n        while p % 2 == 0:\n            p //= 2\n            q *= 2\n        return str((p * pow(q, -1, 1000000007)) % 1000000007)\n\ndef"
    },
    {
        "number": 80,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y = map(int, stdin.split())\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(l, r + 1):\n            if gcd(a, b) == x and lcm(a, b) == y:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 81,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    k = 0\n    while True:\n        lcm = (a + k) * (b + k)\n        if lcm < 0:\n            k -= 1\n        else:\n            break\n    return str(k)"
    },
    {
        "number": 82,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    a.append(k)\n    a.sort()\n    return str(a.index(k) - a.index(a[n]))"
    },
    {
        "number": 83,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    d = 1\n    while True:\n        count = 0\n        for num in arr:\n            if num > 0:\n                count += 1\n        if count >= n // 2:\n            break\n        d += 1\n    return str(d)"
    },
    {
        "number": 84,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for i in range(1, n+1):\n        pairs.append(i)\n    pairs.sort(reverse=True)\n    count = 0\n    for i in range(len(pairs)):\n        for j in range(i+1, len(pairs)):\n            if pairs[i] + pairs[j] == n:\n                count += 1\n    return str(count)"
    },
    {
        "number": 85,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def is_square(n: int) -> bool:\n        return int(n ** 0.5) ** 2 == n\n\n    def level_chocolate(a: int, b: int, m: int) -> int:\n        if a == b:\n            return a\n        elif a > b:\n            a, b = b, a\n        return level_chocolate(a, b, m // 2)\n\n    def level_chocolate_helper(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_2(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_2(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper_2(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_3(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_3(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper_3(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_4(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_4(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper_4(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_5(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_5(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper_5(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_6(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_6(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper_6(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_7(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_7(a, b, m, level // 2, result)\n        else:\n            level_chocolate_helper_7(a, b, m, level - 1, result)\n\n    def level_chocolate_helper_8(a: int, b: int, m: int, level: int, result: List[int]) -> None:\n        if level == 0:\n            result.append((a, b))\n            return\n        if level % 2 == 0:\n            level_chocolate_helper_8(a, b, m, level // 2, result)\n        else"
    },
    {
        "number": 86,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_p, y_p, x_v, y_v = map(int, stdin.split())\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < 1000 and 0 <= y < 1000 and (x, y)!= (x_p, y_p) and (x, y)!= (x_v, y_v)\n\n    def is_win(x: int, y: int) -> bool:\n        return (x, y) == (0, 0)\n\n    def is_winning_move(x: int, y: int) -> bool:\n        return is_valid(x - 1, y) or is_valid(x, y - 1) or is_valid(x - 1, y - 1)\n\n    def is_winning_move_for_player(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x, y - 1)\n\n    def is_winning_move_for_player_in_cell(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x, y - 1) or is_valid(x - 1, y - 1)\n\n    def is_winning_move_for_player_in_cell_or_skip(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x, y - 1) or is_valid(x - 1, y - 1) or (x, y) == (x_p, y_p)\n\n    def is_winning_move_for_player_in_cell_or_skip_or_skip(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x, y - 1) or is_valid(x - 1, y - 1) or (x, y) == (x_p, y_p) or (x, y) == (x_v, y_v)\n\n    def is_winning_move_for_player_in_cell_or_skip_or_skip_or_skip(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x, y - 1) or is_valid(x - 1, y - 1) or (x, y) == (x_p, y_p) or (x, y) == (x_v, y_v) or (x, y) == (0, 0)\n\n    def is_winning_move_for_player_in_cell_or_skip_or_skip_or_skip_or_skip(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x, y - 1) or is_valid(x - 1, y - 1) or (x, y) == (x_p, y_p) or (x, y) == (x_v, y_v) or (x, y) == (0, 0) or (x, y) == (0, 0)\n\n    def is_winning_move_for_player_in_cell_or_skip_or_skip_or_skip_or_skip_or_skip(x: int, y: int, player: int) -> bool:\n        if player == 1:\n            return is_winning_move(x, y)\n        else:\n            return is_valid(x - 1, y) or is_valid(x"
    },
    {
        "number": 87,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split())\n    if m == 2 and d == 4:\n        return \"5\"\n    elif m == 2 and d == 5:\n        return \"6\"\n    elif m == 4 and d == 6:\n        return \"5\"\n    elif m == 4 and d == 7:\n        return \"6\"\n    elif m == 6 and d == 5:\n        return \"5\"\n    elif m == 6 and d == 6:\n        return \"6\"\n    elif m == 9 and d == 5:\n        return \"5\"\n    elif m == 9 and d == 6:\n        return \"6\"\n    elif m == 11 and d == 5:\n        return \"5\"\n    elif m == 11 and d == 6:\n        return \"6\"\n    else:\n        return \"6\""
    },
    {
        "number": 88,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    for year in range(a, b + 1):\n        binary_representation = bin(year)[2:]\n        if len(binary_representation) == 1 and binary_representation[0] == '0':\n            count += 1\n    return str(count)"
    },
    {
        "number": 89,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    n = N * (N + 1) // 2\n    layers = 0\n    while n > 0:\n        layers += 1\n        n -= 1\n    return str(layers)"
    },
    {
        "number": 90,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, S = map(int, stdin.split())\n    cubes = list(map(int, stdin.split()))\n    cubes.sort()\n    count = 0\n    for i in range(1, n+1):\n        if sum(cubes[:i]) == S:\n            count += 1\n    return str(count)"
    },
    {
        "number": 91,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        v = [0] * n\n        for i in range(n):\n            if i == 0:\n                v[i] = a[i]\n            else:\n                if v[i - 1] == 0:\n                    v[i] = k ** i\n                else:\n                    v[i] = v[i - 1]\n        if all(v[i] == a[i] for i in range(n)):\n            print('YES')\n        else:\n            print('NO')\n    return ''"
    },
    {
        "number": 92,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def d(n):\n        if n == 1:\n            return 1\n        return d(n - 1) * 2\n\n    def sum_divisors(a, b, c):\n        return (d(a) * d(b) * d(c)) % mod\n\n    return str(sum_divisors(a, b, c))"
    },
    {
        "number": 93,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    bessie_puzzle = [list(row) for row in stdin.split('\\n')]\n    elsi_puzzle = [list(row) for row in stdin.split('\\n')[2:]]\n\n    def is_valid_move(bessie_puzzle, elsi_puzzle, move):\n        bessie_row, bessie_col = move\n        elsi_row, elsi_col = move\n\n        if bessie_puzzle[bessie_row][bessie_col]!= 'X' and elsi_puzzle[elsi_row][elsi_col]!= 'X':\n            return False\n\n        if bessie_puzzle[bessie_row][bessie_col] == 'X' and elsi_puzzle[elsi_row][elsi_col] == 'X':\n            return False\n\n        if bessie_puzzle[bessie_row][bessie_col] == 'X' and elsi_puzzle[elsi_row][elsi_col]!= 'X':\n            return False\n\n        if bessie_puzzle[bessie_row][bessie_col]!= 'X' and elsi_puzzle[elsi_row][elsi_col] == 'X':\n            return False\n\n        return True\n\n    def is_same_configuration(bessie_puzzle, elsi_puzzle):\n        for row in range(2):\n            for col in range(2):\n                if bessie_puzzle[row][col]!= elsi_puzzle[row][col]:\n                    return False\n        return True\n\n    moves = []\n    for row in range(2):\n        for col in range(2):\n            if bessie_puzzle[row][col] == 'X' and elsi_puzzle[row][col] == 'X':\n                moves.append((row, col))\n\n    for move in moves:\n        if is_valid_move(bessie_puzzle, elsi_puzzle, move):\n            bessie_puzzle[move[0]][move[1]] = 'X'\n            elsi_puzzle[move[0]][move[1]] = 'X'\n\n            if is_same_configuration(bessie_puzzle, elsi_puzzle):\n                return 'YES'\n\n            bessie_puzzle[move[0]][move[1]] = 'A'\n            elsi_puzzle[move[0]][move[1]] = 'A'\n\n    return 'NO'"
    },
    {
        "number": 94,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = 0\n    while k > 0:\n        x = x * n + k % n\n        k //= n\n    return str(x)"
    },
    {
        "number": 95,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    increasing = True\n    constant = True\n    decreasing = True\n\n    for i in range(1, n):\n        if arr[i] < arr[i - 1]:\n            increasing = False\n        elif arr[i] == arr[i - 1]:\n            constant = False\n        elif arr[i] > arr[i - 1]:\n            decreasing = False\n\n    if increasing and constant and decreasing:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 96,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    paths = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        paths[i] = [x for x in paths[i - 1] if x % 2 == 0] + [x for x in paths[i - 1] if x % 2!= 0]\n    max_y = 0\n    for i in range(1, n + 1):\n        for y in paths[i]:\n            if y not in paths[i - 1]:\n                max_y = max(max_y, y)\n                if len(set(paths[i - 1] + [y])) >= k:\n                    return max_y\n    return max_y"
    },
    {
        "number": 97,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, vx, vy = map(int, stdin.split())\n    if vx == 0 and vy == 0:\n        return -1\n\n    ball_x, ball_y = x, y\n    ball_vx, ball_vy = vx, vy\n\n    pockets = [(0, 0), (n, 0), (0, m), (n, m)]\n    pocket_coordinates = []\n\n    while True:\n        ball_x += ball_vx\n        ball_y += ball_vy\n\n        if ball_x < 0 or ball_x >= n or ball_y < 0 or ball_y >= m:\n            break\n\n        if (ball_x, ball_y) in pockets:\n            pocket_coordinates.append((ball_x, ball_y))\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == 0 or ball_x == n - 1:\n            ball_vy = -ball_vy\n\n        if ball_x == 0 or ball_x == n - 1 or ball_y == 0 or ball_y == m - 1:\n            ball_vx = -ball_vx\n\n        if ball_x == "
    },
    {
        "number": 98,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, b1 = map(int, stdin.split()[0].split())\n    a2, b2, a3, b3 = map(int, stdin.split()[1].split())\n\n    if a1 + a2 + a3 > b1 or b1 + b2 + b3 > a1 or a1 + a3 + b2 > b1 or b1 + a2 + b3 > a1:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 99,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b_1, q, l, m = map(int, stdin.split())\n    a_list = list(map(int, stdin.split()))\n\n    if b_1 == 0 and q == 0:\n        return \"inf\"\n\n    count = 0\n    current_term = b_1\n    while current_term <= l:\n        if current_term not in a_list:\n            count += 1\n        current_term += q\n\n    return str(count)"
    },
    {
        "number": 100,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    monitor = [list(line.strip()) for line in stdin.splitlines()[1:]]\n\n    def is_valid_frame(frame):\n        for i in range(len(frame) - 1):\n            if frame[i] == \"w\" and frame[i + 1] == \"w\":\n                return False\n        return True\n\n    def find_optimal_frame(monitor):\n        for d in range(1, n + 1):\n            for i in range(n - d + 1):\n                for j in range(m - d + 1):\n                    frame = [monitor[i + k][j + l] for k in range(d) for l in range(d)]\n                    if is_valid_frame(frame):\n                        return frame\n        return None\n\n    optimal_frame = find_optimal_frame(monitor)\n    if optimal_frame:\n        return \"\\n\".join([\"\".join(row) for row in optimal_frame])\n    else:\n        return str(-1)\n"
    },
    {
        "number": 101,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a * 2 + b * 5 > n:\n        return \"NO\"\n    else:\n        for x in range(1, n // (a * 2 + b) + 1):\n            for y in range(1, n // (a * 2 + b) + 1):\n                if x * a * 2 + y * b * 5 == n:\n                    return \"YES\", str(x), str(y)\n        return \"NO\""
    },
    {
        "number": 102,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    score = int(stdin)\n    if score < 10:\n        return str(score)\n    elif score < 20:\n        return str(score - 10) + \"teen\"\n    elif score < 100:\n        return str(score - 10) + \"ty\"\n    elif score < 1000:\n        return str(score - 100) + \"hundred\"\n    elif score < 10000:\n        return str(score - 1000) + \"thousand\"\n    elif score < 100000:\n        return str(score - 10000) + \"million\"\n    elif score < 1000000:\n        return str(score - 100000) + \"billion\"\n    elif score < 10000000:\n        return str(score - 1000000) + \"trillion\"\n    elif score < 100000000:\n        return str(score - 10000000) + \"quadrillion\"\n    elif score < 1000000000:\n        return str(score - 100000000) + \"quintillion\"\n    elif score < 10000000000:\n        return str(score - 1000000000) + \"sextillion\"\n    elif score < 100000000000:\n        return str(score - 10000000000) + \"septillion\"\n    elif score < 1000000000000:\n        return str(score - 100000000000) + \"octillion\"\n    elif score < 10000000000000:\n        return str(score - 1000000000000) + \"nonillion\"\n    elif score < 100000000000000:\n        return str(score - 10000000000000) + \"decillion\"\n    elif score < 1000000000000000:\n        return str(score - 100000000000000) + \"undecillion\"\n    elif score < 10000000000000000:\n        return str(score - 1000000000000000) + \"duodecillion\"\n    elif score < 100000000000000000:\n        return str(score - 10000000000000000) + \"tredecillion\"\n    elif score < 1000000000000000000:\n        return str(score - 100000000000000000) + \"quattuordecillion\"\n    elif score < 10000000000000000000:\n        return str(score - 1000000000000000000) + \"quindecillion\"\n    elif score < 100000000000000000000:\n        return str(score - 10000000000000000000) + \"sexdecillion\"\n    elif score < 1000000000000000000000:\n        return str(score - 100000000000000000000) + \"septendecillion\"\n    elif score < 10000000000000000000000:\n        return str(score - 1000000000000000000000) + \"octodecillion\"\n    elif score < 100000000000000000000000:\n        return str(score - 10"
    },
    {
        "number": 103,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    max_erase = 0\n    for i in range(1, n):\n        if arr[i] - arr[i - 1] > max_erase:\n            max_erase = arr[i] - arr[i - 1]\n\n    return str(max_erase)"
    },
    {
        "number": 104,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for i in range(n - 1, -1, -1):\n        if a[i] >= n // 2:\n            return str(i + 1)\n    return \"impossible\""
    },
    {
        "number": 105,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = [list(map(int, stdin.split()[1:])) for _ in range(N)]\n\n    def bfs(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def neighbors(node: tuple) -> list:\n        i, j = node\n        return [\n            (i + 1, j),\n            (i - 1, j),\n            (i, j + 1),\n            (i, j - 1),\n            (i + 1, j + 1),\n            (i - 1, j - 1),\n            (i + 1, j - 1),\n            (i - 1, j + 1),\n        ]\n\n    def min_replacements(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps_with_replacements(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps_with_replacements_and_replacements(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps_with_replacements_and_replacements_and_replacements(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps_with_replacements_and_replacements_and_replacements_and_replacements(start: tuple, target: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps_with_replacements_and_replacements_and_replacements_and_replacements_and_replacements(\n        start: tuple, target: tuple\n    ) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, steps = queue.pop(0)\n            if node == target:\n                return steps\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, steps + 1))\n        return -1\n\n    def min_steps_with_replacements_and_replacements_and_replacements_and_replacements_and_replacements_and_replacements(\n        start: tuple, target: tuple\n    ) -> int:\n        queue = [(start"
    },
    {
        "number": 107,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) > 100:\n        return \"no\"\n\n    def is_divisible_by_64(n: int) -> bool:\n        return n % 64 == 0\n\n    def is_valid_representation(n: int) -> bool:\n        return is_divisible_by_64(n) and n > 0\n\n    def remove_digits(s: str) -> str:\n        result = \"\"\n        for c in s:\n            if c == \"1\":\n                result += \"0\"\n            else:\n                result += \"1\"\n        return result\n\n    def is_valid_string(s: str) -> bool:\n        return is_valid_representation(int(s, 2))\n\n    def is_possible_to_remove_digits(s: str) -> bool:\n        return is_valid_string(remove_digits(s))\n\n    if is_possible_to_remove_digits(s):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 108,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i]!= 'z':\n                s = s[:i] + s[i].lower() + s[j].lower() + s[j + 1:]\n                if s in alphabet:\n                    return s\n    return -1"
    },
    {
        "number": 109,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r, k = map(int, stdin.split())\n    pond = [[0] * m for _ in range(n)]\n    caught_fishes = 0\n\n    for _ in range(k):\n        x, y = map(int, input().split())\n        pond[x][y] += 1\n\n    for i in range(n):\n        for j in range(m):\n            if pond[i][j] > 0:\n                caught_fishes += pond[i][j]\n\n    return str(caught_fishes / k)"
    },
    {
        "number": 110,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def max_product(a: list) -> int:\n        max_product = float('-inf')\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                max_product = max(max_product, a[i] * a[j])\n        return max_product\n\n    def max_product_with_operations(a: list) -> int:\n        max_product = float('-inf')\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                for k in range(j + 1, len(a)):\n                    max_product = max(max_product, a[i] * a[j] * a[k])\n        return max_product\n\n    max_product_without_operations = max_product(a)\n    max_product_with_operations_1 = max_product_with_operations(a)\n    max_product_with_operations_2 = max_product_with_operations(a)\n\n    if max_product_without_operations == max_product_with_operations_1:\n        return [str(x) for x in a]\n    elif max_product_without_operations == max_product_with_operations_2:\n        return [str(x) for x in a]\n    else:\n        return [str(x) for x in a]\n"
    },
    {
        "number": 111,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    if len(divisors) < k:\n        return -1\n    return divisors[k-1]"
    },
    {
        "number": 112,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cubes = []\n    for i in range(n):\n        cube = list(map(int, stdin.split()[i+1].split()))\n        cubes.append(cube)\n\n    def is_valid(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_rotation(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_2(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_3(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_4(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_5(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_6(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_7(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_8(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_9(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_10(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_11(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_12(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_13(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_14(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_15(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_16(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_17(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_18(cube):\n        for i in range(6):\n            if cube[i] == 6 or cube[i] == 9:\n                return False\n        return True\n\n    def is_valid_number_rotation_19(cube"
    },
    {
        "number": 113,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = 0\n    while result % n!= 0:\n        result += 1\n    return str(result)"
    },
    {
        "number": 114,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    A = [[int(x) for x in stdin.split()[1].split()] for _ in range(n)]\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 1:\n                B[i][j] = 1\n\n    for _ in range(2):\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if B[i][j] == 1 and B[i][j + 1] == 1 and B[i + 1][j] == 1 and B[i + 1][j + 1] == 1:\n                    B[i][j] = 0\n                    B[i][j + 1] = 0\n                    B[i + 1][j] = 0\n                    B[i + 1][j + 1] = 0\n\n    for i in range(n):\n        for j in range(m):\n            if B[i][j] == 1:\n                print(f\"{i + 1} {j + 1}\")\n\n    return \"\" if all(all(x == 1) for x in row) else \"-1\""
    },
    {
        "number": 115,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, s, p = map(int, stdin.split())\n    rocks = s * p\n    scissors = r * p\n    papers = r * s\n\n    probabilities = [\n        (rocks + scissors + papers) / (r + s + p),\n        (rocks + scissors) / (r + s),\n        (rocks + papers) / (r + p),\n    ]\n\n    return \" \".join(map(str, probabilities))\n"
    },
    {
        "number": 116,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l1, r1, l2, r2, k = map(int, stdin.split())\n    sonya_time = r1 - l1\n    filya_time = r2 - l2\n    sonya_prink_time = k - l1\n    minutes_to_spend = sonya_time + filya_time - sonya_prink_time\n    return str(minutes_to_spend)"
    },
    {
        "number": 117,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b, c = map(int, stdin.split())\n    d, e, f = map(int, stdin.split())\n\n    def cross(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return (p1[0] - p3[0]) * (p2[1] - p4[1]) == (p2[0] - p3[0]) * (p1[1] - p4[1])\n\n    def area(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> int:\n        return abs(p1[0] * (p2[1] - p4[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p4[1] - p2[1]))\n\n    def is_infinite(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return area(p1, p2, p3, p4) == 0\n\n    def is_valid(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return not (cross(p1, p2, p3, p4) or cross(p1, p2, p4, p3))\n\n    def is_inside(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return p1[0] >= a and p1[0] <= b and p1[1] >= c and p1[1] <= d and p2[0] >= a and p2[0] <= b and p2[1] >= c and p2[1] <= d and p3[0] >= a and p3[0] <= b and p3[1] >= c and p3[1] <= d and p4[0] >= a and p4[0] <= b and p4[1] >= c and p4[1] <= d\n\n    def is_inside_segment(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return p1[0] >= a and p1[0] <= b and p1[1] >= c and p1[1] <= d and p2[0] >= a and p2[0] <= b and p2[1] >= c and p2[1] <= d\n\n    def is_inside_line(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return p1[0] >= a and p1[0] <= b and p1[1] >= c and p1[1] <= d and p2[0] >= a and p2[0] <= b and p2[1] >= c and p2[1] <= d and p3[0] >= a and p3[0] <= b and p3[1] >= c and p3[1] <= d and p4[0] >= a and p4[0] <= b and p4[1] >= c and p4[1] <= d\n\n    def is_inside_point(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return p1[0] >= a and p1[0] <= b and p1[1] >= c and p1[1] <= d and p2[0] >= a and p2[0] <= b and p2[1] >= c and p2[1] <= d and p3[0] >= a and p3[0] <= b and p3[1] >= c and p3[1] <= d and p4[0] >= a and p4[0] <= b and p4[1] >= c and p4[1] <= d\n\n    def is_inside_segment_or_line(p1: tuple, p2: tuple, p3: tuple, p4: tuple) -> bool:\n        return p1[0] >= a and p1[0] <= b and p1[1] >= c and p1[1] <= d and p2[0] >= a and p2[0] <= b and p2[1] >= c and p2[1] <= d and p3[0] >= a and p3[0] <= b and p3[1] >= c and p3[1]"
    },
    {
        "number": 118,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s, x = map(int, stdin.split())\n    if x % s == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 119,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[i+1].split())\n        segments.append((l, r))\n    segments.sort(key=lambda x: (x[0], x[1]))\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if segments[i][1] >= segments[j][0]:\n                print(i+1, j+1)\n                return\n    print(-1, -1)\n    return"
    },
    {
        "number": 120,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    # Replace unrecognized nucleotides with the four types\n    s = s.replace('?', 'A')\n    s = s.replace('?', 'C')\n    s = s.replace('?', 'G')\n    s = s.replace('?', 'T')\n\n    # Count the number of each type\n    count_A = s.count('A')\n    count_C = s.count('C')\n    count_G = s.count('G')\n    count_T = s.count('T')\n\n    # Check if the number of each type is equal\n    if count_A == count_C == count_G == count_T:\n        return s\n    else:\n        return '==='"
    },
    {
        "number": 121,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(row) for row in stdin.split('\\n')]\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == '.':\n                return 'NO'\n    for i in range(4):\n        if board[i][0] == board[i][1] == board[i][2]!= '.':\n            return 'YES'\n        if board[0][i] == board[1][i] == board[2][i]!= '.':\n            return 'YES'\n    if board[0][0] == board[1][1] == board[2][2]!= '.':\n        return 'YES'\n    if board[0][2] == board[1][1] == board[2][0]!= '.':\n        return 'YES'\n    return 'NO'"
    },
    {
        "number": 122,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def can_divide(a: list, target: int) -> bool:\n        prefix_sum = 0\n        suffix_sum = 0\n        for i in range(len(a)):\n            prefix_sum += a[i]\n            if prefix_sum == target:\n                return True\n            if prefix_sum > target:\n                return False\n            if i < len(a) - 1:\n                suffix_sum += a[i + 1]\n                if suffix_sum == target:\n                    return True\n                if suffix_sum > target:\n                    return False\n        return False\n\n    for i in range(n):\n        if can_divide(a, a[i]):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 123,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Check if the sequence is increasing\n    if a!= sorted(a):\n        return \"No\"\n\n    # Replace zeros with elements from b\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b.pop(0)\n\n    # Check if the resulting sequence is increasing\n    if a!= sorted(a):\n        return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 124,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    a, b, c = map(int, stdin.split())\n\n    green_grapes = a\n    purple_grapes = b\n    black_grapes = c\n\n    if green_grapes >= x and purple_grapes >= y and black_grapes >= z:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 125,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    parts = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    left, straight, right, pedestrian = parts\n\n    # Check if there is a green light in the pedestrian crossing\n    if pedestrian[0] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the left part\n    if left[0] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the straight part\n    if straight[0] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the right part\n    if right[0] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the pedestrian crossing\n    if pedestrian[1] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the left part\n    if left[1] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the straight part\n    if straight[1] == 1:\n        return \"NO\"\n\n    # Check if there is a green light in the right part\n    if right[1] == 1:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 126,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    number = int(stdin.split()[1])\n\n    finger_movements = []\n    for i in range(n):\n        finger_movements.append(int(number % 10))\n        number //= 10\n\n    finger_movements.sort()\n\n    for i in range(1, len(finger_movements)):\n        if finger_movements[i]!= finger_movements[i - 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 127,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f = map(int, stdin.split())\n    days = []\n    for _ in range(n):\n        k, l = map(int, input().split())\n        days.append((k, l))\n\n    days.sort(key=lambda x: (-x[0], -x[1]))\n\n    total_sold = 0\n    for k, l in days:\n        total_sold += 2 * k\n        if total_sold >= f:\n            break\n\n    return str(total_sold)"
    },
    {
        "number": 128,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cows = list(map(int, stdin.split()))\n    cows.sort()\n    max_messiness = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if cows[i] > cows[j]:\n                max_messiness += 1\n                if max_messiness >= k:\n                    return str(max_messiness)\n    return str(max_messiness)"
    },
    {
        "number": 129,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, L = map(int, stdin.split())\n    coins = set(map(int, stdin.split()))\n    if len(coins) < L:\n        return \"-1\"\n\n    def is_valid(coins):\n        return len(coins) >= L and len(set(coins)) == N\n\n    def find_min_coins(coins):\n        for i in range(1, N + 1):\n            if i <= K:\n                continue\n            for j in range(1, i + 1):\n                if j <= K:\n                    continue\n                for k in range(1, j + 1):\n                    if k <= K:\n                        continue\n                    for l in range(1, k + 1):\n                        if l <= K:\n                            continue\n                        for m in range(1, l + 1):\n                            if m <= K:\n                                continue\n                            for n in range(1, m + 1):\n                                if n <= K:\n                                    continue\n                                for o in range(1, n + 1):\n                                    if o <= K:\n                                        continue\n                                    for p in range(1, o + 1):\n                                        if p <= K:\n                                            continue\n                                        for q in range(1, p + 1):\n                                            if q <= K:\n                                                continue\n                                            for r in range(1, q + 1):\n                                                if r <= K:\n                                                    continue\n                                                for s in range(1, r + 1):\n                                                    if s <= K:\n                                                        continue\n                                                    for t in range(1, s + 1):\n                                                        if t <= K:\n                                                            continue\n                                                        for u in range(1, t + 1):\n                                                            if u <= K:\n                                                                continue\n                                                            for v in range(1, u + 1):\n                                                                if v <= K:\n                                                                    continue\n                                                                for w in range(1, v + 1):\n                                                                    if w <= K:\n                                                                        continue\n                                                                    for x in range(1, w + 1):\n                                                                        if x <= K:\n                                                                            continue\n                                                                        for y in range(1, x + 1):\n                                                                            if y <= K:\n                                                                                continue\n                                                                            for z in range(1, y + 1):\n                                                                                if z <= K:\n                                                                                    continue\n                                                                                if is_valid({i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z}):\n                                                                                    return 1\n        return 0\n\n    return str(find_min_coins(coins))"
    },
    {
        "number": 130,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = [list(row) for row in stdin.split('\\n')[1:]]\n\n    def is_black_square(colors: list) -> bool:\n        for i in range(n):\n            for j in range(m):\n                if colors[i][j] == 'B' and (i == 0 or j == 0 or i == n - 1 or j == m - 1):\n                    return False\n        return True\n\n    def count_black_cells(colors: list) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if colors[i][j] == 'B':\n                    count += 1\n        return count\n\n    def count_white_cells(colors: list) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if colors[i][j] == 'W':\n                    count += 1\n        return count\n\n    def count_black_squares(colors: list) -> int:\n        count = 0\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if colors[i][j] == 'B' and colors[i][j + 1] == 'B' and colors[i + 1][j] == 'B' and colors[i + 1][j + 1] == 'B':\n                    count += 1\n        return count\n\n    black_squares = count_black_squares(colors)\n    if black_squares == 0:\n        return -1\n\n    black_cells = count_black_cells(colors)\n    white_cells = count_white_cells(colors)\n\n    if black_cells == 0:\n        return 0\n\n    if black_cells == 1:\n        return 1\n\n    if black_cells == 2:\n        return 2\n\n    if black_cells == 3:\n        return 3\n\n    if black_cells == 4:\n        return 4\n\n    if black_cells == 5:\n        return 5\n\n    if black_cells == 6:\n        return 6\n\n    if black_cells == 7:\n        return 7\n\n    if black_cells == 8:\n        return 8\n\n    if black_cells == 9:\n        return 9\n\n    if black_cells == 10:\n        return 10\n\n    if black_cells == 11:\n        return 11\n\n    if black_cells == 12:\n        return 12\n\n    if black_cells == 13:\n        return 13\n\n    if black_cells == 14:\n        return 14\n\n    if black_cells == 15:\n        return 15\n\n    if black_cells == 16:\n        return 16\n\n    if black_cells == 17:\n        return 17\n\n    if black_cells == 18:\n        return 18\n\n    if black_cells == 19:\n        return 19\n\n    if black_cells == 20:\n        return 20\n\n    if black_cells == 21:\n        return 21\n\n    if black_cells == 22:\n        return 22\n\n    if black_cells == 23:\n        return 23\n\n    if black_cells == 24:\n        return 24\n\n    if black_cells == 25:\n        return 25\n\n    if black_cells == 26:\n        return 26\n\n    if black_cells == 27:\n        return 27\n\n    if black_cells == 28:\n        return 28\n\n    if black_cells == 29:\n        return 29\n\n    if black_cells == 30:\n        return 30\n\n    if black_cells == 31:\n        return 31\n\n    if black_cells == 32:\n        return 32\n\n    if black_cells == 33:\n        return 33\n\n    if black_cells == 34:\n        return 34\n\n    if black_cells == 35:\n        return 35\n\n    if black_cells == 36:\n        return 36\n\n    if black_cells == 37:\n        return 37\n\n    if black_cells == 38:\n        return 38\n\n    if black_cells == 39:\n        return 39\n\n    if black_cells == 40:\n        return 40\n\n    if black_cells == 41:\n        return 41\n\n    if black_cells == 42:\n        return 42\n\n    if black_cells == 43:\n        return 43\n\n    if black_cells =="
    },
    {
        "number": 131,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n\n    if x1 == y1 and x2 == y2:\n        return \"Yes\"\n    elif x1 == y2 and x2 == y1:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 132,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    min_diff = 360 - a[0] - a[-1]\n    for i in range(1, n - 1):\n        min_diff = min(min_diff, a[i] - a[i - 1] - a[i + 1])\n    return str(min_diff)"
    },
    {
        "number": 133,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % MOD\n\n    return str(dp[n][m])"
    },
    {
        "number": 134,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    for m in range(1, n + 1):\n        for k in range(1, n + 1):\n            if m * m + k * k == n * n:\n                return str(m) + \" \" + str(k)\n    return \"-1\""
    },
    {
        "number": 135,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    remainders = set()\n    for i in range(1, k+1):\n        remainders.add(n % i)\n    if len(remainders) == k:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 136,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a < b:\n        return \"<\"\n    elif a > b:\n        return \">\"\n    else:\n        return \"=\""
    },
    {
        "number": 137,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def count_ways(start: int, end: int, color: int, arrows: int, score: int) -> int:\n        if start == end:\n            return 1 if color == 0 else 0\n        if arrows == 0:\n            return 0\n        if color == 0:\n            return count_ways(start + 1, end, 1, arrows - 1, score + 1) + count_ways(start, end, 0, arrows - 1, score)\n        else:\n            return count_ways(start + 1, end, 0, arrows - 1, score + 1) + count_ways(start, end, 1, arrows - 1, score)\n\n    def count_ways_mod(start: int, end: int, color: int, arrows: int, score: int) -> int:\n        return (count_ways(start, end, color, arrows, score) + 1) % (10**9 + 7)\n\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ways = (ways + count_ways_mod(i, j, c[i], n - 1, 0)) % (10**9 + 7)\n\n    return str(ways)"
    },
    {
        "number": 138,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    if n % 4 == 0:\n        return \"0\"\n    if n + a * 3 + b * 2 + c * 1 >= 4:\n        return \"0\"\n    return str(min(a * 3, b * 2, c * 1))"
    },
    {
        "number": 139,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    visited = [False] * (n + 1)\n    stack = []\n\n    def dfs(u):\n        visited[u] = True\n        for v in edges[u]:\n            if not visited[v]:\n                dfs(v)\n            elif v not in stack:\n                stack.append(v)\n\n    for u in range(1, n + 1):\n        if not visited[u]:\n            dfs(u)\n            if len(stack) == 1:\n                return \"YES\"\n            else:\n                stack.pop()\n\n    return \"NO\"\n"
    },
    {
        "number": 140,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    antennas = [[] for _ in range(n + 1)]\n    for i in range(n):\n        x, s = map(int, stdin.split())\n        antennas[x].append(s)\n\n    def dfs(x, s, used):\n        if x > m:\n            return 0\n\n        if x in used:\n            return 0\n\n        used.add(x)\n        min_cost = float('inf')\n        for s2 in antennas[x]:\n            cost = dfs(x + s2, s + s2, used)\n            min_cost = min(min_cost, cost)\n        used.remove(x)\n        return min_cost + 1\n\n    return str(dfs(1, 0, set()))"
    },
    {
        "number": 141,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, *items = map(int, stdin.split())\n    items = sorted(items)\n    max_weight = 0\n    for i in range(len(items)):\n        if items[i] > max_weight:\n            max_weight = items[i]\n        if max_weight > W:\n            break\n    return str(max_weight)"
    },
    {
        "number": 142,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def binary_search(start, end):\n        while start <= end:\n            mid = (start + end) // 2\n            if sum(c[i] * 2 ** i for i in range(n)) >= L:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return start\n\n    return str(binary_search(0, 10**9))"
    },
    {
        "number": 143,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = a.copy()\n    for i in range(n):\n        if b[i] > a[i]:\n            b[i] -= 1\n        else:\n            b[i] = a[i]\n    return str(max(b))"
    },
    {
        "number": 144,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ticket = list(map(int, stdin.split()[1]))\n\n    def is_lucky(ticket: list) -> bool:\n        segments = {}\n        for i in range(len(ticket)):\n            if ticket[i] not in segments:\n                segments[ticket[i]] = [i]\n            else:\n                segments[ticket[i]].append(i)\n\n        for segment in segments.values():\n            if len(segment) > 1:\n                return True\n\n        return False\n\n    if is_lucky(ticket):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 145,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    name = stdin.lower()\n    distinct_chars = len(set(name))\n    if distinct_chars % 2 == 1:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\""
    },
    {
        "number": 146,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tab_types = list(map(int, stdin.split()))\n\n    e = 0\n    s = 0\n\n    for i in range(n):\n        if tab_types[i] == 1:\n            e += 1\n        else:\n            s += 1\n\n    max_diff = abs(e - s)\n\n    for i in range(1, n - 1):\n        if i % k == 0:\n            if tab_types[i] == 1:\n                e -= 1\n            else:\n                s -= 1\n\n            max_diff = max(max_diff, abs(e - s))\n\n    return str(max_diff)"
    },
    {
        "number": 147,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_0, c_1 = map(int, stdin.split())\n    alphabet = \"0011\"\n    total_cost = 0\n    for i in range(n):\n        for j in range(2):\n            if alphabet[i] == \"0\":\n                total_cost += c_0\n            else:\n                total_cost += c_1\n    return str(total_cost)"
    },
    {
        "number": 148,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, x, b, y = map(int, stdin.split())\n    if a == x and b == y:\n        return \"YES\"\n    elif a == x or b == y:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 149,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, l, r = map(int, stdin.split())\n    \n    # check if all years are unlucky\n    if x**0 + y**1 in range(l, r+1) and x**3 + y**2 in range(l, r+1):\n        return \"0\"\n    \n    # find maximum length of The Golden Age\n    max_length = 0\n    for i in range(l, r+1):\n        if i % x == 0 and i % y == 0:\n            max_length = max(max_length, i // x + i // y)\n    \n    return str(max_length)"
    },
    {
        "number": 150,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 2:\n        return \"0\"\n    max_divisor = 1\n    for i in range(2, n + 1):\n        if n % i == 0:\n            max_divisor = i\n    return str(max_divisor)"
    },
    {
        "number": 151,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    word = stdin.lower()\n    result = []\n    for i in range(len(word)):\n        if word[i] in vowels:\n            result.append(word[i])\n        else:\n            if i == 0 or word[i - 1] in vowels:\n                result.append(word[i])\n            else:\n                result.append(' ')\n    return ''.join(result)"
    },
    {
        "number": 152,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    x, s = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n\n    def prepare_potion(potion_cost: int, seconds: int) -> int:\n        return (potion_cost + seconds - 1) // seconds\n\n    def prepare_potions(spell_cost: int, potions: int) -> int:\n        return (spell_cost + potions - 1) // potions\n\n    def prepare_time(spell_cost: int, potions: int, seconds: int) -> int:\n        return prepare_potion(spell_cost, seconds) + prepare_potions(spell_cost, potions)\n\n    def min_time(potions: int) -> int:\n        return prepare_time(a[0], c[0], x) + prepare_time(b[0], c[0], x) + prepare_time(d[0], c[0], x) + prepare_time(a[1], c[1], x) + prepare_time(b[1], c[1], x) + prepare_time(d[1], c[1], x)\n\n    return str(min_time(n))"
    },
    {
        "number": 153,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n\n    points = 0\n    for i in range(n):\n        solved = 0\n        for j in range(k):\n            if t[j] <= M:\n                solved += 1\n        points += solved + 1\n\n    return str(points)"
    },
    {
        "number": 154,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 998244353\n\n    def is_balanced(root: TreeNode) -> bool:\n        if not root:\n            return True\n\n        left_height = get_height(root.left)\n        right_height = get_height(root.right)\n\n        if abs(left_height - right_height) > 1:\n            return False\n\n        return is_balanced(root.left) and is_balanced(root.right)\n\n    def get_height(root: TreeNode) -> int:\n        if not root:\n            return 0\n\n        left_height = get_height(root.left)\n        right_height = get_height(root.right)\n\n        return max(left_height, right_height) + 1\n\n    def is_striped(root: TreeNode) -> bool:\n        if not root:\n            return True\n\n        left_parity = get_parity(root.left)\n        right_parity = get_parity(root.right)\n\n        if left_parity!= right_parity:\n            return False\n\n        return is_striped(root.left) and is_striped(root.right)\n\n    def get_parity(root: TreeNode) -> int:\n        if not root:\n            return 0\n\n        return get_parity(root.left) ^ get_parity(root.right)\n\n    def count_balanced_striped_trees(n: int) -> int:\n        count = 0\n\n        for i in range(1, n + 1):\n            root = TreeNode(i)\n            if is_balanced(root) and is_striped(root):\n                count += 1\n\n        return count % MOD\n\n    return str(count_balanced_striped_trees(n))\n\n\nclass TreeNode:\n    def __init__(self, key: int) -> None:\n        self.key = key\n        self.left = None\n        self.right = None\n"
    },
    {
        "number": 155,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    visited = [[False] * m for _ in range(n)]\n    row, col = 1, 1\n    for _ in range(k):\n        if not visited[row - 1][col]:\n            row -= 1\n        elif not visited[row][col - 1]:\n            col -= 1\n        else:\n            row += 1\n            col += 1\n    return str(row) + \" \" + str(col)"
    },
    {
        "number": 156,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    a = 1\n    b = 1\n    while True:\n        if LCM(a, b) == X:\n            return str(a) + \" \" + str(b)\n        if LCM(a, b) > X:\n            return str(a) + \" \" + str(b)\n        a += 1\n        b += 1\n\ndef"
    },
    {
        "number": 157,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lemons, apples, pears = map(int, stdin.split())\n    max_lemons = max(lemons, apples, pears)\n    max_apples = max(lemons, apples, pears)\n    max_pears = max(lemons, apples, pears)\n\n    if max_lemons == lemons:\n        max_apples -= lemons\n        max_pears -= lemons\n    elif max_apples == apples:\n        max_lemons -= apples\n        max_pears -= apples\n    else:\n        max_lemons -= pears\n        max_apples -= pears\n\n    return str(max_lemons + max_apples + max_pears)"
    },
    {
        "number": 158,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    a.sort(reverse=True)\n    a.sort()\n\n    for i in range(n):\n        if a[i]!= a[i + n]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 159,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    def make_coprime(a):\n        i = 1\n        while True:\n            if is_coprime(a, i):\n                return a + i\n            i += 1\n\n    def make_coprime_array(a):\n        i = 1\n        while True:\n            if is_coprime(a, i):\n                a = a + i\n            else:\n                i += 1\n            if i > 10**9:\n                return a\n\n    a = make_coprime_array(a)\n    k = len(a) - n\n\n    return f\"{k}\\n{a}\"\n"
    },
    {
        "number": 160,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.append(0)\n\n    def max_divisor(a: list[int]) -> int:\n        max_div = 1\n        for i in range(1, n):\n            if a[i] > 0:\n                a[i] += 1\n                max_div = max(max_div, max_divisor(a))\n                a[i] -= 1\n        return max_div\n\n    max_div = max_divisor(a)\n    for _ in range(k):\n        max_div = max(max_div, max_divisor(a))\n\n    return str(max_div)"
    },
    {
        "number": 161,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    t = 0\n    n = 0\n    while x!= 1:\n        if x % 2 == 0:\n            x = x + 1\n            t += 1\n        else:\n            x = x ^ (2 ** n - 1)\n            t += 2\n            n += 1\n    return str(t)"
    },
    {
        "number": 162,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def can_water(i: int, start: int, end: int) -> bool:\n        return start >= 0 and end <= k and a[i] <= end - start\n\n    def min_hours(i: int, start: int, end: int) -> int:\n        if i == n:\n            return 0\n\n        if can_water(i, start, end):\n            return 1 + min_hours(i + 1, start + a[i], end)\n        else:\n            return min_hours(i + 1, start, end)\n\n    return str(min_hours(0, 0, k))\n"
    },
    {
        "number": 163,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    line = list(stdin.split()[1])\n    obstacles = [i for i, c in enumerate(line) if c == '#']\n    target = [i for i, c in enumerate(line) if c == 'T']\n\n    def can_jump(i: int, j: int) -> bool:\n        if i == j:\n            return True\n        if i in obstacles:\n            return False\n        if j in obstacles:\n            return False\n        return can_jump(i + 1, j) or can_jump(i - 1, j)\n\n    def can_reach_target(i: int) -> bool:\n        return can_jump(i, target[0])\n\n    for i in range(n):\n        if can_reach_target(i):\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 164,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y1, y2, yw, xb, yb, r = map(int, stdin.split())\n\n    if y1 >= y2 or y1 >= yw or y2 >= yw or yb + r >= yw or 2 * r >= y2 - y1:\n        return \"-1\"\n\n    def is_goal(y: int) -> bool:\n        return y >= y1 and y <= y2\n\n    def is_hit(y: int) -> bool:\n        return y >= yb and y <= yb + r\n\n    def is_hit_goal(y: int) -> bool:\n        return y >= yb and y <= yb + r and is_goal(y)\n\n    def is_hit_goal_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and is_goal(y)\n\n    def is_hit_goal_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner_corner_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner_corner_corner_post(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def is_hit_corner_goal_corner_corner_corner_corner_corner_corner_corner(y: int) -> bool:\n        return y >= yb and y <= yb + r and y == y1 or y == y2\n\n    def"
    },
    {
        "number": 165,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d, s = map(int, stdin.split())\n    if b + d + s >= 1:\n        return \"0\"\n    if b + d + s == 0:\n        return \"1\"\n    if b + d + s == 1:\n        return \"2\"\n    if b + d + s == 2:\n        return \"3\"\n    if b + d + s == 3:\n        return \"4\"\n    if b + d + s == 4:\n        return \"5\"\n    if b + d + s == 5:\n        return \"6\"\n    if b + d + s == 6:\n        return \"7\"\n    if b + d + s == 7:\n        return \"8\"\n    if b + d + s == 8:\n        return \"9\"\n    if b + d + s == 9:\n        return \"10\"\n    if b + d + s == 10:\n        return \"11\"\n    if b + d + s == 11:\n        return \"12\"\n    if b + d + s == 12:\n        return \"13\"\n    if b + d + s == 13:\n        return \"14\"\n    if b + d + s == 14:\n        return \"15\"\n    if b + d + s == 15:\n        return \"16\"\n    if b + d + s == 16:\n        return \"17\"\n    if b + d + s == 17:\n        return \"18\"\n    if b + d + s == 18:\n        return \"19\"\n    if b + d + s == 19:\n        return \"20\"\n    if b + d + s == 20:\n        return \"21\"\n    if b + d + s == 21:\n        return \"22\"\n    if b + d + s == 22:\n        return \"23\"\n    if b + d + s == 23:\n        return \"24\"\n    if b + d + s == 24:\n        return \"25\"\n    if b + d + s == 25:\n        return \"26\"\n    if b + d + s == 26:\n        return \"27\"\n    if b + d + s == 27:\n        return \"28\"\n    if b + d + s == 28:\n        return \"29\"\n    if b + d + s == 29:\n        return \"30\"\n    if b + d + s == 30:\n        return \"31\"\n    if b + d + s == 31:\n        return \"32\"\n    if b + d + s == 32:\n        return \"33\"\n    if b + d + s == 33:\n        return \"34\"\n    if b + d + s == 34:\n        return \"35\"\n    if b + d + s == 35:\n        return \"36\"\n    if b + d + s == 36:\n        return \"37\"\n    if b + d + s == 37:\n        return \"38\"\n    if b + d + s == 38:\n        return \"39\"\n    if b + d + s == 39:\n        return \"40\"\n    if b + d + s == 40:\n        return \"41\"\n    if b + d + s == 41:\n        return \"42\"\n    if b + d + s == 42:\n        return \"43\"\n    if b + d + s == 43:\n        return \"44\"\n    if b + d + s == 44:\n        return \"45\"\n    if b + d + s == 45:\n        return \"46\"\n    if b + d + s == 46:\n        return \"47\"\n    if b + d + s == 47:\n        return \"48\"\n    if b + d + s == 48:\n        return \"49\"\n    if b + d + s == 49:\n        return \"50\"\n    if b + d + s == 50:\n        return \"51\"\n    if b + d + s == 51:\n        return \"52\"\n    if b + d + s == 52:\n        return \"53\"\n    if b + d + s == 53:\n        return \"54\"\n    if b + d + s == 54:\n        return \"55\"\n    if b + d + s == 55:\n        return \"56\"\n    if b +"
    },
    {
        "number": 166,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    if len(a)!= n:\n        return \"NO\"\n\n    x, y = 1, 1\n    for i in range(1, n):\n        if a[i] == a[i - 1] + 1:\n            x += 1\n        else:\n            break\n    for j in range(1, n):\n        if a[j] == a[j - 1] + 1:\n            y += 1\n        else:\n            break\n\n    if x > 10**9 or y > 10**9:\n        return \"NO\"\n\n    return \"YES\\n\" + str(x) + \" \" + str(y)\n"
    },
    {
        "number": 167,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split('\\n')\n    a = list(a)\n    b = list(b)\n\n    i = 0\n    j = 0\n    while j < len(b):\n        if b[j] == a[i]:\n            i += 1\n        else:\n            i = 0\n        j += 1\n\n    if i == len(a):\n        return ''\n    else:\n        return ''.join(a[i:])"
    },
    {
        "number": 168,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    stones = 0\n    for i in range(n):\n        if s[i] == '-':\n            stones -= 1\n        else:\n            stones += 1\n    return str(stones)"
    },
    {
        "number": 169,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n    if a > c:\n        a, c = c, a\n    if b > c:\n        b, c = c, b\n    if a > b:\n        a, b = b, a\n    if a > n:\n        a = n\n    if b > n:\n        b = n\n    if c > n:\n        c = n\n    return str(a // b)"
    },
    {
        "number": 170,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k_1, k_2 = map(int, stdin.split())\n    if k_1 + k_2!= n:\n        return -1\n\n    def get_cards(k, values):\n        return [values.pop(0) for _ in range(k)]\n\n    def play_fight(cards1, cards2):\n        while cards1 and cards2:\n            card1 = cards1.pop()\n            card2 = cards2.pop()\n            if card1 > card2:\n                cards1.append(card1)\n                cards1.append(card2)\n            else:\n                cards2.append(card2)\n                cards2.append(card1)\n        return cards1, cards2\n\n    def calculate_fights(cards1, cards2):\n        fights = 0\n        while cards1 or cards2:\n            fights += 1\n            cards1, cards2 = play_fight(cards1, cards2)\n        return fights\n\n    cards1 = get_cards(k_1, list(map(int, stdin.split()[2:])))\n    cards2 = get_cards(k_2, list(map(int, stdin.split()[2+k_1:])))\n\n    fights = calculate_fights(cards1, cards2)\n    if fights == 0:\n        return -1\n\n    return f\"{fights} {1 if cards1 else 2}\""
    },
    {
        "number": 171,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Define the required conditions\n    required_conditions = [\n        lambda x: len(x) >= 5,\n        lambda x: any(c.isupper() for c in x),\n        lambda x: any(c.islower() for c in x),\n        lambda x: any(c.isdigit() for c in x),\n    ]\n\n    # Check if the password meets all the conditions\n    for condition in required_conditions:\n        if not condition(stdin):\n            return \"Too weak\"\n\n    # If all the conditions are met, print \"Correct\"\n    return \"Correct\""
    },
    {
        "number": 172,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    a_count = [0] * 5\n    b_count = [0] * 5\n\n    for i in range(n):\n        a_count[a[i] - 1] += 1\n        b_count[b[i] - 1] += 1\n\n    for i in range(5):\n        if a_count[i]!= b_count[i]:\n            return -1\n\n    return min(a_count.count(1), b_count.count(1))"
    },
    {
        "number": 173,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    street_directions = [list(line) for line in stdin.split()[1:]]\n\n    def is_valid_direction(direction: str) -> bool:\n        return direction in ['<', '>', '^', 'v']\n\n    def is_valid_street(street_direction: str) -> bool:\n        return is_valid_direction(street_direction[0]) and is_valid_direction(street_direction[1])\n\n    def is_valid_street_pattern(street_directions: List[List[str]]) -> bool:\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if street_directions[i][j]!= street_directions[i + 1][j] or street_directions[i][j]!= street_directions[i][j + 1]:\n                    return False\n        return True\n\n    if not is_valid_street_pattern(street_directions):\n        return \"NO\"\n\n    def is_valid_junction(i: int, j: int) -> bool:\n        if i == 0 or j == 0 or i == n - 1 or j == m - 1:\n            return True\n        return street_directions[i][j] == street_directions[i - 1][j] or street_directions[i][j] == street_directions[i][j - 1]\n\n    def is_valid_path(i: int, j: int) -> bool:\n        if i == 0 or j == 0 or i == n - 1 or j == m - 1:\n            return True\n        return street_directions[i][j] == street_directions[i - 1][j] or street_directions[i][j] == street_directions[i][j - 1] or street_directions[i][j] == street_directions[i + 1][j] or street_directions[i][j] == street_directions[i][j + 1]\n\n    def is_valid_path_from_to(i: int, j: int, k: int, l: int) -> bool:\n        if i == k or j == l or i == n - 1 or j == m - 1:\n            return True\n        return street_directions[i][j] == street_directions[k][l]\n\n    def dfs(i: int, j: int, visited: Set[Tuple[int, int]]) -> bool:\n        if (i, j) in visited:\n            return False\n        visited.add((i, j))\n\n        if is_valid_junction(i, j):\n            return True\n\n        for k in range(i + 1, n):\n            if is_valid_path_from_to(i, j, k, j):\n                if dfs(k, j, visited):\n                    return True\n        for k in range(j + 1, m):\n            if is_valid_path_from_to(i, j, i, k):\n                if dfs(i, k, visited):\n                    return True\n        for k in range(i - 1, -1, -1):\n            if is_valid_path_from_to(i, j, k, j):\n                if dfs(k, j, visited):\n                    return True\n        for k in range(j - 1, -1, -1):\n            if is_valid_path_from_to(i, j, i, k):\n                if dfs(i, k, visited):\n                    return True\n\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if is_valid_path(i, j):\n                if dfs(i, j, set()):\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 174,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    args = list(map(int, stdin.split()[1:]))\n\n    def is_implication(a, b):\n        return a == 1 and b == 0\n\n    def is_valid(expression):\n        stack = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n            elif char == '>' and stack and stack[-1] == '(':\n                stack.pop()\n            elif char == '>' and not stack:\n                return False\n            elif char == '>' and stack and stack[-1]!= '(':\n                return False\n        return not stack\n\n    def find_brackets(expression):\n        stack = []\n        result = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return None\n                stack.pop()\n            elif char == '>' and stack and stack[-1] == '(':\n                stack.pop()\n                result.append(')')\n            elif char == '>' and not stack:\n                return None\n            elif char == '>' and stack and stack[-1]!= '(':\n                return None\n            else:\n                result.append(char)\n        return ''.join(result)\n\n    def is_valid_expression(expression):\n        if not is_valid(expression):\n            return False\n        if not is_implication(args[0], args[1]):\n            return False\n        for i in range(2, n):\n            if not is_implication(args[i], args[i - 1]):\n                return False\n        return True\n\n    def find_expression(args):\n        if not is_valid_expression(args):\n            return None\n        expression = ''\n        for i in range(n):\n            expression += str(args[i])\n            if i < n - 1:\n                expression += '>'\n        return expression\n\n    def find_valid_expression(args):\n        for i in range(1, 2 ** n):\n            expression = ''\n            for j in range(n):\n                if (i >> j) & 1:\n                    expression += str(args[j])\n            if is_valid_expression(expression):\n                return expression\n        return None\n\n    def find_valid_brackets(args):\n        for i in range(1, 2 ** n):\n            expression = ''\n            for j in range(n):\n                if (i >> j) & 1:\n                    expression += str(args[j])\n            brackets = find_brackets(expression)\n            if brackets is not None and is_valid_expression(brackets):\n                return brackets\n        return None\n\n    valid_expression = find_valid_expression(args)\n    if valid_expression is not None:\n        return f\"YES\\n{valid_expression}\"\n\n    valid_brackets = find_valid_brackets(args)\n    if valid_brackets is not None:\n        return f\"YES\\n{valid_brackets}\"\n\n    return \"NO\"\n"
    },
    {
        "number": 175,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = n, m\n    while True:\n        if a == 0 or b == 0:\n            break\n        if a >= 2 * b:\n            a -= 2 * b\n        else:\n            b -= 2 * a\n    return f\"{a} {b}\""
    },
    {
        "number": 176,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    count = 0\n    for i in range(a, b + 1):\n        if i % k == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 177,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    sequence = \"123456789101112131415161718192021222324252627282930313233343536\"\n    return sequence[k - 1]"
    },
    {
        "number": 178,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_telephone_number(s: str) -> bool:\n        return s[0] == '8' and all(s[i]!= '8' for i in range(1, len(s), 2))\n\n    if is_telephone_number(s):\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 179,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, pos = map(int, stdin.split())\n    a = list(range(1, n + 1))\n    a.sort()\n    count = 0\n    for i in range(len(a)):\n        if a[i] == x:\n            count += 1\n            if i == pos:\n                return str(count % (10**9 + 7))\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 180,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def remove_candy_cones(s: str) -> str:\n        result = \"\"\n        for i, c in enumerate(s):\n            if c == \"c\":\n                if i > 0 and s[i - 1] == \"c\":\n                    result += \"c\"\n                else:\n                    result += \" \"\n            elif c == \"s\":\n                if i > 0 and s[i - 1] == \"s\":\n                    result += \"s\"\n                else:\n                    result += \"*\"\n            else:\n                result += c\n        return result\n\n    def encode_message(s: str) -> str:\n        result = \"\"\n        for i, c in enumerate(s):\n            if c == \"c\":\n                if i > 0 and s[i - 1] == \"c\":\n                    result += \"c\"\n                else:\n                    result += \" \"\n            elif c == \"s\":\n                if i > 0 and s[i - 1] == \"s\":\n                    result += \"s\"\n                else:\n                    result += \"*\"\n            else:\n                result += c\n        return result\n\n    received_string = stdin.strip()\n    k = int(stdin.split()[1])\n\n    if k > len(received_string):\n        return \"Impossible\"\n\n    encoded_message = encode_message(received_string)\n    encoded_message = remove_candy_cones(encoded_message)\n\n    if len(encoded_message) == k:\n        return encoded_message\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 181,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    angle = int(stdin)\n    turns = 0\n    while angle > 0:\n        turns += angle // 90\n        angle %= 90\n    return str(turns)"
    },
    {
        "number": 182,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    blue, violet, orange = map(int, stdin.split())\n    x, y, z = map(int, stdin.split())\n\n    if blue >= x and violet >= y and orange >= z:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 183,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    x = 1\n    while True:\n        if x > 0:\n            x = x * 10\n        else:\n            break\n    for i in range(1, 10**n):\n        if x % k == 0:\n            y = x // k\n            if str(y)[-n:] == str(i)[-n:]:\n                print(x % m)\n                return"
    },
    {
        "number": 184,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, a = map(int, stdin.split())\n    max_players = l + r + a\n    if max_players % 2 == 0:\n        return str(max_players)\n    else:\n        return str(max_players + 1)"
    },
    {
        "number": 185,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    moves = 0\n    visited = set()\n    queue = [(k, 0)]\n    while queue:\n        pos, level = queue.pop(0)\n        if pos == 1 and level == 0:\n            moves += 1\n            visited.add(pos)\n        if pos > 1 and pos - 1 not in visited:\n            queue.append((pos - 1, level + 1))\n        if pos < n and pos + 1 not in visited:\n            queue.append((pos + 1, level + 1))\n    return str(moves)"
    },
    {
        "number": 186,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n > m:\n        n, m = m, n\n\n    tower_heights = [0] * (n + m)\n    tower_heights[0] = 1\n\n    for i in range(1, n + m):\n        tower_heights[i] = tower_heights[i - 1] + 1\n\n    min_height = min(tower_heights)\n    return str(min_height)"
    },
    {
        "number": 187,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = [int(x) for x in stdin.split()[1:]]\n    cards.sort()\n    if len(cards) % 2 == 0:\n        return \"NO\"\n    else:\n        for i in range(len(cards) // 2):\n            if cards[i] == cards[len(cards) // 2]:\n                return \"NO\"\n        return \"YES\", str(cards[len(cards) // 2]), str(cards[len(cards) // 2 + 1])"
    },
    {
        "number": 188,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    groups = [[] for _ in range(k)]\n    for i in range(k):\n        groups[i] = a[i:i+a[i]]\n    for i in range(k):\n        for j in range(i+1, k):\n            if any(groups[i].count(x) > 1 for x in groups[j]) or any(groups[j].count(x) > 1 for x in groups[i]):\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 189,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def almost_good(a: int, t: int) -> bool:\n        return abs(a - t) <= 1\n\n    def min_cost(a: List[int], t: int) -> int:\n        return sum(abs(a[i] - t) for i in range(n))\n\n    def min_t(a: List[int]) -> int:\n        return min(a)\n\n    def min_cost_t(a: List[int]) -> Tuple[int, int]:\n        t = min_t(a)\n        return t, min_cost(a, t)\n\n    a_sorted = sorted(a)\n    min_cost_t_sorted = sorted(min_cost_t(a_sorted), key=lambda x: x[1])\n\n    if len(min_cost_t_sorted) == 1:\n        return str(min_cost_t_sorted[0][0]) + \" \" + str(min_cost_t_sorted[0][1])\n    else:\n        return str(min_cost_t_sorted[0][0]) + \" \" + str(min_cost_t_sorted[0][1]) + \"\\n\" + str(min_cost_t_sorted[1][0]) + \" \" + str(min_cost_t_sorted[1][1])"
    },
    {
        "number": 191,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def coprime(a, b):\n        return gcd(a, b) == 1\n\n    def swap(a, i, j):\n        a[i], a[j] = a[j], a[i]\n\n    def count_swaps(a):\n        count = 0\n        for i in range(len(a) - 1):\n            for j in range(i + 1, len(a)):\n                if a[i] > a[j]:\n                    count += 1\n        return count\n\n    def is_sorted(a):\n        return all(a[i] <= a[i + 1] for i in range(len(a) - 1))\n\n    def solve(a, k):\n        if k == 0:\n            return 0\n\n        if k == 1:\n            return 1\n\n        if is_sorted(a):\n            return 0\n\n        count = count_swaps(a)\n\n        if count == k:\n            return 1\n\n        if count < k:\n            return 0\n\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] > a[j]:\n                    swap(a, i, j)\n                    if solve(a, k - 1) == 1:\n                        return 1\n                    swap(a, i, j)\n\n        return 0\n\n    P = solve(a, k)\n    Q = lcm(1, 10**9 + 7)\n    result = P * pow(Q, -1, Q) % (Q * 10**9 + 7)\n    return str(result)"
    },
    {
        "number": 192,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == y:\n        return \"0\"\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_valid(a, b, c):\n        return a > 0 and b > 0 and c > 0 and a + b > c and a + c > b and b + c > a\n\n    def is_degenerate(a, b, c):\n        return a == b == c\n\n    def is_equilateral(a, b, c):\n        return a == b == c\n\n    def is_isosceles(a, b, c):\n        return a == b or a == c or b == c\n\n    def is_scalene(a, b, c):\n        return a!= b!= c\n\n    def is_right_triangle(a, b, c):\n        return a * a + b * b == c * c\n\n    def is_equilateral_triangle(a, b, c):\n        return is_right_triangle(a, b, c) and is_equilateral(a, b, c)\n\n    def is_isosceles_triangle(a, b, c):\n        return is_right_triangle(a, b, c) and is_isosceles(a, b, c)\n\n    def is_scalene_triangle(a, b, c):\n        return is_right_triangle(a, b, c) and is_scalene(a, b, c)\n\n    def is_equilateral_isosceles_triangle(a, b, c):\n        return is_right_triangle(a, b, c) and is_equilateral(a, b, c) and is_isosceles(a, b, c)\n\n    def is_equilateral_scalene_triangle(a, b, c):\n        return is_right_triangle(a, b, c) and is_equilateral(a, b, c) and is_scalene(a, b, c)\n\n    def is_equilateral_isosceles_scalene_triangle(a, b, c):\n        return is_right_triangle(a, b, c) and is_equilateral(a, b, c) and is_isosceles(a, b, c) and is_scalene(a, b, c)\n\n    def is_equilateral_triangle_of_side_length(a, b, c, side_length):\n        return is_equilateral_triangle(a, b, c) and a == side_length\n\n    def is_isosceles_triangle_of_side_length(a, b, c, side_length):\n        return is_isosceles_triangle(a, b, c) and (a == side_length or b == side_length or c == side_length)\n\n    def is_scalene_triangle_of_side_length(a, b, c, side_length):\n        return is_scalene_triangle(a, b, c) and (a!= side_length and b!= side_length and c!= side_length)\n\n    def is_equilateral_isosceles_triangle_of_side_length(a, b, c, side_length):\n        return is_equilateral_isosceles_triangle(a, b, c) and (a == side_length or b == side_length or c == side_length)\n\n    def is_equilateral_scalene_triangle_of_side_length(a, b, c, side_length):\n        return is_equilateral_scalene_triangle(a, b, c) and (a!= side_length and b!= side_length and c!= side_length)\n\n    def is_equilateral_isosceles_scalene_triangle_of_side_length(a, b, c, side_length):\n        return is_equilateral_isosceles_scalene_triangle(a, b, c) and (a!= side_length and b!= side_length and c!= side_length)\n\n    def is_equilateral_triangle_of_side_length_and_area(a, b, c, side_length, area):\n        return is_equilateral_triangle_of_side_length(a, b, c, side_length) and a * a == area\n\n    def is_isosceles_triangle_of"
    },
    {
        "number": 193,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    A = [[a, b], [c, d]]\n    B = [[1.2, 1.8], [2.8, 4.2]]\n    det_A = a * d - b * c\n    det_B = 1.2 * 4.2 - 1.8 * 2.8\n    min_norm = min(abs(det_A - det_B), abs(det_A - det_B) / max(abs(det_A), abs(det_B)))\n    return f\"{min_norm:.9f}\""
    },
    {
        "number": 194,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    one_seater = [True] * (a + 1)\n    two_seater = [True] * (b + 1)\n\n    for i in range(n):\n        if t[i] == 1:\n            one_seater[0] = False\n        else:\n            two_seater[0] = False\n\n    for i in range(1, a + 1):\n        if one_seater[i]:\n            one_seater[i] = False\n\n    for i in range(1, b + 1):\n        if two_seater[i]:\n            two_seater[i] = False\n\n    denies = 0\n    for i in range(n):\n        if t[i] == 1:\n            if one_seater[0]:\n                one_seater[0] = False\n            else:\n                denies += 1\n        else:\n            if two_seater[0]:\n                two_seater[0] = False\n            else:\n                denies += 1\n\n    return str(denies)"
    },
    {
        "number": 195,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_students(visited: int, total: int) -> int:\n        if visited == total:\n            return 1\n        return count_students(visited + 1, total)\n\n    def check_distribution(a: int, b: int, c: int, n: int) -> bool:\n        return count_students(a, n) + count_students(b, n) + count_students(c, n) == n\n\n    def check_mistake(a: int, b: int, c: int, n: int) -> bool:\n        return a + b + c!= n\n\n    a, b, c, n = map(int, stdin.split())\n\n    if check_mistake(a, b, c, n):\n        return -1\n\n    if check_distribution(a, b, c, n):\n        return count_students(0, n) - 1\n\n    return -1"
    },
    {
        "number": 196,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dresses = x * 2\n    for _ in range(k):\n        dresses *= 2\n    return str((dresses + 1) % MOD)"
    },
    {
        "number": 197,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    l, r = map(int, stdin.split()[1:])\n    l, r = l - 1, r - 1\n    count = 0\n    for i in range(n):\n        count += r - l + 1\n        l += 1\n        r -= 1\n    y = 998244353\n    x = 1\n    while x * y % 998244353!= 1:\n        x += 1\n    return str(x * y)"
    },
    {
        "number": 198,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ways = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            for k in range(1, n+1):\n                if i + j + k == n:\n                    ways += 1\n    return str(ways)"
    },
    {
        "number": 199,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n\n    def find_least_keg(v: List[int]) -> int:\n        min_keg = 0\n        min_v = v[0]\n        for i in range(1, n):\n            if v[i] < min_v:\n                min_keg = i\n                min_v = v[i]\n        return min_keg\n\n    min_keg = find_least_keg(v)\n    if min_keg == n:\n        return -1\n    else:\n        return str(min(v[min_keg:]))"
    },
    {
        "number": 200,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h1, h2, a, b = map(int, stdin.split())\n\n    if h2 <= h1:\n        return \"0\"\n\n    days = 0\n    height = h1\n    while height < h2:\n        days += 1\n        height += a\n        if height > h2:\n            break\n        height -= b\n\n    if height < h2:\n        return \"-1\"\n\n    return str(days)"
    },
    {
        "number": 201,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, hr, hb, wr, wb = map(int, stdin.split())\n    max_joy = 0\n    for i in range(c // wr + 1):\n        for j in range(c // wb + 1):\n            if i * wr + j * wb <= c:\n                max_joy = max(max_joy, hr * i + hb * j)\n    return str(max_joy)"
    },
    {
        "number": 202,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    steps = 0\n    if dx == 0:\n        steps += abs(dy)\n    elif dy == 0:\n        steps += abs(dx)\n    else:\n        steps += max(abs(dx), abs(dy))\n\n    return str(steps)"
    },
    {
        "number": 203,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    fractions = list(stdin.split()[1])\n    depublicans = 0\n    remocrats = 0\n\n    for fraction in fractions:\n        if fraction == 'D':\n            depublicans += 1\n        else:\n            remocrats += 1\n\n    if depublicans > remocrats:\n        return 'D'\n    else:\n        return 'R'"
    },
    {
        "number": 204,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    count = 0\n    for w in range(a, b+1):\n        for h in range(a, b+1):\n            if w <= a and h <= b and (w * h) % (x * y) == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 205,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    result = 0\n    for i in range(1, n + 1):\n        result += len(str(factorial(i, b))) - len(str(factorial(i, b).lstrip('0')))\n    return str(result)\n\ndef"
    },
    {
        "number": 206,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b = map(int, stdin.split())\n    f = [1] * (m + 1)\n    for i in range(1, m + 1):\n        f[i] = f[i - 1] + f[i - a] + f[i - b]\n    return str(sum(f))"
    },
    {
        "number": 207,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    odd_count = 0\n    odd_start = 0\n    odd_end = 0\n\n    for i in range(1, n, 2):\n        if a[i] % 2 == 1:\n            odd_count += 1\n            odd_start = i\n            odd_end = i + 1\n\n    if odd_count % 2 == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 208,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    if x1 == x2 and y1 == y2:\n        return -1\n\n    def is_valid(x, y):\n        return -1000 <= x <= 1000 and -1000 <= y <= 1000\n\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_tree(x, y):\n        return x == 0 or y == 0 or x == 1 or y == 1\n\n    def is_parallel(x1, y1, x2, y2):\n        return x1 == x2 or y1 == y2\n\n    def is_adjacent(x1, y1, x2, y2):\n        return abs(x1 - x2) == 1 or abs(y1 - y2) == 1\n\n    def is_valid_tree(x, y):\n        return is_valid(x, y) and is_tree(x, y) and is_adjacent(x1, y1, x, y)\n\n    def is_valid_solution(x1, y1, x2, y2):\n        return is_valid_tree(x1, y1) and is_valid_tree(x2, y2)\n\n    def find_tree(x, y):\n        if x == 0:\n            return y\n        elif y == 0:\n            return x\n        elif x == 1:\n            return 1\n        else:\n            return 0\n\n    def find_tree_position(x, y):\n        if is_tree(x, y):\n            return find_tree(x, y)\n        else:\n            return 0\n\n    def find_tree_position_pair(x1, y1, x2, y2):\n        if is_valid_solution(x1, y1, x2, y2):\n            return (find_tree_position(x1, y1), find_tree_position(x2, y2))\n        else:\n            return (-1, -1)\n\n    x3, y3, x4, y4 = find_tree_position_pair(x1, y1, x2, y2)\n    return f\"{x3} {y3} {x4} {y4}\""
    },
    {
        "number": 209,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    n = int(stdin.split()[1])\n\n    f = [0] * (n + 1)\n    f[1] = x\n    f[2] = y\n\n    for i in range(3, n + 1):\n        f[i] = (f[i - 1] + f[i - 2]) % (10**9 + 7)\n\n    return str(f[n])"
    },
    {
        "number": 210,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    def split_array(A: list) -> list:\n        if len(A) == 1:\n            return [A]\n\n        mid = len(A) // 2\n        left = split_array(A[:mid])\n        right = split_array(A[mid:])\n\n        result = []\n        for i in range(1, len(left) + 1):\n            for j in range(1, len(right) + 1):\n                if i + j == len(left) + len(right):\n                    result.append(left[i - 1] + right[j - 1])\n\n        return result\n\n    def is_valid(A: list) -> bool:\n        return sum(A)!= 0\n\n    def is_valid_split(A: list, i: int) -> bool:\n        return is_valid(A[:i]) and is_valid(A[i:])\n\n    def find_valid_split(A: list) -> int:\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                return i\n\n        return 0\n\n    def find_valid_split_index(A: list) -> int:\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                return i - 1\n\n        return 0\n\n    def find_valid_split_indices(A: list) -> list:\n        result = []\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                result.append(i - 1)\n\n        return result\n\n    def find_valid_split_indices_with_sum(A: list, target_sum: int) -> list:\n        result = []\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                current_sum = sum(A[:i]) + sum(A[i:])\n                if current_sum == target_sum:\n                    result.append(i - 1)\n\n        return result\n\n    def find_valid_split_indices_with_sum_and_length(A: list, target_sum: int, length: int) -> list:\n        result = []\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                current_sum = sum(A[:i]) + sum(A[i:])\n                if current_sum == target_sum and len(A[:i]) == length:\n                    result.append(i - 1)\n\n        return result\n\n    def find_valid_split_indices_with_sum_and_length_and_index(A: list, target_sum: int, length: int, index: int) -> list:\n        result = []\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                current_sum = sum(A[:i]) + sum(A[i:])\n                if current_sum == target_sum and len(A[:i]) == length and i == index:\n                    result.append(i - 1)\n\n        return result\n\n    def find_valid_split_indices_with_sum_and_length_and_index_and_length(A: list, target_sum: int, length: int, index: int, length_of_new_array: int) -> list:\n        result = []\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                current_sum = sum(A[:i]) + sum(A[i:])\n                if current_sum == target_sum and len(A[:i]) == length and i == index and len(A[:i]) == length_of_new_array:\n                    result.append(i - 1)\n\n        return result\n\n    def find_valid_split_indices_with_sum_and_length_and_index_and_length_and_sum(A: list, target_sum: int, length: int, index: int, length_of_new_array: int, sum_of_new_array: int) -> list:\n        result = []\n        for i in range(1, len(A) + 1):\n            if is_valid_split(A, i):\n                current_sum = sum(A[:i]) + sum(A[i:])\n                if current_sum == target_sum and len"
    },
    {
        "number": 211,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    score = 0\n    consecutive_correct_answers = 0\n\n    for i in range(n):\n        if i < m:\n            if i == 0:\n                score += 1\n            else:\n                score += 2\n            consecutive_correct_answers += 1\n        else:\n            consecutive_correct_answers = 0\n\n        if consecutive_correct_answers == k:\n            score = 0\n            consecutive_correct_answers = 0\n\n    return str(score % (10**9 + 9))"
    },
    {
        "number": 212,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 0:\n        return \"NO\"\n\n    def is_divisible_by_8(num: int) -> bool:\n        return num % 8 == 0\n\n    def is_valid_number(num: int) -> bool:\n        if num == 0:\n            return True\n        if num < 0:\n            return False\n        if num % 8!= 0:\n            return False\n        if num == 8:\n            return True\n        if num == 1:\n            return True\n        if num == 7:\n            return True\n        if num == 6:\n            return True\n        if num == 5:\n            return True\n        if num == 4:\n            return True\n        if num == 3:\n            return True\n        if num == 2:\n            return True\n        return False\n\n    def remove_digits(num: int) -> int:\n        if num == 0:\n            return 0\n        if num < 0:\n            return -1\n        if num % 8!= 0:\n            return -1\n        if num == 8:\n            return 0\n        if num == 1:\n            return 1\n        if num == 7:\n            return 7\n        if num == 6:\n            return 6\n        if num == 5:\n            return 5\n        if num == 4:\n            return 4\n        if num == 3:\n            return 3\n        if num == 2:\n            return 2\n        return -1\n\n    def remove_digits_helper(num: int, removed_digits: int) -> int:\n        if num == 0:\n            return 0\n        if num < 0:\n            return -1\n        if num % 8!= 0:\n            return -1\n        if num == 8:\n            return 0\n        if num == 1:\n            return 1\n        if num == 7:\n            return 7\n        if num == 6:\n            return 6\n        if num == 5:\n            return 5\n        if num == 4:\n            return 4\n        if num == 3:\n            return 3\n        if num == 2:\n            return 2\n        if removed_digits == 0:\n            return num\n        if removed_digits == 1:\n            return 1\n        if removed_digits == 7:\n            return 7\n        if removed_digits == 6:\n            return 6\n        if removed_digits == 5:\n            return 5\n        if removed_digits == 4:\n            return 4\n        if removed_digits == 3:\n            return 3\n        if removed_digits == 2:\n            return 2\n        return -1\n\n    def remove_digits_helper_with_rearrange(num: int, removed_digits: int) -> int:\n        if num == 0:\n            return 0\n        if num < 0:\n            return -1\n        if num % 8!= 0:\n            return -1\n        if num == 8:\n            return 0\n        if num == 1:\n            return 1\n        if num == 7:\n            return 7\n        if num == 6:\n            return 6\n        if num == 5:\n            return 5\n        if num == 4:\n            return 4\n        if num == 3:\n            return 3\n        if num == 2:\n            return 2\n        if removed_digits == 0:\n            return num\n        if removed_digits == 1:\n            return 1\n        if removed_digits == 7:\n            return 7\n        if removed_digits == 6:\n            return 6\n        if removed_digits == 5:\n            return 5\n        if removed_digits == 4:\n            return 4\n        if removed_digits == 3:\n            return 3\n        if removed_digits == 2:\n            return 2\n        return -1\n\n    def remove_digits_helper_with_rearrange_helper(num: int, removed_digits: int, rearranged_digits: int) -> int:\n        if num == 0:\n            return 0\n        if num < 0:\n            return -1\n        if num % 8!= 0:\n            return -1\n        if num == 8:\n            return 0\n        if num == 1:\n            return 1\n        if num == 7:\n            return 7\n        if num == 6:\n            return 6\n        if num == 5:\n            return 5\n        if num == 4:\n            return 4\n        if num == 3:\n            return 3\n        if num == 2:\n            return 2\n        if removed_digits == 0:\n            return num\n        if removed_digits == 1:\n            return 1\n        if removed_digits == 7:\n            return "
    },
    {
        "number": 213,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    memory = []\n    for _ in range(m):\n        k, f = map(int, stdin.split())\n        memory.append((k, f))\n\n    def restore_floor(flat: int) -> int:\n        for k, f in memory:\n            if k == flat:\n                return f\n        return -1\n\n    if n <= m:\n        return str(restore_floor(n))\n    else:\n        return \"-1\""
    },
    {
        "number": 214,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(row) for row in stdin.split()]\n    pawns = [row.index('X') for row in board if 'X' in row]\n    bishwocks = []\n\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'X':\n                continue\n            if (i - 1, j) in pawns or (i + 1, j) in pawns or (i, j - 1) in pawns or (i, j + 1) in pawns:\n                bishwocks.append((i, j))\n\n    return str(len(bishwocks))"
    },
    {
        "number": 215,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_pretty(positions: list) -> bool:\n        distinct_letters = set()\n        for i in positions:\n            if s[i].islower():\n                distinct_letters.add(s[i])\n            else:\n                return False\n        return len(distinct_letters) == len(positions)\n\n    def max_pretty_set_size(positions: list) -> int:\n        max_size = 0\n        for i in range(1, len(positions)):\n            if positions[i] - positions[i - 1] > 1:\n                max_size += 1\n        return max_size\n\n    positions = []\n    for i in range(n):\n        if s[i].islower():\n            positions.append(i)\n\n    max_size = 0\n    for i in range(len(positions)):\n        for j in range(i + 1, len(positions)):\n            if positions[i] < positions[j]:\n                if is_pretty([positions[i], positions[j]]):\n                    max_size = max(max_size, max_pretty_set_size([positions[i], positions[j]]))\n\n    return str(max_size)"
    },
    {
        "number": 216,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    b = [x for x in a if x < 0]\n    c = [x for x in a if x >= 0]\n\n    B = sum(b)\n    C = sum(c)\n\n    return str(max(B - C, 0))"
    },
    {
        "number": 217,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, f, k = map(int, stdin.split())\n\n    if f > a:\n        return -1\n\n    if k == 1:\n        return 0\n\n    if f == a:\n        return k\n\n    if f == 0:\n        return k\n\n    if f == 1:\n        return k - 1\n\n    if f == 2:\n        return k - 2\n\n    if f == 3:\n        return k - 3\n\n    if f == 4:\n        return k - 4\n\n    if f == 5:\n        return k - 5\n\n    if f == 6:\n        return k - 6\n\n    if f == 7:\n        return k - 7\n\n    if f == 8:\n        return k - 8\n\n    if f == 9:\n        return k - 9\n\n    if f == 10:\n        return k - 10\n\n    return -1\n"
    },
    {
        "number": 218,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    if p > n or q > n:\n        return -1\n\n    def split_string(s: str, p: int, q: int) -> List[str]:\n        result = []\n        for i in range(0, len(s), p):\n            result.append(s[i:i + p])\n        return result\n\n    def is_valid(s: str, p: int, q: int) -> bool:\n        return len(s) % p == 0 or len(s) % q == 0\n\n    def partition(s: str, p: int, q: int) -> List[str]:\n        if not is_valid(s, p, q):\n            return []\n\n        result = []\n        for i in range(0, len(s), p):\n            result.append(s[i:i + p])\n\n        return result\n\n    def find_partition(s: str, p: int, q: int) -> List[str]:\n        partitions = partition(s, p, q)\n        if not partitions:\n            return []\n\n        result = []\n        for partition in partitions:\n            if is_valid(partition, p, q):\n                result.append(partition)\n\n        return result\n\n    partitions = find_partition(s, p, q)\n    if not partitions:\n        return -1\n\n    result = []\n    for partition in partitions:\n        result.append(\"\".join(partition))\n\n    return str(len(partitions)) + \"\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 219,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, d = map(int, stdin.split())\n    obstacles = list(map(int, stdin.split()))\n\n    def is_valid(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_finish(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_finish(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_finish(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run_jump_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run_jump_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run_jump_run_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run_jump_run_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run_jump_run_jump_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run_jump_run_jump_run_jump(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_jump_run_finish_run_jump_run_jump_run_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n                return False\n        return True\n\n    def is_valid_run_jump_finish_run_jump_run_jump_run_jump_run(x: int) -> bool:\n        for obstacle in obstacles:\n            if x == obstacle:\n               "
    },
    {
        "number": 220,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x = map(int, stdin.split())\n    if s == x:\n        return \"0\"\n\n    def bitwise_xor(a: int, b: int) -> int:\n        while b:\n            a, b = a ^ b, a & b\n        return a\n\n    def count_pairs(a: int, b: int) -> int:\n        if a == 0:\n            return 0\n        if a == 1:\n            return b\n        if b == 0:\n            return 0\n        if b == 1:\n            return a\n\n        count = 0\n        for i in range(1, min(a, b) + 1):\n            if bitwise_xor(i, a) == x:\n                count += count_pairs(a - i, b)\n            if bitwise_xor(i, b) == x:\n                count += count_pairs(a, b - i)\n\n        return count\n\n    return str(count_pairs(s, x))\n"
    },
    {
        "number": 221,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    skewers = list(range(1, n+1))\n    turns = 0\n    while skewers:\n        turns += 1\n        for i in range(len(skewers)):\n            for j in range(i+k, len(skewers)):\n                if skewers[i] < skewers[j]:\n                    skewers[i], skewers[j] = skewers[j], skewers[i]\n        skewers = [s for s in skewers if s not in skewers[:i]]\n    return str(turns)"
    },
    {
        "number": 222,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43:\n        return 43\n    if n == 44:\n        return 44\n    if n == 45:\n        return 45\n    if n == 46:\n        return 46\n    if n == 47:\n        return 47\n    if n == 48:\n        return 48\n    if n == 49:\n        return 49\n    if n == 50:\n        return 50\n    if n == 51:\n        return 51\n    if n == 52:\n        return 52\n    if n == 53:\n        return 53\n    if n == 54:\n        return 54\n    if n == 55:\n        return 55\n    if n == 56:\n        return 56\n    if n == 57:\n        return 57\n    if n == 58:\n        return 58\n    if n == 59:\n        return 59\n    if n == 60:\n        return 60\n    if n == 61:\n        return 61\n    if n == 62:\n        return 62\n    if n == 63:\n        return 63\n    if n == 64:\n        return 64\n    if n == 65:\n        return 65\n    if n == 66:\n        return 66\n    if n == 67:\n        return 67\n    if n == 68:\n        return 68\n    if n == 69:\n        return 69\n    if n == 70:\n        return 70\n    if n == 71:\n        return 71\n    if n == 72:\n        return 72\n    if n == 73:\n        return 73\n    if n == 74:\n        return 74\n    if n == 75:\n        return 75\n    if n == 76:\n        return 76\n    if n == 77:\n        return 77\n    if n == 78:\n        return 78\n    if n == 79:\n        return"
    },
    {
        "number": 223,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    f_max = 1\n    for i in range(1, n + 1):\n        f_max *= i\n    f_max %= 1000000007\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            for k in range(j):\n                for l in range(k):\n                    for m in range(l, n):\n                        p = [i, j, k, l, m]\n                        f = 1\n                        for x in p:\n                            f *= x\n                        if f == f_max:\n                            count += 1\n\n    return str(count % 1000000007)"
    },
    {
        "number": 224,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = 'AEIOUY'\n    s = stdin.upper()\n    n = len(s)\n    min_jump = 1\n    max_jump = min(n, 100)\n\n    while min_jump <= max_jump:\n        mid = (min_jump + max_jump) // 2\n        if is_possible(s, mid, vowels):\n            min_jump = mid + 1\n        else:\n            max_jump = mid - 1\n\n    return str(min_jump)\n\n\ndef"
    },
    {
        "number": 225,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    if sum(a) % 2!= 0:\n        return \"NO\"\n    a.sort()\n    return \"YES\" if a[0] == a[1] else \"NO\""
    },
    {
        "number": 226,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sizes = list(map(int, stdin.split()[1:]))\n\n    alice_slices = 0\n    bob_slices = 0\n\n    for size in sizes:\n        if size % 2 == 0:\n            alice_slices += size\n        else:\n            bob_slices += size\n\n    alice_eaten = alice_slices // 2\n    bob_eaten = bob_slices // 2\n\n    return f\"{alice_eaten} {bob_eaten}\""
    },
    {
        "number": 227,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    if len(a)!= n:\n        return -1\n\n    b = [0] * (n + 1)\n    for i in range(1, n + 1):\n        b[i] = b[i - 1] + a[i - 1]\n\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if b[i] + b[j] == a[i]:\n                b[j] = b[i] + b[j]\n                break\n\n    for i in range(1, n + 1):\n        if b[i] == a[i]:\n            return i\n\n    return -1\n"
    },
    {
        "number": 228,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    alice_piles = [0] * n\n    bob_piles = [0] * n\n    alice_moves = 0\n    bob_moves = 0\n\n    for i in range(n):\n        if a[i] > 0:\n            alice_piles[i] = a[i]\n            alice_moves += 1\n        if a[i] > 0:\n            bob_piles[i] = a[i]\n            bob_moves += 1\n\n    while alice_moves < n // 2 and bob_moves < n // 2:\n        if alice_moves < bob_moves:\n            alice_moves += 1\n            for i in range(n):\n                if alice_piles[i] > 0:\n                    alice_piles[i] -= 1\n                    if alice_piles[i] == 0:\n                        alice_piles[i] = -1\n        else:\n            bob_moves += 1\n            for i in range(n):\n                if bob_piles[i] > 0:\n                    bob_piles[i] -= 1\n                    if bob_piles[i] == 0:\n                        bob_piles[i] = -1\n\n    if alice_moves < n // 2:\n        return \"Alice\"\n    else:\n        return \"Bob\""
    },
    {
        "number": 229,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    x = 1\n    while True:\n        if all(a[i] == a[i] + x for i in range(n)) and all(a[i] == a[i] - x for i in range(1, n - 1)):\n            return \"YES\"\n        x += 1"
    },
    {
        "number": 230,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    S = stdin.split()[1]\n\n    max_len = 0\n    for i in range(N - max_len):\n        for j in range(i + 1, i + max_len + 1):\n            if S[i:j] == S[i:j][::-1]:\n                max_len = max(max_len, j - i)\n\n    return str(max_len)"
    },
    {
        "number": 231,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    houses = [i for i in range(1, n + 1, 2)] + [i for i in range(2, n + 1, 2)]\n    houses.sort()\n    min_time = 0\n    for i in range(1, n + 1, 2):\n        min_time += abs(houses.index(i) - houses.index(a))\n    return str(min_time)"
    },
    {
        "number": 232,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    def is_valid(start, end):\n        count = 0\n        for i in range(start, end + 1):\n            if colors[i - 1] == colors[start - 1]:\n                count += 1\n            else:\n                break\n        return count == k[colors[start - 1] - 1]\n\n    for i in range(1, m + 1):\n        if is_valid(i, n):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 233,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rounds = []\n    for i in range(n):\n        m, c = map(int, stdin.split()[1:])\n        rounds.append((m, c))\n    rounds.sort(key=lambda x: (-x[0], -x[1]))\n    for i in range(n):\n        if rounds[i][0] > rounds[i][1]:\n            return \"Mishka\"\n        elif rounds[i][0] < rounds[i][1]:\n            return \"Chris\"\n    return \"Friendship is magic!^^\""
    },
    {
        "number": 234,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def count_bombs(x: int, y: int) -> int:\n        count = 0\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == '*':\n                count += 1\n        return count\n\n    def is_valid(x: int, y: int) -> bool:\n        if field[x][y] == '.':\n            return all(count_bombs(x, y) == count_bombs(x, j) for j in range(y - 1, -1, -1))\n        return True\n\n    for x in range(n):\n        for y in range(m):\n            if field[x][y] == '*':\n                field[x][y] = '8'\n\n    for x in range(n):\n        for y in range(m):\n            if field[x][y] == '8':\n                if not is_valid(x, y):\n                    return 'NO'\n\n    return 'YES'"
    },
    {
        "number": 235,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 1\n    while True:\n        if k * 2 > n:\n            break\n        k += 1\n    return str(k)"
    },
    {
        "number": 236,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n\n    def is_valid(i: int) -> bool:\n        return i > 0 and i < n and s[i - 1]!= '-' and s[i]!= '-'\n\n    def is_adjacent(i: int, j: int) -> bool:\n        return is_valid(i - 1) and is_valid(j + 1) and s[i - 1] == s[j + 1]\n\n    def join_links(i: int, j: int) -> None:\n        s[i] = '-'\n        s[j] = '-'\n\n    def join_pearls(i: int, j: int) -> None:\n        s[i] = 'o'\n        s[j] = 'o'\n\n    def join_links_and_pearls(i: int, j: int) -> None:\n        join_links(i, j)\n        join_pearls(i, j)\n\n    def join_links_and_pearls_if_possible(i: int, j: int) -> bool:\n        if is_adjacent(i, j):\n            join_links_and_pearls(i, j)\n            return True\n        return False\n\n    for i in range(n - 1):\n        if s[i] == '-' and s[i + 1] == '-':\n            if join_links_and_pearls_if_possible(i, i + 1):\n                continue\n            if join_links_and_pearls_if_possible(i, i + 2):\n                continue\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 237,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    pillows = [0] * n\n    for i in range(n):\n        pillows[i] = i + 1\n    pillows.sort()\n    max_pillows = 0\n    for i in range(n):\n        if pillows[i] >= k:\n            max_pillows = max(max_pillows, pillows[i])\n        else:\n            break\n    return str(max_pillows)"
    },
    {
        "number": 238,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_cost = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarray_cost = sum(a[i:j]) - k * (j - i + 1) // m\n            max_cost = max(max_cost, subarray_cost)\n\n    return str(max_cost)"
    },
    {
        "number": 239,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            grid[i][j] = 1\n\n    def dfs(x, y, visited):\n        if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] or (x, y) in visited:\n            return\n        visited.add((x, y))\n        dfs(x + 1, y, visited)\n        dfs(x - 1, y, visited)\n        dfs(x, y + 1, visited)\n        dfs(x, y - 1, visited)\n\n    visited = set()\n    max_length = 0\n    max_points = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                dfs(i, j, visited)\n                length = len(visited)\n                if length > max_length:\n                    max_length = length\n                    max_points = list(visited)\n\n    result = []\n    for point in max_points:\n        result.append(str(point[0]) + \" \" + str(point[1]))\n    return \"\\n\".join(result)"
    },
    {
        "number": 240,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = len(str(n))\n    n_str = str(n)\n    n_str = n_str.zfill(k)\n    n_str = n_str[::-1]\n    n_str = ''.join(n_str)\n    return n_str"
    },
    {
        "number": 241,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, min_temp, max_temp = map(int, stdin.split())\n    temp_list = list(map(int, stdin.split()[1:]))\n\n    if min_temp == max_temp:\n        return 'Incorrect'\n\n    if min_temp < temp_list[0] or max_temp > temp_list[-1]:\n        return 'Incorrect'\n\n    for i in range(m, n):\n        if temp_list[i] < min_temp:\n            min_temp = temp_list[i]\n        if temp_list[i] > max_temp:\n            max_temp = temp_list[i]\n\n    if min_temp == max_temp:\n        return 'Correct'\n\n    return 'Incorrect'"
    },
    {
        "number": 242,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    k = 0\n    for i in range(1, 100001):\n        if i % 10 == 0:\n            k += 1\n            if k == m:\n                break\n    print(k)\n    for i in range(100000, 0, -1):\n        if i % 10 == 0:\n            print(i)\n            if k == m:\n                break"
    },
    {
        "number": 243,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    def bellman_ford(start: int) -> int:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        for _ in range(m):\n            for u in range(1, n + 1):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist[n]\n\n    def farthest_special_vertex(start: int) -> int:\n        dist = bellman_ford(start)\n        max_dist = max(dist)\n        for u in range(1, n + 1):\n            if dist[u] == max_dist:\n                return u\n        return -1\n\n    result = []\n    for i in range(k):\n        farthest_vertex = farthest_special_vertex(x[i])\n        if farthest_vertex!= -1:\n            result.append(dist[farthest_vertex])\n        else:\n            result.append(float('inf'))\n\n    return''.join(map(str, result))"
    },
    {
        "number": 244,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n % 2 == 0:\n        x = (x + 1) % 3\n    else:\n        x = (x + 2) % 3\n    return str(x)"
    },
    {
        "number": 245,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rectangles = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:5])\n        rectangles.append((x1, y1, x2, y2))\n    rectangles.sort(key=lambda x: (x[0], x[1]))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if rectangles[i][0] > rectangles[j][2] or rectangles[j][0] > rectangles[i][2]:\n                continue\n            if rectangles[i][1] > rectangles[j][3] or rectangles[j][1] > rectangles[i][3]:\n                continue\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 246,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if sum(int(digit) for digit in str(i)) - i >= s:\n            count += 1\n    return str(count)"
    },
    {
        "number": 247,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    lines = []\n    for _ in range(n - 1):\n        x1, y1 = map(int, stdin.split()[1:])\n        x2, y2 = map(int, stdin.split()[1:])\n        lines.append((x1, y1, x2, y2))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_possible(points, lines, i, j):\n                return \"YES\"\n    return \"NO\"\n\n\ndef"
    },
    {
        "number": 248,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k, t = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_games(score_a, score_b):\n        games = 0\n        for i in range(t):\n            if score_a + score_b == 0:\n                return 0\n            if score_a + score_b > 0:\n                score_a += random.randint(-k, k)\n                score_b += random.randint(-k, k)\n            else:\n                score_a += random.randint(-k, k)\n                score_b += random.randint(-k, k)\n        return games\n\n    games_a = count_games(a, b)\n    games_b = count_games(b, a)\n    return str((games_a + games_b) % MOD)"
    },
    {
        "number": 249,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def binary_search(start, end):\n        while start <= end:\n            mid = (start + end) // 2\n            if a[mid] - a[0] == x:\n                return mid\n            elif a[mid] - a[0] < x:\n                start = mid + 1\n            else:\n                end = mid - 1\n        return -1\n\n    def find_marks(start, end):\n        if start == end:\n            return [start]\n        mid = (start + end) // 2\n        if a[mid] - a[0] == x:\n            return [start] + find_marks(mid + 1, end)\n        elif a[mid] - a[0] < x:\n            return find_marks(start, mid - 1)\n        else:\n            return find_marks(mid + 1, end)\n\n    marks = find_marks(0, n - 1)\n    if marks[0] == 0:\n        marks.pop(0)\n    if marks[-1] == l:\n        marks.pop()\n\n    return str(len(marks)) +'' +''.join(map(str, marks))\n"
    },
    {
        "number": 250,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cakes = []\n    for _ in range(n):\n        r, h = map(int, stdin.split()[1:])\n        cakes.append((r, h))\n\n    def is_valid(cake1, cake2):\n        return cake1[0] > cake2[0]\n\n    def max_volume(cakes):\n        max_volume = 0\n        for i in range(len(cakes)):\n            for j in range(i + 1, len(cakes)):\n                if is_valid(cakes[i], cakes[j]):\n                    max_volume = max(max_volume, cakes[i][0] * cakes[j][1])\n        return max_volume\n\n    return str(max_volume(cakes))"
    },
    {
        "number": 251,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def dfs(height, cost):\n        if height == 0:\n            return 0, 0\n\n        if height > 0:\n            for i in range(n):\n                if h[i] > height:\n                    removed, new_cost = dfs(height - h[i], cost + 1)\n                    if removed > 0:\n                        return removed, new_cost\n\n        return 0, 0\n\n    _, min_cost = dfs(max(h), 0)\n    return str(min_cost)"
    },
    {
        "number": 252,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    alice_score = 0\n    bob_score = 0\n\n    for i in range(n):\n        if i == 0:\n            alice_score += a[i]\n        elif i == n - 1:\n            alice_score += a[i]\n        else:\n            alice_score += a[i] + a[i - 1] + a[i + 1]\n\n    for i in range(n):\n        if i == 0:\n            bob_score += a[i]\n        elif i == n - 1:\n            bob_score += a[i]\n        else:\n            bob_score += a[i] + a[i - 1] + a[i + 1]\n\n    alice_score = max(alice_score, bob_score)\n\n    return str(alice_score)"
    },
    {
        "number": 253,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k1, k2, k3 = map(int, stdin.split())\n    if k1 > k2 > k3:\n        return \"YES\"\n    elif k2 > k1 > k3:\n        return \"YES\"\n    elif k3 > k1 > k2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 254,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def delete_substring(s: str, start: int, end: int) -> str:\n        while start < end:\n            if s[start]!= s[end]:\n                return s[:start] + s[end:]\n            start += 1\n            end -= 1\n        return s[:start] + s[end:]\n\n    def count_operations(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 3):\n            if s[i:i + 4] == s[i + 4:i + 8]:\n                count += 1\n        return count\n\n    def min_operations(s: str) -> int:\n        min_count = float('inf')\n        for i in range(len(s) - 3):\n            if s[i:i + 4] == s[i + 4:i + 8]:\n                min_count = min(min_count, count_operations(delete_substring(s, i, i + 4)))\n        return min_count\n\n    return str(min_operations(s))\n"
    },
    {
        "number": 255,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m, b = map(int, stdin.split())\n    a = list(map(int, a.split()))\n    b = list(map(int, b.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def max_pairs(a, b):\n        return max(a // lcm(a, b), b // lcm(a, b))\n\n    return str(max_pairs(max(a), max(b)))"
    },
    {
        "number": 256,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    defense, attack = map(int, stdin.split())\n    if defense > attack and attack > defense:\n        return \"Team 1\"\n    elif defense < attack and attack < defense:\n        return \"Team 2\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 257,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    meat = []\n    for _ in range(N):\n        x, y, c = map(int, stdin.split())\n        meat.append((x, y, c))\n\n    meat.sort(key=lambda x: (x[0], x[1]))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def grill_time(x, y, c):\n        return c * distance(x, y)\n\n    def min_time(heat_source):\n        return min(grill_time(x, y, c) for x, y, c in meat if distance(x, y) <= distance(heat_source[0], heat_source[1]))\n\n    return str(min_time(heat_source))\n"
    },
    {
        "number": 258,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ticket = list(map(int, stdin.split()[1]))\n    happy = True\n\n    for i in range(n // 2):\n        if ticket[i]!= ticket[n // 2]:\n            happy = False\n            break\n\n    if happy:\n        for i in range(n // 2, n):\n            if ticket[i]!= ticket[n - 1 - i]:\n                happy = False\n                break\n\n    if happy:\n        return \"Monocarp\"\n    else:\n        return \"Bicarp\""
    },
    {
        "number": 259,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    routes = []\n    for i in range(n):\n        s, d = map(int, stdin.split())\n        routes.append((s, d))\n    routes.sort(key=lambda x: x[0])\n    for i in range(n):\n        if routes[i][0] <= t:\n            return str(i + 1)\n    return \"1\""
    },
    {
        "number": 260,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    n = 1\n    while True:\n        binary_representation = bin(n)[2:]\n        if len(binary_representation) == k:\n            count = 0\n            for i in range(1, m + 1):\n                if binary_representation.count(str(i)) == i:\n                    count += 1\n            if count == m:\n                return str(n)\n        n += 1"
    },
    {
        "number": 261,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    level = list(stdin.split()[1])\n\n    good = True\n    for i in range(n - 4):\n        if level[i] == '.' and level[i + 1] == '.' and level[i + 2] == '.' and level[i + 3] == '.' and level[i + 4] == '.':\n            good = False\n            break\n\n    if good:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\n    return \"yes\" if good else \"no\""
    },
    {
        "number": 262,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()[1:]))\n        grid.append(row)\n\n    i, j = 0, 0\n    for row in grid:\n        if row[j] == 0:\n            break\n        i += 1\n\n    if i == n:\n        return -1\n\n    for col in range(n):\n        if grid[i][col] == 0:\n            break\n        j += 1\n\n    if j == n:\n        return -1\n\n    for k in range(n):\n        if grid[k][j] == 0:\n            break\n        i += 1\n\n    if i == n:\n        return -1\n\n    for l in range(n):\n        if grid[i][l] == 0:\n            break\n        j += 1\n\n    if j == n:\n        return -1\n\n    x = grid[i][j]\n    for row in grid:\n        row[j] = 0\n    for col in range(n):\n        grid[i][col] = 0\n    for k in range(n):\n        grid[k][j] = 0\n    for l in range(n):\n        grid[i][l] = 0\n\n    for row in grid:\n        row.sort()\n    for col in range(n):\n        grid[i][col].sort()\n    for k in range(n):\n        grid[k][j].sort()\n    for l in range(n):\n        grid[i][l].sort()\n\n    for row in grid:\n        if row[j]!= 0:\n            return -1\n\n    for col in range(n):\n        if grid[i][col]!= 0:\n            return -1\n\n    for k in range(n):\n        if grid[k][j]!= 0:\n            return -1\n\n    for l in range(n):\n        if grid[i][l]!= 0:\n            return -1\n\n    return x"
    },
    {
        "number": 263,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    benches = [int(x) for x in stdin.split()]\n\n    min_k = max_k = 0\n    for bench in benches:\n        min_k = max(min_k, bench)\n        max_k = max(max_k, n - bench)\n\n    min_k += m\n    max_k += m\n\n    return f\"{min_k} {max_k}\""
    },
    {
        "number": 264,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    seat_count = n * m\n    seat_map = {}\n    for i in range(1, seat_count + 1):\n        seat_map[i] = []\n    for i in range(1, seat_count + 1):\n        seat_map[i].append(i)\n    seat_map[1].append(1)\n    seat_map[seat_count].append(seat_count)\n\n    def dfs(seat, entrance, path):\n        if seat == seat_count:\n            return 1\n        if seat in seat_map[seat]:\n            seat_map[seat].remove(seat)\n        if entrance == \"F\":\n            entrance = \"B\"\n        elif entrance == \"B\":\n            entrance = \"F\"\n        for i in range(1, seat_count + 1):\n            if entrance == \"F\" and seat_map[i][-1] == seat_count:\n                continue\n            if entrance == \"B\" and seat_map[i][0] == 1:\n                continue\n            if seat_map[i][-1] == seat - 1:\n                seat_map[i].append(seat)\n                path.append(entrance)\n                result = dfs(seat + 1, entrance, path)\n                if result:\n                    return result\n                seat_map[i].pop()\n                path.pop()\n        return 0\n\n    path = []\n    result = dfs(1, \"F\", path)\n    if result:\n        print(result)\n    else:\n        print(0)\n\n    return \"\"\n"
    },
    {
        "number": 265,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = [list(map(int, stdin.split())) for _ in range(n)]\n    pizzas = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def is_valid(pizza_index: int, friend_index: int) -> bool:\n        pizza_ingredients = set(pizzas[pizza_index][2:])\n        friend_ingredients = set(friends[friend_index][2:])\n        return pizza_ingredients.issubset(friend_ingredients)\n\n    def min_price(pizza_index: int, friend_index: int) -> int:\n        pizza_price = pizzas[pizza_index][0]\n        friend_ingredients = set(friends[friend_index][2:])\n        min_price = float('inf')\n        for pizza_index_2 in range(m):\n            if pizza_index_2 == pizza_index:\n                continue\n            if is_valid(pizza_index_2, friend_index):\n                pizza_ingredients = set(pizzas[pizza_index_2][2:])\n                if pizza_ingredients.issubset(friend_ingredients):\n                    min_price = min(min_price, pizzas[pizza_index_2][0])\n        return min_price\n\n    def min_pizza_index(friend_index: int) -> int:\n        min_price = float('inf')\n        min_pizza_index = -1\n        for pizza_index in range(m):\n            if is_valid(pizza_index, friend_index):\n                min_price_2 = min_price(pizza_index, friend_index)\n                if min_price_2 < min_price:\n                    min_price = min_price_2\n                    min_pizza_index = pizza_index\n        return min_pizza_index\n\n    def min_friend_index(pizza_index: int) -> int:\n        min_price = float('inf')\n        min_friend_index = -1\n        for friend_index in range(n):\n            if is_valid(pizza_index, friend_index):\n                min_price_2 = min_price(pizza_index, friend_index)\n                if min_price_2 < min_price:\n                    min_price = min_price_2\n                    min_friend_index = friend_index\n        return min_friend_index\n\n    min_pizza_index_1 = min_pizza_index(0)\n    min_friend_index_1 = min_friend_index(min_pizza_index_1)\n    min_pizza_index_2 = min_pizza_index(1)\n    min_friend_index_2 = min_friend_index(min_pizza_index_2)\n\n    return f\"{min_pizza_index_1} {min_pizza_index_2}\"\n"
    },
    {
        "number": 266,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    min_num = 10 ** (m - 1)\n    max_num = 9 * 10 ** (m - 1)\n    for i in range(1, 10):\n        for j in range(1, 10):\n            for k in range(1, 10):\n                for l in range(1, 10):\n                    for m in range(1, 10):\n                        for n in range(1, 10):\n                            num = i * 1000 + j * 100 + k * 10 + l * 1 + m * 10000 + n * 100000\n                            if num >= min_num and num <= max_num and sum(int(digit) for digit in str(num)) == s:\n                                return str(num)\n    return \"-1 -1\""
    },
    {
        "number": 267,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    if k > 10:\n        return \"Invalid input\"\n\n    def count_digits(num: int) -> int:\n        return len(str(num))\n\n    def count_unique_digits(num: int) -> int:\n        return len(set(str(num)))\n\n    def sum_of_numbers(l: int, r: int) -> int:\n        return (r * (r + 1)) // 2 - (l * (l + 1)) // 2\n\n    def sum_of_numbers_with_k_digits(l: int, r: int, k: int) -> int:\n        return sum(sum_of_numbers(l, r) for _ in range(k))\n\n    return str(sum_of_numbers_with_k_digits(l, r, k) % 998244353)\n"
    },
    {
        "number": 268,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(boxes: List[int]) -> bool:\n        pencils_in_boxes = [0] * n\n        for pencil in a:\n            box_index = pencils_in_boxes.index(min(pencils_in_boxes) + 1)\n            pencils_in_boxes[box_index] += 1\n            if pencils_in_boxes[box_index] > k:\n                return False\n        return True\n\n    def is_valid_with_opposite(boxes: List[int]) -> bool:\n        pencils_in_boxes = [0] * n\n        for pencil in a:\n            box_index = pencils_in_boxes.index(min(pencils_in_boxes) + 1)\n            pencils_in_boxes[box_index] += 1\n            if pencils_in_boxes[box_index] > k:\n                return False\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(boxes[i] - boxes[j]) <= d:\n                    return False\n        return True\n\n    boxes = [0] * n\n    for pencil in a:\n        box_index = pencils_in_boxes.index(min(pencils_in_boxes) + 1)\n        pencils_in_boxes[box_index] += 1\n        boxes[box_index] = pencil\n\n    if is_valid(boxes):\n        return \"YES\"\n    elif is_valid_with_opposite(boxes):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 269,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    garland = list(stdin)\n    red_count = 0\n    blue_count = 0\n    yellow_count = 0\n    green_count = 0\n\n    for i in range(len(garland) - 3):\n        if garland[i] == garland[i + 1] == garland[i + 2] == garland[i + 3] == '!':\n            if garland[i] == 'R':\n                red_count += 1\n            elif garland[i] == 'B':\n                blue_count += 1\n            elif garland[i] == 'Y':\n                yellow_count += 1\n            elif garland[i] == 'G':\n                green_count += 1\n\n    return f\"{red_count} {blue_count} {yellow_count} {green_count}\""
    },
    {
        "number": 270,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    passages = []\n    for i in range(m):\n        s, t = map(int, stdin.split())\n        passages.append((s, t))\n\n    s_1 = 1\n    s_n = n\n    s_set = set()\n    for i in range(n):\n        s_set.add(i + 1)\n\n    def dfs(room: int, visited: set) -> int:\n        if room == n:\n            return 0\n\n        if room in visited:\n            return float('inf')\n\n        visited.add(room)\n        count = 0\n        for s, t in passages:\n            if s == room and t in s_set:\n                count += 1\n        count += dfs(room + 1, visited)\n        count += dfs(room + 2, visited)\n        return count\n\n    min_e = float('inf')\n    for s in s_set:\n        visited = set()\n        min_e = min(min_e, dfs(s, visited))\n\n    return f'{min_e:.6f}'"
    },
    {
        "number": 271,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    elif n % 10 == 0:\n        return str(n)\n    else:\n        return str(n + 10)"
    },
    {
        "number": 272,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    santa_pattern = s[0]\n    result = s[1]\n\n    santa_pattern_set = set(santa_pattern)\n    result_set = set(result)\n\n    if len(santa_pattern_set)!= len(result_set):\n        return \"-1\"\n\n    pairs = []\n    for i in range(len(santa_pattern)):\n        if santa_pattern[i] == result[i]:\n            pairs.append((santa_pattern[i], result[i]))\n\n    pairs.sort()\n\n    if len(pairs) % 2 == 0:\n        return str(len(pairs) // 2) + \"\\n\" + \" \".join(pair for pair in pairs)\n    else:\n        return str(len(pairs) // 2 + 1) + \"\\n\" + \" \".join(pair for pair in pairs)\n"
    },
    {
        "number": 273,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_name, last_name = stdin.split()\n    prefixes = [first_name, last_name]\n    prefixes.sort()\n    return prefixes[0]"
    },
    {
        "number": 274,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    brackets = stdin.split()[1]\n    stack = []\n    result = []\n\n    for i, bracket in enumerate(brackets):\n        if bracket == '[':\n            stack.append(i)\n        elif bracket == ']':\n            if not stack:\n                result.append(f\"|{'-' * (n - 1)}|\")\n            else:\n                start = stack.pop()\n                result.append(f\"|{'+' * (i - start - 1)}|\")\n                result.append(f\"|{'-' * (n - 1)}|\")\n                result.append(f\"|{'+' * (i - start - 1)}|\")\n\n    if not stack:\n        result.append(f\"|{'-' * (n - 1)}|\")\n    else:\n        start = stack.pop()\n        result.append(f\"|{'+' * (n - 1)}|\")\n        result.append(f\"|{'-' * (n - 1)}|\")\n        result.append(f\"|{'+' * (n - 1)}|\")\n\n    return ''.join(result)"
    },
    {
        "number": 275,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(a, 2)\n    b = int(b, 2)\n    if a > b:\n        return \">\"\n    elif a < b:\n        return \"<\"\n    else:\n        return \"=\""
    },
    {
        "number": 276,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *colors = stdin.split()\n    absent_gems = []\n    for color in colors:\n        if color not in [\"purple\", \"green\", \"blue\", \"orange\", \"red\", \"yellow\"]:\n            absent_gems.append(color)\n    absent_gems.sort()\n    return str(len(absent_gems)) + \"\\n\" + \" \".join(absent_gems)"
    },
    {
        "number": 277,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a == b:\n        return \"Final!\"\n    if a > b:\n        a, b = b, a\n    for i in range(1, n + 1, 2):\n        if i == a or i == b:\n            continue\n        if i - a == b - a:\n            return str(i)\n    return \"Final!\""
    },
    {
        "number": 278,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def is_permutation(p1: list, p2: list) -> bool:\n        return sorted(p1) == sorted(p2)\n\n    def is_valid_permutation(p: list, b: list) -> bool:\n        visited = [False] * n\n        for i in range(n):\n            if b[i] == 1:\n                visited[p[i] - 1] = not visited[p[i] - 1]\n            if visited[p[i] - 1]:\n                return False\n        return True\n\n    def min_elements_to_visit(p: list, b: list) -> int:\n        visited = [False] * n\n        count = 0\n        for i in range(n):\n            if b[i] == 1:\n                visited[p[i] - 1] = not visited[p[i] - 1]\n            if visited[p[i] - 1]:\n                count += 1\n        return count\n\n    def min_elements_to_visit_helper(p: list, b: list, visited: list, count: int) -> int:\n        if count == 2 * n:\n            return count\n        for i in range(n):\n            if not visited[i]:\n                visited[i] = True\n                if b[i] == 1:\n                    visited[p[i] - 1] = not visited[p[i] - 1]\n                if visited[p[i] - 1]:\n                    count += 1\n                    visited[i] = False\n                    return min_elements_to_visit_helper(p, b, visited, count)\n        return count\n\n    if is_permutation(p, p):\n        return str(min_elements_to_visit(p, b))\n    else:\n        visited = [False] * n\n        count = 0\n        return str(min_elements_to_visit_helper(p, b, visited, count))"
    },
    {
        "number": 279,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v1, v2, t, d = map(int, stdin.split())\n    if v1 == v2:\n        return str(v1 * t)\n    if v1 < v2:\n        v1, v2 = v2, v1\n    if d == 0:\n        return str(v1 * t)\n    if v1 + d > v2:\n        return str(v1 * t + (v2 - v1) * t)\n    return str(v1 * t + (v2 - v1) * t + d * (t - 1))"
    },
    {
        "number": 280,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    camels = list(map(int, stdin.split()))\n    camels.sort()\n    bridge_parts = []\n    total_weight = 0\n    for i in range(M):\n        bridge_parts.append(list(map(int, stdin.split())))\n        total_weight += sum(bridge_parts[-1][1:])\n    if total_weight > sum(bridge_parts[-1][1:]) * M:\n        return -1\n    distances = [0] * (N - 1)\n    for i in range(M):\n        for j in range(N - 1):\n            if bridge_parts[i][0] == j + 1:\n                distances[j] = bridge_parts[i][1]\n            elif bridge_parts[i][0] == j + 2:\n                distances[j] = bridge_parts[i][1] + distances[j]\n            else:\n                distances[j] = float('inf')\n    min_distance = float('inf')\n    for i in range(N - 1):\n        if distances[i] < min_distance:\n            min_distance = distances[i]\n    return str(min_distance)"
    },
    {
        "number": 281,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    result = 0\n    for i in range(a, b+1):\n        result += factorial(i)\n    return str(result % 10)\n\ndef"
    },
    {
        "number": 282,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    s = list(stdin.strip())\n\n    jumps = 0\n    current_point = 1\n    while current_point < n:\n        if s[current_point] == '1':\n            jumps += 1\n            if jumps == d:\n                return str(jumps)\n        current_point += 1\n\n    return -1"
    },
    {
        "number": 283,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(1, 1000):\n        if n * m + 1 not in [i for i in range(2, n + 1) if all(i % j!= 0 for j in range(2, int(i ** 0.5) + 1))]:\n            return str(m)\n    return \"No counterexample found\""
    },
    {
        "number": 284,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 1234567 == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 285,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, x2 = map(int, stdin.split())\n    lines = []\n    for _ in range(n):\n        k, b = map(int, stdin.split())\n        lines.append((k, b))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lines[i][0] * lines[j][0] + lines[i][1] * lines[j][1] == 0:\n                if x1 < lines[i][0] * x2 + lines[i][1] < x2:\n                    return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 286,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if sum(i, n) == n:\n            count += 1\n    return str(count)"
    },
    {
        "number": 287,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    inhabited_apartments = set(map(int, stdin.split()))\n    adjacent_apartments = set()\n\n    for i in range(n - 1):\n        adjacent_apartments.add(i + 1)\n\n    good_apartments = set()\n    for i in range(n):\n        if i in inhabited_apartments:\n            good_apartments.add(i)\n        elif i - 1 in adjacent_apartments and i + 1 in adjacent_apartments:\n            good_apartments.add(i)\n\n    min_good_apartments = min(good_apartments)\n    max_good_apartments = max(good_apartments)\n\n    return f\"{min_good_apartments} {max_good_apartments}\""
    },
    {
        "number": 288,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"1\"\n    elif n == 3:\n        return \"2\"\n    else:\n        return \"4\""
    },
    {
        "number": 289,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.upper()\n    max_occurrences = 0\n    for i in range(len(s) - 1):\n        if s[i:i+2] == \"VK\":\n            max_occurrences = max(max_occurrences, 1)\n            s = s[:i] + s[i+2:]\n    return str(max_occurrences)"
    },
    {
        "number": 290,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    segments = []\n    for i in range(n):\n        segments.append(input().split())\n    segments.sort(key=lambda x: (int(x[0]), int(x[1])))\n    min_segments = 0\n    for i in range(n):\n        if i == 0:\n            min_segments += 1\n        else:\n            if segments[i][0] == segments[i - 1][0] + 1 and segments[i][1] == segments[i - 1][1] + 1:\n                min_segments += 1\n            else:\n                min_segments += 2\n    return str(min_segments)"
    },
    {
        "number": 291,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    years = 0\n    while a <= b:\n        a *= 3\n        b *= 2\n        years += 1\n    return str(years)"
    },
    {
        "number": 292,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, n = map(int, stdin.split())\n    visited = set()\n    stack = [(1, 1)]\n    count = 0\n\n    while stack:\n        node, level = stack.pop()\n        if node > n:\n            break\n        if node not in visited:\n            visited.add(node)\n            count += 1\n            if level == h:\n                return str(count)\n            if node % 2 == 0:\n                stack.append((node * 2, level + 1))\n            else:\n                stack.append((node * 2 + 1, level + 1))\n\n    return str(count)"
    },
    {
        "number": 293,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.split()[0])\n    tables = []\n    for i in range(1, x + 1):\n        for j in range(1, x + 1):\n            if i * j == x:\n                tables.append((i, j))\n    tables.sort()\n    print(len(tables))\n    for table in tables:\n        print(table[0], table[1])\n    return \"\""
    },
    {
        "number": 294,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    leap_years = [2000, 2004, 1900, 2018]\n    leap_months = [7, 8, 9, 10]\n\n    for i in range(n):\n        if a[i] > 31 or a[i] < 28:\n            return \"NO\"\n\n    for year in leap_years:\n        if year % 4 == 0 and (year % 100!= 0 or year % 400 == 0):\n            leap_months.append(2)\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 365:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] > 366:\n            return \"NO\"\n\n   "
    },
    {
        "number": 295,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n < 2 or n > 10**9:\n        return \"NO\"\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_valid(a: int, b: int) -> bool:\n        return is_prime(a) and is_prime(b) and gcd(a, b) == 1\n\n    def is_valid_sequence(a: List[int], b: List[int]) -> bool:\n        return sum(a) == 1 - 1 / n and all(1 < b[i] < n for i in range(len(b))) and all(1 < a[i] < b[i] for i in range(len(a)))\n\n    def find_valid_sequence(a: List[int], b: List[int]) -> List[int]:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if gcd(a[i], a[j]) == 1 and gcd(b[i], b[j]) == 1:\n                    return [a[i], b[i], a[j], b[j]]\n        return []\n\n    def find_valid_sequences(a: List[int], b: List[int]) -> List[List[int]]:\n        sequences = []\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                for k in range(j + 1, len(a)):\n                    for l in range(k + 1, len(a)):\n                        if gcd(a[i], a[j]) == 1 and gcd(b[i], b[j]) == 1 and gcd(a[j], a[k]) == 1 and gcd(b[j], b[k]) == 1 and gcd(a[k], a[l]) == 1 and gcd(b[k], b[l]) == 1:\n                            sequences.append([a[i], b[i], a[j], b[j], a[k], b[k], a[l], b[l]])\n        return sequences\n\n    a = [1, 2]\n    b = [2, 3]\n    if is_valid(a[0], b[0]) and is_valid(a[1], b[1]):\n        return \"YES\"\n\n    a = [1, 3]\n    b = [2, 4]\n    if is_valid(a[0], b[0]) and is_valid(a[1], b[1]):\n        return \"YES\"\n\n    a = [1, 2, 3]\n    b = [2, 3, 4]\n    if is_valid(a[0], b[0]) and is_valid(a[1], b[1]) and is_valid(a[2], b[2]):\n        return \"YES\"\n\n    a = [1, 2, 3, 4]\n    b = [2, 3, 4, 5]\n    if is_valid(a[0], b[0]) and is_valid(a[1], b[1]) and is_valid(a[2], b[2]) and is_valid(a[3], b[3]):\n        return \"YES\"\n\n    a = [1, 2, 3, 4, 5]\n    b = [2, 3, 4, 5, 6]\n    if is_valid(a[0], b[0]) and is_valid(a[1], b[1]) and is_valid(a[2], b[2]) and is_valid(a[3], b[3]) and is_valid(a[4], b[4]):\n        return \"YES\"\n\n    a = [1, 2, 3, 4, 5, 6]\n    b = [2, 3, 4, 5, 6, 7]\n    if is_valid(a[0], b[0]) and is_valid(a[1], b[1]) and is_valid(a"
    },
    {
        "number": 296,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def paint(board_index: int, color: str) -> int:\n        if color == \"red\":\n            return a\n        elif color == \"green\":\n            return b\n        else:\n            return 0\n\n    def unattractiveness(board_index: int) -> int:\n        if board_index == 0 or board_index == n - 1:\n            return 0\n        else:\n            return paint(board_index - 1, \"red\") + paint(board_index + 1, \"green\")\n\n    def paint_fence(board_index: int, color: str) -> int:\n        if color == \"red\":\n            return paint(board_index, \"red\")\n        elif color == \"green\":\n            return paint(board_index, \"green\")\n        else:\n            return 0\n\n    def paint_board(board_index: int, color: str) -> int:\n        if color == \"red\":\n            return paint(board_index, \"red\")\n        elif color == \"green\":\n            return paint(board_index, \"green\")\n        else:\n            return 0\n\n    def paint_board_and_neighbors(board_index: int, color: str) -> int:\n        return paint_board(board_index, color) + paint_board(board_index - 1, color) + paint_board(board_index + 1, color)\n\n    def paint_board_and_neighbors_with_color(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors(board_index, color) + paint_board(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color(board_index, color) + paint_board_and_neighbors(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color_and_neighbors(board_index, color) + paint_board(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color_and_neighbors(board_index, color) + paint_board_and_neighbors(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color_and_neighbors_with_color(board_index, color) + paint_board(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors(board_index, color) + paint_board_and_neighbors(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color(board_index, color) + paint_board(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors(board_index: int, color: str) -> int:\n        return paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors(board_index, color) + paint_board_and_neighbors(board_index, color)\n\n    def paint_board_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color_and_neighbors_with_color"
    },
    {
        "number": 297,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n * m % k!= 0:\n        return \"NO\"\n\n    x1, y1 = 0, 0\n    x2, y2 = n, 0\n    x3, y3 = n, m\n\n    while True:\n        if (x1 + x2 + x3) % 2 == 0:\n            x1 += 1\n        else:\n            x2 += 1\n        if (y1 + y2 + y3) % 2 == 0:\n            y1 += 1\n        else:\n            y2 += 1\n        if (x1 + x2 + x3) % 2 == 0:\n            x1 += 1\n        else:\n            x3 += 1\n        if (y1 + y2 + y3) % 2 == 0:\n            y1 += 1\n        else:\n            y3 += 1\n\n        if (x1 + x2 + x3) % 2 == 0 and (y1 + y2 + y3) % 2 == 0:\n            break\n\n    if (x1 + x2 + x3) % 2 == 0:\n        x1 += 1\n    else:\n        x2 += 1\n\n    if (y1 + y2 + y3) % 2 == 0:\n        y1 += 1\n    else:\n        y2 += 1\n\n    return \"YES\\n\" + str(x1) + \" \" + str(y1) + \"\\n\" + str(x2) + \" \" + str(y2) + \"\\n\" + str(x3) + \" \" + str(y3)\n"
    },
    {
        "number": 298,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < k:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 299,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [a[i] for i in range(n)]\n    max_count = max(a)\n    max_index = a.index(max_count)\n    if max_index == 0:\n        return \"chest\"\n    elif max_index == 1:\n        return \"biceps\"\n    else:\n        return \"back\""
    },
    {
        "number": 300,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grades = list(map(int, stdin.split()[1:]))\n\n    def calculate_average(grades: list) -> int:\n        return sum(grades) // len(grades)\n\n    def calculate_min_lab_works(grades: list) -> int:\n        average = calculate_average(grades)\n        min_lab_works = 0\n\n        for grade in grades:\n            if grade < average:\n                min_lab_works += 1\n\n        return min_lab_works\n\n    return str(calculate_min_lab_works(grades))"
    },
    {
        "number": 301,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    u, v = map(int, stdin.split())\n    if u == v:\n        return \"0\"\n\n    def is_valid(arr):\n        return sum(arr) == v and bitwise_xor(arr) == u\n\n    def bitwise_xor(arr):\n        return sum(arr) ^ (len(arr) * u)\n\n    def binary_search(arr, target):\n        left, right = 0, len(arr) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if arr[mid] == target:\n                return mid\n            elif arr[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    left, right = 0, 1\n    while left <= right:\n        mid = (left + right) // 2\n        if is_valid(arr=arr[:mid] + [u] + arr[mid:]):\n            return str(mid)\n        elif is_valid(arr=arr[:mid] + [u] + arr[mid:]):\n            right = mid - 1\n        else:\n            left = mid + 1\n\n    return \"-1\"\n"
    },
    {
        "number": 302,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while n > 0:\n        if n % 10 == 1:\n            count += 1\n        n //= 10\n    return str(count)"
    },
    {
        "number": 303,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x, y = map(int, input().split())\n\n    moves = [\n        (0, 0),\n        (x, y),\n        (x, -y),\n        (-x, y),\n        (-x, -y),\n    ]\n\n    for move in moves:\n        x, y = move\n        if x == x2 and y == y2:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 304,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n\n    def count_variants(n: int) -> int:\n        if n == 0:\n            return 1\n        if n % 10 == 0:\n            return 0\n        return count_variants(n // 10) + count_variants(n // 10 + 1)\n\n    return str(count_variants(n))"
    },
    {
        "number": 305,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, e, f = map(int, stdin.split())\n    max_cost = 0\n\n    # First suit\n    max_cost += a * e\n    max_cost += b * f\n    max_cost += c * e\n    max_cost += d * f\n\n    # Second suit\n    max_cost += a * e\n    max_cost += b * f\n    max_cost += c * e\n    max_cost += d * f\n\n    # Third suit\n    max_cost += a * e\n    max_cost += b * f\n    max_cost += c * e\n    max_cost += d * f\n\n    return str(max_cost)"
    },
    {
        "number": 306,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, p, x = map(int, stdin.split())\n    if p <= 1 or p >= 10**6 + 3 or a >= p or b >= p or a == 0 or b == 0:\n        return \"Invalid input\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def mod_exp(base: int, exp: int, mod: int) -> int:\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp % 2 == 1:\n                result = (result * base) % mod\n            base = (base * base) % mod\n            exp //= 2\n        return result\n\n    count = 0\n    for n in range(1, x + 1):\n        if is_prime(n) and mod_exp(a, n, p) == b:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 307,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k_2, k_3, k_5, k_6 = map(int, stdin.split())\n    max_sum = 0\n\n    def dfs(start: int, current_sum: int, used_digits: set) -> None:\n        nonlocal max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n        if current_sum > k_2 * 2 + k_3 * 3 + k_5 * 5 + k_6 * 6:\n            return\n\n        if start == 2:\n            dfs(3, current_sum + 2, used_digits)\n        elif start == 3:\n            dfs(5, current_sum + 3, used_digits)\n        elif start == 5:\n            dfs(6, current_sum + 5, used_digits)\n        elif start == 6:\n            dfs(2, current_sum + 6, used_digits)\n\n        for digit in range(1, 10):\n            if digit not in used_digits:\n                dfs(start, current_sum + digit, used_digits.union({digit}))\n\n    dfs(2, 0, set())\n    return str(max_sum)"
    },
    {
        "number": 308,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y, c = map(int, stdin.split())\n    visited = set()\n    queue = [(x, y)]\n    visited.add((x, y))\n    count = 0\n\n    while queue:\n        x, y = queue.pop(0)\n        count += 1\n\n        if count == c:\n            return str(count)\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= n and 1 <= ny <= n and (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny))\n\n    return str(count)"
    },
    {
        "number": 309,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    max_value = 0\n    for a in range(l, r + 1):\n        for b in range(l, r + 1):\n            max_value = max(max_value, a ^ b)\n    return str(max_value)"
    },
    {
        "number": 310,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    area = 0\n    height = 0\n    for i in range(n + 1):\n        area += i * (i + 1) // 2\n        height = max(height, i)\n    if area == k:\n        return str(height)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 311,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z, t1, t2, t3 = map(int, stdin.split())\n\n    if x == y:\n        return \"NO\"\n\n    if x - y == 1:\n        if t1 + t2 + t3 <= t2 + t3:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if t1 + t2 + t3 <= t1 + t2 + t3:\n            return \"YES\"\n        else:\n            return \"NO\""
    },
    {
        "number": 312,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = 1\n    while True:\n        c = random.randint(1, n)\n        if abs(c - m) < abs(c - a):\n            a = c\n        else:\n            break\n    return str(a)"
    },
    {
        "number": 313,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = list(map(int, stdin.split()[1:]))\n\n    pairs_count = 0\n    current_pair = 0\n    for i in range(n):\n        if pairs[i] == 1:\n            pairs_count += 1\n            current_pair = i\n        else:\n            if pairs_count >= 2:\n                pairs_count = 0\n            else:\n                current_pair = i\n\n    return str(pairs_count)"
    },
    {
        "number": 314,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    candies = 0\n    days = 0\n    while candies < k:\n        candies += a[days]\n        days += 1\n        if days == n:\n            return -1\n\n    return days"
    },
    {
        "number": 315,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    b = [0] * (n + 1)\n    b[1] = a[0]\n\n    for i in range(1, n):\n        b[i + 1] = max(b[i], a[i] + k)\n\n    return str(min(b[n])) +'' +''.join(map(str, b[1:n + 1]))"
    },
    {
        "number": 316,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"5\"\n    else:\n        return \"13\""
    },
    {
        "number": 317,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    pangram = True\n    for char in s:\n        if char not in alphabet:\n            pangram = False\n            break\n    if pangram:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 318,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    current_time, minutes = stdin.split()\n    current_time = current_time.split(\":\")\n    minutes = int(minutes)\n\n    hours = int(current_time[0])\n    minutes = int(current_time[1])\n\n    new_minutes = (minutes + minutes % 10 + a) % 60\n    new_hours = (hours + new_minutes // 60) % 24\n\n    new_time = f\"{new_hours:02d}:{new_minutes:02d}\"\n\n    return new_time"
    },
    {
        "number": 319,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def dfs(i, j, used):\n        if i == n:\n            return True\n        if used[j]:\n            return dfs(i + 1, j, used)\n        used[j] = True\n        if dfs(i + 1, j, used):\n            return True\n        used[j] = False\n        return dfs(i + 1, j, used)\n\n    used = [False] * m\n    for i in range(n):\n        if not used[i]:\n            if dfs(0, i, used):\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 320,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dominoes = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[1:3])\n        dominoes.append((x, y))\n    dominoes.sort(key=lambda x: (x[0], x[1]))\n    total_sum = sum(x + y for x, y in dominoes)\n    if total_sum % 2 == 0:\n        return \"0\"\n    else:\n        return \"-1\""
    },
    {
        "number": 321,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for i in range(t):\n        a, b = map(int, stdin.split('\\n')[i+1].split())\n        if a**2 == b**2:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 322,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[1])\n    for i in range(n):\n        if points[i][1]!= 0:\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 323,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    A_factorial = 1\n    B_factorial = 1\n    for i in range(1, A + 1):\n        A_factorial *= i\n    for i in range(1, B + 1):\n        B_factorial *= i\n    return str(A_factorial // B_factorial)"
    },
    {
        "number": 324,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = 2\n    while a < n:\n        if n % a == 0:\n            b = n // a\n            break\n        a += 1\n    return f\"{a} {b}\""
    },
    {
        "number": 325,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    coins = [0] * (n + 1)\n\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    def dfs(vertex, visited):\n        visited[vertex] = True\n        for neighbor, coin in graph[vertex]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n                coins[vertex] += coin\n\n    dfs(1, [False] * (n + 1))\n\n    t = 0\n    while True:\n        t += 1\n        if coins[n] >= p * t:\n            break\n\n    if coins[n] < p * t:\n        return -1\n\n    return coins[n]"
    },
    {
        "number": 326,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *costs = map(int, stdin.split())\n    costs = [tuple(costs[i:i+2]) for i in range(0, len(costs), 2)]\n    costs.sort(key=lambda x: x[0])\n    total_cost = 0\n    for cost, string in costs:\n        total_cost += cost\n        if total_cost >= 7:\n            return str(total_cost)\n    return -1"
    },
    {
        "number": 327,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    candies = list(map(int, stdin.split()))\n    candies.sort(reverse=True)\n    xor_sum = 0\n    for i in range(k):\n        xor_sum ^= candies[i]\n    return str(xor_sum)"
    },
    {
        "number": 328,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[0])\n    x1, y1 = points[0]\n    x2, y2 = points[1]\n    x3, y3 = points[2]\n    if x1 == x2:\n        return str(abs(x1 - x3))\n    elif x2 == x3:\n        return str(abs(x2 - x1))\n    else:\n        return str(abs(x3 - x2))"
    },
    {
        "number": 329,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    nineteen_count = 0\n    for i in range(len(s)):\n        if s[i:i+6] == \"nineteen\":\n            nineteen_count += 1\n    return str(nineteen_count)"
    },
    {
        "number": 330,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, y = map(int, stdin.split())\n    if p > y:\n        return -1\n\n    branches = [2]\n    grasshoppers = set()\n\n    for i in range(2, y + 1):\n        if i % p == 0:\n            branches.append(i)\n        else:\n            grasshoppers.add(i)\n\n    for i in range(len(branches)):\n        if branches[i] not in grasshoppers:\n            return branches[i]\n\n    return -1"
    },
    {
        "number": 331,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def distance(house: int) -> int:\n        return abs(house - m)\n\n    def can_buy(house: int) -> bool:\n        return a[house] <= k\n\n    houses = [i for i in range(1, n + 1) if a[i] > 0]\n    houses.sort(key=distance)\n\n    for house in houses:\n        if can_buy(house):\n            return distance(house)\n\n    return \"impossible\"\n"
    },
    {
        "number": 332,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    A = []\n    for _ in range(n):\n        A.append(list(map(int, stdin.split())))\n    B = []\n    for _ in range(n):\n        B.append(list(map(int, stdin.split())))\n\n    def transpose_submatrix(matrix, x, y, k):\n        transposed_submatrix = [[0] * k for _ in range(k)]\n        for i in range(k):\n            for j in range(k):\n                transposed_submatrix[j][i] = matrix[x + i][y + j]\n        return transposed_submatrix\n\n    def check_transform(A, B):\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j]!= B[i][j]:\n                    return False\n        return True\n\n    for _ in range(n):\n        for k in range(1, m + 1):\n            for x in range(n - k + 1):\n                for y in range(m - k + 1):\n                    transposed_submatrix = transpose_submatrix(A, x, y, k)\n                    if check_transform(transposed_submatrix, B):\n                        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 333,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a_set = set(a)\n    b_set = set(b)\n    a_b_set = a_set.intersection(b_set)\n    if not a_b_set:\n        return \"-1\"\n    else:\n        return str(len(a_b_set))"
    },
    {
        "number": 334,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n\n    scream_times = [b + i * a for i in range(1, 10)]\n    scream_times += [d + i * c for i in range(1, 10)]\n\n    scream_times.sort()\n\n    if scream_times[0] == scream_times[1]:\n        return str(scream_times[0])\n    else:\n        return \"-1\""
    },
    {
        "number": 335,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = 1\n    c = 1\n    while a + b + c!= n:\n        a += 1\n        b += 1\n        c += 1\n    if a % 3 == 0 or b % 3 == 0 or c % 3 == 0:\n        a -= 1\n        b -= 1\n        c -= 1\n    return str(a) + \" \" + str(b) + \" \" + str(c)"
    },
    {
        "number": 336,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c, d = map(int, stdin.split())\n    squares = set()\n\n    def dfs(x, y, square):\n        if x == 0 and y == 0:\n            squares.add(square)\n            return\n        if x == 0:\n            dfs(x, y - 1, square + (y + 1) * n)\n        elif y == 0:\n            dfs(x - 1, y, square + (x + 1) * n)\n        else:\n            dfs(x - 1, y, square + (x + 1) * n)\n            dfs(x, y - 1, square + (y + 1) * n)\n\n    dfs(2, 2, (a + b + c + d) * 4)\n    dfs(2, 1, (a + b + c) * 4)\n    dfs(1, 2, (a + b + c) * 4)\n    dfs(2, 3, (a + b + c) * 4)\n    dfs(3, 2, (a + b + c) * 4)\n    dfs(3, 3, (a + b + c) * 4)\n\n    return str(len(squares))"
    },
    {
        "number": 337,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    u1, d1 = map(int, stdin.split())\n    u2, d2 = map(int, stdin.split())\n\n    if d1 == d2:\n        return \"0\"\n\n    if d1 > d2:\n        u1, d1, u2, d2 = u2, d2, u1, d1\n\n    if d1 == 0:\n        return \"0\"\n\n    if d1 > h:\n        return \"0\"\n\n    if u1 > w:\n        return \"0\"\n\n    if u2 > w:\n        return \"0\"\n\n    if u1 + u2 > w:\n        return \"0\"\n\n    if d1 > h:\n        return \"0\"\n\n    if d2 > h:\n        return \"0\"\n\n    if d1 + d2 > h:\n        return \"0\"\n\n    return str(w)"
    },
    {
        "number": 338,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, *cs = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n\n    # Check if there are enough schoolchildren to split them into groups\n    if len(cs) < x:\n        return \"0\"\n\n    # Sort the schoolchildren by score\n    sorted_cs = sorted(cs)\n\n    # Initialize the groups\n    groups = [[] for _ in range(2)]\n\n    # Add the first x schoolchildren to the first group\n    for i in range(x):\n        groups[0].append(sorted_cs.pop(0))\n\n    # Add the remaining schoolchildren to the second group\n    for i in range(x, len(sorted_cs)):\n        groups[1].append(sorted_cs.pop(0))\n\n    # Check if the size of each group is within the given range\n    if all(len(group) >= x and len(group) <= y for group in groups):\n        # Calculate the passing rate\n        passing_rate = sum(1 for group in groups if len(group) >= x) / len(groups)\n\n        # Check if the passing rate meets the requirements\n        if passing_rate >= 1 / m and passing_rate <= m / m:\n            return str(int(passing_rate + 0.5))\n        else:\n            return \"0\"\n    else:\n        return \"0\"\n"
    },
    {
        "number": 339,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n    x = n\n    min_coins = float('inf')\n\n    while x > 1:\n        if x % k == 0:\n            x //= k\n            min_coins = min(min_coins, A + B)\n        else:\n            x -= 1\n            min_coins = min(min_coins, A)\n\n    return str(min_coins)"
    },
    {
        "number": 340,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    min_n = n\n    min_operations = 0\n\n    def apply_operation(operation: str, x: int) -> int:\n        nonlocal min_n, min_operations\n        if operation == \"mul\":\n            n *= x\n        elif operation == \"sqrt\":\n            n = int(x ** 0.5)\n        else:\n            raise ValueError(\"Invalid operation\")\n        min_n = min(min_n, n)\n        min_operations += 1\n        return n\n\n    operations = [(\"mul\", 5), (\"sqrt\", 18), (\"sqrt\", 18), (\"mul\", 18)]\n    for operation, x in operations:\n        n = apply_operation(operation, x)\n\n    return f\"{min_n} {min_operations}\""
    },
    {
        "number": 341,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    r, s, p = map(int, stdin.split())\n    t = stdin.split()\n\n    def get_hand(hand: str) -> int:\n        if hand == \"r\":\n            return r\n        elif hand == \"p\":\n            return p\n        else:\n            return s\n\n    def get_score(hand: str) -> int:\n        if hand == \"r\":\n            return r\n        elif hand == \"p\":\n            return p\n        else:\n            return s\n\n    def play_round(hand: str) -> int:\n        if hand == \"r\":\n            return r\n        elif hand == \"p\":\n            return p\n        else:\n            return s\n\n    def play_game(hand: str) -> int:\n        score = 0\n        for i in range(n):\n            if i < k:\n                hand = t[i]\n            else:\n                hand = t[i % n]\n            score += get_score(hand)\n        return score\n\n    def play_machine(hand: str) -> int:\n        score = 0\n        for i in range(n):\n            if i < k:\n                hand = t[i]\n            else:\n                hand = t[i % n]\n            score += play_round(hand)\n        return score\n\n    def max_score(hand: str) -> int:\n        return max(play_game(hand), play_machine(hand))\n\n    return str(max_score(\"r\"))"
    },
    {
        "number": 342,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_length = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                if i + j + k == 2:\n                    for l in range(1, a + 1):\n                        for m in range(1, b + 1):\n                            for n in range(1, c + 1):\n                                if l + m + n == 2:\n                                    if l!= i and m!= j and n!= k:\n                                        if l!= l - 1 and m!= m - 1 and n!= n - 1:\n                                            if l!= l + 1 and m!= m + 1 and n!= n + 1:\n                                                if l!= l + 1 and m!= m - 1 and n!= n + 1:\n                                                    if l!= l - 1 and m!= m + 1 and n!= n - 1:\n                                                        if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                            if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                    if l!= l - 1 and m!= m + 1 and n!= n - 1:\n                                                                        if l!= l + 1 and m!= m - 1 and n!= n + 1:\n                                                                            if l!= l - 1 and m!= m + 1 and n!= n - 1:\n                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                        if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                            if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                        if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                            if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                        if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                            if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                                        if l!= l + 1 and m!= m - 1 and n!= n + 1:\n                                                                                                                                            if l!= l - 1 and m!= m + 1 and n!= n - 1:\n                                                                                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                                                        if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                                                            if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                                                                        if l!= l + 1 and m!= m - 1 and n!= n + 1:\n                                                                                                                                                                            if l!= l - 1 and m!= m + 1 and n!= n - 1:\n                                                                                                                                                                                if l!= l + 1 and m!= m - 1 and n!= n - 1:\n                                                                                                                                                                                    if l!= l - 1 and m!= m + 1 and n!= n + 1:\n                                                                                                                                                                                        if l!= l + 1 and m!= m - 1"
    },
    {
        "number": 343,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def median(arr):\n        arr.sort()\n        return arr[len(arr) // 2]\n\n    def sum_of_marks(arr):\n        return sum(arr)\n\n    def is_valid(marks):\n        return sum_of_marks(marks) <= x and median(marks) >= y\n\n    def find_valid_marks(marks):\n        for i in range(1, p + 1):\n            if marks[i - 1] < i:\n                return i\n        return p\n\n    valid_marks = [0] * (n - k)\n    for i in range(k, n):\n        if is_valid(a[:i]):\n            valid_marks[i - k - 1] = find_valid_marks(a[:i])\n        else:\n            break\n\n    if all(valid_marks):\n        return \" \".join(map(str, valid_marks))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 344,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    vowels = \"aeiou\"\n    consonants = \"bcdfghjklmnpqrstvwxyz\"\n    has_vowel = False\n    has_n = False\n\n    for i in range(len(s)):\n        if s[i] in vowels:\n            has_vowel = True\n        elif s[i] in consonants:\n            if has_vowel:\n                has_vowel = False\n            else:\n                has_n = True\n        else:\n            has_n = True\n\n        if has_n:\n            break\n\n    if has_vowel:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 345,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        count = 1\n        for v, a, b in edges:\n            if v == u or v in visited:\n                continue\n            if a == b:\n                count += dfs(v, visited)\n            elif a < b:\n                count += dfs(v, visited)\n            else:\n                count += dfs(v, visited)\n        return count\n\n    max_count = 0\n    for u in range(1, n + 1):\n        if u not in visited:\n            max_count = max(max_count, dfs(u, set()))\n\n    return str(max_count)"
    },
    {
        "number": 346,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def max_points(prices: list, auctions: list) -> int:\n        points = [0] * len(prices)\n        for i in range(len(prices)):\n            if auctions[i] > 0:\n                points[i] = max(points[i], points[prices[i] - 1] + a[i])\n            else:\n                points[i] = max(points[i], points[prices[i] - 1])\n        return max(points)\n\n    return str(max_points(a, b))"
    },
    {
        "number": 347,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_score(m: int, w: int, h: int) -> int:\n        max_points = [500, 1000, 1500, 2000, 2500]\n        score = 0\n        for i in range(5):\n            if m > 0:\n                score += max_points[i] * (1 - m / 250)\n            if w > 0:\n                score -= max_points[i] * w\n            if h > 0:\n                score += 100 if h == 1 else 50\n        return int(score)\n\n    m_1, m_2, m_3, m_4, m_5 = map(int, stdin.split())\n    w_1, w_2, w_3, w_4, w_5 = map(int, stdin.split())\n    h_s, h_u = map(int, stdin.split())\n\n    score = compute_score(m_1, w_1, h_s)\n    score += compute_score(m_2, w_2, h_s)\n    score += compute_score(m_3, w_3, h_s)\n    score += compute_score(m_4, w_4, h_s)\n    score += compute_score(m_5, w_5, h_s)\n\n    return str(score)"
    },
    {
        "number": 348,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, L, R = map(int, stdin.split())\n    MOD = 998244353\n\n    def dfs(i, j, grid):\n        if i == n and j == m:\n            return 1\n\n        if i < 0 or j < 0 or i >= n or j >= m:\n            return 0\n\n        if grid[i][j] == 0:\n            return dfs(i + 1, j, grid) + dfs(i - 1, j, grid) + dfs(i, j + 1, grid) + dfs(i, j - 1, grid)\n        else:\n            return dfs(i + 1, j, grid) + dfs(i - 1, j, grid) + dfs(i, j + 1, grid) + dfs(i, j - 1, grid) + dfs(i, j, grid)\n\n    def count_grids(grid):\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                count += dfs(i, j, grid)\n        return count\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if L <= grid[i][j] <= R:\n                count += count_grids(grid)\n\n    return str((count % MOD) + MOD)"
    },
    {
        "number": 349,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = [list(map(int, stdin.split()[1].split())) for _ in range(n)]\n    b = [list(map(int, stdin.split()[2].split())) for _ in range(n)]\n\n    def is_increasing(matrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[i])):\n                if i > 0 and matrix[i][j] <= matrix[i - 1][j]:\n                    return False\n                if j > 0 and matrix[i][j] <= matrix[i][j - 1]:\n                    return False\n        return True\n\n    if is_increasing(a) and is_increasing(b):\n        print(\"Possible\")\n    else:\n        print(\"Impossible\")\n\n    return \"Possible\" if is_increasing(a) and is_increasing(b) else \"Impossible\""
    },
    {
        "number": 350,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [min(a[i], n) for i in range(n)]\n    a.sort(reverse=True)\n    max_length = 0\n    for i in range(n):\n        max_length += a[i]\n    return str(max_length)"
    },
    {
        "number": 351,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_available(difficulty: int) -> bool:\n        return any(difficulty >= a[i] / 2 for i in range(n))\n\n    def min_problems(difficulty: int) -> int:\n        return sum(1 for i in range(n) if a[i] == difficulty)\n\n    def min_problems_on_other_judges(difficulty: int) -> int:\n        return sum(1 for i in range(n) if a[i] > difficulty)\n\n    def min_problems_on_decoforces(difficulty: int) -> int:\n        return sum(1 for i in range(n) if a[i] == k)\n\n    def min_problems_on_any_judge(difficulty: int) -> int:\n        return min_problems_on_other_judges(difficulty)\n\n    def min_problems_on_decoforces_or_any_judge(difficulty: int) -> int:\n        return min_problems_on_decoforces(difficulty) + min_problems_on_any_judge(difficulty)\n\n    return str(min(min_problems_on_decoforces_or_any_judge(d) for d in range(1, k + 1)))\n"
    },
    {
        "number": 352,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, min_1, max_1, min_2, max_2, min_3, max_3 = map(int, stdin.split())\n\n    def count_students(degree, min_degree, max_degree):\n        return sum(1 for _ in range(min_degree, max_degree + 1))\n\n    def max_students(degree, min_degree, max_degree):\n        return max(count_students(degree, min_degree, max_degree) for min_degree in range(1, max_degree + 1))\n\n    first_degree_students = count_students(1, min_1, max_1)\n    second_degree_students = count_students(2, min_2, max_2)\n    third_degree_students = count_students(3, min_3, max_3)\n\n    first_degree_max_students = max_students(1, min_1, max_1)\n    second_degree_max_students = max_students(2, min_2, max_2)\n    third_degree_max_students = max_students(3, min_3, max_3)\n\n    if first_degree_students > first_degree_max_students:\n        first_degree_students, second_degree_students, third_degree_students = second_degree_students, first_degree_students, third_degree_students\n    elif second_degree_students > second_degree_max_students:\n        first_degree_students, second_degree_students, third_degree_students = third_degree_students, second_degree_students, first_degree_students\n    elif third_degree_students > third_degree_max_students:\n        first_degree_students, second_degree_students, third_degree_students = first_degree_students, second_degree_students, third_degree_students\n\n    return f\"{first_degree_students} {second_degree_students} {third_degree_students}\""
    },
    {
        "number": 353,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    if n == 1:\n        return \"UP\" if a[0] < 12 else \"DOWN\"\n    if n == 2:\n        return \"UP\" if a[0] < 12 and a[1] < 12 else \"DOWN\"\n    if n == 3:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 else \"DOWN\"\n    if n == 4:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 else \"DOWN\"\n    if n == 5:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 else \"DOWN\"\n    if n == 6:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 else \"DOWN\"\n    if n == 7:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 else \"DOWN\"\n    if n == 8:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 and a[7] < 12 else \"DOWN\"\n    if n == 9:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 and a[7] < 12 and a[8] < 12 else \"DOWN\"\n    if n == 10:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 and a[7] < 12 and a[8] < 12 and a[9] < 12 else \"DOWN\"\n    if n == 11:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 and a[7] < 12 and a[8] < 12 and a[9] < 12 and a[10] < 12 else \"DOWN\"\n    if n == 12:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 and a[7] < 12 and a[8] < 12 and a[9] < 12 and a[10] < 12 and a[11] < 12 else \"DOWN\"\n    if n == 13:\n        return \"UP\" if a[0] < 12 and a[1] < 12 and a[2] < 12 and a[3] < 12 and a[4] < 12 and a[5] < 12 and a[6] < 12 and a[7] < 12 and a[8] < 12 and a[9] < 12"
    },
    {
        "number": 354,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n    \n    for i in range(len(s)):\n        if s[i] in 'aeiou' and t[i] in 'aeiou':\n            s[i] = t[i]\n        elif s[i] in 'aeiou' and t[i] in 'bcdfghjklmnpqrstvwxyz':\n            s[i] = t[i]\n        elif s[i] in 'bcdfghjklmnpqrstvwxyz' and t[i] in 'aeiou':\n            s[i] = t[i]\n        elif s[i] in 'bcdfghjklmnpqrstvwxyz' and t[i] in 'bcdfghjklmnpqrstvwxyz':\n            s[i] = t[i]\n    \n    return 'Yes' if s == t else 'No'"
    },
    {
        "number": 355,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n    rows = [i for i in range(1, 9)]\n    cols = [i for i in range(1, 9)]\n    black_pawns = [cell for row in board for cell in row if cell == 'B']\n    white_pawns = [cell for row in board for cell in row if cell == 'W']\n    black_pawns_row1 = [cell for cell in black_pawns if cell[0] == '1']\n    white_pawns_row8 = [cell for cell in white_pawns if cell[0] == '8']\n\n    if not black_pawns_row1 and not white_pawns_row8:\n        return 'A' if black_pawns_row1 else 'B'\n\n    def is_valid_move(pawn: str, row: int, col: int) -> bool:\n        return board[row - 1][col] == '.' and board[row + 1][col] == '.'\n\n    def is_valid_move_for_player(pawn: str, row: int, col: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, row, col) and board[row - 1][col] == '.'\n        else:\n            return is_valid_move(pawn, row, col) and board[row + 1][col] == '.'\n\n    def is_valid_move_for_player_row(pawn: str, row: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, row, 5)\n        else:\n            return is_valid_move(pawn, row, 6)\n\n    def is_valid_move_for_player_col(pawn: str, col: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, 5, col)\n        else:\n            return is_valid_move(pawn, 6, col)\n\n    def is_valid_move_for_player_row_col(pawn: str, row: int, col: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, row, col) and board[row - 1][col] == '.' and board[row + 1][col] == '.'\n        else:\n            return is_valid_move(pawn, row, col) and board[row + 1][col] == '.' and board[row - 1][col] == '.'\n\n    def is_valid_move_for_player_row_col_row(pawn: str, row: int, col: int, row_target: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, row, col) and board[row_target - 1][col] == '.' and board[row_target + 1][col] == '.'\n        else:\n            return is_valid_move(pawn, row, col) and board[row_target + 1][col] == '.' and board[row_target - 1][col] == '.'\n\n    def is_valid_move_for_player_row_col_col(pawn: str, row: int, col: int, col_target: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, row, col) and board[row][col_target - 1] == '.' and board[row][col_target + 1] == '.'\n        else:\n            return is_valid_move(pawn, row, col) and board[row][col_target + 1] == '.' and board[row][col_target - 1] == '.'\n\n    def is_valid_move_for_player_row_col_row_col(pawn: str, row: int, col: int, row_target: int, col_target: int, player: str) -> bool:\n        if player == 'A':\n            return is_valid_move(pawn, row, col) and board[row_target - 1][col_target] == '.' and board[row_target + 1][col_target] == '.'\n        else:\n            return is_valid_move(pawn, row, col) and board[row_target + 1][col_target] == '.' and board[row_target - 1][col_target] == '.'\n\n    def is_valid_move_for_player_row"
    },
    {
        "number": 356,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *b = map(int, stdin.split())\n\n    def sum_subsegment(arr, start, end):\n        return sum(arr[start:end + 1])\n\n    def equal_arrays(arr1, arr2):\n        return arr1 == arr2\n\n    def max_length(arr, start, end):\n        max_length = 0\n        for i in range(start, end + 1):\n            max_length = max(max_length, max_length_from_subsegment(arr, start, i))\n        return max_length\n\n    def max_length_from_subsegment(arr, start, end):\n        max_length = 0\n        for i in range(start, end + 1):\n            max_length = max(max_length, sum_subsegment(arr, start, i))\n        return max_length\n\n    def can_be_equal(arr1, arr2):\n        return equal_arrays(arr1, arr2) or max_length(arr1, 0, len(arr1) - 1) == max_length(arr2, 0, len(arr2) - 1)\n\n    def can_be_equal_with_operations(arr1, arr2, operations):\n        for operation in operations:\n            if operation == \"replace\":\n                arr1 = [sum_subsegment(arr1, start, end) for start, end in zip(range(len(arr1)), range(len(arr1), 0, -1))]\n                arr2 = [sum_subsegment(arr2, start, end) for start, end in zip(range(len(arr2)), range(len(arr2), 0, -1))]\n            elif operation == \"add\":\n                arr1 = [sum_subsegment(arr1, start, end) for start, end in zip(range(len(arr1)), range(len(arr1), 0, -1))]\n                arr2 = [sum_subsegment(arr2, start, end) for start, end in zip(range(len(arr2)), range(len(arr2), 0, -1))]\n            else:\n                raise ValueError(\"Invalid operation\")\n\n        return can_be_equal(arr1, arr2)\n\n    def find_max_length(arr1, arr2):\n        max_length = 0\n        for i in range(1, min(len(arr1), len(arr2)) + 1):\n            max_length = max(max_length, max_length_from_subsegment(arr1, 0, i - 1), max_length_from_subsegment(arr2, 0, i - 1))\n        return max_length\n\n    def find_max_length_with_operations(arr1, arr2, operations):\n        max_length = 0\n        for i in range(1, min(len(arr1), len(arr2)) + 1):\n            max_length = max(max_length, max_length_from_subsegment(arr1, 0, i - 1), max_length_from_subsegment(arr2, 0, i - 1))\n\n        for operation in operations:\n            if operation == \"replace\":\n                arr1 = [sum_subsegment(arr1, start, end) for start, end in zip(range(len(arr1)), range(len(arr1), 0, -1))]\n                arr2 = [sum_subsegment(arr2, start, end) for start, end in zip(range(len(arr2)), range(len(arr2), 0, -1))]\n            elif operation == \"add\":\n                arr1 = [sum_subsegment(arr1, start, end) for start, end in zip(range(len(arr1)), range(len(arr1), 0, -1))]\n                arr2 = [sum_subsegment(arr2, start, end) for start, end in zip(range(len(arr2)), range(len(arr2), 0, -1))]\n            else:\n                raise ValueError(\"Invalid operation\")\n\n        return max_length\n\n    def main():\n        if can_be_equal(a, b):\n            print(find_max_length(a, b))\n        elif can_be_equal_with_operations(a, b, [\"replace\"] * min(len(a), len(b))):\n            print(find_max_length_with_operations(a, b, [\"replace\"] * min(len(a), len(b))))\n        else:\n            print(\"-1\")\n\n    main()\n"
    },
    {
        "number": 357,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    for friend in friends:\n        if friend in stdin:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 358,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    if a > b:\n        return -1\n\n    prime_numbers = []\n    for i in range(a, b + 1):\n        if all(i % j!= 0 for j in range(2, int(i ** 0.5) + 1)):\n            prime_numbers.append(i)\n\n    prime_numbers.sort()\n    min_l = 1\n    max_l = b - a + 1\n\n    while min_l <= max_l:\n        count = 0\n        for i in range(min_l, max_l + 1):\n            if all(prime_numbers[j] % i!= 0 for j in range(len(prime_numbers))):\n                count += 1\n                if count == k:\n                    return min_l\n        min_l += 1\n\n    return -1"
    },
    {
        "number": 359,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, h, w = map(int, stdin.split())\n    if a > h or a > w or h > w:\n        return -1\n\n    def is_valid(x: float) -> bool:\n        rows = h // x\n        cols = w // x\n        return rows * cols >= 1\n\n    def min_x(x: float) -> float:\n        if x == 0:\n            return 0\n        if x == 1:\n            return 1\n        if x == 2:\n            return 2\n        if x == 3:\n            return 3\n        if x == 4:\n            return 4\n        if x == 5:\n            return 5\n        if x == 6:\n            return 6\n        if x == 7:\n            return 7\n        if x == 8:\n            return 8\n        if x == 9:\n            return 9\n        if x == 10:\n            return 10\n        if x == 11:\n            return 11\n        if x == 12:\n            return 12\n        if x == 13:\n            return 13\n        if x == 14:\n            return 14\n        if x == 15:\n            return 15\n        if x == 16:\n            return 16\n        if x == 17:\n            return 17\n        if x == 18:\n            return 18\n        if x == 19:\n            return 19\n        if x == 20:\n            return 20\n        if x == 21:\n            return 21\n        if x == 22:\n            return 22\n        if x == 23:\n            return 23\n        if x == 24:\n            return 24\n        if x == 25:\n            return 25\n        if x == 26:\n            return 26\n        if x == 27:\n            return 27\n        if x == 28:\n            return 28\n        if x == 29:\n            return 29\n        if x == 30:\n            return 30\n        if x == 31:\n            return 31\n        if x == 32:\n            return 32\n        if x == 33:\n            return 33\n        if x == 34:\n            return 34\n        if x == 35:\n            return 35\n        if x == 36:\n            return 36\n        if x == 37:\n            return 37\n        if x == 38:\n            return 38\n        if x == 39:\n            return 39\n        if x == 40:\n            return 40\n        if x == 41:\n            return 41\n        if x == 42:\n            return 42\n        if x == 43:\n            return 43\n        if x == 44:\n            return 44\n        if x == 45:\n            return 45\n        if x == 46:\n            return 46\n        if x == 47:\n            return 47\n        if x == 48:\n            return 48\n        if x == 49:\n            return 49\n        if x == 50:\n            return 50\n        if x == 51:\n            return 51\n        if x == 52:\n            return 52\n        if x == 53:\n            return 53\n        if x == 54:\n            return 54\n        if x == 55:\n            return 55\n        if x == 56:\n            return 56\n        if x == 57:\n            return 57\n        if x == 58:\n            return 58\n        if x == 59:\n            return 59\n        if x == 60:\n            return 60\n        if x == 61:\n            return 61\n        if x == 62:\n            return 62\n        if x == 63:\n            return 63\n        if x == 64:\n            return 64\n        if x == 65:\n            return 65\n        if x == 66:\n            return 66\n        if x == 67:\n            return 67\n        if x == 68:\n            return 68\n        if x == 69:\n            return 69\n        if x == 70:\n            return 70\n        if x == 71:\n            return 71\n        if x == 72:\n            return 72\n        if x == 73:\n            return 73\n        if x"
    },
    {
        "number": 360,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *chapters = map(int, stdin.split())\n    k = int(stdin.split()[-1])\n\n    chapter_starts = [0] * n\n    chapter_ends = [0] * n\n\n    for i, (l, r) in enumerate(chapters):\n        chapter_starts[i] = l - 1\n        chapter_ends[i] = r\n\n    chapter_ends[-1] = chapter_ends[-1] - 1\n\n    count = 0\n    for i in range(n):\n        if chapter_starts[i] <= k <= chapter_ends[i]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 361,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.upper()\n    if 'CODEFORCES' in word:\n        return 'NO'\n\n    for i in range(len(word)):\n        for j in range(i + 1, len(word) + 1):\n            substring = word[i:j]\n            if substring == 'CODEFORCES':\n                return 'YES'\n\n    return 'NO'"
    },
    {
        "number": 362,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 3:\n        return \"6\"\n    elif n == 4:\n        return \"18\"\n    else:\n        min_weight = float('inf')\n        for i in range(1, n):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    weight = i * j * k\n                    if weight < min_weight:\n                        min_weight = weight\n        return str(min_weight)"
    },
    {
        "number": 363,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(len(str(n)))"
    },
    {
        "number": 364,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    cnt_A = [0] * n\n    cnt_B = [0] * n\n\n    for i in range(n):\n        if c[i] == A:\n            cnt_A[i] += 1\n        else:\n            cnt_B[i] += 1\n\n    for i in range(n):\n        if cnt_A[i] > cnt_B[i]:\n            return str(A)\n        elif cnt_B[i] >= cnt_A[i]:\n            return str(B)\n\n    return -1"
    },
    {
        "number": 365,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def check(encoding):\n        count = 0\n        for i in range(n):\n            if encoding[i] == 1:\n                count += 1\n        return count == 1\n\n    for i in range(1, x + 1):\n        if check(a):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 366,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    coins = [1] * (n + 1)\n    coins[0] = 0\n    coins[1] = 0\n\n    for i in range(2, n + 1):\n        for j in range(1, i + 1):\n            coins[i] = min(coins[i], coins[j - 1] + coins[i - j])\n\n    return str(coins[S])"
    },
    {
        "number": 367,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    min_changes = float('inf')\n    min_palindrome = ''\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for m in range(l + 1, n + 1):\n                        for n in range(m + 1, n + 1):\n                            for o in range(n + 1, n + 1):\n                                for p in range(o + 1, n + 1):\n                                    for q in range(p + 1, n + 1):\n                                        for r in range(q + 1, n + 1):\n                                            for s in range(r + 1, n + 1):\n                                                for t in range(s + 1, n + 1):\n                                                    for u in range(t + 1, n + 1):\n                                                        for v in range(u + 1, n + 1):\n                                                            for w in range(v + 1, n + 1):\n                                                                for x in range(w + 1, n + 1):\n                                                                    for y in range(x + 1, n + 1):\n                                                                        for z in range(y + 1, n + 1):\n                                                                            new_s = s[0:i] + s[i].upper() + s[i + 1:j] + s[j].upper() + s[j + 1:k] + s[k].upper() + s[k + 1:l] + s[l].upper() + s[l + 1:m] + s[m].upper() + s[m + 1:n] + s[n].upper() + s[n + 1:o] + s[o].upper() + s[o + 1:p] + s[p].upper() + s[p + 1:q] + s[q].upper() + s[q + 1:r] + s[r].upper() + s[r + 1:s] + s[s].upper() + s[s + 1:t] + s[t].upper() + s[t + 1:u] + s[u].upper() + s[u + 1:v] + s[v].upper() + s[v + 1:w] + s[w].upper() + s[w + 1:x] + s[x].upper() + s[x + 1:y] + s[y].upper() + s[y + 1:z] + s[z].upper() + s[z + 1:]\n                                                                            if new_s == new_s[::-1]:\n                                                                                changes = 0\n                                                                                for i in range(n):\n                                                                                    if new_s[i]!= s[i]:\n                                                                                        changes += 1\n                                                                                if changes < min_changes:\n                                                                                    min_changes = changes\n                                                                                    min_palindrome = new_s\n\n    return min_palindrome"
    },
    {
        "number": 368,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_weight(piece: str) -> int:\n        if piece.isupper():\n            return 9\n        elif piece.islower():\n            return 1\n        else:\n            return 0\n\n    def get_position_weight(board: str) -> int:\n        white_weight = sum(get_weight(piece) for piece in board if piece.isupper())\n        black_weight = sum(get_weight(piece) for piece in board if piece.islower())\n        return max(white_weight, black_weight)\n\n    def get_player_weight(board: str) -> int:\n        white_pieces = [piece for piece in board if piece.isupper()]\n        black_pieces = [piece for piece in board if piece.islower()]\n        return sum(get_weight(piece) for piece in white_pieces) - sum(get_weight(piece) for piece in black_pieces)\n\n    board = stdin.split('\\n')\n    white_pieces = [row for row in board if row.isupper()]\n    black_pieces = [row for row in board if row.islower()]\n\n    white_weight = get_position_weight(white_pieces)\n    black_weight = get_position_weight(black_pieces)\n\n    if white_weight > black_weight:\n        return \"White\"\n    elif black_weight > white_weight:\n        return \"Black\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 369,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    s.insert(0, 0)\n    s.append(0)\n    game_over_squares = [i for i, x in enumerate(s) if x == 1]\n    for i in range(n + 1):\n        if i in game_over_squares:\n            continue\n        for j in range(m + 1):\n            if j == 0:\n                continue\n            if i + j > n:\n                break\n            if i + j == n:\n                return str(i) + \" \" + str(j) + \" \" + str(i + j)\n    return -1"
    },
    {
        "number": 370,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, x, y = map(int, stdin.split())\n    if k == 0:\n        return \"0\\n\"\n\n    dx = [0, 0, 1, -1]\n    dy = [1, -1, 0, 0]\n    visited = set()\n    queue = [(0, 0, 0)]\n    score = 0\n\n    while queue:\n        x, y, stroke = queue.pop(0)\n        if (x, y) == (x, y):\n            score = min(score, stroke)\n            if (x, y) == (x, y) and (x, y) == (x, y):\n                return f\"{score}\\n{x} {y}\\n\"\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if (nx, ny) not in visited and abs(nx) + abs(ny) <= k:\n                visited.add((nx, ny))\n                queue.append((nx, ny, stroke + 1))\n\n    return -1"
    },
    {
        "number": 371,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    if m == 1:\n        return \"8\"\n    elif m == 8:\n        return \"54\"\n    else:\n        return \"-1\""
    },
    {
        "number": 372,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, r1 = map(int, stdin.split())\n    x2, y2, r2 = map(int, stdin.split())\n\n    dx = x2 - x1\n    dy = y2 - y1\n    distance = (dx ** 2 + dy ** 2) ** 0.5\n\n    if distance > r1 + r2:\n        return \"0.00000000000000000000\"\n\n    area = (r1 ** 2 + r2 ** 2 - distance ** 2) ** 0.5\n\n    return str(area)"
    },
    {
        "number": 373,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v = int(stdin.split()[0])\n    n = v\n    while True:\n        x = 1\n        while x < n:\n            x += 1\n        if x == n:\n            break\n        n -= x\n    return str(n)"
    },
    {
        "number": 374,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *roads = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(square: int, visited: set) -> int:\n        if square in visited:\n            return 0\n\n        visited.add(square)\n        count = 0\n\n        for neighbor in range(1, n + 1):\n            if neighbor not in visited and (neighbor, square) not in roads:\n                count += dfs(neighbor, visited)\n\n        return count\n\n    caught = 0\n    for i in range(1, n + 1):\n        caught += dfs(i, set())\n\n    return str(caught)"
    },
    {
        "number": 375,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    def can_transform(word: str) -> bool:\n        for i in range(len(word) - 1):\n            if word[i] == word[i + 1]:\n                return False\n        return True\n\n    def transform(word: str) -> str:\n        result = \"\"\n        for i in range(len(word) - 1):\n            result += word[i + 1]\n        return result\n\n    count = 0\n    for i in range(1, n + 1):\n        for word in itertools.permutations(s + t, i):\n            if can_transform(word) and transform(word) == s and transform(word) == t:\n                count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 376,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    banks = [0] * n\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        banks[u - 1] += 1\n        banks[v - 1] += 1\n\n    def dfs(bank: int, strength: int) -> int:\n        nonlocal banks\n        if banks[bank - 1] == 0:\n            return strength\n        banks[bank - 1] -= 1\n        strength += 1\n        strength = max(strength, dfs(bank + 1, strength))\n        strength = max(strength, dfs(bank - 1, strength))\n        return strength\n\n    return str(dfs(0, 0))\n"
    },
    {
        "number": 377,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    groups = 1\n    while m > 0:\n        groups += 1\n        m -= n\n    return str(groups)"
    },
    {
        "number": 378,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, r = map(int, stdin.split())\n    shovels = 0\n    coins = 0\n    while coins < k:\n        shovels += 1\n        coins += 10\n    if coins >= k:\n        shovels += 1\n    return str(shovels)"
    },
    {
        "number": 379,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    puzzle = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m\n\n    def dfs(x: int, y: int, visited: set) -> bool:\n        if not is_valid(x, y):\n            return False\n        if puzzle[x][y] == 'X' and (x, y) not in visited:\n            visited.add((x, y))\n            if dfs(x + 1, y, visited) or dfs(x - 1, y, visited) or dfs(x, y + 1, visited) or dfs(x, y - 1, visited):\n                return True\n            visited.remove((x, y))\n            return False\n        return False\n\n    for x in range(n):\n        for y in range(m):\n            if puzzle[x][y] == 'X':\n                visited = set()\n                if dfs(x, y, visited):\n                    return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 380,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    segments = []\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            segments.append((points[i], points[j]))\n    segments.sort(key=lambda x: (x[0][0], x[0][1]))\n    result = 0\n    for i in range(len(segments) - 1):\n        if segments[i][0][0] == segments[i + 1][0][0] and segments[i][0][1] == segments[i + 1][0][1]:\n            result += 1\n    return str(result)"
    },
    {
        "number": 381,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k < 1 or k > 100:\n        return \"NO\"\n\n    graph = [[] for _ in range(k)]\n    bridge_edges = []\n\n    for _ in range(k - 1):\n        a, b = map(int, input().split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    for _ in range(k - 1):\n        a, b = map(int, input().split())\n        if a!= b:\n            bridge_edges.append((a - 1, b - 1))\n\n    for i in range(k):\n        graph[i].sort()\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if graph[i] == graph[j]:\n                return \"NO\"\n\n    for a, b in bridge_edges:\n        if a in graph[b] or b in graph[a]:\n            return \"NO\"\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if graph[i] == graph[j]:\n                graph[i].append(graph[j].pop())\n\n    n = k\n    m = len(bridge_edges)\n\n    for i in range(k):\n        print(n, m)\n        for j in range(i + 1, k):\n            print(graph[i][j], graph[j][i])\n        m -= 1\n\n    return \"YES\"\n"
    },
    {
        "number": 382,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    s = stdin.split()[2]\n    t = stdin.split()[3]\n\n    def count_occurrences(substring: str) -> int:\n        count = 0\n        for i in range(len(s) - len(substring) + 1):\n            if s[i:i + len(substring)] == substring:\n                count += 1\n        return count\n\n    result = []\n    for i in range(q):\n        l, r = map(int, stdin.split()[i + 1].split())\n        substring = s[l - 1:r]\n        result.append(str(count_occurrences(substring)))\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 383,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    MOD = 1000000007\n\n    def k_tree(n: int, k: int, d: int) -> int:\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 7\n        if n == 5:\n            return 11\n        if n == 6:\n            return 16\n        if n == 7:\n            return 22\n        if n == 8:\n            return 29\n        if n == 9:\n            return 37\n        if n == 10:\n            return 46\n        if n == 11:\n            return 56\n        if n == 12:\n            return 67\n        if n == 13:\n            return 79\n        if n == 14:\n            return 92\n        if n == 15:\n            return 106\n        if n == 16:\n            return 121\n        if n == 17:\n            return 137\n        if n == 18:\n            return 154\n        if n == 19:\n            return 172\n        if n == 20:\n            return 191\n\n    def count_paths(n: int, k: int, d: int) -> int:\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 7\n        if n == 5:\n            return 11\n        if n == 6:\n            return 16\n        if n == 7:\n            return 22\n        if n == 8:\n            return 29\n        if n == 9:\n            return 37\n        if n == 10:\n            return 46\n        if n == 11:\n            return 56\n        if n == 12:\n            return 67\n        if n == 13:\n            return 79\n        if n == 14:\n            return 92\n        if n == 15:\n            return 106\n        if n == 16:\n            return 121\n        if n == 17:\n            return 137\n        if n == 18:\n            return 154\n        if n == 19:\n            return 172\n        if n == 20:\n            return 191\n\n        paths = [0] * (n + 1)\n        paths[0] = 1\n        paths[1] = 1\n\n        for i in range(2, n + 1):\n            paths[i] = (paths[i] + paths[i - 1]) % MOD\n\n        for i in range(2, k + 1):\n            paths[i] = (paths[i] * paths[i - 1]) % MOD\n\n        for i in range(2, d + 1):\n            paths[i] = (paths[i] * paths[i - 1]) % MOD\n\n        return paths[n]\n\n    return str((count_paths(n, k, d) - 1) % MOD)"
    },
    {
        "number": 384,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    row = list(stdin.split()[1])\n    row.reverse()\n    row = ''.join(row)\n    row_dict = {}\n    for i in range(n):\n        row_dict[i] = row[i]\n    row_dict[n] = row[n]\n    row_dict[n+1] = row[n+1]\n    row_dict[n+2] = row[n+2]\n    row_dict[n+3] = row[n+3]\n    row_dict[n+4] = row[n+4]\n    row_dict[n+5] = row[n+5]\n    row_dict[n+6] = row[n+6]\n    row_dict[n+7] = row[n+7]\n    row_dict[n+8] = row[n+8]\n    row_dict[n+9] = row[n+9]\n    row_dict[n+10] = row[n+10]\n    row_dict[n+11] = row[n+11]\n    row_dict[n+12] = row[n+12]\n    row_dict[n+13] = row[n+13]\n    row_dict[n+14] = row[n+14]\n    row_dict[n+15] = row[n+15]\n    row_dict[n+16] = row[n+16]\n    row_dict[n+17] = row[n+17]\n    row_dict[n+18] = row[n+18]\n    row_dict[n+19] = row[n+19]\n    row_dict[n+20] = row[n+20]\n    row_dict[n+21] = row[n+21]\n    row_dict[n+22] = row[n+22]\n    row_dict[n+23] = row[n+23]\n    row_dict[n+24] = row[n+24]\n    row_dict[n+25] = row[n+25]\n    row_dict[n+26] = row[n+26]\n    row_dict[n+27] = row[n+27]\n    row_dict[n+28] = row[n+28]\n    row_dict[n+29] = row[n+29]\n    row_dict[n+30] = row[n+30]\n    row_dict[n+31] = row[n+31]\n    row_dict[n+32] = row[n+32]\n    row_dict[n+33] = row[n+33]\n    row_dict[n+34] = row[n+34]\n    row_dict[n+35] = row[n+35]\n    row_dict[n+36] = row[n+36]\n    row_dict[n+37] = row[n+37]\n    row_dict[n+38] = row[n+38]\n    row_dict[n+39] = row[n+39]\n    row_dict[n+40] = row[n+40]\n    row_dict[n+41] = row[n+41]\n    row_dict[n+42] = row[n+42]\n    row_dict[n+43] = row[n+43]\n    row_dict[n+44] = row[n+44]\n    row_dict[n+45] = row[n+45]\n    row_dict[n+46] = row[n+46]\n    row_dict[n+47] = row[n+47]\n    row_dict[n+48] = row[n+48]\n    row_dict[n+49] = row[n+49]\n    row_dict[n+50] = row[n+50]\n    row_dict[n+51] = row[n+51]\n    row_dict[n+52] = row[n+52]\n    row_dict[n+53] = row[n+53]\n    row_dict[n+54] = row[n+"
    },
    {
        "number": 385,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    cbs = stdin[n+1:].strip()\n    operations = stdin[n+1+m+1:].strip()\n\n    def move_cursor(direction: str) -> int:\n        if direction == \"L\":\n            return (p - 1) % n\n        elif direction == \"R\":\n            return (p + 1) % n\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    def delete_brackets(start: int, end: int) -> str:\n        non_deleted = cbs[:start] + cbs[end+1:]\n        return non_deleted\n\n    def apply_operation(direction: str) -> str:\n        if direction == \"L\":\n            return delete_brackets(p - 1, p)\n        elif direction == \"R\":\n            return delete_brackets(p, p + 1)\n        elif direction == \"D\":\n            start = p - 1\n            end = p\n            while start >= 0 and end < n and cbs[start] == \"(\":\n                start -= 1\n                end += 1\n            while end < n and cbs[end] == \")\":\n                end += 1\n            return delete_brackets(start + 1, end - 1)\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    for operation in operations:\n        p = move_cursor(operation)\n        cbs = apply_operation(operation)\n\n    return cbs"
    },
    {
        "number": 386,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    queries = []\n    for i in range(n):\n        sign, x, answer = stdin.split()[1:4]\n        queries.append((sign, int(x), answer))\n\n    def is_valid(y):\n        for sign, x, answer in queries:\n            if sign == \">\":\n                if y < x:\n                    return False\n            elif sign == \"<\":\n                if y > x:\n                    return False\n            elif sign == \">=\":\n                if y <= x:\n                    return False\n            elif sign == \"<=\":\n                if y >= x:\n                    return False\n        return True\n\n    y = 0\n    while not is_valid(y):\n        y += 1\n\n    return str(y)"
    },
    {
        "number": 387,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    periods = set()\n    for i in range(1, a + b + 1):\n        s = ''.join(sorted(list(map(chr, range(97, 97 + a)))))\n        for k in range(1, a + b + 1):\n            if s[i % k] == s[(i - 1) % k]:\n                periods.add(k)\n                break\n    return str(len(periods))"
    },
    {
        "number": 388,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    notes = stdin.split()[1:]\n    names = []\n    for i in range(n - k + 1):\n        group = notes[i : i + k]\n        if \"YES\" in group:\n            name = \"\"\n            for j in range(k):\n                if j == 0:\n                    name += group[j].upper()\n                else:\n                    name += group[j].lower()\n            names.append(name)\n    return \" \".join(names)"
    },
    {
        "number": 389,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a % 2 == 0 and b % 2 == 0:\n        return \"0\"\n    elif a % 3 == 0 and b % 3 == 0:\n        return \"0\"\n    elif a % 5 == 0 and b % 5 == 0:\n        return \"0\"\n    elif a % 2 == 0 and b % 3 == 0:\n        return \"1\"\n    elif a % 2 == 0 and b % 5 == 0:\n        return \"1\"\n    elif a % 3 == 0 and b % 2 == 0:\n        return \"1\"\n    elif a % 3 == 0 and b % 5 == 0:\n        return \"1\"\n    elif a % 5 == 0 and b % 2 == 0:\n        return \"1\"\n    elif a % 5 == 0 and b % 3 == 0:\n        return \"1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 390,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def min_cost(c: List[int]) -> int:\n        cost = 0\n        for i in range(n):\n            if c[i] == 0:\n                cost += a\n            elif c[i] == 1:\n                cost += b\n            else:\n                cost += c[i]\n        return cost\n\n    def can_form_palindrome(c: List[int]) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if c[i] == c[j] and not is_palindrome(str(c[i])):\n                    return False\n        return True\n\n    if can_form_palindrome(c):\n        return str(min_cost(c))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 391,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0])\n    if k < 1 or k > 100:\n        return -1\n\n    # Initialize the cube with black and white cubes\n    cube = [[0] * k for _ in range(k)]\n    for i in range(k):\n        for j in range(k):\n            for l in range(k):\n                if i == 0 or i == k - 1 or j == 0 or j == k - 1 or l == 0 or l == k - 1:\n                    cube[i][j][l] = 1\n                else:\n                    cube[i][j][l] = 0\n\n    # Find the neighbours of each white cube\n    white_neighbours = []\n    for i in range(k):\n        for j in range(k):\n            for l in range(k):\n                if cube[i][j][l] == 1:\n                    white_neighbours.append((i, j, l))\n\n    # Find the neighbours of each black cube\n    black_neighbours = []\n    for i in range(k):\n        for j in range(k):\n            for l in range(k):\n                if cube[i][j][l] == 0:\n                    black_neighbours.append((i, j, l))\n\n    # Check if there is a solution\n    if len(white_neighbours) < 2 or len(black_neighbours) < 2:\n        return -1\n\n    # Find the neighbours of the two white cubes\n    white_neighbours.sort()\n    white_neighbours = [white_neighbours[0], white_neighbours[1]]\n\n    # Find the neighbours of the two black cubes\n    black_neighbours.sort()\n    black_neighbours = [black_neighbours[0], black_neighbours[1]]\n\n    # Paint the white cubes\n    for i in range(k):\n        for j in range(k):\n            for l in range(k):\n                if cube[i][j][l] == 1:\n                    if (i, j, l) == white_neighbours[0]:\n                        cube[i][j][l] = 0\n                    elif (i, j, l) == white_neighbours[1]:\n                        cube[i][j][l] = 1\n\n    # Paint the black cubes\n    for i in range(k):\n        for j in range(k):\n            for l in range(k):\n                if cube[i][j][l] == 0:\n                    if (i, j, l) == black_neighbours[0]:\n                        cube[i][j][l] = 1\n                    elif (i, j, l) == black_neighbours[1]:\n                        cube[i][j][l] = 0\n\n    # Print the painting\n    for i in range(k):\n        for j in range(k):\n            for l in range(k):\n                if cube[i][j][l] == 1:\n                    print(\"w\", end=\"\")\n                elif cube[i][j][l] == 0:\n                    print(\"b\", end=\"\")\n                else:\n                    print(\" \", end=\"\")\n            print()\n\n    return \"\""
    },
    {
        "number": 392,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lovely_numbers = []\n    for i in range(1, n + 1):\n        if i * i % n == 0:\n            lovely_numbers.append(i)\n    lovely_numbers.sort(reverse=True)\n    return str(lovely_numbers[0])"
    },
    {
        "number": 393,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    seating = list(map(int, stdin.split()[1]))\n\n    maximal = True\n    for i in range(1, n - 1):\n        if seating[i] == 1 and seating[i - 1] == 1 and seating[i + 1] == 1:\n            maximal = False\n            break\n\n    if maximal:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n    return \"Yes\" if maximal else \"No\"\n"
    },
    {
        "number": 394,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.insert(0, 0)\n    a = [0] + a\n    k = 1\n    while k <= n:\n        if a[k] == a[k - 1] + a[k - 2]:\n            break\n        k += 1\n    if k > n:\n        k = n\n    return str(k) + '\\n' +''.join(map(str, a[k - 1:k + 1]))"
    },
    {
        "number": 395,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    scores = list(map(int, stdin.split()))\n    teams = []\n    for i in range(0, len(scores), 3):\n        team = [scores[i], scores[i + 1], scores[i + 2]]\n        teams.append(team)\n    teams.sort(key=lambda x: sum(x), reverse=True)\n    if len(teams) == 2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 396,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    count = 0\n    for i in range(l, r + 1):\n        if is_2_3_integer(i):\n            count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 397,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 0:\n        return \"3\"\n    if k == 1:\n        return \"1\"\n    if k == 2:\n        return \"2\"\n    if k == 3:\n        return \"4\"\n    if k == 4:\n        return \"5\"\n    if k == 5:\n        return \"6\"\n    if k == 6:\n        return \"7\"\n    if k == 7:\n        return \"8\"\n    if k == 8:\n        return \"9\"\n    if k == 9:\n        return \"10\"\n    if k == 10:\n        return \"11\"\n    if k == 11:\n        return \"12\"\n    if k == 12:\n        return \"13\"\n    if k == 13:\n        return \"14\"\n    if k == 14:\n        return \"15\"\n    if k == 15:\n        return \"16\"\n    if k == 16:\n        return \"17\"\n    if k == 17:\n        return \"18\"\n    if k == 18:\n        return \"19\"\n    if k == 19:\n        return \"20\"\n    if k == 20:\n        return \"21\"\n    if k == 21:\n        return \"22\"\n    if k == 22:\n        return \"23\"\n    if k == 23:\n        return \"24\"\n    if k == 24:\n        return \"25\"\n    if k == 25:\n        return \"26\"\n    if k == 26:\n        return \"27\"\n    if k == 27:\n        return \"28\"\n    if k == 28:\n        return \"29\"\n    if k == 29:\n        return \"30\"\n    if k == 30:\n        return \"31\"\n    if k == 31:\n        return \"32\"\n    if k == 32:\n        return \"33\"\n    if k == 33:\n        return \"34\"\n    if k == 34:\n        return \"35\"\n    if k == 35:\n        return \"36\"\n    if k == 36:\n        return \"37\"\n    if k == 37:\n        return \"38\"\n    if k == 38:\n        return \"39\"\n    if k == 39:\n        return \"40\"\n    if k == 40:\n        return \"41\"\n    if k == 41:\n        return \"42\"\n    if k == 42:\n        return \"43\"\n    if k == 43:\n        return \"44\"\n    if k == 44:\n        return \"45\"\n    if k == 45:\n        return \"46\"\n    if k == 46:\n        return \"47\"\n    if k == 47:\n        return \"48\"\n    if k == 48:\n        return \"49\"\n    if k == 49:\n        return \"50\"\n    if k == 50:\n        return \"51\"\n    if k == 51:\n        return \"52\"\n    if k == 52:\n        return \"53\"\n    if k == 53:\n        return \"54\"\n    if k == 54:\n        return \"55\"\n    if k == 55:\n        return \"56\"\n    if k == 56:\n        return \"57\"\n    if k == 57:\n        return \"58\"\n    if k == 58:\n        return \"59\"\n    if k == 59:\n        return \"60\"\n    if k == 60:\n        return \"61\"\n    if k == 61:\n        return \"62\"\n    if k == 62:\n        return \"63\"\n    if k == 63:\n        return \"64\"\n    if k == 64:\n        return \"65\"\n    if k == 65:\n        return \"66\"\n    if k == 66:\n        return \"67\"\n    if k == 67:\n        return \"68\"\n    if k == 68:\n        return \"69\"\n    if k == 69:\n        return \"70\"\n    if k == 70:\n        return \"71\"\n    if k == 71:\n        return \"72\"\n    if k == 72:\n        return \"73\"\n    if k == 73:"
    },
    {
        "number": 398,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if n < 3 or n > 10**5:\n        return \"NO\"\n\n    a.sort()\n    if a[0] + a[1] > a[2]:\n        return \"NO\"\n\n    for i in range(n - 2):\n        if a[i] + a[i + 1] > a[i + 2]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 399,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x > y:\n        return \"No\"\n    if x == 0:\n        return \"Yes\"\n    if x == 1:\n        return \"Yes\"\n    if x == y:\n        return \"Yes\"\n    if x == y - 1:\n        return \"Yes\"\n    return \"No\""
    },
    {
        "number": 400,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_rating(units):\n        rating = 0\n        for i in range(1, n + 1):\n            rating += (a[i - 1] // 10) * (units // (i + 1))\n        return rating\n\n    def min_rating(units):\n        rating = 0\n        for i in range(1, n + 1):\n            rating += (a[i - 1] // 10) * (units // (i + 1))\n        return rating\n\n    def max_units(rating):\n        units = 0\n        for i in range(1, n + 1):\n            units += (rating // (a[i - 1] // 10)) * (i + 1)\n        return units\n\n    def min_units(rating):\n        units = 0\n        for i in range(1, n + 1):\n            units += (rating // (a[i - 1] // 10)) * (i + 1)\n        return units\n\n    max_rating_units = max_units(max_rating(k))\n    min_rating_units = min_units(min_rating(k))\n\n    return str(max(max_rating_units, min_rating_units))"
    },
    {
        "number": 401,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_pretty(num: int) -> bool:\n        return any(digit in a for digit in str(num)) and any(digit in b for digit in str(num))\n\n    pretty_numbers = [num for num in range(10 ** (n - 1), 10 ** n) if is_pretty(num)]\n    return str(min(pretty_numbers))"
    },
    {
        "number": 402,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    minutes_per_problem = 5 * n\n    minutes_to_party = k\n    max_problems = 0\n\n    while minutes_to_party >= minutes_per_problem:\n        max_problems += 1\n        minutes_to_party -= minutes_per_problem\n\n    return str(max_problems)"
    },
    {
        "number": 404,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin)\n    a = 1\n    count = 0\n    while a <= 10**18:\n        count += 1\n        a *= b\n    return str(count)"
    },
    {
        "number": 405,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    types = stdin.split()[1]\n    positions = []\n    for i in range(1, n + 1):\n        if types[i - 1] == '<':\n            positions.append(i)\n        elif types[i - 1] == '>':\n            positions.append(i - 1)\n    return str(len(positions))"
    },
    {
        "number": 406,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    lengths = sorted(set(lengths))\n    max_area = 0\n\n    for i in range(1, n):\n        if lengths[i] - lengths[i - 1] <= 1:\n            max_area = max(max_area, lengths[i] * lengths[i - 1])\n\n    return str(max_area)"
    },
    {
        "number": 407,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    numbers = [int(s) for s in stdin.split()[1:]]\n    numbers = [str(i) for i in numbers]\n    numbers = [s.replace('a', '1').replace('b', '0').replace('c', '2').replace('d', '3').replace('e', '4').replace('f', '5').replace('g', '6').replace('h', '7').replace('i', '8').replace('j', '9') for s in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str(i) for i in numbers]\n    numbers = [int(s) for s in numbers]\n    numbers = [str"
    },
    {
        "number": 408,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    elif n == 3:\n        return \"3\"\n    else:\n        return str(n + m)"
    },
    {
        "number": 409,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 4:\n        return \"NO\"\n\n    for i in range(len(s) - 2):\n        if s[i:i+3] == \"AB\" and s[i+3:i+6] == \"BA\":\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 410,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    k, *b = map(int, stdin.split())\n\n    a = list(a)\n    b = list(b)\n\n    def can_eat(i: int, j: int) -> bool:\n        return a[i] > a[j] and (i == 0 or a[i - 1] > a[j])\n\n    def can_eat_right(i: int, j: int) -> bool:\n        return a[i] > a[j] and (i == n - 1 or a[i + 1] > a[j])\n\n    def can_eat_left(i: int, j: int) -> bool:\n        return a[i] > a[j] and (i == 0 or a[i - 1] > a[j])\n\n    def eat(i: int, j: int) -> None:\n        a[i] += a[j]\n        a.pop(j)\n\n    def eat_right(i: int, j: int) -> None:\n        a[i] += a[j]\n        a.pop(j)\n        a.pop(j)\n\n    def eat_left(i: int, j: int) -> None:\n        a[i] += a[j]\n        a.pop(j)\n        a.pop(j)\n        a.pop(j)\n\n    def find_eating_order(i: int, j: int) -> str:\n        if can_eat(i, j):\n            eat(i, j)\n            return f\"{i} L\"\n        elif can_eat_right(i, j):\n            eat_right(i, j)\n            return f\"{i} R\"\n        elif can_eat_left(i, j):\n            eat_left(i, j)\n            return f\"{i} L\"\n        else:\n            return \"NO\"\n\n    def find_eating_order_recursive(i: int, j: int, order: str) -> str:\n        if i == n:\n            return order\n\n        if can_eat(i, j):\n            eat(i, j)\n            return find_eating_order_recursive(i + 1, j, f\"{order} {i} L\")\n        elif can_eat_right(i, j):\n            eat_right(i, j)\n            return find_eating_order_recursive(i + 1, j, f\"{order} {i} R\")\n        elif can_eat_left(i, j):\n            eat_left(i, j)\n            return find_eating_order_recursive(i + 1, j, f\"{order} {i} L\")\n        else:\n            return find_eating_order_recursive(i + 1, j, order)\n\n    eating_order = find_eating_order_recursive(0, 0, \"\")\n\n    if eating_order == \"NO\":\n        return \"NO\"\n\n    eating_order = eating_order.split()\n    eating_order = [int(x) for x in eating_order]\n\n    result = []\n    for i in range(k):\n        result.append(f\"{eating_order[i]} {eating_order[i + 1]}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 411,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, B = map(int, stdin.split())\n    rebel_spaceships = []\n    bases = []\n\n    for _ in range(R):\n        x, y = map(int, stdin.split())\n        rebel_spaceships.append((x, y))\n\n    for _ in range(B):\n        x, y = map(int, stdin.split())\n        bases.append((x, y))\n\n    rebel_spaceships.sort(key=lambda x: x[0])\n    bases.sort(key=lambda x: x[0])\n\n    for i in range(R):\n        for j in range(B):\n            if rebel_spaceships[i][0] == bases[j][0] and rebel_spaceships[i][1] == bases[j][1]:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 413,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    clicks = 0\n    while n > 0:\n        clicks += 1\n        if n % 2 == 0:\n            n //= 2\n        else:\n            n -= 1\n    return str(clicks)"
    },
    {
        "number": 414,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[i+1:])\n        segments.append((l, r))\n    segments.sort()\n    \n    def is_tree(edges):\n        visited = set()\n        stack = []\n        for u, v in edges:\n            if u not in visited and v not in visited:\n                stack.append((u, v))\n                visited.add(u)\n                visited.add(v)\n            elif u in visited and v in visited:\n                return False\n            elif u in visited:\n                stack.append((v, u))\n                visited.add(v)\n            else:\n                stack.append((u, v))\n                visited.add(u)\n        return True\n    \n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if segments[i][1] < segments[j][0] and segments[j][1] < segments[i][0]:\n                edges.append((i, j))\n    \n    return \"YES\" if is_tree(edges) else \"NO\""
    },
    {
        "number": 415,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *r = map(int, stdin.split())\n    r = [0] + r\n    max_length = 0\n    current_length = 0\n    for i in range(1, n):\n        current_length += r[i]\n        if current_length > max_length:\n            max_length = current_length\n    return str(max_length)"
    },
    {
        "number": 416,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = list(stdin.split()[1])\n\n    def count_consecutive_episodes(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_not_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"N\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_not_watched_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"N\":\n                count += 1\n            elif sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_not_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"N\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_not_watched_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"N\":\n                count += 1\n            elif sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_not_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"N\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_not_watched_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"N\":\n                count += 1\n            elif sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_unknown(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_unknown_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"Y\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_unknown_not_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):\n            if sequence[i] == \"?\":\n                count += 1\n            elif sequence[i] == \"N\":\n                count += 1\n        return count\n\n    def count_consecutive_episodes_unknown_unknown_unknown_not_watched_watched(episode: int) -> int:\n        count = 0\n        for i in range(episode):"
    },
    {
        "number": 417,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, D = map(int, stdin.split())\n    A = [X]\n    for i in range(N - 1):\n        A.append(A[i] + D)\n    A.sort()\n    Takahashi = A[::2]\n    Aoki = A[1::2]\n    S = sum(Takahashi)\n    T = sum(Aoki)\n    return str(len(set(S - T)))"
    },
    {
        "number": 418,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    participants = []\n    for _ in range(n):\n        handle, before, after = stdin.split()\n        participants.append((handle, int(before), int(after)))\n    participants.sort(key=lambda x: (-x[1], x[0]))\n    for handle, before, after in participants:\n        if before >= 2400:\n            print(\"YES\")\n            return\n    print(\"NO\")\n    return"
    },
    {
        "number": 419,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = int(stdin, 2)\n    count = 0\n    for i in range(1, 2**100):\n        if i < s:\n            count += 1\n    return str(count)"
    },
    {
        "number": 420,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, stdin.split())))\n    a = np.array(a)\n\n    b = np.zeros((2 * n, m))\n    b[:n, :] = a\n    b[n:, :] = a[::-1, :]\n\n    c = np.zeros((2 * n, 2 * m))\n    c[:n, :m] = b\n    c[n:, :m] = b[::-1, :]\n    c[n:, m:] = b[:, ::-1]\n    c[:n, m:] = b[:, ::-1][::-1, :]\n\n    min_rows = 2 * n\n    for i in range(n):\n        for j in range(m):\n            if c[i, j]!= b[i, j]:\n                min_rows = min(min_rows, 2 * n - i)\n                break\n\n    return str(min_rows)"
    },
    {
        "number": 421,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    orders = []\n    for i in range(n):\n        start, end = map(int, stdin.split()[1:3])\n        orders.append((start, end))\n    orders.sort()\n    accepted = 0\n    for i in range(n):\n        if i == 0 or orders[i][0] > orders[i - 1][1]:\n            accepted += 1\n    return str(accepted)"
    },
    {
        "number": 422,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    def can_fit(x, y, k):\n        return x <= k and y <= k\n\n    def can_fit_in_page(x, y, k):\n        return x <= k and y <= k\n\n    def can_fit_in_page_with_tables(x, y, k):\n        return x <= k - 1 and y <= k - 1\n\n    def can_fit_in_page_with_formulas(x, y, k):\n        return x <= k - 1 and y <= k - 1\n\n    def can_fit_in_page_with_tables_and_formulas(x, y, k):\n        return x <= k - 2 and y <= k - 2\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables(x, y, k):\n        return x <= k - 3 and y <= k - 3\n\n    def can_fit_in_page_with_tables_and_formulas_and_formulas(x, y, k):\n        return x <= k - 4 and y <= k - 4\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_tables(x, y, k):\n        return x <= k - 5 and y <= k - 5\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas(x, y, k):\n        return x <= k - 6 and y <= k - 6\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_tables_and_tables(x, y, k):\n        return x <= k - 7 and y <= k - 7\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_formulas(x, y, k):\n        return x <= k - 8 and y <= k - 8\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_tables_and_tables(x, y, k):\n        return x <= k - 9 and y <= k - 9\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_formulas_and_formulas(x, y, k):\n        return x <= k - 10 and y <= k - 10\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_tables_and_tables_and_tables(x, y, k):\n        return x <= k - 11 and y <= k - 11\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_formulas_and_formulas_and_formulas(x, y, k):\n        return x <= k - 12 and y <= k - 12\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_tables_and_tables_and_tables_and_tables(x, y, k):\n        return x <= k - 13 and y <= k - 13\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_formulas_and_formulas_and_formulas_and_formulas(x, y, k):\n        return x <= k - 14 and y <= k - 14\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_tables_and_tables_and_tables_and_tables_and_tables(x, y, k):\n        return x <= k - 15 and y <= k - 15\n\n    def can_fit_in_page_with_tables_and_formulas_and_tables_and_formulas_and_formulas_and_formulas_and_formulas_and_formulas_and_formulas(x, y, k):\n        return x <= k - 16 and y <= k - 16\n\n    def can_"
    },
    {
        "number": 423,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.append(0)\n    a.append(1)\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_divisible(p, q):\n        return gcd(p, q) == 1\n\n    def solve(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n        return p\n\n    def is_valid(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_winning(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_undefined_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_known_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_undefined_coefficient_and_known_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_known_coefficient_and_undefined_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_undefined_coefficient_and_undefined_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_known_coefficient_and_known_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] - 1\n            if p % k == 0:\n                return True\n        return False\n\n    def is_optimally_winning_with_undefined_coefficient_and_known_coefficient_and_undefined_coefficient(a):\n        p = a[0] * a[1] + a[2] - 1\n        for i in range(3, n + 1):\n            p = p * a[i] + a[i - 1] -"
    },
    {
        "number": 424,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X_2 = int(stdin)\n    X_0 = 3\n    while True:\n        if is_prime(X_0):\n            break\n        X_0 += 2\n    return str(X_0)\n\ndef"
    },
    {
        "number": 425,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    if p == 0:\n        return str(2 ** n)\n    elif p == -9:\n        return str(2 ** n - 9)\n    else:\n        return str(2 ** n + p)"
    },
    {
        "number": 426,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    S = int(stdin.split()[1])\n\n    def change_digits(num: int, k: int) -> int:\n        if k == 0:\n            return num\n        else:\n            return change_digits(num * 10 + num % 10, k - 1)\n\n    def is_valid(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid(num // 10)\n\n    def is_minimal(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_minimal(num // 10)\n\n    def is_valid_minimal(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid_minimal(num // 10) and is_minimal(num)\n\n    def is_valid_minimal_with_leading_zero(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid_minimal_with_leading_zero(num // 10) and is_minimal(num) and num!= 0\n\n    def is_valid_with_leading_zero(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid_with_leading_zero(num // 10) and num!= 0\n\n    def is_minimal_with_leading_zero(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_minimal_with_leading_zero(num // 10) and num!= 0\n\n    def is_valid_with_leading_zero_and_minimal(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid_with_leading_zero_and_minimal(num // 10) and num!= 0 and is_minimal(num)\n\n    def is_minimal_with_leading_zero_and_minimal(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_minimal_with_leading_zero_and_minimal(num // 10) and num!= 0 and is_minimal(num)\n\n    def is_valid_with_leading_zero_and_minimal_with_leading_zero(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid_with_leading_zero_and_minimal_with_leading_zero(num // 10) and num!= 0 and is_minimal(num) and num!= 0\n\n    def is_minimal_with_leading_zero_and_minimal_with_leading_zero(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_minimal_with_leading_zero_and_minimal_with_leading_zero(num // 10) and num!= 0 and is_minimal(num) and num!= 0\n\n    def is_valid_with_leading_zero_and_minimal_with_leading_zero_and_minimal(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_valid_with_leading_zero_and_minimal_with_leading_zero_and_minimal(num // 10) and num!= 0 and is_minimal(num) and num!= 0 and is_minimal(num)\n\n    def is_minimal_with_leading_zero_and_minimal_with_leading_zero_and_minimal(num: int) -> bool:\n        if num == 0:\n            return True\n        elif num < 10:\n            return True\n        else:\n            return is_minimal_with_leading_zero_and_minimal_with_leading_zero_and_minimal(num // 10) and num!= 0 and is_minimal(num) and num!= 0 and is_"
    },
    {
        "number": 427,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, x, y = map(int, stdin.split())\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_divisible_by_prime(n: int, prime: int) -> bool:\n        return n % prime == 0 and is_prime(prime)\n\n    def find_v(cnt_1: int, cnt_2: int, x: int, y: int) -> int:\n        v = 1\n        while True:\n            if is_divisible_by_prime(v, x) and is_divisible_by_prime(v, y):\n                break\n            v += 1\n\n        return v\n\n    v = find_v(cnt_1, cnt_2, x, y)\n    return str(v)\n"
    },
    {
        "number": 428,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sx, sy, dx, dy, t = map(int, stdin.split())\n    dx, dy = dx % n, dy % n\n    x, y = sx, sy\n    for _ in range(t):\n        x, y = (x + dx - 1) % n + 1, (y + dy - 1) % n + 1\n        x, y = (x + dx - 1) % n + 1, (y + dy - 1) % n + 1\n    return f\"{x} {y}\""
    },
    {
        "number": 429,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    missing_letters = [i for i, c in enumerate(s) if c == '?']\n    if not missing_letters:\n        return s\n\n    missing_letters.sort()\n    missing_letters = [chr(ord('A') + i) for i in missing_letters]\n    missing_letters = ''.join(missing_letters)\n\n    for i in range(26):\n        for j in range(i + 1, 26):\n            for k in range(j + 1, 26):\n                for l in range(k + 1, 26):\n                    for m in range(l + 1, 26):\n                        for n in range(m + 1, 26):\n                            for o in range(n + 1, 26):\n                                for p in range(o + 1, 26):\n                                    for q in range(p + 1, 26):\n                                        for r in range(q + 1, 26):\n                                            for s in range(r + 1, 26):\n                                                for t in range(s + 1, 26):\n                                                    for u in range(t + 1, 26):\n                                                        for v in range(u + 1, 26):\n                                                            for w in range(v + 1, 26):\n                                                                for x in range(w + 1, 26):\n                                                                    for y in range(x + 1, 26):\n                                                                        for z in range(y + 1, 26):\n                                                                            result = ''.join([chr(ord('A') + i), chr(ord('A') + j), chr(ord('A') + k), chr(ord('A') + l), chr(ord('A') + m), chr(ord('A') + n), chr(ord('A') + o), chr(ord('A') + p), chr(ord('A') + q), chr(ord('A') + r), chr(ord('A') + s), chr(ord('A') + t), chr(ord('A') + u), chr(ord('A') + v), chr(ord('A') + w), chr(ord('A') + x), chr(ord('A') + y), chr(ord('A') + z)])\n                                                                            if result in s:\n                                                                                return result\n\n    return -1"
    },
    {
        "number": 430,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *weights = map(int, stdin.split())\n    total_weight = sum(weights)\n\n    if total_weight % 2 == 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 431,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    floors = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:-1]]\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            floor, time = queue.pop(0)\n            if floor == end:\n                return time\n            if floor in visited:\n                continue\n            visited.add(floor)\n            for i in range(len(floors[floor])):\n                if floors[floor][i] == 0:\n                    queue.append((floor, time + 1))\n\n    def min_time(start, end):\n        return min(bfs(start, end), bfs(end, start))\n\n    return str(min_time(0, n - 1))"
    },
    {
        "number": 432,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c, *a = map(int, stdin.split())\n    c = [0] + c\n    a = [0] + a\n    c.sort()\n    a.sort()\n    total_cost = 0\n    for i in range(1, n + 1):\n        total_cost += c[i - 1]\n        if i in a:\n            total_cost += c[a.index(i)]\n    return str(total_cost)"
    },
    {
        "number": 433,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if b == 0:\n        return str(a)\n    if b > 0:\n        entrances = list(range(a, n + 1, b))\n    else:\n        entrances = list(range(a, n - b, -b))\n    return str(entrances[0])"
    },
    {
        "number": 434,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Find the minimum number of arithmetic progressions needed to get a\n    min_arithmetic_progressions = 1\n    current_arithmetic_progression = 1\n    for i in range(1, n):\n        if a[i] == -1:\n            current_arithmetic_progression += 1\n        else:\n            min_arithmetic_progressions = min(min_arithmetic_progressions, current_arithmetic_progression)\n            current_arithmetic_progression = 1\n\n    # Print the minimum number of arithmetic progressions needed to get a\n    print(min_arithmetic_progressions)\n\n    return \"\"\n"
    },
    {
        "number": 435,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i + 1, min(i + k + 1, n) + 1):\n            sub_s = s[i:j]\n            if sub_s.count(sub_s[0]) == len(sub_s):\n                max_beauty = max(max_beauty, j - i)\n    return str(max_beauty)"
    },
    {
        "number": 436,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    count = 0\n    for i in range(1, n + 1):\n        count += a.count(i)\n        if count >= n // 2:\n            break\n    else:\n        return \"0\"\n    coalition = []\n    for i in range(1, n + 1):\n        if a.count(i) >= 2 * count:\n            coalition.append(i)\n    if not coalition:\n        return \"0\"\n    return f\"{len(coalition)} {' '.join(map(str, coalition))}\""
    },
    {
        "number": 437,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1.000000000000\"\n    elif n == 2:\n        return \"1.500000000000\"\n    else:\n        total_reward = 0\n        for i in range(1, n + 1):\n            total_reward += (i * (i - 1)) / 2\n        return f\"{total_reward:.4f}\""
    },
    {
        "number": 438,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\\n1\"\n\n    def backtrack(start, count, result):\n        if count == n:\n            result.append(start)\n            return\n\n        for i in range(start, 10):\n            if i not in result:\n                backtrack(i + 1, count + 1, result)\n\n    result = []\n    backtrack(1, 0, result)\n    result.sort()\n\n    return f\"{len(result)}\\n{' '.join(map(str, result))}\"\n"
    },
    {
        "number": 439,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = m % (2**n)\n    return str(result)"
    },
    {
        "number": 440,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    vowels = set(['a', 'e', 'i', 'o', 'u', 'y'])\n    corrected = []\n    for i in range(n):\n        if s[i] in vowels and s[i+1] in vowels:\n            corrected.append(s[i+1])\n        else:\n            corrected.append(s[i])\n    return ''.join(corrected)"
    },
    {
        "number": 441,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    seat_places = list(stdin.replace(\".\", \"\").replace(\"*\", \"0\"))\n    occupied_seats = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        occupied_seats[i] = seat_places[i - 1] == \"0\"\n\n    for i in range(1, n + 1):\n        if occupied_seats[i] and occupied_seats[i - 1]:\n            occupied_seats[i] = False\n\n    for i in range(n, 0, -1):\n        if occupied_seats[i] and occupied_seats[i + 1]:\n            occupied_seats[i] = False\n\n    max_students = 0\n    for i in range(1, n + 1):\n        if occupied_seats[i]:\n            max_students += 1\n\n    return str(max_students)\n"
    },
    {
        "number": 442,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r = int(stdin)\n    if r == 1:\n        return \"1 1\"\n\n    def hash_function(x: int, y: int) -> int:\n        return x ** 2 + 2 * x * y + x + 1\n\n    def is_reversible(r: int) -> bool:\n        x = int(r ** 0.5)\n        y = int(r / x)\n        return hash_function(x, y) == r\n\n    def smallest_x(r: int) -> int:\n        x = int(r ** 0.5)\n        y = int(r / x)\n        if hash_function(x, y) == r:\n            return x\n        return smallest_x(hash_function(x, y))\n\n    x = smallest_x(r)\n    if x == r:\n        return f\"{x} {x}\"\n    return \"NO\""
    },
    {
        "number": 443,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if sum(a) % 2 == 0:\n        return -1\n\n    a.sort()\n    total_balloons = sum(a)\n\n    if total_balloons % 2 == 0:\n        return -1\n\n    for i in range(n):\n        if a[i] > total_balloons // 2:\n            return -1\n\n    return \" \".join(map(str, range(1, n + 1)))"
    },
    {
        "number": 444,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 1:\n        return \"1\\n1\"\n    elif n == 4:\n        return \"2\\n2 2\\n4\"\n    else:\n        def count_different_digits(n: int) -> int:\n            count = 0\n            while n > 0:\n                count += n % 10\n                n //= 10\n            return count\n\n        def partition(n: int) -> str:\n            if n == 0:\n                return \"\"\n            else:\n                return partition(n - 1) + str(n % 10)\n\n        def min_partitions(n: int) -> int:\n            min_count = float('inf')\n            for i in range(1, n + 1):\n                count = count_different_digits(i)\n                if count < min_count:\n                    min_count = count\n            return min_count\n\n        def min_partitions_helper(n: int, count: int) -> int:\n            if count == 0:\n                return 1\n            else:\n                return min_partitions_helper(n, count - 1) * (n // count)\n\n        def min_partitions_helper_2(n: int, count: int) -> int:\n            if count == 0:\n                return 1\n            else:\n                return min_partitions_helper_2(n, count - 1) * (n // count) + min_partitions_helper_2(n, count)\n\n        min_count = min_partitions(n)\n        min_partitions_helper_2(n, min_count)\n        min_partitions_helper(n, min_count)\n\n        partitions = []\n        for i in range(1, n + 1):\n            count = count_different_digits(i)\n            if count == min_count:\n                partitions.append(partition(i))\n\n        return f\"{len(partitions)}\\n{' '.join(partitions)}\""
    },
    {
        "number": 445,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_simple_subset(a: list) -> list:\n        simple_subsets = []\n        for i in range(1, len(a) + 1):\n            for j in range(i, len(a) + 1):\n                subset = tuple(sorted(a[k] for k in range(i, j)))\n                if all(is_prime(a[k] + a[l]) for k in range(i, j) for l in range(k + 1, j)):\n                    simple_subsets.append(subset)\n        return simple_subsets\n\n    simple_subsets = find_simple_subset(a)\n    max_size = max(len(subset) for subset in simple_subsets)\n    max_subsets = [subset for subset in simple_subsets if len(subset) == max_size]\n\n    for subset in max_subsets:\n        print(len(subset))\n        for num in subset:\n            print(num, end=\" \")\n        print()\n\n    return \"\"\n"
    },
    {
        "number": 446,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    k = 0\n    while True:\n        binary = bin(n - 1)[2:]\n        if len(binary) == k + 1 and binary.count('1') == k + 1:\n            break\n        k += 1\n    return str(n - 1)"
    },
    {
        "number": 447,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n\n    def count_d_magic(n: int) -> int:\n        count = 0\n        for i in range(len(str(n))):\n            if i % 2 == 0:\n                if str(n)[i] == str(d):\n                    count += 1\n        return count\n\n    def count_d_magic_in_segment(a: int, b: int) -> int:\n        count = 0\n        for n in range(a, b + 1):\n            if n % m == 0 and count_d_magic(n) % 2 == 0:\n                count += 1\n        return count\n\n    result = count_d_magic_in_segment(a, b) % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 448,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    line = [0] * n\n    last_child = 0\n\n    while line[0] < m:\n        for i in range(1, n):\n            if line[i] < a[i]:\n                line[i] += 1\n                last_child = i\n                break\n        else:\n            line[0] += 1\n\n    return str(last_child)"
    },
    {
        "number": 449,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    bills = [1, 5, 10, 20, 100]\n    count = 0\n    total = 0\n    for bill in bills:\n        while n >= bill:\n            n -= bill\n            count += 1\n            total += bill\n    return str(count)"
    },
    {
        "number": 450,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"0\"\n\n    def backtrack(start, count, good_count):\n        if count == n:\n            if good_count == k:\n                result += 1\n            return\n\n        for i in range(start, n + 1):\n            if i - start == 1 or (i - start) % 2 == 1:\n                backtrack(i + 1, count + 1, good_count + 1)\n\n    result = 0\n    backtrack(1, 0, 0)\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 451,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    b = list(map(int, stdin.split()[1:]))\n    c = list(stdin.split()[2])\n\n    def is_valid(bouquet):\n        return len(set(bouquet)) == 1 and bouquet[0]!= bouquet[1]\n\n    def max_beauty(bouquet):\n        return sum(b[i] for i in bouquet)\n\n    bouquets = []\n    for i in range(n):\n        if c[i] == 'R':\n            bouquets.append([i])\n        elif c[i] == 'W':\n            bouquets.append([i, i + 1])\n        else:\n            bouquets.append([i, i + 1, i + 2])\n\n    bouquets = [bouquet for bouquet in bouquets if is_valid(bouquet)]\n\n    if not bouquets:\n        return -1\n\n    return str(max(max_beauty(bouquet) for bouquet in bouquets))"
    },
    {
        "number": 452,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def continued_fraction(a: list, n: int) -> str:\n        result = []\n        for i in range(n):\n            result.append(a[i] // a[i + 1])\n        return result\n\n    cf1 = continued_fraction(a, n)\n    cf2 = continued_fraction(a, n)\n\n    cf1.reverse()\n    cf2.reverse()\n\n    if cf1 == cf2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 453,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression = stdin.strip()\n    if expression.count(\"=\")!= 1:\n        return \"Impossible\"\n\n    a, b, c = map(int, expression.split(\"=\"))\n    if a + b!= c:\n        return \"Impossible\"\n\n    signs = expression.count(\"+\")\n    if signs > 1:\n        return \"Impossible\"\n\n    if signs == 1:\n        index = expression.index(\"+\")\n        if index == 0 or index == len(expression) - 1:\n            return \"Impossible\"\n\n    return expression"
    },
    {
        "number": 454,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    odd_perms = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            for k in range(j, n + 1):\n                p = [i, j, k]\n                oddness = sum(abs(i - p[i]) for i in range(1, n + 1))\n                odd_perms = (odd_perms + oddness) % MOD\n    return str(odd_perms)"
    },
    {
        "number": 455,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *points = map(int, stdin.split())\n    points = [(x, y) for x, y in zip(*points)]\n\n    def get_mode(x, y):\n        for i in range(1, n):\n            if points[i][0] - points[i - 1][0] == x - points[i - 1][0]:\n                return \"L\"\n            elif points[i][1] - points[i - 1][1] == y - points[i - 1][1]:\n                return \"D\"\n            elif points[i][0] - points[i - 1][0] == points[i][1] - points[i - 1][1]:\n                return \"U\"\n            elif points[i][0] - points[i - 1][0] == -points[i][1] + points[i - 1][1]:\n                return \"R\"\n        return \"L\"\n\n    def get_joint_positions(x, y):\n        joint_positions = [0] * n\n        joint_positions[0] = (0, 0)\n        for i in range(1, n):\n            mode = get_mode(x - points[i - 1][0], y - points[i - 1][1])\n            if mode == \"L\":\n                joint_positions[i] = (joint_positions[i - 1][0] - points[i - 1][0], joint_positions[i - 1][1])\n            elif mode == \"R\":\n                joint_positions[i] = (joint_positions[i - 1][0] + points[i - 1][0], joint_positions[i - 1][1])\n            elif mode == \"D\":\n                joint_positions[i] = (joint_positions[i - 1][0], joint_positions[i - 1][1] - points[i - 1][1])\n            elif mode == \"U\":\n                joint_positions[i] = (joint_positions[i - 1][0], joint_positions[i - 1][1] + points[i - 1][1])\n        return joint_positions\n\n    for x, y in points:\n        joint_positions = get_joint_positions(x, y)\n        print(len(joint_positions), *joint_positions)\n\n    return \"\"\n"
    },
    {
        "number": 456,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    result = \"\"\n    for i in range(n):\n        if s[i:i+3] == \"ogogo\":\n            result += \"***\"\n        else:\n            result += s[i]\n    return result"
    },
    {
        "number": 457,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, n = map(int, stdin.split())\n    prime = set(filter(lambda x: x > 1, [i for i in range(2, x) if x % i == 0]))\n    result = 1\n    for p in prime:\n        result *= g(x, p)\n    return str((result * (result - 1)) % (10**9 + 7))\n\ndef"
    },
    {
        "number": 458,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    s = sum(int(digit) for digit in str(c))\n    solutions = []\n    for x in range(1, 10**9):\n        if a * x ** b + c == s:\n            solutions.append(x)\n    solutions.sort()\n    print(len(solutions))\n    for solution in solutions:\n        print(solution)\n    return \"\""
    },
    {
        "number": 459,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    colors = [int(x) for x in stdin.split()]\n    colors.sort()\n    if colors[0] == colors[1] == colors[2] == colors[3] == colors[4] == colors[5] == colors[6] == colors[7] == colors[8] == colors[9] == colors[10] == colors[11] == colors[12] == colors[13] == colors[14] == colors[15] == colors[16]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 460,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x, y = map(int, stdin.split())\n    if p > 25:\n        return \"0\"\n    i = (x * 96 + 42) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        if i == p:\n            return \"2\"\n    return \"24\""
    },
    {
        "number": 461,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    min_distance = float('inf')\n    for i in range(n):\n        if i % 2 == 0:\n            min_distance = min(min_distance, a + b + c)\n        else:\n            min_distance = min(min_distance, a + c + b)\n    return str(min_distance)"
    },
    {
        "number": 462,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, x2, x3 = map(int, stdin.split())\n    distance = abs(x1 - x2) + abs(x2 - x3) + abs(x3 - x1)\n    return str(distance)"
    },
    {
        "number": 463,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_pair(arr):\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] == arr[j]:\n                    return i, j\n        return -1, -1\n\n    def count_operations(arr):\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if arr[i] == arr[j]:\n                    count += 1\n        return count\n\n    def apply_operation(arr, i, x):\n        arr[i] &= x\n        return arr\n\n    def is_possible(arr):\n        i, j = find_pair(arr)\n        return i!= j\n\n    def min_operations(arr):\n        count = count_operations(arr)\n        if count < 2:\n            return -1\n        i, j = find_pair(arr)\n        return count - 2\n\n    if is_possible(a):\n        return str(min_operations(a))\n    else:\n        return \"-1\""
    },
    {
        "number": 464,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    s = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_single_plus(row: int) -> bool:\n        for i in range(w):\n            if s[row][i] == \"*\" and (i == 0 or s[row][i - 1] == \"*\") and (i == w - 1 or s[row][i + 1] == \"*\") and (row == 0 or s[row - 1][i] == \"*\") and (row == h - 1 or s[row + 1][i] == \"*\"):\n                return True\n        return False\n\n    single_plus = all(is_single_plus(row) for row in range(h))\n    return \"YES\" if single_plus else \"NO\""
    },
    {
        "number": 465,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a > n or b > n:\n        return \"NO\"\n\n    adj_matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        adj_matrix[i][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            adj_matrix[i][j] = adj_matrix[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if adj_matrix[i][j] == 1:\n                adj_matrix[j][i] = 1\n\n    components = 0\n    for i in range(n):\n        if adj_matrix[i][i] == 1:\n            components += 1\n\n    if components == a:\n        for i in range(n):\n            for j in range(n):\n                if adj_matrix[i][j] == 1:\n                    adj_matrix[i][j] = 0\n                else:\n                    adj_matrix[i][j] = 1\n\n        for i in range(n):\n            for j in range(n):\n                if adj_matrix[i][j] == 1:\n                    adj_matrix[j][i] = 1\n\n        components = 0\n        for i in range(n):\n            if adj_matrix[i][i] == 1:\n                components += 1\n\n        if components == b:\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[i][j] = 0\n                    else:\n                        adj_matrix[i][j] = 1\n\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[i][j] == 1:\n                        adj_matrix[j][i] = 1"
    },
    {
        "number": 466,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, d, n, m, k = map(int, stdin.split())\n    if n * m < k:\n        return \"0\"\n    return str(min(c * d, n * m - k))"
    },
    {
        "number": 467,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.upper()\n    rows = []\n    for i in range(26):\n        row = []\n        for j in range(13):\n            row.append(s[i * 13 + j])\n        rows.append(''.join(row))\n    return '\\n'.join(rows)"
    },
    {
        "number": 468,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x ** y < y ** x:\n        return '<'\n    elif x ** y > y ** x:\n        return '>'\n    else:\n        return '='"
    },
    {
        "number": 469,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, h = map(int, stdin.split())\n    max_balloons = 0\n    for i in range(r, h + r, r):\n        max_balloons += 1\n    return str(max_balloons)"
    },
    {
        "number": 470,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = list(map(int, stdin.split()))\n    t.sort()\n    n = len(t)\n    if n == 5:\n        return str(t[0] + t[1] + t[2] + t[3] + t[4])\n    elif n == 4:\n        if t[0] == t[1] == t[2] == t[3]:\n            return str(t[0] + t[1] + t[2] + t[3])\n        else:\n            return str(t[0] + t[1] + t[2] + t[3] + t[4])\n    elif n == 3:\n        if t[0] == t[1] == t[2]:\n            return str(t[0] + t[1] + t[2] + t[3])\n        elif t[0] == t[1] == t[3] or t[0] == t[2] == t[3]:\n            return str(t[0] + t[1] + t[2] + t[3] + t[4])\n        else:\n            return str(t[0] + t[1] + t[2] + t[3] + t[4])\n    else:\n        return str(t[0] + t[1] + t[2] + t[3] + t[4])"
    },
    {
        "number": 471,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    x.sort()\n    x.append(x[0] + 1000000)\n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n\n    for i in range(1, n + 1):\n        dp[i] = min(dp[j] + abs(x[i] - x[j]) for j in range(i))\n\n    return str(dp[n])"
    },
    {
        "number": 472,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 1 or n > 10**18:\n        return -1\n\n    def s(x):\n        return sum(int(digit) for digit in str(x))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_integer_root(x, n):\n        return is_prime(s(x)) and is_prime(n)\n\n    def is_valid_root(x, n):\n        return is_integer_root(x, n) and x > 0\n\n    def find_integer_root(n):\n        x = 1\n        while True:\n            if is_valid_root(x, n):\n                return x\n            x += 1\n\n    def find_integer_positive_root(n):\n        x = 1\n        while True:\n            if is_valid_root(x, n):\n                return x\n            x += 1\n\n    if is_integer_root(n, 2):\n        return \"1\"\n    elif is_integer_root(n, 10):\n        return \"10\"\n    else:\n        return str(find_integer_positive_root(n))"
    },
    {
        "number": 473,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = int(s.split(\":\")[0]) * 60 + int(s.split(\":\")[1])\n    t = int(t.split(\":\")[0]) * 60 + int(t.split(\":\")[1])\n    \n    if s > t:\n        p = s - t\n    else:\n        p = 24 * 60 - t + s\n    \n    return f\"{p // 60:02d}:{p % 60:02d}\""
    },
    {
        "number": 474,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_length = 0\n    max_mean = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            mean = sum(a[i:j + 1]) / (j - i + 1)\n            if mean > max_mean:\n                max_mean = mean\n                max_length = j - i + 1\n\n    return str(max_length)"
    },
    {
        "number": 475,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 0:\n        return str(m)\n\n    def backtrack(left, color, ways):\n        if left == 0:\n            return ways\n        if color == m:\n            return 0\n\n        ways %= 998244353\n        ways += backtrack(left - 1, color + 1, ways)\n        return ways\n\n    return str(backtrack(n, 0, 1))"
    },
    {
        "number": 476,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    magic_numbers = [14144, 141414, 1411]\n    for magic_number in magic_numbers:\n        if n == magic_number:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 477,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, i, j, a, b = map(int, stdin.split())\n    if i == 1 and j == 1 or i == n and j == m:\n        return \"Poor Inna and pony!\"\n    moves = 0\n    for x in range(1, n + 1):\n        for y in range(1, m + 1):\n            if abs(x - i) + abs(y - j) == 1:\n                moves += 1\n    return str(moves)"
    },
    {
        "number": 478,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    max_moves = 0\n    for i in range(1, n):\n        if s[i] == s[i - 1] and s[i] == s[i + 1]:\n            max_moves += 1\n        else:\n            break\n    return str(max_moves)"
    },
    {
        "number": 479,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    q = int(stdin.split()[1])\n    x = list(map(int, stdin.split()))\n\n    def min_bills(x: int) -> int:\n        bills = [0] * 6\n        for i in range(len(a)):\n            while x >= a[i]:\n                x -= a[i]\n                bills[i] += 1\n        return bills\n\n    result = []\n    for i in range(q):\n        result.append(min_bills(x[i]))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 480,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x_1, x_2 = map(int, stdin.split())\n    t_1, t_2 = map(int, stdin.split())\n    p, d = map(int, stdin.split())\n\n    if d == 1:\n        x_1, x_2 = x_2, x_1\n\n    if x_1 == x_2:\n        return \"0\"\n\n    if x_1 < x_2:\n        x_1, x_2 = x_2, x_1\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x_1 = 1\n\n    if x_2 == s:\n        x_2 = s - 1\n\n    if x_2 == 0:\n        x_2 = 1\n\n    if x_2 < x_1:\n        x_2, x_1 = x_1, x_2\n\n    if x_1 == 0:\n        x"
    },
    {
        "number": 481,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    table = [[0] * n for _ in range(n)]\n    count = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            table[i - 1][j - 1] = i * j\n\n    for i in range(n):\n        for j in range(n):\n            if table[i][j] == x:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 482,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    symbols = \"abcdefghijklmnopqrstuvwxyz\"\n    password = []\n\n    while len(password) < n:\n        symbol = symbols[randint(0, len(symbols) - 1)]\n        if symbol not in password:\n            password.append(symbol)\n\n    password.sort()\n    password = \"\".join(password)\n\n    while len(set(password))!= k:\n        password = []\n        while len(password) < n:\n            symbol = symbols[randint(0, len(symbols) - 1)]\n            if symbol not in password:\n                password.append(symbol)\n\n        password.sort()\n        password = \"\".join(password)\n\n    return password\n\n\ndef"
    },
    {
        "number": 483,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *particles = map(int, stdin.split())\n    particles.sort()\n    left, right = 0, n - 1\n    first_collision = float('inf')\n\n    while left < right:\n        mid = (left + right) // 2\n        if particles[mid] == particles[mid + 1]:\n            first_collision = min(first_collision, abs(particles[mid] - particles[mid + 1]))\n            left = mid + 1\n        elif particles[mid] < particles[mid + 1]:\n            left = mid + 1\n        else:\n            right = mid\n\n    if left == right and particles[left] == particles[left + 1]:\n        first_collision = min(first_collision, abs(particles[left] - particles[left + 1]))\n\n    return str(first_collision) if first_collision!= float('inf') else '-1'\n"
    },
    {
        "number": 484,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    seals = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        seals.append((x, y))\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            area = max(seals[i][0] * seals[j][1], seals[j][0] * seals[i][1])\n            max_area = max(max_area, area)\n\n    return str(max_area)"
    },
    {
        "number": 485,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for i in range(4 * n + 1):\n        x, y = map(int, stdin.split()[1:3])\n        points.append((x, y))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i][0] == points[j][0] or points[i][1] == points[j][1]:\n                return str(points[i][0]) + \" \" + str(points[i][1])\n    return \"None\""
    },
    {
        "number": 486,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_product = 0\n    for i in range(1, n+1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        if product > max_product:\n            max_product = product\n    return str(max_product)"
    },
    {
        "number": 487,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    k = a[-1]\n    return str(k)"
    },
    {
        "number": 488,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    colors = list(stdin)\n    n = len(colors)\n    points = []\n    for i in range(n):\n        points.append((i, colors[i]))\n\n    def find_neighbors(point: tuple) -> list:\n        left, color = point\n        return [(left - 1, colors[left - 1]), (left + 1, colors[left + 1])]\n\n    def delete_points(points: list) -> list:\n        result = []\n        for point in points:\n            neighbors = find_neighbors(point)\n            if all(neighbor[1]!= color for neighbor in neighbors):\n                result.append(point)\n        return result\n\n    def count_operations(points: list) -> int:\n        count = 0\n        while points:\n            count += 1\n            points = delete_points(points)\n        return count\n\n    return str(count_operations(points))\n"
    },
    {
        "number": 489,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def min_triples(a: list) -> int:\n        n = len(a)\n        min_sum = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    min_sum = min(min_sum, a[i] * a[j] * a[k])\n        return min_sum\n\n    result = min_triples(a)\n    print(result)\n    return \"\"\n"
    },
    {
        "number": 490,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"2\"\n    if n == 3:\n        return \"3\"\n    if n == 4:\n        return \"4\"\n    if n == 5:\n        return \"5\"\n    if n == 6:\n        return \"6\"\n    if n == 7:\n        return \"7\"\n    if n == 8:\n        return \"8\"\n    if n == 9:\n        return \"9\"\n    if n == 10:\n        return \"10\"\n    if n == 11:\n        return \"11\"\n    if n == 12:\n        return \"12\"\n    if n == 13:\n        return \"13\"\n    if n == 14:\n        return \"14\"\n    if n == 15:\n        return \"15\"\n    if n == 16:\n        return \"16\"\n    if n == 17:\n        return \"17\"\n    if n == 18:\n        return \"18\"\n    if n == 19:\n        return \"19\"\n    if n == 20:\n        return \"20\"\n    if n == 21:\n        return \"21\"\n    if n == 22:\n        return \"22\"\n    if n == 23:\n        return \"23\"\n    if n == 24:\n        return \"24\"\n    if n == 25:\n        return \"25\"\n    if n == 26:\n        return \"26\"\n    if n == 27:\n        return \"27\"\n    if n == 28:\n        return \"28\"\n    if n == 29:\n        return \"29\"\n    if n == 30:\n        return \"30\"\n    if n == 31:\n        return \"31\"\n    if n == 32:\n        return \"32\"\n    if n == 33:\n        return \"33\"\n    if n == 34:\n        return \"34\"\n    if n == 35:\n        return \"35\"\n    if n == 36:\n        return \"36\"\n    if n == 37:\n        return \"37\"\n    if n == 38:\n        return \"38\"\n    if n == 39:\n        return \"39\"\n    if n == 40:\n        return \"40\"\n    if n == 41:\n        return \"41\"\n    if n == 42:\n        return \"42\"\n    if n == 43:\n        return \"43\"\n    if n == 44:\n        return \"44\"\n    if n == 45:\n        return \"45\"\n    if n == 46:\n        return \"46\"\n    if n == 47:\n        return \"47\"\n    if n == 48:\n        return \"48\"\n    if n == 49:\n        return \"49\"\n    if n == 50:\n        return \"50\"\n    if n == 51:\n        return \"51\"\n    if n == 52:\n        return \"52\"\n    if n == 53:\n        return \"53\"\n    if n == 54:\n        return \"54\"\n    if n == 55:\n        return \"55\"\n    if n == 56:\n        return \"56\"\n    if n == 57:\n        return \"57\"\n    if n == 58:\n        return \"58\"\n    if n == 59:\n        return \"59\"\n    if n == 60:\n        return \"60\"\n    if n == 61:\n        return \"61\"\n    if n == 62:\n        return \"62\"\n    if n == 63:\n        return \"63\"\n    if n == 64:\n        return \"64\"\n    if n == 65:\n        return \"65\"\n    if n == 66:\n        return \"66\"\n    if n == 67:\n        return \"67\"\n    if n == 68:\n        return \"68\"\n    if n == 69:\n        return \"69\"\n    if n == 70:\n        return \"70\"\n    if n == 71:\n        return \"71\"\n    if n == 72:\n        return \"72\"\n    if n == 73:\n        return \"73\"\n   "
    },
    {
        "number": 491,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_state = 0\n    while n > 0:\n        max_state = max(max_state, n % 10)\n        n //= 10\n    return str(max_state)"
    },
    {
        "number": 492,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    start, end, n = stdin.split()\n    start = start.lower()\n    end = end.lower()\n\n    if start == end:\n        return \"undefined\"\n\n    if start == \"v\" and end == \"^\":\n        return \"cw\"\n    elif start == \"<\" and end == \"^\":\n        return \"ccw\"\n    elif start == \"^\" and end == \"v\":\n        return \"ccw\"\n    elif start == \">\" and end == \"^\":\n        return \"cw\"\n    else:\n        return \"undefined\""
    },
    {
        "number": 493,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    left_pushes = 0\n    right_pushes = 0\n    for i in range(n):\n        if s[i] == \"L\":\n            left_pushes += 1\n        elif s[i] == \"R\":\n            right_pushes += 1\n    return str(left_pushes + right_pushes)"
    },
    {
        "number": 494,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    leaders = list(map(int, stdin.split()))\n\n    def find_permutation(leaders: List[int]) -> List[int]:\n        def backtrack(start: int, current: List[int], result: List[int]) -> None:\n            if len(current) == n:\n                result.append(current[:])\n                return\n\n            for i in range(start, n):\n                if i not in current:\n                    backtrack(i + 1, current + [i], result)\n\n        result = []\n        backtrack(0, [], result)\n        return result\n\n    permutations = find_permutation(leaders)\n    if not permutations:\n        return -1\n\n    for permutation in permutations:\n        if all(leader in permutation for leader in leaders):\n            return \" \".join(map(str, permutation))\n\n    return -1\n"
    },
    {
        "number": 495,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = map(int, stdin.split())\n    max_num = a\n    for i in range(k):\n        max_num = max(max_num, a * 10 + a % 10)\n        a = a // 10\n    return str(max_num)"
    },
    {
        "number": 496,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sequence = list(map(int, stdin.split()))\n    n = len(sequence)\n\n    if n < 4:\n        return \"42\"\n\n    if sequence[0] == 1:\n        is_geometric = True\n    else:\n        is_geometric = False\n\n    for i in range(1, n - 1):\n        if sequence[i] == sequence[i - 1] + sequence[i + 1]:\n            is_geometric = True\n            break\n\n    if is_geometric:\n        next_element = sequence[n - 1] - 1\n        for i in range(n - 1, 0, -1):\n            if sequence[i] == next_element:\n                next_element = sequence[i - 1] - 1\n            else:\n                break\n    else:\n        next_element = sequence[n - 1] + sequence[1]\n\n    if next_element % 1!= 0:\n        return \"42\"\n\n    return str(next_element)\n"
    },
    {
        "number": 497,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *colors = map(int, stdin.split())\n    colors = set(colors)\n    if len(colors) < 2:\n        return \"1\"\n\n    min_distance = float(\"inf\")\n    for i in range(n):\n        for j in range(i + 1, n):\n            if colors.issubset({colors[i], colors[j]}):\n                distance = abs(j - i)\n                min_distance = min(min_distance, distance)\n\n    return str(min_distance)\n"
    },
    {
        "number": 498,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    k -= 1\n    left_count = 0\n    right_count = 0\n    for i in range(n):\n        for j in range(m):\n            if j == k:\n                left_count += 1\n            elif j == k + 1:\n                right_count += 1\n    if left_count > right_count:\n        r = 1\n        d = k + 1\n        s = \"L\"\n    else:\n        r = 2\n        d = k\n        s = \"R\"\n    return f\"{r} {d} {s}\""
    },
    {
        "number": 499,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    colors = set(s)\n    colors.remove('B')\n    colors.remove('G')\n    colors.remove('R')\n    colors = sorted(colors)\n    return ''.join(colors)"
    },
    {
        "number": 500,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited)\n\n    if all(visited):\n        return \"YES\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in zip(range(n), visited))\n    else:\n        return \"NO\\n\"\n"
    },
    {
        "number": 501,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    if l > r:\n        l, r = r, l\n\n    def get_next_set(set_name: str) -> list:\n        if set_name == \"first\":\n            return [2 * i + 1 for i in range(len(set_first))]\n        elif set_name == \"second\":\n            return [2 * i + 2 for i in range(len(set_second))]\n        else:\n            raise ValueError(\"Invalid set name\")\n\n    set_first = [1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n    set_second = [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\n    total = 0\n    for i in range(l, r + 1):\n        if i % 2 == 0:\n            set_name = \"first\"\n        else:\n            set_name = \"second\"\n\n        next_set = get_next_set(set_name)\n        total += i * len(next_set)\n\n    return str((total % (10 ** 9 + 7)))"
    },
    {
        "number": 502,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n\n    # Check if the points are distinct\n    if a_x == b_x and a_x == c_x and a_y == b_y and a_y == c_y:\n        return \"No\"\n\n    # Calculate the angle between the lines AB and AC\n    angle_AB = atan2(b_y - a_y, b_x - a_x)\n    angle_AC = atan2(c_y - a_y, c_x - a_x)\n\n    # Check if the angle is between 0 and 180 degrees\n    if angle_AB < 0:\n        angle_AB += 2 * pi\n    if angle_AC < 0:\n        angle_AC += 2 * pi\n\n    if angle_AB > 180 or angle_AC > 180:\n        return \"No\"\n\n    # Calculate the new position of A\n    x_A = a_x + cos(angle_AB) * (b_x - a_x) + sin(angle_AB) * (b_y - a_y)\n    y_A = a_y - sin(angle_AB) * (b_x - a_x) + cos(angle_AB) * (b_y - a_y)\n\n    # Calculate the new position of B\n    x_B = b_x + cos(angle_AC) * (c_x - b_x) + sin(angle_AC) * (c_y - b_y)\n    y_B = b_y - sin(angle_AC) * (c_x - b_x) + cos(angle_AC) * (c_y - b_y)\n\n    # Check if the new positions of A and B are the same\n    if x_A == x_B and y_A == y_B:\n        return \"Yes\"\n    else:\n        return \"No\"\n\n\ndef"
    },
    {
        "number": 503,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_geometric_progression(a, k):\n        a_len = len(a)\n        for i in range(a_len - 2):\n            if a[i] * k ** i!= a[i + 1] * k ** (i + 1):\n                return False\n        return True\n\n    def count_geometric_progressions(a, k):\n        count = 0\n        for i in range(len(a) - 2):\n            if a[i] * k ** i == a[i + 1] * k ** (i + 1):\n                count += 1\n        return count\n\n    def count_subsequences(a, k):\n        count = 0\n        for i in range(len(a) - 2):\n            for j in range(i + 1, len(a) - 1):\n                for k in range(j + 1, len(a)):\n                    if a[i] * k ** i == a[j] * k ** (j - i) == a[k] * k ** (k - j):\n                        count += 1\n        return count\n\n    def count_subsequences_with_common_ratio(a, k):\n        count = 0\n        for i in range(len(a) - 2):\n            for j in range(i + 1, len(a) - 1):\n                for k in range(j + 1, len(a)):\n                    if a[i] * k ** i == a[j] * k ** (j - i) == a[k] * k ** (k - j):\n                        count += 1\n                        if gcd(a[i], a[j]) == gcd(a[j], a[k]):\n                            return count\n        return count\n\n    if is_geometric_progression(a, k):\n        return str(count_geometric_progressions(a, k))\n    else:\n        return str(count_subsequences_with_common_ratio(a, k))"
    },
    {
        "number": 504,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    creatures = []\n    for _ in range(n):\n        hp, dmg = map(int, stdin.split())\n        creatures.append((hp, dmg))\n\n    def max_damage(spells: list[tuple[int, int]], creatures: list[tuple[int, int]]) -> int:\n        total_damage = 0\n        for spell in spells:\n            for _ in range(spell[0]):\n                total_damage += sum(spell[1] * creatures[i][0] for i in range(n))\n        return total_damage\n\n    spells_first = [(a, 1)]\n    spells_second = [(b, 1)]\n\n    while True:\n        max_damage_first = max_damage(spells_first, creatures)\n        max_damage_second = max_damage(spells_second, creatures)\n\n        if max_damage_first > max_damage_second:\n            spells_first.append((a, 1))\n            spells_second.append((b, 1))\n        else:\n            spells_first.append((b, 1))\n            spells_second.append((a, 1))\n\n        if max_damage_first == max_damage_second:\n            break\n\n    return str(max_damage_first)\n"
    },
    {
        "number": 505,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    maze = [list(row) for row in stdin.splitlines()]\n    visited = set()\n    visited.add(tuple(maze.index(row.index(\"X\")) for row in maze))\n\n    def dfs(i, j, cycle, cycle_length):\n        if cycle_length == k:\n            return cycle\n\n        if (i, j) in visited:\n            return \"IMPOSSIBLE\"\n\n        visited.add((i, j))\n\n        if maze[i][j] == \".\":\n            cycle.append(maze[i][j])\n            cycle_length += 1\n            dfs(i + 1, j, cycle, cycle_length)\n            dfs(i - 1, j, cycle, cycle_length)\n            dfs(i, j + 1, cycle, cycle_length)\n            dfs(i, j - 1, cycle, cycle_length)\n            dfs(i + 1, j + 1, cycle, cycle_length)\n            dfs(i - 1, j - 1, cycle, cycle_length)\n            dfs(i + 1, j - 1, cycle, cycle_length)\n            dfs(i - 1, j + 1, cycle, cycle_length)\n            cycle.pop()\n            cycle_length -= 1\n\n        visited.remove((i, j))\n        return \"IMPOSSIBLE\"\n\n    cycle = []\n    cycle_length = 0\n    dfs(0, 0, cycle, cycle_length)\n    return \"\".join(cycle)\n"
    },
    {
        "number": 506,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    ships = 0\n    while a > b:\n        ships += 1\n        a -= b\n    return str(ships)"
    },
    {
        "number": 507,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    a = set(a)\n    b = set(b)\n    for i in range(n):\n        if a[i] == b[i]:\n            return \" \".join(map(str, range(1, n + 1)))\n    return \" \".join(map(str, a))"
    },
    {
        "number": 508,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    a = a * (math.pi / 180)\n    angles = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                angle = math.degrees(math.acos((i - 1) * (j - 1) * (k - 1) / (math.sqrt(i * j * k))))\n                if angle == a:\n                    angles.append((i, j, k))\n    if not angles:\n        return \"No solution\"\n    angles.sort(key=lambda x: (x[0] - 1, x[1] - 1, x[2] - 1))\n    return \" \".join(map(str, [angles[0][0], angles[0][1], angles[0][2]]))"
    },
    {
        "number": 509,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n    a.sort()\n    for i in range(n):\n        a[i] %= 360\n    for i in range(n):\n        if a[i] == 0:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 510,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    min_duration = float('inf')\n    current_position = a\n    current_distance = 0\n\n    for i in range(1, 1000000):\n        if current_position == b or current_position == c:\n            min_duration = min(min_duration, i)\n            current_position += 1\n            current_distance = 0\n        elif current_position == a:\n            min_duration = min(min_duration, i)\n            current_position += 1\n            current_distance = 0\n        else:\n            current_position += 1\n            current_distance += 1\n\n        if current_distance >= d:\n            break\n\n    return str(min_duration)"
    },
    {
        "number": 511,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    f = lambda a, b: 1 + f(a, b - gcd(a, b)) if b else 0\n    return str(f(x, y))\n\ndef"
    },
    {
        "number": 512,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n    a = [x for x in a if x!= -1]\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i] + 1\n    for i in range(n):\n        if b[i] == -1:\n            b[i] = 2 * n\n    for i in range(n):\n        if a[i] == -1:\n            a[i] = 1\n    for i in range(n):\n        if a[i] > b[i]:\n            a[i], b[i] = b[i], a[i]\n    for i in range(n):\n        if a[i] == b[i]:\n            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 513,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    x1, y1, x2, y2, x3, y3, x4, y4 = points\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y2 or x3 == x4 or y3 == y4:\n        return \"ugly\"\n\n    if x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x2 or x4 == x2:\n        return \"ugly\"\n\n    if y1 == y3 or y1 == y4 or y2 == y3 or y2 == y4 or y3 == y2 or y4 == y2:\n        return \"ugly\"\n\n    if x1 == x2 or y1 == y"
    },
    {
        "number": 514,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        n, d = map(int, stdin.split('\\n')[1].split())\n        if d <= n:\n            print('YES')\n        else:\n            print('NO')"
    },
    {
        "number": 515,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    if k > 10**6:\n        return -1\n\n    n = 1\n    while True:\n        if sum(int(digit) for digit in str(n)) == k:\n            return str(n)\n        n += 1"
    },
    {
        "number": 516,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def replace_symbol(s, symbol):\n        return s.replace(symbol, \"?\")\n\n    def find_substring(s, t):\n        return t in s\n\n    def find_symbol(s, symbol):\n        return symbol in s\n\n    def find_positions(s, symbol):\n        positions = []\n        for i, c in enumerate(s):\n            if c == symbol:\n                positions.append(i + 1)\n        return positions\n\n    def find_min_symbols(s, t):\n        min_symbols = 0\n        for symbol in \"?!@#$%^&*()_+-=[]{}|;':\\\",./<>?\":\n            if find_symbol(s, symbol) and find_substring(replace_symbol(s, symbol), t):\n                min_symbols += 1\n        return min_symbols\n\n    def find_min_positions(s, t):\n        min_positions = []\n        for symbol in \"?!@#$%^&*()_+-=[]{}|;':\\\",./<>?\":\n            if find_symbol(s, symbol) and find_substring(replace_symbol(s, symbol), t):\n                positions = find_positions(s, symbol)\n                min_positions.extend(positions)\n        return min_positions\n\n    min_symbols = find_min_symbols(s, t)\n    min_positions = find_min_positions(s, t)\n\n    return str(min_symbols) + \"\\n\" + \" \".join(map(str, min_positions))\n"
    },
    {
        "number": 517,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, h = map(int, stdin.split())\n\n    if d > n - 1 or h > d or h > n - 1:\n        return \"-1\"\n\n    def dfs(vertex, visited, path):\n        if vertex == n:\n            return True\n\n        for neighbor in range(1, n + 1):\n            if neighbor not in visited and (neighbor - 1) % d!= 0:\n                visited.add(neighbor)\n                path.append(neighbor)\n                if dfs(neighbor, visited, path):\n                    return True\n                visited.remove(neighbor)\n                path.pop()\n\n        return False\n\n    visited = set()\n    path = []\n    if dfs(1, visited, path):\n        return \" \".join(map(str, path))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 518,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    R = 2 * r * n\n    return str(R)"
    },
    {
        "number": 519,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, p, q = map(int, stdin.split())\n    p_speed = p\n    q_speed = q\n    distance = 0\n    while True:\n        distance += 1\n        if distance == l:\n            break\n        if p_speed > q_speed:\n            p_speed -= 1\n        else:\n            q_speed -= 1\n    return str(distance)"
    },
    {
        "number": 520,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(set(a))\n    for i in range(1, n):\n        if a[i] - a[i - 1] > 1:\n            return a[i]\n    return a[-1]"
    },
    {
        "number": 521,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(stdin.split()[1])\n\n    # Count the number of painted segments\n    painted = sum(1 for c in s if c!= '?')\n\n    # If there are less than two painted segments, there are no different ways\n    if painted < 2:\n        return \"No\"\n\n    # Initialize a boolean array to keep track of whether each segment has been painted\n    painted_segments = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted = [False] * n\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count_2 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count_2 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count_2 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count_3 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count_3 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count_3 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count_4 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count_4 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count_4 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count_5 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count_5 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count_5 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count_6 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count_6 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count_6 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the current way\n    current_way_painted_count_7 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the previous way\n    previous_way_painted_count_7 = 0\n\n    # Initialize a boolean array to keep track of whether each segment has been painted in the next way\n    next_way_painted_count"
    },
    {
        "number": 522,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f1, f2, f3, c = map(int, stdin.split())\n    MOD = 10**9 + 7\n    f4 = (c ** 2 * f1 ** 2 * f2 ** 2 * f3 ** 2) % MOD\n    f5 = (f1 * f2 * f3 * f4) % MOD\n    for i in range(4, n + 1):\n        f6 = (c ** 2 * f5 ** 2 * f1 ** 2 * f2 ** 2) % MOD\n        f7 = (f5 * f1 * f2 * f6) % MOD\n        f5 = f7\n    return str(f5)"
    },
    {
        "number": 523,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    strings = [input().strip() for _ in range(n)]\n    palindromes = [s[::-1] for s in strings]\n    palindromes.sort(key=len, reverse=True)\n    longest_palindrome = \"\"\n    for p in palindromes:\n        if p == p[::-1]:\n            longest_palindrome = p\n            break\n    return str(len(longest_palindrome)) + \"\\n\" + longest_palindrome"
    },
    {
        "number": 524,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def power_sequence(a: list, c: int) -> int:\n        n = len(a)\n        for i in range(n):\n            a[i] = c ** i\n        return a\n\n    def reorder(a: list) -> list:\n        p = list(range(n))\n        for i in range(n):\n            j = random.randint(0, n - 1)\n            p[i], p[j] = p[j], p[i]\n        return p\n\n    def increment(a: list, i: int) -> int:\n        a[i] += 1\n        return a\n\n    def decrement(a: list, i: int) -> int:\n        a[i] -= 1\n        return a\n\n    def min_cost(a: list, p: list) -> int:\n        cost = 0\n        for i in range(n):\n            a[i] = p[i]\n            if a[i] == 1:\n                cost += 1\n            elif a[i] == n:\n                cost += 1\n            else:\n                cost += abs(a[i] - 1)\n        return cost\n\n    p = reorder(a)\n    a = power_sequence(a, 1)\n    min_cost_1 = min_cost(a, p)\n\n    a = increment(a, random.randint(0, n - 1))\n    min_cost_2 = min_cost(a, p)\n\n    a = decrement(a, random.randint(0, n - 1))\n    min_cost_3 = min_cost(a, p)\n\n    return min(min_cost_1, min_cost_2, min_cost_3)"
    },
    {
        "number": 525,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        count = 0\n        while count < n:\n            i = 1\n            while i < n - 1 and a[i] == a[i + 1]:\n                i += 1\n            if i < n - 1:\n                a[i], a[i + 1] = a[i + 1], a[i]\n                count += 1\n        print(len(a))"
    },
    {
        "number": 526,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        a.append(row)\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 0:\n                a[i][j] = 1023\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 1)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 2)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 4)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 8)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 16)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 32)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 64)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 128)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 256)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 512)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 1024)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 2048)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 4096)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 8192)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 16384)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 32768)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 65536)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 131072)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 262144)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 524288)\n\n    for i in range(n):\n        for j in range(m):\n            a[i][j] = a[i][j] ^ (a[i][j] >> 1048576)\n\n    for"
    },
    {
        "number": 527,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = s * 10**100\n    t = t.lower()\n    i = 0\n    while i < 10**100:\n        s_i = s[:i]\n        if t in s_i:\n            return str(i)\n        i += 1\n    return \"-1\""
    },
    {
        "number": 528,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        friends.add((a, b))\n        friends.add((b, a))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) in friends and (j, i) in friends:\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 529,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    n = int(stdin.split()[1])\n    result = \"\"\n    for i in range(n):\n        result += alphabet[i % 26]\n    return result"
    },
    {
        "number": 530,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split())\n    s = list(s)\n    t = list(t)\n\n    def play_game(s, t, player):\n        s_index = 0\n        t_index = 0\n        result = []\n        while s_index < len(s) and t_index < len(t):\n            if s[s_index] == t[t_index]:\n                result.append(s[s_index])\n                s_index += 1\n                t_index += 1\n            elif s[s_index] < t[t_index]:\n                s_index += 1\n            else:\n                t_index += 1\n        return result\n\n    def max_number(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return max_s if max_s > max_t else max_t\n\n    def max_number_index(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_index_with_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return max_s if max_s > max_t else max_t\n\n    def max_number_with_leading_zeros_index(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros_and_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros_and_leading_zeros_and_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s) if max_s > max_t else t.index(max_t)\n\n    def max_number_with_leading_zeros_index_with_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros_and_leading_zeros(s, t):\n        max_s = max(s)\n        max_t = max(t)\n        return s.index(max_s)"
    },
    {
        "number": 531,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1].split()))\n\n    # Check if the difference between the maximum and minimum values is at most 2\n    if max(x) - min(x) > 2:\n        return \"Invalid input\"\n\n    # Sort the values\n    x.sort()\n\n    # Initialize the variables\n    strike_off = 0\n    equal_count = 0\n    y = []\n\n    # Iterate through the values\n    for i in range(n):\n        # Check if there is an equal value in Kirill's work\n        if x[i] == x[i + 1]:\n            # If there is, strike off the value\n            strike_off += 1\n            # If there are more than two equal values, increment the count\n            if strike_off > 2:\n                equal_count += 1\n        else:\n            # If there is not, add the value to the output\n            y.append(x[i])\n\n    # Check if there are more than two equal values\n    if equal_count > 2:\n        return \"Invalid input\"\n\n    # Check if the minimum value among Anya's values is not less than the minimum among Kirill's values\n    if min(y) < min(x):\n        return \"Invalid input\"\n\n    # Check if the maximum value among Anya's values is not greater than the maximum among Kirill's values\n    if max(y) > max(x):\n        return \"Invalid input\"\n\n    # Print the minimum possible number of equal measurements\n    print(equal_count)\n\n    # Print the values in the desired order\n    print(\" \".join(map(str, y)))\n\n    return \"Valid input\"\n"
    },
    {
        "number": 532,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    exhibit_name = stdin.lower()\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    alphabet_index = {letter: index for index, letter in enumerate(alphabet)}\n    exhibit_name_index = alphabet_index[exhibit_name[0]]\n\n    def rotate_wheel(index: int) -> int:\n        return (index + 1) % 26\n\n    def print_letter(letter: str) -> None:\n        print(letter, end=\"\")\n\n    def print_exhibit_name() -> None:\n        print(exhibit_name, end=\"\")\n\n    def print_exhibit_name_with_rotation(rotation: int) -> None:\n        print_letter(exhibit_name[0])\n        for _ in range(rotation):\n            print_letter(exhibit_name[0])\n\n    def find_minimum_rotation() -> int:\n        current_index = exhibit_name_index\n        minimum_rotation = 0\n        while True:\n            next_index = rotate_wheel(current_index)\n            if next_index == exhibit_name_index:\n                return minimum_rotation\n            minimum_rotation += 1\n            current_index = next_index\n\n    minimum_rotation = find_minimum_rotation()\n    print(minimum_rotation)\n"
    },
    {
        "number": 533,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, k1, k2, n = map(int, stdin.split())\n\n    min_players = max(0, a1 * k1 + a2 * k2 - n)\n    max_players = min(a1 * k1 + a2 * k2, n)\n\n    return f\"{min_players} {max_players}\""
    },
    {
        "number": 534,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s = stdin.split()[1]\n    queue = [i for i in range(1, n + 1)]\n    time = 0\n    result = []\n\n    while time < t:\n        for i in range(len(queue)):\n            if queue[i] == 1:\n                if s[i - 1] == 'B':\n                    queue[i] = 2\n                else:\n                    queue[i] = 3\n            elif queue[i] == 2:\n                if s[i - 1] == 'G':\n                    queue[i] = 1\n                else:\n                    queue[i] = 3\n            elif queue[i] == 3:\n                if s[i - 1] == 'B':\n                    queue[i] = 1\n                else:\n                    queue[i] = 2\n\n        time += 1\n        result.append(s[queue.index(1) - 1])\n\n    return ''.join(result)"
    },
    {
        "number": 535,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    P = 1\n    Q = 1\n    for i in range(2, n+1):\n        P *= i\n        Q *= 58\n    P %= 10**9 + 7\n    Q %= 10**9 + 7\n    return str((P * pow(Q, -1, 10**9 + 7)) % (10**9 + 7))"
    },
    {
        "number": 536,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n + m > 10**6:\n        return -1\n\n    def is_valid(cards: list[int]) -> bool:\n        zero_count = 0\n        one_count = 0\n        for card in cards:\n            if card == 0:\n                zero_count += 1\n            elif card == 1:\n                one_count += 1\n            else:\n                return False\n            if zero_count > 1 or one_count > 1:\n                return False\n            if zero_count > 0 and one_count > 0 and (card - 1) % 3 == 0:\n                return False\n        return True\n\n    def find_sequence(cards: list[int]) -> str:\n        sequence = []\n        for i in range(len(cards)):\n            if cards[i] == 0:\n                sequence.append(0)\n            else:\n                sequence.append(1)\n        return ''.join(map(str, sequence))\n\n    def find_sequences(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence):\n                    sequences.append(find_sequence(sub_sequence))\n        return sequences\n\n    def find_sequences_with_zeroes(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence) and sub_sequence[0] == 0:\n                    sequences.append(find_sequence(sub_sequence))\n        return sequences\n\n    def find_sequences_with_ones(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence) and sub_sequence[-1] == 1:\n                    sequences.append(find_sequence(sub_sequence))\n        return sequences\n\n    def find_sequences_with_zeroes_and_ones(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence) and sub_sequence[0] == 0 and sub_sequence[-1] == 1:\n                    sequences.append(find_sequence(sub_sequence))\n        return sequences\n\n    def find_sequences_with_zeroes_and_ones_in_any_order(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence) and sub_sequence[0] == 0 and sub_sequence[-1] == 1:\n                    sequences.append(find_sequence(sub_sequence))\n        return sequences\n\n    def find_sequences_with_zeroes_and_ones_in_any_order_with_zeroes(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence) and sub_sequence[0] == 0 and sub_sequence[-1] == 1:\n                    sequences.append(find_sequence(sub_sequence))\n        return sequences\n\n    def find_sequences_with_zeroes_and_ones_in_any_order_with_ones(cards: list[int]) -> list[str]:\n        sequences = []\n        for i in range(1, len(cards) + 1):\n            for j in range(len(cards) - i + 1):\n                sub_sequence = cards[j:j + i]\n                if is_valid(sub_sequence) and sub_sequence[0] == 0 and sub_sequence[-1] == 1"
    },
    {
        "number": 537,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    diplomas = 0\n    certificates = 0\n    not_winners = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            diplomas += 1\n        else:\n            certificates += 1\n\n        if i % 2 == 0 and certificates >= k * diplomas:\n            not_winners += 1\n\n    max_winners = min(n // 2, n - not_winners)\n    max_winners_with_diplomas = max(0, max_winners - diplomas)\n    max_winners_with_certificates = max(0, max_winners - certificates)\n\n    return f\"{max_winners_with_diplomas} {max_winners_with_certificates} {not_winners}\""
    },
    {
        "number": 538,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 10:\n        return \"NO\"\n    if x < 100:\n        return \"YES\"\n    if x < 1000:\n        return \"NO\"\n    if x < 10000:\n        return \"YES\"\n    if x < 100000:\n        return \"NO\"\n    if x < 1000000:\n        return \"YES\"\n    if x < 10000000:\n        return \"NO\"\n    if x < 100000000:\n        return \"YES\"\n    if x < 1000000000:\n        return \"NO\"\n    if x < 10000000000:\n        return \"YES\"\n    if x < 100000000000:\n        return \"NO\"\n    if x < 1000000000000:\n        return \"YES\"\n    if x < 10000000000000:\n        return \"NO\"\n    if x < 100000000000000:\n        return \"YES\"\n    if x < 1000000000000000:\n        return \"NO\"\n    if x < 10000000000000000:\n        return \"YES\"\n    if x < 100000000000000000:\n        return \"NO\"\n    if x < 1000000000000000000:\n        return \"YES\"\n    if x < 10000000000000000000:\n        return \"NO\"\n    if x < 100000000000000000000:\n        return \"YES\"\n    if x < 1000000000000000000000:\n        return \"NO\"\n    if x < 10000000000000000000000:\n        return \"YES\"\n    if x < 100000000000000000000000:\n        return \"NO\"\n    if x < 1000000000000000000000000:\n        return \"YES\"\n    if x < 10000000000000000000000000:\n        return \"NO\"\n    if x < 100000000000000000000000000:\n        return \"YES\"\n    if x < 1000000000000000000000000000:\n        return \"NO\"\n    if x < 10000000000000000000000000000:\n        return \"YES\"\n    if x < 100000000000000000000000000000:\n        return \"NO\"\n    if x < 1000000000000000000000000000000:\n        return \"YES\"\n    if x < 10000000000000000000000000000000:\n        return \"NO\"\n    if x < 100000000000000000000000000000000:\n        return \"YES\"\n    if x < 1000000000000000000000000000000000:\n        return \"NO\"\n    if x < 10000000000000000000000000000000000:\n        return \"YES\"\n    if x < 100000000"
    },
    {
        "number": 539,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            for k in range(1, n+1):\n                if a + b + c == 0:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 540,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n    r_1, c_1 = map(int, stdin.split()[2].split())\n    r_2, c_2 = map(int, stdin.split()[3].split())\n\n    def is_valid(r: int, c: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= m\n\n    def is_intact(r: int, c: int) -> bool:\n        return grid[r - 1][c - 1] == '.'\n\n    def is_cracked(r: int, c: int) -> bool:\n        return grid[r - 1][c - 1] == 'X'\n\n    def move(r: int, c: int, dr: int, dc: int) -> None:\n        if not is_valid(r + dr, c + dc):\n            return\n        if is_intact(r + dr, c + dc):\n            grid[r - 1][c - 1] = 'X'\n        else:\n            grid[r - 1][c - 1] = '.'\n\n    def fall_through(r: int, c: int) -> None:\n        move(r, c, 0, 1)\n        move(r, c, 0, 1)\n        move(r, c, 0, 1)\n\n    def can_reach(r: int, c: int) -> bool:\n        return is_valid(r_2, c_2) and (is_intact(r_2, c_2) or is_cracked(r_2, c_2))\n\n    if can_reach(r_1, c_1):\n        fall_through(r_1, c_1)\n        if can_reach(r_2, c_2):\n            return 'YES'\n        else:\n            return 'NO'\n    else:\n        return 'NO'"
    },
    {
        "number": 541,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    a_set = set(a)\n    b_set = set(b)\n    if len(a_set)!= len(b_set):\n        return \"IMPOSSIBLE\"\n    bridges = 0\n    for i in range(n):\n        if i not in a_set and i not in b_set:\n            bridges += 1\n    return str(bridges)"
    },
    {
        "number": 542,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n    a.sort()\n    if a[0] == a[1]:\n        if a[2] > a[3]:\n            return \"first\"\n        else:\n            return \"second\"\n    else:\n        return \"first\" if a[0] > a[1] else \"second\""
    },
    {
        "number": 543,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [0] + a\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1]\n        for j in range(i):\n            if a[j] > 0:\n                dp[i] += dp[i - j - 1]\n    if dp[n] == 0:\n        return \"NO\"\n    return \"YES\""
    },
    {
        "number": 544,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        n = int(stdin.split()[1])\n        s = stdin.split()[2]\n        s = ''.join(sorted(s))\n        if s == s[::-1]:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 545,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s1, s2 = stdin.split()\n    s1 = list(s1)\n    s2 = list(s2)\n\n    def f(a, b):\n        return sum(1 for i in range(n) if a[i]!= b[i])\n\n    for i in range(n):\n        if f(s1, s1[:i] + s1[i+1:]) == t:\n            return ''.join(s1[:i] + s1[i+1:])\n        if f(s2, s2[:i] + s2[i+1:]) == t:\n            return ''.join(s2[:i] + s2[i+1:])\n\n    return -1"
    },
    {
        "number": 546,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    good_letters, pattern = stdin.split('\\n')\n    n = int(stdin.split('\\n')[1])\n    queries = stdin.split('\\n')[2:]\n\n    def replace_pattern(pattern: str) -> str:\n        result = []\n        for char in pattern:\n            if char == '?':\n                result.append(good_letters[0])\n            elif char == '*':\n                result.append('')\n            else:\n                result.append(char)\n        return ''.join(result)\n\n    def is_match(pattern: str, query: str) -> bool:\n        return replace_pattern(pattern) == query\n\n    result = []\n    for query in queries:\n        if is_match(pattern, query):\n            result.append('YES')\n        else:\n            result.append('NO')\n\n    return '\\n'.join(result)"
    },
    {
        "number": 547,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    passwords = stdin.split('\\n')[1:]\n    codehorses_password = stdin.split('\\n')[-1]\n\n    def is_valid_password(password: str) -> bool:\n        return len(set(password)) == len(password)\n\n    def is_valid_codehorses_password(password: str) -> bool:\n        return password == codehorses_password\n\n    def is_valid_password_length(password: str) -> bool:\n        return len(password) <= 100\n\n    def is_valid_password_order(password: str) -> bool:\n        return all(password[i] < password[i + 1] for i in range(len(password) - 1))\n\n    def is_valid_password_set(password: str) -> bool:\n        return is_valid_password_length(password) and is_valid_password_order(password)\n\n    def is_valid_password_combination(password: str) -> bool:\n        return is_valid_password_set(password) and is_valid_codehorses_password(password)\n\n    def is_valid_password_combination_set(passwords: List[str]) -> bool:\n        return all(is_valid_password_combination(password) for password in passwords)\n\n    def is_valid_password_combination_set_with_duplicates(passwords: List[str]) -> bool:\n        return len(passwords) == len(set(passwords))\n\n    def is_valid_password_combination_set_with_duplicates_and_order(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates(passwords) and is_valid_password_order(passwords[0])\n\n    def is_valid_password_combination_set_with_duplicates_and_order_and_length(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates_and_order(passwords) and is_valid_password_length(passwords[0])\n\n    def is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates_and_order_and_length(passwords) and is_valid_codehorses_password(passwords[0])\n\n    def is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password(passwords) and is_valid_password_order(passwords[0])\n\n    def is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order_and_length(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order(passwords) and is_valid_password_length(passwords[0])\n\n    def is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order_and_length_and_valid_codehorses_password(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order_and_length(passwords) and is_valid_codehorses_password(passwords[0])\n\n    def is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order_and_length_and_valid_codehorses_password_and_valid_order(passwords: List[str]) -> bool:\n        return is_valid_password_combination_set_with_duplicates_and_order_and_length_and_codehorses_password_and_valid_order_and_length_and_valid_codehorses_password(passwords) and is_valid_password_order(passwords[0])\n\n    def is_valid_password_combination_set_with"
    },
    {
        "number": 548,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def remove_subsegment(arr, start, end):\n        non_zero_sum = sum(arr[start:end+1])\n        if non_zero_sum % 2 == 0:\n            return arr[:start] + arr[end+1:]\n        else:\n            return arr[:start] + arr[end+1:end+1]\n\n    def check_win(arr):\n        odd_sum = sum(arr) % 2 == 1\n        for i in range(1, len(arr)):\n            if arr[i] % 2 == 0:\n                return False\n        return odd_sum\n\n    def first_player_move(arr):\n        max_sum = max(arr)\n        for i in range(len(arr)):\n            if arr[i] == max_sum:\n                return remove_subsegment(arr, i, i)\n        return arr\n\n    def second_player_move(arr):\n        min_sum = min(arr)\n        for i in range(len(arr)-1, -1, -1):\n            if arr[i] == min_sum:\n                return remove_subsegment(arr, i, i)\n        return arr\n\n    first_player_win = check_win(first_player_move(arr))\n    second_player_win = check_win(second_player_move(arr))\n\n    if first_player_win:\n        return \"First\"\n    elif second_player_win:\n        return \"Second\"\n    else:\n        return \"Tie\""
    },
    {
        "number": 549,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = n\n    while a <= b:\n        if a * b == n:\n            return f\"{a} {b}\"\n        elif a * b < n:\n            a += 1\n        else:\n            b -= 1\n    return \"Invalid input\""
    },
    {
        "number": 550,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()[0]\n    n = int(stdin.split()[1])\n    logins = stdin.split()[2:]\n\n    def similar(login: str) -> bool:\n        for i in range(len(login)):\n            if login[i].islower():\n                login = login[:i] + login[i].upper() + login[i+1:]\n            elif login[i].isupper():\n                login = login[:i] + login[i].lower() + login[i+1:]\n            elif login[i] == 'O':\n                login = login[:i] + '0' + login[i+1:]\n            elif login[i] == '1':\n                login = login[:i] + 'l' + login[i+1:]\n            elif login[i] == 'l':\n                login = login[:i] + 'L' + login[i+1:]\n            elif login[i] == 'I':\n                login = login[:i] + 'i' + login[i+1:]\n            elif login[i] == 'i':\n                login = login[:i] + 'I' + login[i+1:]\n            else:\n                login = login[:i] + login[i] + login[i+1:]\n        return login == s\n\n    for login in logins:\n        if similar(login):\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 551,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    y = list(map(int, stdin.split()[1:]))\n\n    # Check if all points lie on the same line\n    for i in range(n):\n        for j in range(i + 1, n):\n            if y[i] == y[j]:\n                return \"No\"\n\n    # Check if all points lie on the same line\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(y[i] - y[j]) == abs(y[j] - y[i]):\n                return \"No\"\n\n    # Check if all points lie on the same line\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(y[i] - y[j]) == abs(y[i] - y[j]):\n                return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 552,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b, s = stdin.split()\n\n    def count_ways(l1: int, r1: int, l2: int, r2: int) -> int:\n        if l1 > r1 or l2 > r2:\n            return 0\n\n        if l1 == l2 == r1 == r2:\n            return 1\n\n        if a[l1] == b[l2]:\n            return count_ways(l1 + 1, r1, l2 + 1, r2)\n\n        return count_ways(l1 + 1, r1, l2, r2)\n\n    ways = 0\n    for l1 in range(n):\n        for r1 in range(l1 + 1, n + 1):\n            for l2 in range(n):\n                for r2 in range(l2 + 1, n + 1):\n                    if a[l1:r1] + b[l2:r2] == s:\n                        ways += count_ways(l1, r1, l2, r2)\n\n    return str(ways)\n"
    },
    {
        "number": 553,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    promocodes = [int(p) for p in stdin.split()[1:]]\n    max_k = 0\n    for p in promocodes:\n        for i in range(6):\n            if p % 10 == i:\n                p //= 10\n            else:\n                p -= 1\n        if p == 0:\n            max_k = 0\n            break\n        max_k = max(max_k, p)\n    return str(max_k)"
    },
    {
        "number": 554,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flowers = list(map(int, stdin.split()))\n    subarrays = []\n    for i in range(m):\n        l, r = map(int, stdin.split())\n        subarrays.append((l, r))\n\n    happiness = 0\n    for flower in flowers:\n        for subarray in subarrays:\n            if flower in range(subarray[0], subarray[1] + 1):\n                happiness += flower * len(subarrays)\n                break\n\n    return str(happiness)"
    },
    {
        "number": 555,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    inverted_number = 0\n    while x > 0:\n        inverted_number = inverted_number * 10 + 9 - x % 10\n        x //= 10\n    return str(inverted_number)"
    },
    {
        "number": 556,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    if k == 1:\n        return \"1\"\n\n    def splay(node: int) -> int:\n        if node == 0:\n            return 0\n        if node < 0:\n            node = -node\n            node = splay(node)\n            node = -node\n            return node\n        node = splay(node * 2)\n        node = splay(node - 1)\n        return node\n\n    def splay_range(node: int, l: int, r: int) -> int:\n        if l == r:\n            return node\n        node = splay(node)\n        if l <= node and node <= r:\n            return splay_range(node * 2, l, r)\n        if l < node:\n            return splay_range(node * 2 + 1, l, r)\n        return splay_range(node * 2 - 1, l, r)\n\n    def expose(node: int, l: int, r: int) -> int:\n        if l == r:\n            return node\n        node = splay_range(node, l, r)\n        if l <= node and node <= r:\n            return expose(node * 2, l, r)\n        if l < node:\n            return expose(node * 2 + 1, l, r)\n        return expose(node * 2 - 1, l, r)\n\n    def print_powers(node: int, l: int, r: int) -> None:\n        if l == r:\n            print(l, end=\" \")\n            return\n        node = expose(node, l, r)\n        print_powers(node * 2, l, r)\n        print_powers(node * 2 + 1, l, r)\n\n    node = splay(1)\n    print_powers(node, l, r)\n    return \"\"\n"
    },
    {
        "number": 557,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teleports = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        teleports.append((a, b))\n\n    teleports.sort(key=lambda x: x[1])\n\n    def is_valid(x: int) -> bool:\n        for i in range(n):\n            if x >= teleports[i][0] and x <= teleports[i][1]:\n                return True\n        return False\n\n    if is_valid(m):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 558,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    colors = list(map(int, input().split()))\n\n    def backtrack(start, color, pairs):\n        if start == n:\n            return 1\n\n        count = 0\n        for i in range(start, n):\n            if colors[i] == color:\n                continue\n\n            if i - start <= k and colors[i - 1] == color:\n                continue\n\n            count += backtrack(i + 1, color, pairs)\n\n        return count % 998244353\n\n    return str(backtrack(0, 0, 0))"
    },
    {
        "number": 559,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, *a = map(int, stdin.split())\n    b = [0] * p\n    for i in range(p):\n        b[i] = a[i] % p\n    for i in range(p - 1):\n        b[i] = (b[i] + 1) % p\n    return \" \".join(map(str, b))"
    },
    {
        "number": 560,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    grid = [list(row) for row in stdin.splitlines()]\n\n    def is_valid(row, col):\n        return grid[row][col]!= 'S' and grid[row][col]!= '.'\n\n    def is_valid_row(row):\n        return all(is_valid(row, col) for col in range(c))\n\n    def is_valid_col(col):\n        return all(is_valid(row, col) for row in range(r))\n\n    def eat_cake(row, col):\n        nonlocal grid\n        grid[row][col] = '.'\n\n    def eat_valid_cell(row, col):\n        nonlocal grid\n        if is_valid(row, col):\n            eat_cake(row, col)\n\n    def eat_valid_cell_in_row(row):\n        nonlocal grid\n        for col in range(c):\n            if is_valid(row, col):\n                eat_cake(row, col)\n\n    def eat_valid_cell_in_col(col):\n        nonlocal grid\n        for row in range(r):\n            if is_valid(row, col):\n                eat_cake(row, col)\n\n    def eat_valid_cell_in_row_or_col(row, col):\n        nonlocal grid\n        if is_valid(row, col):\n            eat_cake(row, col)\n\n    eaten_cells = 0\n    while True:\n        valid_rows = [row for row in range(r) if is_valid_row(row)]\n        valid_cols = [col for col in range(c) if is_valid_col(col)]\n\n        if not valid_rows and not valid_cols:\n            break\n\n        if valid_rows:\n            row = valid_rows[0]\n            eat_valid_cell_in_row(row)\n            eaten_cells += c\n        elif valid_cols:\n            col = valid_cols[0]\n            eat_valid_cell_in_col(col)\n            eaten_cells += r\n        else:\n            row, col = valid_rows[0], valid_cols[0]\n            eat_valid_cell_in_row_or_col(row, col)\n            eaten_cells += 1\n\n    return str(eaten_cells)"
    },
    {
        "number": 561,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = map(int, stdin.split())\n    cards.sort()\n    count = 0\n    for i in range(len(cards) - 1):\n        if cards[i + 1] - cards[i] == 1:\n            count += 1\n    if count == 0:\n        return -1\n    else:\n        return str(count) +'' +''.join(map(str, cards))"
    },
    {
        "number": 562,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    shows = []\n    for i in range(n):\n        start, end = map(int, stdin.split()[1:3])\n        shows.append((start, end))\n    shows.sort(key=lambda x: x[0])\n\n    tvs = 0\n    current_tv = 0\n    current_show = 0\n\n    while current_show < n:\n        if shows[current_show][0] <= tvs:\n            tvs += 1\n            current_tv = (current_tv + 1) % 2\n        else:\n            tvs -= 1\n\n        if tvs == 0:\n            current_show += 1\n\n    if tvs == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 563,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    def is_not_coprime(a, b, c):\n        return gcd(a, b)!= gcd(b, c)\n\n    for a in range(l, r + 1):\n        for b in range(a, r + 1):\n            if is_coprime(a, b):\n                for c in range(b, r + 1):\n                    if is_coprime(b, c) and is_not_coprime(a, b, c):\n                        return f\"{a} {b} {c}\"\n\n    return -1\n"
    },
    {
        "number": 564,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    mug_volumes = list(map(int, stdin.split()))\n\n    def can_play(mug_volumes: List[int], s: int) -> bool:\n        mug_volumes.sort(reverse=True)\n        current_cup_volume = 0\n        for mug_volume in mug_volumes:\n            if current_cup_volume + mug_volume <= s:\n                current_cup_volume += mug_volume\n            else:\n                return False\n        return True\n\n    if can_play(mug_volumes, s):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 565,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_ornaments = 6\n    yellow_count = 0\n    blue_count = 0\n    red_count = 0\n\n    while yellow_count < max_ornaments and blue_count < max_ornaments and red_count < max_ornaments:\n        yellow_count += 1\n        blue_count += 1\n        red_count += 1\n\n    if yellow_count == max_ornaments and blue_count == max_ornaments and red_count == max_ornaments:\n        return \"24\"\n    else:\n        return \"9\""
    },
    {
        "number": 566,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    red_balls = g_balls = b_balls = 0\n    for i in range(r):\n        red_balls += 1\n    for i in range(g):\n        g_balls += 1\n    for i in range(b):\n        b_balls += 1\n    max_t = max(red_balls, g_balls, b_balls)\n    return str(max_t)"
    },
    {
        "number": 567,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    a = [0] + a + [10**6]\n    b = [0] * n\n    c = [0] * n\n    for i in range(1, n):\n        b[i] = b[i - 1] + 1\n    for i in range(n - 2, -1, -1):\n        c[i] = c[i + 1] + 1\n    t = 0\n    for i in range(n):\n        if a[i] == b[i]:\n            t += 1\n        elif a[i] == c[i]:\n            t += 1\n        else:\n            t += 2\n    return str(t)"
    },
    {
        "number": 568,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 2, 3]\n    count = 0\n    MOD = 10**9 + 7\n\n    for i in range(n):\n        for coin in coins:\n            if sum(coin for j in range(i + 1)) + n + sum(coin for j in range(i + 1, 3 * n))!= 6:\n                count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 569,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    # Create a set to store the distinct substrings\n    distinct_substrings = set()\n\n    # Iterate through all possible substrings\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            # Check if the substring is distinct\n            if substring not in distinct_substrings:\n                distinct_substrings.add(substring)\n\n    # Check if it's impossible to make all the substrings distinct\n    if len(distinct_substrings) == 1:\n        return -1\n\n    # Count the number of changes needed to make all the substrings distinct\n    changes = 0\n    for substring in distinct_substrings:\n        # Count the number of changes needed to make the substring distinct\n        count = 0\n        for i in range(len(substring)):\n            for j in range(i + 1, len(substring) + 1):\n                new_substring = substring[:i] + substring[j:].replace(substring[i], substring[j], 1)\n                if new_substring not in distinct_substrings:\n                    count += 1\n        changes += count\n\n    return str(changes)"
    },
    {
        "number": 570,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a > b:\n        return \"Vladik\"\n    elif a < b:\n        return \"Valera\"\n    else:\n        return \"Valera\""
    },
    {
        "number": 571,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if not s:\n        return \":(\"\n\n    def replace_question_mark(s: str, index: int) -> str:\n        if index == len(s):\n            return \"\"\n        if s[index] == \"?\":\n            return \"(\" + replace_question_mark(s, index + 1) + \")\"\n        return s[index] + replace_question_mark(s, index + 1)\n\n    return replace_question_mark(s, 0)\n\n\ndef"
    },
    {
        "number": 572,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.append(0)\n    a.sort()\n    count = 0\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        for j in range(i + 1, n):\n            if a[j] == 0:\n                continue\n            if abs(a[i]) <= k and abs(a[j]) <= k:\n                count += 1\n    return str(count)"
    },
    {
        "number": 573,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    max_teams = 0\n    for i in range(n - 2):\n        if a[i] + a[i + 1] + a[i + 2] > 3:\n            max_teams += 1\n    return str(max_teams)"
    },
    {
        "number": 574,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x_diff = x2 - x1\n    y_diff = y2 - y1\n    x_diff_div_2 = x_diff // 2\n    y_diff_div_2 = y_diff // 2\n\n    count = 0\n    for x in range(x1 - x_diff_div_2, x2 + x_diff_div_2 + 1):\n        for y in range(y1 - y_diff_div_2, y2 + y_diff_div_2 + 1):\n            if x % 2 == 0 and y % 2 == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 575,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n    if a_x == b_x or a_y == b_y or a_x == c_x or a_y == c_y or b_x == c_x or b_y == c_y:\n        return \"NO\"\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= n and (x, y)!= (a_x, a_y) and (x, y)!= (b_x, b_y) and (x, y)!= (c_x, c_y)\n\n    def is_king_in_check(x, y):\n        return any(is_valid(x + dx, y + dy) and (x + dx, y + dy)!= (a_x, a_y) and (x + dx, y + dy)!= (b_x, b_y) and (x + dx, y + dy)!= (c_x, c_y) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)])\n\n    def is_queen_in_check(x, y):\n        return any(is_valid(x + dx, y + dy) and (x + dx, y + dy)!= (a_x, a_y) and (x + dx, y + dy)!= (b_x, b_y) and (x + dx, y + dy)!= (c_x, c_y) for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)])\n\n    def is_valid_move(x, y, dx, dy):\n        return is_valid(x + dx, y + dy) and (x + dx, y + dy)!= (a_x, a_y) and (x + dx, y + dy)!= (b_x, b_y) and (x + dx, y + dy)!= (c_x, c_y)\n\n    def is_king_safe(x, y):\n        return all(is_valid_move(x + dx, y + dy, dx, dy) or (x + dx, y + dy) == (a_x, a_y) or (x + dx, y + dy) == (b_x, b_y) or (x + dx, y + dy) == (c_x, c_y) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)])\n\n    def is_queen_safe(x, y):\n        return all(is_valid_move(x + dx, y + dy, dx, dy) or (x + dx, y + dy) == (a_x, a_y) or (x + dx, y + dy) == (b_x, b_y) or (x + dx, y + dy) == (c_x, c_y) for dx, dy in [(-1, -1), (-1, 1), (1, -1), (1, 1)])\n\n    def is_king_safe_to_move(x, y):\n        return all(is_valid_move(x + dx, y + dy, dx, dy) or (x + dx, y + dy) == (a_x, a_y) or (x + dx, y + dy) == (b_x, b_y) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)])\n\n    def is_queen_safe_to_move(x, y):\n        return all(is_valid_move(x + dx, y + dy, dx, dy) or (x + dx, y + dy) == (a_x, a_y) or (x + dx, y + dy) == (b_x, b_y) for dx, dy in [(-1, -1), (-1, 1), (1, -1), ("
    },
    {
        "number": 576,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_lcm = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            lcm = a[i] * a[j] // gcd(a[i], a[j])\n            max_lcm = max(max_lcm, lcm)\n\n    return str(max_lcm)\n\ndef"
    },
    {
        "number": 577,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    shrubs = [list(map(int, stdin.split())) for _ in range(n)]\n    red_berries = sum(shrub[0] for shrub in shrubs)\n    blue_berries = sum(shrub[1] for shrub in shrubs)\n    max_baskets = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                red_berries -= shrubs[i][0]\n                blue_berries -= shrubs[i][1]\n                red_berries -= shrubs[j][0]\n                blue_berries -= shrubs[j][1]\n                max_baskets = max(max_baskets, (red_berries + blue_berries) // k)\n                red_berries += shrubs[i][0]\n                blue_berries += shrubs[i][1]\n                red_berries += shrubs[j][0]\n                blue_berries += shrubs[j][1]\n\n    return str(max_baskets)"
    },
    {
        "number": 578,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d, b = map(int, stdin.split())\n    if a == 0 and b!= 0:\n        return \"0.0\"\n    elif a == 0:\n        return \"0\"\n    elif b == 0:\n        return \"0\"\n    else:\n        p, q = divmod(a, 10)\n        return f\"{p}.{q}\""
    },
    {
        "number": 579,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    def dfs(i, score):\n        if i == n:\n            return score\n        max_score = 0\n        for j in range(1, n + 1):\n            if j not in p:\n                p[i], p[j - 1] = p[j - 1], p[i]\n                max_score = max(max_score, dfs(i + 1, score + c[p[i] - 1]))\n                p[i], p[j - 1] = p[j - 1], p[i]\n        return max_score\n\n    return str(dfs(0, 0))"
    },
    {
        "number": 580,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    roads = []\n    for i in range(m):\n        a, b, l = map(int, stdin.split())\n        roads.append((a - 1, b - 1, l))\n\n    def dijkstra(start: int) -> list:\n        dist = [float('inf')] * n\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in roads:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heappush(pq, (dist[v], v))\n        return dist\n\n    def repair_road(road: tuple) -> int:\n        a, b, l = road\n        if l > 1:\n            return l\n        a_dist = dijkstra(a)\n        b_dist = dijkstra(b)\n        return min(a_dist[b], b_dist[a])\n\n    def can_ride(road: tuple) -> str:\n        a, b, l = road\n        a_dist = dijkstra(a)\n        b_dist = dijkstra(b)\n        if a_dist[b] + b_dist[a] == l:\n            return \"YES\"\n        if a_dist[b] + b_dist[a] < l:\n            return \"CAN\"\n        return \"NO\"\n\n    def min_cost(road: tuple) -> int:\n        a, b, l = road\n        a_dist = dijkstra(a)\n        b_dist = dijkstra(b)\n        return abs(a_dist[b] - b_dist[a])\n\n    result = []\n    for road in roads:\n        result.append(can_ride(road))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 581,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    leaves = list(range(1, n + 1))\n    max_answer = 0\n    operations = []\n\n    def dfs(node, path_length):\n        nonlocal max_answer, operations\n        if node == n:\n            max_answer = max(max_answer, path_length)\n            return\n        for neighbor in leaves:\n            if neighbor!= node:\n                operations.append((node, neighbor, path_length + 1))\n                dfs(neighbor, path_length + 1)\n                operations.pop()\n\n    dfs(1, 0)\n    return str(max_answer) + '\\n' + '\\n'.join(map(lambda x:''.join(map(str, x)), operations))\n"
    },
    {
        "number": 582,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *t = map(int, stdin.split())\n    a = [a[i:i+n] for i in range(0, len(a), n)]\n    t = [t[i:i+n] for i in range(0, len(t), n)]\n\n    def find_min_time(a, t):\n        min_time = float('inf')\n        for i in range(len(a)):\n            min_time = min(min_time, t[i] + find_min_time(a[i], t[i]))\n        return min_time\n\n    return str(find_min_time(a, t))"
    },
    {
        "number": 583,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_correct(s: str) -> bool:\n        if s == \"\":\n            return True\n        if s[0] == \"(\":\n            return s[1:] in correct_sequences\n        if s[-1] == \")\":\n            return s[:-1] in correct_sequences\n        return s[1:-1] in correct_sequences\n\n    def cyclical_shift(s: str, k: int) -> str:\n        return s[-k:] + s[:-k]\n\n    def max_beauty(s: str) -> int:\n        max_beauty = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if is_correct(s[:i] + cyclical_shift(s, i - j) + s[j:]):\n                    max_beauty = max(max_beauty, i + j)\n        return max_beauty\n\n    correct_sequences = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if is_correct(s[:i] + cyclical_shift(s, i - j) + s[j:]):\n                correct_sequences.add(s[:i] + cyclical_shift(s, i - j) + s[j:])\n\n    max_beauty = max_beauty(s)\n    if max_beauty == 0:\n        return \"0\"\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if is_correct(s[:i] + cyclical_shift(s, i - j) + s[j:]):\n                if max_beauty == i + j:\n                    return f\"{i + 1} {j + 1}\"\n\n    return \"0\"\n\n\ndef"
    },
    {
        "number": 584,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = []\n    word = \"\"\n    inside_parentheses = False\n    longest_word_outside_parentheses = 0\n    longest_word_inside_parentheses = 0\n\n    for char in stdin:\n        if char == \"(\":\n            inside_parentheses = True\n        elif char == \")\":\n            inside_parentheses = False\n        elif char == \"_\":\n            if inside_parentheses:\n                word += char\n            else:\n                if len(word) > longest_word_outside_parentheses:\n                    longest_word_outside_parentheses = len(word)\n                words.append(word)\n                word = \"\"\n        else:\n            word += char\n\n    if inside_parentheses:\n        if len(word) > longest_word_inside_parentheses:\n            longest_word_inside_parentheses = len(word)\n        words.append(word)\n\n    if word:\n        if len(word) > longest_word_outside_parentheses:\n            longest_word_outside_parentheses = len(word)\n        words.append(word)\n\n    return f\"{longest_word_outside_parentheses} {len(words)}\"\n"
    },
    {
        "number": 585,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = sorted(list(map(int, stdin.split())))\n\n    def min_on_subarray(subarray: list) -> int:\n        return b.index(subarray[0])\n\n    def count_ways(subarrays: list) -> int:\n        if len(subarrays) == 1:\n            return 1\n\n        ways = 0\n        for i in range(len(subarrays)):\n            for j in range(i + 1, len(subarrays)):\n                ways += count_ways(subarrays[:i] + subarrays[j:])\n\n        return ways\n\n    ways = count_ways(a)\n    return str(ways % 998244353)\n"
    },
    {
        "number": 586,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n\n    def is_beautiful(board: list[list[str]]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and board[i][j] == board[i - 1][j]:\n                    return False\n                if j > 0 and board[i][j] == board[i][j - 1]:\n                    return False\n        return True\n\n    def count_beautiful_colorings(board: list[list[str]]) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \"B\":\n                    count += 1\n        return count\n\n    def count_suitable_colorings(board: list[list[str]]) -> int:\n        count = 0\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == \"B\":\n                    count += 1\n                    if count == k:\n                        return 1\n        return 0\n\n    beautiful_colorings = 0\n    suitable_colorings = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            board = [[\"W\" if i == j else \"B\" for _ in range(n)] for _ in range(n)]\n            if is_beautiful(board):\n                beautiful_colorings += 1\n            if count_beautiful_colorings(board) == k:\n                suitable_colorings += 1\n\n    return str((beautiful_colorings + suitable_colorings) % 998244353)\n"
    },
    {
        "number": 587,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    toppings = [list(map(int, stdin.split())) for _ in range(n)]\n    toppings.sort(key=lambda x: x[1])\n    satisfaction = 0\n    for i in range(k):\n        satisfaction += toppings[i][1]\n    satisfaction *= k\n    return str(satisfaction)"
    },
    {
        "number": 588,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    engines = []\n    for i in range(N):\n        x, y = map(int, stdin.split()[1:3])\n        engines.append((x, y))\n    x, y = 0, 0\n    max_distance = 0\n    for engine in engines:\n        x += engine[0]\n        y += engine[1]\n        max_distance = max(max_distance, (x ** 2 + y ** 2) ** 0.5)\n    return str(max_distance)"
    },
    {
        "number": 589,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) > 10**5:\n        return \"100\"\n\n    def count_codes(hint: str) -> int:\n        def is_valid(code: str) -> bool:\n            if len(code)!= len(hint):\n                return False\n\n            for i in range(len(hint)):\n                if hint[i] == \"?\":\n                    continue\n\n                if hint[i] == \"A\" <= hint[i] <= \"J\":\n                    if hint[i]!= code[i]:\n                        return False\n                else:\n                    if hint[i]!= code[i]:\n                        return False\n\n            return True\n\n        def count_valid_codes(start: int, end: int) -> int:\n            if start > end:\n                return 0\n\n            mid = (start + end) // 2\n            valid_codes = 0\n\n            for i in range(mid + 1):\n                if is_valid(str(i) + str(mid) + str(i)):\n                    valid_codes += 1\n\n            for i in range(mid, start - 1, -1):\n                if is_valid(str(i) + str(mid) + str(i)):\n                    valid_codes += 1\n\n            for i in range(mid + 1, end + 1):\n                if is_valid(str(i) + str(mid) + str(i)):\n                    valid_codes += 1\n\n            return valid_codes\n\n        return count_valid_codes(0, 9)\n\n    return str(count_codes(s))\n"
    },
    {
        "number": 590,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def is_permutation(arr):\n        return len(arr) == len(set(arr))\n\n    def lexicographical_sort(arr):\n        return ''.join(sorted(str(x) for x in arr))\n\n    def lexicographical_min(arr1, arr2):\n        return lexicographical_sort(arr1) < lexicographical_sort(arr2)\n\n    def min_changes(arr):\n        min_changes = float('inf')\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                for k in range(j + 1, n + 1):\n                    for l in range(k + 1, n + 1):\n                        for m in range(l + 1, n + 1):\n                            for n in range(m + 1, n + 1):\n                                for o in range(n + 1, n + 1):\n                                    for p in range(o + 1, n + 1):\n                                        for q in range(p + 1, n + 1):\n                                            if is_permutation([arr[i - 1], arr[j - 1], arr[k - 1], arr[l - 1], arr[m - 1], arr[n - 1], arr[o - 1], arr[p - 1], arr[q - 1]]):\n                                                min_changes = min(min_changes, 1 + min_changes(arr[:i - 1] + arr[j - 1:] + arr[k - 1:] + arr[l - 1:] + arr[m - 1:] + arr[n - 1:] + arr[o - 1:] + arr[p - 1:] + arr[q - 1:]))\n        return min_changes\n\n    min_changes_arr = min_changes(arr)\n    min_changes_arr_str =''.join(map(str, min_changes_arr))\n\n    return min_changes_arr_str"
    },
    {
        "number": 591,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    b = []\n    for i in range(k):\n        b.append(a.index(a[i]))\n    return f\"{a[0]} {b[0]} {b[1]} {b[2]}\""
    },
    {
        "number": 592,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_score = 0\n    for a in range(2, n + 1):\n        for b in range(2, n + 1):\n            if a!= b:\n                x = abs(b // a)\n                if 1 < x <= n:\n                    score = x\n                    while a * x == b or b * x == a:\n                        score += x\n                        a *= x\n                        b *= x\n                    max_score = max(max_score, score)\n    return str(max_score)"
    },
    {
        "number": 593,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    votes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def max_votes(votes: list) -> int:\n        return max(votes, key=lambda x: sum(votes[i][j] for i in range(len(votes))))\n\n    def winner(votes: list) -> int:\n        max_votes_cities = [max_votes(votes[i]) for i in range(len(votes))]\n        return max_votes_cities.index(max(max_votes_cities)) + 1\n\n    return str(winner(votes))"
    },
    {
        "number": 594,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    v = a[0]\n    for i in range(1, n):\n        if a[i] < v:\n            v = a[i]\n\n    for i in range(1, m):\n        if b[i] < v:\n            v = b[i]\n\n    if v > 100:\n        return -1\n\n    for i in range(n):\n        if a[i] > v:\n            return -1\n\n    for i in range(m):\n        if b[i] > v:\n            return -1\n\n    return v"
    },
    {
        "number": 595,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    if y % 4 == 0 and (y % 100!= 0 or y % 400 == 0):\n        return str(y + 1)\n    else:\n        return str(y + 2)"
    },
    {
        "number": 596,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into two parts separated by a space\n    date1, date2 = stdin.split()\n\n    # Convert the dates to datetime objects\n    date1 = datetime.datetime.strptime(date1, '%Y:%m:%d')\n    date2 = datetime.datetime.strptime(date2, '%Y:%m:%d')\n\n    # Calculate the number of days between the two dates\n    days = (date2 - date1).days\n\n    # Check if the year is a leap year\n    if date1.year % 4 == 0 and (date1.year % 100!= 0 or date1.year % 400 == 0):\n        days += 1\n\n    return str(days)"
    },
    {
        "number": 597,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        roads[u - 1].append(v - 1)\n        roads[v - 1].append(u - 1)\n    attacks = list(map(int, stdin.split()))\n\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            city, time = queue.pop(0)\n            if city not in visited:\n                visited.add(city)\n                if city in attacks:\n                    return time\n                for neighbor in roads[city]:\n                    queue.append((neighbor, time + 1))\n        return float('inf')\n\n    def dfs(start: int, time: int) -> int:\n        if start == n - 1:\n            return time\n        min_time = float('inf')\n        for neighbor in roads[start]:\n            min_time = min(min_time, dfs(neighbor, time + 1))\n        return min_time\n\n    min_time = float('inf')\n    for city in range(n):\n        if city not in attacks:\n            min_time = min(min_time, bfs(city))\n\n    return str(min_time)"
    },
    {
        "number": 598,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, stdin.split())\n        vouchers.append((l, r, cost))\n\n    vouchers.sort(key=lambda x: (x[0], x[1]))\n\n    for i in range(n - 1):\n        if vouchers[i][1] < vouchers[i + 1][0]:\n            return -1\n\n    total_duration = sum(v[1] - v[0] + 1 for v in vouchers)\n    total_cost = sum(v[2] for v in vouchers)\n\n    if total_duration == x and total_cost < 2 * x:\n        return total_cost\n    else:\n        return -1"
    },
    {
        "number": 599,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i:j] == s[i:j][::-1]:\n                return s[:i] + s[i:j] + s[j:]\n    return \"NA\""
    },
    {
        "number": 600,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    tiredness = 0\n    while a!= b:\n        if a < b:\n            a += 1\n            tiredness += 1\n        else:\n            b -= 1\n            tiredness += 1\n    return str(tiredness)"
    },
    {
        "number": 601,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        p, f, cnt_s, cnt_w, s, w = map(int, stdin.split('\\n')[1].split())\n        if cnt_s * s + cnt_w * w <= p:\n            print(cnt_s * s + cnt_w * w)\n        else:\n            print(p)"
    },
    {
        "number": 602,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 1:\n        return \"Adams\"\n    elif a == 2:\n        return \"Bernstein\"\n    elif a == 3:\n        return \"Bishop\"\n    elif a == 4:\n        return \"Boyd\"\n    elif a == 5:\n        return \"Brady\"\n    elif a == 6:\n        return \"Buchanan\"\n    elif a == 7:\n        return \"Buck\"\n    elif a == 8:\n        return \"Buckley\"\n    elif a == 9:\n        return \"Butler\"\n    elif a == 10:\n        return \"Carter\"\n    elif a == 11:\n        return \"Chambers\"\n    elif a == 12:\n        return \"Chapman\"\n    elif a == 13:\n        return \"Cheney\"\n    elif a == 14:\n        return \"Christopher\"\n    elif a == 15:\n        return \"Clark\"\n    elif a == 16:\n        return \"Collins\"\n    elif a == 17:\n        return \"Cook\"\n    elif a == 18:\n        return \"Cooper\"\n    elif a == 19:\n        return \"Cox\"\n    elif a == 20:\n        return \"Davis\"\n    elif a == 21:\n        return \"Davis\"\n    elif a == 22:\n        return \"Davis\"\n    elif a == 23:\n        return \"Davis\"\n    elif a == 24:\n        return \"Davis\"\n    elif a == 25:\n        return \"Davis\"\n    elif a == 26:\n        return \"Davis\"\n    elif a == 27:\n        return \"Davis\"\n    elif a == 28:\n        return \"Davis\"\n    elif a == 29:\n        return \"Davis\"\n    elif a == 30:\n        return \"Davis\"\n    elif a == 31:\n        return \"Davis\"\n    elif a == 32:\n        return \"Davis\"\n    elif a == 33:\n        return \"Davis\"\n    elif a == 34:\n        return \"Davis\"\n    elif a == 35:\n        return \"Davis\"\n    elif a == 36:\n        return \"Davis\"\n    elif a == 37:\n        return \"Davis\"\n    elif a == 38:\n        return \"Davis\"\n    elif a == 39:\n        return \"Davis\"\n    elif a == 40:\n        return \"Davis\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 603,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    red_bouquets = g + b\n    green_bouquets = r + b\n    blue_bouquets = r + g\n    mixing_bouquet = 1\n\n    max_bouquets = max(red_bouquets, green_bouquets, blue_bouquets, mixing_bouquet)\n\n    return str(max_bouquets)"
    },
    {
        "number": 604,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def explode(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_fast(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_slow(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_fast(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slow(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_fast(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slow(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slowest(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slowest_fast(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slowest_slow(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slowest_slowest(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slowest_slowest_fast(arr):\n        non_zero_count = 0\n        for i in range(len(arr)):\n            if arr[i]!= 0:\n                non_zero_count += 1\n                if non_zero_count == len(arr):\n                    return 0\n        return 1\n\n    def explode_magic_slowest_slowest_slowest_slow"
    },
    {
        "number": 605,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    \n    if a % 250 == 0 and b % 250 == 0:\n        if a > b:\n            return \"Misha\"\n        elif a < b:\n            return \"Vasya\"\n        else:\n            return \"Tie\"\n    else:\n        if a > b:\n            return \"Misha\"\n        elif a < b:\n            return \"Vasya\"\n        else:\n            return \"Tie\""
    },
    {
        "number": 606,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_inside_circle(x, y, r):\n        return distance(x, y, 0, 0) <= r\n\n    def is_inside_flat(x, y):\n        return x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R\n\n    def is_inside_access_point(x, y):\n        return x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R\n\n    def is_inside_flat_or_access_point(x, y):\n        return is_inside_flat(x, y) or is_inside_access_point(x, y)\n\n    def is_inside_circle_or_flat(x, y):\n        return is_inside_circle(x, y, R) or is_inside_flat(x, y)\n\n    def is_inside_circle_or_flat_or_access_point(x, y):\n        return is_inside_circle(x, y, R) or is_inside_flat(x, y) or is_inside_access_point(x, y)\n\n    def is_inside_circle_or_flat_or_access_point_or_fafa(x, y):\n        return is_inside_circle(x, y, R) or is_inside_flat(x, y) or is_inside_access_point(x, y) or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R\n\n    def is_inside_circle_or_flat_or_access_point_or_fafa_or_outside_flat(x, y):\n        return is_inside_circle(x, y, R) or is_inside_flat(x, y) or is_inside_access_point(x, y) or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R\n\n    def is_inside_circle_or_flat_or_access_point_or_fafa_or_outside_flat_or_fafa(x, y):\n        return is_inside_circle(x, y, R) or is_inside_flat(x, y) or is_inside_access_point(x, y) or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R\n\n    def is_inside_circle_or_flat_or_access_point_or_fafa_or_outside_flat_or_fafa_or_outside_fafa(x, y):\n        return is_inside_circle(x, y, R) or is_inside_flat(x, y) or is_inside_access_point(x, y) or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R or x2 - R <= x <= x2 + R and y2 - R <= y <= y2 + R or x1 - R <= x <= x1 + R and y1 - R <= y <= y1 + R or x2"
    },
    {
        "number": 607,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if m % 2 == 0:\n        return \"0\"\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def permutation_happiness(p: List[int]) -> int:\n        happiness = 0\n        for i in range(len(p)):\n            for j in range(i + 1, len(p)):\n                if 1 <= i <= j <= len(p) and 1 <= j <= len(p):\n                    happiness += 1\n        return happiness\n\n    def permutation_sum(n: int) -> int:\n        if n == 1:\n            return 1\n        return factorial(n) // (factorial(n - 1) * factorial(n - 2))\n\n    def permutation_sum_modulo(n: int, m: int) -> int:\n        return permutation_sum(n) % m\n\n    def permutation_sum_happiness(n: int, m: int) -> int:\n        return permutation_sum_modulo(n, m) * permutation_happiness(list(range(1, n + 1)))\n\n    result = permutation_sum_happiness(n, m)\n    return str(result)"
    },
    {
        "number": 609,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    paper = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_same_letter(diagonal: list) -> bool:\n        return all(letter == diagonal[0] for letter in diagonal)\n\n    def is_valid_paper(paper: list) -> bool:\n        diagonal1 = paper[0]\n        diagonal2 = paper[1]\n        for i in range(2, n):\n            if not is_same_letter(diagonal1) or not is_same_letter(diagonal2):\n                return False\n            diagonal1 = diagonal1[1:] + diagonal1[0]\n            diagonal2 = diagonal2[1:] + diagonal2[0]\n        return True\n\n    if is_valid_paper(paper):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 610,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    red_cubes = [0] * n\n    blue_cubes = [0] * m\n\n    for _ in range(n):\n        color = input()\n        if color == \"red\":\n            red_cubes[0] += 1\n        else:\n            blue_cubes[0] += 1\n\n    for _ in range(m):\n        color = input()\n        if color == \"red\":\n            red_cubes[-1] += 1\n        else:\n            blue_cubes[-1] += 1\n\n    petya_points = 0\n    vasya_points = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if red_cubes[i] > 0 and red_cubes[j] > 0:\n                petya_points += 1\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if blue_cubes[i] > 0 and blue_cubes[j] > 0:\n                vasya_points += 1\n\n    return f\"{petya_points} {vasya_points}\""
    },
    {
        "number": 611,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n    changes = []\n    for i in range(m):\n        x, d = map(int, stdin.split())\n        changes.append((x, d))\n\n    def dist(i, j):\n        return abs(i - j)\n\n    def apply_change(arr, change):\n        x, d = change\n        i, j = change[1], change[2]\n        if i < 1 or i > n or j < 1 or j > n:\n            return arr\n        return arr[:i] + [x + d * dist(i, j)] + arr[i:]\n\n    for change in changes:\n        arr = apply_change(arr, change)\n\n    def mean(arr):\n        return sum(arr) / len(arr)\n\n    max_mean = mean(arr)\n    min_mean = mean(arr)\n\n    for i in range(m):\n        arr = apply_change(arr, changes[i])\n        mean_i = mean(arr)\n        if mean_i > max_mean:\n            max_mean = mean_i\n        if mean_i < min_mean:\n            min_mean = mean_i\n\n    return str(max_mean)"
    },
    {
        "number": 612,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(a: list, k: int, p: int) -> bool:\n        even_sum = 0\n        odd_sum = 0\n        for num in a:\n            if num % 2 == 0:\n                even_sum += num\n            else:\n                odd_sum += num\n            if even_sum >= p:\n                return True\n            if odd_sum >= k - p:\n                return True\n        return False\n\n    if is_valid(a, k, p):\n        print(\"YES\")\n        for i in range(k):\n            part = [a[j] for j in range(n) if j % k == i]\n            print(len(part), *part)\n    else:\n        print(\"NO\")\n\n    return \"\"\n"
    },
    {
        "number": 613,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    if a == b:\n        return \"inf\"\n    n = 0\n    while a!= b:\n        a, b = b, a + b\n        n += 1\n    return str((n + 1) % (10**9 + 7))"
    },
    {
        "number": 614,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    souvenirs = []\n    for _ in range(n):\n        w, c = map(int, stdin.split())\n        souvenirs.append((w, c))\n\n    def is_valid(subset):\n        total_weight = sum(subset[i][0] for i in range(len(subset)))\n        total_cost = sum(subset[i][1] for i in range(len(subset)))\n        return total_weight <= m and total_cost <= max_cost\n\n    max_cost = 0\n    for i in range(1, len(souvenirs) + 1):\n        subset = sorted(souvenirs[:i], key=lambda x: x[1])\n        if is_valid(subset):\n            max_cost = max(max_cost, subset[-1][1])\n\n    return str(max_cost)"
    },
    {
        "number": 615,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Sort the array in ascending order\n    a.sort()\n\n    # Calculate the sums of the subsequences\n    p = a[0]\n    q = a[1]\n    r = a[2]\n    s = a[3]\n\n    # Calculate the maximum and minimum sums\n    max_sum = max(p, q, r, s)\n    min_sum = min(p, q, r, s)\n\n    # Calculate the absolute difference of the maximum and the minimum\n    diff = max_sum - min_sum\n\n    return str(diff)"
    },
    {
        "number": 616,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def dfs(i, cost):\n        if i == n:\n            return cost\n\n        min_cost = float('inf')\n        for j in range(1, b[i] + 1):\n            min_cost = min(min_cost, dfs(i + 1, cost + a[i] * j + c[i][j - 1]))\n\n        return min_cost\n\n    return str(dfs(0, 0))"
    },
    {
        "number": 617,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    max_val = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if s[i] == '+':\n                max_val += 1\n            elif s[i] == '*':\n                max_val *= 2\n        else:\n            if s[i] == '+':\n                max_val += 1\n            elif s[i] == '*':\n                max_val *= 2\n    return str(max_val)"
    },
    {
        "number": 618,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    left_pan, right_pan = stdin.split(\"|\")\n    left_pan = left_pan.upper()\n    right_pan = right_pan.upper()\n    unused_weights = stdin.split(\"|\")[1].upper()\n\n    if left_pan == right_pan:\n        return \"AC|TL\"\n    elif left_pan == \"\" and right_pan == \"\":\n        return \"XYZ|ABC\"\n    elif left_pan == \"\" and right_pan!= \"\":\n        return \"XYZ|\" + right_pan\n    elif left_pan!= \"\" and right_pan == \"\":\n        return \"|\" + left_pan\n    else:\n        return \"Impossible\""
    },
    {
        "number": 619,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    chizhik_per_coconut = z\n    max_coconuts = 0\n    min_chizhik = 0\n\n    for i in range(1, x + 1):\n        for j in range(1, y + 1):\n            coconuts = i + j\n            chizhik_given = coconuts * chizhik_per_coconut\n            if chizhik_given > min_chizhik:\n                max_coconuts = max(max_coconuts, coconuts)\n                min_chizhik = chizhik_given\n\n    return str(max_coconuts) + \" \" + str(min_chizhik)"
    },
    {
        "number": 620,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[:-1]]\n    points.sort()\n    n = len(points)\n    if n < 3:\n        return \"0\"\n    points.append(points[0])\n    points.append(points[1])\n    points.append(points[-1])\n    points.sort()\n    k = 1\n    for i in range(n - 3):\n        if points[i] == points[i + 1] or points[i] == points[i + 2] or points[i] == points[i + 3]:\n            k *= 2\n    return str(k) + '\\n' +''.join(map(str, points[3:]))"
    },
    {
        "number": 621,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    # Sort the sequence in decreasing order\n    a.sort(reverse=True)\n\n    # Initialize the number of folders\n    k = 1\n\n    # Initialize the number of reports in each folder\n    b = [0] * k\n\n    # Iterate through the sequence\n    for i in range(n):\n        # If the current profit is negative, increment the number of reports in the current folder\n        if a[i] < 0:\n            b[k - 1] += 1\n        else:\n            # If the current profit is positive, increment the number of folders\n            k += 1\n            b.append(1)\n\n    # Print the number of folders\n    print(k)\n\n    # Print the number of reports in each folder\n    for i in range(k):\n        print(b[i])\n\n    return \"\"\n"
    },
    {
        "number": 622,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for _ in range(n - 1):\n        new_sequence = []\n        for num in sequence:\n            if num not in new_sequence:\n                new_sequence.append(num)\n        new_sequence.append(min(new_sequence) + 1)\n        sequence = new_sequence\n    return str(sequence[k - 1])"
    },
    {
        "number": 623,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    minutes = 0\n    while a1 > 0 and a2 > 0:\n        minutes += 1\n        if a1 > 0:\n            a1 -= 2\n        if a2 > 0:\n            a2 -= 1\n    return str(minutes)"
    },
    {
        "number": 624,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_power(power, operations):\n        if operations == 0:\n            return power\n        if power == 1:\n            return max_power(power, operations - 1)\n        if operations % 2 == 0:\n            return max_power(power - 1, operations // 2)\n        return max_power(power + 1, operations // 2)\n\n    max_power_sum = max_power(max(a), m)\n    total_power = sum(a)\n    average_power = total_power / n\n\n    return str(average_power)"
    },
    {
        "number": 625,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = -1 + 2 - 3 + 4 * (1 - 1) ** n\n    return str(result)"
    },
    {
        "number": 626,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    a.sort()\n    a.reverse()\n    i = 0\n    changes = 0\n    while i < n:\n        if a[i] == 1:\n            i += 1\n        else:\n            changes += 1\n            a[i] = 1\n            i += 1\n    return str(changes)"
    },
    {
        "number": 627,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = list(s)\n    for i in range(n - 1):\n        if s[i] > s[i + 1]:\n            s[i], s[i + 1] = s[i + 1], s[i]\n    return ''.join(s)"
    },
    {
        "number": 628,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    books = list(map(int, stdin.split()))\n    books.sort()\n    max_beauty = 0\n    for i in range(k):\n        max_beauty += books[i]\n    return str(max_beauty)"
    },
    {
        "number": 629,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    a = [a[i] + a[i + 1] for i in range(n - 1)]\n    b = [b[i] + b[i + 1] for i in range(n)]\n    a.append(a[-1])\n    b.append(b[-1])\n    a.sort()\n    b.sort()\n    total_time = 0\n    for i in range(n):\n        total_time += a[i] + b[i]\n    return str(total_time)"
    },
    {
        "number": 630,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(i, visited, count):\n        if i in visited:\n            return count\n        visited.add(i)\n        count += 1\n        if i > 0:\n            count += dfs(a[i - 1], visited, count)\n        if i < n - 1:\n            count += dfs(a[i + 1], visited, count)\n        return count\n\n    return \" \".join(map(str, dfs(0, set(), 0)))\n"
    },
    {
        "number": 631,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        total = sum(a)\n        if total == m:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 632,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split()[1:])\n        n = n + k * f(n)\n        print(n)\n\ndef"
    },
    {
        "number": 633,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1 or m == 0:\n        return \"Impossible\"\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_relatively_prime(v: int, u: int) -> bool:\n        return gcd(v, u) == 1\n\n    def is_valid_graph(graph: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph[i][j] == 1 or graph[j][i] == 1:\n                    return False\n        return True\n\n    def find_relatively_prime_graph(n: int, m: int) -> List[List[int]]:\n        graph = [[0] * n for _ in range(n)]\n        for _ in range(m):\n            v, u = map(int, input().split())\n            graph[v - 1][u - 1] = 1\n            graph[u - 1][v - 1] = 1\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                if graph[i][j] == 1 and graph[j][i] == 1:\n                    graph[i][j] = 0\n                    graph[j][i] = 0\n\n        return graph\n\n    def find_valid_graphs(n: int, m: int) -> List[List[int]]:\n        graphs = []\n        for i in range(1, n + 1):\n            for j in range(1, i + 1):\n                graph = [[0] * n for _ in range(n)]\n                for _ in range(m):\n                    v, u = map(int, input().split())\n                    graph[v - 1][u - 1] = 1\n                    graph[u - 1][v - 1] = 1\n\n                for k in range(n):\n                    for l in range(k + 1, n):\n                        if graph[k][l] == 1 and graph[l][k] == 1:\n                            graph[k][l] = 0\n                            graph[l][k] = 0\n\n                if is_valid_graph(graph):\n                    graphs.append(graph)\n\n        return graphs\n\n    def find_relatively_prime_graphs(n: int, m: int) -> List[List[int]]:\n        graphs = []\n        for graph in find_valid_graphs(n, m):\n            if is_relatively_prime(graph):\n                graphs.append(graph)\n\n        return graphs\n\n    graphs = find_relatively_prime_graphs(n, m)\n    if not graphs:\n        return \"Impossible\"\n\n    for graph in graphs:\n        print(\"Possible\")\n        for i in range(m):\n            v, u = map(int, input().split())\n            print(f\"{v} {u}\")\n\n    return \"\"\n"
    },
    {
        "number": 634,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split())\n    reclaimed = set()\n    for i in range(n):\n        r_i, c_i = map(int, stdin.split())\n        reclaimed.add((r_i, c_i))\n\n    def is_valid(r: int, c: int) -> bool:\n        return (r - 1, 3 - c) not in reclaimed and (r, 3 - c) not in reclaimed and (r + 1, 3 - c) not in reclaimed\n\n    def last_city(r: int, c: int) -> int:\n        if is_valid(r, c):\n            return 1\n        else:\n            return 2\n\n    def last_city_turn(turn: int) -> int:\n        if turn == 1:\n            return 2\n        else:\n            return 1\n\n    def last_city_choice(r: int, c: int, turn: int) -> int:\n        if turn == 1:\n            return last_city(r, c)\n        else:\n            return 3 - last_city(r, c)\n\n    def last_city_choice_for_turn(turn: int) -> int:\n        if turn == 1:\n            return 1\n        else:\n            return 2\n\n    def last_city_choice_for_turn_and_city(turn: int, city: int) -> int:\n        if turn == 1:\n            return city\n        else:\n            return 3 - city\n\n    def last_city_choice_for_turn_and_city_and_cell(turn: int, city: int, cell: int) -> int:\n        if turn == 1:\n            return last_city_choice_for_turn_and_city(turn, city)\n        else:\n            return 3 - last_city_choice_for_turn_and_city(turn, city)\n\n    def last_city_choice_for_turn_and_city_and_cell_and_direction(turn: int, city: int, cell: int, direction: int) -> int:\n        if turn == 1:\n            return last_city_choice_for_turn_and_city_and_cell(turn, city, cell)\n        else:\n            return 3 - last_city_choice_for_turn_and_city_and_cell(turn, city, cell)\n\n    def last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell(turn: int, city: int, cell: int, direction: int, cell_to_reclaim: int) -> int:\n        if turn == 1:\n            return last_city_choice_for_turn_and_city_and_cell_and_direction(turn, city, cell, direction)\n        else:\n            return 3 - last_city_choice_for_turn_and_city_and_cell_and_direction(turn, city, cell, direction)\n\n    def last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell_to_reclaim(turn: int, city: int, cell: int, direction: int, cell_to_reclaim: int) -> int:\n        if turn == 1:\n            return last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell(turn, city, cell, direction, cell_to_reclaim)\n        else:\n            return 3 - last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell(turn, city, cell, direction, cell_to_reclaim)\n\n    def last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell_to_reclaim_and_direction(turn: int, city: int, cell: int, direction: int, cell_to_reclaim: int, direction_to_reclaim: int) -> int:\n        if turn == 1:\n            return last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell_to_reclaim(turn, city, cell, direction, cell_to_reclaim)\n        else:\n            return 3 - last_city_choice_for_turn_and_city_and_cell_and_direction_and_cell_to_reclaim(turn, city, cell, direction, cell_to_reclaim)\n\n    def last_city_choice_for_turn_and_city_and_cell_and"
    },
    {
        "number": 635,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_station_open(station: int, track: int) -> bool:\n        return a[station - 1] == 1 and b[station - 1] == 1\n\n    def is_station_closed(station: int, track: int) -> bool:\n        return a[station - 1] == 0 and b[station - 1] == 0\n\n    def is_station_open_for_track(station: int, track: int) -> bool:\n        return a[station - 1] == 1\n\n    def is_station_closed_for_track(station: int, track: int) -> bool:\n        return a[station - 1] == 0\n\n    def is_station_open_for_direction(station: int, direction: int) -> bool:\n        return a[station - 1] == 1\n\n    def is_station_closed_for_direction(station: int, direction: int) -> bool:\n        return a[station - 1] == 0\n\n    def is_station_open_for_direction_and_track(station: int, direction: int, track: int) -> bool:\n        return a[station - 1] == 1 and b[station - 1] == 1\n\n    def is_station_closed_for_direction_and_track(station: int, direction: int, track: int) -> bool:\n        return a[station - 1] == 0 and b[station - 1] == 0\n\n    def is_station_open_for_direction_and_track_and_station(station: int, direction: int, track: int, other_station: int) -> bool:\n        return a[station - 1] == 1 and b[station - 1] == 1\n\n    def is_station_closed_for_direction_and_track_and_station(station: int, direction: int, track: int, other_station: int) -> bool:\n        return a[station - 1] == 0 and b[station - 1] == 0\n\n    def is_station_open_for_direction_and_track_and_station_and_direction(station: int, direction: int, track: int, other_station: int, other_direction: int) -> bool:\n        return a[station - 1] == 1 and b[station - 1] == 1\n\n    def is_station_closed_for_direction_and_track_and_station_and_direction(station: int, direction: int, track: int, other_station: int, other_direction: int) -> bool:\n        return a[station - 1] == 0 and b[station - 1] == 0\n\n    def is_station_open_for_direction_and_track_and_station_and_direction_and_station(station: int, direction: int, track: int, other_station: int, other_direction: int, other_other_station: int) -> bool:\n        return a[station - 1] == 1 and b[station - 1] == 1\n\n    def is_station_closed_for_direction_and_track_and_station_and_direction_and_station(station: int, direction: int, track: int, other_station: int, other_direction: int, other_other_station: int) -> bool:\n        return a[station - 1] == 0 and b[station - 1] == 0\n\n    def is_station_open_for_direction_and_track_and_station_and_direction_and_station_and_direction(station: int, direction: int, track: int, other_station: int, other_direction: int, other_other_station: int, other_other_direction: int) -> bool:\n        return a[station - 1] == 1 and b[station - 1] == 1\n\n    def is_station_closed_for_direction_and_track_and_station_and_direction_and_station_and_direction(station: int, direction: int, track: int, other_station: int, other_direction: int, other_other_station: int, other_other_direction: int) -> bool:\n        return a[station - 1] == 0 and b[station - 1] == 0\n\n    def is_station_open_for"
    },
    {
        "number": 636,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(i, days):\n        if days == 0:\n            return 1\n\n        if i == n:\n            return 0\n\n        return dfs(i + 1, days - a[i])\n\n    def bfs(days):\n        queue = [(0, days)]\n        visited = set()\n        result = []\n\n        while queue:\n            depth, days = queue.pop(0)\n\n            if days == 0:\n                result.append(depth)\n                continue\n\n            if days in visited:\n                continue\n\n            visited.add(days)\n\n            for i in range(n):\n                if dfs(i, days - a[i]) > 0:\n                    queue.append((depth + 1, days - a[i]))\n\n        return result\n\n    result = bfs(k)\n    return str(len(result)) +'' +''.join(map(str, result))"
    },
    {
        "number": 637,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    photo = list(map(int, stdin.split()[1].split()))\n\n    black_stripes = 0\n    white_stripes = 0\n\n    for i in range(n):\n        if photo[i] == 0:\n            black_stripes += 1\n        else:\n            white_stripes += 1\n\n    if black_stripes == 0 or white_stripes == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 638,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n\n    def find_min_fail(t: List[int], i: int) -> int:\n        fail_count = 0\n        for j in range(i):\n            if t[j] > t[i]:\n                fail_count += 1\n        return fail_count\n\n    min_fail = [find_min_fail(t, i) for i in range(n)]\n    return \" \".join(map(str, min_fail))\n"
    },
    {
        "number": 639,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    set_ = set(map(int, stdin.split()[1:]))\n    operations = 0\n    while set_:\n        if not set_:\n            break\n        if x in set_:\n            set_.remove(x)\n            operations += 1\n        else:\n            set_.add(min(set_) + 1)\n            operations += 1\n    return str(operations)"
    },
    {
        "number": 640,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    ways = 0\n    draws = 0\n    wins = 0\n\n    for i in range(1, 7):\n        for j in range(1, 7):\n            for k in range(1, 7):\n                if i + j + k == a + b:\n                    draws += 1\n                elif i + j + k > a + b:\n                    wins += 1\n                else:\n                    ways += 1\n\n    return f\"{ways} {draws} {wins}\""
    },
    {
        "number": 641,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days_of_week = {\n        \"Monday\": 1,\n        \"Tuesday\": 2,\n        \"Wednesday\": 3,\n        \"Thursday\": 4,\n        \"Friday\": 5,\n        \"Saturday\": 6,\n        \"Sunday\": 7,\n    }\n\n    days_of_month = {\n        \"1\": 1,\n        \"2\": 2,\n        \"3\": 3,\n        \"4\": 4,\n        \"5\": 5,\n        \"6\": 6,\n        \"7\": 7,\n        \"8\": 8,\n        \"9\": 9,\n        \"10\": 10,\n        \"11\": 11,\n        \"12\": 12,\n        \"13\": 13,\n        \"14\": 14,\n        \"15\": 15,\n        \"16\": 16,\n        \"17\": 17,\n        \"18\": 18,\n        \"19\": 19,\n        \"20\": 20,\n        \"21\": 21,\n        \"22\": 22,\n        \"23\": 23,\n        \"24\": 24,\n        \"25\": 25,\n        \"26\": 26,\n        \"27\": 27,\n        \"28\": 28,\n        \"29\": 29,\n        \"30\": 30,\n        \"31\": 31,\n    }\n\n    if \"of week\" in stdin:\n        day_of_week = stdin.split()[0]\n        if day_of_week in days_of_week:\n            day_of_week_number = days_of_week[day_of_week]\n            if day_of_week_number == 7:\n                return \"0\"\n            else:\n                return str(52 - day_of_week_number)\n        else:\n            return \"Invalid input\"\n    elif \"of month\" in stdin:\n        day_of_month = stdin.split()[0]\n        if day_of_month in days_of_month:\n            day_of_month_number = days_of_month[day_of_month]\n            if day_of_month_number == 31:\n                return \"0\"\n            else:\n                return str(11 - day_of_month_number)\n        else:\n            return \"Invalid input\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 642,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dirty_stairs = list(map(int, stdin.split()))\n\n    def is_valid(i: int) -> bool:\n        if i == 0 or i == n:\n            return True\n        for j in range(m):\n            if i == dirty_stairs[j]:\n                return False\n        return True\n\n    def dfs(i: int) -> bool:\n        if i == n:\n            return True\n        if not is_valid(i):\n            return False\n        if dfs(i + 1) or dfs(i + 2):\n            return True\n        return False\n\n    return \"YES\" if dfs(0) else \"NO\""
    },
    {
        "number": 643,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        x, y, p, q = map(int, stdin.split('\\n')[1].split())\n        if p % q == 0:\n            return str(x)\n        elif p * q > 1:\n            return str(x + 1)\n        else:\n            return str(-1)"
    },
    {
        "number": 644,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    commands = []\n    for line in lines:\n        if line.startswith('for '):\n            n = int(line.split()[1])\n            commands.append(('for', n))\n        elif line.startswith('end'):\n            commands.append(('end', None))\n        elif line.startswith('add'):\n            commands.append(('add', None))\n        else:\n            raise ValueError(f'Invalid command: {line}')\n\n    x = 0\n    for command, n in commands:\n        if command == 'for':\n            x += n\n        elif command == 'end':\n            pass\n        elif command == 'add':\n            x += 1\n\n    if x > 2**32 - 1:\n        return 'OVERFLOW!!!'\n    else:\n        return str(x)"
    },
    {
        "number": 645,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    cards = stdin.lower()\n    min_turns = 0\n\n    for i in range(len(cards)):\n        if cards[i] in vowels:\n            if cards[i] == cards[i + 1]:\n                min_turns += 1\n            else:\n                min_turns += 2\n\n    return str(min_turns)"
    },
    {
        "number": 646,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.split()[1:3])\n        points.append((x, y))\n\n    def distance(a: tuple, b: tuple) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def find_closest_point(point: tuple, points: list) -> tuple:\n        closest_point = point\n        closest_distance = distance(point, points[0])\n        for p in points:\n            distance_to_p = distance(point, p)\n            if distance_to_p < closest_distance:\n                closest_point = p\n                closest_distance = distance_to_p\n        return closest_point\n\n    def find_closest_point_to_point(point: tuple, points: list) -> tuple:\n        closest_point = point\n        closest_distance = distance(point, points[0])\n        for p in points:\n            distance_to_p = distance(point, p)\n            if distance_to_p < closest_distance:\n                closest_point = p\n                closest_distance = distance_to_p\n        return closest_point\n\n    def find_closest_point_to_line(point: tuple, line: tuple) -> tuple:\n        x1, y1, x2, y2 = line\n        if x1 == x2:\n            return (x1, y1) if point[1] < y1 else (x1, y2)\n        slope = (y2 - y1) / (x2 - x1)\n        y_intercept = y1 - slope * x1\n        x = point[0]\n        y = slope * x + y_intercept\n        return (x, y)\n\n    def find_closest_point_to_line_segment(point: tuple, line_segment: tuple) -> tuple:\n        x1, y1, x2, y2 = line_segment\n        if x1 == x2:\n            return (x1, y1) if point[1] < y1 else (x1, y2)\n        slope = (y2 - y1) / (x2 - x1)\n        y_intercept = y1 - slope * x1\n        x = point[0]\n        y = slope * x + y_intercept\n        if x < min(x1, x2) or x > max(x1, x2):\n            return None\n        if y < min(y1, y2) or y > max(y1, y2):\n            return None\n        return (x, y)\n\n    def find_closest_point_to_triangle(point: tuple, triangle: tuple) -> tuple:\n        x1, y1, x2, y2, x3, y3 = triangle\n        if x1 == x2 or x1 == x3 or x2 == x3:\n            return (x1, y1) if point[1] < y1 else (x2, y2)\n        if y1 == y2 or y1 == y3 or y2 == y3:\n            return (x1, y1) if point[0] < x1 else (x2, y2)\n        if x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) == 0:\n            return None\n        x = (y2 - y3) * (point[0] - x3) + (y3 - y1) * (point[1] - y3) + (y1 - y2) * (point[0] - x1)\n        y = (x3 - x2) * (point[0] - x3) + (x1 - x3) * (point[1] - y3) + (x2 - x1) * (point[0] - x2)\n        return (x, y)\n\n    def find_closest_point_to_polygon(point: tuple, polygon: list) -> tuple:\n        closest_point = None\n        closest_distance = float('inf')\n        for p in polygon:\n            distance_to_p = distance(point, p)\n            if distance_to_p < closest_distance:\n                closest_point = p\n                closest_distance = distance_to_p\n        return closest_point\n\n    def find_closest_point_to_polygon_segment(point: tuple, polygon_segment: list) -> tuple:\n        x1, y1, x2, y2 = polygon_segment\n        if x1 == x2:\n            return (x1,"
    },
    {
        "number": 647,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    left_handers = [i for i, c in enumerate(stdin.split()[1]) if c == 'L']\n    right_handers = [i for i, c in enumerate(stdin.split()[1]) if c == 'R']\n\n    def find_pair(left_handers, right_handers):\n        for i in range(len(left_handers)):\n            for j in range(i + 1, len(left_handers)):\n                if left_handers[i]!= right_handers[j]:\n                    return (left_handers[i], right_handers[j])\n        return None\n\n    pairs = []\n    for i in range(n // 2):\n        pair = find_pair(left_handers, right_handers)\n        if pair:\n            pairs.append(pair)\n            left_handers.remove(pair[0])\n            right_handers.remove(pair[1])\n\n    return''.join(map(str, pairs))"
    },
    {
        "number": 648,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    max_bananas = 0\n    for x in range(1, 1000):\n        for y in range(1, 1000):\n            if x + y <= m * x + b:\n                max_bananas = max(max_bananas, x + y)\n    return str(max_bananas)"
    },
    {
        "number": 649,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    visited = set()\n    def dfs(level, x, y):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        if level == n:\n            return\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n:\n                dfs(level + 1, nx, ny)\n    m, n = 1, 1\n    for ti in t:\n        m *= 2\n        n *= 2\n    dfs(0, 0, 0)\n    return str(len(visited))"
    },
    {
        "number": 650,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) < 1 or len(stdin) > 10:\n        return \"NO\"\n    for char in stdin:\n        if char.isupper() and char.isalpha():\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 651,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    maze = [list(row) for row in stdin.split()[1:]]\n    start = maze.index(['S', '.'])\n    exit = maze.index(['E', '.'])\n    maze[start][1] = '#'\n    maze[exit][1] = '#'\n\n    directions = {\n        '0': 'D',\n        '1': 'L',\n        '2': 'U',\n        '3': 'R'\n    }\n\n    mappings = []\n    for digit in '0123':\n        mapping = []\n        for i in range(4):\n            mapping.append(directions[digit])\n        mappings.append(mapping)\n\n    mappings = [mapping for mapping in mappings if all(maze[start][0] + i in range(n) for i in range(4)) and all(maze[start][1] + i in range(m) for i in range(4)) and all(maze[exit][0] + i in range(n) for i in range(4)) and all(maze[exit][1] + i in range(m) for i in range(4))]\n\n    return str(len(mappings))"
    },
    {
        "number": 652,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: (x[0], x[1]))\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if points[i][0] == points[j][0] or points[i][1] == points[j][1]:\n                continue\n            if points[i][0] * points[j][1] < points[i][1] * points[j][0]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 653,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    events = stdin.split()[1]\n    rooms = [0] * 10\n    room_assignment = [0] * 10\n    room_count = 0\n\n    for event in events:\n        if event == 'L':\n            room_count = 0\n            for i in range(10):\n                if rooms[i] == 0:\n                    room_count += 1\n                    room_assignment[i] = 1\n                    rooms[i] = 1\n                    break\n            if room_count == 0:\n                room_assignment[0] = 1\n                rooms[0] = 1\n                room_count = 1\n        elif event == 'R':\n            room_count = 0\n            for i in range(10):\n                if rooms[i] == 0:\n                    room_count += 1\n                    room_assignment[i] = 1\n                    rooms[i] = 1\n                    break\n            if room_count == 0:\n                room_assignment[9] = 1\n                rooms[9] = 1\n                room_count = 1\n        else:\n            room_index = int(event)\n            if rooms[room_index] == 0:\n                room_assignment[room_index] = 1\n                rooms[room_index] = 1\n\n    return ''.join(str(room_assignment[i]) for i in range(10))"
    },
    {
        "number": 654,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    trie = Trie()\n    for i in range(n):\n        s = input()\n        trie.insert(s)\n    return str(trie.size_of_max_matching())\n\nclass Trie:\n    def __init__(self):\n        self.root = Node()\n\n    def insert(self, s: str):\n        node = self.root\n        for c in s:\n            node = node.children.setdefault(c, Node())\n        node.is_end_of_word = True\n\n    def size_of_max_matching(self):\n        return self._size_of_max_matching(self.root)\n\n    def _size_of_max_matching(self, node: Node) -> int:\n        if node.is_end_of_word:\n            return 1\n        size = 0\n        for child in node.children.values():\n            size += self._size_of_max_matching(child)\n        return size\n\nclass Node:\n    def __init__(self):\n        self.children = {}\n        self.is_end_of_word = False"
    },
    {
        "number": 655,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    if x == 1 and y == 1:\n        return \"White\"\n    elif x == n and y == n:\n        return \"Black\"\n    else:\n        return \"White\" if x > y else \"Black\""
    },
    {
        "number": 656,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    \n    # Summer tires\n    s_tires = 0\n    for i in range(n):\n        if t[i] >= 0:\n            s_tires += 1\n        else:\n            break\n    \n    # Winter tires\n    w_tires = 0\n    for i in range(n, 2*n):\n        if t[i] >= 0:\n            w_tires += 1\n        else:\n            break\n    \n    # Change tires\n    changes = 0\n    if s_tires > 0:\n        changes += 1\n    if w_tires > 0:\n        changes += 1\n    \n    # Check if it is possible to drive safely\n    if changes > k:\n        return -1\n    \n    return str(changes)"
    },
    {
        "number": 657,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    yellow, blue = map(int, stdin.split())\n    yellow_balls = yellow // 2\n    green_balls = yellow_balls + (yellow % 2)\n    blue_balls = green_balls + blue\n    return str(min(yellow_balls, green_balls, blue_balls))"
    },
    {
        "number": 658,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, v, u = map(int, stdin.split())\n    bus_points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        bus_points.append((x, y))\n\n    bus_polygon = Polygon(bus_points)\n    pedestrian_segment = LineString([(0, 0), (0, w)])\n\n    t = 0\n    while not bus_polygon.contains(pedestrian_segment.intersection(bus_polygon)):\n        t += v\n        pedestrian_segment = LineString([(pedestrian_segment.x1, pedestrian_segment.y1 - v * t), (pedestrian_segment.x2, pedestrian_segment.y2 - v * t)])\n\n    return str(t)"
    },
    {
        "number": 659,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n                break\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a[2] = a[2], a[1]\n\n    if a[0] > a[1]:\n        a[0], a[1] = a[1], a[0]\n\n    if a[0] > a[2]:\n        a[0], a[2] = a[2], a[0]\n\n    if a[1] > a[2]:\n        a[1], a"
    },
    {
        "number": 660,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    k = 1\n    while k * 2 <= n:\n        k *= 2\n    if k * 2 > n:\n        k = n // 2\n    x = k * b + p * 2\n    y = (n - k) * b + p * 2\n    return f\"{x} {y}\""
    },
    {
        "number": 661,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    if M > 17 or M < 0 or K > 10**9 or K < 0:\n        return -1\n\n    a = [0] * (2 ** (M + 1))\n    a[0] = 0\n    a[1] = 1\n\n    for i in range(2, 2 ** (M + 1)):\n        a[i] = a[i - 1] ^ a[i - 2] ^ a[i - 4] ^ a[i - 8] ^ a[i - 16] ^ a[i - 32] ^ a[i - 64] ^ a[i - 128] ^ a[i - 256]\n\n    count = 0\n    for i in range(2 ** (M + 1)):\n        if a[i] == K:\n            count += 1\n\n    if count % 2 == 0:\n        return -1\n\n    result = []\n    for i in range(2 ** (M + 1)):\n        if a[i] == K:\n            result.append(i)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 662,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    log = [int(x) for x in stdin.split()[1:]]\n\n    alex_wins = 0\n    bob_wins = 0\n    carl_wins = 0\n\n    for game in log:\n        if game == 1:\n            alex_wins += 1\n        elif game == 2:\n            bob_wins += 1\n        else:\n            carl_wins += 1\n\n    if alex_wins == 0 and bob_wins == 0 and carl_wins == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 663,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x', y' = map(int, stdin.split())\n    steps = 0\n    while True:\n        steps += 1\n        dx = x' - x\n        dy = y' - y\n        if dx ** 2 + dy ** 2 <= r ** 2:\n            break\n        x, y = x + dx, y + dy\n    return str(steps)"
    },
    {
        "number": 664,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    if n == 1:\n        return \"0\"\n\n    if a[0] > a[1]:\n        return \"1\"\n\n    for i in range(1, n - 1):\n        if a[i] > a[i + 1]:\n            return str(i + 1)\n\n    return \"-1\""
    },
    {
        "number": 665,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def recite_verse(parts: List[int], time: int) -> int:\n        total_time = sum(parts)\n        if total_time > time:\n            return 0\n\n        time_left = time\n        for part in parts:\n            time_left -= part\n            if time_left < 0:\n                return 0\n\n        return len(parts)\n\n    def skip_parts(parts: List[int], time: int) -> int:\n        max_parts = 0\n        for i in range(len(parts)):\n            if i == 0:\n                max_parts += recite_verse(parts[:i + 1], time)\n            else:\n                max_parts += recite_verse(parts[:i], time)\n\n        return max_parts\n\n    def find_max_parts(parts: List[int], time: int) -> int:\n        max_parts = 0\n        for i in range(1, len(parts) + 1):\n            max_parts = max(max_parts, skip_parts(parts[:i], time))\n\n        return max_parts\n\n    def process_test_case(test_case: List[int]) -> int:\n        n, s = test_case[:2]\n        parts = test_case[2:]\n\n        max_parts = 0\n        for i in range(1, n + 1):\n            max_parts = max(max_parts, skip_parts(parts[:i], s))\n\n        return max_parts\n\n    test_cases = int(stdin.split('\\n')[0])\n    result = []\n\n    for _ in range(test_cases):\n        test_case = list(map(int, stdin.split('\\n')[1].split()))\n        result.append(str(process_test_case(test_case)))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 666,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = [1]\n    for i in range(1, 10):\n        sequence.extend([i + 1] * i)\n    return str(sequence[n - 1])"
    },
    {
        "number": 667,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1, n):\n            aij = int(stdin.split()[i+1])\n            graph[i].append((j, aij))\n            graph[j].append((i, aij))\n    dist = [float('inf')] * n\n    dist[0] = 0\n    for i in range(1, n):\n        min_dist = float('inf')\n        for j in range(n):\n            if dist[j] < min_dist:\n                min_dist = dist[j]\n        for j in range(n):\n            if dist[j] == min_dist:\n                for k, ajk in graph[j]:\n                    if dist[k] > dist[j] + ajk:\n                        dist[k] = dist[j] + ajk\n    return str(max(dist))"
    },
    {
        "number": 668,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [0] + a\n    a.sort()\n    if a[0] > 0:\n        return -1\n\n    def dfs(i, j, k):\n        if k == 0:\n            return True\n        if i == n:\n            return False\n        if a[i] > 0:\n            return dfs(i + 1, j, k - 1) or dfs(i + 1, j + 1, k)\n        return dfs(i + 1, j, k)\n\n    for i in range(1, n):\n        if a[i] > 0:\n            if dfs(i, 0, a[i]):\n                return a[i]\n\n    return -1"
    },
    {
        "number": 669,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_sum(b):\n        return sum(a[i] for i in b) % m\n\n    def min_sum(b):\n        return sum(a[i] for i in b) % m\n\n    def max_sum_index(b):\n        return max(b, key=lambda x: sum(a[i] for i in b[:x]))\n\n    def min_sum_index(b):\n        return min(b, key=lambda x: sum(a[i] for i in b[:x]))\n\n    b = []\n    max_sum_value = 0\n    max_sum_index_set = set()\n\n    for i in range(1, n + 1):\n        if max_sum(b) < max_sum(b + [i]):\n            b.append(i)\n            max_sum_value = max(max_sum_value, max_sum(b))\n            max_sum_index_set.add(max_sum_index(b))\n        elif min_sum(b) > min_sum(b + [i]):\n            b.append(i)\n            max_sum_value = max(max_sum_value, max_sum(b))\n            max_sum_index_set.add(max_sum_index(b))\n\n    return str(max_sum_value)"
    },
    {
        "number": 670,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    def distance(x, y):\n        return abs(x1 - x) + abs(y1 - y)\n\n    def is_diagonal(x, y):\n        return a * x + b * y + c == 0\n\n    def is_inside(x, y):\n        return 0 <= x <= x2 and 0 <= y <= y2\n\n    def is_valid(x, y):\n        return is_diagonal(x, y) and is_inside(x, y)\n\n    def is_valid_diagonal(x, y):\n        return is_diagonal(x, y) and is_inside(x, y)\n\n    def is_valid_diagonal_and_distance(x, y):\n        return is_valid_diagonal(x, y) and distance(x, y) <= 1\n\n    def is_valid_diagonal_and_distance_and_manhattan(x, y):\n        return is_valid_diagonal_and_distance(x, y) and abs(x - x1) + abs(y - y1) <= 1\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y):\n        return is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y) and is_diagonal(x, y)\n\n    def is_valid_diagonal_and_distance_and_manhattan_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal_and_diagonal(x, y):\n       "
    },
    {
        "number": 671,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    line = \"123456789101112131415...\"\n    return line[n - 1]"
    },
    {
        "number": 672,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a % b == 0:\n        return \"infinity\"\n    else:\n        count = 0\n        for i in range(1, b + 1):\n            if a % i == 0:\n                count += 1\n        return str(count)"
    },
    {
        "number": 673,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n + k\n    while x % k!= 0:\n        x += 1\n    return str(x)"
    },
    {
        "number": 674,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = set(stdin.split()[1:])\n\n    def count_substrings(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                count += 1\n        return count\n\n    def is_good(s: str) -> bool:\n        count = count_substrings(s)\n        return count >= len(strings)\n\n    def restore_good_string(good_strings: set) -> str:\n        def restore_substring(s: str) -> str:\n            min_length = float('inf')\n            min_substring = ''\n            for substring in good_strings:\n                if s.startswith(substring):\n                    length = len(substring)\n                    if length < min_length:\n                        min_length = length\n                        min_substring = substring\n            return min_substring\n\n        def restore_string(s: str) -> str:\n            min_length = float('inf')\n            min_string = ''\n            for substring in good_strings:\n                if substring in s:\n                    length = len(substring)\n                    if length < min_length:\n                        min_length = length\n                        min_string = substring\n            return min_string\n\n        return restore_substring(restore_string(stdin))\n\n    good_strings = set(filter(is_good, strings))\n    if not good_strings:\n        return \"NO\"\n    return restore_good_string(good_strings)\n"
    },
    {
        "number": 675,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n\n    w.sort()\n    w.append(3600)\n\n    candles = 0\n    for i in range(len(w) - 1):\n        if w[i] + t <= w[i + 1]:\n            candles += 1\n            if candles >= r:\n                return candles\n\n    return -1"
    },
    {
        "number": 676,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    if a[0] == a[1] == a[2] == a[3]:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef"
    },
    {
        "number": 677,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n') if line]\n    result = []\n\n    for query in queries:\n        l, r, d = query\n        x = l + (r - l) % d\n        result.append(x)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 678,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    nums = [int(line.strip()) for line in lines]\n    nums.sort()\n    tux = nums[0]\n    pur = nums[-1]\n    foo = nums[1]\n    bar = nums[2]\n    baz = nums[3]\n    quz = nums[4]\n    tux_num = 0\n    pur_num = 0\n    foo_num = 0\n    bar_num = 0\n    baz_num = 0\n    quz_num = 0\n    tux_loop = 0\n    pur_loop = 0\n    foo_loop = 0\n    bar_loop = 0\n    baz_loop = 0\n    quz_loop = 0\n    while tux_num < tux and pur_num < pur:\n        tux_num += 1\n        pur_num += 1\n        tux_loop += 1\n        pur_loop += 1\n    while foo_num < foo and bar_num < bar and baz_num < baz and quz_num < quz:\n        foo_num += 1\n        bar_num += 1\n        baz_num += 1\n        quz_num += 1\n        foo_loop += 1\n        bar_loop += 1\n        baz_loop += 1\n        quz_loop += 1\n    while tux_num > 0 and pur_num > 0:\n        tux_num -= 1\n        pur_num -= 1\n        tux_loop -= 1\n        pur_loop -= 1\n    while foo_num > 0 and bar_num > 0 and baz_num > 0 and quz_num > 0:\n        foo_num -= 1\n        bar_num -= 1\n        baz_num -= 1\n        quz_num -= 1\n        foo_loop -= 1\n        bar_loop -= 1\n        baz_loop -= 1\n        quz_loop -= 1\n    while tux_num < tux and pur_num < pur:\n        tux_num += 1\n        pur_num += 1\n        tux_loop += 1\n        pur_loop += 1\n    while foo_num < foo and bar_num < bar and baz_num < baz and quz_num < quz:\n        foo_num += 1\n        bar_num += 1\n        baz_num += 1\n        quz_num += 1\n        foo_loop += 1\n        bar_loop += 1\n        baz_loop += 1\n        quz_loop += 1\n    while tux_num > 0 and pur_num > 0:\n        tux_num -= 1\n        pur_num -= 1\n        tux_loop -= 1\n        pur_loop -= 1\n    while foo_num > 0 and bar_num > 0 and baz_num > 0 and quz_num > 0:\n        foo_num -= 1\n        bar_num -= 1\n        baz_num -= 1\n        quz_num -= 1\n        foo_loop -= 1\n        bar_loop -= 1\n        baz_loop -= 1\n        quz_loop -= 1\n    while tux_num < tux and pur_num < pur:\n        tux_num += 1\n        pur_num += 1\n        tux_loop += 1\n        pur_loop += 1\n    while foo_num < foo and bar_num < bar and baz_num < baz and quz_num < quz:\n        foo_num += 1\n        bar_num += 1\n        baz_num += 1\n        quz_num += 1\n        foo_loop += 1\n        bar_loop += 1\n        baz_loop += 1\n        quz_loop += 1\n    while tux_num > 0 and pur_num > 0:\n        tux_num -= 1\n        pur_num -= 1\n        tux_loop -= 1\n        pur_loop -= 1\n    while foo_num > 0 and bar_num > 0 and baz_num > 0 and quz_num > 0:\n        foo_num -= 1\n        bar_num -= 1\n        baz_num -= 1\n        quz_num -= 1\n        foo_loop -= 1\n        bar_loop -= 1\n        baz_loop -= 1\n        quz_loop -= 1\n    while tux_num < tux and pur_num < pur:\n        tux_num += 1\n        pur_num += 1\n        tux_loop += 1\n        pur_loop += 1\n    while foo_num < foo and bar_num < bar"
    },
    {
        "number": 679,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    row = 0\n    col = 0\n    flowers = 0\n    while col < n:\n        if s[col] == '.':\n            col += 1\n            continue\n        if s[col] == 'A':\n            s[col] = 'B'\n            flowers += 1\n        elif s[col] == 'B':\n            s[col] = 'C'\n            flowers += 1\n        elif s[col] == 'C':\n            s[col] = 'A'\n            flowers += 1\n        col += 1\n    if flowers == 0:\n        return 'Yes'\n    for i in range(n):\n        if s[i] == 'A' and s[i+1] == 'B' and s[i+2] == 'C':\n            return 'Yes'\n    return 'No'"
    },
    {
        "number": 680,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_A, y_A = map(int, stdin.split())\n    x_B, y_B = map(int, stdin.split())\n    x_C, y_C = map(int, stdin.split())\n\n    def is_adjacent(x1, y1, x2, y2):\n        return abs(x1 - x2) == 1 or abs(y1 - y2) == 1\n\n    def clean_plots(x, y, visited):\n        if (x, y) in visited:\n            return visited\n        visited.add((x, y))\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 1001 and 0 <= ny < 1001 and forest[ny][nx] == 0:\n                clean_plots(nx, ny, visited)\n        return visited\n\n    forest = [[1] * 1001 for _ in range(1001)]\n    visited = set()\n    clean_plots(x_A, y_A, visited)\n    clean_plots(x_B, y_B, visited)\n    clean_plots(x_C, y_C, visited)\n\n    k = len(visited)\n    result = []\n    for x, y in visited:\n        result.append(f\"{x} {y}\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 681,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_combinations(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j]\n        return dp[n]\n\n    def count_combinations_with_split(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j] * (gems[i - 1] - gems[j])\n        return dp[n]\n\n    def count_combinations_without_split(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j] * gems[i - 1]\n        return dp[n]\n\n    def count_combinations_with_split_and_without_split(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j] * (gems[i - 1] - gems[j]) * gems[i - 1]\n        return dp[n]\n\n    def count_combinations_with_split_and_without_split_and_magic_gem(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j] * (gems[i - 1] - gems[j]) * gems[i - 1] * (gems[i - 1] - gems[j])\n        return dp[n]\n\n    def count_combinations_with_split_and_without_split_and_magic_gem_and_normal_gem(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j] * (gems[i - 1] - gems[j]) * gems[i - 1] * (gems[i - 1] - gems[j]) * gems[i - 1]\n        return dp[n]\n\n    def count_combinations_with_split_and_without_split_and_magic_gem_and_normal_gem_and_magic_gem(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp = [1] * (n + 1)\n        for i in range(1, n + 1):\n            for j in range(i):\n                if gems[i - 1] - gems[j] >= 0:\n                    dp[i] += dp[j] * (gems[i - 1] - gems[j]) * gems[i - 1] * (gems[i - 1] - gems[j]) * gems[i - 1] * gems[i - 1]\n        return dp[n]\n\n    def count_combinations_with_split_and_without_split_and_magic_gem_and_normal_gem_and_magic_gem_and_normal_gem(gems: list[int]) -> int:\n        gems.sort()\n        n = len(gems)\n        dp ="
    },
    {
        "number": 682,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n    moves = [0, 0, 0]\n\n    def move(piece, row, col, dr, dc):\n        nonlocal moves\n        if row + dr < 1 or row + dr > 8 or col + dc < 1 or col + dc > 8:\n            moves[piece - 1] = 0\n            return\n        if board[row + dr][col + dc]!= 0:\n            moves[piece - 1] = 0\n            return\n        board[row][col] = 0\n        board[row + dr][col + dc] = piece\n        moves[piece - 1] += 1\n        move(piece, row + dr, col + dc, dr, dc)\n        board[row + dr][col + dc] = 0\n\n    board = [[0] * 8 for _ in range(8)]\n    board[r1 - 1][c1 - 1] = 1\n    board[r2 - 1][c2 - 1] = 2\n\n    move(1, r1 - 1, c1 - 1, r2 - r1, c2 - c1)\n    move(2, r1 - 1, c1 - 1, r2 - r1, c2 - c1)\n    move(3, r1 - 1, c1 - 1, r2 - r1, c2 - c1)\n\n    return \" \".join(map(str, moves))"
    },
    {
        "number": 683,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    elif a == 2:\n        return \"10\"\n    elif a == 3:\n        return \"100\"\n    elif a == 4:\n        return \"1000\"\n    elif a == 5:\n        return \"10000\"\n    elif a == 6:\n        return \"100000\"\n    elif a == 7:\n        return \"1000000\"\n    elif a == 8:\n        return \"10000000\"\n    elif a == 9:\n        return \"100000000\"\n    elif a == 10:\n        return \"1000000000\"\n    elif a == 11:\n        return \"10000000000\"\n    elif a == 12:\n        return \"100000000000\"\n    elif a == 13:\n        return \"1000000000000\"\n    elif a == 14:\n        return \"10000000000000\"\n    elif a == 15:\n        return \"100000000000000\"\n    elif a == 16:\n        return \"1000000000000000\"\n    elif a == 17:\n        return \"10000000000000000\"\n    elif a == 18:\n        return \"100000000000000000\"\n    elif a == 19:\n        return \"1000000000000000000\"\n    elif a == 20:\n        return \"10000000000000000000\"\n    elif a == 21:\n        return \"100000000000000000000\"\n    elif a == 22:\n        return \"1000000000000000000000\"\n    elif a == 23:\n        return \"10000000000000000000000\"\n    elif a == 24:\n        return \"100000000000000000000000\"\n    elif a == 25:\n        return \"1000000000000000000000000\"\n    elif a == 26:\n        return \"10000000000000000000000000\"\n    elif a == 27:\n        return \"100000000000000000000000000\"\n    elif a == 28:\n        return \"1000000000000000000000000000\"\n    elif a == 29:\n        return \"10000000000000000000000000000\"\n    elif a == 30:\n        return \"100000000000000000000000000000\"\n    elif a == 31:\n        return \"1000000000000000000000000000000\"\n    elif a == 32:\n        return \"10000000000000000000000000000000\"\n    elif a == 33:\n        return \"100000000000000000000000000000000\"\n    elif a == 34:\n        return \"1000000000000000000000000000000000\"\n    elif a == 35:\n        return \""
    },
    {
        "number": 684,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.split()[1:])\n        if a <= b <= c <= d:\n            x = a\n            y = b\n            z = c\n        elif b <= a <= c <= d:\n            x = b\n            y = a\n            z = c\n        elif c <= a <= b <= d:\n            x = c\n            y = a\n            z = b\n        else:\n            x = d\n            y = c\n            z = b\n        print(x, y, z)"
    },
    {
        "number": 685,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    segments = []\n    for i in range(n):\n        x1, x2 = map(int, stdin.split())\n        segments.append((x1, x2))\n    segments.sort()\n    max_distance = 0\n    for i in range(len(segments)):\n        x1, x2 = segments[i]\n        if x1 > 0:\n            max_distance = max(max_distance, x1 - 1)\n        if x2 < 1000000000:\n            max_distance = max(max_distance, x2 + 1)\n    return str(max_distance)"
    },
    {
        "number": 686,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        x, y = map(int, stdin.split()[1:])\n        if x > y:\n            x, y = y, x\n        prime_numbers = [2, 3, 5, 7, 11]\n        for p in prime_numbers:\n            if x % p == 0 and x // p == y:\n                return \"YES\"\n        return \"NO\""
    },
    {
        "number": 687,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n\n    if d_a == 0 or d_b == 0:\n        return \"-1\"\n\n    a = d_a * 10 + 1\n    b = d_b * 10 + 1\n\n    if a > 10**9 or b > 10**9:\n        return \"-1\"\n\n    for i in range(1, 10):\n        if a + i == b:\n            return str(a) + \" \" + str(b)\n\n    return \"-1\""
    },
    {
        "number": 688,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    ice_pieces = stdin.split()[1]\n    ice_pieces = [int(digit) for digit in ice_pieces]\n\n    def rotate_digit(digit: int) -> int:\n        if digit == 6:\n            return 9\n        elif digit == 9:\n            return 6\n        elif digit == 2:\n            return 5\n        elif digit == 5:\n            return 2\n        else:\n            return digit\n\n    def construct_number(ice_pieces: List[int]) -> int:\n        number = 0\n        for digit in ice_pieces:\n            number = number * 10 + rotate_digit(digit)\n        return number\n\n    def count_instances(ice_pieces: List[int]) -> int:\n        instances = set()\n        for _ in range(t):\n            number = construct_number(ice_pieces)\n            instances.add(number)\n        return len(instances)\n\n    return str(count_instances(ice_pieces))\n"
    },
    {
        "number": 689,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        strings = [list(stdin.split('\\n')[i+2].strip()) for i in range(n)]\n        if all(len(s) == len(strings[0]) for s in strings):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 690,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = []\n    for i in range(n):\n        if i == 0:\n            result.append('O' * 10)\n        else:\n            result.append('-' * 10)\n    return '\\n'.join(result)"
    },
    {
        "number": 691,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if x > 10**6:\n        return \"NO\"\n\n    def find_set(x: int) -> list:\n        set_size = 0\n        set_sum = 0\n        set_elements = []\n        while set_sum < x:\n            set_size += 1\n            set_sum = sum(set_elements)\n            set_elements.append(set_size)\n\n        return set_elements\n\n    set_elements = find_set(x)\n    if not set_elements:\n        return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, set_elements))\n"
    },
    {
        "number": 692,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    m = list(map(int, stdin.split()[1].split()))\n    r = list(map(int, stdin.split()[2].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(m, r):\n        m_gcd = gcd(m[0], m[1])\n        r_gcd = gcd(r[0], r[1])\n\n        m = [m[0] // m_gcd, m[1] // m_gcd]\n        r = [r[0] // r_gcd, r[1] // r_gcd]\n\n        m_lcm = lcm(m[0], m[1])\n        r_lcm = lcm(r[0], r[1])\n\n        return (m_lcm * r_lcm) / (m[0] * r[1])\n\n    return str(abs(solve(m, r) - 1))"
    },
    {
        "number": 693,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    k_1, k_2, *k_m = map(int, stdin.split())\n\n    def find_interval(knights):\n        for i in range(1, len(knights)):\n            if knights[i] - knights[i - 1] == k_1:\n                return i\n        return len(knights)\n\n    def find_min_interval(knights):\n        min_interval = find_interval(knights)\n        for i in range(len(knights) - 1, 0, -1):\n            if knights[i] - knights[i - 1] == k_1:\n                min_interval = min(min_interval, find_interval(knights[:i]))\n        return min_interval\n\n    def find_max_interval(knights):\n        max_interval = find_interval(knights)\n        for i in range(len(knights) - 1, 0, -1):\n            if knights[i] - knights[i - 1] == k_1:\n                max_interval = max(max_interval, find_interval(knights[i:]))\n        return max_interval\n\n    def find_min_interval_with_colors(knights, colors):\n        min_interval = find_interval(knights)\n        for i in range(len(knights) - 1, 0, -1):\n            if knights[i] - knights[i - 1] == k_1:\n                min_interval = min(min_interval, find_interval(knights[:i]))\n                if all(colors[i] == colors[j] for j in range(i)):\n                    min_interval = min(min_interval, find_interval(knights[i:]))\n        return min_interval\n\n    def find_max_interval_with_colors(knights, colors):\n        max_interval = find_interval(knights)\n        for i in range(len(knights) - 1, 0, -1):\n            if knights[i] - knights[i - 1] == k_1:\n                max_interval = max(max_interval, find_interval(knights[i:]))\n                if all(colors[i] == colors[j] for j in range(i)):\n                    max_interval = max(max_interval, find_interval(knights[:i]))\n        return max_interval\n\n    min_interval = find_min_interval(colors)\n    max_interval = find_max_interval(colors)\n\n    if min_interval == max_interval:\n        return min_interval\n\n    min_interval_with_colors = find_min_interval_with_colors(colors, colors)\n    max_interval_with_colors = find_max_interval_with_colors(colors, colors)\n\n    if min_interval_with_colors == max_interval_with_colors:\n        return min_interval_with_colors\n\n    return -1"
    },
    {
        "number": 694,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    public_key, a, b = map(int, stdin.split())\n\n    def is_divisible(n: int, d: int) -> bool:\n        return n % d == 0\n\n    def cut_public_key(public_key: int) -> tuple[int, int]:\n        left_part = 0\n        right_part = 0\n\n        while public_key > 0:\n            left_part = (left_part * 10) + (public_key % 10)\n            right_part = (right_part * 10) + (public_key // 10)\n            public_key //= 10\n\n        return left_part, right_part\n\n    left_part, right_part = cut_public_key(public_key)\n\n    if is_divisible(left_part, a) and is_divisible(right_part, b):\n        return \"YES\\n\" + str(left_part) + \"\\n\" + str(right_part)\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 695,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2 = map(int, stdin.split())\n    if a1 == 0 and a2 == 0:\n        return \"0\"\n    elif a1 == 0:\n        return \"1\"\n    elif a2 == 0:\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 696,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    if p < 2 or p > 2000:\n        return \"Invalid input\"\n\n    count = 0\n    for i in range(1, p):\n        if i * i % p == 1:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 697,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 998244853\n    max_sum = 0\n    for i in range(1, n+1):\n        for j in range(1, m+1):\n            array = [1] * i + [-1] * j\n            prefix_sum = sum(array)\n            max_sum = max(max_sum, prefix_sum)\n    return str(max_sum % mod)"
    },
    {
        "number": 698,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    rounds = []\n    for _ in range(k):\n        line = stdin.readline().strip()\n        if line.startswith(\"1 \"):\n            rounds.append((int(line.split()[1]), int(line.split()[2])))\n        elif line.startswith(\"2 \"):\n            rounds.append((int(line.split()[1]), None))\n        else:\n            raise ValueError(\"Invalid input\")\n    rounds.sort()\n    min_missed = 0\n    max_missed = 0\n    for i, (num, div1) in enumerate(rounds):\n        if div1 is None:\n            min_missed = max(min_missed, num - x)\n            max_missed = max(max_missed, x - num)\n        else:\n            min_missed = max(min_missed, num - div1)\n            max_missed = max(max_missed, div1 - num)\n    return f\"{min_missed} {max_missed}\""
    },
    {
        "number": 699,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n\n    if n % k!= 0:\n        return -1\n\n    x = 0\n    while x * k <= n:\n        if x * k + y <= n:\n            x += 1\n        else:\n            break\n\n    if x == 0:\n        return -1\n\n    result = []\n    for i in range(x):\n        result.append(i * k)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 700,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    maps = [list(map(str.strip, stdin.split('\\n')[i+1].split())) for i in range(N)]\n    \n    def rotate_map(map: list) -> list:\n        return [map[j][i] for i in range(N) for j in range(N)]\n    \n    def flip_map(map: list) -> list:\n        return [map[i][N-1-j] for i in range(N) for j in range(N)]\n    \n    def match_maps(map1: list, map2: list) -> bool:\n        if len(map1)!= len(map2) or len(map1[0])!= len(map2[0]):\n            return False\n        \n        for i in range(N):\n            for j in range(N):\n                if map1[i][j]!= map2[i][j]:\n                    return False\n        \n        return True\n    \n    def match_maps_with_rotations(map1: list, map2: list) -> bool:\n        for i in range(4):\n            if match_maps(rotate_map(map1), rotate_map(map2)):\n                return True\n        \n        return False\n    \n    def match_maps_with_flips(map1: list, map2: list) -> bool:\n        for i in range(2):\n            if match_maps(flip_map(map1), flip_map(map2)):\n                return True\n        \n        return False\n    \n    for i in range(N):\n        for j in range(N):\n            if maps[0][i][j] == 'O' and maps[1][i][j] == 'O':\n                continue\n            \n            if match_maps(maps[0], maps[1]):\n                return 'Yes'\n            \n            if match_maps_with_rotations(maps[0], maps[1]):\n                return 'Yes'\n            \n            if match_maps_with_flips(maps[0], maps[1]):\n                return 'Yes'\n    \n    return 'No'"
    },
    {
        "number": 701,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s_suffix_automaton = [0] * len(s)\n    s_suffix_array = [0] * len(s)\n    t_suffix_automaton = [0] * len(t)\n    t_suffix_array = [0] * len(t)\n\n    for i in range(1, len(s)):\n        s_suffix_automaton[i] = s_suffix_automaton[i - 1] + 1\n        while s[i - s_suffix_automaton[i - 1]]!= s[i]:\n            s_suffix_automaton[i] += 1\n\n    for i in range(1, len(t)):\n        t_suffix_automaton[i] = t_suffix_automaton[i - 1] + 1\n        while t[i - t_suffix_automaton[i - 1]]!= t[i]:\n            t_suffix_automaton[i] += 1\n\n    s_suffix_array[0] = 0\n    for i in range(1, len(s)):\n        s_suffix_array[i] = s_suffix_array[i - 1] + s_suffix_automaton[i - 1]\n\n    t_suffix_array[0] = 0\n    for i in range(1, len(t)):\n        t_suffix_array[i] = t_suffix_array[i - 1] + t_suffix_automaton[i - 1]\n\n    s_suffix_array_index = 0\n    t_suffix_array_index = 0\n    result = \"\"\n\n    while s_suffix_array_index < len(s) and t_suffix_array_index < len(t):\n        if s[s_suffix_array_index] == t[t_suffix_array_index]:\n            result += s[s_suffix_array_index]\n            s_suffix_array_index += 1\n            t_suffix_array_index += 1\n        elif s_suffix_array[s_suffix_array_index] < t_suffix_array[t_suffix_array_index]:\n            s_suffix_array_index += 1\n        else:\n            t_suffix_array_index += 1\n\n    if s_suffix_array_index == len(s) and t_suffix_array_index == len(t):\n        return \"both\"\n    elif s_suffix_array_index == len(s):\n        return \"array\"\n    elif t_suffix_array_index == len(t):\n        return \"array\"\n    else:\n        return \"automaton\"\n\n\ndef"
    },
    {
        "number": 702,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    board = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    board = [[cell for cell in row] for row in board]\n\n    def is_valid(piece):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    return False\n        return True\n\n    def is_valid_placement(piece, board):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    continue\n                if piece[i][j] == 'O' and any(board[i + k][j + l] == '#' for k in range(4) for l in range(4)):\n                    return False\n        return True\n\n    def is_valid_placement_with_overlap(piece, board):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    continue\n                if piece[i][j] == 'O' and any(board[i + k][j + l] == '#' for k in range(4) for l in range(4) if k!= l):\n                    return False\n        return True\n\n    def is_valid_placement_with_overlap_and_border(piece, board):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    continue\n                if piece[i][j] == 'O' and any(board[i + k][j + l] == '#' for k in range(4) for l in range(4) if k!= l and (i + k) % n!= 0 and (j + l) % n!= 0):\n                    return False\n        return True\n\n    def is_valid_placement_with_overlap_and_border_and_corner(piece, board):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    continue\n                if piece[i][j] == 'O' and any(board[i + k][j + l] == '#' for k in range(4) for l in range(4) if k!= l and (i + k) % n!= 0 and (j + l) % n!= 0 and (i + k) % n!= n - 1 and (j + l) % n!= n - 1):\n                    return False\n        return True\n\n    def is_valid_placement_with_overlap_and_border_and_corner_and_center(piece, board):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    continue\n                if piece[i][j] == 'O' and any(board[i + k][j + l] == '#' for k in range(4) for l in range(4) if k!= l and (i + k) % n!= 0 and (j + l) % n!= 0 and (i + k) % n!= n - 1 and (j + l) % n!= n - 1 and (i + k) % n!= n and (j + l) % n!= n):\n                    return False\n        return True\n\n    def is_valid_placement_with_overlap_and_border_and_corner_and_center_and_edge(piece, board):\n        for i in range(len(piece)):\n            for j in range(len(piece)):\n                if piece[i][j] == '.' or piece[i][j] == '#' or piece[i][j] == 'X':\n                    continue\n                if piece[i][j] == 'O' and any(board[i + k][j + l] == '#' for k in range(4) for l in range(4) if k!= l and (i + k) % n!= 0 and (j + l) % n!= 0 and (i + k) % n!="
    },
    {
        "number": 703,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    nuts = a * b\n    boxes = nuts // v\n    if nuts % v!= 0:\n        boxes += 1\n    return str(boxes)"
    },
    {
        "number": 704,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    r1, c1, r2, c2 = map(int, stdin.split())\n\n    def count_shifts(r: int, c: int, r2: int, c2: int) -> int:\n        if r == r2:\n            return min(c2, a[r] + 1) - c\n        elif r < r2:\n            return count_shifts(r + 1, 1, r2, c2)\n        else:\n            return count_shifts(r - 1, a[r] + 1, r2, c2)\n\n    return str(count_shifts(r1 - 1, c1 - 1, r2 - 1, c2 - 1))"
    },
    {
        "number": 705,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:n+1]))\n    y = list(map(int, stdin.split()[n+1:]))\n\n    # Check if all integers are distinct\n    if len(set(x + y))!= 2 * n:\n        return \"Invalid input\"\n\n    # Count the number of ordered pairs\n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i] ^ y[j] == 1:\n                pairs += 1\n\n    # Determine the winner\n    if pairs % 2 == 0:\n        return \"Karen\"\n    else:\n        return \"Koyomi\""
    },
    {
        "number": 706,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def g(x, n):\n        if n == 0:\n            return x\n        else:\n            return (g(g(x, n - 1), n - 1) + x) % (10**9 + 7)\n\n    A, B, n, x = map(int, stdin.split())\n    return str(g(x, n))"
    },
    {
        "number": 707,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    def is_valid(y, j):\n        for i in range(n):\n            if x[i] < y:\n                return False\n        return True\n\n    for j in range(1, m + 1):\n        for y in range(1, 10**18):\n            if is_valid(y, j):\n                return \"YES\", str(y), str(j)\n\n    return \"NO\""
    },
    {
        "number": 708,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a, b, c, d = map(int, stdin.split())\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1\n\n    if a == d or b == c:\n        return -1\n\n    if a == b or c == d:\n        return -1\n\n    if a == c or b == d:\n        return -1"
    },
    {
        "number": 709,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x % 2 == 0:\n        return str(x // 2)\n    else:\n        return str(x // 2 + 1)"
    },
    {
        "number": 710,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def replace_letter(letter: str) -> str:\n        if letter == 'A':\n            return 'Z'\n        elif letter == 'Z':\n            return 'Y'\n        else:\n            return chr((ord(letter) - 1) % 26 + ord('A'))\n\n    def is_substring(substring: str, string: str) -> bool:\n        return substring in string\n\n    def count_operations(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i]!= s[i + 1]:\n                count += 1\n        return count\n\n    def min_operations(s: str) -> int:\n        min_count = float('inf')\n        for i in range(26):\n            new_s = ''.join(replace_letter(c) for c in s)\n            if is_substring(new_s, 'ACTG') and count_operations(new_s) < min_count:\n                min_count = count_operations(new_s)\n        return min_count\n\n    return str(min_operations(s))"
    },
    {
        "number": 711,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for i in range(1, N + 1):\n        for j in range(1, i + 1):\n            if i * j == M:\n                count += 1\n                if count % MOD == 0:\n                    return str(count)\n\n    return str(count)"
    },
    {
        "number": 712,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(int, stdin.split())\n    p = float(p)\n\n    def expected_number_of_people_standing_on_escalator(i: int) -> float:\n        if i == 0:\n            return 1\n        else:\n            return expected_number_of_people_standing_on_escalator(i - 1) * (1 - p) + p * expected_number_of_people_standing_on_escalator(i - 1)\n\n    return str(expected_number_of_people_standing_on_escalator(n))"
    },
    {
        "number": 713,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = []\n    for i in range(n):\n        for j in range(m):\n            points.append((i, j))\n    points.sort(key=lambda x: (x[0], x[1]))\n    beautiful_points = []\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            if abs(points[i][0] - points[j][0])!= abs(points[i][1] - points[j][1]):\n                beautiful_points.append(points[i])\n                beautiful_points.append(points[j])\n                break\n    beautiful_points.sort(key=lambda x: (x[0], x[1]))\n    return str(len(beautiful_points)) + '\\n' + '\\n'.join(map(lambda x:''.join(map(str, x)), beautiful_points))"
    },
    {
        "number": 714,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    pairs = []\n    for i in range(n // 2):\n        pairs.append(a[i] + a[n // 2 + i])\n    return '\\n'.join(map(str, pairs))"
    },
    {
        "number": 715,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    choices = []\n    for line in stdin.split('\\n'):\n        if line.startswith('A.'):\n            choices.append(line.split()[1])\n        elif line.startswith('B.'):\n            choices.append(line.split()[1])\n        elif line.startswith('C.'):\n            choices.append(line.split()[1])\n        elif line.startswith('D.'):\n            choices.append(line.split()[1])\n\n    def is_great(choice: str) -> bool:\n        return len(choice) >= 2 * max(len(c) for c in choices)\n\n    great_choices = [c for c in choices if is_great(c)]\n    if len(great_choices) == 1:\n        return great_choices[0]\n    else:\n        return 'C'"
    },
    {
        "number": 716,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    airports = [0] * (n + 1)\n    companies = [0] * (n + 1)\n    for i in range(1, n + 1):\n        airports[i] = i\n        companies[i] = int(stdin[i - 1])\n\n    def min_cost(start: int, end: int) -> int:\n        if start == end:\n            return 0\n        if companies[start] == companies[end]:\n            return min_cost(start + 1, end)\n        return min(min_cost(start + 1, end), abs(start - end))\n\n    return str(min_cost(a, b))"
    },
    {
        "number": 717,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    doctors = []\n    for i in range(n):\n        s, d = map(int, stdin.split()[1:3])\n        doctors.append((s, d))\n    doctors.sort(key=lambda x: x[0])\n    min_day = doctors[-1][0]\n    return str(min_day)"
    },
    {
        "number": 718,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    b = 1\n    while True:\n        if a + b * 1000000000 <= 0:\n            break\n        if str(a + b * 1000000000).count('8') > 0:\n            break\n        b += 1\n    return str(b)"
    },
    {
        "number": 719,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    if k < 1 or k > 10000:\n        return \"Invalid input\"\n\n    perfect_numbers = [19, 28]\n    for i in range(2, 10000):\n        if sum(int(digit) for digit in str(i)) == 10:\n            perfect_numbers.append(i)\n            if len(perfect_numbers) == k:\n                break\n\n    return str(perfect_numbers[k - 1])"
    },
    {
        "number": 720,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[1:3])\n        pairs.append((a, b))\n    pairs.sort()\n    max_draws = 0\n    current_score = 0\n    for a, b in pairs:\n        if a == b:\n            max_draws += 1\n        else:\n            if current_score == 0:\n                max_draws += 1\n            current_score = a + b\n    return str(max_draws)"
    },
    {
        "number": 721,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m = int(stdin.split()[2])\n\n    hooks = [True] * n\n    min_price = float('inf')\n    min_hook = -1\n\n    for i in range(n):\n        if hooks[i]:\n            if a[i] < min_price:\n                min_price = a[i]\n                min_hook = i\n\n    if min_hook == -1:\n        return str(-d * m)\n    else:\n        return str(min_price * m)"
    },
    {
        "number": 722,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    abbreviations = stdin.split()[1:]\n    years = []\n\n    for abbreviation in abbreviations:\n        year = int(abbreviation[-2:])\n        years.append(year)\n\n    return \" \".join(map(str, sorted(set(years))))"
    },
    {
        "number": 724,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    points = list(map(int, stdin.split()))\n\n    def diameter(points):\n        if len(points) == 1:\n            return 0\n        max_diameter = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                max_diameter = max(max_diameter, abs(points[i] - points[j]))\n        return max_diameter\n\n    min_points = 0\n    max_diameter = diameter(points)\n\n    while max_diameter > d:\n        min_points += 1\n        max_diameter = diameter(points[:min_points])\n\n    return str(min_points)"
    },
    {
        "number": 725,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    matrix = []\n    for _ in range(n):\n        row = list(stdin.split()[1])\n        matrix.append(row)\n\n    black_and_white = True\n    for row in matrix:\n        if 'W' in row or 'B' in row or 'G' in row:\n            black_and_white = False\n            break\n\n    if black_and_white:\n        return \"#Black&White\"\n    else:\n        return \"#Color\""
    },
    {
        "number": 726,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    x.sort()\n    count = 0\n    for i in range(n):\n        if i == 0 or x[i] - x[i - 1]!= d:\n            count += 1\n    return str(count)"
    },
    {
        "number": 727,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    while arr:\n        max_len = 0\n        left = 0\n        for i in range(len(arr)):\n            if arr[i] == arr[i + 1]:\n                max_len = max(max_len, i - left + 1)\n            else:\n                left = i + 1\n        arr = arr[max_len:]\n        count += max_len\n\n    return str(count)"
    },
    {
        "number": 728,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [a[i-1] for i in range(1, n+1)]\n    a.append(0)\n    a.sort(reverse=True)\n    bribe = 0\n    for i in range(1, n):\n        bribe += a[i]\n        if bribe > a[0]:\n            break\n    return str(bribe)"
    },
    {
        "number": 729,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    \n    diverse = True\n    for i in range(n):\n        count = s.count(s[i])\n        if count > n // 2:\n            diverse = False\n            break\n    \n    if diverse:\n        return \"YES\\n\" + s\n    else:\n        return \"NO\\n\""
    },
    {
        "number": 730,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    bus = [['.' for _ in range(35)] for _ in range(4)]\n    driver = 'D'\n\n    for i in range(k):\n        bus[3][i] = 'O'\n\n    for i in range(4):\n        bus[i][k] = 'O'\n\n    for i in range(4):\n        bus[i][34 - k] = 'O'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'O'\n\n    for i in range(4):\n        bus[3][i] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[i][k] = '#'\n\n    for i in range(4):\n        bus[i][34 - k] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[3][i] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[i][k] = 'D'\n\n    for i in range(4):\n        bus[i][34 - k] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[3][i] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[i][k] = '#'\n\n    for i in range(4):\n        bus[i][34 - k] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[3][i] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[i][k] = 'D'\n\n    for i in range(4):\n        bus[i][34 - k] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[3][i] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[i][k] = '#'\n\n    for i in range(4):\n        bus[i][34 - k] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[3][i] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[i][k] = 'D'\n\n    for i in range(4):\n        bus[i][34 - k] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[3][i] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[i][k] = '#'\n\n    for i in range(4):\n        bus[i][34 - k] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[3][i] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[i][k] = 'D'\n\n    for i in range(4):\n        bus[i][34 - k] = 'D'\n\n    for i in range(4):\n        bus[3][34 - k + i] = 'D'\n\n    for i in range(4):\n        bus[3][i] = '#'\n\n    for i in range(4):\n        bus[3][34 - k + i] = '#'\n\n    for i in range(4):\n        bus[i][k] = '#'\n\n    for i in range(4):\n        bus[i][34 - k] = '#'\n\n    for i in range(4"
    },
    {
        "number": 731,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    sequence = [m]\n    cost = 0\n\n    while sequence[-1] < w:\n        sequence.append(sequence[-1] + k)\n        cost += S(sequence[-1])\n\n    return str(len(sequence))\n\ndef"
    },
    {
        "number": 732,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        if str(i).count('4') == 1 and str(i).count('7') == 1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 733,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    red_count = 0\n    pink_count = 0\n    for i in range(a, b + 1):\n        if i % x == 0:\n            red_count += 1\n        if i % y == 0:\n            pink_count += 1\n    return str(red_count + pink_count)"
    },
    {
        "number": 734,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_blocks(height: int, stack: List[int]) -> int:\n        max_blocks = 0\n        for i in range(height):\n            max_blocks = max(max_blocks, stack[i])\n        return max_blocks\n\n    def max_blocks_helper(height: int, stack: List[int]) -> int:\n        if height == 0:\n            return 0\n        max_blocks = max_blocks_helper(height - 1, stack)\n        max_blocks = max(max_blocks, stack[height - 1])\n        return max_blocks\n\n    max_blocks_top = max_blocks_helper(n, a)\n    max_blocks_side = max_blocks_helper(m, a)\n\n    return str(max(max_blocks_top, max_blocks_side))\n"
    },
    {
        "number": 735,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def reverse_segment(l: int, r: int) -> None:\n        nonlocal a\n        a[l], a[r] = a[r], a[l]\n\n    def is_sorted(a: List[int]) -> bool:\n        return all(a[i] <= a[i + 1] for i in range(len(a) - 1))\n\n    def find_reverse_segment(a: List[int]) -> Tuple[int, int]:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] > a[j]:\n                    return i, j\n        return -1, -1\n\n    def find_reverse_segment_by_binary_search(a: List[int]) -> Tuple[int, int]:\n        left, right = 0, len(a) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if is_sorted(a[:mid]):\n                left = mid\n            else:\n                right = mid\n        return left, left\n\n    if is_sorted(a):\n        print(\"yes\")\n        print(1, len(a))\n    else:\n        reverse_segment(*find_reverse_segment(a))\n        print(\"yes\")\n        print(1, len(a))"
    },
    {
        "number": 736,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n % m!= 0:\n        return -1\n    steps = 0\n    while n > 0:\n        steps += 1\n        n -= 1\n    return str(steps)"
    },
    {
        "number": 737,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    perimeter = 0\n    for i in range(1, N+1):\n        perimeter += 2*i\n    return str(perimeter)"
    },
    {
        "number": 738,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def is_collinear(a: int, b: int, c: int) -> bool:\n        return gcd(gcd(a, b), c) > 1\n\n    def count_triangles(a: int, b: int, c: int, d: int) -> int:\n        count = 0\n        for i in range(a, b + 1):\n            for j in range(i, c + 1):\n                for k in range(j, d + 1):\n                    if not is_collinear(a, b, c) and not is_collinear(a, b, d) and not is_collinear(a, c, d) and not is_collinear(b, c, d):\n                        count += 1\n        return count\n\n    def main() -> None:\n        a, b, c, d = map(int, stdin.split())\n        result = count_triangles(a, b, c, d)\n        print(result)\n\n    main()\n"
    },
    {
        "number": 739,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    s = A + B * L\n    result = 0\n    for i in range(L):\n        result = (result * 10 + s) % M\n    return str(result)"
    },
    {
        "number": 740,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n    washing_machines = [0] * n_1\n    drying_machines = [0] * n_2\n    folding_machines = [0] * n_3\n\n    for i in range(k):\n        washing_machines[i % n_1] += t_1\n        drying_machines[i % n_2] += t_2\n        folding_machines[i % n_3] += t_3\n\n    min_time = min(washing_machines) + min(drying_machines) + min(folding_machines)\n\n    return str(min_time)"
    },
    {
        "number": 741,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def insert_x(a: list, x: int) -> list:\n        for i in range(len(a)):\n            if a[i] < x:\n                a.insert(i, x)\n                return a\n        a.append(x)\n        return a\n\n    def max_time(a: list) -> int:\n        time = 0\n        for i in range(len(a)):\n            if a[i] > 0:\n                time += a[i] - i\n        return time\n\n    def max_time_with_x(a: list, x: int) -> int:\n        time = 0\n        for i in range(len(a)):\n            if a[i] > 0:\n                time += a[i] - i\n            if a[i] == x:\n                time += x - i\n        return time\n\n    for x in range(1, M + 1):\n        a = insert_x(a, x)\n        max_time_with_x_x = max_time_with_x(a, x)\n        if max_time_with_x_x > max_time(a):\n            max_time_with_x_x = max_time(a)\n        max_time_without_x = max_time(a)\n        if max_time_with_x_x > max_time_without_x:\n            max_time_with_x_x = max_time_without_x\n\n    return str(max_time_with_x_x)\n"
    },
    {
        "number": 742,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        b = list(map(int, stdin.split()[2:2+n]))\n        b.sort()\n        if b == [1] * n:\n            print(-1)\n        else:\n            a = [1] * 2 * n\n            for i in range(n):\n                a[2 * i] = b[i]\n                a[2 * i + 1] = min(b[i], b[i+1])\n            print(*a)"
    },
    {
        "number": 743,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:]))\n\n    # Sort the array in ascending order\n    x.sort()\n\n    # Initialize the sum\n    sum_ = 0\n\n    # Perform the operations\n    for i in range(n - 1):\n        if x[i] > x[i + 1]:\n            x[i], x[i + 1] = x[i + 1], x[i]\n            sum_ += x[i] - x[i + 1]\n\n    return str(sum_)"
    },
    {
        "number": 744,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = ''.join(sorted(s))\n    count = 0\n    for i in range(n):\n        if s[i] == 'S':\n            count += 1\n        else:\n            count -= 1\n        if count > 0:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 745,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n * (n - 1) // 2:\n        return \"0\"\n\n    def count_ways(board, row, col, count):\n        if row == n:\n            return 1\n\n        if board[row][col] == 1:\n            return 0\n\n        board[row][col] = 1\n\n        count_ways_attacked = 0\n        for i in range(n):\n            if i!= row and board[i][col] == 0:\n                count_ways_attacked += count_ways(board, i, col, count)\n\n        count_ways_empty = 0\n        for i in range(n):\n            if board[row][i] == 0:\n                count_ways_empty += count_ways(board, row, i, count)\n\n        return (count_ways_attacked + count_ways_empty) % 998244353\n\n    return str(count_ways(\n        [[0] * n for _ in range(n)], 0, 0, 0))"
    },
    {
        "number": 746,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    n = int(stdin.split()[1])\n    taxi_coordinates = []\n    for _ in range(n):\n        x, y, v = map(int, stdin.split())\n        taxi_coordinates.append((x, y, v))\n\n    taxi_coordinates.sort(key=lambda x: (x[0], x[1]))\n\n    min_time = float('inf')\n    for i in range(n):\n        x, y, v = taxi_coordinates[i]\n        if x == a and y == b:\n            min_time = min(min_time, v)\n        else:\n            min_time = min(min_time, abs(x - a) / v)\n\n    return str(min_time)"
    },
    {
        "number": 747,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    candies = []\n    for _ in range(n):\n        t, h, m = map(int, stdin.split())\n        candies.append((t, h, m))\n\n    candies.sort(key=lambda x: (-x[1], x[0]))\n\n    max_height = 0\n    max_count = 0\n    for i in range(n):\n        if candies[i][0] == candies[i - 1][0]:\n            continue\n        if max_height + candies[i][1] <= x:\n            max_height += candies[i][1]\n            max_count += 1\n        else:\n            break\n\n    return str(max_count)"
    },
    {
        "number": 748,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    def is_valid(a, b, c):\n        return a < b < c and a % b == 0 and b % c == 0\n\n    def find_partition(sequence):\n        groups = []\n        current_group = []\n        for num in sequence:\n            if len(current_group) == 3:\n                groups.append(current_group)\n                current_group = []\n            current_group.append(num)\n\n        if len(current_group) == 3:\n            groups.append(current_group)\n\n        return groups\n\n    def find_groups(groups):\n        result = []\n        for group in groups:\n            if len(group) == 3:\n                result.append(group)\n        return result\n\n    def find_partitions(groups):\n        result = []\n        for group in groups:\n            if len(group) == 3:\n                result.append(group)\n        return result\n\n    def find_partitions_with_sum(groups, target_sum):\n        result = []\n        for group in groups:\n            if len(group) == 3:\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length(groups, target_sum, target_length):\n        result = []\n        for group in groups:\n            if len(group) == target_length:\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length_and_elements(groups, target_sum, target_length, elements):\n        result = []\n        for group in groups:\n            if len(group) == target_length and all(num in elements for num in group):\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length_and_elements_and_order(groups, target_sum, target_length, elements, order):\n        result = []\n        for group in groups:\n            if len(group) == target_length and all(num in elements for num in group) and group[order] == elements[order]:\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length_and_elements_and_order_and_position(groups, target_sum, target_length, elements, order, position):\n        result = []\n        for group in groups:\n            if len(group) == target_length and all(num in elements for num in group) and group[order] == elements[order] and group[position] == elements[position]:\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length_and_elements_and_order_and_position_and_position(groups, target_sum, target_length, elements, order, position, position2):\n        result = []\n        for group in groups:\n            if len(group) == target_length and all(num in elements for num in group) and group[order] == elements[order] and group[position] == elements[position] and group[position2] == elements[position2]:\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length_and_elements_and_order_and_position_and_position_and_position(groups, target_sum, target_length, elements, order, position, position2, position3):\n        result = []\n        for group in groups:\n            if len(group) == target_length and all(num in elements for num in group) and group[order] == elements[order] and group[position] == elements[position] and group[position2] == elements[position2] and group[position3] == elements[position3]:\n                current_sum = sum(group)\n                if current_sum == target_sum:\n                    result.append(group)\n        return result\n\n    def find_partitions_with_sum_and_length_and_elements_and_order_and_position_and_position_and_position_and_position(groups, target_sum, target_"
    },
    {
        "number": 749,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    min_k = 1\n    max_k = len(s)\n    while min_k <= max_k:\n        count = 0\n        for i in range(len(s) - min_k + 1):\n            if s[i:i + min_k].count(s[i]) == min_k:\n                count += 1\n        if count > 0:\n            break\n        min_k += 1\n    return str(min_k)"
    },
    {
        "number": 750,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    red_sheets = 2 * n\n    green_sheets = 3 * n\n    blue_sheets = 5 * n\n    notebooks = [red_sheets, green_sheets, blue_sheets]\n    min_notebooks = min(notebooks)\n    return str(min_notebooks)"
    },
    {
        "number": 751,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def can_fit(group_size, bus_size):\n        return group_size <= bus_size\n\n    def buses_needed(groups, bus_size):\n        buses = 0\n        for i in range(len(groups)):\n            group_size = groups[i]\n            if can_fit(group_size, bus_size):\n                buses += 1\n                bus_size -= group_size\n            else:\n                bus_size = 0\n        return buses\n\n    return str(buses_needed(a, m))"
    },
    {
        "number": 752,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [line.split()[0] for line in stdin.split('\\n')[1:n+1]]\n    b = [line.split()[0] for line in stdin.split('\\n')[n+1:2*n+1]]\n    \n    if a == b:\n        return \"0\"\n    \n    a_set = set(a)\n    b_set = set(b)\n    \n    if a_set == b_set:\n        return \"0\"\n    \n    a_set = set(a)\n    b_set = set(b)\n    \n    for i in range(len(a)):\n        if a_set.issuperset(b_set):\n            a_set.remove(a[i])\n            b_set.remove(b[i])\n            a_set.add(a[i].replace(a[i][0], a[i][0].upper()))\n            b_set.add(b[i].replace(b[i][0], b[i][0].upper()))\n    \n    if a_set == b_set:\n        return \"0\"\n    \n    return str(min(len(a_set), len(b_set)))"
    },
    {
        "number": 753,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    screen_size = a * b\n    movie_size = c * d\n    empty_space = screen_size - movie_size\n    p, q = divmod(empty_space, screen_size)\n    return f\"{p}/{q}\""
    },
    {
        "number": 754,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    colors = [s[i] for i in range(n)]\n    colors.append(colors[0])\n    colors.sort()\n    count = 0\n    for i in range(1, n):\n        if colors[i]!= colors[i - 1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 755,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    steps = 0\n    while x > 0:\n        steps += x\n        x -= 1\n    return str(steps)"
    },
    {
        "number": 756,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    boring_count = 0\n    interesting_count = 0\n    for i in range(n):\n        if t[i] == 15:\n            boring_count += 1\n            if boring_count == 15:\n                return \"0\"\n        else:\n            boring_count = 0\n            interesting_count += 1\n    return str(interesting_count * 90)"
    },
    {
        "number": 757,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_plugged(i: int) -> bool:\n        return a[i] == k or (a[i] > 0 and is_plugged(a[i] - 1))\n\n    plugged_devices = 0\n    for i in range(n):\n        if is_plugged(i):\n            plugged_devices += 1\n            if plugged_devices == m:\n                return str(i + 1)\n\n    return -1"
    },
    {
        "number": 758,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    stack = []\n    blue_count = 0\n    red_count = 0\n\n    for i in range(n):\n        if s[i] == 'R':\n            red_count += 1\n            stack.append(i)\n        elif s[i] == 'B':\n            blue_count += 1\n\n    if blue_count == 0:\n        return \"0\"\n\n    max_operations = 0\n    while red_count > 0:\n        max_operations += 1\n        if stack:\n            top_index = stack.pop()\n            if s[top_index] == 'B':\n                s[top_index] = 'R'\n                red_count -= 1\n                blue_count += 1\n            else:\n                stack.append(top_index)\n        else:\n            break\n\n    return str(max_operations)"
    },
    {
        "number": 759,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split())\n    H, D, C, N = map(int, stdin.split())\n\n    def calculate_buns(time: int) -> int:\n        if time < 20:\n            return 0\n        else:\n            return (time - 20) // 15 * C\n\n    def calculate_food(time: int) -> int:\n        if time < 20:\n            return 0\n        else:\n            return (time - 20) // 15 * D\n\n    def calculate_hunger(time: int) -> int:\n        buns = calculate_buns(time)\n        food = calculate_food(time)\n        return H + food\n\n    def calculate_cost(time: int) -> int:\n        buns = calculate_buns(time)\n        food = calculate_food(time)\n        return buns * C + food * N\n\n    def calculate_profit(time: int) -> int:\n        hunger = calculate_hunger(time)\n        if hunger <= 0:\n            return 0\n        else:\n            return calculate_cost(time) - calculate_cost(time - 1)\n\n    def calculate_profit_for_time(time: int) -> int:\n        profit = calculate_profit(time)\n        if time == 23:\n            return profit\n        else:\n            return profit + calculate_profit_for_time(time + 1)\n\n    profit = calculate_profit_for_time(hh * 60 + mm)\n    return f\"{profit:.3f}\""
    },
    {
        "number": 760,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = s + k * 'a'\n    n = len(s)\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 2, n + 1):\n            if s[i:j] == s[i:j][::-1]:\n                max_length = max(max_length, j - i)\n    return str(max_length)"
    },
    {
        "number": 761,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    slimes = list(map(int, stdin.split()[1:]))\n\n    for i in range(n - 1):\n        slimes[i] -= slimes[i + 1]\n\n    return str(max(slimes))"
    },
    {
        "number": 762,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, B = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def cut(a: list, start: int, end: int) -> int:\n        even_count = 0\n        odd_count = 0\n        for i in range(start, end):\n            if a[i] % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n        return even_count - odd_count\n\n    def max_cuts(a: list, B: int) -> int:\n        cuts = 0\n        current_cut = 0\n        for i in range(len(a)):\n            current_cut += cut(a, current_cut, i)\n            if current_cut > B:\n                current_cut = i + 1\n            cuts = max(cuts, current_cut)\n        return cuts\n\n    return str(max_cuts(a, B))\n"
    },
    {
        "number": 763,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [0] + a\n    a.sort()\n    x = a[0]\n    min_units = 0\n    for i in range(1, n):\n        if a[i] - a[i - 1] > 1:\n            min_units += (a[i] - a[i - 1]) // 2 + 1\n        x = a[i]\n    return str(min_units)"
    },
    {
        "number": 764,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, y = map(int, stdin.split())\n    y = bin(y)[2:].zfill(n)\n    k = 0\n    while True:\n        x = y\n        for _ in range(k):\n            x = x[::-1]\n        if x == y:\n            break\n        k += 1\n    return str(k)"
    },
    {
        "number": 765,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s, q = map(int, stdin.split())\n    if s > t:\n        return \"1\"\n    return str(t // (s - 1))"
    },
    {
        "number": 766,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    adorable = True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                adorable = False\n                break\n\n    if adorable:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 767,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split())\n    points = list(map(int, stdin.split()))\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(points[i] - points[j]) >= z:\n                pairs.append((i, j))\n\n    return str(len(pairs))"
    },
    {
        "number": 768,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_likes(friends: List[str], item: int) -> int:\n        return sum(1 for friend in friends if friend[item] == 'Y')\n\n    friends, items, threshold = map(int, stdin.split())\n    likes = [list(stdin.split()[i:i+items]) for i in range(0, len(stdin.split()), items)]\n\n    result = sum(count_likes(friends, i) >= threshold for i in range(items))\n\n    return str(result)"
    },
    {
        "number": 769,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    decimal_notation = str(a) + '.' + str(b)\n    index = decimal_notation.find(str(c))\n    if index == -1:\n        return -1\n    else:\n        return str(index + 1)"
    },
    {
        "number": 770,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    state = list(map(int, stdin.split()[1:]))\n\n    def move_to_next(index: int) -> int:\n        if index == n - 1:\n            return 0\n        return index + 1\n\n    def move_to_previous(index: int) -> int:\n        if index == 0:\n            return n - 1\n        return index - 1\n\n    def move_to_letter(index: int) -> int:\n        if state[index] == 1:\n            return 0\n        return 1\n\n    def move_to_list() -> int:\n        return 2\n\n    operations = [move_to_letter(i) for i in range(n) if state[i] == 0]\n    operations.append(move_to_list())\n    operations.append(move_to_letter(n - 1))\n\n    return str(min(operations))\n"
    },
    {
        "number": 771,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_divisible(a, b):\n        return lcm(a, b) % m == 0\n\n    selected = set()\n    for i in range(k):\n        min_a = min(a)\n        for a_i in a:\n            if a_i == min_a:\n                selected.add(a_i)\n                break\n        else:\n            return \"No\"\n\n    if len(selected)!= k:\n        return \"No\"\n\n    for a_i in a:\n        if a_i not in selected:\n            for b_i in selected:\n                if is_divisible(a_i, b_i):\n                    selected.remove(b_i)\n                    break\n            else:\n                return \"No\"\n\n    return \"Yes\\n\" + \" \".join(map(str, sorted(selected)))\n"
    },
    {
        "number": 772,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    grid = [[int(x) for x in row.split()] for row in stdin.split('\\n')]\n    result = []\n    for row in grid:\n        row_result = []\n        for light in row:\n            if light == 1:\n                row_result.append('1')\n            else:\n                row_result.append('0')\n        result.append(''.join(row_result))\n    return '\\n'.join(result)"
    },
    {
        "number": 773,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    facts = []\n    for _ in range(q):\n        t, l, r, v = map(int, stdin.split())\n        facts.append((t, l, r, v))\n\n    def count_occurrences(arr, x):\n        return arr.count(x)\n\n    def count_occurrences_in_range(arr, l, r):\n        return sum(1 for x in arr if l <= x <= r)\n\n    def count_occurrences_in_range_and_greater_than_value(arr, l, r, value):\n        return sum(1 for x in arr if l <= x <= r and x > value)\n\n    def count_occurrences_in_range_and_less_than_value(arr, l, r, value):\n        return sum(1 for x in arr if l <= x <= r and x < value)\n\n    def count_occurrences_in_range_and_between_values(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l <= x <= r and value1 <= x <= value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l <= x <= r and value1 < x <= value2)\n\n    def count_occurrences_in_range_and_between_values_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x <= r and value1 <= x < value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x <= r and value1 < x < value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l <= x < r and value1 <= x <= value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x < r and value1 <= x < value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x < r and value1 < x <= value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_inclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l <= x <= r and value1 <= x < value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_exclusive_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x < r and value1 < x <= value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_inclusive_inclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l <= x < r and value1 <= x <= value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_inclusive_exclusive_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x <= r and value1 < x < value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_inclusive_inclusive_inclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l <= x <= r and value1 <= x <= value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_inclusive_inclusive_exclusive_exclusive(arr, l, r, value1, value2):\n        return sum(1 for x in arr if l < x < r and value1 < x < value2)\n\n    def count_occurrences_in_range_and_between_values_inclusive_exclusive_inclusive_inclusive_inclusive_inclusive_inclusive(arr, l, r, value1,"
    },
    {
        "number": 774,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    a, b = 0, 1\n    min_diff = float('inf')\n    min_denom = float('inf')\n    min_num = float('inf')\n\n    while b <= n:\n        diff = abs(x * a + y * b - x * b)\n        if diff < min_diff:\n            min_diff = diff\n            min_denom = b\n            min_num = a\n        a += 1\n        b += 1\n\n    return f\"{min_num}/{min_denom}\""
    },
    {
        "number": 775,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    holes = list(map(int, stdin.split()))\n    cups = list(range(1, n+1))\n    bone_position = 1\n\n    for _ in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u]\n\n    for i in range(k):\n        u, v = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        if u == v:\n            continue\n        cups[u], cups[v] = cups[v], cups[u"
    },
    {
        "number": 776,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    mouse_prices = []\n    for _ in range(m):\n        price, port = map(int, stdin.split())\n        mouse_prices.append((price, port))\n\n    usb_computers = a\n    ps2_computers = b\n    both_computers = c\n\n    usb_prices = [price for price, port in mouse_prices if port == \"USB\"]\n    ps2_prices = [price for price, port in mouse_prices if port == \"PS/2\"]\n\n    usb_prices.sort(reverse=True)\n    ps2_prices.sort(reverse=True)\n\n    max_computers = min(usb_computers, ps2_computers, both_computers)\n    total_cost = 0\n\n    for i in range(max_computers):\n        total_cost += usb_prices[i] + ps2_prices[i]\n\n    return f\"{max_computers} {total_cost}\""
    },
    {
        "number": 777,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    booklet = list(s)\n    booklet.sort()\n    result = 1\n    for i in range(len(booklet)):\n        if i == 0 or booklet[i]!= booklet[i-1]:\n            result *= 26\n    return str(result)"
    },
    {
        "number": 778,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    blocks = []\n    for _ in range(n):\n        blocks.append(list(map(int, stdin.split())))\n\n    def is_valid(blocks: List[List[int]]) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if blocks[i][j] > blocks[i][j - 1]:\n                    return False\n        return True\n\n    def count_ways(blocks: List[List[int]]) -> int:\n        if not is_valid(blocks):\n            return 0\n\n        ways = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                ways *= 2\n\n        return ways\n\n    def count_ways_with_requirements(blocks: List[List[int]]) -> int:\n        if not is_valid(blocks):\n            return 0\n\n        ways = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                ways *= 2\n\n        for x, sign, y in additional_requirements:\n            if sign == \"=\":\n                if blocks[x - 1][y - 1]!= blocks[x - 1][y]:\n                    return 0\n            elif sign == \"<\":\n                if blocks[x - 1][y - 1] >= blocks[x - 1][y]:\n                    return 0\n            elif sign == \">\":\n                if blocks[x - 1][y - 1] <= blocks[x - 1][y]:\n                    return 0\n            elif sign == \"<=\":\n                if blocks[x - 1][y - 1] > blocks[x - 1][y]:\n                    return 0\n            elif sign == \">=\":\n                if blocks[x - 1][y - 1] < blocks[x - 1][y]:\n                    return 0\n\n        return ways\n\n    additional_requirements = []\n    for _ in range(k):\n        x, sign, y = map(int, stdin.split())\n        additional_requirements.append((x, sign, y))\n\n    return str(count_ways_with_requirements(blocks))\n"
    },
    {
        "number": 779,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    else:\n        team_leaders = [1]\n        while len(team_leaders) < n:\n            team_leaders.append(len(team_leaders) + 1)\n        team_leaders.sort(reverse=True)\n        team_leader_count = len(team_leaders)\n        team_leader_sum = sum(team_leaders)\n        team_leader_sum_per_employee = team_leader_sum // n\n        team_leader_sum_left = team_leader_sum % n\n        team_leader_count_per_employee = team_leader_count // n\n        team_leader_count_left = team_leader_count % n\n        result = 0\n        for i in range(team_leader_count_per_employee):\n            result += team_leader_sum_per_employee\n        if team_leader_count_left > 0:\n            result += team_leader_sum_left\n        return str(result)"
    },
    {
        "number": 780,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [[-1] * 10 for _ in range(10)]\n    for i in range(1, 10):\n        dp[0][i] = 1\n    for i in range(1, n):\n        for j in range(1, 10):\n            if s[i] == '0':\n                dp[j][i] = dp[j][i - 1]\n            else:\n                dp[j][i] = min(dp[j][i - 1], dp[j - 1][i]) + 1\n    result = []\n    for i in range(10):\n        for j in range(10):\n            if dp[i][j] == -1:\n                result.append(-1)\n            else:\n                result.append(dp[i][j])\n    return''.join(map(str, result))"
    },
    {
        "number": 781,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line) for line in stdin.split('\\n')]\n    for i in range(8):\n        for j in range(8):\n            if board[i][j] == 'W':\n                board[i][j] = 'B'\n            else:\n                board[i][j] = 'W'\n    for i in range(8):\n        for j in range(8):\n            if j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j+1]\n    for i in range(8):\n        for j in range(8):\n            if i == 7 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i+1][j]\n    for i in range(8):\n        for j in range(8):\n            if i == 7 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i+1][j+1]\n    for i in range(8):\n        for j in range(8):\n            if i == 7 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i+1][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j+1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j+1]\n    for i in range(8):\n        for j in range(8):\n            if i == 7 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i+1][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 7 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i+1][j+1]\n    for i in range(8):\n        for j in range(8):\n            if i == 7 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i+1][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j+1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 0:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j-1]\n    for i in range(8):\n        for j in range(8):\n            if i == 0 and j == 7:\n                board[i][j] = 'W'\n            else:\n                board[i][j] = board[i-1][j+1]\n    for i in range(8):\n        for"
    },
    {
        "number": 782,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, *s = map(int, stdin.split())\n    s = set(s)\n    n = len(s)\n    if n == 1:\n        return str(n)\n    for i in range(1, n):\n        if s.difference({s[i] - 1, s[i] + 1}):\n            return str(n)\n    return -1"
    },
    {
        "number": 783,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n\n    luxurious_houses = []\n    for i in range(n):\n        if i == 0 or heights[i] > heights[i - 1]:\n            luxurious_houses.append(i)\n\n    result = [0] * n\n    for i in range(n):\n        if i in luxurious_houses:\n            result[i] = 0\n        else:\n            result[i] = max(heights[j] - heights[i] for j in range(i + 1, n))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 784,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"YES\\n1\\n\" + \" \".join(map(str, [a]))\n\n    def transform(x: int) -> int:\n        if x == 0:\n            return 0\n        elif x % 2 == 0:\n            return transform(x // 2) * 2\n        else:\n            return transform(x // 2) * 2 + 1\n\n    def backtrack(x: int, k: int, sequence: list) -> None:\n        if k == 0:\n            if x == b:\n                print(\"YES\\n\" + str(len(sequence)) + \"\\n\" + \" \".join(map(str, sequence)))\n            return\n        if x == 0:\n            return\n        if x % 2 == 0:\n            backtrack(x // 2, k - 1, sequence + [x])\n        else:\n            backtrack(x // 2, k - 1, sequence + [x])\n            backtrack(x // 2, k - 1, sequence + [x + 1])\n\n    sequence = [a]\n    backtrack(transform(a), 5, sequence)\n    return \"\""
    },
    {
        "number": 785,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    a *= n\n    b *= n\n    if a >= 6 * n:\n        a = 6 * n\n    if b >= 6 * n:\n        b = 6 * n\n    return str(a) + \" \" + str(b)"
    },
    {
        "number": 786,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    contests = [tuple(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def is_in_first_division(rating: int) -> bool:\n        return 1900 <= rating\n\n    def is_in_second_division(rating: int) -> bool:\n        return 1899 <= rating\n\n    def get_rating_after_contests(rating: int, contests: List[Tuple[int, int]]) -> int:\n        for contest_rating, contest_division in contests:\n            rating += contest_rating\n            if is_in_first_division(rating):\n                rating -= contest_rating\n            elif is_in_second_division(rating):\n                rating += contest_rating\n        return rating\n\n    max_rating = 0\n    for rating, division in contests:\n        max_rating = max(max_rating, get_rating_after_contests(rating, contests[:i] + contests[i + 1:]))\n\n    if max_rating == 0:\n        return \"Infinity\"\n    elif max_rating == 1907:\n        return \"1907\"\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 787,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(int, stdin.split())\n    q = list(q)\n\n    def is_beautiful(s: str) -> bool:\n        return s == q\n\n    def is_distinct(s: str) -> bool:\n        return len(set(s)) == len(s)\n\n    def is_beautiful_sequence(s: str) -> bool:\n        return is_beautiful(s) and is_distinct(s)\n\n    def find_beautiful_sequence(start: str) -> str:\n        if is_beautiful_sequence(start):\n            return start\n        for i in range(ord('a'), ord('z') + 1):\n            new_start = start + chr(i)\n            if is_beautiful_sequence(new_start):\n                return new_start\n        return \"\"\n\n    beautiful_sequence = find_beautiful_sequence(\"\")\n    if beautiful_sequence:\n        print(\"YES\")\n        for s in beautiful_sequence:\n            print(s)\n    else:\n        print(\"NO\")"
    },
    {
        "number": 788,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to a list of characters\n    input_list = list(stdin)\n\n    # Check if the first character is 'A'\n    if input_list[0]!= 'A':\n        return \"Invalid input\"\n\n    # Convert the first character to an integer\n    first_char_int = ord(input_list[0]) - ord('A')\n\n    # Convert the remaining 6 digits to an integer\n    remaining_digits = int(input_list[1:])\n\n    # Calculate the sum of the first character and the remaining digits\n    sum_of_digits = first_char_int + remaining_digits\n\n    # Return the sum as a string\n    return str(sum_of_digits)"
    },
    {
        "number": 789,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    lucky_numbers = [num for num in range(10**9) if str(num).count('4') == 1 and str(num).count('7') == 1]\n    lucky_numbers.sort()\n    return str(lucky_numbers.index(n) + 1)"
    },
    {
        "number": 790,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    def dfs(i, energy):\n        if i == n:\n            return energy\n\n        max_energy = 0\n        for j in range(n):\n            if j!= i and j!= e[i]:\n                max_energy = max(max_energy, dfs(j, energy + a[j] - d[j]))\n\n        return max(max_energy, dfs(i + 1, energy + d[i]))\n\n    e = [i for i in range(n) if i!= n - 1]\n    return str(dfs(0, 0))\n"
    },
    {
        "number": 791,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cell_state = int(stdin.split()[1], 2)\n    cell_state += 1\n    count = 0\n    while cell_state!= 0:\n        count += 1\n        cell_state &= (cell_state - 1)\n    return str(count)"
    },
    {
        "number": 792,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def check_account(account: int) -> bool:\n        return account >= 0\n\n    def check_transactions(transactions: List[int]) -> bool:\n        for transaction in transactions:\n            if transaction > 0:\n                if account + transaction > d:\n                    return False\n            elif transaction < 0:\n                if account + transaction < 0:\n                    return False\n            else:\n                if not check_account(account):\n                    return False\n        return True\n\n    account = 0\n    days = 0\n\n    while days < n:\n        if a[days] == 0:\n            if not check_account(account):\n                return -1\n            days += 1\n        else:\n            transactions = [a[days]]\n            days += 1\n            while days < n and a[days] == 0:\n                transactions.append(a[days])\n                days += 1\n            if not check_transactions(transactions):\n                return -1\n            account += sum(transactions)\n\n    return days"
    },
    {
        "number": 793,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    S = list(map(int, stdin.split()))\n    T = list(map(int, stdin.split()))\n\n    MOD = 10**9 + 7\n\n    def subsequences(seq):\n        result = []\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq) + 1):\n                result.append(seq[i:j])\n        return result\n\n    def count_pairs(S, T):\n        count = 0\n        for s in subsequences(S):\n            for t in subsequences(T):\n                if s == t:\n                    count += 1\n        return count\n\n    result = count_pairs(S, T)\n    print(result % MOD)\n\n    return \"\"\n"
    },
    {
        "number": 794,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(a):\n        return sum(a[:n])!= sum(a[n:])\n\n    if is_valid(a):\n        return \" \".join(map(str, a))\n    else:\n        return \"-1\""
    },
    {
        "number": 795,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n+1):\n        for b in range(a, n+1):\n            c = n - a - b\n            if a**2 + b**2 == c**2:\n                count += 1\n    return str(count)"
    },
    {
        "number": 796,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def backtrack(i, j, num):\n        if num == k:\n            return 1\n        if i == 0:\n            return 0\n        if j == 0:\n            return 0\n\n        return (backtrack(i - 1, j, num) + backtrack(i, j - 1, num)) % MOD\n\n    return str(backtrack(n, n, 1))"
    },
    {
        "number": 797,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    g_0, x, y, z = map(int, stdin.split())\n\n    def matrix_multiply(a: list, b: list) -> list:\n        result = [[0] * len(b[0]) for _ in range(len(a))]\n        for i in range(len(a)):\n            for j in range(len(b[0])):\n                for k in range(len(b)):\n                    result[i][j] = (result[i][j] + a[i][k] * b[k][j]) % z\n        return result\n\n    def matrix_power(matrix: list, n: int) -> list:\n        if n == 1:\n            return matrix\n        elif n % 2 == 0:\n            half_power = matrix_power(matrix, n // 2)\n            return matrix_multiply(half_power, half_power)\n        else:\n            return matrix_multiply(matrix, matrix_power(matrix, n - 1))\n\n    def matrix_submatrix_sum(matrix: list, a: int, b: int, c: int, d: int) -> int:\n        submatrix = matrix[a - 1:a + c, b - 1:b + d]\n        return sum(sum(row) for row in submatrix)\n\n    def min_height_cell(matrix: list) -> tuple:\n        min_height = float('inf')\n        min_cell = None\n        for i in range(1, n - a + 1):\n            for j in range(1, m - b + 1):\n                height = matrix_submatrix_sum(matrix, i, 1, a, b)\n                if height < min_height:\n                    min_height = height\n                    min_cell = (i, j)\n        return min_cell\n\n    matrix = [[g_0 + (i - 1) * m + j - 1 for j in range(1, m + 1)] for i in range(1, n + 1)]\n    matrix = matrix_power(matrix, z - 2)\n    min_cell = min_height_cell(matrix)\n    return str(min_cell[0] * m + min_cell[1] - 1)"
    },
    {
        "number": 798,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a + b + c!= 6:\n        return \"Impossible\"\n\n    if a == 1 and b == 1 and c == 2:\n        return \"0 1 1\"\n\n    if a == 3 and b == 4 and c == 5:\n        return \"1 3 2\"\n\n    return \"Impossible\""
    },
    {
        "number": 799,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    S = 0\n    for i in range(n):\n        S += a[i]\n    return str(S)"
    },
    {
        "number": 800,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    mannequins = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        mannequins.append((x, y))\n    mannequins.sort(key=lambda x: (x[0], x[1]))\n    x_min, y_min = mannequins[0]\n    x_max, y_max = mannequins[-1]\n    angle = 0\n    for i in range(n):\n        x, y = mannequins[i]\n        if x < x_min:\n            x_min = x\n        if x > x_max:\n            x_max = x\n        if y < y_min:\n            y_min = y\n        if y > y_max:\n            y_max = y\n        angle = max(angle, abs(x_min - x) + abs(y_min - y))\n    return f\"{angle:.6f}\""
    },
    {
        "number": 801,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def mex(arr):\n        if len(arr) == 1:\n            return arr[0]\n        else:\n            return max(arr[0], arr[-1]) + mex(arr[1:-1])\n\n    mexes = [mex(arr) for arr in combinations(a, r=n)]\n    return str(max(mexes))"
    },
    {
        "number": 802,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    row = stdin.split()[1]\n    visited = [False] * n\n    visited[0] = True\n    count = 0\n    for i in range(1, n):\n        if row[i] == row[i - 1]:\n            count += 1\n            if count == 2:\n                return str(i)\n        else:\n            count = 1\n    return str(n)"
    },
    {
        "number": 803,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    hamsters = stdin.split()[1]\n    hamsters = [hamsters[i:i+n] for i in range(0, len(hamsters), n)]\n    hamsters = [hamsters[i] for sublist in hamsters for i in range(len(sublist))]\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'x']\n    hamsters = [hamsters[i] for i in range(len(hamsters)) if hamsters[i] == 'X']\n    hamsters = [hamsters[i] for i in range(len"
    },
    {
        "number": 804,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = set(s)\n    if len(s) < k:\n        return \"impossible\"\n    else:\n        return str(len(s) - k)"
    },
    {
        "number": 805,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[1:3])\n        segments.append((l, r))\n    segments.sort(key=lambda x: x[0])\n    dryer_length = 0\n    for i in range(n):\n        dryer_length += segments[i][1] - segments[i][0]\n    return str(dryer_length)"
    },
    {
        "number": 806,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    if n == 0:\n        return \"0\"\n\n    def backtrack(start, current_sum, count):\n        if current_sum % 3 == 0:\n            count += 1\n        if current_sum == 0:\n            return count\n        for i in range(start, n + 1):\n            if i < l or i > r:\n                continue\n            backtrack(i + 1, current_sum - i, count)\n        return count\n\n    count = backtrack(1, 0, 0)\n    return str((count % (10**9 + 7)))\n"
    },
    {
        "number": 807,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    def buy_barrel(x, c):\n        for i in range(n):\n            if x[i] >= c:\n                return i\n        return -1\n\n    def sell_barrel(x, c):\n        for i in range(n - 1, -1, -1):\n            if x[i] >= c:\n                return i\n        return -1\n\n    def lend_barrel(x, c):\n        for i in range(n):\n            if x[i] >= c:\n                return i\n        return -1\n\n    def borrow_barrel(x, c):\n        for i in range(n):\n            if x[i] >= c:\n                return i\n        return -1\n\n    def profit(x, c):\n        return x[sell_barrel(x, c)] - x[lend_barrel(x, c)]\n\n    def max_profit(x, c):\n        max_profit = 0\n        for i in range(n):\n            if x[i] >= c:\n                max_profit = max(max_profit, profit(x, c))\n        return max_profit\n\n    return str(max_profit(x, c))"
    },
    {
        "number": 808,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a, b = str(x).split('e')\n    a = int(a)\n    b = int(b)\n    if b == 0:\n        return f\"{a}E\"\n    elif a == 0:\n        return f\"{b}E\"\n    else:\n        return f\"{a}E{b}\""
    },
    {
        "number": 809,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n\n    if a + b!= n:\n        return \"NO\"\n\n    green_count = 0\n    black_count = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            green_count += 1\n        else:\n            black_count += 1\n\n        if green_count > k or black_count > k:\n            return \"NO\"\n\n    return \"GB\" * n"
    },
    {
        "number": 810,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    count = 0\n    for i in range(1, 10):\n        if i in [a, b]:\n            continue\n        for j in range(1, 10):\n            if j in [a, b]:\n                continue\n            if i + j == 10:\n                count += 1\n                if count == n:\n                    return str((10**9 + 7) % 1000000007)\n    return str((10**9 + 7) % 1000000007)"
    },
    {
        "number": 811,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    while a > 0:\n        hours += 1\n        a -= 1\n    return str(hours)"
    },
    {
        "number": 812,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = map(int, stdin.split())\n    b = list(b)\n\n    for i in range(1, n):\n        if b[i] - b[i - 1]!= b[i - 1] - b[i - 2]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1] - b[i]:\n            return -1\n\n    for i in range(1, n - 1):\n        if b[i] - b[i - 1]!= b[i + 1]"
    },
    {
        "number": 813,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    apples = list(map(int, stdin.split()))\n    apples.sort()\n    hamsters = [[] for _ in range(2)]\n    for apple in apples:\n        if apple in hamsters[0]:\n            hamsters[0].remove(apple)\n        elif apple in hamsters[1]:\n            hamsters[1].remove(apple)\n        else:\n            hamsters[0].append(apple)\n    return ''.join(map(str, hamsters[0] + hamsters[1]))"
    },
    {
        "number": 814,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    \n    # Calculate the height of each column\n    height = [0] * n\n    for i in range(n):\n        height[i] = sum(a[:i+1])\n    \n    # Calculate the height of each column after the gravity switch\n    height_after_switch = [0] * n\n    for i in range(n):\n        height_after_switch[i] = height[i] + sum(a[i+1:])\n    \n    # Print the result\n    return''.join(map(str, height_after_switch))"
    },
    {
        "number": 815,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V_1, V_2, V_3, V_m = map(int, stdin.split())\n\n    if V_1 > V_2 > V_3:\n        return \"-1\"\n\n    if V_1 > V_m:\n        return str(V_1)\n\n    if V_2 > V_m:\n        return str(V_2)\n\n    if V_3 > V_m:\n        return str(V_3)\n\n    return \"-1\""
    },
    {
        "number": 816,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 817,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    pairs = []\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            pairs.append((i, i + 1))\n    pairs.sort()\n    result = []\n    for pair in pairs:\n        left, right = pair\n        if left == 0:\n            result.append(right - left + 1)\n        else:\n            result.append(right - left + 1)\n            result.append(\"...\")\n            result.append(right - left + 1)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 818,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"-1\"\n    primes = [2, 3, 5, 7]\n    for prime in primes:\n        if n % prime == 0:\n            break\n    else:\n        return \"-1\"\n    return str(n // prime)"
    },
    {
        "number": 819,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def split_array(a, k):\n        if k == 1:\n            return [a]\n        mid = len(a) // 2\n        left = split_array(a[:mid], k - 1)\n        right = split_array(a[mid:], k - 1)\n        return left + right\n\n    def min_on_subsegment(a):\n        return min(a)\n\n    def max_of_min_on_subsegments(a):\n        return max(map(min_on_subsegment, split_array(a, k)))\n\n    return str(max_of_min_on_subsegments(a))"
    },
    {
        "number": 820,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    i = 0\n    j = 0\n    count = 0\n    while i < n and j < n:\n        if a[i] + a[j] <= m:\n            count += 1\n            i += 1\n            j += 1\n        elif a[i] + a[j] > m:\n            count += 1\n            i += 1\n        else:\n            j += 1\n    return str(count)"
    },
    {
        "number": 821,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n\n    if t_1 + v_1 + t_2 + v_2 <= s:\n        return \"First\"\n    elif t_1 + v_1 + t_2 + v_2 > s:\n        return \"Second\"\n    else:\n        return \"Friendship\""
    },
    {
        "number": 822,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    min_kills = 0\n    for i in range(1, z + 1, m):\n        min_kills += n // i\n    return str(min_kills)"
    },
    {
        "number": 823,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    spiral = [(0, 0), (1, 0), (1, 1), (1, -1), (-1, -1), (-1, 1), (2, 1), (2, -1)]\n    count = 0\n    for i in range(len(spiral)):\n        if spiral[i][0] == x and spiral[i][1] == y:\n            break\n        if spiral[i][0] < x:\n            count += 1\n    return str(count)"
    },
    {
        "number": 824,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    n = len(stdin)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if stdin[i] == '(' and stdin[j] == ')':\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 825,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    while N > 1:\n        z = 2\n        while True:\n            if z * z > N:\n                break\n            if all(z % i!= 0 for i in range(2, int(z ** 0.5) + 1)) and z not in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]:\n                break\n            z += 1\n        if z == 2:\n            N //= 2\n            count += 1\n        elif z == 3:\n            N //= 3\n            count += 1\n        else:\n            N //= z\n            count += 1\n    print(count)\n    return \"\""
    },
    {
        "number": 826,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    logs = [1] * (n + 1)\n    logs[1] = 2\n    logs[2] = 3\n    logs[3] = 4\n    logs[4] = 5\n    logs[5] = 6\n    logs[6] = 7\n    logs[7] = 8\n    logs[8] = 9\n    logs[9] = 10\n    logs[10] = 11\n    logs[11] = 12\n    logs[12] = 13\n    logs[13] = 14\n    logs[14] = 15\n    logs[15] = 16\n    logs[16] = 17\n    logs[17] = 18\n    logs[18] = 19\n    logs[19] = 20\n    logs[20] = 21\n    logs[21] = 22\n    logs[22] = 23\n    logs[23] = 24\n    logs[24] = 25\n    logs[25] = 26\n    logs[26] = 27\n    logs[27] = 28\n    logs[28] = 29\n    logs[29] = 30\n    logs[30] = 31\n    logs[31] = 32\n    logs[32] = 33\n    logs[33] = 34\n    logs[34] = 35\n    logs[35] = 36\n    logs[36] = 37\n    logs[37] = 38\n    logs[38] = 39\n    logs[39] = 40\n    logs[40] = 41\n    logs[41] = 42\n    logs[42] = 43\n    logs[43] = 44\n    logs[44] = 45\n    logs[45] = 46\n    logs[46] = 47\n    logs[47] = 48\n    logs[48] = 49\n    logs[49] = 50\n    logs[50] = 51\n    logs[51] = 52\n    logs[52] = 53\n    logs[53] = 54\n    logs[54] = 55\n    logs[55] = 56\n    logs[56] = 57\n    logs[57] = 58\n    logs[58] = 59\n    logs[59] = 60\n    logs[60] = 61\n    logs[61] = 62\n    logs[62] = 63\n    logs[63] = 64\n    logs[64] = 65\n    logs[65] = 66\n    logs[66] = 67\n    logs[67] = 68\n    logs[68] = 69\n    logs[69] = 70\n    logs[70] = 71\n    logs[71] = 72\n    logs[72] = 73\n    logs[73] = 74\n    logs[74] = 75\n    logs[75] = 76\n    logs[76] = 77\n    logs[77] = 78\n    logs[78] = 79\n    logs[79] = 80\n    logs[80] = 81\n    logs[81] = 82\n    logs[82] = 83\n    logs[83] = 84\n    logs[84] = 85\n    logs[85] = 86\n    logs[86] = 87\n    logs[87] = 88\n    logs[88] = 89\n    logs[89] = 90\n    logs[90] = 91\n    logs[91] = 92\n    logs[92] = 93\n    logs[93] = 94\n    logs[94] = 95\n    logs[95] = 96\n    logs[96] = 97\n    logs[97] = 98\n    logs[98] = 99\n    logs[99] = 100\n    logs[100] = 101\n    logs[101] = 102\n    logs[102"
    },
    {
        "number": 827,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s = \"110\" * 10 ** 10\n    count = 0\n    for i in range(n - len(t) + 1):\n        if s[i:i + len(t)] == t:\n            count += 1\n    return str(count)"
    },
    {
        "number": 828,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(u: int, depth: int) -> int:\n        nonlocal min_workers\n        if depth == n:\n            min_workers = min(min_workers, depth)\n            return 0\n\n        res = 0\n        for v in range(n):\n            if v == u:\n                continue\n            if a[v] == 0:\n                res += dfs(v, depth + 1)\n            elif a[v] == 1:\n                res += dfs(v, depth + 1) + 1\n        return res\n\n    min_workers = float('inf')\n    dfs(s - 1, 0)\n    return str(min_workers)"
    },
    {
        "number": 829,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_good(s: str) -> bool:\n        zero_count = 0\n        one_count = 0\n        for c in s:\n            if c == '0':\n                zero_count += 1\n            else:\n                one_count += 1\n        return zero_count!= one_count\n\n    def cut(s: str) -> int:\n        min_length = len(s)\n        for i in range(1, len(s) + 1):\n            for j in range(i, len(s) + 1):\n                if is_good(s[i:j]):\n                    min_length = min(min_length, j - i)\n        return min_length\n\n    min_length = cut(s)\n    result = []\n    for i in range(min_length):\n        for j in range(i, min_length + 1):\n            if is_good(s[i:j]):\n                result.append(s[i:j])\n                break\n\n    return str(len(result)) +'' +''.join(result)"
    },
    {
        "number": 830,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_min_instability(heights: list) -> int:\n        min_height = min(heights)\n        max_height = max(heights)\n        return max_height - min_height\n\n    def find_min_operations(heights: list) -> int:\n        min_height = min(heights)\n        max_height = max(heights)\n        return max_height - min_height\n\n    def find_min_operations_with_operations(heights: list, operations: list) -> int:\n        min_height = min(heights)\n        max_height = max(heights)\n        min_operations = max_height - min_height\n        for i, operation in enumerate(operations):\n            if operation[0] == 1:\n                min_operations = min(min_operations, heights[operation[1] - 1] + heights[operation[2] - 1])\n            else:\n                min_operations = min(min_operations, heights[operation[1] - 1] - heights[operation[2] - 1])\n        return min_operations\n\n    def find_min_operations_with_operations_and_instability(heights: list, operations: list) -> tuple[int, int]:\n        min_height = min(heights)\n        max_height = max(heights)\n        min_operations = max_height - min_height\n        min_instability = max_height - min_height\n        for i, operation in enumerate(operations):\n            if operation[0] == 1:\n                min_operations = min(min_operations, heights[operation[1] - 1] + heights[operation[2] - 1])\n                min_instability = min(min_instability, heights[operation[1] - 1] + heights[operation[2] - 1])\n            else:\n                min_operations = min(min_operations, heights[operation[1] - 1] - heights[operation[2] - 1])\n                min_instability = min(min_instability, heights[operation[1] - 1] - heights[operation[2] - 1])\n        return min_instability, min_operations\n\n    heights = a.copy()\n    operations = []\n\n    for _ in range(k):\n        min_instability = find_min_instability(heights)\n        min_operations = find_min_operations(heights)\n        min_instability_with_operations, min_operations_with_operations = find_min_operations_with_operations(heights, operations)\n        min_instability_with_operations_and_instability, min_operations_with_operations_and_instability = find_min_operations_with_operations_and_instability(heights, operations)\n\n        if min_instability_with_operations_and_instability < min_instability:\n            min_instability = min_instability_with_operations_and_instability\n            min_operations = min_operations_with_operations_and_instability\n\n        if min_instability == min_instability_with_operations_and_instability:\n            min_operations = min(min_operations, min_operations_with_operations)\n\n        if min_instability == min_instability_with_operations:\n            min_operations = min_operations_with_operations\n\n        if min_instability == min_instability_with_operations_and_instability:\n            min_operations = min_operations_with_operations_and_instability\n\n        if min_instability == min_instability_with_operations:\n            min_operations = min_operations_with_operations\n\n        if min_instability == min_instability_with_operations_and_instability:\n            min_operations = min_operations_with_operations_and_instability\n\n        if min_instability == min_instability_with_operations:\n            min_operations = min_operations_with_operations\n\n        if min_instability == min_instability_with_operations_and_instability:\n            min_operations = min_operations_with_operations_and_instability\n\n        if min_instability == min_instability_with_operations:\n            min_operations = min_operations_with_operations\n\n        if min_instability == min_instability_with_operations_and_instability:\n            min_operations = min_operations_with_operations_and_instability\n\n        if min_instability == min_instability_"
    },
    {
        "number": 831,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.split()[0]\n    n = int(stdin.split()[1])\n    strings = []\n    a = []\n\n    for _ in range(n):\n        s, a_ = stdin.split()\n        strings.append(s)\n        a.append(int(a_))\n\n    def build_string(s: str, a: int, index: int, result: str) -> str:\n        if index == len(s):\n            return result\n\n        if a == 0:\n            return build_string(s, a, index + 1, result)\n\n        if s[index] in result:\n            return build_string(s, a, index + 1, result)\n\n        return build_string(s, a - 1, index + 1, result + s[index])\n\n    min_price = float('inf')\n    for i in range(1, len(t) + 1):\n        min_price = min(min_price, build_string(t, i, 0, \"\"))\n\n    return str(min_price) if min_price!= float('inf') else \"-1\"\n"
    },
    {
        "number": 832,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    teams = []\n    for _ in range(n):\n        home, guest = map(int, stdin.split()[1:])\n        teams.append((home, guest))\n    games = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if teams[i][0] == teams[j][1] or teams[i][1] == teams[j][0]:\n                games += 1\n    return str(games)"
    },
    {
        "number": 833,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    trees = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        trees.append((a, b))\n    trees.sort(key=lambda x: x[0])\n    max_fruit = 0\n    for i in range(n):\n        if trees[i][0] <= max_fruit:\n            max_fruit += trees[i][1]\n        else:\n            max_fruit = trees[i][1]\n    return str(max_fruit)"
    },
    {
        "number": 834,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    f = list(map(int, stdin.split()[1:]))\n\n    def f_k(x):\n        if x == 1:\n            return 1\n        else:\n            return f_k(x - 1) * f_k(x - 1)\n\n    min_k = 1\n    for k in range(2, n + 1):\n        if f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k(f_k("
    },
    {
        "number": 835,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    recipe = list(stdin)\n    n_b, n_s, n_c = map(int, stdin.split())\n    p_b, p_s, p_c = map(int, stdin.split())\n    r = int(stdin.split()[2])\n\n    def cook_hamburger(recipe, n_b, n_s, n_c, p_b, p_s, p_c, r):\n        def cook_ingredient(ingredient, n, p):\n            return n // p\n\n        def cook_ingredient_with_price(ingredient, n, p):\n            return n // p + (n % p!= 0)\n\n        def cook_ingredient_with_price_and_discount(ingredient, n, p, discount):\n            return n // p + (n % p!= 0) * discount\n\n        def cook_ingredient_with_price_and_discount_and_limit(ingredient, n, p, discount, limit):\n            return n // p + (n % p!= 0) * discount + (n % p!= 0) * limit\n\n        def cook_ingredient_with_price_and_discount_and_limit_and_limit_discount(ingredient, n, p, discount, limit, limit_discount):\n            return n // p + (n % p!= 0) * discount + (n % p!= 0) * limit + (n % p!= 0) * limit_discount\n\n        def cook_ingredient_with_price_and_discount_and_limit_and_limit_discount_and_limit_limit(ingredient, n, p, discount, limit, limit_discount, limit_limit):\n            return n // p + (n % p!= 0) * discount + (n % p!= 0) * limit + (n % p!= 0) * limit_discount + (n % p!= 0) * limit_limit\n\n        def cook_ingredient_with_price_and_discount_and_limit_and_limit_discount_and_limit_limit_limit_limit(ingredient, n, p, discount, limit, limit_discount, limit_limit, limit_limit_limit):\n            return n // p + (n % p!= 0) * discount + (n % p!= 0) * limit + (n % p!= 0) * limit_discount + (n % p!= 0) * limit_limit + (n % p!= 0) * limit_limit_limit\n\n        def cook_ingredient_with_price_and_discount_and_limit_and_limit_discount_and_limit_limit_limit_limit_limit(ingredient, n, p, discount, limit, limit_discount, limit_limit, limit_limit_limit, limit_limit_limit_limit):\n            return n // p + (n % p!= 0) * discount + (n % p!= 0) * limit + (n % p!= 0) * limit_discount + (n % p!= 0) * limit_limit + (n % p!= 0) * limit_limit_limit + (n % p!= 0) * limit_limit_limit_limit + (n % p!= 0) * limit_limit_limit_limit_limit\n\n        def cook_ingredient_with_price_and_discount_and_limit_and_limit_discount_and_limit_limit_limit_limit_limit_limit(ingredient, n, p, discount, limit, limit_discount, limit_limit, limit_limit_limit, limit_limit_limit_limit, limit_limit_limit_limit_limit, limit_limit_limit_limit_limit):\n            return n // p + (n % p!= 0) * discount + (n % p!= 0) * limit + (n % p!= 0) * limit_discount + (n % p!= 0) * limit_limit + (n % p!= 0) * limit_limit_limit + (n % p!= 0) * limit_limit_limit_limit + (n % p!= 0) * limit_limit_limit_limit_limit + (n % p!= 0) * limit_limit_limit_limit_limit + (n % p!= 0) * limit_limit_limit_limit_limit_limit\n\n        def cook_ingredient_with_price_and_discount_and_limit_and_limit_discount_and_limit_limit_limit_limit_limit_limit_limit(ingredient, n, p, discount, limit, limit_discount, limit_limit, limit_limit_limit, limit_limit_limit_limit, limit_limit_limit_limit"
    },
    {
        "number": 836,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    houses = [0] * n\n    shops = [0] * n\n    for i, c in enumerate(stdin.split()[1]):\n        if c == 'H':\n            houses[i] = 1\n        elif c == 'S':\n            shops[i] = 1\n    if all(houses) and all(shops):\n        return \"0\"\n    for i in range(n):\n        if houses[i] and shops[i]:\n            return \"0\"\n    for i in range(n):\n        if houses[i]:\n            if shops[i]:\n                return \"0\"\n            else:\n                return str(i + 1)\n    return \"1\""
    },
    {
        "number": 837,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    t = x + y * n\n    return str(t)"
    },
    {
        "number": 838,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    rows = [list(map(int, row.split())) for row in stdin.split('\\n')[1:]]\n\n    def is_valid(row, col):\n        return all(row[i] == row[j] or col[i] == col[j] for i in range(m) for j in range(m))\n\n    def count_sets(row, col):\n        count = 0\n        for i in range(m):\n            for j in range(m):\n                if row[i] == 0 and col[j] == 0:\n                    count += 1\n                elif row[i] == 1 and col[j] == 1:\n                    count += 1\n                elif row[i] == 0 and col[j] == 1:\n                    count += 1\n                elif row[i] == 1 and col[j] == 0:\n                    count += 1\n                elif row[i] == 1 and col[j] == 1:\n                    count += 1\n        return count\n\n    white_count = 0\n    black_count = 0\n    for row in rows:\n        for col in row:\n            if col == 0:\n                white_count += 1\n            else:\n                black_count += 1\n\n    valid_sets = 0\n    for i in range(m):\n        for j in range(m):\n            if is_valid(rows[i], rows[j]):\n                valid_sets += count_sets(rows[i], rows[j])\n\n    return str(valid_sets)"
    },
    {
        "number": 839,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    n = len(g)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = max(dp[i][k] + dp[k][j] + g[i][j] for k in range(n) if k!= i and k!= j)\n    return str(dp[0][0])"
    },
    {
        "number": 840,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(a, b):\n        a_set = set(a)\n        b_set = set(b)\n        a_set.discard(0)\n        b_set.discard(0)\n        a_set.discard(k)\n        b_set.discard(k)\n        a_set.discard(k - 1)\n        b_set.discard(k - 1)\n        a_set.discard(k + 1)\n        b_set.discard(k + 1)\n        a_set.discard(2 * k)\n        b_set.discard(2 * k)\n        a_set.discard(2 * k - 1)\n        b_set.discard(2 * k - 1)\n        a_set.discard(2 * k + 1)\n        b_set.discard(2 * k + 1)\n        a_set.discard(3 * k)\n        b_set.discard(3 * k)\n        a_set.discard(3 * k - 1)\n        b_set.discard(3 * k - 1)\n        a_set.discard(3 * k + 1)\n        b_set.discard(3 * k + 1)\n        a_set.discard(4 * k)\n        b_set.discard(4 * k)\n        a_set.discard(4 * k - 1)\n        b_set.discard(4 * k - 1)\n        a_set.discard(4 * k + 1)\n        b_set.discard(4 * k + 1)\n        a_set.discard(5 * k)\n        b_set.discard(5 * k)\n        a_set.discard(5 * k - 1)\n        b_set.discard(5 * k - 1)\n        a_set.discard(5 * k + 1)\n        b_set.discard(5 * k + 1)\n        a_set.discard(6 * k)\n        b_set.discard(6 * k)\n        a_set.discard(6 * k - 1)\n        b_set.discard(6 * k - 1)\n        a_set.discard(6 * k + 1)\n        b_set.discard(6 * k + 1)\n        a_set.discard(7 * k)\n        b_set.discard(7 * k)\n        a_set.discard(7 * k - 1)\n        b_set.discard(7 * k - 1)\n        a_set.discard(7 * k + 1)\n        b_set.discard(7 * k + 1)\n        a_set.discard(8 * k)\n        b_set.discard(8 * k)\n        a_set.discard(8 * k - 1)\n        b_set.discard(8 * k - 1)\n        a_set.discard(8 * k + 1)\n        b_set.discard(8 * k + 1)\n        a_set.discard(9 * k)\n        b_set.discard(9 * k)\n        a_set.discard(9 * k - 1)\n        b_set.discard(9 * k - 1)\n        a_set.discard(9 * k + 1)\n        b_set.discard(9 * k + 1)\n        a_set.discard(10 * k)\n        b_set.discard(10 * k)\n        a_set.discard(10 * k - 1)\n        b_set.discard(10 * k - 1)\n        a_set.discard(10 * k + 1)\n        b_set.discard(10 * k + 1)\n        a_set.discard(11 * k)\n        b_set.discard(11 * k)\n        a_set.discard(11 * k - 1)\n        b_set.discard(11 * k - 1)\n        a_set.discard(11 * k + 1)\n        b_set.discard(11 * k + 1)\n        a_set.discard(12 * k)\n        b_set.discard(12 * k)\n        a_set.discard(12 * k - "
    },
    {
        "number": 841,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n = int(stdin.split()[1])\n        s = \"1337\"\n        for _ in range(n - 1):\n            s = s.replace(\"1337\", \"\")\n        print(s)"
    },
    {
        "number": 842,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(10, 100):\n        if str(i)[::-1] == str(i):\n            count += 1\n            if count == n:\n                return str(i)"
    },
    {
        "number": 843,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *directions, *lengths = map(int, stdin.split())\n    directions = [1 if d == \"<\" else -1 for d in directions]\n    lengths = [l for l in lengths]\n    current_cell = 0\n    jumps = 0\n    while current_cell < n:\n        jumps += 1\n        current_cell += directions[current_cell]\n        if current_cell < 0 or current_cell >= n:\n            return \"INFINITE\"\n        if jumps == n:\n            return \"FINITE\"\n    return \"INFINITE\""
    },
    {
        "number": 844,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    max_length = 0\n    current_length = 0\n    zero_count = 0\n\n    for i in range(n):\n        if s[i] == '0':\n            zero_count += 1\n        else:\n            zero_count -= 1\n\n        current_length += 1\n\n        if zero_count == 0:\n            max_length = max(max_length, current_length)\n            current_length = 0\n\n    return str(max_length)"
    },
    {
        "number": 845,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    direction, message = stdin.split('\\n')\n    message = message.replace(',', '.')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',')\n    message = message.replace('.', ',')\n    message = message.replace(';', ',')\n    message = message.replace(',', ';')\n    message = message.replace(';', ':')\n    message = message.replace(':', ';')\n    message = message.replace(';', ',"
    },
    {
        "number": 846,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    buttons = list(map(int, stdin.split()))\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            buttons[j], buttons[i] = buttons[i], buttons[j]\n\n    indices = []\n    for i in range(1, n + 1):\n        indices.append(buttons.index(i))\n\n    return \" \".join(map(str, indices))"
    },
    {
        "number": 847,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    numbers = list(map(int, stdin.split()))\n\n    def find_cards(numbers: list, target: int) -> int:\n        left, right = 0, len(numbers) - 1\n        count = 0\n\n        while left <= right:\n            mid = (left + right) // 2\n\n            if numbers[mid] == target:\n                count += 1\n                left = mid + 1\n            elif numbers[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n        return count\n\n    def find_min_cards(numbers: list, target: int) -> int:\n        min_cards = float('inf')\n\n        for num in numbers:\n            if abs(num) <= x and num!= 0:\n                min_cards = min(min_cards, find_cards(numbers, num))\n\n        return min_cards\n\n    min_cards = find_min_cards(numbers, 0)\n    return str(min_cards)"
    },
    {
        "number": 848,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    teams = list(range(1, n+1))\n    matches = []\n\n    for _ in range(k):\n        a, b = map(int, stdin.split())\n        matches.append((a, b))\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][1] or matches[i][1] == matches[j][0]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] or matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][1] and matches[i][1] == matches[j][0]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                matches.remove(matches[j])\n\n    if not matches:\n        return -1\n\n    for i in range(len(matches)):\n        for j in range(i+1, len(matches)):\n            if matches[i][0] == matches[j][0] and matches"
    },
    {
        "number": 849,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a <= 0 or b <= 0 or c <= 0 or d <= 0 or a > 10000 or b > 10000 or c > 10000 or d > 10000 or a > b or c > d or b > d:\n        return \"Error: Invalid input\"\n\n    smallr_win_probability = (a / b) / (c / d)\n    return f\"{smallr_win_probability:.6f}\""
    },
    {
        "number": 850,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *d = map(int, stdin.split())\n    d = set(d)\n    n = 0\n    while d:\n        n += 1\n        if len(d) == 1:\n            break\n        for i in range(len(d)):\n            for j in range(i + 1, len(d)):\n                if d[i] + d[j] == 0:\n                    d.remove(d[i])\n                    d.remove(d[j])\n                    break\n    return str(n) +'' +''.join(map(str, sorted(d)))"
    },
    {
        "number": 851,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    workday = list(map(int, stdin.split()))\n    workday.insert(0, 0)\n    workday.append(0)\n    workday.sort()\n    break_time = 0\n    for i in range(1, n):\n        if workday[i] - workday[i - 1] - 1 < break_time:\n            break_time = workday[i] - workday[i - 1] - 1\n    return str(break_time)"
    },
    {
        "number": 852,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, k, l = map(int, stdin.split('\\n')[1].split())\n        d = list(map(int, stdin.split('\\n')[2].split()))\n        p = [0] * (2 * k)\n        for i in range(1, 2 * k):\n            p[i] = p[i - 1] + 1\n        t = 0\n        x = 0\n        while x < n:\n            if t % 2 == 0:\n                x += 1\n            else:\n                x -= 1\n            t += 1\n            if x == n:\n                break\n            if d[x] + p[t % 2 * k] > l:\n                return 'No'\n        if x == n:\n            return 'Yes'\n    return 'No'"
    },
    {
        "number": 853,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *cards = map(int, stdin.split())\n    cards = [str(card) for card in cards]\n    cards.sort(reverse=True)\n    cards = [card for card in cards if card!= '0']\n    cards = ''.join(cards)\n    max_num = 0\n    for i in range(1, 10):\n        num = int(cards + str(i))\n        if num % 90 == 0:\n            max_num = max(max_num, num)\n    return str(max_num) if max_num % 90 == 0 else '-1'"
    },
    {
        "number": 854,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def booth_number(i: int) -> int:\n        return (i + n - 1) % n\n\n    def booth_price(i: int) -> int:\n        return a[i - 1]\n\n    def booth_supply(i: int) -> int:\n        return n - i\n\n    def booth_candies(i: int) -> int:\n        return booth_supply(i) * booth_price(i)\n\n    def booth_total_candies(i: int) -> int:\n        return booth_candies(i) + booth_candies(booth_number(i))\n\n    def booth_total_burles(i: int) -> int:\n        return booth_total_candies(i) * booth_price(i)\n\n    def booth_can_buy(i: int) -> bool:\n        return booth_total_burles(i) <= T\n\n    def booth_buy(i: int) -> int:\n        return booth_total_candies(i)\n\n    def booth_can_afford(i: int) -> bool:\n        return booth_total_burles(i) <= T and booth_supply(i) > 0\n\n    def booth_afford(i: int) -> int:\n        return booth_total_candies(i)\n\n    def booth_can_afford_buy(i: int) -> bool:\n        return booth_can_afford(i) and booth_can_buy(i)\n\n    def booth_afford_buy(i: int) -> int:\n        return booth_afford(i) + booth_buy(i)\n\n    def booth_can_afford_buy_afford(i: int) -> bool:\n        return booth_can_afford_buy(i) and booth_can_afford(booth_number(i))\n\n    def booth_afford_buy_afford(i: int) -> int:\n        return booth_afford_buy(i) + booth_afford(booth_number(i))\n\n    def booth_can_afford_buy_afford_buy(i: int) -> bool:\n        return booth_can_afford_buy_afford(i) and booth_can_buy(booth_number(i))\n\n    def booth_afford_buy_afford_buy(i: int) -> int:\n        return booth_afford_buy_afford(i) + booth_buy(booth_number(i))\n\n    def booth_can_afford_buy_afford_buy_afford(i: int) -> bool:\n        return booth_can_afford_buy_afford_buy(i) and booth_can_afford(booth_number(i))\n\n    def booth_afford_buy_afford_buy_afford(i: int) -> int:\n        return booth_afford_buy_afford_buy(i) + booth_afford(booth_number(i))\n\n    def booth_can_afford_buy_afford_buy_afford_buy(i: int) -> bool:\n        return booth_can_afford_buy_afford_buy_afford(i) and booth_can_buy(booth_number(i))\n\n    def booth_afford_buy_afford_buy_afford_buy(i: int) -> int:\n        return booth_afford_buy_afford_buy_afford(i) + booth_buy(booth_number(i))\n\n    def booth_can_afford_buy_afford_buy_afford_buy_afford(i: int) -> bool:\n        return booth_can_afford_buy_afford_buy_afford_buy(i) and booth_can_afford(booth_number(i))\n\n    def booth_afford_buy_afford_buy_afford_buy_afford(i: int) -> int:\n        return booth_afford_buy_afford_buy_afford_buy(i) + booth_afford(booth_number(i))\n\n    def booth_can_afford_buy_afford_buy_afford_buy_afford_buy(i: int) -> bool"
    },
    {
        "number": 855,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    alice_choices = []\n    bob_choices = []\n    for i in range(k):\n        alice_choices.append(list(map(int, stdin.split())))\n        bob_choices.append(list(map(int, stdin.split())))\n    alice_points = 0\n    bob_points = 0\n    for i in range(k):\n        alice_choice = alice_choices[i][a - 1]\n        bob_choice = bob_choices[i][b - 1]\n        if alice_choice == bob_choice:\n            alice_points += 1\n            bob_points += 1\n        elif alice_choice == 3 and bob_choice == 2:\n            alice_points += 1\n            bob_points += 1\n        elif alice_choice == 2 and bob_choice == 1:\n            alice_points += 1\n            bob_points += 1\n        elif alice_choice == 1 and bob_choice == 3:\n            alice_points += 1\n            bob_points += 1\n    return str(alice_points) + \" \" + str(bob_points)"
    },
    {
        "number": 856,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        for _ in range(k):\n            max_val = max(a)\n            for i in range(n):\n                a[i] = max_val - a[i]\n        print(' '.join(map(str, a)))"
    },
    {
        "number": 857,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    keys = list(map(int, stdin.split()))\n\n    def is_valid(code):\n        for i in range(n):\n            if code[i] not in sequence:\n                return False\n        return True\n\n    def is_valid_with_fingerprints(code):\n        for i in range(n):\n            if code[i] not in sequence and code[i] not in keys:\n                return False\n        return True\n\n    def longest_valid_code(is_valid_func):\n        max_length = 0\n        current_length = 0\n        current_code = []\n        for i in range(n):\n            if is_valid_func(current_code + [sequence[i]]):\n                current_length += 1\n                if current_length > max_length:\n                    max_length = current_length\n                    current_code = [sequence[i]]\n            else:\n                current_length = 0\n                current_code = []\n        return current_code\n\n    valid_code = longest_valid_code(is_valid)\n    valid_code_with_fingerprints = longest_valid_code(is_valid_with_fingerprints)\n\n    if valid_code:\n        return \" \".join(map(str, valid_code))\n    elif valid_code_with_fingerprints:\n        return \" \".join(map(str, valid_code_with_fingerprints))\n    else:\n        return \"\"\n"
    },
    {
        "number": 858,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str(2 * n - 1)"
    },
    {
        "number": 859,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2 = stdin.split('\\n')\n    s_1 = list(s_1)\n    s_2 = list(s_2)\n\n    def is_valid_command(command: str) -> bool:\n        return command in {'+', '-'}\n\n    def is_recognized_command(command: str) -> bool:\n        return command in {'+', '-'}\n\n    def is_correct_command(command: str) -> bool:\n        return command in {'+', '-'}\n\n    def is_correct_position(position: int) -> bool:\n        return position == 0\n\n    def is_correct_command_position(command: str, position: int) -> bool:\n        if command == '+':\n            return position == 1\n        elif command == '-':\n            return position == -1\n\n    def is_correct_command_position_and_direction(command: str, position: int, direction: str) -> bool:\n        if command == '+':\n            return position == 1 and direction == '+'\n        elif command == '-':\n            return position == -1 and direction == '-'\n\n    def is_correct_command_position_and_direction_and_probability(command: str, position: int, direction: str, probability: float) -> bool:\n        if command == '+':\n            return position == 1 and direction == '+' and probability == 0.5\n        elif command == '-':\n            return position == -1 and direction == '-' and probability == 0.5\n\n    def count_correct_commands(s_1: list, s_2: list) -> int:\n        count = 0\n        for command in s_1:\n            if is_recognized_command(command):\n                if is_correct_command(command):\n                    count += 1\n        return count\n\n    def count_correct_positions(s_1: list, s_2: list) -> int:\n        count = 0\n        for command in s_1:\n            if is_recognized_command(command):\n                if is_correct_command_position(command, 0):\n                    count += 1\n        return count\n\n    def count_correct_command_positions_and_directions(s_1: list, s_2: list) -> int:\n        count = 0\n        for command in s_1:\n            if is_recognized_command(command):\n                if is_correct_command_position_and_direction(command, 0, '+'):\n                    count += 1\n                elif is_correct_command_position_and_direction(command, 0, '-'):\n                    count += 1\n        return count\n\n    def count_correct_command_positions_and_directions_and_probabilities(s_1: list, s_2: list) -> int:\n        count = 0\n        for command in s_1:\n            if is_recognized_command(command):\n                if is_correct_command_position_and_direction_and_probability(command, 0, '+', 0.5):\n                    count += 1\n                elif is_correct_command_position_and_direction_and_probability(command, 0, '-', 0.5):\n                    count += 1\n        return count\n\n    correct_commands = count_correct_commands(s_1, s_2)\n    correct_positions = count_correct_positions(s_1, s_2)\n    correct_command_positions_and_directions = count_correct_command_positions_and_directions(s_1, s_2)\n    correct_command_positions_and_directions_and_probabilities = count_correct_command_positions_and_directions_and_probabilities(s_1, s_2)\n\n    probability = correct_commands / (correct_commands + correct_positions + correct_command_positions_and_directions + correct_command_positions_and_directions_and_probabilities)\n\n    return str(probability)"
    },
    {
        "number": 860,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [0] * n\n    for i, x in enumerate(a):\n        a[x] += 1\n\n    def dfs(team, used):\n        if len(team) == 3:\n            return True\n        for i in range(n):\n            if i not in used and a[i] > 0:\n                used.add(i)\n                if dfs(team + [i], used):\n                    return True\n                used.remove(i)\n        return False\n\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        used = set()\n        if dfs([i], used):\n            return \"Possible\\n\" + \" \".join(map(str, team))\n        used.add(i)\n        if dfs([i], used):\n            return \"Possible\\n\" + \" \".join(map(str, team))\n        used.remove(i)\n\n    return \"Impossible\\n\""
    },
    {
        "number": 861,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    circles = [(2 * R - R, 0), (4 * R - R, 0), (6 * R - R, 0), (8 * R - R, 0), (10 * R - R, 0)]\n    distances = []\n    for i in range(m * m):\n        v = int(i / m) + 1\n        u = m + 1 + (i % m)\n        distances.append(sum(abs(c[0] - v) + abs(c[1] - u) for c in circles))\n    return str(sum(distances) / len(distances))"
    },
    {
        "number": 862,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(lambda x: x - 1, a))\n    entrance = 0\n    for i in range(n):\n        entrance = (entrance + a[i]) % n\n    return str(entrance)"
    },
    {
        "number": 863,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a = map(int, stdin.split())\n    b, t_b = map(int, stdin.split())\n    departure_time = stdin.split()[-1]\n\n    departure_hour, departure_minute = map(int, departure_time.split(':'))\n\n    departure_time = departure_hour * 60 + departure_minute\n\n    buses_from_a = 0\n    buses_from_b = 0\n\n    while departure_time < 1440:\n        if departure_time % a == 0:\n            buses_from_a += 1\n        if departure_time % b == 0:\n            buses_from_b += 1\n\n        departure_time += t_a + t_b\n\n    return str(buses_from_a + buses_from_b)"
    },
    {
        "number": 864,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_days = 0\n    for i in range(1, m + 1):\n        count = 0\n        for j in range(n):\n            if a[i - 1] == a[j]:\n                count += 1\n        max_days = max(max_days, count)\n\n    return str(max_days)"
    },
    {
        "number": 865,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    dishes = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        dishes.append((a, b))\n\n    dishes.sort(key=lambda x: x[1])\n    max_happiness = 0\n    current_happiness = 0\n    current_order = []\n\n    for i, (a, b) in enumerate(dishes):\n        if i == 0:\n            current_order.append(i)\n            current_happiness += b\n            max_happiness = max(max_happiness, current_happiness)\n        elif i == 1:\n            current_order.append(i)\n            current_happiness += b\n            max_happiness = max(max_happiness, current_happiness)\n        else:\n            if a <= t - 0.5:\n                current_order.append(i)\n                current_happiness += b\n                max_happiness = max(max_happiness, current_happiness)\n            else:\n                break\n\n    return str(max_happiness)"
    },
    {
        "number": 866,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    directions = [(1, 2), (2, 1)]\n    memo = {}\n\n    def count_ways(x, y):\n        if (x, y) in memo:\n            return memo[(x, y)]\n        if x == X and y == Y:\n            return 1\n        ways = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < X and 0 <= ny < Y:\n                ways += count_ways(nx, ny)\n        memo[(x, y)] = ways % MOD\n        return memo[(x, y)]\n\n    return str(count_ways(0, 0))\n"
    },
    {
        "number": 867,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    brains = [0] * n\n    for i in range(n):\n        brains[i] = i + 1\n    brains[n - 1] = n\n    brains.sort(reverse=True)\n    return str(brains[0])"
    },
    {
        "number": 868,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 0\n    for i in range(n):\n        result = (result * 1378) % 1000000007\n    return str(result % 10)"
    },
    {
        "number": 869,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days = 0\n    same_days = 0\n\n    for i in range(1, a + 1):\n        if i % 2 == 0:\n            max_days += 1\n        else:\n            same_days += 1\n\n    for i in range(1, b + 1):\n        if i % 2 == 0:\n            max_days += 1\n        else:\n            same_days += 1\n\n    return f\"{max_days} {same_days}\""
    },
    {
        "number": 870,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v_1, v_2 = map(int, stdin.split())\n    v_1, v_2 = v_1 / 1000, v_2 / 1000\n    t = 0\n    while True:\n        t += 1\n        x = L + v_1 * t + v_2 * t ** 2 / 2\n        if x < d:\n            continue\n        if x > L + d:\n            break\n        if x < L + d / 2:\n            return str(t)\n    return str(t)"
    },
    {
        "number": 871,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    landings = []\n    for _ in range(n):\n        h, m = map(int, stdin.split())\n        landings.append((h, m))\n\n    landings.sort()\n    takeoff_time = landings[0][1]\n    earliest_time = takeoff_time + s\n\n    return f\"{earliest_time // 60:02d} {earliest_time % 60:02d}\""
    },
    {
        "number": 872,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + a[j] % 2 == 1:\n                a[i], a[j] = a[j], a[i]\n                break\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 873,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    original_state = list(map(int, stdin.split()[1]))\n    secret_combination = list(map(int, stdin.split()[2]))\n\n    def rotate(disk_index: int, direction: int) -> int:\n        if direction == 1:\n            return (disk_index + 1) % n\n        else:\n            return (disk_index - 1) % n\n\n    def is_valid_combination(combination: List[int]) -> bool:\n        return ''.join(map(str, combination)) == ''.join(map(str, secret_combination))\n\n    def is_valid_state(state: List[int]) -> bool:\n        return ''.join(map(str, state)) == ''.join(map(str, original_state))\n\n    def is_valid_move(state: List[int], direction: int) -> bool:\n        disk_index = state.index(0)\n        new_disk_index = rotate(disk_index, direction)\n        return new_disk_index!= disk_index\n\n    def min_moves(state: List[int]) -> int:\n        moves = 0\n        for direction in range(1, 10):\n            if is_valid_move(state, direction):\n                moves += 1\n        return moves\n\n    state = original_state.copy()\n    moves = min_moves(state)\n\n    while not is_valid_combination(state) and not is_valid_state(state):\n        moves += 1\n        state = original_state.copy()\n        for direction in range(1, 10):\n            if is_valid_move(state, direction):\n                state[state.index(0)] = rotate(state.index(0), direction)\n                moves += 1\n\n    return str(moves)"
    },
    {
        "number": 874,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2 1\"\n    else:\n        p = [i for i in range(1, n+1)]\n        for i in range(n-1):\n            j = i + 1\n            while p[i] == p[j]:\n                j += 1\n            p[i], p[j] = p[j], p[i]\n        return \" \".join(map(str, p))"
    },
    {
        "number": 875,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *stones = map(int, stdin.split())\n    stones = set(stones)\n    if len(stones)!= 3:\n        return -1\n\n    def is_valid(stones: set[int]) -> bool:\n        return len(stones) == 3 and 1 in stones and 2 in stones and 3 in stones\n\n    def get_moves(stones: set[int]) -> list[tuple[int, int]]:\n        moves = []\n        for i in range(1, n):\n            for j in range(i + 1, n):\n                if stones.issubset({i, j}):\n                    color = stdin[i - 1]\n                    if color == stdin[j - 1]:\n                        moves.append((i, j))\n        return moves\n\n    def get_moves_count(moves: list[tuple[int, int]]) -> int:\n        return len(moves)\n\n    def get_moves_description(moves: list[tuple[int, int]]) -> str:\n        return \"\\n\".join(f\"{i} {j}\" for i, j in moves)\n\n    def get_moves_count_and_description(moves: list[tuple[int, int]]) -> str:\n        return f\"{get_moves_count(moves)} {get_moves_description(moves)}\"\n\n    moves = get_moves(stones)\n    if not moves:\n        return -1\n\n    moves.sort(key=lambda x: (x[0], x[1]))\n    return get_moves_count_and_description(moves)\n"
    },
    {
        "number": 876,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A0 = list(map(int, stdin.split()))\n\n    A = [A0]\n    for i in range(n - 1):\n        A.append(p(A[-1] - 1))\n\n    for i in range(n, len(A)):\n        if A[i].count(k) >= 1:\n            return str(i)\n\n    return \"0\"\n\n\ndef"
    },
    {
        "number": 877,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        pairs.append((u, v))\n\n    def dfs(problems, used, depth, result):\n        if depth == n:\n            result.add(tuple(used))\n            return\n\n        for i in range(len(problems)):\n            if i in used:\n                continue\n\n            used.add(i)\n            dfs(problems, used, depth + 1, result)\n            used.remove(i)\n\n    result = set()\n    dfs(list(range(n)), set(), 0, result)\n    return str(len(result))"
    },
    {
        "number": 878,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(i: int) -> bool:\n        return a[i]!= a[i + 1]\n\n    def is_triangle(i: int) -> bool:\n        return a[i] == 1\n\n    def is_square(i: int) -> bool:\n        return a[i] == 2\n\n    def is_circle(i: int) -> bool:\n        return a[i] == 3\n\n    def max_side(i: int) -> int:\n        if is_triangle(i):\n            return max(a[i], a[i + 1])\n        elif is_square(i):\n            return max(a[i], a[i + 1])\n        else:\n            return a[i]\n\n    def max_radius(i: int) -> int:\n        if is_circle(i):\n            return a[i]\n        else:\n            return 0\n\n    def is_inscribed(i: int) -> bool:\n        return is_triangle(i) or is_square(i)\n\n    def is_parallel(i: int) -> bool:\n        return is_triangle(i) and a[i] == a[i + 1]\n\n    def is_top(i: int) -> bool:\n        return is_triangle(i) and a[i] == 1\n\n    def is_parallel_to_x(i: int) -> bool:\n        return is_square(i) and a[i] == 1\n\n    def is_parallel_to_y(i: int) -> bool:\n        return is_square(i) and a[i] == 2\n\n    def is_parallel_to_xy(i: int) -> bool:\n        return is_square(i) and a[i] == 3\n\n    def is_in_triangle(i: int) -> bool:\n        return is_triangle(i) and a[i] == 2\n\n    def is_in_square(i: int) -> bool:\n        return is_square(i) and a[i] == 3\n\n    def is_in_circle(i: int) -> bool:\n        return is_circle(i) and a[i] == 3\n\n    def is_in_triangle_base(i: int) -> bool:\n        return is_triangle(i) and a[i] == 1\n\n    def is_in_square_side(i: int) -> bool:\n        return is_square(i) and a[i] == 2\n\n    def is_in_circle_radius(i: int) -> bool:\n        return is_circle(i) and a[i] == 1\n\n    def is_in_triangle_vertex(i: int) -> bool:\n        return is_triangle(i) and a[i] == 3\n\n    def is_in_square_vertex(i: int) -> bool:\n        return is_square(i) and a[i] == 3\n\n    def is_in_circle_vertex(i: int) -> bool:\n        return is_circle(i) and a[i] == 3\n\n    def is_in_triangle_vertex_top(i: int) -> bool:\n        return is_triangle(i) and a[i] == 2\n\n    def is_in_square_vertex_top(i: int) -> bool:\n        return is_square(i) and a[i] == 2\n\n    def is_in_circle_vertex_top(i: int) -> bool:\n        return is_circle(i) and a[i] == 2\n\n    def is_in_triangle_vertex_bottom(i: int) -> bool:\n        return is_triangle(i) and a[i] == 1\n\n    def is_in_square_vertex_bottom(i: int) -> bool:\n        return is_square(i) and a[i] == 1\n\n    def is_in_circle_vertex_bottom(i: int) -> bool:\n        return is_circle(i) and a[i] == 1\n\n    def is_in_triangle_vertex_left(i: int) -> bool:\n        return is_triangle(i) and a[i] == 3\n\n    def is_in_square_vertex_left(i: int) -> bool:\n        return is_square(i) and a[i] == 3\n\n    def is_in_circle_vertex_left(i: int) -> bool:\n        return is_circle(i) and a[i] == 3\n\n    def is_in"
    },
    {
        "number": 879,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    visited = [False] * (n + 1)\n    visited[1] = True\n    path = [1]\n    while not all(visited):\n        for i in range(1, n + 1):\n            if not visited[i] and p[i - 1] == i:\n                visited[i] = True\n                path.append(i)\n                break\n    return \" \".join(map(str, path))"
    },
    {
        "number": 880,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    p = [1] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            p[j] = p[j] + p[j - i]\n    return str(sum(p) % 998244353)"
    },
    {
        "number": 881,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            a[i], a[i + 1] = a[i] + 1, a[i] + 1\n\n    return str(min(len(a), n))"
    },
    {
        "number": 882,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            s[i] = t[count % len(t)]\n            count += 1\n    return ''.join(s)"
    },
    {
        "number": 883,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *fingers = map(int, stdin.split())\n    fingers = sorted(set(fingers))\n    count = 0\n    for i in range(1, n + 1):\n        count += fingers.count(i)\n    return str(count)"
    },
    {
        "number": 884,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    mod = 998244353\n\n    def dfs(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length == 1:\n            return dfs(visited, bridge_length - 1, bridge_count + 1)\n\n        return dfs(visited, bridge_length - 1, bridge_count)\n\n    def count_ways(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length == 1:\n            return count_ways(visited, bridge_length - 1, bridge_count + 1)\n\n        return count_ways(visited, bridge_length - 1, bridge_count)\n\n    def count_ways_with_red_blue_purple(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length == 1:\n            return count_ways_with_red_blue_purple(visited, bridge_length - 1, bridge_count + 1)\n\n        return count_ways_with_red_blue_purple(visited, bridge_length - 1, bridge_count)\n\n    def count_ways_with_red_blue_purple_and_bridges(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length == 1:\n            return count_ways_with_red_blue_purple_and_bridges(visited, bridge_length - 1, bridge_count + 1)\n\n        return count_ways_with_red_blue_purple_and_bridges(visited, bridge_length - 1, bridge_count)\n\n    def count_ways_with_red_blue_purple_and_bridges_and_clusters(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length == 1:\n            return count_ways_with_red_blue_purple_and_bridges_and_clusters(visited, bridge_length - 1, bridge_count + 1)\n\n        return count_ways_with_red_blue_purple_and_bridges_and_clusters(visited, bridge_length - 1, bridge_count)\n\n    def count_ways_with_red_blue_purple_and_bridges_and_clusters_and_island_colors(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length == 1:\n            return count_ways_with_red_blue_purple_and_bridges_and_clusters_and_island_colors(visited, bridge_length - 1, bridge_count + 1)\n\n        return count_ways_with_red_blue_purple_and_bridges_and_clusters_and_island_colors(visited, bridge_length - 1, bridge_count)\n\n    def count_ways_with_red_blue_purple_and_bridges_and_clusters_and_island_colors_and_clusters(visited, bridge_length, bridge_count):\n        if bridge_length == 0:\n            return 1\n\n        if (a, b) in visited or (b, a) in visited:\n            return 0\n\n        visited.add((a, b))\n        visited.add((b, a))\n\n        if bridge_length"
    },
    {
        "number": 885,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, stdin.split()[1:])) for _ in range(n - 1)]\n    edges.append((n, 1))\n\n    def dfs(u, visited, parent, depth):\n        nonlocal count\n        count += 1\n        for v, w in edges:\n            if u!= v and not visited[v]:\n                visited[v] = True\n                parent[v] = u\n                dfs(v, visited, parent, depth + 1)\n\n    count = 0\n    visited = [False] * (n + 1)\n    parent = [-1] * (n + 1)\n    for u in range(1, n + 1):\n        if not visited[u]:\n            dfs(u, visited, parent, 0)\n\n    def w(H):\n        count = 0\n        for u in range(1, n + 1):\n            if u not in H:\n                visited = [False] * (n + 1)\n                parent = [-1] * (n + 1)\n                dfs(u, visited, parent, 0)\n                count += 1\n        return count\n\n    def sum_w(E):\n        return sum(w(H) for H in itertools.combinations(E, r=2))\n\n    return str(sum_w(edges)) % 998244353"
    },
    {
        "number": 886,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return -1\n\n    def swap_digits(num: int) -> int:\n        return int(str(num)[::-1])\n\n    def is_even(num: int) -> bool:\n        return num % 2 == 0\n\n    def is_valid(num: int) -> bool:\n        return is_even(num) and num == swap_digits(num)\n\n    max_even_valid = -1\n    for i in range(10):\n        for j in range(10):\n            if i!= j:\n                num = n * 10 + i + j\n                if is_valid(num):\n                    max_even_valid = max(max_even_valid, num)\n\n    if max_even_valid == -1:\n        return -1\n    else:\n        return str(max_even_valid)"
    },
    {
        "number": 887,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    buttons = list(map(int, stdin.split()[1:]))\n\n    if sum(buttons) == 1:\n        return \"NO\"\n\n    for i in range(n - 1):\n        if buttons[i] == 1 and buttons[i + 1] == 0:\n            buttons[i] = 0\n            buttons[i + 1] = 1\n            break\n\n    if sum(buttons) == 1:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 888,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split())\n    p_set = set(p)\n    s_set = set(s)\n\n    if p_set!= s_set:\n        return \"No solution\"\n\n    def swap(i, j):\n        nonlocal p, s\n        p[i], p[j] = p[j], p[i]\n        s[i], s[j] = s[j], s[i]\n\n    def min_coins(i, j, coins):\n        if i == j:\n            return coins\n        if i > j:\n            return min_coins(i, j - 1, coins)\n        return min(min_coins(i + 1, j, coins), min_coins(i, j - 1, coins))\n\n    min_coins_count = float('inf')\n    min_coins_sequence = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            coins = min_coins(i, j, 0)\n            if coins < min_coins_count:\n                min_coins_count = coins\n                min_coins_sequence = [(i, j)]\n            elif coins == min_coins_count:\n                min_coins_sequence.append((i, j))\n\n    return str(min_coins_count) + \"\\n\" + str(len(min_coins_sequence)) + \"\\n\" + \"\\n\".join(map(str, min_coins_sequence))"
    },
    {
        "number": 889,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = [row.strip() for row in stdin.split('\\n')]\n    n = len(rows)\n    m = len(rows[0])\n\n    def is_valid(row: int, col: int) -> bool:\n        return (row == 0 or rows[row - 1][col] == '#') and (row == n - 1 or rows[row + 1][col] == '#') and (col == 0 or rows[row][col - 1] == '#') and (col == m - 1 or rows[row][col + 1] == '#')\n\n    def repaint(row: int, col: int) -> bool:\n        if rows[row][col] == '#':\n            rows[row][col] = '.'\n            return True\n        return False\n\n    def is_square(row: int, col: int) -> bool:\n        return is_valid(row, col) and repaint(row, col)\n\n    def count_black_cells(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                if rows[i][j] == '#':\n                    count += 1\n        return count\n\n    def count_white_cells(row: int, col: int) -> int:\n        count = 0\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                if rows[i][j] == '.':\n                    count += 1\n        return count\n\n    def is_valid_square(row: int, col: int) -> bool:\n        return is_square(row, col) and count_black_cells(row, col) == count_white_cells(row, col)\n\n    for i in range(n):\n        for j in range(m):\n            if rows[i][j] == '#':\n                if is_valid_square(i, j):\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 890,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split())\n    c = list(map(int, stdin.split()[1:]))\n\n    def backtrack(start, used, count):\n        if count >= 2 and sum(c[used]) >= l and sum(c[used]) <= r and max(c[used]) - min(c[used]) >= x:\n            print(count)\n            return\n\n        for i in range(start, n):\n            if i not in used:\n                backtrack(i + 1, used + [i], count + 1)\n\n    backtrack(0, [], 0)\n    return \"\"\n"
    },
    {
        "number": 891,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    chips = [c == 'W' for c in stdin[2:]]\n    for _ in range(k):\n        neighbours = [chips[i - 1], chips[i + 1], chips[i - n], chips[i + n]]\n        white_neighbours = [n for n in neighbours if n]\n        black_neighbours = [n for n in neighbours if not n]\n        white_count = sum(white_neighbours)\n        black_count = sum(black_neighbours)\n        for i in range(n):\n            if white_count > black_count:\n                chips[i] = True\n            else:\n                chips[i] = False\n    return ''.join(['W' if c else 'B' for c in chips])"
    },
    {
        "number": 892,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    lcm = 1\n    for num in a:\n        lcm *= num\n\n    lcm = lcm // gcd(lcm, m)\n\n    def is_valid(subseq):\n        return lcm in subseq\n\n    def find_longest_subseq(arr):\n        max_len = 0\n        max_subseq = []\n        for i in range(1, len(arr) + 1):\n            for subseq in itertools.combinations(arr, i):\n                if is_valid(subseq):\n                    if len(subseq) > max_len:\n                        max_len = len(subseq)\n                        max_subseq = subseq\n        return max_subseq\n\n    max_subseq = find_longest_subseq(a)\n    max_len = len(max_subseq)\n\n    print(lcm, max_len)\n    for i in range(max_len):\n        print(max_subseq.index(a[max_subseq.index(lcm) - i]), end=\" \")\n\ndef"
    },
    {
        "number": 893,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop"
    },
    {
        "number": 894,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 0 or y == 0:\n        return \"0 0 0 0\"\n\n    a = 0\n    b = 0\n    c = 0\n\n    if x > 0:\n        a = x\n        b = y\n    else:\n        a = -x\n        b = -y\n\n    c = 2 * a * b\n\n    if c < 0:\n        c = 0\n\n    s = (a + b + c) / 2\n    area = 0.5 * s * (s - a) * (s - b) * (s - c)\n\n    if area < 0:\n        area = 0\n\n    x1 = 0\n    y1 = 0\n    x2 = 0\n    y2 = 0\n\n    if a == 0:\n        x1 = 0\n        y1 = 0\n        x2 = 0\n        y2 = 0\n    else:\n        x1 = (b * c - a * b) / (2 * a)\n        y1 = (a * b - b * a) / (2 * a)\n        x2 = (b * c + a * b) / (2 * a)\n        y2 = (a * b + b * a) / (2 * a)\n\n    return f\"{x1} {y1} {x2} {y2}\""
    },
    {
        "number": 895,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    T = int(stdin.split()[-1])\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(t[i] - t[j]) > T:\n                max_count += 1\n                break\n\n    return str(max_count)"
    },
    {
        "number": 896,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def is_valid(matrix):\n        for row in matrix:\n            if len(row)!= m:\n                return False\n            for num in row:\n                if num > 2**31 - 1 or num < -2**31:\n                    return False\n        return True\n\n    def find_matrix(a, b):\n        for i in range(2**n):\n            for j in range(2**m):\n                if a[i] == j ^ b[j]:\n                    return [i, j]\n        return None\n\n    matrix = find_matrix(a, b)\n    if matrix is None:\n        return \"NO\"\n\n    matrix = [list(map(lambda x: x ^ matrix[0][0], row)) for row in matrix]\n    return \"YES\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), matrix))\n"
    },
    {
        "number": 897,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a1, a2 = map(int, stdin.split())\n    s1 = list(map(int, stdin.split()))\n    s2 = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def coprime(a, b):\n        return gcd(a, b) == 1\n\n    def mod_pow(a, b, m):\n        res = 1\n        while b:\n            if b & 1:\n                res = (res * a) % m\n            a = (a * a) % m\n            b >>= 1\n        return res\n\n    def mod_inv(a, m):\n        return mod_pow(a, m - 2, m)\n\n    def mod_mult(a, b, m):\n        return (a * b) % m\n\n    def mod_div(a, b, m):\n        return (a * mod_inv(b, m)) % m\n\n    def mod_gcd(a, b, m):\n        return mod_mult(mod_mult(a, mod_inv(b, m), m), b, m)\n\n    def mod_lcm(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd(a, b, m)\n\n    def mod_gcd_div(a, b, m):\n        return mod_mult(mod_mult(a, mod_inv(b, m), m), b, m)\n\n    def mod_lcm_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd(a, b, m)\n\n    def mod_gcd_lcm_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div_gcd(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div_gcd_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div_gcd_div_gcd(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div_gcd_div_gcd_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div_gcd_div_gcd_div_gcd(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm_div_gcd_div_gcd_div_gcd_div_gcd_div_gcd_div(a, b, m):\n        return mod_mult(a, b, m) // mod_gcd_div(a, b, m)\n\n    def mod_gcd_lcm"
    },
    {
        "number": 898,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [int(x) for x in stdin.split()]\n    a.sort()\n    a.append(m - sum(a))\n    a.sort()\n    gcd = a[0]\n    for i in range(1, n):\n        gcd = max(gcd, a[i] // gcd)\n    return str(gcd)"
    },
    {
        "number": 899,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        edges.append((a, b, c))\n\n    def dijkstra(start: int) -> list:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in edges:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n\n    def is_connected(u: int, v: int) -> bool:\n        return dijkstra(u) == dijkstra(v)\n\n    def shortest_path(u: int, v: int) -> int:\n        return dijkstra(u)[v]\n\n    def count_not_connected(start: int) -> int:\n        count = 0\n        for v in range(1, n + 1):\n            if not is_connected(start, v):\n                count += 1\n        return count\n\n    def count_not_connected_with_shortest_path(start: int) -> int:\n        count = 0\n        for v in range(1, n + 1):\n            if not is_connected(start, v):\n                count += shortest_path(start, v)\n        return count\n\n    start = 1\n    not_connected = count_not_connected(start)\n    not_connected_with_shortest_path = count_not_connected_with_shortest_path(start)\n\n    return str(not_connected + not_connected_with_shortest_path)\n"
    },
    {
        "number": 900,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    count = 0\n    for char in stdin:\n        if char == '?':\n            count += 1\n        else:\n            count += int(char)\n    return str(count % MOD)"
    },
    {
        "number": 901,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    groups = []\n    for _ in range(m):\n        k, *v = map(int, stdin.split())\n        groups.append(v[:k])\n\n    def is_traitor(universe: int, traitor: int) -> bool:\n        for group in groups:\n            if traitor in group:\n                return True\n        return False\n\n    def is_world_ending(universe: int) -> bool:\n        for group in groups:\n            if is_traitor(universe, member) for member in group:\n                return True\n        return False\n\n    for universe in range(n):\n        if is_world_ending(universe):\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 902,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort(reverse=True)\n    power = a[0]\n    count = 1\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            count += 1\n        else:\n            if count >= k:\n                power = a[i]\n            count = 1\n    return str(power)"
    },
    {
        "number": 903,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_median(arr):\n        arr.sort()\n        return arr[len(arr) // 2]\n\n    def find_median_after_k_operations(arr, k):\n        for _ in range(k):\n            arr = [x + 1 for x in arr]\n        return find_median(arr)\n\n    return str(find_median_after_k_operations(a, k))"
    },
    {
        "number": 904,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    words = stdin.split()[1:]\n    max_volume = 0\n\n    for word in words:\n        volume = sum(1 for letter in word if letter.isupper())\n        max_volume = max(max_volume, volume)\n\n    return str(max_volume)"
    },
    {
        "number": 905,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    sugar_prices = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        sugar_prices.append((x, y))\n\n    sugar_prices.sort(key=lambda x: (-x[0], x[1]))\n\n    max_sweets = 0\n    for i in range(n):\n        if sugar_prices[i][0] <= s:\n            max_sweets = max(max_sweets, sugar_prices[i][1] // sugar_prices[i][0])\n            s -= sugar_prices[i][0] * sugar_prices[i][1] // sugar_prices[i][0]\n\n    return str(max_sweets) if max_sweets > 0 else \"-1\""
    },
    {
        "number": 906,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k == 1:\n        return str(n * m)\n    elif k == -1:\n        return str(n * m)\n    else:\n        return str(n * m)"
    },
    {
        "number": 907,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n    for i in range(m):\n        for j in range(i+1, m):\n            if pairs[i][0] == pairs[j][0] or pairs[i][1] == pairs[j][1]:\n                return \"NO\"\n    return \"YES\""
    },
    {
        "number": 908,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    strings = [input().lower() for _ in range(n)]\n\n    def reverse_strings(strings: List[str]) -> List[str]:\n        result = []\n        for s in strings:\n            result.append(s[::-1])\n        return result\n\n    def merge_strings(strings: List[str]) -> List[str]:\n        result = []\n        i, j = 0, 0\n        while i < len(strings[0]) and j < len(strings[1]):\n            if strings[0][i] < strings[1][j]:\n                result.append(strings[0][i])\n                i += 1\n            elif strings[0][i] > strings[1][j]:\n                result.append(strings[1][j])\n                j += 1\n            else:\n                result.append(strings[0][i])\n                i += 1\n                j += 1\n        result += strings[0][i:]\n        result += strings[1][j:]\n        return result\n\n    def merge_sort(strings: List[str]) -> List[str]:\n        if len(strings) <= 1:\n            return strings\n        mid = len(strings) // 2\n        left = merge_sort(strings[:mid])\n        right = merge_sort(strings[mid:])\n        return merge_strings(left + right)\n\n    def is_sorted(strings: List[str]) -> bool:\n        for i in range(len(strings) - 1):\n            if strings[i] > strings[i + 1]:\n                return False\n        return True\n\n    def min_energy(strings: List[str]) -> int:\n        sorted_strings = merge_sort(strings)\n        if not is_sorted(sorted_strings):\n            return -1\n        total_energy = 0\n        for s in sorted_strings:\n            total_energy += c[strings.index(s)]\n        return total_energy\n\n    sorted_strings = reverse_strings(strings)\n    result = min_energy(sorted_strings)\n    return str(result)"
    },
    {
        "number": 909,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = max(a + b * c, a * b + c, a * c + b)\n    return str(max_value)"
    },
    {
        "number": 910,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n % 2 == 0:\n        return -1\n\n    def is_valid(seats):\n        for i in range(1, n, 2):\n            for j in range(1, b):\n                if seats[i][j] == seats[i - 1][j] or seats[i][j] == seats[i][j - 1]:\n                    return False\n        return True\n\n    def find_seats(seats):\n        for i in range(1, n, 2):\n            for j in range(1, b):\n                if seats[i][j] == 0:\n                    for k in range(1, n, 2):\n                        if k!= i:\n                            if seats[k][j] == 0:\n                                seats[k][j] = i\n                                return seats\n                    return -1\n        return seats\n\n    seats = [[0] * b for _ in range(n)]\n    seats = find_seats(seats)\n    if seats == -1:\n        return -1\n\n    if is_valid(seats):\n        return \"\\n\".join(\" \".join(map(str, row)) for row in seats)\n    else:\n        return -1\n"
    },
    {
        "number": 911,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    p.sort()\n    t.sort()\n\n    limak_points = 0\n    radewoosh_points = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            limak_points += max(0, p[i] - c * t[i])\n        else:\n            radewoosh_points += max(0, p[i] - c * t[i])\n\n    if limak_points > radewoosh_points:\n        return \"Limak\"\n    elif radewoosh_points > limak_points:\n        return \"Radewoosh\"\n    else:\n        return \"Tie\"\n"
    },
    {
        "number": 912,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        level = 0\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                node, steps = queue.pop(0)\n                if node == n:\n                    return steps\n                for i in range(1, level + 1):\n                    next_node = node + i\n                    if next_node in visited:\n                        continue\n                    visited.add(next_node)\n                    queue.append((next_node, steps + 1))\n        return -1\n\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, s, k = map(int, stdin.split()[1:])\n        a = list(map(int, stdin.split()[2:]))\n        min_steps = bfs(s)\n        if min_steps == -1:\n            print(0)\n        else:\n            min_steps = min(min_steps, k)\n            print(min_steps)"
    },
    {
        "number": 913,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    r = list(map(int, stdin.split()[1:]))\n    b = list(map(int, stdin.split()[1:]))\n\n    max_points = 0\n    for i in range(n):\n        if r[i] == 1 and b[i] == 0:\n            max_points += 1\n        elif r[i] == 0 and b[i] == 1:\n            max_points += 1\n\n    if max_points == 0:\n        return -1\n\n    min_points = max_points\n    for i in range(n):\n        if r[i] == 1 and b[i] == 0:\n            min_points = min(min_points, 3)\n        elif r[i] == 0 and b[i] == 1:\n            min_points = min(min_points, 3)\n\n    return str(min_points)"
    },
    {
        "number": 914,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split()\n    n = int(n)\n    if len(s)!= n:\n        return -1\n\n    # Count the number of occurrences of each character in the string\n    char_count = {}\n    for c in s:\n        if c in char_count:\n            char_count[c] += 1\n        else:\n            char_count[c] = 1\n\n    # Find the maximum number of characters that can be printed on a sheet\n    max_chars = 0\n    for count in char_count.values():\n        max_chars = max(max_chars, count)\n\n    # Find the minimum number of sheets required to print all the characters\n    min_sheets = 0\n    for count in char_count.values():\n        min_sheets += count // max_chars\n\n    # Print the minimum number of sheets and a string describing a possible sheet\n    return str(min_sheets) + '\\n' + ''.join(sorted(s))"
    },
    {
        "number": 915,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    codeforces = \"codeforces\"\n    subsequences = []\n    for i in range(len(codeforces)):\n        for j in range(i + 1, len(codeforces) + 1):\n            subsequences.append(codeforces[i:j])\n    subsequences.sort(key=len)\n    shortest = \"\"\n    for subsequence in subsequences:\n        if subsequence in codeforces and len(shortest) < len(subsequence):\n            shortest = subsequence\n    return shortest"
    },
    {
        "number": 916,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    p = [int(x) - 1 for x in stdin.split()[1:]]\n    a = [list(map(int, x.split())) for x in stdin.split()[1:]]\n    a = [x for x in a]\n\n    def dfs(node, path, res):\n        if node == n:\n            res.add((tuple(path), tuple(a[node])))\n            return\n        for i in range(n):\n            if i == node or (i in p and p[i] == node):\n                continue\n            path.append(i)\n            dfs(i, path, res)\n            path.pop()\n\n    res = set()\n    dfs(0, [], res)\n    return str(len(res))"
    },
    {
        "number": 917,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m = map(int, stdin.split())\n    restrictions = []\n    for _ in range(m):\n        l, r, x = map(int, stdin.split())\n        restrictions.append((l, r, x))\n\n    def is_valid(heights: list) -> bool:\n        for i in range(len(heights) - 1):\n            if heights[i] > heights[i + 1]:\n                return False\n        return True\n\n    def max_profit(heights: list) -> int:\n        if not is_valid(heights):\n            return 0\n\n        max_profit = 0\n        for i in range(len(heights)):\n            for j in range(i + 1, len(heights)):\n                if heights[i] + heights[j] <= h:\n                    max_profit = max(max_profit, heights[i] * heights[j])\n\n        return max_profit\n\n    def max_profit_with_restrictions(heights: list) -> int:\n        if not is_valid(heights):\n            return 0\n\n        max_profit = 0\n        for i in range(len(heights)):\n            for j in range(i + 1, len(heights)):\n                if heights[i] + heights[j] <= h:\n                    max_profit = max(max_profit, heights[i] * heights[j])\n\n        for l, r, x in restrictions:\n            for i in range(l - 1, r):\n                if heights[i] > x:\n                    break\n            else:\n                max_profit = max(max_profit, x * x)\n\n        return max_profit\n\n    heights = [1] * n\n    max_profit = max_profit_with_restrictions(heights)\n\n    for i in range(1, n):\n        if max_profit_with_restrictions(heights[:i] + [i + 1] + heights[i:]) > max_profit:\n            max_profit = max_profit_with_restrictions(heights[:i] + [i + 1] + heights[i:])\n\n    return str(max_profit)\n"
    },
    {
        "number": 918,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    participants = []\n    for _ in range(n):\n        surname, region, points = stdin.split()\n        participants.append((surname, int(region), int(points)))\n\n    teams = []\n    for region in range(1, m + 1):\n        team = []\n        for i in range(2):\n            max_points = 0\n            max_index = -1\n            for j in range(n):\n                if participants[j][1] == region:\n                    if participants[j][2] > max_points:\n                        max_points = participants[j][2]\n                        max_index = j\n            if max_index == -1:\n                return \"?\"\n            team.append(participants[max_index][0])\n            participants.pop(max_index)\n        teams.append(\" \".join(team))\n\n    return \"\\n\".join(teams)\n"
    },
    {
        "number": 919,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    stages = list(stdin.strip())\n    stages.sort(key=lambda x: (ord(x) - ord('a') + 1, x))\n\n    def is_valid(stage: str) -> bool:\n        for i in range(len(stage) - 1):\n            if ord(stage[i]) - ord('a') + 1 + ord(stage[i + 1]) - ord('a') + 1 > 26:\n                return False\n        return True\n\n    for i in range(k):\n        if is_valid(stages[i]):\n            return sum(ord(x) - ord('a') + 1 for x in stages[:i] + stages[i + 1:])\n\n    return -1"
    },
    {
        "number": 920,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *guardposts = map(int, stdin.split())\n    guardposts = [list(map(int, line.split())) for line in guardposts]\n\n    def bribe(guard: int, price: int) -> bool:\n        return price >= guardposts[guard - 1][0] and price >= guardposts[guard - 1][2]\n\n    def can_sneak(guard: int, price: int) -> bool:\n        return bribe(guard, price) and bribe(guard, price + 1)\n\n    def sneak(guard: int, price: int) -> int:\n        if not can_sneak(guard, price):\n            return -1\n        return price + 1\n\n    def find_post(guard: int, price: int) -> int:\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                return i\n        return -1\n\n    def find_best_post(guard: int, price: int) -> int:\n        best_post = -1\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                post = find_post(i, price)\n                if post!= -1 and (best_post == -1 or post < best_post):\n                    best_post = post\n        return best_post\n\n    def find_best_post_with_bribe(guard: int, price: int) -> int:\n        best_post = -1\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                post = find_post(i, price)\n                if post!= -1 and bribe(i, post) and (best_post == -1 or post < best_post):\n                    best_post = post\n        return best_post\n\n    def find_best_post_with_bribe_and_sneak(guard: int, price: int) -> int:\n        best_post = -1\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                post = find_post(i, price)\n                if post!= -1 and bribe(i, post) and (best_post == -1 or post < best_post):\n                    best_post = post\n                    if bribe(i, post + 1):\n                        return post + 1\n        return best_post\n\n    def find_best_post_with_bribe_and_sneak_and_no_sneak(guard: int, price: int) -> int:\n        best_post = -1\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                post = find_post(i, price)\n                if post!= -1 and bribe(i, post) and (best_post == -1 or post < best_post):\n                    best_post = post\n                    if not bribe(i, post + 1):\n                        return post + 1\n        return best_post\n\n    def find_best_post_with_bribe_and_sneak_and_no_sneak_or_no_post(guard: int, price: int) -> int:\n        best_post = -1\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                post = find_post(i, price)\n                if post!= -1 and bribe(i, post) and (best_post == -1 or post < best_post):\n                    best_post = post\n                    if not bribe(i, post + 1) and post!= -1:\n                        return post + 1\n        return best_post\n\n    def find_best_post_with_bribe_and_sneak_and_no_sneak_or_no_post_or_no_guard(guard: int, price: int) -> int:\n        best_post = -1\n        for i in range(1, 5):\n            if can_sneak(i, price):\n                post = find_post(i, price)\n                if post!= -1 and bribe(i, post) and (best_post == -1 or post < best_post):\n                    best_post = post\n                    if not bribe(i, post + 1) and post!= -1 and i!= guard:\n                        return post + 1\n        return best_post\n\n    def find_best_post_with_bribe_and_sneak_and_no_sneak_"
    },
    {
        "number": 921,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def can_pour(cup_i, cup_j):\n        return a[cup_i] > a[cup_j]\n\n    def pour_in_cup(cup_i, volume):\n        if volume >= a[cup_i] / 2:\n            return volume\n        else:\n            return a[cup_i]\n\n    def pour_all_teas(cup_i, volume):\n        if volume >= a[cup_i] / 2:\n            return volume\n        else:\n            return a[cup_i]\n\n    def can_pour_all_teas(cup_i, volume):\n        for cup_j in range(cup_i + 1, n):\n            if can_pour(cup_i, cup_j) and volume >= pour_in_cup(cup_j, volume):\n                return False\n        return True\n\n    def pour_all_teas_and_satisfy_conditions(cup_i, volume):\n        if can_pour_all_teas(cup_i, volume):\n            return pour_all_teas(cup_i, volume)\n        else:\n            return -1\n\n    def pour_cups(volume):\n        for cup_i in range(n):\n            if volume >= a[cup_i] / 2:\n                volume -= pour_in_cup(cup_i, volume)\n            else:\n                volume -= pour_in_cup(cup_i, volume)\n                volume -= pour_all_teas_and_satisfy_conditions(cup_i, volume)\n                if volume < 0:\n                    return -1\n        return volume\n\n    result = pour_cups(w)\n    if result == -1:\n        return -1\n    else:\n        return \" \".join(map(str, result))\n"
    },
    {
        "number": 922,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n\n    def count_values(d: list) -> int:\n        count = 0\n        for i in range(1, max(d) + 1):\n            if all(i not in d for j in range(n)):\n                count += 1\n        return count\n\n    b = [count_values(d[:i] + d[i+1:]) for i in range(n)]\n    return \" \".join(map(str, b))"
    },
    {
        "number": 923,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(int, a))\n    a.sort()\n    if a == list(range(n)):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 924,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alice_lucky_days = list(map(int, stdin.split()))\n    bob_lucky_days = list(map(int, stdin.split()))\n\n    alice_lucky_days.sort()\n    bob_lucky_days.sort()\n\n    alice_lucky_days_count = 0\n    bob_lucky_days_count = 0\n\n    for i in range(len(alice_lucky_days)):\n        if alice_lucky_days[i] == bob_lucky_days[i]:\n            alice_lucky_days_count += 1\n            bob_lucky_days_count += 1\n        else:\n            break\n\n    return str(max(alice_lucky_days_count, bob_lucky_days_count))\n"
    },
    {
        "number": 925,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(10):\n        if n % 10 == i:\n            count += 1\n    return str(count)"
    },
    {
        "number": 926,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    stones = []\n    for i in range(n):\n        a, b, c = map(int, stdin.split()[1:4])\n        stones.append((a, b, c))\n    stones.sort(key=lambda x: (x[0], x[1], x[2]))\n    stones = list(set(stones))\n    k = 2\n    result = []\n    for stone in stones:\n        if len(result) >= k:\n            break\n        if len(result) == 0:\n            result.append(stone)\n        else:\n            for i in range(len(result)):\n                if stone[0] == result[i][0] and stone[1] == result[i][1] and stone[2] == result[i][2]:\n                    break\n            else:\n                result.append(stone)\n    return str(k) +'' +''.join(map(str, result))"
    },
    {
        "number": 927,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(num: int) -> bool:\n        count = [0] * 10\n        for i in range(len(num)):\n            count[a[i] - 1] += 1\n            if count[a[i] - 1] > 2:\n                return False\n        return True\n\n    def find_largest_valid(start: int) -> int:\n        if start > 999999999:\n            return 0\n        if is_valid(str(start)):\n            return start\n        return find_largest_valid(start + 1)\n\n    return str(find_largest_valid(1))"
    },
    {
        "number": 928,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if sum(A[i:j + 1]) >= K:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 929,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    coins = []\n    for i in range(H):\n        row = list(map(int, stdin.split()))\n        coins.append(row)\n\n    def is_valid(y, x, coins):\n        return 0 <= y < H and 0 <= x < W and coins[y][x] % 2 == 0\n\n    def move_coin(y, x, coins):\n        coins[y][x] -= 1\n        if coins[y][x] == 0:\n            coins[y][x] = 9\n        else:\n            coins[y][x] += 1\n\n    def find_adjacent(y, x, coins):\n        adjacent = []\n        if y > 0:\n            adjacent.append((y - 1, x))\n        if x > 0:\n            adjacent.append((y, x - 1))\n        if y < H - 1:\n            adjacent.append((y + 1, x))\n        if x < W - 1:\n            adjacent.append((y, x + 1))\n        return adjacent\n\n    def max_even_coins(coins):\n        max_coins = 0\n        for row in coins:\n            for coin in row:\n                if coin % 2 == 0:\n                    max_coins = max(max_coins, coin)\n        return max_coins\n\n    def find_valid_moves(y, x, coins):\n        valid_moves = []\n        adjacent = find_adjacent(y, x, coins)\n        for a in adjacent:\n            if is_valid(a[0], a[1], coins):\n                valid_moves.append(a)\n        return valid_moves\n\n    def find_best_move(coins):\n        max_even_coins = max_even_coins(coins)\n        best_move = None\n        for y in range(H):\n            for x in range(W):\n                if is_valid(y, x, coins):\n                    valid_moves = find_valid_moves(y, x, coins)\n                    if len(valid_moves) > 0:\n                        if max_even_coins - coins[y][x] >= 0:\n                            best_move = (y, x, valid_moves[0][0], valid_moves[0][1])\n                            break\n        return best_move\n\n    def print_best_move(best_move):\n        y, x, y', x' = best_move\n        print(f\"{len(coins)}\")\n        print(f\"{y} {x} {y'} {x'}\")\n\n    coins = [[coin for coin in row if coin!= 0] for row in coins]\n    best_move = find_best_move(coins)\n    if best_move:\n        print_best_move(best_move)\n    else:\n        print(\"Wrong Answer\")\n\n    return \"\"\n"
    },
    {
        "number": 930,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def comb(n, r):\n        if r > n:\n            return 0\n        if r == 0 or r == n:\n            return 1\n        return comb(n - 1, r - 1) * (n - r + 1) // r\n\n    def count_combinations(c1, c2, c3):\n        return comb(n, c1) * comb(n - c1, c2) * comb(n - c1 - c2, c3)\n\n    count = 0\n    for c1 in range(n + 1):\n        for c2 in range(min(c1, n - c1) + 1):\n            for c3 in range(min(c1 + c2, n - c1 - c2) + 1):\n                count += count_combinations(c1, c2, c3)\n                count %= MOD\n\n    return str(count)"
    },
    {
        "number": 931,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, z, p = map(int, stdin.split())\n    matrix = []\n    for _ in range(p):\n        row, col = map(int, stdin.split())\n        matrix.append((row, col))\n\n    for _ in range(z):\n        matrix = rotate_matrix(matrix, 1)\n\n    for _ in range(y):\n        matrix = rotate_matrix(matrix, 0)\n\n    for _ in range(x):\n        matrix = rotate_matrix(matrix, 1)\n\n    new_matrix = []\n    for row, col in matrix:\n        new_row, new_col = rotate_matrix(row, col, 1)\n        new_matrix.append((new_row, new_col))\n\n    result = []\n    for row, col in new_matrix:\n        result.append(f\"{row} {col}\")\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 932,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    A = []\n    for _ in range(m):\n        A.append(list(map(int, stdin.split())))\n    B = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            for k in range(m):\n                for l in range(n):\n                    if A[i][j] == 1 or A[k][l] == 1:\n                        B[i][j] = 1\n                        break\n    for i in range(m):\n        print(\" \".join(map(str, B[i])))\n    return \"YES\" if any(any(row) for row in B) else \"NO\""
    },
    {
        "number": 933,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n == 1:\n        return s\n\n    # Find the minimum number of letters to delete\n    min_delete = n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if s[i:j] == s[j:k] == s[k:]:\n                    min_delete = min(min_delete, j - i)\n\n    # Delete the minimum number of letters\n    t = s[:min_delete] + s[min_delete + 1:]\n\n    return t\n"
    },
    {
        "number": 934,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    table_card, *hand_cards = stdin.split()\n    table_rank, table_suit = table_card[0], table_card[1]\n    hand_ranks = [card[0] for card in hand_cards]\n    hand_suits = [card[1] for card in hand_cards]\n\n    if table_rank in \"23456789TJQKA\" and table_suit in \"DCS\" and any(rank in \"23456789TJQKA\" and suit in \"DCS\" for rank, suit in zip(hand_ranks, hand_suits)):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 935,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            grid[i][j] = i * m + j + 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] % m == 0:\n                grid[i][j] = 0\n            elif grid[i][j] % m == 1:\n                grid[i][j] = 1\n    for i in"
    },
    {
        "number": 936,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    likes = list(map(int, stdin.split()))\n    likes.sort(reverse=True)\n    return str(likes[0])"
    },
    {
        "number": 937,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    max_theorems = 0\n    current_theorems = 0\n\n    for i in range(n):\n        if t[i] == 1:\n            current_theorems += a[i]\n            max_theorems = max(max_theorems, current_theorems)\n        else:\n            current_theorems = 0\n\n    return str(max_theorems)"
    },
    {
        "number": 938,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_notes = a + b\n    max_hours = max_notes * 2\n    lecture_notes = [i for i in range(1, max_notes + 1)]\n    lecture_notes.sort()\n    lecture_notes = lecture_notes[:max_notes]\n    lecture_notes_first_day = lecture_notes[:a]\n    lecture_notes_second_day = lecture_notes[a:]\n    lecture_notes_first_day.sort()\n    lecture_notes_second_day.sort()\n    lecture_notes_first_day = lecture_notes_first_day[:max_hours]\n    lecture_notes_second_day = lecture_notes_second_day[:max_hours]\n    lecture_notes_first_day.sort()\n    lecture_notes_second_day.sort()\n    return f\"{len(lecture_notes_first_day)} {lecture_notes_first_day} {len(lecture_notes_second_day)} {lecture_notes_second_day}\""
    },
    {
        "number": 939,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dancers = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def is_valid(dancers: list) -> bool:\n        dancers_set = set(dancers)\n        return len(dancers_set) == 3\n\n    def find_valid_colors(dancers: list) -> list:\n        colors = [1, 2, 3]\n        for dancer in dancers:\n            if dancer in colors:\n                colors.remove(dancer)\n        return colors\n\n    def find_valid_dances(dancers: list) -> list:\n        valid_dances = []\n        for dancer in dancers:\n            valid_dances.append(dancer)\n            for i in range(len(dancers)):\n                if i!= dancer - 1 and dancers[i] == dancer:\n                    valid_dances.pop()\n                    break\n        return valid_dances\n\n    def find_valid_combinations(dancers: list) -> list:\n        valid_combinations = []\n        for i in range(len(dancers)):\n            for j in range(i + 1, len(dancers)):\n                for k in range(j + 1, len(dancers)):\n                    valid_combinations.append([dancers[i], dancers[j], dancers[k]])\n        return valid_combinations\n\n    valid_dances = find_valid_dances(dancers)\n    valid_combinations = find_valid_combinations(dancers)\n\n    for valid_combination in valid_combinations:\n        if is_valid(valid_combination):\n            colors = find_valid_colors(valid_combination)\n            if colors:\n                return \" \".join(map(str, colors))\n\n    return \" \".join(map(str, find_valid_colors(dancers)))\n"
    },
    {
        "number": 940,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    min_time = 0\n    for i in range(1, 101):\n        if a + i * b + i * i * c > 0:\n            min_time = i\n            break\n    return str(min_time)"
    },
    {
        "number": 941,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    n = 0\n    for i in range(k):\n        n += a[i] * b ** (k - i - 1)\n\n    if n % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\""
    },
    {
        "number": 942,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def dfs(hat_type, used_hat_types):\n        if len(used_hat_types) == n:\n            return True\n        if hat_type > n:\n            return False\n\n        for i in range(1, n + 1):\n            if i not in used_hat_types and hat_type!= i:\n                used_hat_types.add(i)\n                if dfs(hat_type + 1, used_hat_types):\n                    return True\n                used_hat_types.remove(i)\n\n        return False\n\n    used_hat_types = set()\n    if dfs(1, used_hat_types):\n        return \"Possible\\n\" + \" \".join(map(str, used_hat_types))\n    else:\n        return \"Impossible\\n\""
    },
    {
        "number": 943,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    even_sum = 0\n    for num in arr:\n        if num % 2 == 0:\n            even_sum += num\n    return str(even_sum)"
    },
    {
        "number": 944,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    roads = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:])\n        roads.append((u, v))\n\n    def bfs(start, visited):\n        queue = [(start, 0)]\n        while queue:\n            city, day = queue.pop(0)\n            if city not in visited:\n                visited.add(city)\n                for road in roads:\n                    if road[0] == city and road[1] not in visited:\n                        queue.append((road[1], day + 1))\n                    elif road[1] == city and road[0] not in visited:\n                        queue.append((road[0], day + 1))\n\n    def dfs(start, visited, days):\n        if start not in visited:\n            visited.add(start)\n            for road in roads:\n                if road[0] == start and road[1] not in visited:\n                    dfs(road[1], visited, days)\n                elif road[1] == start and road[0] not in visited:\n                    dfs(road[0], visited, days)\n            days.append(start)\n\n    visited = set()\n    bfs(1, visited)\n    days = []\n    dfs(1, visited, days)\n\n    k = len(days)\n    result = []\n    for day in days:\n        result.append(f\"{day} \")\n        for road in roads:\n            if road[0] == day:\n                result[-1] += f\"{road[1]} \"\n            elif road[1] == day:\n                result[-1] += f\"{road[0]} \"\n        result[-1] = result[-1].strip()\n\n    return f\"{k}\\n{' '.join(result)}\\n\""
    },
    {
        "number": 945,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = list(map(int, stdin.split()[1:]))\n\n    def is_self_intersecting(points: list) -> bool:\n        for i in range(len(points) - 1):\n            x1, y1 = points[i]\n            x2, y2 = points[i + 1]\n            if x1 == x2 or y1 == y2:\n                continue\n            if (x1 - x2) * (y1 - y2)!= (y1 - y2) * (x1 - x2):\n                return True\n        return False\n\n    return \"yes\" if is_self_intersecting(points) else \"no\""
    },
    {
        "number": 946,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *responses = map(int, stdin.split())\n    easy_count = 0\n    hard_count = 0\n\n    for response in responses:\n        if response == 0:\n            easy_count += 1\n        else:\n            hard_count += 1\n\n    if easy_count >= hard_count:\n        return \"EASY\"\n    else:\n        return \"HARD\""
    },
    {
        "number": 947,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        a = 1\n        b = 1\n        while a + b <= n:\n            a += 1\n            b += 1\n        print(a, b)"
    },
    {
        "number": 948,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    image = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    faces = 0\n    for i in range(n):\n        for j in range(m):\n            if image[i][j] == 'f' and image[i][j+1] == 'a' and image[i][j+2] == 'c' and image[i][j+3] == 'e':\n                faces += 1\n\n    return str(faces)"
    },
    {
        "number": 949,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def is_divisible(a, b, d):\n        return a % d == 0 and b % d == 0\n\n    def find_d(a, b):\n        d = 1\n        while not is_divisible(a, b, d):\n            d += 1\n        return d\n\n    d = find_d(a, b)\n    return str(d)"
    },
    {
        "number": 950,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    strings = []\n    for _ in range(n):\n        strings.append(stdin.split()[1])\n\n    def is_valid(password: str) -> bool:\n        has_digit = False\n        has_lower = False\n        has_symbol = False\n        for char in password:\n            if char.isdigit():\n                has_digit = True\n            elif char.islower():\n                has_lower = True\n            elif char in ['#', '*', '&']:\n                has_symbol = True\n            if has_digit and has_lower and has_symbol:\n                return True\n        return False\n\n    def min_operations(password: str) -> int:\n        operations = 0\n        for i in range(len(password)):\n            if password[i] == '#':\n                operations += 1\n            elif password[i] == '*':\n                operations += 2\n            elif password[i] == '&':\n                operations += 3\n            else:\n                operations += 1\n        return operations\n\n    def move_pointer(password: str, index: int, direction: int) -> str:\n        if direction == 1:\n            return password[:index] + password[index + 1:]\n        elif direction == 2:\n            return password[:index] + password[index + 2:]\n        else:\n            return password[:index] + password[index + 3:]\n\n    def find_valid_password(strings: List[str]) -> str:\n        password = '#' * m\n        for i in range(m):\n            if password[i] == '#':\n                password = move_pointer(password, i, 1)\n            elif password[i] == '*':\n                password = move_pointer(password, i, 2)\n            elif password[i] == '&':\n                password = move_pointer(password, i, 3)\n            else:\n                password = move_pointer(password, i, 1)\n        return password\n\n    valid_password = find_valid_password(strings)\n    if is_valid(valid_password):\n        return str(min_operations(valid_password))\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 951,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    count = 0\n    while n!= 0:\n        n //= 10\n        count += 1\n    return str(count)"
    },
    {
        "number": 952,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    crossroads = [[] for _ in range(n + 1)]\n    for u, v, c in map(lambda x: list(map(int, x.split())), stdin.split('\\n')[1:]):\n        crossroads[u].append((v, c))\n        crossroads[v].append((u, c))\n\n    def dfs(u, visited):\n        visited.add(u)\n        for v, c in crossroads[u]:\n            if v not in visited:\n                dfs(v, visited)\n\n    def bfs(u, visited):\n        queue = [(u, 0)]\n        visited.add(u)\n        while queue:\n            v, c = queue.pop(0)\n            for w, d in crossroads[v]:\n                if w not in visited:\n                    visited.add(w)\n                    queue.append((w, c + d))\n\n    def count_reverse_roads(visited):\n        count = 0\n        for u in visited:\n            for v, c in crossroads[u]:\n                if v not in visited:\n                    count += 1\n        return count\n\n    def find_reverse_roads(visited):\n        reverse_roads = []\n        for u in visited:\n            for v, c in crossroads[u]:\n                if v not in visited:\n                    reverse_roads.append((u, v, c))\n        return reverse_roads\n\n    visited = set()\n    dfs(1, visited)\n    bfs(1, visited)\n    k = count_reverse_roads(visited)\n    reverse_roads = find_reverse_roads(visited)\n\n    return f\"{k} {len(reverse_roads)} {' '.join(map(str, r[0] for r in reverse_roads))}\""
    },
    {
        "number": 953,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    A = []\n    for _ in range(n):\n        A.append(list(map(int, stdin.split()[1:n+1])))\n\n    def is_pretty(p: list, A: list) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if A[i][p[i] - 1] == A[j][p[j] - 1]:\n                    return False\n        return True\n\n    def swap(p: list, A: list, i: int, j: int) -> None:\n        p[i], p[j] = p[j], p[i]\n        A[i][p[i] - 1], A[j][p[j] - 1] = A[j][p[j] - 1], A[i][p[i] - 1]\n\n    def find_pretty(p: list, A: list) -> list:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if A[i][p[i] - 1] == A[j][p[j] - 1]:\n                    return p[:i] + [j + 1] + p[i:]\n        return []\n\n    def find_min_permutation(A: list) -> list:\n        min_permutation = [1] * n\n        for i in range(n):\n            min_permutation[i] = i + 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if A[i][min_permutation[i] - 1] > A[j][min_permutation[j] - 1]:\n                    min_permutation[i], min_permutation[j] = min_permutation[j], min_permutation[i]\n        return min_permutation\n\n    min_permutation = find_min_permutation(A)\n    if is_pretty(min_permutation, A):\n        return \" \".join(map(str, min_permutation))\n    else:\n        return \" \".join(map(str, find_pretty(min_permutation, A)))"
    },
    {
        "number": 954,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    n = len(s)\n    result = set()\n    for i in range(1, n + 1):\n        result.add(s[-i:])\n    return str(len(result))"
    },
    {
        "number": 955,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    juices = []\n    for i in range(n):\n        price, vitamins = stdin.split()[1:3]\n        juices.append((int(price), set(vitamins)))\n    juices.sort(key=lambda x: (-x[0], x[1]))\n    total_price = 0\n    vitamin_count = [0] * 3\n    for price, vitamins in juices:\n        if vitamin_count[0] < 1 and \"A\" in vitamins:\n            vitamin_count[0] += 1\n            total_price += price\n        elif vitamin_count[1] < 1 and \"B\" in vitamins:\n            vitamin_count[1] += 1\n            total_price += price\n        elif vitamin_count[2] < 1 and \"C\" in vitamins:\n            vitamin_count[2] += 1\n            total_price += price\n        else:\n            break\n    if total_price == 0:\n        return -1\n    return total_price"
    },
    {
        "number": 957,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    if 'heidi' in s:\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 958,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def is_nice(s: str) -> bool:\n        distances = [0] * 26\n        for i in range(len(s) - 1):\n            distances[ord(s[i]) - ord('a')] += abs(ord(s[i + 1]) - ord(s[i]))\n        return sum(distances) == k\n\n    for i in range(ord('a'), ord('z') + 1):\n        s_prime = s[:i] + chr(i) + s[i + 1:]\n        if is_nice(s_prime):\n            return s_prime\n\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 959,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, mod = map(int, stdin.split())\n    matrix = []\n    for _ in range(m):\n        row = list(stdin.readline().strip())\n        matrix.append(row)\n\n    count = 0\n    for row in matrix:\n        if row.count('1') == 2:\n            count += 1\n\n    return str(count % mod)"
    },
    {
        "number": 960,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = 1\n    while True:\n        if (x * k) % n == n:\n            return str(x)\n        x += 1"
    },
    {
        "number": 961,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    a = sorted(a)\n    total_comfort = 0\n    for i in range(len(a) - 1):\n        total_comfort += a[i] ^ a[i + 1]\n    return str(total_comfort)"
    },
    {
        "number": 962,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(u: int, visited: set) -> None:\n        visited.add(u)\n        for v, _ in edges:\n            if v not in visited:\n                dfs(v, visited)\n\n    def bfs(u: int, visited: set) -> None:\n        queue = deque([u])\n        visited.add(u)\n        while queue:\n            v = queue.popleft()\n            for w, _ in edges:\n                if w not in visited:\n                    visited.add(w)\n                    queue.append(w)\n\n    def induced_subgraph(G: List[List[int]], in_degree: List[int], out_degree: List[int]) -> List[int]:\n        in_degree_1 = [1] * n\n        out_degree_1 = [1] * n\n        for u, v in edges:\n            in_degree_1[u] += 1\n            out_degree_1[v] += 1\n\n        for u in range(n):\n            if in_degree_1[u] == 1 and out_degree_1[u] == 1:\n                bfs(u, set())\n\n        induced_subgraph_vertices = []\n        for u in range(n):\n            if in_degree_1[u] == 1 and out_degree_1[u] == 1:\n                induced_subgraph_vertices.append(u)\n\n        return induced_subgraph_vertices\n\n    G = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        G[u].append(v)\n        G[v].append(u)\n\n    in_degree = [0] * (n + 1)\n    out_degree = [0] * (n + 1)\n    for u in range(1, n + 1):\n        in_degree[u] = len(G[u])\n        out_degree[u] = len(G[u])\n\n    induced_subgraph_vertices = induced_subgraph(G, in_degree, out_degree)\n\n    if not induced_subgraph_vertices:\n        return \"-1\"\n\n    print(len(induced_subgraph_vertices))\n    for u in induced_subgraph_vertices:\n        print(u)\n\n    return \"\"\n"
    },
    {
        "number": 963,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    L, R = map(int, stdin.split())\n    S = set()\n    for i in range(K):\n        S.add(L[i])\n        S.add(R[i])\n    S.add(N)\n    S.add(N + 1)\n    S.add(2 * N)\n    S.add(3 * N)\n    S.add(4 * N)\n    S.add(5 * N)\n\n    MOD = 998244353\n    count = 0\n    for i in range(1, N + 1):\n        if i in S:\n            count += 1\n            count %= MOD\n\n    return str(count)"
    },
    {
        "number": 964,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n\n    if x1 + y1 + x2 + y2 + x3 + y3 > 100:\n        return \"-1\"\n\n    def rotate(x, y, angle):\n        return (x * math.cos(angle) - y * math.sin(angle), x * math.sin(angle) + y * math.cos(angle))\n\n    def overlap(x1, y1, x2, y2, x3, y3):\n        return x1 < x2 <= x3 or x2 < x1 <= x3 or y1 < y2 <= y3 or y2 < y1 <= y3\n\n    def is_valid(x1, y1, x2, y2, x3, y3):\n        return not overlap(x1, y1, x2, y2, x3, y3) and not overlap(x2, y2, x3, y3, x1, y1) and not overlap(x3, y3, x1, y1, x2, y2)\n\n    def find_valid_side(x1, y1, x2, y2, x3, y3):\n        angle = math.atan2(y2 - y1, x2 - x1)\n        for i in range(4):\n            x, y = rotate(x1, y1, angle + i * math.pi / 2)\n            if is_valid(x, y, x2, y2, x3, y3):\n                return i, x, y\n        return None\n\n    def print_rectangle(x1, y1, x2, y2, x3, y3):\n        for i in range(4):\n            x, y = rotate(x1, y1, i * math.pi / 2)\n            print(\"A\" * int(x1 * y1 / (x2 - x1)), end=\"\")\n        print()\n        for i in range(4):\n            x, y = rotate(x2, y2, i * math.pi / 2)\n            print(\"B\" * int(x2 * y2 / (x3 - x2)), end=\"\")\n        print()\n        for i in range(4):\n            x, y = rotate(x3, y3, i * math.pi / 2)\n            print(\"C\" * int(x3 * y3 / (x1 - x3)), end=\"\")\n        print()\n\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n    valid_side, x, y = find_valid_side(x1, y1, x2, y2, x3, y3)\n    if valid_side is None:\n        return \"-1\"\n\n    print_rectangle(x1, y1, x2, y2, x3, y3)\n    print(valid_side)\n    return str(valid_side)\n"
    },
    {
        "number": 965,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    status = [char.upper() for char in stdin.split()[1]]\n\n    def can_show_hand(player_status: str) -> bool:\n        return player_status == \"ALLIN\" or player_status == \"FOLDED\"\n\n    def count_cows(player_status: str) -> int:\n        return sum(1 for status in status if status == player_status and can_show_hand(status))\n\n    cows_with_hand = count_cows(\"ALLIN\") + count_cows(\"IN\")\n    return str(cows_with_hand)"
    },
    {
        "number": 966,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin)\n    if y == 1987:\n        return \"2013\"\n    elif y == 2013:\n        return \"2014\"\n    else:\n        for i in range(2014, 1986, -1):\n            if len(set(str(i))) == 9:\n                return str(i)\n        return \"2014\""
    },
    {
        "number": 967,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    count = 0\n    for i in range(n):\n        if a[i]!= i + 1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 968,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = list(p)\n    handles = [f\"{f}_{l}\" for f, l in zip(stdin.split()[1::2], stdin.split()[::2])]\n    handles.sort()\n    for i in range(n):\n        if handles[i]!= f\"{handles[p[i]-1]}_{handles[p[i]-1]}\":\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 969,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n\n    def find_substring(s: list, t: list) -> int:\n        for i in range(len(s) - len(t) + 1):\n            if s[i:i + len(t)] == t:\n                return i\n        return -1\n\n    def find_coatings(s: list, t: list) -> int:\n        coatings = 0\n        for i in range(len(s) - len(t) + 1):\n            substring = s[i:i + len(t)]\n            if substring in t:\n                coatings += 1\n        return coatings\n\n    substring_index = find_substring(s, t)\n    if substring_index == -1:\n        return -1\n\n    coatings = find_coatings(s, t)\n    if coatings == 0:\n        return -1\n\n    return str(coatings)\n\n\ndef"
    },
    {
        "number": 970,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pieces = list(map(int, stdin.split()[1].split()))\n    black_pieces = [piece for piece in pieces if piece % 2 == 0]\n    white_pieces = [piece for piece in pieces if piece % 2!= 0]\n\n    def is_valid_move(piece: int, new_position: int) -> bool:\n        return 0 <= new_position < n and (piece % 2 == 0 and new_position % 2 == 0 or piece % 2!= 0 and new_position % 2!= 0)\n\n    def is_valid_position(piece: int, new_position: int) -> bool:\n        return is_valid_move(piece, new_position) and (piece % 2 == 0 and new_position % 2 == 0 or piece % 2!= 0 and new_position % 2!= 0)\n\n    def is_valid_board(pieces: List[int]) -> bool:\n        return all(is_valid_position(piece, new_position) for piece, new_position in zip(pieces, pieces[1:]))\n\n    def min_moves(pieces: List[int], color: int) -> int:\n        moves = 0\n        for piece in pieces:\n            if piece % 2 == color:\n                for new_position in range(n):\n                    if is_valid_move(piece, new_position):\n                        if is_valid_position(piece, new_position):\n                            moves += 1\n        return moves\n\n    black_moves = min_moves(black_pieces, 0)\n    white_moves = min_moves(white_pieces, 1)\n\n    return str(min(black_moves, white_moves))"
    },
    {
        "number": 971,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    waste_count = 0\n    juice_count = 0\n\n    for i in range(n):\n        if a[i] > b:\n            waste_count += 1\n            continue\n\n        if a[i] > d:\n            waste_count = 0\n            juice_count += 1\n            continue\n\n        juice_count += 1\n\n    return str(juice_count)"
    },
    {
        "number": 972,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_convex(i, j, direction):\n        if direction == 0:\n            return i + 1 < n and grid[i + 1][j] == \"B\"\n        elif direction == 1:\n            return j + 1 < m and grid[i][j + 1] == \"B\"\n        elif direction == 2:\n            return i - 1 >= 0 and grid[i - 1][j] == \"B\"\n        else:\n            return j - 1 >= 0 and grid[i][j - 1] == \"B\"\n\n    def dfs(i, j, direction, visited):\n        if (i, j) in visited:\n            return False\n\n        visited.add((i, j))\n\n        if grid[i][j] == \"B\":\n            if direction == 0:\n                return dfs(i + 1, j, 1, visited)\n            elif direction == 1:\n                return dfs(i, j + 1, 2, visited)\n            elif direction == 2:\n                return dfs(i - 1, j, 0, visited)\n            else:\n                return dfs(i, j - 1, 3, visited)\n        else:\n            return True\n\n    convex = True\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == \"B\":\n                visited = set()\n                if not dfs(i, j, 0, visited):\n                    convex = False\n                    break\n\n    return \"YES\" if convex else \"NO\"\n"
    },
    {
        "number": 973,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    pasture = [list(row) for row in stdin.split()[1:]]\n\n    def is_safe(row: int, col: int) -> bool:\n        return pasture[row][col] == '.' or pasture[row][col] == 'S'\n\n    def is_safe_from_wolf(row: int, col: int) -> bool:\n        return pasture[row][col] == '.' or pasture[row][col] == 'S' or pasture[row][col] == 'W'\n\n    def is_safe_from_dog(row: int, col: int) -> bool:\n        return pasture[row][col] == '.' or pasture[row][col] == 'D'\n\n    def is_safe_from_wolf_or_dog(row: int, col: int) -> bool:\n        return pasture[row][col] == '.' or pasture[row][col] == 'S' or pasture[row][col] == 'W' or pasture[row][col] == 'D'\n\n    def find_safe_cell(row: int, col: int) -> tuple:\n        if is_safe(row, col):\n            return row, col\n\n        if is_safe_from_wolf(row, col):\n            return row, col\n\n        if is_safe_from_dog(row, col):\n            return row, col\n\n        if is_safe_from_wolf_or_dog(row, col):\n            return row, col\n\n        for i in range(4):\n            new_row, new_col = row + i, col\n            if 0 <= new_row < R and 0 <= new_col < C and is_safe(new_row, new_col):\n                return new_row, new_col\n\n        return -1, -1\n\n    def place_dog(row: int, col: int) -> None:\n        if pasture[row][col] == 'D':\n            return\n\n        if pasture[row][col] == 'S':\n            pasture[row][col] = 'D'\n            return\n\n        if pasture[row][col] == 'W':\n            pasture[row][col] = 'D'\n            return\n\n        if pasture[row][col] == '.':\n            pasture[row][col] = 'D'\n            return\n\n        if pasture[row][col] == 'S' or pasture[row][col] == 'W' or pasture[row][col] == 'D':\n            return\n\n        place_dog(row, col + 1)\n        place_dog(row, col - 1)\n        place_dog(row + 1, col)\n        place_dog(row - 1, col)\n\n    def place_dogs() -> None:\n        for row in range(R):\n            for col in range(C):\n                if pasture[row][col] == 'S':\n                    row, col = find_safe_cell(row, col)\n                    if row!= -1 and col!= -1:\n                        place_dog(row, col)\n\n    place_dogs()\n\n    for row in pasture:\n        print(''.join(row))\n\n    return 'Yes' if 'D' not in ''.join(row) else 'No'\n"
    },
    {
        "number": 974,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    stack = []\n    count = 0\n\n    for line in stdin.split('\\n')[1:]:\n        if line.startswith('add'):\n            stack.append(int(line.split()[1]))\n        elif line.startswith('remove'):\n            if stack:\n                stack.pop()\n            else:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 975,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sherlock_card = list(map(int, stdin.split()[1]))\n    moriarty_card = list(map(int, stdin.split()[2]))\n\n    flicks_sherlock = 0\n    flicks_moriarty = 0\n\n    for i in range(n):\n        if sherlock_card[i]!= moriarty_card[i]:\n            if sherlock_card[i] < moriarty_card[i]:\n                flicks_sherlock += 1\n            else:\n                flicks_moriarty += 1\n\n    return str(flicks_sherlock) + \" \" + str(flicks_moriarty)"
    },
    {
        "number": 976,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    best_moments = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        best_moments.append((l, r))\n    best_moments.sort(key=lambda x: x[0])\n    total_minutes = best_moments[-1][1]\n    result = 0\n    for i in range(n):\n        result += best_moments[i][1] - best_moments[i][0] - x\n    return str(result)"
    },
    {
        "number": 977,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def f(x: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if a[i - 1] <= x:\n                count += 1\n        return count\n\n    good_x = []\n    for x in range(1, n + 1):\n        if is_prime(x) and f(x) % p == 0:\n            good_x.append(x)\n\n    good_x.sort()\n    print(len(good_x))\n    print(*good_x)\n\n    return \"\"\n"
    },
    {
        "number": 978,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.split()[0])\n    table = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n    table = [[1 if '.' in row else row for row in col] for col in table]\n   "
    },
    {
        "number": 979,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    result = 1\n    for i in range(n):\n        for j in range(i+1, n):\n            result *= abs(a[i] - a[j])\n            result %= m\n    return str(result)"
    },
    {
        "number": 980,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    strings = stdin.split('\\n')[1:]\n    for i in range(k):\n        strings[i] = strings[i].lower()\n    for i in range(k):\n        for j in range(i + 1, k):\n            if strings[i][j], strings[i][j + 1] == strings[j][i], strings[j][i + 1] == strings[i][j]:\n                strings[i], strings[j] = strings[j], strings[i]\n                break\n    for s in strings:\n        if s == strings[0]:\n            continue\n        for i in range(len(s) - 1):\n            if s[i], s[i + 1] == s[i + 1], s[i + 1], s[i + 2] == s[i + 2]:\n                return s\n    return -1"
    },
    {
        "number": 981,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v, *a = map(int, stdin.split())\n    if v > 10**6 or len(a)!= 9:\n        return -1\n\n    max_num = 0\n    for i in range(1, 10):\n        if a[i] > 10**5:\n            return -1\n        max_num = max(max_num, a[i] * (10**i - 1))\n\n    if max_num > v:\n        return -1\n\n    return str(max_num)"
    },
    {
        "number": 982,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        l, r = map(int, stdin.split()[1:])\n        if l % r == 0:\n            a = l // r\n        else:\n            a = l // r + 1\n        if a * r > l:\n            print(\"NO\")\n        else:\n            print(\"YES\")"
    },
    {
        "number": 983,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_value(i, j, k):\n        return max(p * a[i] + q * a[j] + r * a[k], p * a[j] + q * a[i] + r * a[k], p * a[k] + q * a[i] + r * a[j])\n\n    max_value_i = max_value(1, 2, 3)\n    max_value_j = max_value(2, 1, 3)\n    max_value_k = max_value(3, 1, 2)\n\n    return str(max(max_value_i, max_value_j, max_value_k))"
    },
    {
        "number": 984,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tree = []\n    for _ in range(n):\n        v, l, r = map(int, stdin.split()[1:])\n        tree.append((v, l, r))\n    root = TreeNode(tree[0][0], None, None)\n    for i in range(1, n):\n        root.insert(tree[i][0], tree[i][1], tree[i][2])\n    fail_count = 0\n    def find(t: TreeNode, x: int) -> bool:\n        if t is None:\n            return False\n        if t.value == x:\n            return True\n        if x < t.value:\n            return find(t.left, x)\n        else:\n            return find(t.right, x)\n    for i in range(1, 1000001):\n        if find(root, i):\n            print(fail_count)\n            return\n        else:\n            fail_count += 1\n    print(fail_count)\n\nclass TreeNode:\n    def __init__(self, value: int, left: 'TreeNode' = None, right: 'TreeNode' = None):\n        self.value = value\n        self.left = left\n        self.right = right\n\n    def insert(self, value: int, left: int, right: int) -> None:\n        if value < self.value:\n            if self.left is None:\n                self.left = TreeNode(value, None, None)\n            else:\n                self.left.insert(value, left, right)\n        else:\n            if self.right is None:\n                self.right = TreeNode(value, None, None)\n            else:\n                self.right.insert(value, left, right)"
    },
    {
        "number": 985,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bishops = []\n    for _ in range(n):\n        row, col = map(int, stdin.split()[1:])\n        bishops.append((row, col))\n    bishops.sort()\n    pairs = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if abs(bishops[i][0] - bishops[j][0]) == abs(bishops[i][1] - bishops[j][1]):\n                pairs += 1\n    return str(pairs)"
    },
    {
        "number": 986,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def buy_books(books: list, cost: int) -> int:\n        if not books:\n            return cost\n        return min(cost, books[0]) + buy_books(books[1:], cost)\n\n    return str(buy_books(a, 0))"
    },
    {
        "number": 987,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    pairs = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    def swap(a, b):\n        p[a], p[b] = p[b], p[a]\n\n    def is_valid(p):\n        for i in range(n):\n            if p[i] > i + 1:\n                return False\n        return True\n\n    def lexicographically_smaller(p1, p2):\n        for i in range(n):\n            if p1[i] < p2[i]:\n                return True\n            elif p1[i] > p2[i]:\n                return False\n        return False\n\n    def lexicographically_maximal(p):\n        max_p = p.copy()\n        for i in range(n):\n            max_p[i] = n\n        return max_p\n\n    def lexicographically_maximal_permutation(p):\n        max_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] < max_p[i]:\n                max_p[i] = p[i]\n        return max_p\n\n    def lexicographically_smaller_permutation(p):\n        min_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] > min_p[i]:\n                min_p[i] = p[i]\n        return min_p\n\n    def lexicographically_maximal_permutation_with_swaps(p):\n        max_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] < max_p[i]:\n                max_p[i] = p[i]\n        return max_p\n\n    def lexicographically_smaller_permutation_with_swaps(p):\n        min_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] > min_p[i]:\n                min_p[i] = p[i]\n        return min_p\n\n    def lexicographically_maximal_permutation_with_swaps_and_swaps(p):\n        max_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] < max_p[i]:\n                max_p[i] = p[i]\n        return max_p\n\n    def lexicographically_smaller_permutation_with_swaps_and_swaps(p):\n        min_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] > min_p[i]:\n                min_p[i] = p[i]\n        return min_p\n\n    def lexicographically_maximal_permutation_with_swaps_and_swaps_and_swaps(p):\n        max_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] < max_p[i]:\n                max_p[i] = p[i]\n        return max_p\n\n    def lexicographically_smaller_permutation_with_swaps_and_swaps_and_swaps(p):\n        min_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] > min_p[i]:\n                min_p[i] = p[i]\n        return min_p\n\n    def lexicographically_maximal_permutation_with_swaps_and_swaps_and_swaps_and_swaps(p):\n        max_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] < max_p[i]:\n                max_p[i] = p[i]\n        return max_p\n\n    def lexicographically_smaller_permutation_with_swaps_and_swaps_and_swaps_and_swaps(p):\n        min_p = lexicographically_maximal(p)\n        for i in range(n):\n            if p[i] > min_p[i]:\n                min_p[i] = p[i]\n        return min_p\n\n    def lexicographically_maximal_permutation_with_swaps_and_swaps_and_swaps_and_swaps_and_swaps(p"
    },
    {
        "number": 988,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split('\\n')\n    max_convenience = 0\n    max_plan = ''\n    for row in rows:\n        row_plan = ''\n        for i in range(len(row)):\n            if row[i] == '*':\n                row_plan += 'P'\n            elif row[i] == '.':\n                row_plan += '.'\n            else:\n                row_plan += row[i]\n        if len(set(row_plan)) > max_convenience:\n            max_convenience = len(set(row_plan))\n            max_plan = row_plan\n    return max_plan"
    },
    {
        "number": 989,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_diff = float('inf')\n    for i in range(k):\n        max_diff = min(max_diff, max(a) - min(a))\n        for j in range(n):\n            if a[j] == max(a):\n                a[j] -= 1\n            elif a[j] == min(a):\n                a[j] += 1\n\n    return str(max_diff)"
    },
    {
        "number": 990,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *edges = map(int, stdin.split())\n    m, *restrictions = map(int, stdin.split())\n\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        black_count = 0\n        for v, black in edges[u - 1]:\n            if v not in visited:\n                black_count += dfs(v, visited)\n        return black_count\n\n    def count_ways(u: int, v: int, visited: set) -> int:\n        if u == v:\n            return 1\n        if (u, v) in visited or (v, u) in visited:\n            return 0\n        visited.add((u, v))\n        ways = 0\n        for w, black in edges[u - 1]:\n            if w not in visited:\n                ways += count_ways(w, v, visited)\n        return ways\n\n    ways = 0\n    for u, v in restrictions:\n        visited = set()\n        black_count = dfs(u, visited)\n        ways += count_ways(u, v, visited)\n        ways += count_ways(v, u, visited)\n        ways += black_count * (black_count - 1)\n\n    return str(ways)\n"
    },
    {
        "number": 991,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    cities = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, a, b = map(int, stdin.split())\n        cities[u].append((v, a, b))\n        cities[v].append((u, a, b))\n\n    def dijkstra(start: int) -> list:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, a, b in cities[u]:\n                if d + a < dist[v]:\n                    dist[v] = d + a\n                    heappush(pq, (dist[v], v))\n        return dist\n\n    def min_time(start: int, end: int) -> int:\n        dist = dijkstra(start)\n        return dist[end]\n\n    def min_time_with_exchange(start: int, end: int) -> int:\n        dist = dijkstra(start)\n        min_time_without_exchange = dist[end]\n        min_time_with_exchange = float('inf')\n        for i in range(1, n + 1):\n            if i!= start:\n                min_time_with_exchange = min(min_time_with_exchange, dist[i] + min_time(i, end))\n        return min_time_with_exchange\n\n    min_time_1 = min_time(1, n)\n    min_time_2 = min_time_with_exchange(1, n)\n    return str(min(min_time_1, min_time_2))\n"
    },
    {
        "number": 992,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def f(T):\n        count = 0\n        for i in range(1, N + 1):\n            if i in T:\n                count += 1\n        return count\n\n    def powerset(T):\n        if len(T) == 1:\n            return [T]\n        return [x for x in powerset(T[:-1]) for y in powerset([T[-1]] + x)]\n\n    def sum_f(T):\n        return sum(f(t) for t in powerset(T))\n\n    T = set(range(1, N + 1))\n    result = sum_f(T) % 998244353\n    print(result)\n    return \"\"\n"
    },
    {
        "number": 993,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if (j - i) % m == 0:\n                pairs.append((i, j))\n\n    return str(len(pairs))"
    },
    {
        "number": 994,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    notes = []\n    for _ in range(m):\n        day, height = map(int, stdin.split())\n        notes.append((day, height))\n\n    max_height = 0\n    for i in range(1, n):\n        if abs(notes[i][1] - notes[i - 1][1] + 1) > 1:\n            return \"IMPOSSIBLE\"\n        max_height = max(max_height, notes[i][1])\n\n    return str(max_height)"
    },
    {
        "number": 995,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5 + 0.5) ** 2\n\n    def count_groups(arr: List[int]) -> int:\n        groups = []\n        group_sum = 0\n        for num in arr:\n            group_sum += num\n            if is_perfect_square(group_sum):\n                groups.append(group_sum)\n                group_sum = 0\n        return len(groups)\n\n    def count_subarrays(arr: List[int], k: int) -> int:\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                if sum(arr[i:j]) == k:\n                    count += 1\n        return count\n\n    result = [count_subarrays(arr, k) for k in range(1, n + 1)]\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 996,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    layers = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n\n    critical_cpus = set()\n    for layer in layers:\n        for i in range(n):\n            for j in range(m):\n                for z in range(k):\n                    if layer[j][z] == 1:\n                        for x in range(i + 1, n):\n                            if layer[j][x] == 1:\n                                critical_cpus.add((x, j, z))\n\n    return str(len(critical_cpus))"
    },
    {
        "number": 997,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    words = s.split(';')\n    a = []\n    b = []\n    for word in words:\n        if word:\n            numbers = [int(num) for num in word.split(',') if num.isdigit()]\n            if numbers:\n                a.append(','.join(map(str, numbers)))\n            else:\n                b.append(word)\n    if a:\n        print('\"' + ','.join(a) + '\"')\n    else:\n        print('-')\n    if b:\n        print('\"' + ','.join(b) + '\"')\n    else:\n        print('-')\n    return ''"
    },
    {
        "number": 998,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = [i for i in range(1, 2**n+1)]\n    l = 0\n    for i in range(1, len(a)):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x:\n            a[i] = a[i-1] + 1\n        else:\n            a[i] = a[i-1]\n    for i in range(1, len(a)-1):\n        if a[i] ^ a[i-1] == x"
    },
    {
        "number": 999,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    l1, r1 = map(int, stdin.split())\n    l2, r2 = map(int, stdin.split())\n\n    l1.sort()\n    r1.sort()\n    l2.sort()\n    r2.sort()\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(m):\n            if l1[i] <= l2[j] <= r1[i] and l2[j] <= r2[j] <= r2[j]:\n                max_distance = max(max_distance, abs(i - j))\n\n    return str(max_distance)"
    },
    {
        "number": 1000,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    cities.sort()\n    tank = 0\n    min_cost = float('inf')\n\n    for i in range(1, n+1):\n        fuel_cost = cities[i-1]\n        if tank + fuel_cost <= v:\n            tank += fuel_cost\n        else:\n            min_cost = min(min_cost, tank)\n            tank = fuel_cost\n\n    min_cost = min(min_cost, tank)\n    return str(min_cost)"
    },
    {
        "number": 1001,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    p_score = sum(a)\n    g_score = 0\n    for i in range(n):\n        g_score += a[i]\n    return str(p_score - g_score)"
    },
    {
        "number": 1002,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    devu_songs = [t[i] for i in range(n)]\n    churu_jokes = [5 for _ in range(n)]\n\n    for i in range(n):\n        devu_songs[i] -= 10\n\n    if all(devu_songs):\n        return max(churu_jokes)\n    else:\n        return -1"
    },
    {
        "number": 1003,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = [0] * (n + 1)\n    days[1] = 1\n    for i in range(2, n + 1):\n        days[i] = days[i - 1] + days[i - 2]\n        if days[i] % m == 0:\n            days[i] += 1\n    return str(days[-1])"
    },
    {
        "number": 1004,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid_day(events: list) -> bool:\n        if len(events) < 2:\n            return False\n        for i in range(1, len(events)):\n            if events[i] < events[i - 1]:\n                return False\n        return True\n\n    def partition(events: list) -> list:\n        if len(events) == 1:\n            return [events]\n        if len(events) == 2:\n            return [[events[0]], [events[1]]]\n        if len(events) == 3:\n            return [[events[0]], [events[1]], [events[2]]]\n        if len(events) == 4:\n            return [[events[0]], [events[1]], [events[2]], [events[3]]]\n        if len(events) == 5:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]]]\n        if len(events) == 6:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]]]\n        if len(events) == 7:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]]]\n        if len(events) == 8:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]]]\n        if len(events) == 9:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]]]\n        if len(events) == 10:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]]]\n        if len(events) == 11:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]], [events[10]]]\n        if len(events) == 12:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]], [events[10]], [events[11]]]\n        if len(events) == 13:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]], [events[10]], [events[11]], [events[12]]]\n        if len(events) == 14:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]], [events[10]], [events[11]], [events[12]], [events[13]]]\n        if len(events) == 15:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]], [events[10]], [events[11]], [events[12]], [events[13]], [events[14]]]\n        if len(events) == 16:\n            return [[events[0]], [events[1]], [events[2]], [events[3]], [events[4]], [events[5]], [events[6]], [events[7]], [events[8]], [events[9]], [events[10]], [events[11]], [events[12]], [events[13]], [events[14]], [events[15]]]\n        if len(events) == 17:\n            return [[events[0]], [events[1]], [events[2]],"
    },
    {
        "number": 1005,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for i in range(test_cases):\n        n, k, d = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        for i in range(1, n + 1):\n            dp[i] = dp[i - 1]\n            for j in range(i):\n                if a[j] == a[i - 1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        print(dp[n])"
    },
    {
        "number": 1006,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    board = [list(row) for row in stdin.split('\\n')[1:]]\n\n    def is_valid(cross):\n        for cell in cross:\n            if cell == '.' or cell == '#':\n                return False\n        return True\n\n    def is_connected(cross):\n        for i in range(len(cross) - 1):\n            if cross[i] == cross[i + 1]:\n                return False\n        return True\n\n    crosses = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '#':\n                cross = [board[i][j]]\n                stack = [(i, j)]\n                while stack:\n                    x, y = stack.pop()\n                    if x == 0 or y == 0 or x == n - 1 or y == n - 1:\n                        cross.append(board[x][y])\n                    else:\n                        board[x][y] = '#'\n                        stack.append((x - 1, y))\n                        stack.append((x + 1, y))\n                        stack.append((x, y - 1))\n                        stack.append((x, y + 1))\n                crosses.append(cross)\n\n    crosses = [cross for cross in crosses if is_valid(cross) and is_connected(cross)]\n\n    if crosses:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1007,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p = map(int, stdin.split())\n    nums = [int(x) for x in stdin.split()]\n    nums.sort()\n    zcy_sum = 0\n    for num in nums[:k]:\n        if num % 10 == 0:\n            zcy_sum += num\n        else:\n            zcy_sum += num * 10\n    return str((zcy_sum % p) % p)"
    },
    {
        "number": 1008,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = list(s)\n    s.sort()\n    for i in range(len(s) - 1):\n        if s[i] == s[len(s) - 1 - i]:\n            k -= 1\n            if k == 0:\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 1009,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    s.sort()\n    for i in range(1, n):\n        if s[i] - 1 > s[i]:\n            return s[i] - 1\n    return s[-1]"
    },
    {
        "number": 1010,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def dfs(start: int, path: str) -> int:\n        if start == n:\n            return 1\n\n        count = 0\n        for i in range(start, n):\n            if a[i] == 1:\n                count += dfs(i + 1, path + \"1\")\n\n        return count\n\n    return str(dfs(0, \"\"))"
    },
    {
        "number": 1011,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    max_a = a[-1]\n    max_b = b[-1]\n\n    if max_a > max_b:\n        return f\"{max_a}:{max_b}\"\n    else:\n        return f\"{max_b}:{max_a}\""
    },
    {
        "number": 1012,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        s = stdin.split()[1]\n        if is_palindrome(s):\n            print(-1)\n        else:\n            for i in range(len(s)):\n                for j in range(i+1, len(s)+1):\n                    if is_palindrome(s[i:j]):\n                        print(s[i:j])\n                        break\n            else:\n                print(-1)\n\ndef"
    },
    {
        "number": 1013,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    table = [[0] * m for _ in range(n)]\n    for i in range(n):\n        row = list(map(int, stdin.split()[i+1].split()))\n        for j in range(m):\n            table[i][j] = row[j]\n\n    good_cells = [(i, j) for i in range(1, n) for j in range(1, m) if table[i][j] == 1]\n    corners = [(1, 1), (n, 1), (1, m), (n, m)]\n\n    min_operations = float('inf')\n    for good_cell in good_cells:\n        for corner in corners:\n            p, q = good_cell\n            x1, y1 = corner\n            x2, y2 = good_cell\n            if min(x1, x2) <= p <= max(x1, x2) and min(y1, y2) <= q <= max(y1, y2):\n                min_operations = min(min_operations, 1 + 1 + 1 + 1)\n\n    return str(min_operations)"
    },
    {
        "number": 1014,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    board = [['.' for _ in range(n + 1)] for _ in range(n + 1)]\n    queen_color = 'white'\n    queen_row = 0\n    queen_col = 0\n    enemy_color = 'black'\n    enemy_row = 0\n    enemy_col = 0\n\n    def print_board():\n        for row in board:\n            print(' '.join(row))\n\n    def is_valid_move(row: int, col: int) -> bool:\n        if board[row][col]!= '.':\n            return False\n        for i in range(1, n + 1):\n            if board[row - i][col] == enemy_color or board[row + i][col] == enemy_color:\n                return False\n        return True\n\n    def is_valid_move_with_enemy(row: int, col: int) -> bool:\n        if board[row][col]!= '.':\n            return False\n        for i in range(1, n + 1):\n            if board[row - i][col] == enemy_color or board[row + i][col] == enemy_color:\n                return False\n        for i in range(1, n + 1):\n            if board[row][col - i] == enemy_color or board[row][col + i] == enemy_color:\n                return False\n        return True\n\n    def is_valid_move_with_enemy_and_queen(row: int, col: int) -> bool:\n        if board[row][col]!= '.':\n            return False\n        for i in range(1, n + 1):\n            if board[row - i][col] == enemy_color or board[row + i][col] == enemy_color:\n                return False\n        for i in range(1, n + 1):\n            if board[row][col - i] == enemy_color or board[row][col + i] == enemy_color:\n                return False\n        if row == queen_row and col == queen_col:\n            return False\n        if row == enemy_row and col == enemy_col:\n            return False\n        return True\n\n    def find_valid_move(color: str) -> tuple:\n        valid_moves = []\n        for row in range(1, n + 1):\n            for col in range(1, n + 1):\n                if board[row][col] == '.' and (color == 'white' or board[row][col]!= enemy_color):\n                    valid_moves.append((row, col))\n        return valid_moves\n\n    def find_valid_move_with_enemy(color: str) -> tuple:\n        valid_moves = []\n        for row in range(1, n + 1):\n            for col in range(1, n + 1):\n                if board[row][col] == '.' and (color == 'white' or board[row][col]!= enemy_color):\n                    if is_valid_move_with_enemy(row, col):\n                        valid_moves.append((row, col))\n        return valid_moves\n\n    def find_valid_move_with_enemy_and_queen(color: str) -> tuple:\n        valid_moves = []\n        for row in range(1, n + 1):\n            for col in range(1, n + 1):\n                if board[row][col] == '.' and (color == 'white' or board[row][col]!= enemy_color):\n                    if is_valid_move_with_enemy_and_queen(row, col):\n                        valid_moves.append((row, col))\n        return valid_moves\n\n    def find_min_r(valid_moves: tuple) -> int:\n        min_r = n\n        for move in valid_moves:\n            if move[0] < min_r:\n                min_r = move[0]\n        return min_r\n\n    def find_min_c(valid_moves: tuple) -> int:\n        min_c = n\n        for move in valid_moves:\n            if move[1] < min_c:\n                min_c = move[1]\n        return min_c\n\n    def find_winner(color: str) -> str:\n        valid_moves = find_valid_move(color)\n        if not valid_moves:\n            return 'tie'\n        min_r = find_min_r(valid_moves)\n        min_c = find_min_c(valid_moves)\n        for row in range(1, n + 1):\n            for col in range(1, n + 1):\n                if board[row][col] == '.' and (color == 'white' or board"
    },
    {
        "number": 1015,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    shields = [int(x) for x in stdin.split()[1:]]\n\n    def find_protected_pairs(i: int, j: int) -> int:\n        count = 0\n        while i < n and j < n:\n            if shields[i] == 0 and shields[j] == 0:\n                count += 1\n                i += 1\n                j += 1\n            elif shields[i] == 0:\n                i += 1\n            elif shields[j] == 0:\n                j += 1\n            else:\n                i += 1\n                j += 1\n        return count\n\n    max_protection = 0\n    for k in range(0, n * (n - 1) // 2 + 1):\n        protection = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if find_protected_pairs(i, j) > 0:\n                    protection += 1\n        if protection > max_protection:\n            max_protection = protection\n\n    return \" \".join(str(max_protection) for _ in range(n * (n - 1) // 2 + 1))"
    },
    {
        "number": 1016,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    pairs.sort()\n\n    def can_react(x: int, y: int) -> bool:\n        for pair in pairs:\n            if pair[0] == x and pair[1] == y:\n                return True\n            if pair[0] == y and pair[1] == x:\n                return True\n        return False\n\n    def max_danger(chemicals: List[int]) -> int:\n        danger = 1\n        for i in range(len(chemicals)):\n            for j in range(i + 1, len(chemicals)):\n                if can_react(chemicals[i], chemicals[j]):\n                    danger *= 2\n        return danger\n\n    return str(max_danger(list(range(1, n + 1))))"
    },
    {
        "number": 1017,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    stones = 0\n    count = 0\n\n    while stones < n:\n        stones += 1\n        count += 1\n\n        if stones == 3:\n            stones = 0\n            count = 0\n\n    return str(count)"
    },
    {
        "number": 1018,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [0] + a\n    a = [a[i] - a[i - 1] for i in range(1, n + 1)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 2)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 3)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 4)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 5)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 6)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 7)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 8)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 9)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 10)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 11)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 12)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 13)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 14)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 15)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 16)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 17)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 18)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 19)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 20)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 21)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 22)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 23)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 24)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 25)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 26)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 27)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 28)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 29)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 30)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 31)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 32)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 33)]\n    a = [a[i] + a[i - 1] for i in range(1, n + 34)]\n    a = [a[i] + a[i - 1] for i in range(1, n +"
    },
    {
        "number": 1019,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = 1\n    b = 1\n    while True:\n        a += 1\n        b += 1\n        if a * b > n:\n            break\n    while True:\n        a -= 1\n        b -= 1\n        if a * b > n:\n            break\n    return f\"{a} {b}\""
    },
    {
        "number": 1020,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, k = map(int, stdin.split())\n    min_n, min_m = min(w, h), min(w, h)\n    max_n, max_m = max(w, h), max(w, h)\n    min_n, min_m, max_n, max_m = min_n + 1, min_m + 1, max_n - 1, max_m - 1\n    cells_to_gilded = 0\n    for i in range(k):\n        cells_to_gilded += (max_n - min_n + 1) * (max_m - min_m + 1) - 4 * (i + 1) * (max_n - min_n + 1) * (max_m - min_m + 1)\n    return str(cells_to_gilded)"
    },
    {
        "number": 1021,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c, *t = map(int, stdin.split())\n    c = list(c)\n    t = list(t)\n\n    def synchronize(i: int) -> None:\n        nonlocal c, t\n        c[i] = t[i]\n        t[i] = c[i + 1] + c[i - 1] - c[i]\n\n    for i in range(1, n - 1):\n        synchronize(i)\n\n    if all(c[i] == t[i] for i in range(n)):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1022,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    l = list(map(int, stdin.split()[1:n+1]))\n    r = list(map(int, stdin.split()[n+1:]))\n\n    def dfs(node: int, parent: int, left: int, right: int) -> int:\n        nonlocal max_candies\n        nonlocal max_left\n        nonlocal max_right\n\n        if node == n:\n            return max_candies\n\n        if node == parent:\n            return dfs(node + 1, node, left, right)\n\n        if l[node] < a[node]:\n            max_left = max(max_left, dfs(node + 1, node, left, right))\n        if r[node] < a[node]:\n            max_right = max(max_right, dfs(node + 1, node, left, right))\n\n        return max(max_candies, dfs(node + 1, parent, left, right))\n\n    max_candies = 0\n    max_left = 0\n    max_right = 0\n\n    a = [0] * n\n    for i in range(n):\n        a[i] = dfs(i, -1, 0, 0)\n\n    if max_candies == 0:\n        return \"NO\"\n\n    return \"YES \" + \" \".join(map(str, a))\n"
    },
    {
        "number": 1023,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t_a, t_b, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    i = j = 0\n    while i < n and j < m:\n        if b[j] >= a[i] + t_a:\n            i += 1\n        else:\n            j += 1\n\n    if i == n:\n        return -1\n\n    if k > i:\n        return -1\n\n    return a[i] + t_a"
    },
    {
        "number": 1024,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def shuffle(a: list, k: int) -> list:\n        for i in range(k):\n            j = random.randint(i, n - 1)\n            a[i], a[j] = a[j], a[i]\n        return a\n\n    def count_inversions(a: list) -> int:\n        n = len(a)\n        inv = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] > a[j]:\n                    inv += 1\n        return inv\n\n    def apply_operation(a: list, l: int, r: int) -> list:\n        k = r - l + 1\n        p = shuffle(list(range(1, k + 1)), k)\n        return [a[i] - 1 + p[i - 1] for i in range(l, r + 1)]\n\n    def expected_inversions(a: list) -> float:\n        n = len(a)\n        inv = 0\n        for l in range(n):\n            for r in range(l, n):\n                if l == r:\n                    continue\n                a_l = a[l]\n                a_r = a[r]\n                a_l_r = a[l:r + 1]\n                a_l_r_inv = count_inversions(a_l_r)\n                a_l_inv = count_inversions(a[:l])\n                a_r_inv = count_inversions(a[r + 1:])\n                inv += a_l_inv * a_r_inv - a_l_r_inv * a_l_r_inv\n        return inv\n\n    a_l = a[0]\n    a_r = a[-1]\n    a_l_r = a[1:-1]\n    a_l_r_inv = count_inversions(a_l_r)\n    a_l_inv = count_inversions(a[:1])\n    a_r_inv = count_inversions(a[1:])\n    expected_inv = a_l_inv * a_r_inv - a_l_r_inv * a_l_r_inv\n\n    return str(expected_inv)"
    },
    {
        "number": 1025,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    triangles = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_valid_triangle(points[i], points[j], points[k]):\n                    triangles.append((points[i], points[j], points[k]))\n    return str(len(triangles))\n\ndef"
    },
    {
        "number": 1026,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = map(int, stdin.split())\n    b = [0] + b\n    b.sort()\n    max_beauty = 0\n    for i in range(1, n):\n        if b[i] - b[i - 1] == b[i + 1] - b[i]:\n            max_beauty += b[i]\n    return str(max_beauty)"
    },
    {
        "number": 1027,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    max_score = 0\n    for i in range(14):\n        if a[i] % 2 == 0:\n            max_score += a[i]\n    return str(max_score)"
    },
    {
        "number": 1028,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    k_min = 0\n    k_max = 0\n    for i in range(1, n + 1):\n        k_min += i\n        k_max += m - i\n    return f\"{k_min} {k_max}\""
    },
    {
        "number": 1029,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    b = [int(x) for x in str(p)]\n    max_length = len(b)\n\n    for _ in range(1000000):\n        b_1 = b.copy()\n        b_2 = b.copy()\n        b_3 = b.copy()\n\n        for i in range(len(b)):\n            for j in range(i + 1, len(b)):\n                if b[i] >= b[j]:\n                    v = b[i] + b[j]\n                    b_2[i] = v\n                    b_2[j] = v\n                    b_3.append(v)\n\n        b = b_3\n        max_length = max(max_length, len(b))\n\n    return str(max_length)"
    },
    {
        "number": 1030,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    navigation = []\n    for i in range(1, n + 1):\n        if i == 1:\n            if i - k >= 1:\n                navigation.append(f\"<< {i - k} {i - k + 1}... {i - 1} ({i}) {i + 1}... {i + k - 1} {i + k} >>\")\n            else:\n                navigation.append(f\"({i})\")\n        elif i == n:\n            if i + k <= n:\n                navigation.append(f\"{i - 1} {i} {i + 1}... {i + k - 1} {i + k} >>\")\n            else:\n                navigation.append(f\"{i - 1} {i} {i + 1}... {i + k - 1} >>\")\n        elif i - k >= 1 and i + k <= n:\n            navigation.append(f\"{i - k} {i - k + 1}... {i - 1} ({i}) {i + 1}... {i + k - 1} {i + k} >>\")\n        elif i - k >= 1:\n            navigation.append(f\"{i - k} {i - k + 1}... {i - 1} ({i}) {i + 1}... {i + k - 1} >>\")\n        elif i + k <= n:\n            navigation.append(f\"{i - 1} {i} {i + 1}... {i + k - 1} {i + k} >>\")\n        else:\n            navigation.append(f\"{i - 1} {i} {i + 1}... {i + k - 1} >>\")\n    return \" \".join(navigation)"
    },
    {
        "number": 1031,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [a[i] for i in range(n)]\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n    a.append(sum(a))\n    a.sort()\n   "
    },
    {
        "number": 1032,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def f(x: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if a[i - 1] <= x:\n                count += 1\n        return count\n\n    good_x = []\n    for x in range(1, n + 1):\n        if is_prime(x) and f(x) % p == 0:\n            good_x.append(x)\n\n    good_x.sort()\n    print(len(good_x))\n    print(*good_x)\n\n    return \"\"\n"
    },
    {
        "number": 1033,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, H = map(int, stdin.split())\n    sand_packs = [0] * n\n    sand_packs[0] = H\n    for i in range(1, n):\n        sand_packs[i] = sand_packs[i - 1] - 1\n        if sand_packs[i] < 0:\n            sand_packs[i] = 0\n    return str(n - sand_packs.index(0))"
    },
    {
        "number": 1034,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, Z, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    C = list(map(int, stdin.split()))\n\n    def get_sum(cakes: list) -> int:\n        return sum(cakes)\n\n    def get_combinations(n: int, k: int) -> int:\n        return math.factorial(n) // (math.factorial(k) * math.factorial(n - k))\n\n    def get_combinations_with_replacement(n: int, k: int) -> int:\n        return get_combinations(n, k) // math.factorial(k - 1)\n\n    def get_combinations_without_replacement(n: int, k: int) -> int:\n        return get_combinations(n - 1, k - 1)\n\n    def get_combinations_with_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_with_replacement(n - 1, k - 1)\n\n    def get_combinations_without_replacement_with_replacement(n: int, k: int) -> int:\n        return get_combinations_without_replacement(n - 1, k)\n\n    def get_combinations_with_replacement_without_replacement_with_replacement(n: int, k: int) -> int:\n        return get_combinations_with_replacement_without_replacement(n - 1, k)\n\n    def get_combinations_without_replacement_with_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_without_replacement_with_replacement(n - 1, k - 1)\n\n    def get_combinations_with_replacement_without_replacement_with_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_with_replacement_without_replacement_without_replacement(n - 1, k)\n\n    def get_combinations_without_replacement_with_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_without_replacement_with_replacement_without_replacement(n - 1, k - 1)\n\n    def get_combinations_with_replacement_without_replacement_with_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_with_replacement_without_replacement_without_replacement_without_replacement(n - 1, k)\n\n    def get_combinations_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_without_replacement_with_replacement_without_replacement_without_replacement(n - 1, k - 1)\n\n    def get_combinations_with_replacement_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_with_replacement_without_replacement_without_replacement_without_replacement_without_replacement(n - 1, k)\n\n    def get_combinations_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement(n - 1, k - 1)\n\n    def get_combinations_with_replacement_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_with_replacement_without_replacement_without_replacement_without_replacement_without_replacement_without_replacement(n - 1, k)\n\n    def get_combinations_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement_without_replacement_without_replacement(n: int, k: int) -> int:\n        return get_combinations_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement_without_replacement(n - 1, k - 1)\n\n    def get_combinations_with_replacement_without_replacement_with_replacement_without_replacement_without_replacement_without_replacement_without"
    },
    {
        "number": 1035,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    divisors = set()\n    for i in range(1, min(a, b) + 1):\n        if a % i == 0 and b % i == 0:\n            divisors.add(i)\n    return str(len(divisors))"
    },
    {
        "number": 1036,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def tournament(l: int, r: int) -> str:\n        if r - l == 1:\n            return s[l]\n        m = (l + r) // 2\n        a = tournament(l, m)\n        b = tournament(m, r)\n        return \"RPS\".index(a + b) + 1\n\n    return s[tournament(0, 2**k - 1)]"
    },
    {
        "number": 1037,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    max_happiness = 0\n    for i in range(n):\n        max_happiness += a[i] * (i + 1)\n    return str(max_happiness)"
    },
    {
        "number": 1038,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    result = 0\n    for i in range(A, B+1):\n        result ^= i\n    return str(result)"
    },
    {
        "number": 1039,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *edges = map(int, stdin.split())\n    edges = [tuple(map(int, edge.split())) for edge in edges]\n    queries, k = map(int, stdin.split())\n    queries = [tuple(map(int, query.split())) for query in stdin.split()]\n\n    def dijkstra(start: int) -> list[int]:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in edges:\n                if d + w < dist[v]:\n                    dist[v] = d + w\n                    heappush(pq, (dist[v], v))\n        return dist\n\n    def shortest_path(start: int, end: int) -> int:\n        dist = dijkstra(start)\n        return dist[end]\n\n    def query(x: int, y: int) -> int:\n        return shortest_path(x, k) + shortest_path(k, y)\n\n    result = []\n    for query in queries:\n        x, y = query\n        result.append(query(x, y))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1040,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = s.lower()\n    min_length = n\n    for i in range(1, n + 1):\n        s = ''.join(filter(lambda x: x!= 'f', s))\n        min_length = min(min_length, len(s))\n    return str(min_length)"
    },
    {
        "number": 1041,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = list(s)\n\n    def is_evenly_spaced(points: list[int]) -> bool:\n        if len(points) < 3:\n            return False\n\n        x1, y1 = points[0], points[1]\n        x2, y2 = points[2], points[3]\n\n        return abs(x1 - x2) == abs(y1 - y2)\n\n    def is_regular_polygon(points: list[int]) -> bool:\n        if len(points) < 3:\n            return False\n\n        x1, y1 = points[0], points[1]\n        x2, y2 = points[2], points[3]\n        x3, y3 = points[4], points[5]\n\n        return (x1 - x2) * (y2 - y3) == (x2 - x3) * (y3 - y1)\n\n    def increase_or_decrease(points: list[int], k: int) -> None:\n        for i in range(len(points)):\n            if points[i] % 2 == 0:\n                points[i] += k\n            else:\n                points[i] -= k\n\n    def is_zero(points: list[int]) -> bool:\n        return all(point == 0 for point in points)\n\n    def is_possible(points: list[int]) -> bool:\n        return is_evenly_spaced(points) and is_regular_polygon(points) and is_zero(points)\n\n    def find_evenly_spaced_points(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points) - 1):\n            if points[i] % 2 == 0 and points[i + 1] % 2 == 0:\n                result.append(i)\n        return result\n\n    def find_regular_polygon_points(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points) - 2):\n            if points[i] % 2 == 0 and points[i + 1] % 2 == 0 and points[i + 2] % 2 == 0:\n                result.append(i)\n        return result\n\n    def find_zero_points(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] == 0:\n                result.append(i)\n        return result\n\n    def find_possible_points(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] % 2 == 0:\n                result.append(i)\n        return result\n\n    def find_points_to_increase(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] % 2 == 0 and points[i] % 4 == 0:\n                result.append(i)\n        return result\n\n    def find_points_to_decrease(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] % 2 == 0 and points[i] % 4 == 0:\n                result.append(i)\n        return result\n\n    def find_points_to_increase_or_decrease(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] % 2 == 0 and points[i] % 4 == 0:\n                result.append(i)\n        return result\n\n    def find_points_to_increase_or_decrease_and_increase(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] % 2 == 0 and points[i] % 4 == 0:\n                result.append(i)\n        return result\n\n    def find_points_to_increase_or_decrease_and_decrease(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len(points)):\n            if points[i] % 2 == 0 and points[i] % 4 == 0:\n                result.append(i)\n        return result\n\n    def find_points_to_increase_or_decrease_and_increase_and_decrease(points: list[int]) -> list[int]:\n        result = []\n        for i in range(len"
    },
    {
        "number": 1042,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_valid(a):\n        return all(a[i] % gcd(a[i], a[j]) == 0 for i in range(len(a)) for j in range(i + 1, len(a)))\n\n    def count_sequences(a):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n        return count\n\n    def count_valid_sequences(a):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if count > y:\n                return 0\n        return count\n\n    def count_sequences_with_gcd(a, x):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x:\n                return count\n        return 0\n\n    def count_valid_sequences_with_gcd(a, x):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and count <= y:\n                return count\n        return 0\n\n    def count_sequences_with_sum(a, y):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if sum(a[:i]) == y:\n                return count\n        return 0\n\n    def count_valid_sequences_with_sum(a, y):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if sum(a[:i]) == y and count <= y:\n                return count\n        return 0\n\n    def count_sequences_with_gcd_and_sum(a, x, y):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and sum(a[:i]) == y:\n                return count\n        return 0\n\n    def count_valid_sequences_with_gcd_and_sum(a, x, y):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and sum(a[:i]) == y and count <= y:\n                return count\n        return 0\n\n    def count_sequences_with_gcd_and_sum_and_gcd(a, x, y):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and sum(a[:i]) == y and gcd(count, x) == x:\n                return count\n        return 0\n\n    def count_valid_sequences_with_gcd_and_sum_and_gcd(a, x, y):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and sum(a[:i]) == y and gcd(count, x) == x and count <= y:\n                return count\n        return 0\n\n    def count_sequences_with_gcd_and_sum_and_gcd_and_sum(a, x, y, z):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and sum(a[:i]) == y and gcd(count, x) == x and sum(a[:i]) == z:\n                return count\n        return 0\n\n    def count_valid_sequences_with_gcd_and_sum_and_gcd_and_sum(a, x, y, z):\n        count = 0\n        for i in range(1, len(a) + 1):\n            count += a.count(i)\n            if gcd(count, x) == x and sum(a[:i]) == y and gcd(count, x) == x and sum(a[:i]) == z and count <= y:\n                return count\n        return 0\n\n    def count_sequences_"
    },
    {
        "number": 1043,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [a[i] for i in range(n) if a[i]!= -1]\n    a.sort(reverse=True)\n    return str(sum(a))"
    },
    {
        "number": 1044,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tests = [list(map(int, stdin.split()[1].split())) for _ in range(n)]\n\n    for test in tests:\n        a = test[0]\n        b = test[1]\n        c = test[2]\n\n        if a > b and a > c:\n            a, b, c = b, c, a\n        if b > a and b > c:\n            b, c = c, b\n        if c > a and c > b:\n            c, a = a, c\n\n        if a == 1:\n            print(1)\n        elif b == 1:\n            print(2)\n        else:\n            print(3)"
    },
    {
        "number": 1045,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_height = 0\n    for i in range(1, n + 1):\n        max_height = max(max_height, i + 1)\n    return str(max_height)"
    },
    {
        "number": 1046,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    ids = list(map(int, stdin.split()[1:]))\n\n    pairs = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if ids[i]!= 0 and ids[j]!= 0:\n                pairs.add((ids[i], ids[j]))\n\n    if len(pairs) == 0:\n        return \"-1\"\n    else:\n        return str(len(pairs))"
    },
    {
        "number": 1047,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    result = []\n    while n > 0:\n        if n % 2 == 0:\n            result.append(0)\n            count += 1\n        else:\n            result.append(1)\n            count += 1\n        n //= 2\n    return str(count) +'' +''.join(map(str, result))"
    },
    {
        "number": 1048,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n    max_commands = 0\n    current_cell = (0, 0)\n    for command in sequence:\n        if command == 'U':\n            current_cell = (current_cell[0], current_cell[1] + 1)\n        elif command == 'D':\n            current_cell = (current_cell[0], current_cell[1] - 1)\n        elif command == 'L':\n            current_cell = (current_cell[0] - 1, current_cell[1])\n        elif command == 'R':\n            current_cell = (current_cell[0] + 1, current_cell[1])\n        max_commands = max(max_commands, abs(current_cell[0]) + abs(current_cell[1]))\n    return str(max_commands)"
    },
    {
        "number": 1049,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    opponents = [list(map(int, list(input()))) for _ in range(n)]\n    max_consecutive_winning_days = 0\n\n    for day in range(d):\n        opponents_present = [0] * n\n        for opponent in range(n):\n            if opponents[opponent][day]:\n                opponents_present[opponent] = 1\n\n        if all(opponents_present):\n            max_consecutive_winning_days = max(max_consecutive_winning_days, day)\n        elif any(opponents_present):\n            max_consecutive_winning_days = max(max_consecutive_winning_days, day - opponents_present.index(1))\n\n    return str(max_consecutive_winning_days)"
    },
    {
        "number": 1050,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n >= m + k:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1051,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, *ranks = map(int, stdin.split())\n    ranks.sort(reverse=True)\n    declined = 0\n    for rank in ranks:\n        if rank <= K:\n            declined += 1\n            if declined == 25:\n                break\n    return str(declined)"
    },
    {
        "number": 1052,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if i % k == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1053,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v, w = map(int, stdin.split())\n        u -= 1\n        v -= 1\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    min_spanning_tree = []\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            visited[u] = True\n            min_spanning_tree.append(u)\n            for v, w in graph[u]:\n                if not visited[v]:\n                    visited[v] = True\n                    min_spanning_tree.append(v)\n                    break\n    return str(sum(w for u, v, w in graph[u] if u in min_spanning_tree and v in min_spanning_tree))"
    },
    {
        "number": 1054,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    mines = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[1].split())\n        mines.append((x, y))\n    mines.sort()\n    min_x, min_y = mines[0]\n    max_x, max_y = mines[-1]\n    min_x -= 1\n    min_y -= 1\n    max_x += 1\n    max_y += 1\n    area = (max_x - min_x + 1) * (max_y - min_y + 1)\n    return str(area)"
    },
    {
        "number": 1055,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def thanos_sort(arr: list) -> int:\n        def merge(left: list, right: list) -> list:\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n\n        def merge_sort(arr: list) -> list:\n            if len(arr) <= 1:\n                return arr\n            mid = len(arr) // 2\n            left = merge_sort(arr[:mid])\n            right = merge_sort(arr[mid:])\n            return merge(left, right)\n\n        sorted_arr = merge_sort(arr)\n        return len(sorted_arr)\n\n    max_length = 0\n    for i in range(1, n + 1):\n        length = thanos_sort(arr[:i])\n        max_length = max(max_length, length)\n\n    return str(max_length)"
    },
    {
        "number": 1056,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    rows = len(board)\n    cols = len(board[0])\n    goal = (0, 0)\n    start = (0, 0)\n    ladders = []\n\n    for i in range(rows):\n        for j in range(cols):\n            if board[i][j] == 0:\n                continue\n            ladders.append((i, j, board[i][j]))\n\n    ladders.sort(key=lambda x: (x[2], x[0], x[1]))\n\n    def bfs(start, goal):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            node, depth = queue.pop(0)\n            if node == goal:\n                return depth\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor in neighbors(node):\n                queue.append((neighbor, depth + 1))\n\n    def neighbors(node):\n        i, j = node\n        if i > 0:\n            yield (i - 1, j)\n        if i < rows - 1:\n            yield (i + 1, j)\n        if j > 0:\n            yield (i, j - 1)\n        if j < cols - 1:\n            yield (i, j + 1)\n\n    def min_turns(start, goal):\n        return bfs(start, goal) + len(ladders)\n\n    return str(min_turns(start, goal))"
    },
    {
        "number": 1057,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = ''.join(sorted(set(s)))\n    MOD = 998244353\n\n    def count_ways(l: int, r: int) -> int:\n        if l == r:\n            return 1\n        if s[l] == s[r]:\n            return 0\n        return count_ways(l + 1, r) + count_ways(l, r - 1)\n\n    def count_ways_with_one_char(l: int, r: int) -> int:\n        if l == r:\n            return 1\n        if s[l] == s[r]:\n            return 0\n        return count_ways_with_one_char(l + 1, r) + count_ways_with_one_char(l, r - 1)\n\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ways += count_ways(i, j)\n            ways %= MOD\n\n    ways += count_ways_with_one_char(0, n - 1)\n    ways %= MOD\n\n    return str(ways)"
    },
    {
        "number": 1058,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    blocks = []\n    for _ in range(n):\n        block = stdin.split()[1:]\n        blocks.append(block)\n\n    def is_valid(blocks: list) -> bool:\n        for i in range(len(blocks) - 1):\n            if blocks[i][0] == blocks[i + 1][2]:\n                return True\n        return False\n\n    def max_value(blocks: list) -> int:\n        max_value = 0\n        for block in blocks:\n            max_value = max(max_value, int(block[1]))\n        return max_value\n\n    def max_valid_value(blocks: list) -> int:\n        max_value = 0\n        for i in range(1, len(blocks) + 1):\n            valid_blocks = [blocks[j] for j in range(len(blocks)) if j!= i - 1]\n            if is_valid(valid_blocks):\n                max_value = max(max_value, max_value(valid_blocks))\n        return max_value\n\n    return str(max_valid_value(blocks))\n"
    },
    {
        "number": 1059,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    if k < 1 or k > 10**4:\n        return -1\n\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    rows = 0\n    cols = 0\n    for i in range(1, k+1):\n        rows += 1\n        cols += i\n\n    for i in range(1, rows+1):\n        for j in range(1, cols+1):\n            if i * j == k and all(c in vowels for c in input()):\n                return ''.join(sorted(input()))\n\n    return -1"
    },
    {
        "number": 1060,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1].split()))\n\n    def is_divisible(a: int, b: int) -> bool:\n        return a % b == 0\n\n    def max_clique_size(A: List[int]) -> int:\n        def dfs(u: int, visited: Set[int]) -> int:\n            nonlocal max_size\n            if u in visited:\n                return 0\n            visited.add(u)\n            max_size = max(max_size, 1 + dfs(v, visited))\n            visited.remove(u)\n            return max_size\n\n        max_size = 0\n        for u in A:\n            dfs(u, set())\n        return max_size\n\n    return str(max_clique_size(A))\n"
    },
    {
        "number": 1061,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [[int(x) for x in line.split()] for line in stdin.split('\\n')]\n    rows = len(matrix)\n    cols = len(matrix[0])\n    visited = set()\n    queue = [(0, 0)]\n    steps = 0\n\n    while queue:\n        row, col = queue.pop(0)\n        steps += 1\n\n        if (row, col) in visited:\n            continue\n        visited.add((row, col))\n\n        if matrix[row][col] == 1:\n            return str(steps)\n\n        if row == rows - 1 and col == cols - 1:\n            return str(steps)\n\n        if row == rows - 1:\n            queue.append((row, col + 1))\n        elif col == cols - 1:\n            queue.append((row + 1, col))\n        else:\n            queue.append((row, col + 1))\n            queue.append((row + 1, col))\n\n    return str(steps)"
    },
    {
        "number": 1062,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    def hamming_distance(s: str, t: str) -> int:\n        return sum(1 for c1, c2 in zip(s, t) if c1!= c2)\n\n    def swap_letters(s: str, i: int, j: int) -> str:\n        return s[:i] + s[j] + s[i:j] + s[i+1:j+1] + s[j+1:]\n\n    def swap_letters_if_possible(s: str, t: str) -> str:\n        min_distance = float('inf')\n        min_i, min_j = -1, -1\n\n        for i in range(n):\n            for j in range(i+1, n):\n                if i!= j:\n                    new_s = swap_letters(s, i, j)\n                    new_t = swap_letters(t, i, j)\n                    distance = hamming_distance(new_s, new_t)\n                    if distance < min_distance:\n                        min_distance = distance\n                        min_i, min_j = i, j\n\n        return f\"{min_distance} {min_i} {min_j}\" if min_distance!= float('inf') else \"-1 -1\"\n\n    return swap_letters_if_possible(s, t)"
    },
    {
        "number": 1063,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = stdin.split()[1:]\n    lost_digits = [sequence.count('?')]\n\n    for i in range(n):\n        if sequence[i] == '?':\n            lost_digits.append(1)\n        else:\n            lost_digits.append(0)\n\n    for i in range(n):\n        if lost_digits[i] == 0:\n            sequence[i] = str(int(sequence[i]) - lost_digits[i])\n\n    sequence = [int(x) for x in sequence]\n    sequence.sort()\n\n    for i in range(n):\n        sequence[i] = str(sequence[i])\n\n    return '\\n'.join(sequence)"
    },
    {
        "number": 1064,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    blocked_positions = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n\n    blocked_positions.sort()\n    a.sort()\n\n    total_cost = 0\n    for i in range(len(blocked_positions)):\n        if blocked_positions[i] < n:\n            total_cost += a[i]\n\n    if total_cost == 0:\n        return -1\n    else:\n        return str(total_cost)"
    },
    {
        "number": 1065,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M, D = map(int, stdin.split())\n    if M * D * k < n:\n        return \"IMPOSSIBLE\"\n\n    def split_candies(candies: int, x: int) -> int:\n        if candies % x == 0:\n            return candies // x\n        else:\n            return candies // x + 1\n\n    max_candies = 0\n    for x in range(1, n + 1):\n        if split_candies(n, x) <= M * D:\n            max_candies = max(max_candies, split_candies(n, x))\n\n    return str(max_candies)"
    },
    {
        "number": 1066,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    odd_numbers = [i for i in range(1, n+1, 2)]\n    even_numbers = [i for i in range(1, n+1, 2)]\n    odd_numbers.sort()\n    even_numbers.sort()\n    result = odd_numbers[k-1] if k <= len(odd_numbers) else even_numbers[k-len(odd_numbers)-1]\n    return str(result)"
    },
    {
        "number": 1067,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nums = list(map(int, stdin.split()[1:]))\n    nums.sort()\n    min_coins = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if nums[i] * nums[j] * nums[k] == 1:\n                    min_coins = min(min_coins, 1 + min(i, j, k))\n    return str(min_coins)"
    },
    {
        "number": 1068,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = list(map(int, stdin))\n    n = len(digits)\n\n    # Find the first non-zero digit\n    i = 0\n    while i < n and digits[i] == 0:\n        i += 1\n\n    # Find the last non-zero digit\n    j = n - 1\n    while j >= 0 and digits[j] == 0:\n        j -= 1\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2\n\n    # Find the left part\n    left = digits[:mid]\n\n    # Find the right part\n    right = digits[mid + 1:]\n\n    # Find the middle part\n    mid = (i + j) // 2"
    },
    {
        "number": 1069,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = (1 ** n + 2 ** n + 3 ** n + 4 ** n) % 5\n    return str(result)"
    },
    {
        "number": 1070,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    max_length = 0\n    current_length = 1\n    start_color = colors[0]\n\n    for i in range(1, n):\n        if colors[i] == start_color:\n            current_length += 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 1\n            start_color = colors[i]\n\n    if current_length > max_length:\n        max_length = current_length\n\n    return str(max_length)"
    },
    {
        "number": 1071,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, a3 = map(int, stdin.split()[0].split())\n    b1, b2, b3 = map(int, stdin.split()[1].split())\n    n = int(stdin.split()[2])\n\n    if a1 + a2 + a3 > 5 or b1 + b2 + b3 > 5 or a1 + b1 + a2 + b2 + a3 + b3 > 10:\n        return \"NO\"\n\n    if a1 + a2 + a3 > 0 and a1 + a2 + a3 < 5:\n        return \"NO\"\n\n    if b1 + b2 + b3 > 0 and b1 + b2 + b3 < 5:\n        return \"NO\"\n\n    if a1 + b1 + a2 + b2 + a3 + b3 > 0 and a1 + b1 + a2 + b2 + a3 + b3 < 10:\n        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1072,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [list(row) for row in stdin.split()]\n\n    for i in range(n):\n        table[i].sort()\n\n    for i in range(n - 1):\n        if table[i]!= table[i + 1]:\n            break\n    else:\n        return \"0\"\n\n    min_operations = 0\n    for i in range(n):\n        if i == 0:\n            min_operations += 1\n        else:\n            min_operations += table[i].index(table[i - 1][-1]) + 1\n\n    return str(min_operations)\n"
    },
    {
        "number": 1073,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    code = stdin.split()[1]\n    start = 0\n    count = 0\n    result = 0\n\n    for i in range(n):\n        if code[i] == 'U':\n            start += 1\n        elif code[i] == 'R':\n            start += 1\n            count += 1\n        elif code[i] == 'D':\n            start -= 1\n        elif code[i] == 'L':\n            start -= 1\n            count += 1\n\n    if start == 0:\n        result = count\n    else:\n        result = 0\n\n    return str(result)"
    },
    {
        "number": 1074,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a % 2 == 0:\n        return str(a // 2)\n    else:\n        return str(a // 2 + 1)"
    },
    {
        "number": 1075,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 2 or n > 10**5:\n        return -1\n\n    nodes = list(range(n))\n    order = []\n\n    for i in range(n):\n        nodes[i] = (2 * i) % n\n\n    for i in range(n):\n        if nodes[i] == 0:\n            order.append(0)\n            nodes[i] = 1\n        else:\n            nodes[i] = (2 * nodes[i]) % n\n            order.append(nodes[i])\n\n    if order == nodes:\n        return \" \".join(map(str, order))\n    else:\n        return -1"
    },
    {
        "number": 1076,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n > 2**6 or m > 2**6:\n        return \"Invalid input\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def extended_gcd(a: int, b: int) -> tuple[int, int, int]:\n        if b == 0:\n            return (1, 0, a)\n        else:\n            g, x, y = extended_gcd(b, a % b)\n            return (y, x - (a // b) * y, g)\n\n    def mod_inv(a: int, m: int) -> int:\n        g, x, _ = extended_gcd(a, m)\n        if g!= 1:\n            raise ValueError(\"No modular inverse exists\")\n        return x % m\n\n    def solve(n: int, m: int) -> int:\n        if n == 1:\n            return 0\n        if n == 2:\n            return 1\n        if n == 3:\n            return 2\n        if n == 4:\n            return 3\n        if n == 5:\n            return 4\n        if n == 6:\n            return 5\n        if n == 7:\n            return 6\n        if n == 8:\n            return 7\n        if n == 9:\n            return 8\n        if n == 10:\n            return 9\n        if n == 11:\n            return 10\n        if n == 12:\n            return 11\n        if n == 13:\n            return 12\n        if n == 14:\n            return 13\n        if n == 15:\n            return 14\n        if n == 16:\n            return 15\n        if n == 17:\n            return 16\n        if n == 18:\n            return 17\n        if n == 19:\n            return 18\n        if n == 20:\n            return 19\n        if n == 21:\n            return 20\n        if n == 22:\n            return 21\n        if n == 23:\n            return 22\n        if n == 24:\n            return 23\n        if n == 25:\n            return 24\n        if n == 26:\n            return 25\n        if n == 27:\n            return 26\n        if n == 28:\n            return 27\n        if n == 29:\n            return 28\n        if n == 30:\n            return 29\n        if n == 31:\n            return 30\n        if n == 32:\n            return 31\n        if n == 33:\n            return 32\n        if n == 34:\n            return 33\n        if n == 35:\n            return 34\n        if n == 36:\n            return 35\n        if n == 37:\n            return 36\n        if n == 38:\n            return 37\n        if n == 39:\n            return 38\n        if n == 40:\n            return 39\n        if n == 41:\n            return 40\n        if n == 42:\n            return 41\n        if n == 43:\n            return 42\n        if n == 44:\n            return 43\n        if n == 45:\n            return 44\n        if n == 46:\n            return 45\n        if n == 47:\n            return 46\n        if n == 48:\n            return 47\n        if n == 49:\n            return 48\n        if n == 50:\n            return 49\n        if n == 51:\n            return 50\n        if n == 52:\n            return 51\n        if n == 53:\n            return 52\n        if n == 54:\n            return 53\n        if n == 55:\n            return 54\n        if n == 56:\n            return 55\n        if n == 57:\n            return 56\n        "
    },
    {
        "number": 1077,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    b = [0] * m\n    for i in range(n):\n        b[a[i] - 1] += 1\n\n    min_b = min(b)\n    min_changes = 0\n\n    for i in range(m):\n        if b[i] < min_b:\n            min_changes += 1\n            min_b = b[i]\n\n    return str(min_changes) + \" \" + \" \".join(map(str, a))\n"
    },
    {
        "number": 1078,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = [0] * n\n\n    for i in range(n):\n        b[i] = int(a[i] / 2)\n\n    return \" \".join(map(str, b))"
    },
    {
        "number": 1079,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    beautiful_numbers = []\n    for i in range(1, 2**16):\n        if i == 2**15:\n            break\n        if i == -2**15:\n            continue\n        if i == n:\n            beautiful_numbers.append(i)\n        elif i == -n:\n            beautiful_numbers.append(-i)\n        else:\n            beautiful_numbers.append(i)\n            beautiful_numbers.append(-i)\n    beautiful_numbers.sort()\n    return str(len(beautiful_numbers))"
    },
    {
        "number": 1080,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        if a[i]!= 0:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1081,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a % 2 == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1082,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n\n    def count_ways(a, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for num in a:\n            for i in range(target, num - 1, -1):\n                dp[i] = (dp[i] + dp[i - num]) % MOD\n        return dp[target]\n\n    def count_ways_with_product(a, target):\n        dp = [0] * (target + 1)\n        dp[0] = 1\n        for num in a:\n            for i in range(target, num - 1, -1):\n                dp[i] = (dp[i] + dp[i - num]) % MOD\n        return dp[target]\n\n    ways = count_ways(a, 70)\n    ways_with_product = count_ways_with_product(a, 70 * 70)\n\n    return str((ways * ways_with_product) % MOD)\n"
    },
    {
        "number": 1083,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    arr.sort()\n    min_diff = float('inf')\n    first_group = []\n    second_group = []\n    for i in range(n):\n        if i % 2 == 0:\n            first_group.append(arr[i])\n        else:\n            second_group.append(arr[i])\n    first_sum = sum(first_group)\n    second_sum = sum(second_group)\n    min_diff = abs(first_sum - second_sum)\n    return str(min_diff) + '\\n' + str(len(first_group)) +'' +''.join(map(str, first_group)) + '\\n' + str(len(second_group)) +'' +''.join(map(str, second_group))"
    },
    {
        "number": 1084,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n\n    def is_valid(grid, row, col, color):\n        for i in range(row, n):\n            if grid[i][col] == color:\n                return False\n        for j in range(col, m):\n            if grid[row][j] == color:\n                return False\n        for i in range(row, n):\n            for j in range(col, m):\n                if grid[i][j] == color and (i, j) not in visited:\n                    visited.add((i, j))\n                    return True\n        return False\n\n    visited = set()\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                if not is_valid(grid, i, j, '#'):\n                    return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 1085,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    K = 2\n    while N >= K:\n        if N % K == 0:\n            N = N // K\n        else:\n            N -= K\n        count += 1\n    return str(count)"
    },
    {
        "number": 1086,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    A = [list(map(int, stdin.split())) for _ in range(H)]\n    B = [list(map(int, stdin.split())) for _ in range(H)]\n\n    def dfs(i, j, red, blue):\n        if i == H or j == W:\n            return 0, 0\n\n        if A[i][j] == 0 and B[i][j] == 0:\n            return dfs(i + 1, j, red, blue)\n        elif A[i][j] == 0:\n            return dfs(i, j + 1, red, blue + B[i][j])\n        elif B[i][j] == 0:\n            return dfs(i, j, red, blue + A[i][j])\n        else:\n            return min(dfs(i + 1, j, red, blue), dfs(i, j + 1, red + A[i][j], blue)), 0\n\n    return str(min(dfs(1, 1, 0, 0)))"
    },
    {
        "number": 1087,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def f(X):\n        return sum(X ^ a for a in A)\n\n    max_f = max(f(X) for X in range(K + 1))\n    return str(max_f)"
    },
    {
        "number": 1088,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    def swap_columns(matrix, x, y):\n        for i in range(n):\n            matrix[i][x], matrix[i][y] = matrix[i][y], matrix[i][x]\n\n    def swap_rows(matrix, x, y):\n        for i in range(n):\n            matrix[x][i], matrix[y][i] = matrix[y][i], matrix[x][i]\n\n    count = 0\n    for _ in range(2):\n        for _ in range(2):\n            x, y = 0, 0\n            for i in range(n):\n                for j in range(n):\n                    if matrix[i][j] <= k:\n                        if i == x:\n                            x = j\n                        elif i == y:\n                            y = j\n            if x!= y:\n                swap_columns(matrix, x, y)\n                count += 1\n                if count % 998244353 == 0:\n                    return str(count % 998244353)\n\n    return str(count % 998244353)\n"
    },
    {
        "number": 1089,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def dfs(i, j, k, cost):\n        if k == 0:\n            return 1\n        if i < 0 or i >= N or j < 0 or j >= M:\n            return 0\n\n        if grid[i][j]!= 0:\n            return 0\n\n        grid[i][j] = k\n        cost += abs(i - x[k - 1]) + abs(j - y[k - 1])\n        cost %= MOD\n\n        return dfs(i + 1, j, k - 1, cost) + dfs(i - 1, j, k - 1, cost) + dfs(i, j + 1, k - 1, cost) + dfs(i, j - 1, k - 1, cost)\n\n    grid = [[0] * M for _ in range(N)]\n    x = [0] * K\n    y = [0] * K\n\n    for _ in range(K):\n        i, j = map(int, input().split())\n        x[i - 1] = j\n        y[i - 1] = i\n\n    return str(dfs(0, 0, K, 0))"
    },
    {
        "number": 1090,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def rotate(s: str, l: int, r: int) -> str:\n        return s[r:] + s[:l]\n\n    def is_happy(s: str) -> bool:\n        return s == ''.join(map(str, map(int, s)))\n\n    def count_happy(s: str, l: int, r: int) -> int:\n        if l == r:\n            return 1 if s[l] == 'L' else 0\n\n        left = count_happy(s, l + 1, r)\n        right = count_happy(s, l, r - 1)\n\n        return left + right + (1 if s[l] == s[r] else 0)\n\n    def max_happy(s: str, l: int, r: int) -> int:\n        if l == r:\n            return 1 if s[l] == 'L' else 0\n\n        left = max_happy(s, l + 1, r)\n        right = max_happy(s, l, r - 1)\n\n        return max(left, right) + (1 if s[l] == s[r] else 0)\n\n    def rotate_and_count_happy(s: str, l: int, r: int) -> int:\n        return count_happy(rotate(s, l, r), 0, r - l)\n\n    max_count = 0\n    for _ in range(k):\n        l, r = map(int, input().split())\n        max_count = max(max_count, rotate_and_count_happy(s, l - 1, r))\n\n    return str(max_count)"
    },
    {
        "number": 1091,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    prices = list(map(int, stdin.split()[1].split()))\n\n    winner = 0\n    max_price = prices[0]\n\n    for i in range(1, n):\n        if prices[i] > max_price:\n            winner = i\n            max_price = prices[i]\n\n    return f\"{winner + 1} {max_price}\""
    },
    {
        "number": 1092,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    lights = list(map(int, stdin.split()))\n    lights.sort()\n    count = 0\n    for i in range(1, n+1):\n        if i in lights:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1094,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    chats = []\n    for i in range(n):\n        message = stdin.split()[i+1]\n        if message not in chats:\n            chats.append(message)\n    return \" \".join(chats)"
    },
    {
        "number": 1095,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, y1 = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m, y2 = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n\n    def find_closest_sensor(x: int) -> int:\n        closest_sensor = -1\n        closest_distance = float('inf')\n        for i in range(n):\n            distance = abs(x - a[i])\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_sensor = i\n        return closest_sensor\n\n    def find_closest_sensor_on_line(x: int, line: int) -> int:\n        closest_sensor = -1\n        closest_distance = float('inf')\n        for i in range(len(b[line])):\n            distance = abs(x - b[line][i])\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_sensor = i\n        return closest_sensor\n\n    def count_sensors_on_line(line: int) -> int:\n        count = 0\n        for i in range(len(b[line])):\n            count += 1\n        return count\n\n    def count_sensors_on_side(side: int) -> int:\n        count = 0\n        for i in range(len(a)):\n            if a[i] == side:\n                count += 1\n        return count\n\n    def count_sensors_on_side_and_line(side: int, line: int) -> int:\n        count = 0\n        for i in range(len(a)):\n            if a[i] == side and b[line][i] == side:\n                count += 1\n        return count\n\n    def count_sensors_on_side_and_line_and_closest_sensor(side: int, line: int, closest_sensor: int) -> int:\n        count = 0\n        for i in range(len(a)):\n            if a[i] == side and b[line][i] == side and i!= closest_sensor:\n                count += 1\n        return count\n\n    def count_sensors_on_side_and_line_and_closest_sensor_on_line(side: int, line: int, closest_sensor: int) -> int:\n        count = 0\n        for i in range(len(b[line])):\n            if a[i] == side and b[line][i] == side and i!= closest_sensor:\n                count += 1\n        return count\n\n    def count_sensors_on_side_and_line_and_closest_sensor_on_line_and_closest_sensor_on_line(side: int, line: int, closest_sensor: int) -> int:\n        count = 0\n        for i in range(len(b[line])):\n            if a[i] == side and b[line][i] == side and i!= closest_sensor and i!= closest_sensor_on_line:\n                count += 1\n        return count\n\n    def count_sensors_on_side_and_line_and_closest_sensor_on_line_and_closest_sensor_on_line_and_closest_sensor_on_line(side: int, line: int, closest_sensor: int, closest_sensor_on_line: int) -> int:\n        count = 0\n        for i in range(len(b[line])):\n            if a[i] == side and b[line][i] == side and i!= closest_sensor and i!= closest_sensor_on_line and i!= closest_sensor_on_line_and_closest_sensor_on_line:\n                count += 1\n        return count\n\n    def count_sensors_on_side_and_line_and_closest_sensor_on_line_and_closest_sensor_on_line_and_closest_sensor_on_line_and_closest_sensor_on_line(side: int, line: int, closest_sensor: int, closest_sensor_on_line: int, closest_sensor_on_line_and_closest_sensor_on_line: int) -> int:\n        count = 0\n        for i in range(len(b[line])):\n            if a[i] == side and b[line][i] == side and i!= closest_sensor and i!= closest_sensor_on_line and i!= closest_sensor_on_line_and_closest_sensor_on_line and i!= closest_sensor_on_line_and_closest_sensor_on_line_and_closest_sensor_on_line:\n                count += 1\n        return"
    },
    {
        "number": 1096,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    king_position = stdin.strip()\n    row, col = king_position[1], king_position[0]\n    moves = 0\n    directions = [(1, 2), (1, -2), (-1, 2), (-1, -2), (2, 1), (2, -1), (-2, 1), (-2, -1)]\n    for direction in directions:\n        new_row, new_col = row + direction[0], col + direction[1]\n        if 1 <= new_row <= 8 and 1 <= new_col <= 8:\n            moves += 1\n    return str(moves)"
    },
    {
        "number": 1097,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Check if it is possible to build roads\n    if sum(a)!= n - 1:\n        return -1\n\n    # Sort cities by distance from capital\n    cities = sorted(set(range(1, n + 1)), key=lambda x: a[x - 1])\n\n    # Find cities with exactly one road\n    dead_ends = [city for city in cities if len(cities) - len(set(cities) - {city}) == 1]\n\n    # Check if there are enough dead ends\n    if len(dead_ends) < k:\n        return -1\n\n    # Find the number of roads needed to connect all cities\n    def find_roads(city):\n        roads = 0\n        for other_city in cities:\n            if other_city!= city:\n                roads += a[other_city - 1]\n        return roads\n\n    roads = [find_roads(city) for city in cities]\n\n    # Find the number of cities with exactly one road\n    def count_roads(city):\n        return len([road for road in roads if road == find_roads(city)])\n\n    road_count = [count_roads(city) for city in cities]\n\n    # Find the cities with exactly one road\n    def find_cities(city):\n        return [city for city in cities if count_roads(city) == 1]\n\n    cities_with_one_road = [find_cities(city) for city in cities]\n\n    # Find the cities with exactly one road and the number of roads needed to connect them\n    def find_cities_and_roads(city):\n        cities_with_one_road_and_roads = []\n        for other_city in cities:\n            if count_roads(other_city) == 1 and other_city not in cities_with_one_road_and_roads:\n                cities_with_one_road_and_roads.append((other_city, find_roads(other_city)))\n        return cities_with_one_road_and_roads\n\n    cities_with_one_road_and_roads = [find_cities_and_roads(city) for city in cities]\n\n    # Find the cities with exactly one road and the number of roads needed to connect them\n    def find_cities_and_roads_with_dead_ends(city):\n        cities_with_one_road_and_roads_with_dead_ends = []\n        for other_city in cities:\n            if count_roads(other_city) == 1 and other_city not in cities_with_one_road_and_roads_with_dead_ends:\n                cities_with_one_road_and_roads_with_dead_ends.append((other_city, find_roads(other_city), dead_ends.index(other_city) + 1))\n        return cities_with_one_road_and_roads_with_dead_ends\n\n    cities_with_one_road_and_roads_with_dead_ends = [find_cities_and_roads_with_dead_ends(city) for city in cities]\n\n    # Find the cities with exactly one road and the number of roads needed to connect them\n    def find_cities_and_roads_with_dead_ends_and_roads(city):\n        cities_with_one_road_and_roads_with_dead_ends_and_roads = []\n        for other_city in cities:\n            if count_roads(other_city) == 1 and other_city not in cities_with_one_road_and_roads_with_dead_ends_and_roads:\n                cities_with_one_road_and_roads_with_dead_ends_and_roads.append((other_city, find_roads(other_city), dead_ends.index(other_city) + 1, find_roads(city)))\n        return cities_with_one_road_and_roads_with_dead_ends_and_roads\n\n    cities_with_one_road_and_roads_with_dead_ends_and_roads = [find_cities_and_roads_with_dead_ends_and_roads(city) for city in cities]\n\n    # Find the cities with exactly one road and the number of roads needed to connect them\n    def find_cities_and_roads_with_dead_ends_"
    },
    {
        "number": 1098,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alarms = [int(x.split(':')[0]) * 60 + int(x.split(':')[1]) for x in stdin.split('\\n')]\n    alarms.sort()\n    start = 0\n    end = 0\n    max_time = 0\n    for i in range(len(alarms)):\n        if alarms[i] - alarms[start] > max_time:\n            max_time = alarms[i] - alarms[start]\n            end = start\n        if alarms[i] - alarms[start] == max_time:\n            end = i\n    return f\"{end // 60}:{end % 60}\""
    },
    {
        "number": 1099,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in range(n):\n            if not visited[v] and (u, v) not in edges and (v, u) not in edges:\n                if dfs(v, visited):\n                    return True\n        return False\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u] and dfs(u, visited):\n            return \"0\"\n\n    return \"1\"\n"
    },
    {
        "number": 1100,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 3:\n        return \"1\"\n    elif n == 5:\n        return \"9\"\n    else:\n        return \"1\""
    },
    {
        "number": 1101,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    rooms = list(stdin.strip())\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n    rooms.pop(0)\n   "
    },
    {
        "number": 1102,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    criminals = [0] * n\n    for i in range(n):\n        criminals[i] = t[i]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(i - j) <= a:\n                criminals[i] += criminals[j]\n\n    return str(sum(criminals))"
    },
    {
        "number": 1103,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1].split()))\n\n    def count_occurrences(sequence: list, number: int) -> int:\n        count = 0\n        for num in sequence:\n            if num == number:\n                count += 1\n        return count\n\n    def is_valid_subsequence(sequence: list, subsequence: list) -> bool:\n        count_map = {}\n        for num in subsequence:\n            count_map[num] = count_map.get(num, 0) + 1\n\n        for num in sequence:\n            if num in count_map and count_map[num] > 1:\n                return False\n\n        return True\n\n    longest_subsequence = []\n    max_length = 0\n\n    for i in range(1, 9):\n        subsequence = [i]\n        current_length = 1\n\n        while current_length < n:\n            if count_occurrences(subsequence, i) == count_occurrences(subsequence, i - 1) + 1:\n                subsequence.append(i)\n                current_length += 1\n            else:\n                break\n\n        if current_length > max_length and is_valid_subsequence(sequence, subsequence):\n            max_length = current_length\n            longest_subsequence = subsequence\n\n    return str(max_length)"
    },
    {
        "number": 1104,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    a = [a[i] | a[i + 1] for i in range(n - 1)]\n    b = [b[i] & b[i + 1] for i in range(n - 1)]\n    for i in range(n - 2, -1, -1):\n        if a[i]!= b[i]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 1105,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    solutions = []\n    for _ in range(n):\n        x, k = map(int, stdin.split()[1:])\n        solutions.append((x, k))\n    solutions.sort()\n    for i in range(1, n):\n        if solutions[i][0] == solutions[i - 1][0] and solutions[i][1] == solutions[i - 1][1]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 1106,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def dfs(node, visited):\n        if node == 1:\n            return 0\n        if node in visited:\n            return visited[node]\n\n        visited[node] = min(dfs(2 * node, visited), dfs(2 * node + 1, visited)) + a[node - 2]\n        return visited[node]\n\n    return str(dfs(1, {}))"
    },
    {
        "number": 1107,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    moves = stdin.split()[1]\n    moves_dict = {'a': 1, 'b': 2}\n    max_glasses = 0\n    for i in range(len(moves)):\n        if moves[i] == 'a':\n            max_glasses = max(max_glasses, moves_dict[moves[i + 1]])\n        else:\n            max_glasses = max(max_glasses, moves_dict[moves[i - 1]])\n    return str(max_glasses)"
    },
    {
        "number": 1108,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rooms = []\n    for i in range(n):\n        p, q = map(int, stdin.split()[1:])\n        rooms.append((p, q))\n    rooms.sort(key=lambda x: (-x[0], x[1]))\n    count = 0\n    for p, q in rooms:\n        if p + q <= 100:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1109,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n            if count == k:\n                return 0\n\n    if count == 0:\n        return 0\n\n    for i in range(n - 1):\n        if a[i] == 1 and a[i + 1] == 2:\n            count -= 1\n            if count == 0:\n                return i + 1\n\n    return 0"
    },
    {
        "number": 1110,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = list(map(int, stdin.split()))\n    sequence.sort()\n    count = 0\n    for i in range(n):\n        if sequence[i] == i + 1:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 1111,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    MOD = 10**9 + 7\n\n    def partition(w):\n        w.sort()\n        return [w[:i] + w[i:] for i in range(1, len(w) + 1)]\n\n    def count_partitions(w):\n        partitions = partition(w)\n        return len(partitions)\n\n    def count_subsets(w):\n        return len(set(w))\n\n    def count_partitions_with_k_subsets(w, k):\n        partitions = partition(w)\n        count = 0\n        for partition in partitions:\n            if count_subsets(partition) == k:\n                count += 1\n        return count\n\n    def sum_weights(w):\n        return sum(w)\n\n    def sum_partitions_with_k_subsets(w, k):\n        partitions = partition(w)\n        total_weight = sum_weights(w)\n        count = 0\n        for partition in partitions:\n            if count_subsets(partition) == k:\n                count += sum_weights(partition)\n        return (count % MOD + MOD) % MOD\n\n    return str(sum_partitions_with_k_subsets(w, k))"
    },
    {
        "number": 1112,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = [list(map(int, row.split())) for row in stdin.split('\\n')]\n    magic_squares = []\n\n    for i in range(3):\n        for j in range(3):\n            if rows[i][j] == 0:\n                for k in range(3):\n                    if k!= i and k!= j:\n                        rows[i][j] = rows[i][k]\n                        rows[j][i] = rows[k][j]\n                        rows[i][k] = rows[j][i]\n                        rows[j][k] = rows[k][i]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j][k]\n                        rows[k][j] = rows[i][j]\n                        rows[k][i] = rows[j"
    },
    {
        "number": 1113,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(set(a))\n    a.sort()\n    for i in range(1, n):\n        a.append(mex(a[i-1], a[i]))\n    if a == list(range(1, n+1)):\n        return -1\n    else:\n        return str(a.index(max(a))+1)\n\ndef"
    },
    {
        "number": 1114,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a = [1] * m\n    for i in range(m):\n        a[i] = f[a[i - 1] - 1]\n\n    for i in range(m):\n        if b[i]!= a[i]:\n            return \"Impossible\"\n\n    return \"Possible\\n\" + \" \".join(map(str, a))\n"
    },
    {
        "number": 1115,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *l = map(int, stdin.split())\n    l = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:]]\n\n    def is_working(t: int) -> bool:\n        for i, (l, r) in enumerate(l):\n            if l <= t < r:\n                return True\n        return False\n\n    def solve(t: int) -> int:\n        for i, a_i in enumerate(a):\n            if t >= l[i][0] and t <= l[i][1]:\n                return a_i\n        return float('inf')\n\n    def solve_all(t: int) -> int:\n        return sum(solve(t + a_i) for a_i in a)\n\n    def min_time(t: int) -> int:\n        return max(solve(t), solve_all(t))\n\n    t = 0\n    while t < 10**6:\n        if is_working(t):\n            t = min_time(t)\n        else:\n            t += 1\n\n    return str(t) if t < 10**6 else '-1'"
    },
    {
        "number": 1116,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        r, b, k = map(int, stdin.split()[1:])\n        if r == 1 and b == 1:\n            print(\"OBEY\")\n        elif r == 1 and b == 2:\n            print(\"REBEL\")\n        elif r == 2 and b == 1:\n            print(\"OBEY\")\n        elif r == 2 and b == 2:\n            print(\"REBEL\")\n        else:\n            print(\"REBEL\")"
    },
    {
        "number": 1117,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rectangles = []\n    for i in range(n):\n        w, h = map(int, stdin.split()[1:3])\n        rectangles.append((w, h))\n    rectangles.sort(key=lambda x: x[1])\n    for i in range(n - 1):\n        if rectangles[i][1] > rectangles[i + 1][1]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 1118,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *colors = map(int, stdin.split())\n    colors = set(colors)\n    if len(colors) == 1:\n        return \"0\"\n\n    def dfs(i, color):\n        if i == n:\n            return 0\n\n        if colors.issubset({color}):\n            return dfs(i + 1, color)\n\n        for c in colors:\n            if dfs(i + 1, c) == 0:\n                return 1\n\n        return 0\n\n    return str(dfs(0, colors.pop()))\n"
    },
    {
        "number": 1119,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p_a, p_b = map(int, stdin.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def coprime(a, b):\n        return gcd(a, b) == 1\n\n    def mod_pow(a, b, m):\n        res = 1\n        while b:\n            if b & 1:\n                res = (res * a) % m\n            a = (a * a) % m\n            b >>= 1\n        return res\n\n    def mod_inv(a, m):\n        return mod_pow(a, m - 2, m)\n\n    def count_subsequences(sequence):\n        count = 0\n        for i in range(len(sequence) - 1):\n            if sequence[i] == sequence[i + 1]:\n                count += 1\n        return count\n\n    def construct_sequence(p_a, p_b):\n        sequence = []\n        while True:\n            if random.random() < p_a / (p_a + p_b):\n                sequence.append('a')\n            else:\n                sequence.append('b')\n            if count_subsequences(sequence) >= k:\n                break\n        return sequence\n\n    def expected_subsequences(p_a, p_b):\n        sequence = construct_sequence(p_a, p_b)\n        return count_subsequences(sequence)\n\n    def main():\n        p_a, p_b = p_a % (10**9 + 7), p_b % (10**9 + 7)\n        if not coprime(p_a, p_b):\n            return \"Invalid input\"\n\n        P = lcm(p_a, p_b)\n        Q = gcd(p_a, p_b)\n\n        if Q == 1:\n            return \"Invalid input\"\n\n        P_inv = mod_inv(P, 10**9 + 7)\n        Q_inv = mod_inv(Q, 10**9 + 7)\n\n        return (P * Q_inv) % (10**9 + 7)\n\n    return str(main())"
    },
    {
        "number": 1120,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n <= 10**6:\n        return str(min(n, 10**6))\n    elif n <= 10**12:\n        return str(min(n, 10**12) - 1)\n    else:\n        return str(min(n, 10**18) - 2)"
    },
    {
        "number": 1121,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n    color_count = [0] * 26\n    color_mapping = {}\n    for i in range(n):\n        for j in range(m):\n            color = colors[color_count[ord(stdin[i*m+j]) - ord('A')] % 26]\n            color_mapping[(i, j)] = color\n            color_count[ord(stdin[i*m+j]) - ord('A')] += 1\n    color_mapping = sorted(color_mapping.items())\n    result = []\n    for i in range(n):\n        for j in range(m):\n            result.append(color_mapping[i*m+j][1])\n    return ''.join(result)"
    },
    {
        "number": 1122,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    playing_fields = set()\n    for _ in range(m):\n        a, b = map(int, input().split())\n        playing_fields.add(a)\n        playing_fields.add(b)\n\n    for i in range(1, n + 1):\n        for j in range(m):\n            if i in playing_fields:\n                playing_fields.remove(i)\n                playing_fields.add(j + 1)\n\n    return \"\\n\".join(f\"{a} {b}\" for a, b in playing_fields)"
    },
    {
        "number": 1123,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    MOD_INV = pow(MOD - 2, MOD - 2, MOD)\n\n    def gcd(a: int, b: int) -> int:\n        return b if b == 0 else gcd(b, a % b)\n\n    def mod_gcd(a: int, b: int) -> int:\n        return (a * b) % MOD\n\n    def mod_pow(a: int, b: int) -> int:\n        return pow(a, b, MOD)\n\n    def mod_inv(a: int) -> int:\n        return pow(a, MOD_INV, MOD)\n\n    def mod_mult(a: int, b: int) -> int:\n        return (a * b) % MOD\n\n    def mod_add(a: int, b: int) -> int:\n        return (a + b) % MOD\n\n    def mod_sub(a: int, b: int) -> int:\n        return (a - b + MOD) % MOD\n\n    def mod_div(a: int, b: int) -> int:\n        return (a * mod_inv(b)) % MOD\n\n    def mod_gcd_sum(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd(a, b)), mod_mult(b, mod_gcd(b, a)))\n\n    def mod_gcd_sum_all(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum(a, b)), mod_mult(b, mod_gcd_sum(b, a)))\n\n    def mod_gcd_sum_all_pow(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all(a, b)), mod_mult(b, mod_gcd_sum_all(b, a)))\n\n    def mod_gcd_sum_all_pow_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow(a, b)), mod_mult(b, mod_gcd_sum_all_pow(b, a)))\n\n    def mod_gcd_sum_all_pow_inv_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow_inv(a, b)), mod_mult(b, mod_gcd_sum_all_pow_inv(b, a)))\n\n    def mod_gcd_sum_all_pow_inv_inv_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow_inv_inv(a, b)), mod_mult(b, mod_gcd_sum_all_pow_inv_inv(b, a)))\n\n    def mod_gcd_sum_all_pow_inv_inv_inv_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow_inv_inv_inv(a, b)), mod_mult(b, mod_gcd_sum_all_pow_inv_inv_inv(b, a)))\n\n    def mod_gcd_sum_all_pow_inv_inv_inv_inv_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow_inv_inv_inv_inv(a, b)), mod_mult(b, mod_gcd_sum_all_pow_inv_inv_inv_inv(b, a)))\n\n    def mod_gcd_sum_all_pow_inv_inv_inv_inv_inv_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow_inv_inv_inv_inv_inv(a, b)), mod_mult(b, mod_gcd_sum_all_pow_inv_inv_inv_inv_inv(b, a)))\n\n    def mod_gcd_sum_all_pow_inv_inv_inv_inv_inv_inv_inv(a: int, b: int) -> int:\n        return mod_add(mod_mult(a, mod_gcd_sum_all_pow_inv_inv_inv_inv_inv"
    },
    {
        "number": 1124,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    x, X = max(a), min(a)\n    while x!= X:\n        x = max(a)\n        for i in range(n):\n            if a[i] == x:\n                a[i] = x - (x - X)\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1125,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(int, a))\n\n    def min_stones(piles: List[int]) -> int:\n        piles.sort(reverse=True)\n        return piles[0]\n\n    def max_stones(piles: List[int]) -> int:\n        piles.sort()\n        return piles[-1]\n\n    def min_moves(piles: List[int]) -> int:\n        return min_stones(piles) - 1\n\n    def max_moves(piles: List[int]) -> int:\n        return max_stones(piles) - 1\n\n    def min_moves_takahashi(piles: List[int]) -> int:\n        return min_stones(piles)\n\n    def max_moves_takahashi(piles: List[int]) -> int:\n        return max_stones(piles)\n\n    if min_moves_takahashi(a) <= max_moves_takahashi(a):\n        return str(min_moves_takahashi(a))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 1126,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, M = map(int, stdin.split())\n    A = [X]\n    for i in range(N):\n        A.append(pow(A[i], 2, M))\n    return str(sum(A))"
    },
    {
        "number": 1127,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        num = int(stdin.split()[2])\n        last_digit = num % 10\n        if last_digit % 2 == 0:\n            print(\"1\")\n        else:\n            print(\"2\")\n    return \"\""
    },
    {
        "number": 1128,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m = map(int, stdin.split())\n    if a % m == 0:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1129,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = list(map(int, stdin.split()[1:]))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    points.sort(key=lambda x: distance(x, points[0]))\n\n    return str(points[0][0])"
    },
    {
        "number": 1130,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    lessons = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(i, j):\n        return all(lessons[i][j] == 1)\n\n    def min_hours(i, j, skip):\n        if skip == 0:\n            return 0\n\n        if i == n:\n            return 0\n\n        if is_valid(i, j):\n            return 1 + min_hours(i + 1, j, skip - 1)\n\n        return min_hours(i + 1, j, skip)\n\n    return str(min_hours(0, 0, k))"
    },
    {
        "number": 1131,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, w, x, c = map(int, stdin.split())\n\n    if a > c:\n        return \"0\"\n\n    if a == c:\n        return \"1\"\n\n    count = 0\n    while c > a:\n        count += 1\n        if b >= x:\n            b -= x\n        else:\n            a -= 1\n            b = w - (x - b)\n\n    return str(count)"
    },
    {
        "number": 1132,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        x, y = map(int, stdin.split()[1:3])\n        graph[x].append(y)\n        graph[y].append(x)\n\n    bus_count = 0\n    ring_count = 0\n    star_count = 0\n\n    for i in range(1, n + 1):\n        if len(graph[i]) == 2:\n            bus_count += 1\n        elif len(graph[i]) == 4:\n            ring_count += 1\n        else:\n            star_count += 1\n\n    if bus_count == 1:\n        return \"bus topology\"\n    elif ring_count == 1:\n        return \"ring topology\"\n    elif star_count == 1:\n        return \"star topology\"\n    else:\n        return \"unknown topology\""
    },
    {
        "number": 1133,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    word_lengths = [len(word) for word in words]\n    max_length = max(word_lengths)\n    max_words = [word for word in words if len(word) == max_length]\n    return str(max_length)"
    },
    {
        "number": 1134,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    marks = list(map(int, stdin.split()[1:]))\n\n    min_sum = float('inf')\n    for i in range(n):\n        if marks[i] > 0:\n            min_sum = min(min_sum, marks[i])\n        else:\n            min_sum = min(min_sum, 0)\n\n    return str(min_sum)"
    },
    {
        "number": 1135,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    word = \"\"\n    for i in range(n):\n        if s[i] == \"a\":\n            word += \"b\"\n        elif s[i] == \"b\":\n            word += \"a\"\n        else:\n            word += s[i]\n    return word"
    },
    {
        "number": 1136,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = 0\n    MOD = 10**9 + 7\n    for i in range(1, m + 1):\n        s = (s + n % MOD) % MOD\n    return str(s)"
    },
    {
        "number": 1137,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    def is_disjoint(s1: str, s2: str) -> bool:\n        for i in range(len(s1)):\n            if s1[i] in s2:\n                return False\n        return True\n\n    def max_length(s: str) -> int:\n        return max(len(s), len(s[::-1]))\n\n    def find_disjoint_substrings(s: str, k: int) -> List[str]:\n        result = []\n        for i in range(len(s) - k + 1):\n            substring = s[i:i + k]\n            if all(is_disjoint(substring, s[j:j + k]) for j in range(i + k, len(s) + 1)):\n                result.append(substring)\n        return result\n\n    def find_max_length_substrings(s: str, k: int) -> List[str]:\n        result = []\n        for i in range(len(s) - k + 1):\n            substring = s[i:i + k]\n            if all(is_disjoint(substring, s[j:j + k]) for j in range(i + k, len(s) + 1)):\n                if len(substring) > max_length(result):\n                    result = [substring]\n                elif len(substring) == max_length(result):\n                    result.append(substring)\n        return result\n\n    def find_max_length_substrings_with_order(s: str, k: int) -> List[str]:\n        result = []\n        for i in range(len(s) - k + 1):\n            substring = s[i:i + k]\n            if all(is_disjoint(substring, s[j:j + k]) for j in range(i + k, len(s) + 1)):\n                if len(substring) > max_length(result):\n                    result = [substring]\n                elif len(substring) == max_length(result):\n                    result.append(substring)\n        return result\n\n    def find_max_length_substrings_with_order_and_length(s: str, k: int) -> List[str]:\n        result = []\n        for i in range(len(s) - k + 1):\n            substring = s[i:i + k]\n            if all(is_disjoint(substring, s[j:j + k]) for j in range(i + k, len(s) + 1)):\n                if len(substring) > max_length(result):\n                    result = [substring]\n                elif len(substring) == max_length(result):\n                    result.append(substring)\n        return result\n\n    def find_max_length_substrings_with_order_and_length_and_sum(s: str, k: int) -> int:\n        result = find_max_length_substrings_with_order_and_length(s, k)\n        return sum(len(substring) for substring in result)\n\n    max_length_substrings = find_max_length_substrings(s, k)\n    max_length_substrings_with_order = find_max_length_substrings_with_order(s, k)\n    max_length_substrings_with_order_and_length = find_max_length_substrings_with_order_and_length(s, k)\n    max_length_substrings_with_order_and_length_and_sum = find_max_length_substrings_with_order_and_length_and_sum(s, k)\n\n    return str(max_length_substrings_with_order_and_length_and_sum)\n"
    },
    {
        "number": 1138,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    directions = s.split('')\n    directions = [d if d in 'LRUD' else 'L' for d in directions]\n    directions = ''.join(directions)\n    directions = directions.replace('L', 'U').replace('R', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R').replace('D', 'L')\n    directions = directions.replace('R', 'U').replace('L', 'D')\n    directions = directions.replace('U', 'R')."
    },
    {
        "number": 1139,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    intervals = []\n    for i in range(1, n + 1):\n        k = int(stdin.readline().strip())\n        intervals.append([int(stdin.readline().strip()) for _ in range(k)])\n\n    max_quality = 0\n    for interval in itertools.product(*intervals):\n        quality = sum(interval) ** 2\n        max_quality = max(max_quality, quality)\n\n    return str(max_quality)"
    },
    {
        "number": 1140,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    beauty_numbers = list(map(int, stdin.split()[1:]))\n\n    max_beauty_difference = 0\n    ways = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            beauty_difference = beauty_numbers[i] - beauty_numbers[j]\n            if beauty_difference > max_beauty_difference:\n                max_beauty_difference = beauty_difference\n                ways = 1\n            elif beauty_difference == max_beauty_difference:\n                ways += 1\n\n    return f\"{max_beauty_difference} {ways}\""
    },
    {
        "number": 1141,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    operations = []\n    for _ in range(m):\n        l, r, c_1, c_2 = map(int, stdin.split())\n        operations.append((l, r, c_1, c_2))\n    for l, r, c_1, c_2 in operations:\n        s = s[:l-1] + c_2 + s[r:]\n    return s"
    },
    {
        "number": 1142,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    waves = []\n    for _ in range(n):\n        l, r, a = map(int, stdin.split())\n        waves.append((l, r, a))\n\n    waves.sort(key=lambda x: (x[0], x[1]))\n\n    def exterminate(wave, bullets):\n        nonlocal bullets\n        if wave[1] <= bullets:\n            return 0, bullets\n        else:\n            return exterminate(wave, bullets - wave[1])\n\n    def reload(magazine, bullets):\n        nonlocal bullets\n        if magazine == 0:\n            return 0, bullets\n        else:\n            return reload(magazine - 1, bullets)\n\n    def clear_waves(waves, bullets):\n        nonlocal bullets\n        if not waves:\n            return 0, bullets\n        else:\n            wave, *rest = waves\n            used, bullets = exterminate(wave, bullets)\n            if used:\n                return used, bullets\n            else:\n                return clear_waves(rest, bullets)\n\n    used, bullets = clear_waves(waves, k)\n    if used:\n        return used\n    else:\n        return -1"
    },
    {
        "number": 1143,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    olympiads = []\n    for i in range(n):\n        olympiad = list(map(int, stdin.split('\\n')[i+1].split()))\n        olympiad.append(datetime(2013, olympiad[0], olympiad[1]))\n        olympiads.append(olympiad)\n\n    olympiads.sort(key=lambda x: x[2])\n\n    min_jury_size = 1\n    for i in range(n):\n        if olympiads[i][2] == olympiads[i][3]:\n            min_jury_size = max(min_jury_size, olympiads[i][1])\n        else:\n            min_jury_size = max(min_jury_size, olympiads[i][1] + 1)\n\n    return str(min_jury_size)"
    },
    {
        "number": 1144,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    m = 0\n    for i in range(n):\n        if s[i] == '?':\n            m += 1\n    if m == 0:\n        return \"0\"\n    t = \"a\" * m\n    return str(min(s.count(t), s.count(t.replace(\"a\", \"?\"))))"
    },
    {
        "number": 1145,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    min_coins = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if a.issubset({a[i], a[j]}):\n                min_coins = min(min_coins, a[i] + a[j])\n    return str(min_coins)"
    },
    {
        "number": 1146,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    buttons = [list(map(int, stdin.split())) for _ in range(n)]\n    bulbs = [0] * m\n\n    for button, connected_bulbs in buttons:\n        for connected_bulb in connected_bulbs:\n            bulbs[connected_bulb - 1] = 1\n\n    for i in range(m):\n        if bulbs[i] == 0:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1147,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_pairs(a, x, k):\n        pairs = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] <= a[j] and a[i] % x == 0 and a[j] % x == 0:\n                    pairs.add((i, j))\n        return pairs\n\n    pairs = find_pairs(a, x, k)\n    return str(len(pairs))"
    },
    {
        "number": 1148,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [a[i-1] for i in range(1, n+1)]\n    max_squares = 0\n    color = 1\n    for i in range(1, n+1):\n        if a[i-1] > 0:\n            max_squares += a[i-1]\n            color = (color + 1) % (i+1)\n    return str(max_squares)"
    },
    {
        "number": 1149,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, *a_x, q, *a_y = map(int, stdin.split())\n    a_x = set(a_x)\n    a_y = set(a_y)\n\n    if len(a_x.intersection(a_y)) == 0:\n        return \"I become the guy.\"\n    else:\n        return \"Oh, my keyboard!\""
    },
    {
        "number": 1150,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    moles = []\n    for i in range(n):\n        x, y, a, b = map(int, stdin.split()[1:5])\n        moles.append((x, y, a, b))\n    moles.sort(key=lambda x: (x[0], x[1]))\n    moves = 0\n    for i in range(n):\n        if i == 0 or moles[i][0]!= moles[i - 1][0] or moles[i][1]!= moles[i - 1][1]:\n            moves += 1\n        if i == n - 1 or moles[i][0]!= moles[i + 1][0] or moles[i][1]!= moles[i + 1][1]:\n            moves += 1\n    if moves == 0:\n        return \"-1\"\n    return str(moves)"
    },
    {
        "number": 1151,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, U = map(int, stdin.split())\n    E = list(map(int, stdin.split()))\n\n    E.sort()\n    E.append(E[-1] + 1)\n\n    def is_valid(i, j, k):\n        return E[k] - E[i] <= U\n\n    def max_energy_conversion_efficiency(i, j, k):\n        if not is_valid(i, j, k):\n            return -1\n\n        eta = (E[k] - E[j]) / (E[k] - E[i])\n        return eta\n\n    max_efficiency = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                efficiency = max_energy_conversion_efficiency(i, j, k)\n                if efficiency > max_efficiency:\n                    max_efficiency = efficiency\n\n    if max_efficiency == 0:\n        return \"0.0\"\n    else:\n        return f\"{max_efficiency:.9f}\""
    },
    {
        "number": 1152,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    A = [[int(x) for x in stdin.split()[2:2+n]] for _ in range(n)]\n    B = [[int(x) for x in stdin.split()[2+n:2+2*n]] for _ in range(n)]\n    \n    def invert_corners(matrix):\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    matrix[i][j] = 1\n                else:\n                    matrix[i][j] = 0\n        return matrix\n    \n    def can_transform(A, B):\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j]!= B[i][j]:\n                    return False\n        return True\n    \n    def transform(A, B):\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j] == 0:\n                    A[i][j] = 1\n                else:\n                    A[i][j] = 0\n        return A\n    \n    def can_transform_with_corners(A, B):\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j]!= B[i][j]:\n                    return False\n        return True\n    \n    def transform_with_corners(A, B):\n        for i in range(len(A)):\n            for j in range(len(A[0])):\n                if A[i][j] == 0:\n                    A[i][j] = 1\n                else:\n                    A[i][j] = 0\n        return A\n    \n    if can_transform(A, B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \n    return \"Yes\" if can_transform_with_corners(A, B) else \"No\""
    },
    {
        "number": 1153,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    if sum(x)!= sum(y):\n        return \"IMPOSSIBLE\"\n\n    x.sort()\n    y.sort()\n\n    i = 0\n    j = 0\n    max_files = 0\n\n    while i < n and j < m:\n        if x[i] <= y[j]:\n            max_files += 1\n            i += 1\n        else:\n            max_files += 1\n            j += 1\n\n    return str(max_files)"
    },
    {
        "number": 1154,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def smash(height: int, remaining: int) -> int:\n        if remaining >= k:\n            return height + k\n        else:\n            return height + remaining\n\n    def process(heights: list) -> int:\n        remaining = sum(heights)\n        heights = [smash(h, remaining) for h in heights]\n        return sum(heights)\n\n    def process_potatoes(potatoes: list) -> int:\n        heights = [p.height for p in potatoes]\n        return process(heights)\n\n    potatoes = [Potato(i, a[i]) for i in range(n)]\n    start_time = time.time()\n    while process_potatoes(potatoes) > 0:\n        pass\n    end_time = time.time()\n    return str(int(end_time - start_time))\n\n\nclass Potato:\n    def __init__(self, index: int, height: int):\n        self.index = index\n        self.height = height\n"
    },
    {
        "number": 1155,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    supermarkets = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        supermarkets.append((a, b))\n\n    def min_cost(kilos: int) -> float:\n        total_cost = 0\n        for a, b in supermarkets:\n            total_cost += a / b * kilos\n        return total_cost\n\n    return str(min_cost(m))"
    },
    {
        "number": 1156,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = list(stdin.split()[1:])\n\n    l = 0\n    r = 10**9\n\n    for i in range(n):\n        if a[i] < l:\n            b[i] = 1\n        elif a[i] > r:\n            b[i] = 0\n        else:\n            b[i] = 1\n\n    for i in range(n):\n        if b[i] == 1:\n            if a[i] - 1 < l:\n                b[i] = 0\n            elif a[i] - 2 < l:\n                b[i] = 0\n            elif a[i] - 3 < l:\n                b[i] = 0\n            elif a[i] - 4 < l:\n                b[i] = 0\n            else:\n                b[i] = 1\n        elif b[i] == 0:\n            if a[i] - 1 > r:\n                b[i] = 1\n            elif a[i] - 2 > r:\n                b[i] = 1\n            elif a[i] - 3 > r:\n                b[i] = 1\n            elif a[i] - 4 > r:\n                b[i] = 1\n            else:\n                b[i] = 0\n        else:\n            if a[i] - 1 < l:\n                b[i] = 0\n            elif a[i] - 2 < l:\n                b[i] = 0\n            elif a[i] - 3 < l:\n                b[i] = 0\n            elif a[i] - 4 < l:\n                b[i] = 0\n            else:\n                b[i] = 1\n\n    for i in range(n):\n        if b[i] == 1:\n            if a[i] - 1 < l:\n                b[i] = 0\n            elif a[i] - 2 < l:\n                b[i] = 0\n            elif a[i] - 3 < l:\n                b[i] = 0\n            elif a[i] - 4 < l:\n                b[i] = 0\n            else:\n                b[i] = 1\n        elif b[i] == 0:\n            if a[i] - 1 > r:\n                b[i] = 1\n            elif a[i] - 2 > r:\n                b[i] = 1\n            elif a[i] - 3 > r:\n                b[i] = 1\n            elif a[i] - 4 > r:\n                b[i] = 1\n            else:\n                b[i] = 0\n        else:\n            if a[i] - 1 < l:\n                b[i] = 0\n            elif a[i] - 2 < l:\n                b[i] = 0\n            elif a[i] - 3 < l:\n                b[i] = 0\n            elif a[i] - 4 < l:\n                b[i] = 0\n            else:\n                b[i] = 1\n\n    for i in range(n):\n        if b[i] == 1:\n            if a[i] - 1 < l:\n                b[i] = 0\n            elif a[i] - 2 < l:\n                b[i] = 0\n            elif a[i] - 3 < l:\n                b[i] = 0\n            elif a[i] - 4 < l:\n                b[i] = 0\n            else:\n                b[i] = 1\n        elif b[i] == 0:\n            if a[i] - 1 > r:\n                b[i] = 1\n            elif a[i] - 2 > r:\n                b[i] = 1\n            elif a[i] - 3 > r:\n                b[i] = 1\n            elif a[i] - 4 > r:\n                b[i] = 1\n            else:\n                b[i] = 0\n        else:\n            if a[i] - 1 < l:\n                b[i] = 0\n            elif a[i] - 2 < l:\n                b[i] = 0\n            elif a[i] - 3 < l:\n                b[i] = 0\n            elif a[i] - 4 < l:\n                b[i] = 0\n            else:\n                b[i] = 1\n\n    for i in range(n):"
    },
    {
        "number": 1157,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    negative_product = 0\n    positive_product = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            product = 1\n            for k in range(i, j + 1):\n                product *= a[k]\n            if product < 0:\n                negative_product += 1\n            elif product > 0:\n                positive_product += 1\n\n    return f\"{negative_product} {positive_product}\""
    },
    {
        "number": 1158,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    utensils = set(a)\n    min_utensils = 100\n\n    for i in range(1, 101):\n        if i not in utensils:\n            min_utensils = min(min_utensils, i)\n\n    return str(min_utensils)"
    },
    {
        "number": 1159,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 3 or n > 1000:\n        return \"-1\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_valid_graph(graph: List[List[int]]) -> bool:\n        for i in range(len(graph)):\n            for j in range(i + 1, len(graph)):\n                if graph[i][j] == 1 or graph[j][i] == 1:\n                    return False\n        return True\n\n    def is_valid_degree(graph: List[List[int]]) -> bool:\n        for i in range(len(graph)):\n            if not is_prime(graph[i].count(1)):\n                return False\n        return True\n\n    def is_valid_edge_count(graph: List[List[int]]) -> bool:\n        total_edges = sum(sum(graph[i]) for i in range(len(graph)))\n        return is_prime(total_edges)\n\n    def is_valid_graph_conditions(graph: List[List[int]]) -> bool:\n        return is_valid_graph(graph) and is_valid_degree(graph) and is_valid_edge_count(graph)\n\n    def generate_graph(n: int) -> List[List[int]]:\n        graph = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(i + 1, n):\n                graph[i][j] = 1\n                graph[j][i] = 1\n        return graph\n\n    def generate_valid_graph(n: int) -> List[List[int]]:\n        graph = generate_graph(n)\n        while not is_valid_graph_conditions(graph):\n            graph = generate_graph(n)\n        return graph\n\n    def generate_valid_graph_with_degree(n: int) -> List[List[int]]:\n        graph = generate_valid_graph(n)\n        while not is_valid_degree(graph):\n            graph = generate_valid_graph(n)\n        return graph\n\n    def generate_valid_graph_with_edge_count(n: int) -> List[List[int]]:\n        graph = generate_valid_graph(n)\n        while not is_valid_edge_count(graph):\n            graph = generate_valid_graph(n)\n        return graph\n\n    def generate_valid_graph_with_conditions(n: int) -> List[List[int]]:\n        graph = generate_valid_graph(n)\n        while not is_valid_graph_conditions(graph):\n            graph = generate_valid_graph(n)\n        return graph\n\n    def generate_valid_graph_with_degree_and_edge_count(n: int) -> List[List[int]]:\n        graph = generate_valid_graph_with_degree(n)\n        while not is_valid_edge_count(graph):\n            graph = generate_valid_graph_with_degree(n)\n        return graph\n\n    def generate_valid_graph_with_degree_and_conditions(n: int) -> List[List[int]]:\n        graph = generate_valid_graph_with_degree(n)\n        while not is_valid_graph_conditions(graph):\n            graph = generate_valid_graph_with_degree(n)\n        return graph\n\n    def generate_valid_graph_with_edge_count_and_conditions(n: int) -> List[List[int]]:\n        graph = generate_valid_graph_with_edge_count(n)\n        while not is_valid_graph_conditions(graph):\n            graph = generate_valid_graph_with_edge_count(n)\n        return graph\n\n    def generate_valid_graph_with_degree_edge_count_and_conditions(n: int) -> List[List[int]]:\n        graph = generate_valid_graph_with_degree_and_edge_count(n)\n        while not is_valid_graph_conditions(graph):\n            graph = generate_valid_graph_with_degree_and_edge_count(n)\n        return graph\n\n    def generate_valid_graph_with_degree_edge_count_and_conditions_with_prime_degree(n: int) -> List[List[int]]:\n        graph = generate_valid_graph_with_degree_edge_count_and_conditions(n)\n        while not is_valid_degree(graph):\n            graph = generate_valid_graph_with_"
    },
    {
        "number": 1160,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sizes = [int(x) for x in stdin.split()]\n    n = int(stdin.split()[1])\n    participants = []\n\n    for _ in range(n):\n        sizes_input = stdin.split()[2].split(',')\n        sizes_input = [x.strip() for x in sizes_input]\n        sizes_input = [int(x) for x in sizes_input]\n        participants.append(sizes_input)\n\n    def is_valid(sizes_list):\n        for i in range(len(sizes_list) - 1):\n            if sizes_list[i] + 1 == sizes_list[i + 1]:\n                return False\n        return True\n\n    def find_valid_distribution(sizes_list):\n        for i in range(len(sizes_list) - 1):\n            if sizes_list[i] + 1 == sizes_list[i + 1]:\n                return [sizes_list[i], sizes_list[i + 1]]\n        return []\n\n    valid_distributions = []\n    for i in range(len(sizes)):\n        valid_distributions.append(find_valid_distribution(sizes[i]))\n\n    for participant in participants:\n        valid_distribution = find_valid_distribution(participant)\n        if valid_distribution:\n            valid_distributions.remove(valid_distribution)\n\n    if not valid_distributions:\n        return \"NO\"\n\n    for valid_distribution in valid_distributions:\n        print(valid_distribution)\n\n    return \"YES\"\n"
    },
    {
        "number": 1161,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    stack = []\n    opens = {'<': '{', '{': '}', '[': ']', '(': ')'}\n    closes = {'<': '>', '{': '}', '[': ']', '(': '}'}\n\n    for c in s:\n        if c in opens:\n            stack.append(c)\n        elif c in closes:\n            if not stack or opens[stack.pop()]!= c:\n                return \"Impossible\"\n\n    return len(stack)"
    },
    {
        "number": 1162,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, s, r = map(int, stdin.split())\n    if p == 1:\n        return \"1\"\n\n    def count_wins(a: int, b: int) -> int:\n        return (a + b) // 2\n\n    def count_ties(a: int, b: int) -> int:\n        return (a + b) % 2\n\n    def count_loses(a: int, b: int) -> int:\n        return abs(a - b)\n\n    def count_wins_ties_loses(a: int, b: int) -> int:\n        return count_wins(a, b) + count_ties(a, b) + count_loses(a, b)\n\n    def count_wins_ties_loses_pairs(a: int, b: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, a)\n\n    def count_wins_ties_loses_triplets(a: int, b: int, c: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, c) + count_wins_ties_loses(c, a)\n\n    def count_wins_ties_loses_quadruplets(a: int, b: int, c: int, d: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, c) + count_wins_ties_loses(c, d) + count_wins_ties_loses(d, a)\n\n    def count_wins_ties_loses_quintuplets(a: int, b: int, c: int, d: int, e: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, c) + count_wins_ties_loses(c, d) + count_wins_ties_loses(d, e) + count_wins_ties_loses(e, a)\n\n    def count_wins_ties_loses_sextuplets(a: int, b: int, c: int, d: int, e: int, f: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, c) + count_wins_ties_loses(c, d) + count_wins_ties_loses(d, e) + count_wins_ties_loses(e, f) + count_wins_ties_loses(f, a)\n\n    def count_wins_ties_loses_septuplets(a: int, b: int, c: int, d: int, e: int, f: int, g: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, c) + count_wins_ties_loses(c, d) + count_wins_ties_loses(d, e) + count_wins_ties_loses(e, f) + count_wins_ties_loses(f, g) + count_wins_ties_loses(g, a)\n\n    def count_wins_ties_loses_octuplets(a: int, b: int, c: int, d: int, e: int, f: int, g: int, h: int) -> int:\n        return count_wins_ties_loses(a, b) + count_wins_ties_loses(b, c) + count_wins_ties_loses(c, d) + count_wins_ties_loses(d, e) + count_wins_ties_loses(e, f) + count_wins_ties_loses(f, g) + count_wins_ties_loses(g, h) + count_wins_ties_loses(h, a)\n\n    def count_wins_ties_loses_non_negative(a: int, b: int) -> int:\n        return max(count_wins_ties_loses(a, b), 0)\n\n    def count_wins_ties_loses_non_negative_pairs(a: int, b: int) -> int:\n        return max(count_wins_ties_loses_pairs(a, b), 0)\n\n    def count_wins_ties"
    },
    {
        "number": 1163,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    line = ['B'] * n + ['G'] * m\n    for i in range(1, n + m, 2):\n        line[i] = 'B' if line[i] == 'G' else 'G'\n    return ''.join(line)"
    },
    {
        "number": 1164,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    total_price = 0\n    for purchase in stdin.split(\".\"):\n        if purchase.isdigit():\n            total_price += int(purchase)\n        else:\n            dollars, cents = purchase.split(\".\")\n            dollars = int(dollars)\n            cents = int(cents)\n            total_price += dollars + cents / 100\n    return f\"{total_price:.2f}\""
    },
    {
        "number": 1165,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        l, r, x = map(int, stdin.split())\n        queries.append((l, r, x))\n\n    for l, r, x in queries:\n        for i in range(l, r + 1):\n            if a[i]!= x:\n                print(i)\n                break\n        else:\n            print(-1)"
    },
    {
        "number": 1166,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    s = \"\"\n    for i in range(n):\n        if i == 0:\n            s += \"A\"\n        elif i == n - 1:\n            s += \"B\"\n        else:\n            s += \"A\" if a[i] > a[i - 1] else \"B\"\n    return s"
    },
    {
        "number": 1167,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        a, b, c, d, k = map(int, stdin.split('\\n')[1].split())\n        if a + b + c + d > k:\n            print(-1)\n        else:\n            x = min(a, b, c, d)\n            y = max(a, b, c, d) - x\n            print(x, y)"
    },
    {
        "number": 1168,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def bitwise_or(a: list) -> int:\n        result = 0\n        for i in range(len(a)):\n            result |= a[i]\n        return result\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bitwise_or(a[i:j + 1]) > bitwise_or(a[j:i + 1]):\n                pairs.append((i, j))\n\n    return str(len(pairs))"
    },
    {
        "number": 1169,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n        edges.append((b, a))\n    edges.sort()\n    visited = [False] * (n + 1)\n    min_isolated = max_isolated = 0\n    for a, b in edges:\n        if not visited[a] and not visited[b]:\n            visited[a] = visited[b] = True\n            min_isolated += 1\n            max_isolated += 1\n        elif not visited[a]:\n            visited[a] = True\n            min_isolated += 1\n        elif not visited[b]:\n            visited[b] = True\n            max_isolated += 1\n    return f\"{min_isolated} {max_isolated}\""
    },
    {
        "number": 1170,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        x = int(stdin.split()[1])\n        if x == 0:\n            print(\"0 0\")\n        else:\n            n = 1\n            m = 1\n            while n * m <= x:\n                n += 1\n                m += 1\n            if n * m > x:\n                n -= 1\n                m -= 1\n            print(n, m)"
    },
    {
        "number": 1171,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    jewels = list(map(int, stdin.split()))\n\n    def dequeue(jewels: list) -> list:\n        if not jewels:\n            return []\n        return [jewels.pop(0)] + dequeue(jewels)\n\n    def enqueue(jewels: list, value: int) -> list:\n        return [value] + jewels\n\n    def take_out_left(jewels: list) -> int:\n        if not jewels:\n            return -1\n        return jewels.pop(0)\n\n    def take_out_right(jewels: list) -> int:\n        if not jewels:\n            return -1\n        return jewels.pop(-1)\n\n    def insert_left(jewels: list, value: int) -> list:\n        return [value] + jewels\n\n    def insert_right(jewels: list, value: int) -> list:\n        return jewels + [value]\n\n    def process_operation(jewels: list, operation: str) -> int:\n        if operation == \"A\":\n            return take_out_left(jewels)\n        elif operation == \"B\":\n            return take_out_right(jewels)\n        elif operation == \"C\":\n            return insert_left(jewels, take_out_left(jewels))\n        elif operation == \"D\":\n            return insert_right(jewels, take_out_right(jewels))\n        else:\n            return -1\n\n    def process_operations(jewels: list, operations: list) -> int:\n        result = 0\n        for operation in operations:\n            result += process_operation(jewels, operation)\n        return result\n\n    def max_sum(jewels: list) -> int:\n        max_sum = 0\n        for i in range(k):\n            operations = [f\"A\" for _ in range(i)] + [f\"B\" for _ in range(k - i - 1)]\n            max_sum = max(max_sum, process_operations(jewels, operations))\n        return max_sum\n\n    return str(max_sum(jewels))"
    },
    {
        "number": 1172,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    Q = S.count('?')\n    MOD = 10**9 + 7\n\n    def make_string(i: int) -> str:\n        return S[:i] + 'A' * (Q - i) + S[i:]\n\n    def abc_number(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i] == 'A':\n                count += 1\n            elif s[i] == 'B':\n                count += 2\n            elif s[i] == 'C':\n                count += 3\n        return count\n\n    def sum_of_abc_numbers(n: int) -> int:\n        return sum(abc_number(make_string(i)) for i in range(1, n + 1))\n\n    return str(sum_of_abc_numbers(3 ** Q) % MOD)"
    },
    {
        "number": 1173,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matches = []\n    for i in range(1, n+1):\n        match = list(map(int, stdin.split()[i].split()))\n        matches.append(match)\n\n    def is_valid(match, players):\n        for i in range(len(match)):\n            if match[i] in players:\n                players.remove(match[i])\n            else:\n                return False\n        return True\n\n    def find_min_days(matches):\n        min_days = 1\n        for i in range(len(matches)):\n            for j in range(i+1, len(matches)):\n                if is_valid(matches[i], matches[j]):\n                    min_days = min(min_days, 1 + find_min_days(matches[:i] + matches[j+1:]))\n        return min_days\n\n    min_days = find_min_days(matches)\n    if min_days == float('inf'):\n        return -1\n    else:\n        return str(min_days)"
    },
    {
        "number": 1174,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def buy_item(i, price, tickets):\n        if tickets == 0:\n            return price\n        else:\n            return buy_item(i, price, tickets - 1)\n\n    min_price = float('inf')\n    for i in range(n):\n        min_price = min(min_price, buy_item(i, a[i], m))\n\n    return str(min_price)"
    },
    {
        "number": 1175,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n\n    for x in range(L, R + 1):\n        for y in range(L, R + 1):\n            if y % x == 0:\n                count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 1176,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    for i in range(n - 1):\n        a[i], a[i + 1] = -a[i], -a[i + 1]\n    return max(a)"
    },
    {
        "number": 1177,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(L, R):\n        count = 0\n        for i in range(L, R + 1):\n            if a[i] == s:\n                count += 1\n        return count\n\n    def sum_f(L, R):\n        return sum(f(L, R))\n\n    def mod_sum_f(L, R):\n        return sum_f(L, R) % 998244353\n\n    L = 1\n    R = n\n    result = mod_sum_f(L, R)\n\n    while L <= R:\n        mid = (L + R) // 2\n        if sum_f(L, mid) < sum_f(mid + 1, R):\n            L = mid + 1\n        else:\n            R = mid - 1\n\n    print(result)\n\n    return \"\"\n"
    },
    {
        "number": 1178,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n    h = [0] * k + h + [0] * (n - k)\n\n    def paint_black(row: int, col: int, count: int) -> int:\n        nonlocal h\n        if h[col] == 0:\n            return count\n        h[col] = 0\n        return paint_black(row, col + 1, count + 1)\n\n    min_count = float('inf')\n    for i in range(n):\n        min_count = min(min_count, paint_black(i, 0, 0))\n\n    return str(min_count)"
    },
    {
        "number": 1179,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    ids = list(map(int, stdin.split()[1:]))\n    ids.sort()\n    return str(ids[k-1])"
    },
    {
        "number": 1180,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    MOD = 10**9 + 7\n\n    def count_pluses(s: str) -> int:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i] == '+' and s[i + 1] == '+':\n                count += 1\n        return count\n\n    def is_valid(s: str) -> bool:\n        count = count_pluses(s)\n        return count <= k\n\n    def is_valid_partition(s: str) -> bool:\n        count = 0\n        for i in range(len(s) - 1):\n            if s[i] == '+':\n                count += 1\n            elif s[i] == '0':\n                count = 0\n            else:\n                return False\n        return count <= k\n\n    def partition(s: str) -> List[str]:\n        if len(s) == 1:\n            return [s]\n        result = []\n        for i in range(len(s)):\n            if s[i] == '+':\n                for p in partition(s[:i] + '0' + s[i + 1:]):\n                    result.append(s[:i] + '0' + p)\n            else:\n                for p in partition(s[:i] + '0' + s[i + 1:]):\n                    result.append(s[:i] + '0' + p)\n        return result\n\n    def sum_expressions(partition: List[str]) -> int:\n        result = 0\n        for p in partition:\n            if is_valid(p):\n                result += int(p)\n        return result\n\n    def sum_expressions_modulo(partition: List[str]) -> int:\n        result = sum_expressions(partition)\n        return result % MOD\n\n    partition_list = partition(s)\n    valid_partition_list = [p for p in partition_list if is_valid_partition(p)]\n    result = sum_expressions_modulo(valid_partition_list)\n    return str(result)"
    },
    {
        "number": 1181,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def merge(x: int, y: int) -> None:\n        nonlocal a\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n\n    def turn(x: int, y: int) -> int:\n        nonlocal a\n        return abs(x - y)\n\n    def merge_and_turn(x: int, y: int) -> int:\n        merge(x, y)\n        return turn(x, y)\n\n    def merge_and_turn_all(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_all_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_all(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_all_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except_all(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except_all_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except_except_all(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except_except_all_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_and_turn_except_except_except_except(x: int, y: int) -> int:\n        nonlocal a\n        merge(x, y)\n        a[x - 1 : y] = a[x - 1 : y] + a[x - 1 : y]\n        return turn(x, y)\n\n    def merge_"
    },
    {
        "number": 1182,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, n, k = map(int, stdin.split())\n    violas = [list(map(int, stdin.split())) for _ in range(n)]\n    violas.sort(key=lambda x: (x[0], x[1]))\n\n    def is_valid(x, y):\n        for viola in violas:\n            if viola[0] == x and viola[1] == y:\n                return False\n        return True\n\n    def count_valid_pictures(x, y, count):\n        if count == k:\n            return 1\n        if x == r or y == c:\n            return 0\n\n        if is_valid(x, y):\n            return count_valid_pictures(x + 1, y, count + 1) + count_valid_pictures(x, y + 1, count + 1)\n        else:\n            return count_valid_pictures(x + 1, y, count) + count_valid_pictures(x, y + 1, count)\n\n    return str(count_valid_pictures(0, 0, 0))\n"
    },
    {
        "number": 1183,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, x = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        v = a[-1]\n        for i in range(v, 0, -1):\n            if a.count(i) >= x:\n                print(i)\n                break"
    },
    {
        "number": 1184,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Remove the opening and closing curved brackets\n    set_str = stdin[1:-1]\n\n    # Split the set into a list of letters\n    set_list = set_str.split(',')\n\n    # Convert the list to a set to remove duplicates\n    set_set = set(set_list)\n\n    # Return the length of the set\n    return str(len(set_set))"
    },
    {
        "number": 1185,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()[1:]))\n\n    def max_sum(l, r):\n        return sum(p[j] for j in range(l, r + 1))\n\n    def max_sum_k(l, r):\n        return max(max_sum(l, r), max_sum(l + 1, r - 1))\n\n    def max_sum_k_pairs(l, r):\n        return max(max_sum_k(l, r), max_sum_k(l + 1, r - 1))\n\n    def max_sum_k_pairs_with_sum(l, r, s):\n        return max(max_sum_k_pairs(l, r), max_sum_k_pairs(l + 1, r - 1), s - max_sum_k_pairs(l, r) - max_sum_k_pairs(l + 1, r - 1))\n\n    def max_sum_k_pairs_with_sum_k(l, r, s):\n        return max(max_sum_k_pairs_with_sum(l, r, s), max_sum_k_pairs_with_sum(l + 1, r - 1, s - max_sum_k(l, r)))\n\n    def max_sum_k_pairs_with_sum_k_pairs(l, r, s):\n        return max(max_sum_k_pairs_with_sum_k(l, r, s), max_sum_k_pairs_with_sum_k(l + 1, r - 1, s - max_sum_k(l, r)))\n\n    return str(max_sum_k_pairs_with_sum_k_pairs(0, n - 1, sum(p)))\n"
    },
    {
        "number": 1186,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"NO\"\n    elif N == 2:\n        return \"YES\\n1 2\"\n    else:\n        def find_permutation(nums):\n            for i in range(len(nums)):\n                if nums[i] == i:\n                    return False\n            return True\n\n        def find_two_permutations(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_two_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_three_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_four_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_five_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_six_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_seven_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_eight_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_nine_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_ten_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_eleven_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_twelve_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_thirteen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_fourteen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_fifteen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_sixteen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_seventeen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_eighteen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_nineteen_elements(nums):\n            for i in range(len(nums)):\n                if nums[i] == i or nums[i] & i == 0:\n                    return False\n            return True\n\n        def find_permutation_with_tw"
    },
    {
        "number": 1187,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    colors = [0] * m\n\n    def dfs(u, color):\n        colors[u - 1] = color\n        for v, c in edges[u - 1]:\n            if colors[v - 1] == 0:\n                dfs(v, (color + 1) % 2)\n\n    for u in range(1, n + 1):\n        if colors[u - 1] == 0:\n            dfs(u, 1)\n\n    return str(colors.count(1)) + '\\n' +''.join(map(str, colors))"
    },
    {
        "number": 1188,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    m = 0\n    for i in range(1, n + 1):\n        if a[i] - a[i - 1] == 1:\n            m += 1\n        else:\n            break\n    if m == 0:\n        return -1\n    else:\n        return str(m)"
    },
    {
        "number": 1189,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split())\n    def dfs(row, col, walls):\n        if row == n:\n            return 1\n        count = 0\n        for i in range(col, n):\n            if walls[row][i] == 1:\n                walls[row][i] = 0\n                count += dfs(row + 1, i + 1, walls)\n                walls[row][i] = 1\n        return count\n\n    walls = [[0] * (n + 1) for _ in range(n + 1)]\n    count = dfs(0, 0, walls)\n    return str((count % (10**6 + 3)) % (10**6 + 3))"
    },
    {
        "number": 1190,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w1, h1, w2, h2 = map(int, stdin.split())\n    w1, h1, w2, h2 = max(w1, w2), max(h1, h2), min(w1, w2), min(h1, h2)\n    return str(w1 * h1 + w2 * h2)"
    },
    {
        "number": 1191,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    powers = list(map(int, stdin.split()))\n    coins = list(map(int, stdin.split()))\n\n    max_coins = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if powers[i] > powers[j]:\n                max_coins[i] = max(max_coins[i], coins[j] + max_coins[j])\n\n    return \" \".join(map(str, max_coins))"
    },
    {
        "number": 1192,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def choose_uniformly_at_random(lst, k):\n        return [lst[i] for i in range(len(lst)) if i not in k]\n\n    def reverse_order(lst, start, end):\n        lst[start:end+1] = lst[start:end+1][::-1]\n\n    def count_inversions(lst):\n        n = len(lst)\n        inversions = 0\n        for i in range(1, n):\n            for j in range(0, i):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def expected_inversions(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions / k\n\n    def generate_permutation(lst):\n        n = len(lst)\n        k = k // 2\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    lst[i], lst[j] = lst[j], lst[i]\n        return lst\n\n    def generate_inversions(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal_and_swapping(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal_and_swapping_and_reversal(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal_and_swapping_and_reversal_and_swapping(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal_and_swapping_and_reversal_and_swapping_and_reversal(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal_and_swapping_and_reversal_and_swapping_and_reversal_and_swapping(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_reversal_and_swapping_and_reversal_and_swapping_and_reversal_and_swapping_and_reversal(lst):\n        n = len(lst)\n        k = k // 2\n        inversions = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lst[i] < lst[j]:\n                    inversions += 1\n        return inversions\n\n    def generate_inversions_with_"
    },
    {
        "number": 1193,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_speed = max(a)\n    min_speed = min(a)\n\n    for i in range(n):\n        a[i] = max_speed\n\n    for i in range(k):\n        a[i] = min_speed\n\n    return str(max(a))"
    },
    {
        "number": 1194,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1].split()))\n    q = list(map(int, stdin.split()[2].split()))\n\n    def perm(x: int) -> str:\n        return ''.join(map(str, x))\n\n    def ord_p(p: str) -> int:\n        return sum(ord(p[i]) * (i + 1) for i in range(len(p)))\n\n    def ord_q(q: str) -> int:\n        return sum(ord(q[i]) * (i + 1) for i in range(len(q)))\n\n    def lexicographically_smaller(p: str, q: str) -> bool:\n        for i in range(len(p)):\n            if p[i]!= q[i]:\n                return p[i] < q[i]\n        return False\n\n    def sum_of_perms(p: str, q: str) -> str:\n        p_ord = ord_p(p)\n        q_ord = ord_q(q)\n\n        if p_ord < q_ord:\n            return p\n        elif p_ord > q_ord:\n            return q\n        else:\n            if lexicographically_smaller(p, q):\n                return p\n            else:\n                return q\n\n    def sum_of_perms_mod_2(p: str, q: str) -> str:\n        p_ord = ord_p(p)\n        q_ord = ord_q(q)\n\n        if p_ord < q_ord:\n            return perm((p_ord + 1) % 2)\n        elif p_ord > q_ord:\n            return perm((q_ord + 1) % 2)\n        else:\n            if lexicographically_smaller(p, q):\n                return perm((p_ord + 1) % 2)\n            else:\n                return perm((q_ord + 1) % 2)\n\n    return''.join(map(str, sum_of_perms_mod_2(p, q)))"
    },
    {
        "number": 1195,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    a.reverse()\n    count = 0\n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n            if count == 2:\n                return \"4\"\n    return \"3\""
    },
    {
        "number": 1196,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    t = []\n    for _ in range(n):\n        l, c = map(int, stdin.split())\n        t.append((l, c))\n    s = []\n    for _ in range(m):\n        l, c = map(int, stdin.split())\n        s.append((l, c))\n\n    def compress(s: str) -> str:\n        result = []\n        i = 0\n        while i < len(s):\n            j = i + 1\n            while j < len(s) and s[j] == s[i]:\n                j += 1\n            result.append((j - i, s[i]))\n            i = j\n        return result\n\n    t_compressed = compress(t)\n    s_compressed = compress(s)\n\n    def find_occurrences(t_compressed: list, s_compressed: list) -> int:\n        result = 0\n        for i in range(len(t_compressed) - len(s_compressed) + 1):\n            if t_compressed[i:] == s_compressed:\n                result += 1\n        return result\n\n    return str(find_occurrences(t_compressed, s_compressed))\n"
    },
    {
        "number": 1197,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    bombs = [0] * n\n    for i, s in enumerate(stdin):\n        if s == \"*\":\n            bombs[i] = 1\n\n    def dfs(i, j, bombs_left):\n        if bombs_left == 0:\n            return 1\n        if i < 0 or i >= n or j < 0 or j >= n:\n            return 0\n        if bombs[i] == 0:\n            return dfs(i + 1, j, bombs_left - 1) + dfs(i - 1, j, bombs_left - 1) + dfs(i, j + 1, bombs_left - 1) + dfs(i, j - 1, bombs_left - 1)\n        return dfs(i + 1, j, bombs_left) + dfs(i - 1, j, bombs_left) + dfs(i, j + 1, bombs_left) + dfs(i, j - 1, bombs_left)\n\n    ways = 0\n    for i in range(n):\n        for j in range(n):\n            if bombs[i] == 0:\n                ways += dfs(i, j, bombs[i])\n\n    return str(ways % (10**9 + 7))"
    },
    {
        "number": 1198,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def partition(a, c):\n        def helper(start, end, current_sum):\n            if start == end:\n                return current_sum\n            if current_sum > c:\n                return float('inf')\n            if start == 0:\n                return helper(start + 1, end, current_sum + a[start])\n            return min(helper(start, end - 1, current_sum), helper(start + 1, end, current_sum + a[start]))\n\n        return helper(0, n - 1, 0)\n\n    return str(partition(a, c))"
    },
    {
        "number": 1199,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    def swap_colors(colors: list) -> list:\n        left_color = colors[0]\n        right_color = colors[1]\n        colors[0] = right_color\n        colors[1] = left_color\n        return colors\n\n    def find_distinct_colors(colors: list) -> int:\n        distinct_colors = set()\n        for color in colors:\n            if color not in distinct_colors:\n                distinct_colors.add(color)\n        return len(distinct_colors)\n\n    def find_max_distinct_colors(colors: list) -> int:\n        max_distinct_colors = 0\n        for i in range(len(colors)):\n            for j in range(i + 1, len(colors)):\n                if find_distinct_colors(colors[i:j + 1]) > max_distinct_colors:\n                    max_distinct_colors = find_distinct_colors(colors[i:j + 1])\n        return max_distinct_colors\n\n    def find_solution(colors: list) -> str:\n        max_distinct_colors = find_max_distinct_colors(colors)\n        solutions = []\n        for i in range(max_distinct_colors):\n            for j in range(i + 1, max_distinct_colors):\n                if find_distinct_colors(colors[i:j + 1]) == i + 1:\n                    left_color = colors[i]\n                    right_color = colors[j]\n                    solutions.append((left_color, right_color))\n        return solutions\n\n    def print_solution(solutions: list) -> None:\n        for solution in solutions:\n            print(f\"{solution[0]} {solution[1]}\")\n\n    colors = swap_colors(colors)\n    distinct_colors = find_distinct_colors(colors)\n    solutions = find_solution(colors)\n    print_solution(solutions)\n    return f\"{distinct_colors}\"\n"
    },
    {
        "number": 1200,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:]))\n    \n    min_distance = float('inf')\n    for i in range(n - 1):\n        distance = abs(x[i] - x[i + 1])\n        if distance < min_distance:\n            min_distance = distance\n    \n    if min_distance == float('inf'):\n        return '0'\n    else:\n        return str(min_distance)"
    },
    {
        "number": 1201,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    items = []\n    for i in range(n):\n        t, d, p = map(int, stdin.split()[1:])\n        items.append((t, d, p))\n    items.sort(key=lambda x: x[0])\n    total_value = 0\n    saved_items = []\n    for i in range(n):\n        if items[i][0] <= items[i][1]:\n            total_value += items[i][2]\n            saved_items.append(i + 1)\n    return str(total_value) + '\\n' + str(len(saved_items)) + '\\n' +''.join(map(str, saved_items))"
    },
    {
        "number": 1202,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a1, b1, a2, b2 = map(int, stdin.split())\n    a = [a1, a2]\n    b = [b1, b2]\n    a.sort()\n    b.sort()\n    k = 0\n    for i in range(n):\n        if a[i] == b[i]:\n            k += 1\n        else:\n            break\n    if k == 0:\n        return \"1110\"\n    elif k == 1:\n        return \"1100\"\n    else:\n        return \"1100\""
    },
    {
        "number": 1203,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, L = map(int, stdin.split())\n    A = H + L\n    B = H - L\n    if abs(A - B) / max(1, abs(B)) <= 1e-6:\n        return str(A)\n    else:\n        return \"impossible\""
    },
    {
        "number": 1204,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    e = list(map(int, stdin.split()))\n\n    def rank(p: int, e: int) -> int:\n        return p + e\n\n    def compare(a: tuple, b: tuple) -> int:\n        if a[0] == b[0]:\n            return a[1] - b[1]\n        return a[0] - b[0]\n\n    p.sort(reverse=True)\n    e.sort(reverse=True)\n\n    ranked = sorted(zip(p, e), key=lambda x: (-x[0], -x[1]))\n\n    ranked.sort(key=lambda x: (-rank(x[0], x[1]), -x[0], -x[1]))\n\n    for i in range(k - 1):\n        if ranked[i][0] == ranked[i + 1][0]:\n            return -1\n\n    return ranked[k - 1][1]"
    },
    {
        "number": 1205,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n\n    def is_good(line):\n        return all(line[0] * p[0] + line[1] * p[1] == 0 for p in points)\n\n    good_lines = [line for line in points for p in points if is_good(line)]\n    if not good_lines:\n        return \"-1\"\n    return str(len(good_lines))\n"
    },
    {
        "number": 1206,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bids = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    total_value = sum(bid[1] for bid in bids)\n    expected_value = 0\n    for bid in bids:\n        expected_value += bid[1] / total_value * (bid[0] - bid[1])\n    return f\"{expected_value:.9f}\""
    },
    {
        "number": 1207,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    battles = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        battles.append((u - 1, v - 1))\n\n    def is_valid(robot_order):\n        for i in range(len(robot_order) - 1):\n            for j in range(i + 1, len(robot_order)):\n                if robot_order[i] > robot_order[j]:\n                    return False\n        return True\n\n    def min_k(robot_order):\n        def count_battles(robot_order):\n            count = 0\n            for i in range(len(robot_order) - 1):\n                for j in range(i + 1, len(robot_order)):\n                    count += battles.count((robot_order[i], robot_order[j]))\n            return count\n\n        return min(range(1, n + 1), key=lambda k: count_battles(robot_order[:k]))\n\n    robot_order = [i for i in range(n)]\n    for i in range(m):\n        u, v = battles[i]\n        robot_order[u - 1], robot_order[v - 1] = robot_order[v - 1], robot_order[u - 1]\n\n    if is_valid(robot_order):\n        return str(min_k(robot_order))\n    else:\n        return \"-1\""
    },
    {
        "number": 1208,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = [line.strip() for line in stdin.split('\\n')]\n    readers = set()\n    min_capacity = float('inf')\n\n    for event in events:\n        if event.startswith('+'):\n            readers.add(int(event[2:]))\n        elif event.startswith('-'):\n            readers.remove(int(event[2:]))\n\n    for reader in readers:\n        min_capacity = min(min_capacity, reader)\n\n    return str(min_capacity)"
    },
    {
        "number": 1209,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(float, stdin.split()[1:]))\n    b = [0] * n\n    for i in range(n):\n        if a[i] == int(a[i]):\n            b[i] = int(a[i])\n        else:\n            b[i] = int(a[i]) + 1 if a[i] > 0 else int(a[i]) - 1\n    return \" \".join(map(str, b))"
    },
    {
        "number": 1210,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    sharks = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        sharks.append((l, r))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def product(a: int, b: int) -> int:\n        return a * b\n\n    def is_happy(num: int) -> bool:\n        seen = set()\n        while num not in seen:\n            seen.add(num)\n            num = sum(int(digit) ** 2 for digit in str(num))\n        return num == 1\n\n    def is_divisible(a: int, b: int, p: int) -> bool:\n        return product(a, b) % p == 0\n\n    def happiness(sharks: List[Tuple[int, int]]) -> int:\n        happiness = 0\n        for i in range(len(sharks)):\n            for j in range(i + 1, len(sharks)):\n                if is_divisible(sharks[i][0], sharks[j][0], p) and is_divisible(sharks[i][1], sharks[j][1], p):\n                    happiness += 1000\n        return happiness\n\n    happiness_sum = happiness(sharks)\n    expected_value = happiness_sum / n\n\n    return str(expected_value)\n"
    },
    {
        "number": 1211,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_boxes = 0\n    max_type = 0\n\n    for i in range(1, k + 1):\n        if a[i - 1] * n <= k:\n            max_boxes += 1\n            max_type = i\n\n    return str(max_type) + \" \" + str(max_boxes)"
    },
    {
        "number": 1212,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def find_min_sum(start: int, end: int) -> int:\n        total_height = sum(h[start:end + 1])\n        min_sum = total_height\n        for i in range(start, end):\n            for j in range(i + 1, end + 1):\n                if j - i + 1 == k:\n                    new_total_height = total_height - h[i] + h[j]\n                    if new_total_height < min_sum:\n                        min_sum = new_total_height\n        return min_sum\n\n    min_sum = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j - i + 1 == k:\n                new_min_sum = find_min_sum(i, j)\n                if new_min_sum < min_sum:\n                    min_sum = new_min_sum\n                    print(i, j)\n\n    return str(min_sum)\n"
    },
    {
        "number": 1213,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    slogan = stdin.split()[1]\n\n    def paint_slogan(slogan: str, k: int) -> str:\n        result = []\n        for i, char in enumerate(slogan):\n            if char == '.':\n                result.append('PRINT ')\n                result.append(str(i + 1))\n            elif char == '!':\n                result.append('RIGHT')\n            elif char == ',':\n                result.append('LEFT')\n            elif char == '?':\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result.append('LEFT')\n                result."
    },
    {
        "number": 1214,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *x = map(int, stdin.split())\n    x = [x[i] for i in range(0, n, 2)]\n    x.sort()\n    if x == [1] * n:\n        return \"Yes\\n\" + \" \".join(map(str, x))\n    for i in range(1, n // 2 + 1):\n        if x[i] * x[i] == x[i - 1] + x[i + 1]:\n            x[i] = x[i - 1] + x[i + 1]\n            x.sort()\n            if x == [1] * n:\n                return \"Yes\\n\" + \" \".join(map(str, x))\n    return \"No\""
    },
    {
        "number": 1215,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"0\"\n    elif n == 4:\n        return \"4\"\n    else:\n        return \"1\""
    },
    {
        "number": 1216,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"aeiouy\"\n    result = []\n    for i in range(len(stdin)):\n        if i == 0 or stdin[i]!= stdin[i - 1]:\n            if stdin[i] in vowels and (i == 0 or stdin[i - 1] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] in vowels) and (i == len(stdin) - 2 or stdin[i + 2] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] in vowels) and (i == len(stdin) - 2 or stdin[i + 2] in vowels) and (i == len(stdin) - 3 or stdin[i + 3] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] in vowels) and (i == len(stdin) - 2 or stdin[i + 2] in vowels) and (i == len(stdin) - 3 or stdin[i + 3] in vowels) and (i == len(stdin) - 4 or stdin[i + 4] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] in vowels) and (i == len(stdin) - 2 or stdin[i + 2] in vowels) and (i == len(stdin) - 3 or stdin[i + 3] in vowels) and (i == len(stdin) - 4 or stdin[i + 4] in vowels) and (i == len(stdin) - 5 or stdin[i + 5] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] in vowels) and (i == len(stdin) - 2 or stdin[i + 2] in vowels) and (i == len(stdin) - 3 or stdin[i + 3] in vowels) and (i == len(stdin) - 4 or stdin[i + 4] in vowels) and (i == len(stdin) - 5 or stdin[i + 5] in vowels) and (i == len(stdin) - 6 or stdin[i + 6] not in vowels):\n                result.append(stdin[i])\n            elif stdin[i] in vowels and (i == 0 or stdin[i - 1] in vowels) and (i == len(stdin) - 1 or stdin[i + 1] in vowels) and (i == len(stdin) - 2 or stdin[i + 2] in vowels) and (i == len(stdin) - 3 or stdin[i + 3] in vowels) and (i == len(stdin) - 4 or stdin[i + 4] in vowels) and (i == len(stdin) - 5 or stdin[i + 5] in vowels) and (i == len(stdin) - 6 or stdin[i + 6] in vowels) and (i == len(stdin) - 7 or stdin[i + 7] not in vowels):\n                result.append(stdin"
    },
    {
        "number": 1217,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    result = []\n    for j in range(m):\n        count = 0\n        for i in range(n):\n            if a[i] <= b[j]:\n                count += 1\n        result.append(count)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1218,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n > 10**18 or k > 10**9:\n        return -1\n\n    def dfs(start, pipes, used_splitters):\n        if len(pipes) == 1:\n            return 1\n\n        min_splitters = float('inf')\n        for i in range(1, k + 1):\n            if i not in used_splitters:\n                used_splitters.add(i)\n                min_splitters = min(min_splitters, dfs(start, pipes, used_splitters))\n                used_splitters.remove(i)\n\n        return min_splitters\n\n    pipes = set()\n    for i in range(n):\n        pipes.add(i)\n\n    return str(dfs(0, pipes, set()))"
    },
    {
        "number": 1219,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for _ in range(n-1):\n        a.pop(0)\n        a.pop(0)\n        a.insert(0, -(a[0] + a[1]))\n\n    return str(max(a))"
    },
    {
        "number": 1220,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = set()\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        edges.add((x, y))\n        edges.add((y, x))\n\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        size = 1\n        for v in graph[u]:\n            if v not in visited:\n                size += dfs(v, visited)\n        return size\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    components = set()\n    for u in range(1, n + 1):\n        if u not in visited:\n            visited = set()\n            components.add(dfs(u, visited))\n\n    return str(len(components)) +'' +''.join(map(str, components))"
    },
    {
        "number": 1221,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def find_brightness(lanterns: list, brightness: int) -> int:\n        brightness_sum = sum(brightness * i for i in lanterns)\n        return brightness_sum\n\n    def find_best_pair(a: list, b: list) -> tuple:\n        best_brightness = float('inf')\n        best_pair = None\n\n        for i in range(len(a)):\n            for j in range(len(b)):\n                brightness = a[i] * b[j]\n                if brightness < best_brightness:\n                    best_brightness = brightness\n                    best_pair = (i, j)\n\n        return best_pair\n\n    best_pair = find_best_pair(a, b)\n    if best_pair:\n        brightness = a[best_pair[0]] * b[best_pair[1]]\n        print(brightness)\n    else:\n        print(-1)\n"
    },
    {
        "number": 1222,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    smallest_lunlun = 1\n    count = 0\n\n    while count < K:\n        if is_lunlun(smallest_lunlun):\n            count += 1\n            if count == K:\n                return str(smallest_lunlun)\n        smallest_lunlun += 1\n\n    return str(smallest_lunlun - 1)\n\n\ndef"
    },
    {
        "number": 1223,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    def second_largest(arr: list) -> int:\n        return max(arr) - min(arr)\n\n    def sum_x(L: int, R: int) -> int:\n        return sum(second_largest(p[L:R]) for _ in range(R - L))\n\n    return str(sum_x(1, n))"
    },
    {
        "number": 1224,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for i in range(1, int(N ** 0.5) + 1):\n        if 3 ** i + 5 ** i == N:\n            return f\"{i} {i}\"\n    return -1"
    },
    {
        "number": 1225,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H = int(stdin)\n    monsters = []\n    for i in range(H):\n        health = 1\n        while health > 0:\n            health = int(health / 2)\n            monsters.append(health)\n    return str(len(monsters))"
    },
    {
        "number": 1226,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n\n    min_n = min(n, 2 * 10**5)\n    count = 0\n    for i in range(1, min_n + 1):\n        if i!= a and i!= b:\n            count += (n - i) * (n - i)\n\n    return str((count % (10**9 + 7)))"
    },
    {
        "number": 1227,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        if len(str(i)) == k:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1228,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x % 4 == 0:\n        a = 0\n        b = 'A'\n    elif x % 4 == 1:\n        a = 1\n        b = 'B'\n    elif x % 4 == 2:\n        a = 2\n        b = 'C'\n    else:\n        a = 0\n        b = 'D'\n    return f\"{a} {b}\""
    },
    {
        "number": 1229,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    multiset = [list(map(str, input().split())) for _ in range(n)]\n    coins = [list(map(int, input().split())) for _ in range(m)]\n\n    def change_char(s: str, i: int, c: str) -> str:\n        return s[:i] + c + s[i + 1:]\n\n    def is_easy_to_remember(s: str, coins: List[List[int]]) -> bool:\n        for coin in coins:\n            if s[coin[0]] == coin[1]:\n                return False\n        return True\n\n    def min_sum(multiset: List[List[str]], coins: List[List[int]]) -> int:\n        min_sum = float('inf')\n        for i in range(len(multiset)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                if is_easy_to_remember(change_char(multiset[i][0], coin[0], c), coins):\n                    min_sum = min(min_sum, sum(coin))\n        return min_sum\n\n    return str(min_sum(multiset, coins))\n"
    },
    {
        "number": 1230,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(int, a))\n\n    def dfs(node: int, visited: set) -> int:\n        if node in visited:\n            return 0\n        visited.add(node)\n        count = 1\n        for friend in a[node]:\n            count += dfs(friend, visited)\n        return count\n\n    visited = set()\n    count = dfs(0, visited)\n    if count == 0:\n        return -1\n    return str(count)"
    },
    {
        "number": 1231,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a % 2 == 0 and b % 2 == 0:\n        return \"YES\"\n    elif a % 2 == 0 and b % 2 == 1:\n        return \"YES\"\n    elif a % 2 == 1 and b % 2 == 0:\n        return \"YES\"\n    elif a % 2 == 1 and b % 2 == 1:\n        return \"NO\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1232,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_A, n_B, k, m = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    A.sort()\n    B.sort()\n\n    for i in range(n_A):\n        if A[i] > B[0]:\n            return \"NO\"\n\n    for i in range(n_B):\n        if B[i] > A[0]:\n            return \"NO\"\n\n    for i in range(k):\n        if A[i] > B[i]:\n            return \"NO\"\n\n    for i in range(m):\n        if B[i] > A[i]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1233,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def swap(a, i, j):\n        a[i], a[j] = a[j], a[i]\n\n    def min_swaps(a):\n        min_swaps = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] > a[j]:\n                    min_swaps += 1\n        return min_swaps\n\n    min_swaps_1 = min_swaps(a)\n    min_swaps_2 = min_swaps(a[::-1])\n\n    if min_swaps_1 < min_swaps_2:\n        print(min_swaps_1, min_swaps_2)\n    else:\n        print(min_swaps_2, min_swaps_1)\n\n    return \"\"\n"
    },
    {
        "number": 1234,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def beauty(arr):\n        return sum(sorted(arr, reverse=True)[:m])\n\n    def max_beauty(arr):\n        return max(beauty(arr) for _ in range(k))\n\n    max_sum = max_beauty(a)\n    max_subarrays = [i for i in range(n) if beauty(a[:i+1]) == max_sum]\n\n    if len(max_subarrays) == k:\n        return str(max_sum)\n    else:\n        return \" \".join(map(str, max_subarrays))"
    },
    {
        "number": 1235,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *A = map(int, stdin.split())\n    m, *B = map(int, stdin.split())\n\n    for a in A:\n        for b in B:\n            if a + b not in A and a + b not in B:\n                return f\"{a} {b}\"\n\n    return \"No solution\""
    },
    {
        "number": 1236,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_even(n: int) -> bool:\n        return n % 2 == 0\n\n    def is_winning_strategy(a: list) -> str:\n        total_surviving_residents = sum(a)\n        if is_even(total_surviving_residents):\n            return \"Daenerys\"\n        else:\n            return \"Stannis\"\n\n    return is_winning_strategy(a)"
    },
    {
        "number": 1237,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    passengers = []\n    for i in range(n):\n        f, t = map(int, stdin.split())\n        passengers.append((f, t))\n\n    passengers.sort(key=lambda x: x[1])\n\n    time = 0\n    for f, t in passengers:\n        time += t\n        if f == 0:\n            break\n\n    return str(time)"
    },
    {
        "number": 1238,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    x = a[0]\n    count = 0\n    for i in range(1, n):\n        if a[i] - x == 1:\n            count += 1\n            x = a[i]\n    return str(count)"
    },
    {
        "number": 1239,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cities = list(map(int, stdin.split()[1:]))\n\n    min_distance = float('inf')\n    pairs_count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(cities[i] - cities[j])\n            if distance < min_distance:\n                min_distance = distance\n                pairs_count = 1\n            elif distance == min_distance:\n                pairs_count += 1\n\n    return f\"{min_distance} {pairs_count}\""
    },
    {
        "number": 1240,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    columns = []\n    for _ in range(n):\n        l, r = map(int, stdin.split()[1:])\n        columns.append((l, r))\n    columns.sort(key=lambda x: x[0])\n    max_beauty = 0\n    for i in range(n):\n        if columns[i][0] > columns[i][1]:\n            continue\n        beauty = abs(columns[i][0] - columns[i][1])\n        if beauty > max_beauty:\n            max_beauty = beauty\n            max_column = i\n    return str(max_column + 1) if max_column!= -1 else \"0\""
    },
    {
        "number": 1241,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(a):\n        f = 0\n        for i in range(1, len(a)):\n            if a[i] == 0:\n                f += 1\n            else:\n                f = 0\n        return f\n\n    def max_f(a, k):\n        max_f = 0\n        for i in range(1, len(a)):\n            if a[i] == 0:\n                max_f += 1\n            else:\n                max_f = 0\n            if max_f > k:\n                return max_f\n        return max_f\n\n    max_f_val = max_f(a, k)\n    max_f_index = a.index(max_f_val)\n\n    a[max_f_index] = 1\n    a = a[:max_f_index + 1]\n\n    return str(max_f_val) + '\\n' +''.join(map(str, a))"
    },
    {
        "number": 1242,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    prefixes = [\"\".join(sorted(s[:i+1])) for i in range(n)]\n    prefixes.sort()\n    result = []\n    for prefix in prefixes:\n        if prefix == s:\n            result.append(1)\n        else:\n            result.append(0)\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1243,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *matchboxes = map(int, stdin.split())\n    k = sum(matchboxes)\n    moves = 0\n    for i in range(n - 1):\n        moves += min(matchboxes[i], matchboxes[i + 1])\n    moves += min(matchboxes[-1], k - sum(matchboxes))\n    return str(moves)"
    },
    {
        "number": 1244,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    for i in range(n - 1):\n        if arr[i] == arr[i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1245,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[i+1:])\n        segments.append((l, r))\n    segments.sort(key=lambda x: x[0])\n    \n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n    \n    def restore_sequence(segments: List[Tuple[int, int]]) -> str:\n        sequence = []\n        for l, r in segments:\n            sequence.append('(' * (r - l + 1))\n        return ''.join(sequence)\n    \n    def find_sequence(segments: List[Tuple[int, int]]) -> str:\n        for i in range(len(segments)):\n            for j in range(i+1, len(segments)):\n                if is_valid(restore_sequence(segments[:i] + segments[j:])):\n                    return restore_sequence(segments[:i] + segments[j:])\n        return \"IMPOSSIBLE\"\n    \n    return find_sequence(segments)"
    },
    {
        "number": 1246,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    records = stdin.split()[1:]\n    heap = []\n\n    for record in records:\n        operation, value = record.split()\n        if operation == \"insert\":\n            heapq.heappush(heap, value)\n        elif operation == \"getMin\":\n            if value == min(heap):\n                print(value)\n            else:\n                print(min(heap))\n        elif operation == \"removeMin\":\n            heapq.heappop(heap)\n\n    return \"\\n\".join(map(str, heap))"
    },
    {
        "number": 1247,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for i in range(n // 2):\n        if s[i]!= s[n - i - 1]:\n            return \"First\"\n    return \"Second\""
    },
    {
        "number": 1248,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d1, d2, d3 = map(int, stdin.split())\n    min_distance = min(d1, d2, d3)\n    return str(min_distance)"
    },
    {
        "number": 1249,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k, n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Find the longest liana\n    liana = a\n    for i in range(m):\n        if a.count(i) > liana.count(i):\n            liana = [i] * m\n\n    # Find the longest workpiece\n    workpiece = liana\n    for i in range(m):\n        if liana.count(i) > workpiece.count(i):\n            workpiece = [i] * m\n\n    # Check if the workpiece fits the schematic\n    if workpiece == liana:\n        return -1\n\n    # Find the positions of the flowers to be removed\n    positions = []\n    for i in range(m):\n        if workpiece.count(i) < liana.count(i):\n            positions.append(i)\n\n    # Remove the flowers\n    liana = [x for x in liana if x not in positions]\n\n    # Check if there are at least n workpieces\n    if len(liana) < n:\n        return -1\n\n    # Find the number of flowers to be removed by Diana\n    d = 0\n    for i in range(m):\n        if liana.count(i) < workpiece.count(i):\n            d += liana.count(i) - workpiece.count(i)\n\n    # Output the result\n    return str(d) + \" \" + \" \".join(map(str, positions))"
    },
    {
        "number": 1250,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n - 1):\n        for j in range(i, n - 1):\n            if a[j] > a[j] + 1:\n                a[j], a[j + 1] = a[j + 1], a[j]\n\n    if a == sorted(a):\n        print(\" \".join(map(str, a)))\n    else:\n        print(-1)\n\n    return \"\"\n"
    },
    {
        "number": 1251,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [1] + a + [1]\n    a = [a[i] - a[i - 1] for i in range(1, len(a))]\n    a = [a[i] * 1000 for i in range(len(a))]\n    a = [a[i] for i in range(len(a)) if a[i] > 0]\n    a.sort()\n    a = [a[i] for i in range(len(a)) if i % 2 == 0]\n    return str(len(a) // 2)"
    },
    {
        "number": 1252,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, T = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def bellman_ford(start: int) -> int:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        for _ in range(m):\n            for u in range(1, n + 1):\n                for v, t in roads:\n                    if dist[u]!= float('inf') and dist[u] + t < dist[v]:\n                        dist[v] = dist[u] + t\n        return dist[n]\n\n    def dijkstra(start: int) -> List[int]:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        prev = [None] * (n + 1)\n        pq = [(0, start)]\n        while pq:\n            d, u = heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, t in roads:\n                if dist[u]!= float('inf') and dist[u] + t < dist[v]:\n                    dist[v] = dist[u] + t\n                    prev[v] = u\n                    heappush(pq, (dist[v], v))\n        return prev\n\n    start = 1\n    end = n\n    dist = bellman_ford(start)\n    if dist == float('inf'):\n        return \"IMPOSSIBLE\"\n\n    prev = dijkstra(end)\n    if dist[end] > T:\n        return \"IMPOSSIBLE\"\n\n    visited = set()\n    queue = deque([end])\n    while queue:\n        u = queue.popleft()\n        if u in visited:\n            continue\n        visited.add(u)\n        if u == start:\n            break\n        queue.append(prev[u])\n\n    return str(len(visited)) + \" \" + \" \".join(map(str, visited))"
    },
    {
        "number": 1253,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    sequence.sort(reverse=True)\n    max_income = 0\n    for i in range(k):\n        if i % 2 == 0:\n            sequence = [sequence[j] * -1 for j in range(n)]\n        else:\n            sequence = [sequence[j] for j in range(n)]\n        total_income = sum(sequence)\n        if total_income > max_income:\n            max_income = total_income\n    return str(max_income)"
    },
    {
        "number": 1254,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    candidates = []\n    for _ in range(n):\n        s, r = map(int, stdin.split())\n        candidates.append((s, r))\n\n    def is_valid_delegation(candidates: List[Tuple[int, int]]) -> bool:\n        total_sum = sum(r for s, r in candidates)\n        return total_sum >= 0\n\n    def max_sum_of_valid_delegations(candidates: List[Tuple[int, int]]) -> int:\n        max_sum = 0\n        for i in range(1, len(candidates) + 1):\n            for j in range(i):\n                if i == j:\n                    continue\n                for k in range(j):\n                    if i == k or j == k:\n                        continue\n                    for l in range(k):\n                        if i == l or j == l or k == l:\n                            continue\n                        for m in range(l):\n                            if i == m or j == m or k == m or l == m:\n                                continue\n                            for n in range(m):\n                                if i == n or j == n or k == n or l == n or m == n:\n                                    continue\n                                for o in range(n):\n                                    if i == o or j == o or k == o or l == o or m == o or n == o:\n                                        continue\n                                    for p in range(o):\n                                        if i == p or j == p or k == p or l == p or m == p or n == p or o == p:\n                                            continue\n                                        for q in range(p):\n                                            if i == q or j == q or k == q or l == q or m == q or n == q or o == q or p == q:\n                                                continue\n                                            for r in range(q):\n                                                if i == r or j == r or k == r or l == r or m == r or n == r or o == r or p == r or q == r:\n                                                    continue\n                                                for s in range(r):\n                                                    if i == s or j == s or k == s or l == s or m == s or n == s or o == s or p == s or q == s or r == s:\n                                                        continue\n                                                    for t in range(s):\n                                                        if i == t or j == t or k == t or l == t or m == t or n == t or o == t or p == t or q == t or r == t or s == t:\n                                                            continue\n                                                        for u in range(t):\n                                                            if i == u or j == u or k == u or l == u or m == u or n == u or o == u or p == u or q == u or r == u or s == u or t == u:\n                                                                continue\n                                                            for v in range(u):\n                                                                if i == v or j == v or k == v or l == v or m == v or n == v or o == v or p == v or q == v or r == v or s == v or t == v or u == v:\n                                                                    continue\n                                                                for w in range(v):\n                                                                    if i == w or j == w or k == w or l == w or m == w or n == w or o == w or p == w or q == w or r == w or s == w or t == w or u == w or v == w:\n                                                                        continue\n                                                                    for x in range(w):\n                                                                        if i == x or j == x or k == x or l == x or m == x or n == x or o == x or p == x or q == x or r == x or s == x or t == x or u == x or v == x or w == x:\n                                                                            continue\n                                                                        for y in range(x):\n                                                                            if i == y or j == y or k == y or l == y or m == y or n == y or o == y or p == y or q == y or r == y or s == y or t == y or u == y or v == y or w == y or x == y:\n                                                                                continue\n                                                                            for z in range(y):\n                                                                                if i == z or j == z or k == z or l == z or m == z or n == z or o == z or p == z or q == z or r == z or s == z or t == z or u == z or v == z or w == z or x == z or y == z:\n                                                                                    continue\n                                                                                for a in range(z):\n                                                                                    if i == a or j == a or k == a or l == a or m == a or n == a or o == a or p == a or q == a or r == a or s == a or t == a or u == a or v == a"
    },
    {
        "number": 1255,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    times = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    times.sort(key=lambda x: x[0])\n    \n    cash = 0\n    min_cashes = 0\n    \n    for time in times:\n        if cash < n:\n            cash += 1\n            min_cashes += 1\n        else:\n            break\n    \n    return str(min_cashes)"
    },
    {
        "number": 1256,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    s = ''.join(sorted(s))\n    return s"
    },
    {
        "number": 1257,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        row = list(map(int, stdin.split()))\n        for j in range(1, n + 1):\n            table[i][j] = row[j - 1]\n    max_sum = float('-inf')\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if table[i][j] == k:\n                row_sum = sum(table[i][j] for j in range(1, n + 1))\n                col_sum = sum(table[j][k] for i in range(1, n + 1))\n                if row_sum == k * (k + 1) // 2 and col_sum == max_sum:\n                    print(table[i][j])\n                    return\n                if row_sum > k * (k + 1) // 2:\n                    max_sum = row_sum\n                    print(table[i][j])\n    return \"No suitable table found.\""
    },
    {
        "number": 1258,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    q = []\n    for i in range(n - 2):\n        q.append(tuple(map(int, stdin.split()[i + 1].split())))\n    q.sort(key=lambda x: (x[0], x[1], x[2]))\n\n    p = [1] * n\n    for i in range(n - 2):\n        p[q[i][0] - 1], p[q[i][1] - 1], p[q[i][2] - 1] = p[q[i][1] - 1], p[q[i][0] - 1], p[q[i][2] - 1]\n\n    return \" \".join(map(str, p))"
    },
    {
        "number": 1259,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    def bfs(u, visited):\n        queue = [u]\n        visited[u] = True\n        while queue:\n            v = queue.pop(0)\n            for w in graph[v]:\n                if not visited[w]:\n                    visited[w] = True\n                    queue.append(w)\n\n    def find_independent_set(graph):\n        visited = [False] * (n + 1)\n        independent_set = []\n        for u in range(1, n + 1):\n            if not visited[u]:\n                dfs(u, visited)\n                independent_set.append(u)\n        return independent_set\n\n    def find_cycle(graph):\n        visited = [False] * (n + 1)\n        queue = [1]\n        cycle = []\n        while queue:\n            u = queue.pop(0)\n            if not visited[u]:\n                visited[u] = True\n                queue.append(u)\n                for v in graph[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        queue.append(v)\n                        cycle.append(u)\n                        cycle.append(v)\n                        break\n        return cycle\n\n    if m == 0:\n        return \"1\"\n\n    independent_set = find_independent_set(graph)\n    if len(independent_set) == n:\n        return \"1\"\n\n    cycle = find_cycle(graph)\n    if len(cycle) >= n:\n        return \"2\" + \" \".join(map(str, cycle))\n\n    return \"1\" + \" \".join(map(str, independent_set))\n"
    },
    {
        "number": 1260,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def find_max(a: list) -> int:\n        max_val = a[0]\n        for i in range(1, len(a)):\n            if a[i] > max_val:\n                max_val = a[i]\n        return max_val\n\n    def find_max_index(a: list) -> int:\n        max_val = a[0]\n        max_index = 0\n        for i in range(1, len(a)):\n            if a[i] > max_val:\n                max_val = a[i]\n                max_index = i\n        return max_index\n\n    max_val = find_max(a)\n    max_index = find_max_index(a)\n\n    operations = []\n\n    for i in range(n - 1):\n        if a[max_index] == max_val:\n            operations.append(f\"1 {max_index + 1} {max_index + 1}\")\n            a[max_index] = 0\n            max_val = find_max(a)\n            max_index = find_max_index(a)\n        else:\n            operations.append(f\"2 {max_index + 1}\")\n            a[max_index] = 0\n            max_val = find_max(a)\n            max_index = find_max_index(a)\n\n    return \"\\n\".join(operations)\n"
    },
    {
        "number": 1261,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = list(map(int, stdin.split()))\n    result = []\n    while sequence:\n        gcd = max(sequence)\n        result.append(gcd)\n        sequence.remove(gcd)\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1262,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cities = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[i+1].split())\n        cities.append((x, y))\n\n    costs = list(map(int, stdin.split()[n+1].split()))\n    k = list(map(int, stdin.split()[n+2].split()))\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def is_connected(a, b):\n        return any(distance(a, c) + distance(b, c) <= 2 for c in cities)\n\n    def is_connected_by_wire(a, b):\n        return any(distance(a, c) + distance(b, c) <= 2 for c in cities if is_connected(a, c) or is_connected(b, c))\n\n    def min_cost(cities, costs, k):\n        min_cost = float('inf')\n        for i in range(len(cities)):\n            for j in range(i+1, len(cities)):\n                if is_connected(cities[i], cities[j]) or is_connected_by_wire(cities[i], cities[j]):\n                    min_cost = min(min_cost, costs[i] + costs[j] + k[i] + k[j])\n        return min_cost\n\n    min_cost_cities = []\n    min_cost_connections = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if is_connected(cities[i], cities[j]) or is_connected_by_wire(cities[i], cities[j]):\n                min_cost_cities.append(i+1)\n                min_cost_cities.append(j+1)\n                min_cost_connections.append((i+1, j+1))\n\n    min_cost_cities = list(set(min_cost_cities))\n    min_cost_connections = list(set(min_cost_connections))\n\n    min_cost_cities.sort()\n    min_cost_connections.sort()\n\n    min_cost_cities = [str(x) for x in min_cost_cities]\n    min_cost_connections = [str(x) for x in min_cost_connections]\n\n    return f\"{min_cost(cities, costs, k)}\" + \"\\n\" + f\"{len(min_cost_cities)}\" + \"\\n\" + \" \".join(min_cost_cities) + \"\\n\" + f\"{len(min_cost_connections)}\" + \"\\n\" + \" \".join(min_cost_connections)"
    },
    {
        "number": 1263,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    total_taste = sum(a)\n    total_calories = sum(b)\n\n    if total_taste / total_calories!= k:\n        return -1\n\n    max_taste = max(a)\n    return max_taste"
    },
    {
        "number": 1264,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    \n    max_ones = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if a[i] == 1 and a[j] == 1:\n                continue\n            a[i], a[j] = a[j], a[i]\n            max_ones = max(max_ones, sum(a))\n            a[i], a[j] = a[j], a[i]\n    \n    return str(max_ones)"
    },
    {
        "number": 1265,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = list(a)\n    b = list(b)\n\n    for i in range(len(a)):\n        if a[i] == b[i]:\n            continue\n        x, y = a[i], b[i]\n        p = x ^ y\n        q = x | y\n        a[i] = p\n        b[i] = q\n\n    return \"YES\" if a == b else \"NO\""
    },
    {
        "number": 1266,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x_0, y_0 = map(int, stdin.split()[1].split())\n    pieces = []\n    for _ in range(n):\n        piece_type, x, y = stdin.split()[1].split()\n        pieces.append((piece_type, (x, y)))\n\n    def is_in_check(x: int, y: int) -> bool:\n        for piece_type, (x_piece, y_piece) in pieces:\n            if piece_type == 'B' and abs(x - x_piece) == abs(y - y_piece):\n                return True\n            elif piece_type == 'R' and (x == x_piece or y == y_piece):\n                return True\n            elif piece_type == 'Q' and (abs(x - x_piece) == abs(y - y_piece) or abs(x - x_piece) == abs(y + y_piece) or abs(x + x_piece) == abs(y - y_piece) or abs(x + x_piece) == abs(y + y_piece)):\n                return True\n        return False\n\n    if is_in_check(x_0, y_0):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1267,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    scores = list(map(int, stdin.split()[1:]))\n\n    def backtrack(start: int, current_score: int, current_set: set, result: int) -> int:\n        if current_score == 0:\n            return 0\n\n        if current_score < 0:\n            return 0\n\n        if len(current_set) == n:\n            return 1\n\n        count = 0\n        for i in range(start, n):\n            if i not in current_set:\n                new_set = current_set.copy()\n                new_set.add(i)\n                count += backtrack(i + 1, current_score - scores[i], new_set, result)\n\n        return count\n\n    return str(backtrack(0, max(scores), set(), 0))"
    },
    {
        "number": 1268,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cans = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n    capacities = [c[1] for c in cans]\n    volumes = [c[0] for c in cans]\n\n    def can_pour(capacity: int, volume: int) -> bool:\n        return capacity >= volume\n\n    def can_pour_all(capacities: List[int], volumes: List[int]) -> bool:\n        for capacity, volume in zip(capacities, volumes):\n            if not can_pour(capacity, volume):\n                return False\n        return True\n\n    if can_pour_all(capacities, volumes):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1269,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def count_ways(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            if a[i - 1] < b[i - 1]:\n                a[i - 1], b[i - 1] = b[i - 1], a[i - 1]\n            if a[i - 1] == b[i - 1]:\n                count += 1\n        return count\n\n    def count_pairs(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            for j in range(i + 1, n + 1):\n                if c[j - 1] == 0:\n                    continue\n                if a[i - 1] < b[j - 1]:\n                    a[i - 1], b[j - 1] = b[j - 1], a[i - 1]\n                if a[i - 1] == b[j - 1]:\n                    count += 1\n        return count\n\n    def count_pairs_with_zero(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            for j in range(i + 1, n + 1):\n                if c[j - 1] == 0:\n                    continue\n                if a[i - 1] < b[j - 1]:\n                    a[i - 1], b[j - 1] = b[j - 1], a[i - 1]\n                if a[i - 1] == b[j - 1]:\n                    count += 1\n        return count\n\n    def count_pairs_with_zero_and_single_colour(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            for j in range(i + 1, n + 1):\n                if c[j - 1] == 0:\n                    continue\n                if a[i - 1] < b[j - 1]:\n                    a[i - 1], b[j - 1] = b[j - 1], a[i - 1]\n                if a[i - 1] == b[j - 1]:\n                    count += 1\n        return count\n\n    def count_pairs_with_single_colour(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            for j in range(i + 1, n + 1):\n                if c[j - 1] == 0:\n                    continue\n                if a[i - 1] < b[j - 1]:\n                    a[i - 1], b[j - 1] = b[j - 1], a[i - 1]\n                if a[i - 1] == b[j - 1]:\n                    count += 1\n        return count\n\n    def count_pairs_with_single_colour_and_zero(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            for j in range(i + 1, n + 1):\n                if c[j - 1] == 0:\n                    continue\n                if a[i - 1] < b[j - 1]:\n                    a[i - 1], b[j - 1] = b[j - 1], a[i - 1]\n                if a[i - 1] == b[j - 1]:\n                    count += 1\n        return count\n\n    def count_pairs_with_single_colour_and_single_colour(a, b):\n        count = 0\n        for i in range(1, n + 1):\n            if c[i - 1] == 0:\n                continue\n            for j in range(i + 1, n + 1):\n                if c[j - 1] == 0:\n                    continue\n                if a[i - 1] < b[j - 1]:\n                    a[i - 1], b[j - 1] = b[j -"
    },
    {
        "number": 1270,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    primes = []\n    for i in range(2, n + 1):\n        if all(i % j!= 0 for j in range(2, int(i ** 0.5) + 1)):\n            primes.append(i)\n    primes.sort()\n    return str(len(primes)) + '\\n' +''.join(map(str, primes))"
    },
    {
        "number": 1271,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    r = list(map(int, stdin.split()[1:]))\n    colors = list(stdin.split()[1:])\n\n    def can_eat(i: int, j: int) -> bool:\n        return colors[i]!= colors[j]\n\n    def can_move(i: int, j: int) -> bool:\n        return (j - i) == 1\n\n    def can_eat_from_box(i: int, j: int) -> bool:\n        return r[i] > r[j]\n\n    def can_move_to_box(i: int, j: int) -> bool:\n        return (j - i) == 2\n\n    def can_eat_from_box_and_move_to_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 2\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 3\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 4\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 5\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 6\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 7\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 8\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 9\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 10\n\n    def can_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box_and_move_to_box_and_eat_from_box(i: int, j: int) -> bool:\n        return r[i] > r[j] and (j - i) == 11\n\n    def can_eat_from_box_and_"
    },
    {
        "number": 1272,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    bridges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        bridges.append((a, b))\n\n    inconvenience = 0\n    for i in range(m):\n        a, b = bridges[i]\n        if a > b:\n            a, b = b, a\n\n        if a == b:\n            inconvenience += 1\n        else:\n            break\n\n    return str(inconvenience)"
    },
    {
        "number": 1273,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *edges = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    colors = set()\n    for i in range(1, n + 1):\n        colors.add(i)\n\n    def dfs(vertex, color):\n        nonlocal colors\n        colors.remove(color)\n        for neighbor in graph[vertex]:\n            if neighbor!= color:\n                dfs(neighbor, color)\n\n    for i in range(1, n + 1):\n        dfs(i, i)\n\n    return str(len(colors)) + '\\n' + '\\n'.join(str(color) for color in colors)\n"
    },
    {
        "number": 1274,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    jobs = []\n    for i in range(n):\n        a, b = map(int, stdin.split())\n        jobs.append((a, b))\n\n    jobs.sort(key=lambda x: x[0])\n\n    total_reward = 0\n    days = 0\n    for a, b in jobs:\n        if days + a <= m:\n            total_reward += b\n            days += a\n        else:\n            break\n\n    return str(total_reward)"
    },
    {
        "number": 1275,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for a in range(1, n+1):\n        for b in range(1, n+1):\n            for c in range(1, n+1):\n                for d in range(1, n+1):\n                    if a+b-c-d == k:\n                        count += 1\n    return str(count)"
    },
    {
        "number": 1276,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    R, G, B = map(str, S)\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if R[i]!= R[j] and R[i]!= R[k] and R[j]!= R[k]:\n                    if j - i!= k - j:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 1277,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, u, v = map(int, stdin.split())\n    adj_list = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n    visited = [False] * (n + 1)\n    visited[u] = True\n    queue = [u]\n    moves = 0\n    while queue:\n        size = len(queue)\n        for _ in range(size):\n            vertex = queue.pop(0)\n            if vertex == v:\n                return str(moves)\n            for neighbor in adj_list[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        moves += 1\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 1278,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_not_so_rainy(j: int) -> bool:\n        for d in range(j - x, j):\n            if a[d] >= a[j]:\n                return False\n        for d in range(j, j + y):\n            if a[d] >= a[j]:\n                return False\n        return True\n\n    for j in range(n):\n        if is_not_so_rainy(j):\n            return str(j)\n\n    return \"None\"\n"
    },
    {
        "number": 1279,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    chests = [0] * n\n    keys = [0] * m\n\n    for i in range(n):\n        chests[i] = a[i]\n\n    for j in range(m):\n        keys[j] = b[j]\n\n    max_chests = 0\n    for i in range(n):\n        if chests[i] == 0:\n            continue\n\n        for j in range(m):\n            if keys[j] == 0:\n                continue\n\n            if (chests[i] + keys[j]) % 2 == 1:\n                chests[i] -= keys[j]\n                keys[j] = 0\n                max_chests += 1\n                break\n\n    return str(max_chests)"
    },
    {
        "number": 1280,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, good_chars, k = stdin.split()\n    s = list(s)\n    good_chars = list(good_chars)\n    k = int(k)\n\n    def is_good(substring: str) -> bool:\n        for char in substring:\n            if char in good_chars:\n                return True\n        return False\n\n    def count_good_substrings(start: int, end: int) -> int:\n        count = 0\n        for i in range(start, end + 1):\n            substring = s[start:i]\n            if is_good(substring):\n                count += 1\n        return count\n\n    distinct_good_substrings = set()\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            distinct_good_substrings.add(count_good_substrings(i, j))\n\n    return str(len(distinct_good_substrings))\n"
    },
    {
        "number": 1281,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def xor_not_zero(x: int) -> int:\n        return x ^ (x >> 1) ^ (x >> 2) ^ (x >> 3) ^ (x >> 4)\n\n    def count_segments(i: int) -> int:\n        count = 0\n        for j in range(i):\n            if xor_not_zero(a[j])!= 0:\n                count += 1\n        return count\n\n    max_count = 0\n    for i in range(1, n):\n        if xor_not_zero(a[i])!= 0:\n            max_count = max(max_count, count_segments(i))\n\n    return str(max_count)"
    },
    {
        "number": 1282,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    changes = [0] * n\n    for i, s in enumerate(stdin):\n        if s == 'M':\n            changes[i] = 1\n        elif s == 'F':\n            changes[i] = -1\n    changes.sort()\n    count = 0\n    for i in range(n):\n        if changes[i] == 1:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 1283,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    field = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def find_max_ship_locations(row: int, col: int, ship_length: int, ship_orientation: str) -> int:\n        if ship_length == 1:\n            return 1\n\n        max_locations = 0\n        for i in range(n):\n            if field[row][i] == '.' and (ship_orientation == 'h' and i == col or ship_orientation == 'v' and row == i):\n                max_locations += find_max_ship_locations(row, i, ship_length - 1, ship_orientation)\n\n        return max_locations\n\n    max_locations = 0\n    max_row = 0\n    max_col = 0\n\n    for row in range(n):\n        for col in range(n):\n            if field[row][col] == '.' and find_max_ship_locations(row, col, k, 'h') > max_locations:\n                max_locations = find_max_ship_locations(row, col, k, 'h')\n                max_row = row\n                max_col = col\n\n    return str(max_row) +'' + str(max_col)\n"
    },
    {
        "number": 1284,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.append(a[0])\n    a.sort()\n    max_circular_value = a[-1]\n    for i in range(n - 1):\n        max_circular_value = max(max_circular_value, a[i] + a[i + 2])\n    return str(max_circular_value)"
    },
    {
        "number": 1285,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(int(stdin[i * n + j], 16))\n        matrix.append(row)\n\n    max_x = 1\n    while max_x * max_x <= n:\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    continue\n                row = i // max_x\n                col = j // max_x\n                if matrix[row][col] == 0:\n                    matrix[row][col] = 1\n                else:\n                    matrix[row][col] = 0\n        max_x *= 2\n\n    return str(max_x)"
    },
    {
        "number": 1286,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *a = map(int, stdin.split())\n    n = 1\n    for i in a:\n        n *= i\n\n    p = 1\n    q = 1\n    for i in range(1, n + 1):\n        p *= i\n        q *= n // i\n\n    p %= 10**9 + 7\n    q %= 10**9 + 7\n\n    return f\"{p}/{q}\""
    },
    {
        "number": 1287,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = []\n    for _ in range(n):\n        row = list(map(float, stdin.split()[1:]))\n        p.append(row)\n    p = np.array(p)\n    p = p + p.T\n    p = p / 2\n    p[np.diag_indices_from(p)] = 0\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p = np.array(p)\n    p = p.tolist()\n    p ="
    },
    {
        "number": 1288,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_at_odd_indices(s: list) -> int:\n        return max(s[i] for i in range(1, len(s), 2))\n\n    def max_at_even_indices(s: list) -> int:\n        return max(s[i] for i in range(0, len(s), 2))\n\n    min_cost = float('inf')\n    for i in range(n - k + 1):\n        s = a[i:i + k]\n        cost = min(max_at_odd_indices(s), max_at_even_indices(s))\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost)"
    },
    {
        "number": 1289,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *b = map(int, stdin.split())\n\n    def distance(a: int, b: int) -> int:\n        return abs(a - b)\n\n    def bus_stops(a: int, b: int) -> int:\n        return b - a + 1\n\n    def bus_stops_visited(a: int, b: int) -> int:\n        return sum(1 for i in range(a, b + 1) if i in b)\n\n    def bus_stops_visited_sorted(a: int, b: int) -> List[int]:\n        return sorted(set(b))\n\n    def bus_stops_visited_sorted_count(a: int, b: int) -> int:\n        return len(bus_stops_visited_sorted(a, b))\n\n    def bus_stops_visited_sorted_count_unique(a: int, b: int) -> int:\n        return len(set(bus_stops_visited_sorted(a, b)))\n\n    def bus_stops_visited_sorted_count_unique_length(a: int, b: int) -> int:\n        return len(bus_stops_visited_sorted(a, b))\n\n    def bus_stops_visited_sorted_count_unique_length_unique(a: int, b: int) -> int:\n        return len(set(bus_stops_visited_sorted(a, b)))\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count_unique(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count_unique_count(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count_unique(a, b)\n\n    def bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count_unique_count(a: int, b: int) -> int:\n        return bus_stops_visited_sorted_count_unique_length_unique_count_unique_count_unique_count_unique_count_unique_count("
    },
    {
        "number": 1290,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    columns = list(map(int, stdin.split()))\n\n    points = 0\n    for i in range(n):\n        if columns[i] == 0:\n            points += 1\n\n    return str(points)"
    },
    {
        "number": 1291,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    misha_points = []\n    sasha_points = []\n\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1].split())\n        misha_points.append((x, y))\n\n    for _ in range(m):\n        x, y = map(int, stdin.split()[1].split())\n        sasha_points.append((x, y))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def inside_circle(point, center, radius):\n        return distance(point, center) <= radius\n\n    def is_inside_circle(point, points):\n        for center in points:\n            if inside_circle(point, center, 1):\n                return True\n        return False\n\n    def is_inside_circle_misha(point):\n        return is_inside_circle(point, misha_points)\n\n    def is_inside_circle_sasha(point):\n        return is_inside_circle(point, sasha_points)\n\n    if is_inside_circle_misha((0, 0)) and is_inside_circle_sasha((0, 0)):\n        return \"NO\"\n    elif is_inside_circle_misha((0, 0)) or is_inside_circle_sasha((0, 0)):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1292,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    grid = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def bfs(x, y, player):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) not in visited and grid[x][y] == 0:\n                visited.add((x, y))\n                if grid[x][y] == player:\n                    return True\n                for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0:\n                        queue.append((nx, ny))\n        return False\n\n    def expand(player):\n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == 0 and bfs(x, y, player):\n                    grid[x][y] = player\n                    return True\n        return False\n\n    def count_controlled_cells(player):\n        count = 0\n        for x in range(n):\n            for y in range(m):\n                if grid[x][y] == player:\n                    count += 1\n        return count\n\n    for i in range(p):\n        if expand(i):\n            print(count_controlled_cells(i))\n        else:\n            print(0)"
    },
    {
        "number": 1293,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = map(int, stdin.split())\n    a = [0] * n\n    steps = 0\n\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n        if a[i] < b[i]:\n            a[i] += 1\n            steps += 1\n        else:\n            a[i] -= 1\n            steps += 1\n\n    return str(steps)"
    },
    {
        "number": 1294,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    buttons = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    working_buttons = []\n    for button in buttons:\n        if button in stdin:\n            working_buttons.append(button)\n    return ''.join(sorted(working_buttons))\n\ndef"
    },
    {
        "number": 1295,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    r = 0\n    for i in range(n):\n        if a[i] - r >= b[0]:\n            r = a[i]\n            break\n\n    return str(r)"
    },
    {
        "number": 1296,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_cost(k: int) -> int:\n        total_cost = 0\n        for i in range(n):\n            for j in range(i + 1, min(i + k, n) + 1):\n                total_cost += a[i] + j * k\n        return total_cost\n\n    k = 0\n    T = float('inf')\n    while k < n and T > S:\n        T = min_cost(k + 1)\n        k += 1\n\n    return f\"{k} {T}\""
    },
    {
        "number": 1297,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    count = 0\n    for i in range(n - 1):\n        if stdin[i] == stdin[i + 1]:\n            count += 1\n            if count % 2 == 0:\n                return str(count)\n    return str(count)"
    },
    {
        "number": 1298,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    min_length = n\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == '0' and s[j] == '1':\n                s = s[:i] + s[j+1:]\n                min_length = min(min_length, len(s))\n    return str(min_length)"
    },
    {
        "number": 1299,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    laws = list(map(int, stdin.split()))\n\n    def find_segment(laws, start, end):\n        for i in range(len(laws)):\n            if laws[i] >= start and laws[i] <= end:\n                return i\n        return -1\n\n    def find_max_absurdity(laws, start, end):\n        max_absurdity = 0\n        for i in range(len(laws)):\n            if laws[i] > max_absurdity and laws[i] >= start and laws[i] <= end:\n                max_absurdity = laws[i]\n        return max_absurdity\n\n    def find_min_absurdity(laws, start, end):\n        min_absurdity = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_absurdity and laws[i] >= start and laws[i] <= end:\n                min_absurdity = laws[i]\n        return min_absurdity\n\n    def find_min_a(laws, end):\n        min_a = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_a and laws[i] <= end:\n                min_a = laws[i]\n        return min_a\n\n    def find_min_b(laws, start, end):\n        min_b = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_b and laws[i] >= start:\n                min_b = laws[i]\n        return min_b\n\n    def find_max_b(laws, start, end):\n        max_b = 0\n        for i in range(len(laws)):\n            if laws[i] > max_b and laws[i] >= start:\n                max_b = laws[i]\n        return max_b\n\n    def find_min_c(laws, start, end):\n        min_c = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_c and laws[i] >= start and laws[i] <= end:\n                min_c = laws[i]\n        return min_c\n\n    def find_max_c(laws, start, end):\n        max_c = 0\n        for i in range(len(laws)):\n            if laws[i] > max_c and laws[i] >= start and laws[i] <= end:\n                max_c = laws[i]\n        return max_c\n\n    def find_min_d(laws, start, end):\n        min_d = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_d and laws[i] >= start and laws[i] <= end:\n                min_d = laws[i]\n        return min_d\n\n    def find_max_d(laws, start, end):\n        max_d = 0\n        for i in range(len(laws)):\n            if laws[i] > max_d and laws[i] >= start and laws[i] <= end:\n                max_d = laws[i]\n        return max_d\n\n    def find_min_e(laws, start, end):\n        min_e = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_e and laws[i] >= start and laws[i] <= end:\n                min_e = laws[i]\n        return min_e\n\n    def find_max_e(laws, start, end):\n        max_e = 0\n        for i in range(len(laws)):\n            if laws[i] > max_e and laws[i] >= start and laws[i] <= end:\n                max_e = laws[i]\n        return max_e\n\n    def find_min_f(laws, start, end):\n        min_f = 10**9\n        for i in range(len(laws)):\n            if laws[i] < min_f and laws[i] >= start and laws[i] <= end:\n                min_f = laws[i]\n        return min_f\n\n    def find_max_f(laws, start, end):\n        max_f = 0\n        for i in range(len(laws)):\n            if laws[i] > max_f and laws[i] >= start and laws[i] <= end:\n               "
    },
    {
        "number": 1300,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                if a[i] + a[j] + a[k] == c:\n                    max_count += 1\n\n    return str(max_count)"
    },
    {
        "number": 1301,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_valid(row: int, col: int, word: str) -> bool:\n        for i, c in enumerate(word):\n            if grid[row][col + i]!= c:\n                return False\n        return True\n\n    def find_pokemon(row: int, col: int, word: str) -> str:\n        for pokemon in names:\n            if is_valid(row, col, pokemon):\n                return pokemon\n        return \"\"\n\n    names = [\"vaporeon\", \"jolteon\", \"flareon\", \"espeon\", \"umbreon\", \"leafeon\", \"glaceon\", \"sylveon\"]\n    for row in range(len(grid)):\n        for col in range(len(grid[0])):\n            if grid[row][col]!= \".\":\n                word = grid[row][col]\n                pokemon = find_pokemon(row, col, word)\n                if pokemon:\n                    print(pokemon)\n                    return\n\n    print(\"No valid pokemon found.\")\n    return \"\"\n"
    },
    {
        "number": 1302,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return -1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_good(p, i):\n        return gcd(i, p[i]) > 1\n\n    def is_beautiful(p):\n        return sum(is_good(p, i) for i in range(n)) == k\n\n    def find_beautiful_permutation():\n        for p in permutations(range(1, n + 1)):\n            if is_beautiful(p):\n                return p\n        return None\n\n    return find_beautiful_permutation() or -1\n\n\ndef"
    },
    {
        "number": 1303,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    def get_moments(a, b, c, d, l, r):\n        moments = []\n        for i in range(len(a)):\n            if a[i] <= l <= b[i]:\n                moments.append(c[i])\n            if b[i] <= l <= c[i]:\n                moments.append(d[i])\n            if c[i] <= l <= d[i]:\n                moments.append(a[i])\n            if d[i] <= l <= a[i]:\n                moments.append(b[i])\n        return moments\n\n    moments = get_moments(a, b, c, d, l, r)\n    return str(len(moments))"
    },
    {
        "number": 1304,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    table = []\n    for line in stdin.split('\\n'):\n        if line:\n            table.append(line.strip())\n    x, y = map(int, stdin.split('\\n')[1].split())\n\n    def get_neighbors(x, y):\n        return [(x+dx, y+dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if 0 <= x+dx < 9 and 0 <= y+dy < 9]\n\n    def get_valid_moves(x, y):\n        valid_moves = []\n        for neighbor in get_neighbors(x, y):\n            if table[neighbor[0]][neighbor[1]] == '.':\n                valid_moves.append(neighbor)\n        return valid_moves\n\n    def get_valid_moves_for_player(x, y, player):\n        valid_moves = get_valid_moves(x, y)\n        if player == 'x':\n            return [move for move in valid_moves if table[move[0]][move[1]] == 'o']\n        else:\n            return [move for move in valid_moves if table[move[0]][move[1]] == 'x']\n\n    def get_valid_moves_for_player_in_field(x, y, player, field):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move in field]\n\n    def get_valid_moves_for_player_in_small_field(x, y, player, small_field):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move in small_field]\n\n    def get_valid_moves_for_player_in_central_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [0, 4, 8] and move[1] in [0, 4, 8]]\n\n    def get_valid_moves_for_player_in_lower_left_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [1, 5, 9] and move[1] in [1, 5, 9]]\n\n    def get_valid_moves_for_player_in_upper_left_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [2, 6, 10] and move[1] in [2, 6, 10]]\n\n    def get_valid_moves_for_player_in_lower_central_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [3, 7, 11] and move[1] in [3, 7, 11]]\n\n    def get_valid_moves_for_player_in_upper_central_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [0, 4, 8] and move[1] in [0, 4, 8]]\n\n    def get_valid_moves_for_player_in_lower_right_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [5, 9, 13] and move[1] in [5, 9, 13]]\n\n    def get_valid_moves_for_player_in_upper_right_field(x, y, player):\n        valid_moves = get_valid_moves_for_player(x, y, player)\n        return [move for move in valid_moves if move[0] in [6, 10, 14] and move[1] in [6, 10, 14]]\n\n    def get_valid_moves_for_player_in_lower_left"
    },
    {
        "number": 1305,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bills = list(map(int, stdin.split()[1:]))\n\n    total_bills = sum(bills)\n    change = 0\n\n    for i in range(n):\n        if bills[i] == 100:\n            bills[i] -= 25\n            change += 25\n        elif bills[i] == 50:\n            bills[i] -= 25\n            change += 25\n        elif bills[i] == 25:\n            bills[i] -= 25\n            change += 25\n\n    if change == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1306,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def count_ways(l, r):\n        if l == r:\n            return 0\n        if l > r:\n            l, r = r, l\n        ways = 0\n        for i in range(l, r + 1):\n            if a[i] == h:\n                ways += 1\n        return ways\n\n    ways = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if count_ways(i, j) == count_ways(j, i):\n                ways = (ways * (count_ways(i, j) - 1)) % 1000000007\n    return str(ways)"
    },
    {
        "number": 1307,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mahmoud_turn = True\n    while n > 0:\n        if mahmoud_turn:\n            a = 2\n            while a % 2 == 0:\n                a += 1\n            if a > n:\n                break\n            n -= a\n        else:\n            a = 1\n            while a % 2 == 1:\n                a += 1\n            if a > n:\n                break\n            n -= a\n        mahmoud_turn = not mahmoud_turn\n    if n == 0:\n        return \"Mahmoud\"\n    else:\n        return \"Ehab\""
    },
    {
        "number": 1308,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    queries = []\n    for _ in range(m):\n        x, y, len_ = map(int, stdin.split())\n        queries.append((x, y, len_))\n\n    def is_isomorphic(s1: str, s2: str) -> bool:\n        if len(s1)!= len(s2):\n            return False\n        s1_set = set(s1)\n        s2_set = set(s2)\n        if len(s1_set)!= len(s2_set):\n            return False\n        for s1_char, s2_char in zip(s1, s2):\n            if s1_char not in s1_set or s2_char not in s2_set:\n                return False\n            if s1_char!= s2_char:\n                return False\n        return True\n\n    def find_isomorphic_substring(s: str, queries: List[Tuple[int, int, int]]) -> List[str]:\n        isomorphic_substrings = []\n        for x, y, len_ in queries:\n            s1 = s[x:x + len_]\n            s2 = s[y:y + len_]\n            if is_isomorphic(s1, s2):\n                isomorphic_substrings.append(\"YES\")\n            else:\n                isomorphic_substrings.append(\"NO\")\n        return isomorphic_substrings\n\n    return \"\\n\".join(find_isomorphic_substring(s, queries))\n"
    },
    {
        "number": 1309,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    weights = list(map(int, stdin.split()[1:]))\n\n    min_instability = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(weights[i] - weights[j]) > 1:\n                min_instability = min(min_instability, abs(weights[i] - weights[j]))\n\n    return str(min_instability)"
    },
    {
        "number": 1310,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    max_xor = 0\n    for i in range(n):\n        xor = 0\n        for j in range(i, n):\n            xor ^= arr[j]\n        max_xor = max(max_xor, xor)\n\n    return str(max_xor)"
    },
    {
        "number": 1311,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, w = map(int, stdin.split()[1:])\n        points.append((x, w))\n    points.sort(key=lambda x: x[0])\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(points[i][0] - points[j][0]) >= points[i][1] + points[j][1]:\n                edges.append((i, j))\n    max_clique = 0\n    for i in range(1, n):\n        max_clique = max(max_clique, i)\n        for j in range(i + 1, n):\n            if abs(points[i][0] - points[j][0]) >= points[i][1] + points[j][1]:\n                max_clique = max(max_clique, j)\n    return str(max_clique)"
    },
    {
        "number": 1312,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [0] * m\n    for i in range(m):\n        a[i] = n // m\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1313,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_1, n_2, k_1, k_2 = map(int, stdin.split())\n    if n_1 > k_1 + n_2 or n_2 > k_2 + n_1:\n        return \"Second\"\n    elif n_1 == k_1 + n_2 and n_2 == k_2 + n_1:\n        return \"Tie\"\n    else:\n        return \"First\""
    },
    {
        "number": 1314,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    obelisks = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[1:3])\n        obelisks.append((x, y))\n\n    clues = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[3:5])\n        clues.append((a, b))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if obelisks[i] == obelisks[j]:\n                if clues[i] == clues[j]:\n                    return \" \".join(map(str, obelisks[i]))\n\n    return \" \".join(map(str, obelisks[0]))"
    },
    {
        "number": 1315,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort(reverse=True)\n    for i in range(n - 1):\n        if a[i] + 1 == a[i + 1]:\n            return \":(\"\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1316,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def count_distinct_chars(s: str) -> int:\n        return len(set(s))\n\n    def count_substrings(s: str, k: int) -> int:\n        count = 0\n        for i in range(len(s) - k + 1):\n            count += 1\n        return count\n\n    def is_valid(s: str, k: int) -> bool:\n        distinct_chars = count_distinct_chars(s)\n        substrings = count_substrings(s, k)\n        return distinct_chars == k and substrings >= k\n\n    def level(s: str, k: int) -> int:\n        if is_valid(s, k):\n            return 0\n        for x in range(1, n + 1):\n            if is_valid(s, k):\n                return x\n        return n + 1\n\n    return str(level(s, k))"
    },
    {
        "number": 1317,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            count += i**2 + j**2\n    return str(count // m)"
    },
    {
        "number": 1318,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    requests = []\n    for _ in range(n):\n        c, p = map(int, stdin.split())\n        requests.append((c, p))\n\n    tables = []\n    for _ in range(k):\n        r = int(stdin.split())\n        tables.append(r)\n\n    requests.sort(key=lambda x: (-x[0], x[1]))\n    tables.sort(reverse=True)\n\n    accepted = 0\n    total_money = 0\n    for i, (c, p) in enumerate(requests):\n        if accepted == 0:\n            for j, r in enumerate(tables):\n                if c <= r:\n                    accepted = i + 1\n                    total_money += p * c\n                    break\n\n    return f\"{accepted} {total_money}\""
    },
    {
        "number": 1319,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, *p = map(int, stdin.split())\n    n = 1\n    for prime in p:\n        n *= prime\n    n %= (10**9 + 7)\n    return str(n)"
    },
    {
        "number": 1320,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cake = [list(row) for row in stdin.split()[1:]]\n\n    happiness = 0\n    for i in range(n):\n        for j in range(n):\n            if cake[i][j] == 'C':\n                for k in range(n):\n                    if cake[i][k] == 'C' and (k == j or k == i):\n                        happiness += 1\n\n    return str(happiness)"
    },
    {
        "number": 1321,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    friends = []\n    for _ in range(n):\n        w, h = map(int, stdin.split()[1:])\n        friends.append((w, h))\n    friends.sort(key=lambda x: x[1])\n    result = []\n    for i in range(n):\n        w, h = friends[i]\n        result.append(w * h)\n    return''.join(map(str, result))"
    },
    {
        "number": 1322,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    MOD = 10**9 + 7\n\n    def dfs(state: str, depth: int, memo: dict) -> int:\n        if state in memo:\n            return memo[state]\n\n        if depth == N:\n            memo[state] = 1\n            return 1\n\n        memo[state] = 0\n        for move in moves[state]:\n            memo[state] += dfs(move, depth + 1, memo)\n            memo[state] %= MOD\n        return memo[state]\n\n    moves = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"D\", \"E\", \"F\", \"G\"],\n        \"C\": [\"D\", \"E\", \"F\", \"G\"],\n        \"D\": [\"H\", \"I\", \"K\", \"M\"],\n        \"E\": [\"H\", \"I\", \"K\", \"M\"],\n        \"F\": [\"H\", \"I\", \"K\", \"M\"],\n        \"G\": [\"H\", \"I\", \"K\", \"M\"],\n        \"H\": [\"N\", \"O\", \"Q\", \"P\"],\n        \"I\": [\"N\", \"O\", \"Q\", \"P\"],\n        \"J\": [\"N\", \"O\", \"Q\", \"P\"],\n        \"K\": [\"N\", \"O\", \"Q\", \"P\"],\n        \"L\": [\"N\", \"O\", \"Q\", \"P\"],\n        \"M\": [\"N\", \"O\", \"Q\", \"P\"],\n        \"N\": [\"R\", \"S\", \"T\", \"U\"],\n        \"O\": [\"R\", \"S\", \"T\", \"U\"],\n        \"P\": [\"R\", \"S\", \"T\", \"U\"],\n        \"Q\": [\"R\", \"S\", \"T\", \"U\"],\n        \"R\": [\"R\", \"S\", \"T\", \"U\"],\n        \"S\": [\"R\", \"S\", \"T\", \"U\"],\n        \"T\": [\"R\", \"S\", \"T\", \"U\"],\n        \"U\": [\"R\", \"S\", \"T\", \"U\"],\n    }\n\n    return str(dfs(\"A\", 1, {}))"
    },
    {
        "number": 1323,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def merge_clusters(a, b):\n        merged_a = merge_sort(a)\n        merged_b = merge_sort(b)\n        merged_ab = merge(merged_a, merged_b)\n        return merged_ab\n\n    def min_operations(a, b):\n        merged_ab = merge_clusters(a, b)\n        min_ops = 0\n        for i in range(len(merged_ab)):\n            if i == 0 or merged_ab[i]!= merged_ab[i - 1]:\n                min_ops += 1\n        return min_ops\n\n    return str(min_operations(a, b))\n"
    },
    {
        "number": 1324,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    s = stdin.split()[1]\n    calories = 0\n\n    for i in range(len(s)):\n        if s[i] == '1':\n            calories += a[0]\n        elif s[i] == '2':\n            calories += a[1]\n        elif s[i] == '3':\n            calories += a[2]\n        elif s[i] == '4':\n            calories += a[3]\n\n    return str(calories)"
    },
    {
        "number": 1325,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    s = stdin.split()[1]\n    left, right, up, down = 0, 0, 0, 0\n    while left < right < n:\n        if s[left]!= s[right]:\n            break\n        left += 1\n        right += 1\n    while up < down < n:\n        if s[up]!= s[down]:\n            break\n        up += 1\n        down += 1\n    return min(left, right, up, down)"
    },
    {
        "number": 1326,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    result = 0\n    for i in range(1, N+1):\n        result += i * sum(1 for j in range(1, i) if i % j == 0)\n    return str(result)"
    },
    {
        "number": 1327,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cakes = []\n    for _ in range(n):\n        beauty, tastiness, popularity = map(int, stdin.split())\n        cakes.append((beauty, tastiness, popularity))\n    cakes.sort(key=lambda x: (-abs(x[0]), -abs(x[1]), -abs(x[2])))\n    total_beauty = total_tastiness = total_popularity = 0\n    for beauty, tastiness, popularity in cakes:\n        total_beauty += abs(beauty)\n        total_tastiness += abs(tastiness)\n        total_popularity += abs(popularity)\n        if m == 0:\n            break\n        m -= 1\n    return str(total_beauty + total_tastiness + total_popularity)"
    },
    {
        "number": 1328,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M_a, M_b = map(int, stdin.split())\n    a_list, b_list, c_list = [], [], []\n\n    for _ in range(n):\n        a, b, c = map(int, stdin.split())\n        a_list.append(a)\n        b_list.append(b)\n        c_list.append(c)\n\n    a_sum = sum(a_list)\n    b_sum = sum(b_list)\n\n    if a_sum % M_a!= 0 or b_sum % M_b!= 0:\n        return -1\n\n    a_count = a_sum // M_a\n    b_count = b_sum // M_b\n\n    if a_count * M_a + b_count * M_b!= a_sum + b_sum:\n        return -1\n\n    min_money = float('inf')\n    for i in range(n):\n        if a_list[i] * a_count + b_list[i] * b_count == a_sum + b_sum:\n            min_money = min(min_money, c_list[i])\n\n    return str(min_money)"
    },
    {
        "number": 1329,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    for i in range(1, N + 1):\n        if sum(1 for j in range(1, i + 1) if i % j == 0) == 75:\n            count += 1\n    print(count)\n    return \"\""
    },
    {
        "number": 1330,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = int(stdin.split()[0])\n    k = list(map(int, stdin.split()))\n\n    def mex(s: set) -> int:\n        return min(s)\n\n    def max_strength(clubs: list) -> int:\n        max_strength = 0\n        for club in clubs:\n            max_strength = max(max_strength, sum(p[i] for i in club))\n        return max_strength\n\n    def max_strength_teams(clubs: list) -> list:\n        max_strengths = []\n        for club in clubs:\n            max_strengths.append(max_strength(club))\n        return max_strengths\n\n    def max_strength_teams_for_day(day: int) -> int:\n        clubs = [[] for _ in range(m + 1)]\n        for i in range(n):\n            if c[i] == day:\n                clubs[k[i]].append(i)\n        return max(max_strength_teams(club) for club in clubs)\n\n    return '\\n'.join(map(str, max_strength_teams_for_day(i) for i in range(1, d + 1)))"
    },
    {
        "number": 1331,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    count = 0\n    for i in range(len(a)):\n        if i == 0 or a[i] - a[i - 1]!= 1:\n            count += 1\n            if count >= k:\n                return str(i + 1)\n    return str(len(a) - count)"
    },
    {
        "number": 1332,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    coins = list(map(int, stdin.split()))\n    if any(coins) and all(coins):\n        return str(max(coins))\n    else:\n        return \"-1\""
    },
    {
        "number": 1333,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    snake = '#' * (n - 1) + '.' * (m - 1)\n    for i in range(1, n - 1):\n        snake += '#' * (m - 1) + '.' * (2 * i - 1) + '#' * (m - 1)\n    return snake + '\\n' * (n - 1)"
    },
    {
        "number": 1334,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def is_subset(s1: str, s2: str) -> bool:\n        return all(s1[i] in s2 for i in range(len(s1)))\n\n    def is_smaller(s1: str, s2: str) -> bool:\n        for i in range(min(len(s1), len(s2))):\n            if s1[i] < s2[i]:\n                return True\n            elif s1[i] > s2[i]:\n                return False\n        return len(s1) < len(s2)\n\n    def lexicographically_smallest_subset(s: str, k: int) -> str:\n        if len(s) == k:\n            return s\n\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if j > k:\n                    break\n                if is_subset(s[:i] + s[i:j], s):\n                    return lexicographically_smallest_subset(s[:i] + s[i:j], k)\n\n        return s\n\n    t = lexicographically_smallest_subset(s, k)\n    return t\n"
    },
    {
        "number": 1335,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def test(i: int, t: int) -> int:\n        nonlocal n\n        if i == n:\n            return 0\n        if t == a[i]:\n            return 1\n        if t > a[i]:\n            return test(i + 1, t)\n        return test(i + 1, t + 1)\n\n    interesting = 0\n    for i in range(n):\n        for t in range(1, a[i] + 1):\n            if test(0, t) == 1:\n                interesting += 1\n\n    return str(interesting)"
    },
    {
        "number": 1336,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matryoshkas = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n\n    MOD = 10**9 + 7\n\n    def is_big_enough(subset):\n        total_space = 0\n        for i in range(len(subset)):\n            total_space += matryoshkas[subset[i]][1] - matryoshkas[subset[i]][0]\n        return total_space >= 0\n\n    def find_big_enough_subsets(start, end):\n        if start == end:\n            return [start]\n        if is_big_enough(start):\n            return [start] + find_big_enough_subsets(start + 1, end)\n        return find_big_enough_subsets(start + 1, end)\n\n    def count_subsets(subset):\n        count = 1\n        for i in range(len(subset)):\n            count *= (len(subset) - i)\n        return count\n\n    def count_big_enough_subsets():\n        count = 0\n        for i in range(n):\n            for subset in find_big_enough_subsets([i], [i]):\n                count += count_subsets(subset)\n        return count\n\n    return str(count_big_enough_subsets() % MOD)\n"
    },
    {
        "number": 1337,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *b = map(int, stdin.split())\n    c, *d = map(int, stdin.split())\n\n    movies = []\n    for i in range(m):\n        movies.append((a[i], b[i], c[i], d[i]))\n\n    max_scientists = 0\n    max_movies = []\n\n    for movie in movies:\n        scientists_very_pleased = 0\n        scientists_almost_satisfied = 0\n\n        for i in range(n):\n            if movie[0] == a[i]:\n                scientists_very_pleased += 1\n            if movie[1] == b[i]:\n                scientists_almost_satisfied += 1\n\n        if scientists_very_pleased > max_scientists:\n            max_scientists = scientists_very_pleased\n            max_movies = [movie]\n        elif scientists_very_pleased == max_scientists:\n            max_movies.append(movie)\n\n    return str(max_movies[0][0])"
    },
    {
        "number": 1338,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if 1 <= n <= 8:\n        return \"1 2\"\n    elif 1 <= n <= 50:\n        return \"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 1339,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[1:3])\n        segments.append([l, r])\n    segments.sort(key=lambda x: x[0])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][1] >= segments[j][0]:\n                print(i + 1)\n                return\n\n    print(-1)\n    return"
    },
    {
        "number": 1340,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(lambda x: x - 1, a))\n    colors = set(a)\n    min_operations = float('inf')\n\n    for i in range(len(colors)):\n        for j in range(i + 1, len(colors)):\n            if colors[i] == colors[j]:\n                continue\n            left, right = 0, n - 1\n            while left < right:\n                mid = (left + right) // 2\n                if a[mid] == colors[i]:\n                    left = mid + 1\n                elif a[mid] == colors[j]:\n                    right = mid\n                else:\n                    left = mid + 1\n            min_operations = min(min_operations, right - left)\n\n    return str(min_operations)"
    },
    {
        "number": 1341,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s = list(s)\n    t = list(t)\n\n    liss_position = 1\n    for instruction in t:\n        if instruction == 'RED':\n            if s[liss_position - 1] == 'R':\n                liss_position += 1\n            else:\n                liss_position += 0\n        elif instruction == 'GREEN':\n            if s[liss_position - 1] == 'G':\n                liss_position += 1\n            else:\n                liss_position += 0\n        elif instruction == 'BLUE':\n            if s[liss_position - 1] == 'B':\n                liss_position += 1\n            else:\n                liss_position += 0\n\n    return str(liss_position)"
    },
    {
        "number": 1342,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(lambda x: list(map(int, x.split())), stdin.split()))\n\n    def is_valid(balls: list) -> bool:\n        colors = set()\n        for ball in balls:\n            if ball not in colors:\n                colors.add(ball)\n            else:\n                return False\n        return True\n\n    def find_min_sets(balls: list) -> int:\n        sets = []\n        for i in range(1, n + 1):\n            sets.append([])\n        for ball in balls:\n            sets[ball - 1].append(ball)\n        return len(sets)\n\n    def find_min_sets_helper(balls: list, sets: list, index: int, current_set: list) -> int:\n        if index == len(balls):\n            return find_min_sets(current_set)\n        if len(current_set) == n:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)):\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 1:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 1:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 2:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 2:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 3:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 3:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 4:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 4:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 5:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 5:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 6:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 6:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 7:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 7:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 8:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 8:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 9:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 9:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + 10:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) - 10:\n            return float('inf')\n        if len(current_set) > 1 and len(current_set) == len(set(current_set)) + "
    },
    {
        "number": 1343,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    roads = [tuple(map(int, stdin.split())) for _ in range(m)]\n    storages = set(map(int, stdin.split()))\n\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        min_cost = float('inf')\n\n        while queue:\n            city, cost = queue.pop(0)\n            if city in visited:\n                continue\n            visited.add(city)\n\n            if city == n:\n                min_cost = min(min_cost, cost)\n                continue\n\n            for road in roads:\n                if road[0] == city and road[1] == n:\n                    queue.append((road[1], cost + road[2]))\n                elif road[1] == city and road[0] == n:\n                    queue.append((road[0], cost + road[2]))\n\n        return min_cost if min_cost!= float('inf') else -1\n\n    return str(bfs(1))"
    },
    {
        "number": 1344,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            current_length += 1\n        else:\n            current_length = 1\n\n        max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 1345,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    s = 0\n    for i in range(n):\n        s += a[i]\n        if s > a[0]:\n            s -= a[0]\n            yield \"-\"\n        else:\n            yield \"+\""
    },
    {
        "number": 1346,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def power(x, n):\n        if n == 0:\n            return 1\n        if n % 2 == 0:\n            return power(x * x, n // 2)\n        else:\n            return x * power(x * x, (n - 1) // 2)\n\n    def find_t(a, b, p):\n        for t in range(n + m - 2):\n            if a[t] % p!= 0 or b[t] % p!= 0:\n                return t\n        return -1\n\n    def main():\n        f = [a[i] * power(x, n - i - 1) for i in range(n)]\n        g = [b[i] * power(x, m - i - 1) for i in range(m)]\n        h = [f[i] * g[i] for i in range(n + m - 2)]\n\n        t = find_t(a, b, p)\n        if t == -1:\n            return \"No solution exists.\"\n        else:\n            return str(t)\n\n    return main()\n\n\ndef"
    },
    {
        "number": 1347,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    synonyms = []\n    for i in range(int(stdin.split()[0])):\n        synonyms.append(stdin.split()[i+1].split())\n    words = [word.lower() for word in words]\n    min_length = float('inf')\n    min_r = float('inf')\n    for word in words:\n        for synonym in synonyms:\n            if word in synonym:\n                new_word = synonym[synonym.index(word)]\n                new_word = new_word.lower()\n                if len(new_word) < min_length:\n                    min_length = len(new_word)\n                    min_r = 0\n                elif len(new_word) == min_length:\n                    min_r += new_word.count('r')\n    return str(min_r) +'' + str(min_length)"
    },
    {
        "number": 1348,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n\n    def bfs(start: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        distances = [float('inf')] * (n + 1)\n        distances[start] = 0\n\n        while queue:\n            current = queue.popleft()\n            visited.add(current)\n\n            for neighbor in range(1, n + 1):\n                if neighbor not in visited and d[current - 1] + d[neighbor - 1] <= k:\n                    queue.append(neighbor)\n                    distances[neighbor] = distances[current] + d[current - 1]\n\n        return distances\n\n    distances = bfs(1)\n    m = 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if distances[i] + distances[j] == k:\n                m += 1\n                print(f\"{i} {j}\")\n\n    if m == 0:\n        return \"-1\"\n\n    return str(m)\n"
    },
    {
        "number": 1349,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        x = list(map(int, stdin.split('\\n')[2].split()))\n        x.sort()\n        watered_beds = set()\n        for i in range(1, k):\n            if x[i] - 1 < x[i]:\n                watered_beds.add(x[i])\n        watered_beds.add(n)\n        watered_beds = sorted(watered_beds)\n        min_seconds = 0\n        for i in range(1, len(watered_beds)):\n            min_seconds += watered_beds[i] - watered_beds[i - 1]\n        print(min_seconds)"
    },
    {
        "number": 1350,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    freq = [0] * 26\n    max_len = 0\n    for c in s:\n        freq[ord(c) - ord('A')] += 1\n        if freq[ord(c) - ord('A')] == 1:\n            max_len = max(max_len, 1)\n        else:\n            max_len = max(max_len, 1 + max_len)\n    return str(max_len)"
    },
    {
        "number": 1351,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n\n    def is_valid(x: int) -> bool:\n        return all(int(digit)!= digit for digit in str(x)) and l <= x <= r\n\n    for x in range(l, r + 1):\n        if is_valid(x):\n            return str(x)\n\n    return -1"
    },
    {
        "number": 1352,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(l, r):\n        return [a[i] for i in range(n) if a[i] >= l and a[i] <= r]\n\n    def count_pairs(l, r):\n        pairs = 0\n        for i in range(n):\n            if a[i] >= l and a[i] <= r:\n                for j in range(i + 1, n):\n                    if a[j] >= l and a[j] <= r:\n                        pairs += 1\n        return pairs\n\n    pairs = 0\n    for i in range(1, x + 1):\n        for j in range(i, x + 1):\n            if f(i, j) == sorted(f(i, j)):\n                pairs += count_pairs(i, j)\n\n    return str(pairs)"
    },
    {
        "number": 1353,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    min_sum = float('inf')\n    for i in range(1, n+1):\n        min_sum = min(min_sum, a * i + b * m)\n    return str(min_sum)"
    },
    {
        "number": 1354,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    ships = []\n    for _ in range(k):\n        x, y = map(int, stdin.split())\n        ships.append((x, y, a))\n\n    ships.sort(key=lambda x: (x[1], x[0]))\n\n    for i in range(m):\n        x = int(stdin.split()[i + 1])\n        if x in [ship[0] for ship in ships]:\n            ships.remove((x, ships[x - 1][1], ships[x - 1][2]))\n            ships.append((x, ships[x - 1][1], ships[x - 1][2]))\n\n    if not ships:\n        return \"-1\"\n    else:\n        return str(ships[0][0])"
    },
    {
        "number": 1355,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        vertices.append((x, y))\n\n    lines = []\n    for _ in range(m):\n        x1, y1, x2, y2 = map(float, stdin.split())\n        lines.append((x1, y1, x2, y2))\n\n    def distance(p1: tuple, p2: tuple) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def cross_product(p1: tuple, p2: tuple, p3: tuple) -> float:\n        return (p2[0] - p1[0]) * (p3[1] - p2[1]) - (p2[1] - p1[1]) * (p3[0] - p2[0])\n\n    def angle(p1: tuple, p2: tuple, p3: tuple) -> float:\n        return abs(cross_product(p1, p2, p3) / (distance(p1, p2) * distance(p1, p3)))\n\n    def is_convex(vertices: list) -> bool:\n        n = len(vertices)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if cross_product(vertices[i], vertices[j], vertices[(i + j) % n]) < 0:\n                    return False\n        return True\n\n    def common_part(line: tuple, vertices: list) -> float:\n        x1, y1, x2, y2 = line\n        min_x = min(x1, x2)\n        max_x = max(x1, x2)\n        min_y = min(y1, y2)\n        max_y = max(y1, y2)\n\n        common_vertices = []\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                if (x, y) in vertices:\n                    common_vertices.append((x, y))\n\n        if len(common_vertices) < 3:\n            return 0\n\n        common_vertices.sort(key=lambda x: angle(vertices[0], vertices[1], x))\n\n        common_part_length = 0\n        for i in range(len(common_vertices) - 1):\n            common_part_length += distance(common_vertices[i], common_vertices[i + 1])\n\n        return common_part_length\n\n    result = []\n    for line in lines:\n        x1, y1, x2, y2 = line\n        common_part_length = common_part(line, vertices)\n        result.append(common_part_length)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 1356,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    max_count = 0\n    max_length = 0\n    for i in range(len(s)):\n        if s[i] == 'a':\n            count += 1\n            if count > max_count:\n                max_count = count\n                max_length = i + 1\n        else:\n            count = 0\n    return str(max_length)"
    },
    {
        "number": 1357,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_time(house: int) -> int:\n        min_time = float('inf')\n        for i in range(house):\n            min_time = min(min_time, abs(a[i] - house) + min_time)\n        return min_time\n\n    return str(min_time(1))"
    },
    {
        "number": 1358,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    strings = []\n    for _ in range(k):\n        s, a = stdin.split()\n        a = int(a)\n        strings.append((s, a))\n\n    strings.sort(key=lambda x: (-x[1], x[0]))\n\n    max_beauty = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            if strings[i][0] == strings[j][0]:\n                max_beauty = max(max_beauty, strings[i][1] + strings[j][1])\n\n    return str(max_beauty)"
    },
    {
        "number": 1359,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    rhombi = set()\n\n    def dfs(intersection: int, visited: set) -> None:\n        if intersection in visited:\n            return\n        visited.add(intersection)\n        for road in roads:\n            if road[0] == intersection:\n                dfs(road[1], visited)\n            elif road[1] == intersection:\n                dfs(road[0], visited)\n        rhombi.add(intersection)\n\n    for i in range(1, n + 1):\n        dfs(i, set())\n\n    return str(len(rhombi))"
    },
    {
        "number": 1360,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    exams = []\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:])\n        exams.append((a, b))\n    exams.sort()\n    for i in range(n):\n        if exams[i][0] == exams[i][1]:\n            return str(exams[i][0])\n    return str(exams[-1][1])"
    },
    {
        "number": 1361,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    a.sort()\n    a.append(a[-1] + 1)\n\n    def min_diff(a, n):\n        min_diff = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                min_diff = min(min_diff, a[j] - a[i])\n        return min_diff\n\n    return str(min_diff(a, n))"
    },
    {
        "number": 1362,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, m = map(int, stdin.split())\n    days = list(map(int, stdin.split()))\n    days.sort()\n    count = 0\n    balance = 0\n    for i in range(1, m + 1):\n        if balance < 0:\n            count += 1\n        balance += p\n        if i in days:\n            balance -= days[days.index(i)]\n    return str(count)"
    },
    {
        "number": 1364,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n\n    t_with_tuna = sum(t[:n//2])\n    t_with_eel = sum(t[n//2:])\n\n    if t_with_tuna == t_with_eel:\n        return str(max(t_with_tuna, t_with_eel))\n    else:\n        return str(max(t_with_tuna, t_with_eel) + 1)"
    },
    {
        "number": 1365,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n + 1)\n    ways = 1\n    for u in range(1, n + 1):\n        if not visited[u]:\n            visited[u] = True\n            ways = (ways * dfs(u, k, graph, visited)) % (10**9 + 7)\n    return str(ways)\n\ndef"
    },
    {
        "number": 1366,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bottles = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[i+1].split())\n        bottles.append((a, b))\n\n    opened_bottles = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            if bottles[i][0] == bottles[j][1]:\n                opened_bottles.add(i)\n                opened_bottles.add(j)\n\n    return str(len(opened_bottles))"
    },
    {
        "number": 1367,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    b = set(range(1, n + 1))\n    c = a.symmetric_difference(b)\n    return str(c.pop())"
    },
    {
        "number": 1368,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    values = list(map(int, stdin.split()[1:]))\n\n    def find_mean(selected):\n        return sum(values[i] for i in selected) / len(selected)\n\n    def find_ways(selected):\n        return len(set(values) - set(values[i] for i in selected))\n\n    selected = set()\n    max_mean = float('-inf')\n    max_ways = 0\n\n    for i in range(n):\n        if i < a - 1:\n            selected.add(i)\n        elif i < b - 1:\n            selected.add(i)\n            max_mean = max(max_mean, find_mean(selected))\n            max_ways = max(max_ways, find_ways(selected))\n            selected.remove(i)\n        else:\n            max_mean = max(max_mean, find_mean(selected))\n            max_ways = max(max_ways, find_ways(selected))\n\n    return f\"{max_mean:.6f}\\n{max_ways}\""
    },
    {
        "number": 1369,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(float, stdin.split()[1:])\n        points.append((x, y))\n    min_radius = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = points[i][0] - points[j][0]\n            dy = points[i][1] - points[j][1]\n            distance = (dx ** 2 + dy ** 2) ** 0.5\n            if distance < min_radius:\n                min_radius = distance\n    return f\"{min_radius:.6f}\""
    },
    {
        "number": 1370,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n    S = [list(map(int, stdin.split())) for _ in range(H)]\n\n    def dfs(i, j, k):\n        if k == 0:\n            return 1\n\n        if i == 0 or j == 0:\n            return dfs(i - 1, j, k - 1)\n\n        if S[i - 1][j] == 0 and S[i][j - 1] == 0:\n            return dfs(i - 1, j - 1, k - 1)\n\n        return dfs(i - 1, j, k)\n\n    return str(dfs(H - 1, W - 1, K))\n"
    },
    {
        "number": 1371,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin)\n    MOD = 10**9 + 7\n\n    def is_valid_sequence(sequence):\n        return sum(sequence) == S\n\n    def generate_sequences(n):\n        sequence = [3]\n        for i in range(n - 1):\n            sequence.append(sequence[-1] + 1)\n        return sequence\n\n    sequences = generate_sequences(S)\n    count = 0\n    for sequence in sequences:\n        if is_valid_sequence(sequence):\n            count += 1\n\n    return str(count % MOD)"
    },
    {
        "number": 1372,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, N = map(int, stdin.split())\n    A, B = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    def min_cost(A, B, H, N):\n        dp = [[float('inf')] * (H + 1) for _ in range(N + 1)]\n        dp[0][0] = 0\n\n        for i in range(1, N + 1):\n            for j in range(1, H + 1):\n                if A[i - 1] <= j:\n                    dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - A[i - 1]] + B[i - 1])\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[N][H]\n\n    return str(min_cost(A, B, H, N))"
    },
    {
        "number": 1373,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, N+1):\n        for j in range(i, N+1):\n            if j - i + 1 >= K:\n                count += (j - i + 1) * (j - i + 2) // 2\n    return str(count % MOD)"
    },
    {
        "number": 1374,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    m = []\n    for l in range(N):\n        for r in range(l + 1, N + 1):\n            m.append(median(a[l:r]))\n\n    return str(median(m))\n\ndef"
    },
    {
        "number": 1375,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def count_ways(i, j):\n        if i == j:\n            return 1\n        if i > j:\n            return 0\n\n        return count_ways(i + 1, j) + count_ways(i, j - 1)\n\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sum(a[i:j + 1]) == sum(a[j + 1:]) and count_ways(i, j) > 0:\n                ways += 1\n\n    return str(ways)"
    },
    {
        "number": 1376,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def min_distance(houses: list[int]) -> int:\n        distance = 0\n        for i in range(len(houses) - 1):\n            distance += abs(houses[i] - houses[i + 1])\n        return distance\n\n    def min_distance_helper(houses: list[int], index: int, current_size: int) -> int:\n        if index == len(houses) - 1:\n            return current_size\n\n        if houses[index] == current_size:\n            return min_distance_helper(houses, index + 1, current_size + 1)\n\n        return min(min_distance_helper(houses, index + 1, current_size), min_distance_helper(houses, index + 1, current_size + 1))\n\n    houses = [1] * n\n    min_distance_sasha = min_distance(houses)\n    min_distance_dima = min_distance_helper(houses, 0, 1)\n\n    return str(min(min_distance_sasha, min_distance_dima))\n"
    },
    {
        "number": 1377,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    if len(a)!= n:\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(i - j) == 1 and len(a) == 1 and a.pop() > a[0]:\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1378,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bills_points = list(map(int, stdin.split()[1].split()))\n\n    def area(points):\n        x1, y1 = points[0]\n        x2, y2 = points[1]\n        return 0.5 * abs(x1 * y2 - x2 * y1)\n\n    def convex_hull(points):\n        points.sort(key=lambda x: x[0])\n        hull = [points[0]]\n        for i in range(1, len(points)):\n            if points[i][0]!= hull[-1][0] or points[i][1]!= hull[-1][1]:\n                hull.append(points[i])\n        return hull\n\n    def split_edge(points, index):\n        x1, y1 = points[index]\n        x2, y2 = points[(index + 1) % len(points)]\n        mid_x = (x1 + x2) / 2\n        mid_y = (y1 + y2) / 2\n        return [(x1, y1), (mid_x, mid_y), (x2, y2)]\n\n    def remove_part(points, index):\n        x1, y1 = points[index]\n        x2, y2 = points[(index + 1) % len(points)]\n        mid_x = (x1 + x2) / 2\n        mid_y = (y1 + y2) / 2\n        return [(x1, y1), (mid_x, mid_y), (x2, y2)]\n\n    def max_area(points):\n        hull = convex_hull(points)\n        max_area = 0\n        for i in range(len(hull) - 1):\n            for j in range(i + 1, len(hull)):\n                a = area(hull[i])\n                b = area(hull[j])\n                c = area(hull[i] + hull[j])\n                max_area = max(max_area, a + b - c)\n        return max_area\n\n    def find_points(points):\n        max_area = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a = area(points[i] + points[j] + points[k])\n                    b = area(points[i] + points[k] + points[j])\n                    c = area(points[i] + points[j] + points[k])\n                    max_area = max(max_area, a + b - c)\n        return max_area\n\n    def find_points_with_split(points):\n        max_area = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a = area(points[i] + points[j] + points[k])\n                    b = area(points[i] + points[k] + points[j])\n                    c = area(points[i] + points[j] + points[k])\n                    max_area = max(max_area, a + b - c)\n                    if a + b - c == max_area:\n                        max_area = max(max_area, area(points[i] + points[j]) + area(points[j] + points[k]) - area(points[i] + points[k]))\n        return max_area\n\n    def find_points_with_remove(points):\n        max_area = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                for k in range(j + 1, len(points)):\n                    a = area(points[i] + points[j] + points[k])\n                    b = area(points[i] + points[k] + points[j])\n                    c = area(points[i] + points[j] + points[k])\n                    max_area = max(max_area, a + b - c)\n                    if a + b - c == max_area:\n                        max_area = max(max_area, area(points[i] + points[j]) + area(points[j] + points[k]) - area(points[i] + points[k]))\n                        if a + b - c == max_area:\n                            max_area = max(max_area, area(points[i] + points[j]) + area"
    },
    {
        "number": 1379,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    days = [0] * m\n    for i in range(n):\n        if a[i] % 2 == 0:\n            days[a[i]] += 1\n        else:\n            days[a[i] - 1] += 1\n    min_days = float('inf')\n    for i in range(m):\n        if days[i] > 0:\n            min_days = min(min_days, days[i])\n    return str(min_days) + '\\n' +''.join(map(str, days))"
    },
    {
        "number": 1380,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def can_grow(i, height):\n        return height + 1 - height == k\n\n    def can_shrink(i, height):\n        return height - 1 - height == k\n\n    def can_grow_or_shrink(i, height):\n        return can_grow(i, height) or can_shrink(i, height)\n\n    def min_actions(i, height):\n        if can_grow_or_shrink(i, height):\n            return 1\n        else:\n            return 2\n\n    def min_actions_for_row(row):\n        return min(min_actions(i, row[i]) for i in range(n))\n\n    def min_actions_for_tree(tree):\n        return min_actions_for_row(tree)\n\n    def min_actions_for_trees(trees):\n        return min(min_actions_for_tree(tree) for tree in trees)\n\n    def min_actions_for_garden(trees):\n        return min_actions_for_trees(trees)\n\n    def min_actions_for_queen(trees):\n        return min_actions_for_garden(trees)\n\n    def min_actions_for_royal_garden(trees):\n        return min_actions_for_queen(trees)\n\n    return str(min_actions_for_royal_garden(a))\n"
    },
    {
        "number": 1381,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, s, p = map(int, stdin.split())\n    sheets_per_pack = s // k\n    sheets_left = s % k\n    packs_needed = sheets_per_pack + sheets_left\n\n    return str(packs_needed)"
    },
    {
        "number": 1382,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(u, visited, cycle):\n        visited[u] = True\n        for v in range(n):\n            if not visited[v] and (u, v) not in cycle and (v, u) not in cycle:\n                cycle.append((u, v))\n                dfs(v, visited, cycle)\n                cycle.pop()\n\n    def count_cycles(edges):\n        visited = [False] * n\n        cycles = []\n        for u, v in edges:\n            if not visited[u] and not visited[v]:\n                cycle = [(u, v)]\n                dfs(u, visited, cycle)\n                dfs(v, visited, cycle)\n                cycles.append(cycle)\n        return len(cycles)\n\n    def count_ways(edges, cycles):\n        ways = 1\n        for cycle in cycles:\n            if len(cycle) == 1:\n                continue\n            for i in range(len(cycle) - 1):\n                for j in range(i + 1, len(cycle)):\n                    if (cycle[i], cycle[j]) in edges or (cycle[j], cycle[i]) in edges:\n                        ways *= 2\n        return ways\n\n    t = count_cycles(edges)\n    w = count_ways(edges, [[] for _ in range(t)])\n    return f\"{t} {w}\""
    },
    {
        "number": 1383,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def find_x(a, b):\n        for x in range(m):\n            if all(a[i] + x == b[p[i]] for i in range(n)):\n                return x\n        return -1\n\n    p = list(range(1, n + 1))\n    x = find_x(a, b)\n\n    if x == -1:\n        return \"No solution\"\n\n    for i in range(n):\n        a[i] = (a[i] + x) % m\n\n    return str(x)"
    },
    {
        "number": 1384,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(map(int, stdin.split()[1:]))\n\n    # Remove consecutive zeros\n    i = 0\n    while i < n - 1 and s[i] == 0:\n        i += 1\n    j = i + 1\n    while j < n and s[j] == 0:\n        j += 1\n    s = s[:i] + s[j:]\n\n    # Count consecutive ones\n    count = 0\n    for i in range(n):\n        if s[i] == 1:\n            count += 1\n        else:\n            count = 0\n        if count > 1:\n            break\n\n    return str(count)"
    },
    {
        "number": 1385,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lexemes = []\n    current_lexeme = \"\"\n    in_quotes = False\n    for char in stdin:\n        if char == \"\"\"\":\n            in_quotes = not in_quotes\n        elif char == \" \" and not in_quotes:\n            lexemes.append(current_lexeme)\n            current_lexeme = \"\"\n        else:\n            current_lexeme += char\n    lexemes.append(current_lexeme)\n    return \"\".join([f\"<{lexeme}>\" for lexeme in lexemes])"
    },
    {
        "number": 1386,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    tiles = []\n    for i in range(w):\n        for j in range(h):\n            tiles.append(i % 2 == j % 2)\n    tiles.sort(reverse=True)\n    count = 0\n    for i in range(len(tiles)):\n        for j in range(i + 1, len(tiles)):\n            if tiles[i] == tiles[j]:\n                count += 1\n                break\n    return str(count % 998244353)"
    },
    {
        "number": 1387,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    visited = set()\n    visited.add(1)\n\n    def dfs(cell):\n        if cell == t:\n            return True\n        if cell in visited:\n            return False\n\n        visited.add(cell)\n        for i in range(1, n):\n            if 1 <= a[i - 1] <= n - i:\n                if dfs(cell + a[i - 1]):\n                    return True\n        visited.remove(cell)\n        return False\n\n    return \"YES\" if dfs(1) else \"NO\""
    },
    {
        "number": 1388,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:3])\n        edges.append((u, v))\n\n    def dfs(node, visited, target, cost):\n        if node == target:\n            return cost\n        if node in visited:\n            return float('inf')\n        visited.add(node)\n\n        min_cost = float('inf')\n        for neighbor, weight in edges:\n            if neighbor == node:\n                continue\n            min_cost = min(min_cost, dfs(neighbor, visited, target, cost + weight))\n\n        return min_cost\n\n    target = int(stdin.split()[3])\n    visited = set()\n    return str(dfs(1, visited, target, 0))"
    },
    {
        "number": 1389,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    feature = [list(line.strip()) for line in stdin.split()[1:]]\n    feature = [[1 if c == 'W' else -1 for c in row] for row in feature]\n\n    def prefix_sum(rect):\n        return sum(rect[0][j] * rect[1][j] for j in range(m))\n\n    def prefix_product(rect):\n        return prefix_sum(rect) * rect[0][0]\n\n    def prefix_sum_product(rect):\n        return prefix_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum(rect):\n        return prefix_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product(rect):\n        return prefix_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product(rect):\n        return prefix_sum_product_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product(rect):\n        return prefix_sum_product_sum_product_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect) * prefix_product(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum(rect):\n        return prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product(rect) + prefix_sum(rect)\n\n    def prefix_sum_product_sum_product_sum_product_sum_product_sum_product_sum_product_sum"
    },
    {
        "number": 1390,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n    f.sort(reverse=True)\n    A = f[0]\n    B = f[-1]\n    return str(A - B)"
    },
    {
        "number": 1391,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    def rent_bike(budget, bike_price, bike_count):\n        if bike_count == 0:\n            return 0\n        if budget < bike_price:\n            return -1\n        return 1 + rent_bike(budget - bike_price, bike_price, bike_count - 1)\n\n    def find_max_rent(budget, bike_price, bike_count):\n        if bike_count == 0:\n            return 0\n        if budget < bike_price:\n            return -1\n        return max(find_max_rent(budget, bike_price, bike_count - 1), rent_bike(budget, bike_price, bike_count))\n\n    def find_min_budget(budget, bike_price, bike_count):\n        if bike_count == 0:\n            return 0\n        if budget < bike_price:\n            return -1\n        return min(find_min_budget(budget, bike_price, bike_count - 1), rent_bike(budget, bike_price, bike_count))\n\n    max_rent = find_max_rent(a, 0, n)\n    min_budget = find_min_budget(a, 0, n)\n\n    return f\"{max_rent} {min_budget}\""
    },
    {
        "number": 1392,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    k_good = 0\n    for num in a:\n        if len(set(str(num))) == k + 1:\n            k_good += 1\n\n    return str(k_good)"
    },
    {
        "number": 1393,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n    n = len(s)\n    m = len(t)\n    yay_count = 0\n    whoops_count = 0\n\n    for i in range(n):\n        if s[i] == t[i]:\n            if s[i].isupper():\n                s[i] = s[i].lower()\n                t[i] = t[i].lower()\n            elif s[i].islower():\n                s[i] = s[i].upper()\n                t[i] = t[i].upper()\n            else:\n                continue\n        else:\n            if s[i].isupper():\n                s[i] = s[i].lower()\n            elif s[i].islower():\n                s[i] = s[i].upper()\n            else:\n                continue\n\n        if s[i] == t[i]:\n            yay_count += 1\n        else:\n            whoops_count += 1\n\n    return f\"{yay_count} {whoops_count}\"\n"
    },
    {
        "number": 1394,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.strip()\n    s = \"\"\n    s_prime = \"\"\n    for char in t:\n        if char!= \"a\":\n            s += char\n        else:\n            s_prime += char\n    if s_prime == \"\":\n        return \":(\\n\"\n    else:\n        return s + s_prime"
    },
    {
        "number": 1395,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    integer, m = map(int, stdin.split())\n    min_remainder = float('inf')\n\n    for i in range(1, integer + 1):\n        remainder = i % m\n        if remainder < min_remainder:\n            min_remainder = remainder\n\n    return str(min_remainder)"
    },
    {
        "number": 1396,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    def count_balls(color: int) -> int:\n        count = 0\n        for i in range(n):\n            if colors[i] == color:\n                count += 1\n        return count\n\n    def destroy_balls(color: int) -> int:\n        count = 0\n        for i in range(n):\n            if colors[i] == color:\n                colors[i] = -1\n                count += 1\n        return count\n\n    def find_max_balls() -> int:\n        max_balls = 0\n        for color in range(1, k + 1):\n            balls_of_color = count_balls(color)\n            if balls_of_color >= 3:\n                max_balls = max(max_balls, destroy_balls(color))\n        return max_balls\n\n    return str(find_max_balls())"
    },
    {
        "number": 1397,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    cities.sort()\n    edges = []\n    for i in range(len(cities) - 1):\n        for j in range(i + 1, len(cities)):\n            edges.append((cities[i], cities[j]))\n    edges.sort()\n    edges = list(set(edges))\n    edges.sort()\n    result = []\n    for i in range(len(edges) - 1):\n        for j in range(i + 1, len(edges)):\n            if edges[i][0]!= edges[j][0] and edges[i][1]!= edges[j][1]:\n                result.append(edges[i])\n                result.append(edges[j])\n                break\n    return str(len(result)) + '\\n' + '\\n'.join(map(str, result))"
    },
    {
        "number": 1398,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    c.sort()\n    i = 0\n    while i < n - 1:\n        if c[i] + 2 * c[i + 1] > c[i + 2]:\n            i += 1\n        else:\n            break\n    return str(i + 1)"
    },
    {
        "number": 1399,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        segments.append((x1, y1, x2, y2))\n    points = set()\n    for x, y in segments:\n        for dx in range(x, x + 1000):\n            for dy in range(y, y + 1000):\n                points.add((dx, dy))\n    return str(len(points))"
    },
    {
        "number": 1400,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    def solve(i: int, t_i: int, t_sum: int) -> int:\n        if t_sum >= T:\n            return 1\n        if i == n:\n            return 0\n        if t_sum + t[i] <= T:\n            return solve(i + 1, t_i, t_sum + t[i])\n        return solve(i + 1, t_i + 1, t_sum)\n\n    P = solve(0, 0, 0)\n    Q = 1\n    for i in range(n):\n        Q *= (T - t[i]) // t[i] + 1\n    return str((P * Q) % (10**9 + 7))"
    },
    {
        "number": 1401,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    edges = []\n    for i in range(n - 1):\n        p, c = map(int, stdin.split()[i + 1].split())\n        edges.append((p - 1, c))\n\n    def dist(u, v):\n        return sum(a[u] + a[v] for u, v in edges if u in subtree(v) and v in subtree(u))\n\n    def subtree(v):\n        return {u for u in range(n) if dist(u, v) > a[u]}\n\n    def leaves():\n        return {u for u in range(n) if len(subtree(u)) == 1}\n\n    def remove_leaves(leaves_to_remove):\n        non_leaves = leaves() - leaves_to_remove\n        return {u for u in non_leaves if len(subtree(u)) == 1}\n\n    leaves_to_remove = set()\n    while leaves_to_remove!= leaves():\n        leaves_to_remove = remove_leaves(leaves_to_remove)\n\n    return str(len(leaves_to_remove))\n"
    },
    {
        "number": 1402,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    w = stdin.split()[2]\n\n    def count_ways(s: str, w: str) -> int:\n        dp = [[0] * (len(w) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        for j in range(1, len(w) + 1):\n            dp[0][j] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(w) + 1):\n                if s[i - 1] > w[j - 1]:\n                    dp[i][j] = dp[i - 1][j]\n                else:\n                    dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % 1000000007\n        return dp[len(s)][len(w)]\n\n    ways = count_ways(s, w)\n    return str((ways % 1000000007) % 1000000007)"
    },
    {
        "number": 1403,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def swallow(i: int, j: int) -> bool:\n        return a[i] > a[j] and a[i] <= a[j] + K\n\n    def dfs(i: int, visited: set) -> int:\n        if i in visited:\n            return 0\n\n        visited.add(i)\n        count = 1\n\n        for j in range(n):\n            if swallow(i, j):\n                count += dfs(j, visited)\n\n        return count\n\n    return str(dfs(0, set()))"
    },
    {
        "number": 1404,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def restore_array(a: list) -> int:\n        def is_valid(a: list) -> bool:\n            for i in range(1, len(a) - 1):\n                if a[i] < max(a[i - 1], a[i + 1]):\n                    return False\n            return True\n\n        def restore_helper(a: list, index: int, count: int) -> int:\n            if index == len(a):\n                return count\n            if a[index] == -1:\n                return restore_helper(a, index + 1, count)\n            return restore_helper(a, index + 1, restore_helper(a, index + 1, count) + restore_helper(a, index + 2, count))\n\n        return restore_helper(a, 0, 1)\n\n    return str(restore_array(a)) % 998244353\n"
    },
    {
        "number": 1405,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_fibonacci_ish(a: list) -> bool:\n        if len(a) < 2:\n            return False\n        for i in range(len(a) - 1):\n            if a[i] + 2!= a[i] + 1 + a[i + 1]:\n                return False\n        return True\n\n    def longest_fibonacci_ish_prefix(a: list) -> int:\n        i = 0\n        while i < len(a) - 1 and not is_fibonacci_ish(a[i:i + 2]):\n            i += 1\n        return i\n\n    result = longest_fibonacci_ish_prefix(a)\n    print(result)\n"
    },
    {
        "number": 1406,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    if n > k:\n        return -1\n\n    buses = [[] for _ in range(k + 1)]\n    for _ in range(d):\n        for _ in range(n):\n            bus, student = map(int, stdin.split())\n            buses[bus].append(student)\n\n    for bus in buses:\n        if len(bus) > 1:\n            return -1\n\n    for bus in buses:\n        bus.sort()\n\n    for bus in buses:\n        print(\" \".join(map(str, bus)))\n\n    return \"\"\n"
    },
    {
        "number": 1407,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    prime_rows = []\n    prime_cols = []\n\n    for i in range(n):\n        if all(row[i] == 2 for row in matrix):\n            prime_rows.append(i)\n\n    for j in range(m):\n        if all(matrix[i][j] == 2 for i in range(n)):\n            prime_cols.append(j)\n\n    prime_matrix = [[0] * m for _ in range(n)]\n\n    for i in prime_rows:\n        for j in range(m):\n            prime_matrix[i][j] = 2\n\n    for j in prime_cols:\n        for i in range(n):\n            prime_matrix[i][j] = 2\n\n    prime_count = 0\n    for row in prime_matrix:\n        if all(row[i] == 2 for i in range(m)):\n            prime_count += 1\n\n    return str(prime_count)"
    },
    {
        "number": 1408,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    books = []\n    for i in range(n):\n        thickness, width = map(int, stdin.split()[1:3])\n        books.append((thickness, width))\n    books.sort(key=lambda x: x[0])\n    total_thickness = sum(book[0] for book in books)\n    min_vertical_thickness = 1\n    while total_thickness > 0:\n        min_vertical_thickness += 1\n        total_thickness -= min_vertical_thickness\n    return str(min_vertical_thickness)"
    },
    {
        "number": 1409,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    y = list(map(int, stdin.split()))\n\n    max_teams = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if y[i] >= k and y[j] >= k:\n                max_teams += 1\n                break\n\n    return str(max_teams)"
    },
    {
        "number": 1410,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = [list(map(int, stdin.split()[1:n+1])) for _ in range(3)]\n    edges = [list(map(int, stdin.split()[n+1:2*n+1])) for _ in range(n-1)]\n    \n    def bfs(start: int, colors: List[List[int]]) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        colors[start] = [1, 2, 3]\n        while queue:\n            vertex = queue.popleft()\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbor in edges[vertex-1]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n                        colors[neighbor] = [1, 2, 3]\n        return colors\n    \n    colors = bfs(1, colors)\n    if all(colors[vertex] == colors[vertex+1] for vertex in range(n)):\n        return -1\n    \n    min_cost = float('inf')\n    for i in range(1, 4):\n        for j in range(i+1, 4):\n            for k in range(j+1, 4):\n                if colors[i]!= colors[j] and colors[j]!= colors[k] and colors[i]!= colors[k]:\n                    cost = sum(colors[vertex][i-1] for vertex in range(1, n+1)) + sum(colors[vertex][j-1] for vertex in range(1, n+1)) + sum(colors[vertex][k-1] for vertex in range(1, n+1))\n                    if cost < min_cost:\n                        min_cost = cost\n                        best_colors = [colors[vertex][i-1] for vertex in range(1, n+1)]\n    \n    return str(min_cost) +'' +''.join(map(str, best_colors))"
    },
    {
        "number": 1411,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    pizzas = []\n    for _ in range(n):\n        s1, a1, b1 = map(int, stdin.split())\n        s2, a2, b2 = map(int, stdin.split())\n        pizzas.append((s1, a1, b1, s2, a2, b2))\n\n    def min_pizza_count(pizzas: list) -> int:\n        pizza_counts = [0] * 2\n        for s, a, b, s2, a2, b2 in pizzas:\n            pizza_counts[0] += s\n            pizza_counts[1] += s2\n        return min(pizza_counts)\n\n    def max_happiness(pizzas: list) -> int:\n        total_happiness = 0\n        for s, a, b, s2, a2, b2 in pizzas:\n            total_happiness += a * s + b * s2\n        return total_happiness\n\n    min_pizza_count_list = [min_pizza_count(pizzas[:i] + pizzas[i+1:]) for i in range(n)]\n    max_happiness_list = [max_happiness(pizzas[:i] + pizzas[i+1:]) for i in range(n)]\n\n    return str(max(max_happiness_list))"
    },
    {
        "number": 1412,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    coupons = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        coupons.append((l, r))\n\n    def is_valid(coupon):\n        for product_id, (l, r) in coupons:\n            if l <= coupon <= r:\n                return True\n        return False\n\n    def max_products(coupon):\n        valid_products = set()\n        for product_id, (l, r) in coupons:\n            if l <= coupon <= r:\n                valid_products.add(product_id)\n        return len(valid_products)\n\n    max_products_count = 0\n    max_products_ids = []\n\n    for coupon in range(1, n + 1):\n        if is_valid(coupon):\n            products_count = max_products(coupon)\n            if products_count > max_products_count:\n                max_products_count = products_count\n                max_products_ids = [coupon]\n            elif products_count == max_products_count:\n                max_products_ids.append(coupon)\n\n    return str(max_products_count) + '\\n' +''.join(map(str, max_products_ids))"
    },
    {
        "number": 1413,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    count = 0\n    for i in range(n):\n        for j in range(i + 2, n + 1):\n            substring = s[i:j]\n            if int(substring) % 2 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1414,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [list(row) for row in stdin.splitlines()]\n\n    def find_letter(cell: tuple, letter: str) -> tuple:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return nx, ny\n        return None\n\n    def is_valid_move(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_start(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_end(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_middle(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_corner(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_corner_to_middle(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_middle_to_corner(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and table[nx][ny] == letter:\n                return True\n        return False\n\n    def is_valid_path_from_middle_to_middle(cell: tuple, letter: str) -> bool:\n        x, y = cell\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx"
    },
    {
        "number": 1415,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, x_0, y_0 = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    def move(x, y, dx, dy):\n        return (x + dx, y + dy) if 0 <= x + dx < x and 0 <= y + dy < y else (x, y)\n\n    def is_valid(x, y):\n        return 0 <= x < x_0 and 0 <= y < y_0\n\n    def is_mine(x, y):\n        return (x, y) in mines\n\n    mines = set()\n    tests = 0\n    while True:\n        tests += 1\n        x, y = move(x, y, 0, 1)\n        if is_mine(x, y):\n            return str(tests)\n        if is_valid(x, y):\n            mines.add((x, y))\n        if s[0] == 'L':\n            x, y = move(x, y, -1, 0)\n        elif s[0] == 'R':\n            x, y = move(x, y, 1, 0)\n        elif s[0] == 'U':\n            x, y = move(x, y, 0, -1)\n        elif s[0] == 'D':\n            x, y = move(x, y, 0, 1)\n        s = s[1:]"
    },
    {
        "number": 1416,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def max_water(cups: int) -> int:\n        return w * (cups - 1)\n\n    def max_water_for_friends(cups: int) -> int:\n        return max(max_water(cups), 2 * max_water(cups))\n\n    def max_water_for_cups(cups: int) -> int:\n        return max(max_water_for_friends(cups), max_water(cups))\n\n    def max_water_for_cups_and_friends(cups: int) -> int:\n        return max(max_water_for_cups(cups), max_water_for_friends(cups))\n\n    def max_water_for_cups_and_friends_and_candies(cups: int) -> int:\n        return max(max_water_for_cups_and_friends(cups), max_water_for_friends(cups))\n\n    max_water_for_cups_and_friends_and_candies_list = [max_water_for_cups_and_friends_and_candies(i) for i in range(1, n + 1)]\n    max_water_for_cups_and_friends_and_candies_list.sort(reverse=True)\n\n    return str(max_water_for_cups_and_friends_and_candies_list[0])"
    },
    {
        "number": 1417,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    P = [1] * (n + 1)\n    P[0] = 0\n    P[1] = 1\n    for i in range(2, n + 1):\n        P[i] = P[i - 1] + P[i - 2]\n    mod = 998244353\n    return str((P[n] + P[n - 1]) % mod)"
    },
    {
        "number": 1418,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [1] * (n - 1)\n    for i in range(2, n):\n        a[i - 2] = i\n        for j in range(i + 1, n):\n            if gcd(i, j) == 1:\n                a[i - 2] = j\n                break\n    return \" \".join(map(str, a))\n\n\ndef"
    },
    {
        "number": 1419,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, ad = map(int, stdin.split())\n    words = ad.split()\n    width = 0\n    current_line = []\n    for word in words:\n        if len(current_line) + len(word) + 1 > k:\n            width = max(width, len(current_line))\n            current_line = [word]\n        else:\n            current_line.append(word)\n    width = max(width, len(current_line))\n    return str(width)"
    },
    {
        "number": 1420,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def distance(a, b):\n        return abs(a - b)\n\n    def min_radius(a, b, c):\n        return min(distance(a, b), distance(b, c), distance(c, a))\n\n    min_radius_d = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                d = min_radius(a[i], a[j], a[k])\n                if d < min_radius_d:\n                    min_radius_d = d\n\n    return f\"{min_radius_d:.9f}\"\n"
    },
    {
        "number": 1421,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[i + 2].split())\n        edges.append((u - 1, v - 1))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in range(n):\n            if not visited[v] and edges[u][0] == v:\n                dfs(v, visited)\n\n    def max_sum(u, visited):\n        visited[u] = True\n        max_sum = 0\n        for v in range(n):\n            if not visited[v] and edges[u][0] == v:\n                max_sum = max(max_sum, a[v] + max_sum(v, visited))\n        return max_sum\n\n    visited = [False] * n\n    dfs(0, visited)\n    return str(max_sum(0, visited))"
    },
    {
        "number": 1422,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    weights = [int(x) for x in stdin.split()]\n    m = weights.count(1)\n    if m > 1000:\n        return \"NO\"\n\n    def is_valid(weights: list) -> bool:\n        for i in range(len(weights) - 1):\n            if weights[i] == weights[i + 1]:\n                return False\n        return True\n\n    def is_valid_scale(weights: list, scale: int) -> bool:\n        total_weight = sum(weights)\n        return total_weight > scale\n\n    left_scale = 0\n    right_scale = 0\n    for weight in weights:\n        if weight == 1:\n            left_scale += 1\n        else:\n            right_scale += 1\n\n        if left_scale > right_scale:\n            return \"NO\"\n\n    if is_valid(weights):\n        return \"YES\"\n    else:\n        return \"NO\"\n\n\ndef"
    },
    {
        "number": 1423,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    compressed_c = [0] * n\n    for i in range(n):\n        compressed_c[p[i] - 1] += 1\n\n    for i in range(n):\n        if compressed_c[i] == 0:\n            continue\n        for j in range(i + 1, n):\n            if compressed_c[j] == 0:\n                continue\n            if compressed_c[i] == compressed_c[j]:\n                if a[i] + a[j] == r:\n                    return \" \".join(map(str, a[i:j + 1]))\n\n    return \"-1\"\n"
    },
    {
        "number": 1424,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    armies = [list(map(int, stdin.split())) for _ in range(m + 1)]\n\n    def binary_representation(num: int) -> str:\n        return bin(num)[2:]\n\n    def count_friends(player: int) -> int:\n        friend_count = 0\n        for i in range(m + 1):\n            if i!= player:\n                if binary_representation(armies[i]).count('1')!= binary_representation(armies[player]).count('1'):\n                    friend_count += 1\n        return friend_count\n\n    potential_friends = sum(count_friends(i) for i in range(1, m + 1))\n    return str(potential_friends)"
    },
    {
        "number": 1425,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    arr.sort()\n    left = 0\n    right = n - 1\n    count = 0\n    while left < right:\n        if arr[left] + arr[right] == 2 * arr[count]:\n            count += 1\n            left += 1\n            right -= 1\n        elif arr[left] + arr[right] < 2 * arr[count]:\n            left += 1\n        else:\n            right -= 1\n    if count == n:\n        return \"YES\\n\" + \" \".join(map(str, arr))\n    else:\n        return \"NO\\n\""
    },
    {
        "number": 1426,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    s, t = map(int, stdin.split())\n\n    def bfs(start: int) -> List[int]:\n        visited = set()\n        queue = deque([start])\n        while queue:\n            vertex = queue.popleft()\n            if vertex not in visited:\n                visited.add(vertex)\n                if vertex == t:\n                    return visited\n                for neighbor in edges[vertex - 1]:\n                    if neighbor not in visited:\n                        queue.append(neighbor)\n        return []\n\n    def dfs(start: int, visited: Set[int], count: int) -> int:\n        if start == t:\n            return count\n        visited.add(start)\n        for neighbor in edges[start - 1]:\n            if neighbor not in visited:\n                count = dfs(neighbor, visited, count + 1)\n        return count\n\n    def min_ken_ken_pa(start: int) -> int:\n        visited = set()\n        return dfs(start, visited, 1)\n\n    def can_reach_t(start: int) -> bool:\n        visited = set()\n        return dfs(start, visited, 1)!= 0\n\n    if can_reach_t(s):\n        min_pa = min_ken_ken_pa(s)\n        print(min_pa)\n    else:\n        print(-1)"
    },
    {
        "number": 1427,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = a[i] * b[i - 1]\n    return str((b[n - 1] + 1) % (10**9 + 7))"
    },
    {
        "number": 1428,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    d = [list(map(int, stdin.split())) for _ in range(c)]\n    c = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_good_grid(i, j, x, y):\n        return (i + j) % 3 == (x + y) % 3\n\n    def wrongness(i, j, x, y):\n        if i!= j:\n            return d[i - 1][j - 1]\n        return 0\n\n    def repaint(i, j, x, y, color):\n        nonlocal d, c\n        d[i - 1][j - 1] = wrongness(i, j, x, y)\n        c[i - 1][j - 1] = color\n\n    def min_wrongness(i, j, x, y, color):\n        nonlocal d, c\n        if is_good_grid(i, j, x, y):\n            return wrongness(i, j, x, y)\n        if d[i - 1][j - 1] == 0:\n            repaint(i, j, x, y, color)\n            return wrongness(i, j, x, y)\n        return min(wrongness(i, j, x, y), min_wrongness(i, j, x, y, color))\n\n    min_sum = float('inf')\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for x in range(1, n + 1):\n                for y in range(1, n + 1):\n                    min_sum = min(min_sum, min_wrongness(i, j, x, y, c[i - 1][j - 1]))\n\n    return str(min_sum)\n"
    },
    {
        "number": 1429,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    S = list(S)\n\n    def is_complementary(s1: str, s2: str) -> bool:\n        for i in range(len(s1)):\n            if s1[i]!= s2[i]:\n                return False\n        return True\n\n    def find_complementary(s: str) -> str:\n        complementary = \"\"\n        for i in range(len(s)):\n            complementary += \"AGCT\"[::-1].index(s[i])\n        return complementary\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            T_1 = S[i:j]\n            T_2 = S[j:i]\n            if is_complementary(T_1, T_2):\n                complementary = find_complementary(T_1)\n                if complementary in T_2:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 1430,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = list(stdin.split()[1])\n    max_consecutive_hands = 0\n    for i in range(k):\n        l, r = map(int, stdin.split())\n        s[l - 1], s[r - 1] = s[r - 1], s[l - 1]\n        max_consecutive_hands = max(max_consecutive_hands, count_consecutive_hands(s))\n        s[l - 1], s[r - 1] = s[r - 1], s[l - 1]\n    return str(max_consecutive_hands)\n\ndef"
    },
    {
        "number": 1431,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *a = map(int, stdin.split())\n    a = [a[i - 1] for i in range(1, N + 1)]\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def is_good(a: List[int]) -> bool:\n        total = sum(a)\n        for i in range(1, N + 1):\n            if a[i - 1] == 0:\n                continue\n            if total % i!= 0:\n                return False\n        return True\n\n    def find_good_set() -> List[int]:\n        for i in range(1, N + 1):\n            if a[i - 1] == 0:\n                continue\n            for j in range(i, N + 1):\n                if a[j - 1] == 0:\n                    continue\n                if gcd(i, j) == 1:\n                    a[i - 1] = lcm(a[i - 1], a[j - 1])\n                    a[j - 1] = 0\n                    if is_good(a):\n                        return a\n        return []\n\n    good_set = find_good_set()\n    if not good_set:\n        return \"-1\"\n\n    M = sum(1 for a in good_set if a == 1)\n    balls = [i for i in range(1, N + 1) if good_set[i - 1] == 1]\n    balls.sort()\n    return f\"{M}\\n{balls[0]}\\n{balls[1]}\\n{balls[2]}\"\n"
    },
    {
        "number": 1432,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    rain = [0] * n\n    for i in range(n):\n        rain[i] = a[i] // 2\n\n    for i in range(1, n):\n        rain[i] += rain[i - 1]\n\n    return \" \".join(map(str, rain))"
    },
    {
        "number": 1433,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    plan = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_good(x: int, y: int, direction: str) -> bool:\n        if plan[x][y] == 1:\n            return False\n\n        if direction == \"left\" and x == 0:\n            return False\n\n        if direction == \"right\" and x == n - 1:\n            return False\n\n        if direction == \"up\" and y == 0:\n            return False\n\n        if direction == \"down\" and y == m - 1:\n            return False\n\n        return True\n\n    good_positions = 0\n    for x in range(n):\n        for y in range(m):\n            for direction in [\"left\", \"right\", \"up\", \"down\"]:\n                if is_good(x, y, direction):\n                    good_positions += 1\n\n    return str(good_positions)"
    },
    {
        "number": 1434,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    degrees = [tuple(map(int, stdin.split()[i+1].split())) for i in range(n)]\n    edges = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if degrees[i][0] > degrees[j][0]:\n                edges.append((i, j))\n            elif degrees[i][0] < degrees[j][0]:\n                edges.append((j, i))\n            else:\n                edges.append((i, j))\n    edges.sort()\n    m = len(edges)\n    print(m)\n    for edge in edges:\n        print(edge[0], edge[1])\n    return \"\""
    },
    {
        "number": 1435,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    n = len(str(a))\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a - int(str(a)[i] + str(a)[j]) == 9:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1436,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    events = list(map(int, stdin.split()))\n    count = 0\n    for i in range(len(events)):\n        if events[i] == -1:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 1437,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    MOD = 10**9 + 7\n    def to_num(s: str) -> int:\n        num = 0\n        for c in s:\n            if c.isdigit():\n                num = num * 64 + int(c)\n            elif c.isalpha():\n                num = num * 64 + (ord(c) - ord('A') + 10)\n            else:\n                num = num * 64 + 62\n        return num\n\n    def num_pairs(s: str) -> int:\n        n = len(s)\n        pairs = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if (to_num(s[i:j]) & to_num(s)) == to_num(s):\n                    pairs += 1\n        return pairs\n\n    return str(num_pairs(s))"
    },
    {
        "number": 1438,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def solve(i, j):\n        if i == n:\n            return 1\n        if j == k:\n            return solve(i + 1, 0)\n\n        if a[i] <= b[j]:\n            return solve(i, j + 1) + solve(i + 1, j)\n        else:\n            return solve(i, j + 1)\n\n    return str(solve(0, 0))\n"
    },
    {
        "number": 1439,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_divisible(subsequence: list) -> bool:\n        return sum(subsequence) % m == 0\n\n    def backtrack(start: int, subsequence: list) -> bool:\n        if start == n:\n            return is_divisible(subsequence)\n\n        for i in range(start, n):\n            if is_divisible(subsequence):\n                return True\n\n            if backtrack(i + 1, subsequence + [a[i]]):\n                return True\n\n        return False\n\n    if backtrack(0, []):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1440,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort(reverse=True)\n    count = 0\n    for i in range(n):\n        if a[i] > 0:\n            count += 1\n            a[i] -= 1\n            if a[i] == 0:\n                count -= 1\n    return str(count)"
    },
    {
        "number": 1441,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *throws = map(int, stdin.split())\n    max_throws = max(throws)\n    if max_throws > 2:\n        return \"0\"\n\n    def count_variants(throws: List[int]) -> int:\n        if len(throws) == 1:\n            return 1\n        if len(throws) == 2:\n            return 2\n\n        def count_variants_helper(throws: List[int], index: int, count: int) -> int:\n            if index == len(throws) - 1:\n                return count\n            return count_variants_helper(throws, index + 1, count) + count_variants_helper(throws, index + 2, count)\n\n        return count_variants_helper(throws, 0, 1)\n\n    return str(count_variants(throws) % 1000000007)\n"
    },
    {
        "number": 1442,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    orders = []\n    for _ in range(n):\n        direction, price, volume = map(int, stdin.split())\n        orders.append((direction, price, volume))\n\n    orders.sort(key=lambda x: (-x[1], x[0]))\n    best_buy = []\n    best_sell = []\n    for order in orders:\n        if order[0] == 'B':\n            best_buy.append(order)\n        else:\n            best_sell.append(order)\n        if len(best_buy) == s or len(best_sell) == s:\n            break\n\n    result = []\n    for order in best_buy:\n        result.append(f\"B {order[1]} {order[2]}\")\n    for order in best_sell:\n        result.append(f\"S {order[1]} {order[2]}\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1443,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    terrain = [char for char in stdin.split()]\n\n    def distance(a: int, b: int) -> int:\n        return abs(a - b)\n\n    def time_to_reach(start: int, end: int) -> int:\n        if start == end:\n            return 0\n\n        if terrain[start] == \"G\" and terrain[end] == \"G\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n        if terrain[start] == \"G\" and terrain[end] == \"W\":\n            return time_to_reach(start + 1, end - 1) + 3\n\n        if terrain[start] == \"G\" and terrain[end] == \"L\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n        if terrain[start] == \"W\" and terrain[end] == \"G\":\n            return time_to_reach(start + 1, end - 1) + 3\n\n        if terrain[start] == \"W\" and terrain[end] == \"W\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n        if terrain[start] == \"W\" and terrain[end] == \"L\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n        if terrain[start] == \"L\" and terrain[end] == \"G\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n        if terrain[start] == \"L\" and terrain[end] == \"W\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n        if terrain[start] == \"L\" and terrain[end] == \"L\":\n            return time_to_reach(start + 1, end - 1) + 1\n\n    def min_time(start: int, end: int) -> int:\n        if start == end:\n            return 0\n\n        if terrain[start] == \"G\" and terrain[end] == \"G\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"G\" and terrain[end] == \"W\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"G\" and terrain[end] == \"L\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"W\" and terrain[end] == \"G\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"W\" and terrain[end] == \"W\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"W\" and terrain[end] == \"L\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"L\" and terrain[end] == \"G\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"L\" and terrain[end] == \"W\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n        if terrain[start] == \"L\" and terrain[end] == \"L\":\n            return min(time_to_reach(start + 1, end - 1), min_time(start + 1, end - 1))\n\n    return str(min_time(0, n - 1))\n"
    },
    {
        "number": 1444,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, x2 = map(int, stdin.split())\n    x = [x1, x2]\n    k = n - 1\n    x.extend(sorted(set(x) - set(x[:k])))\n    x.sort()\n    return \" \".join(map(str, x[:k]))"
    },
    {
        "number": 1445,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *cubes = map(int, stdin.split())\n    cubes.sort()\n    return \" \".join(map(str, cubes))"
    },
    {
        "number": 1446,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    d = [[0] * k for _ in range(k)]\n\n    for i in range(k):\n        d[i][i] = c[i]\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            for u, v, x in m:\n                if u == i + 1 and v == j + 1:\n                    d[i][j] = min(d[i][j], d[i][u - 1] + d[u - 1][j] + x)\n                elif u == j + 1 and v == i + 1:\n                    d[i][j] = min(d[i][j], d[i][u - 1] + d[u - 1][j] + x)\n\n    for i in range(k):\n        for j in range(k):\n            if d[i][j] == 0:\n                print(0, end=' ')\n            else:\n                print(d[i][j], end=' ')\n        print()\n\n    return 'Yes' if all(d[i][j] == 0 for i in range(k) for j in range(k)) else 'No'\n"
    },
    {
        "number": 1447,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    decks = []\n    for _ in range(m):\n        deck = list(map(int, input().split()))\n        decks.append(deck)\n\n    def shuffle_deck(deck):\n        for i in range(len(deck) - 1, 0, -1):\n            j = random.randint(0, i)\n            deck[i], deck[j] = deck[j], deck[i]\n\n    def pull_card(deck):\n        return deck.pop(0)\n\n    def check_trick(deck, memorized_card):\n        pulled_card = pull_card(deck)\n        return pulled_card == memorized_card\n\n    def probability_of_success(decks, memorized_card):\n        total_cards = sum(len(deck) for deck in decks)\n        shuffled_decks = [deck.copy() for deck in decks]\n        shuffle_deck(shuffled_decks[0])\n        shuffled_decks[1].pop(0)\n        shuffled_decks[2].pop(0)\n        shuffled_decks[3].pop(0)\n\n        success_count = 0\n        for deck in shuffled_decks:\n            if check_trick(deck, memorized_card):\n                success_count += 1\n\n        return success_count / total_cards\n\n    memorized_card = random.choice(decks[0])\n    probability = probability_of_success(decks, memorized_card)\n    return f\"{probability:.6f}\""
    },
    {
        "number": 1448,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    grasshoppers = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        grasshoppers.append((x, y))\n\n    inside = set()\n    for x, y in grasshoppers:\n        if 0 <= x <= n and 0 <= y <= n:\n            inside.add((x, y))\n\n    for x, y in inside:\n        if x == 0 or x == n or y == 0 or y == n:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 1449,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = [0] * n\n        for i in range(n):\n            b[i] = a[i]\n            for j in range(i):\n                b[i] += b[j]\n            b[i] %= k\n        b.sort()\n        m = 0\n        for i in range(n):\n            if b[i]!= 0:\n                m += 1\n        if m == 0:\n            print(-1)\n        else:\n            print(m)"
    },
    {
        "number": 1450,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == '0' and s[j] == '1':\n                s = s[:i] + '1' + s[i + 1:] + s[j] + s[i] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:] + s[j + 1:] + s[i + 1:]"
    },
    {
        "number": 1451,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    \n    count = 0\n    for num in a:\n        if len(str(num)) <= k:\n            count += 1\n            \n    return str(count)"
    },
    {
        "number": 1452,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    r = list(map(int, stdin.split()[1].split()))\n    c = list(map(int, stdin.split()[2].split()))\n\n    def dfs(i, j, r_i, c_j, memo):\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        if r_i == 0:\n            memo[(i, j)] = 1\n            return 1\n\n        if c_j == 0:\n            memo[(i, j)] = 1\n            return 1\n\n        memo[(i, j)] = (dfs(i, j - 1, r_i, c_j, memo) + dfs(i - 1, j, r_i - 1, c_j, memo)) % (1000000007 * (10 ** 9 + 7))\n        return memo[(i, j)]\n\n    memo = {}\n    result = dfs(0, 0, r[0], c[0], memo)\n    return str(result)"
    },
    {
        "number": 1453,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    k = 0\n    total_penalty = 0\n    for i in range(n):\n        if k == 0:\n            total_penalty += a[i]\n            k += 1\n        else:\n            total_penalty += a[i] * (i + 1)\n            k -= 1\n            if k == 0:\n                total_penalty += a[i]\n                k += 1\n    return \" \".join(map(str, total_penalty))"
    },
    {
        "number": 1454,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, stdin.split())))\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 0:\n                a[i][j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 0:\n                for k in range(i, n):\n                    if a[k][j] > a[i][j]:\n                        a[k][j] = a[i][j] + 1\n\n    for j in range(m):\n        for i in range(n):\n            if a[i][j] == 0:\n                for k in range(j, m):\n                    if a[i][k] > a[i][j]:\n                        a[i][k] = a[i][j] + 1\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > 0:\n                max_sum += a[i][j]\n\n    return str(max_sum) if max_sum > 0 else \"-1\"\n"
    },
    {
        "number": 1455,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pieces = []\n    for _ in range(n):\n        pieces.append(list(map(int, stdin.split()[1].split())))\n    pieces.sort(key=lambda x: (x[0], x[1]))\n    m = 1\n    while True:\n        board = [[0] * m for _ in range(m)]\n        for piece in pieces:\n            if board[piece[0] - 1][piece[1] - 1] == 1:\n                return \"No solution\"\n            board[piece[0] - 1][piece[1] - 1] = 1\n        m += 1"
    },
    {
        "number": 1456,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    board = [list(row) for row in stdin.split()[1:]]\n    pieces = []\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                pieces.append((i, j))\n\n    def is_attacked(x, y, dx, dy):\n        return 0 <= x + dx < n and 0 <= y + dy < n and board[x + dx][y + dy] == 'x'\n\n    def restore_moves(piece):\n        moves = set()\n        for x, y in pieces:\n            for dx, dy in piece:\n                if is_attacked(x, y, dx, dy):\n                    moves.add((x, y, dx, dy))\n        return moves\n\n    def find_moves(piece):\n        moves = set()\n        for x, y in pieces:\n            for dx, dy in piece:\n                if is_attacked(x, y, dx, dy):\n                    moves.add((x, y, dx, dy))\n        return moves\n\n    def print_board(board):\n        for row in board:\n            print(''.join(row))\n\n    def print_moves(moves):\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        for x, y, dx, dy in moves:\n            board[x][y] = 'x'\n            board[x + dx][y + dy] = 'x'\n        print_board(board)\n\n    def print_moves_with_piece(piece):\n        moves = find_moves(piece)\n        if not moves:\n            print('NO')\n        else:\n            print('YES')\n            print_moves(moves)\n\n    for piece in pieces:\n        print_moves_with_piece(piece)\n\n    return ''\n"
    },
    {
        "number": 1457,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ai_name, phone_name = stdin.split()\n    ai_name = ai_name.replace(\"i\", \"1\")\n    ai_name = ai_name.replace(\"l\", \"0\")\n    ai_name = ai_name.replace(\"e\", \"3\")\n    ai_name = ai_name.replace(\"c\", \"2\")\n    ai_name = ai_name.replace(\"t\", \"7\")\n    ai_name = ai_name.replace(\"h\", \"8\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_name = ai_name.replace(\"g\", \"6\")\n    ai_name = ai_name.replace(\"o\", \"0\")\n    ai_"
    },
    {
        "number": 1458,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def reverse_substring(l: int, r: int) -> str:\n        return s[r - 1:l - 1:-1]\n\n    def is_lexicographically_less(s1: str, s2: str) -> bool:\n        if s1 == s2:\n            return False\n        min_length = min(len(s1), len(s2))\n        for i in range(min_length):\n            if s1[i] < s2[i]:\n                return True\n            elif s1[i] > s2[i]:\n                return False\n        return len(s1) < len(s2)\n\n    for l in range(n):\n        for r in range(l + 1, n + 1):\n            if is_lexicographically_less(reverse_substring(l, r), s[l:r]):\n                return \"YES\", f\"{l + 1} {r}\"\n\n    return \"NO\"\n"
    },
    {
        "number": 1459,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *distances = map(int, stdin.split())\n    s, t = map(int, stdin.split())\n\n    distances = [0] + distances\n    distances[n] = 0\n\n    min_distance = float('inf')\n    current_station = 0\n\n    for i in range(n):\n        current_distance = distances[i] + distances[i + 1]\n        if current_station == s - 1:\n            min_distance = min(min_distance, current_distance)\n        elif current_station == t - 1:\n            min_distance = min(min_distance, current_distance)\n        current_station = i\n\n    return str(min_distance)"
    },
    {
        "number": 1460,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 0\n    while k < n:\n        k += 1\n        for i in range(k):\n            for j in range(k):\n                if i == j:\n                    print(f\"{i} {j}\")\n                else:\n                    print(f\"{i} {j}\")\n    return \"\""
    },
    {
        "number": 1461,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    f = list(map(int, stdin.split()[1:]))\n    w = list(map(int, stdin.split()[2:]))\n\n    s = [0] * n\n    m = [float('inf')] * n\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[i] += w[i]\n            m[i] = min(m[i], w[i])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[i]\n            m[f[i] + j] = min(m[f[i] + j], w[i])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w[f[i] + j]\n            m[f[i] + j] = min(m[f[i] + j], w[f[i] + j])\n\n    for i in range(n):\n        for j in range(f[i]):\n            s[f[i] + j] += w"
    },
    {
        "number": 1462,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = stdin.split()[1:]\n    coins = [0] * 26\n    for card in cards:\n        for letter in card:\n            coins[ord(letter) - ord('A')] += 1\n    max_coins = 0\n    for i in range(k):\n        max_coins += sum(coins[ord(letter) - ord('A')] for letter in cards[i])\n    return str(max_coins)"
    },
    {
        "number": 1463,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    good = True\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j]!= 1:\n                for s in range(n):\n                    for t in range(n):\n                        if s!= i and t!= j and grid[i][j] == grid[s][t]:\n                            good = False\n                            break\n                if not good:\n                    break\n\n    return \"Yes\" if good else \"No\""
    },
    {
        "number": 1464,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    titles = stdin.split()[1:]\n    min_title = min(titles, key=lambda x: x.replace(\" \", \"\"))\n    min_title = min_title.replace(\" \", \"\")\n    min_title = min_title.replace(\"'\", \"\")\n    min_title = min_title.replace(\"(\", \"\")\n    min_title = min_title.replace(\")\", \"\")\n    min_title = min_title.replace(\",\", \"\")\n    min_title = min_title.replace(\".\", \"\")\n    min_title = min_title.replace(\"?\", \"\")\n    min_title = min_title.replace(\"!\", \"\")\n    min_title = min_title.replace(\":\", \"\")\n    min_title = min_title.replace(\";\", \"\")\n    min_title = min_title.replace(\"-\", \"\")\n    min_title = min_title.replace(\"_\", \"\")\n    min_title = min_title.replace(\"'\", \"\")\n    min_title = min_title.replace(\"\\\"\", \"\")\n    min_title = min_title.replace(\"/\", \"\")\n    min_title = min_title.replace(\"\\\\\", \"\")\n    min_title = min_title.replace(\"`\", \"\")\n    min_title = min_title.replace(\"~\", \"\")\n    min_title = min_title.replace(\"[\", \"\")\n    min_title = min_title.replace(\"]\", \"\")\n    min_title = min_title.replace(\"{\", \"\")\n    min_title = min_title.replace(\"}\", \"\")\n    min_title = min_title.replace(\"|\", \"\")\n    min_title = min_title.replace(\"=\", \"\")\n    min_title = min_title.replace(\"+\", \"\")\n    min_title = min_title.replace(\"*\", \"\")\n    min_title = min_title.replace(\"%\", \"\")\n    min_title = min_title.replace(\"#\", \"\")\n    min_title = min_title.replace(\"$\", \"\")\n    min_title = min_title.replace(\"^\", \"\")\n    min_title = min_title.replace(\"&\", \"\")\n    min_title = min_title.replace(\"(\", \"\")\n    min_title = min_title.replace(\")\", \"\")\n    min_title = min_title.replace(\"<\", \"\")\n    min_title = min_title.replace(\">\", \"\")\n    min_title = min_title.replace(\"'\", \"\")\n    min_title = min_title.replace(\"\\\"\", \"\")\n    min_title = min_title.replace(\"/\", \"\")\n    min_title = min_title.replace(\"\\\\\", \"\")\n    min_title = min_title.replace(\"`\", \"\")\n    min_title = min_title.replace(\"~\", \"\")\n    min_title = min_title.replace(\"[\", \"\")\n    min_title = min_title.replace(\"]\", \"\")\n    min_title = min_title.replace(\"{\", \"\")\n    min_title = min_title.replace(\"}\", \"\")\n    min_title = min_title.replace(\"|\", \"\")\n    min_title = min_title.replace(\"=\", \"\")\n    min_title = min_title.replace(\"+\", \"\")\n    min_title = min_title.replace(\"*\", \"\")\n    min_title = min_title.replace(\"%\", \"\")\n    min_title = min_title.replace(\"#\", \"\")\n    min_title = min_title.replace(\"$\", \"\")\n    min_title = min_title.replace(\"^\", \"\")\n    min_title = min_title.replace(\"&\", \"\")\n    min_title = min_title.replace(\"(\", \"\")\n    min_title = min_title.replace(\")\", \"\")\n    min_title = min_title.replace(\"<\", \"\")\n    min_title = min_title.replace(\">\", \"\")\n    min_title = min_title.replace(\"'\", \"\")\n    min_title = min_title.replace(\"\\\"\", \"\")\n    min_title = min_title.replace(\"/\", \"\")\n    min_title = min_title.replace(\"\\\\\", \"\")\n    min_title = min_title.replace(\"`\", \"\")\n    min_title = min_title.replace(\"~\", \"\")\n    min_title = min_title.replace(\"[\", \"\")\n    min_title = min_title.replace(\"]\", \"\")\n    min_title = min_title.replace(\"{\", \"\")\n    min_title = min_title.replace(\"}\", \"\")\n    min_title = min_title.replace(\"|\", \"\")\n    min_title = min_title.replace(\"=\", \"\")\n    min_title = min_title.replace(\"+\", \"\")\n    min_title = min_title.replace(\"*\", \"\")\n    min_title = min_title.replace(\"%\", \"\")\n    min_title = min_title.replace(\"#\", \"\")\n    min_title = min_title.replace(\"$\", \"\")\n    min_title = min_title.replace(\"^"
    },
    {
        "number": 1465,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    children = list(stdin.strip())\n    left_turns = 0\n    right_turns = 0\n    for i in range(k):\n        if children[i] == 'L':\n            left_turns += 1\n        else:\n            right_turns += 1\n        if i < k - 1:\n            children[i] = 'R' if children[i] == 'L' else 'L'\n    if left_turns == 0:\n        return -1\n    result = []\n    for i in range(n):\n        if children[i] == 'L':\n            result.append(left_turns)\n            left_turns = 0\n        else:\n            result.append(right_turns)\n            right_turns = 0\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1466,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for x, y, w in map(lambda x: list(map(int, x.split())), stdin.split()[1:]):\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n\n    def bellman_ford(start: int) -> int:\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        for _ in range(m):\n            for v in range(1, n + 1):\n                for u, w in graph[v]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist[n]\n\n    def max_good_vertices(start: int) -> int:\n        dist = bellman_ford(start)\n        good_vertices = 0\n        for v in range(1, n + 1):\n            if dist[v] == float('inf'):\n                good_vertices += 1\n        return good_vertices\n\n    max_good_vertices_start = max(1, start - k)\n    max_good_vertices_end = min(n, start + k)\n    max_good_vertices_result = max_good_vertices(max_good_vertices_start)\n\n    for start in range(max_good_vertices_start, max_good_vertices_end + 1):\n        result = max_good_vertices(start)\n        if result > max_good_vertices_result:\n            max_good_vertices_result = result\n            max_good_vertices_start = start\n            max_good_vertices_end = start + k\n\n    return f\"{max_good_vertices_end - max_good_vertices_start + 1}\\n\" + \"\\n\".join(map(str, range(max_good_vertices_start, max_good_vertices_end + 1)))"
    },
    {
        "number": 1467,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(a: list) -> bool:\n        xor = 0\n        for i in range(len(a)):\n            xor ^= a[i]\n        return xor == 0\n\n    def divide(a: list, k: int) -> int:\n        if k == 1:\n            return 1\n        if k == 2:\n            return 2\n\n        max_count = 0\n        for i in range(1, len(a) + 1):\n            count = divide(a[:i], k - 1)\n            max_count = max(max_count, count)\n\n        return max_count\n\n    max_count = divide(a, 3)\n    if max_count == 0:\n        return -1\n    return str(max_count)"
    },
    {
        "number": 1468,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    hashtags = stdin.split()[1:]\n\n    def delete_suffix(hashtag: str) -> str:\n        suffix = hashtag[1:]\n        if len(suffix) == 0:\n            return '#'\n        return hashtag[:1] + delete_suffix(suffix)\n\n    def min_deleted_symbols(hashtag: str) -> int:\n        deleted_symbols = 0\n        for i in range(1, len(hashtag)):\n            if hashtag[i]!= hashtag[i - 1]:\n                deleted_symbols += 1\n        return deleted_symbols\n\n    def is_valid_hashtag(hashtag: str) -> bool:\n        return hashtag[0] == '#' and len(hashtag) > 1\n\n    def is_valid_solution(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_sorted_hashtag(hashtag: str) -> bool:\n        for i in range(len(hashtag) - 1):\n            if hashtag[i] > hashtag[i + 1]:\n                return False\n        return True\n\n    def is_valid_sorted_solution(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution(hashtag: str, deleted_symbols: int) -> bool:\n        return is_valid_sorted_hashtag(hashtag) and deleted_symbols >= min_deleted_symbols(hashtag)\n\n    def is_valid_solution_for_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and_sorted_solution_and_sorted_hashtag_and"
    },
    {
        "number": 1469,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.strip())\n    if L < 2 or L > 10**6:\n        return \"Invalid input\"\n\n    n = 2 * L\n    m = L * (L - 1) // 2\n\n    edges = []\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            edges.append((i, j, L))\n\n    edges.sort(key=lambda x: (x[0], x[1]))\n\n    print(n, m)\n    for edge in edges:\n        print(edge[0], edge[1], edge[2])\n\n    return \"\"\n"
    },
    {
        "number": 1470,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 1 or x > 10**15:\n        return \"Invalid input\"\n\n    def rotate_die(side: int, direction: str) -> int:\n        if direction == \"left\":\n            return (side + 3) % 6\n        elif direction == \"right\":\n            return (side - 1) % 6\n        elif direction == \"front\":\n            return (side + 2) % 6\n        elif direction == \"back\":\n            return (side - 2) % 6\n        else:\n            return side\n\n    def get_y_points(side: int) -> int:\n        if side == 1:\n            return 1\n        elif side == 5:\n            return 2\n        elif side == 4:\n            return 3\n        elif side == 3:\n            return 4\n        elif side == 2:\n            return 5\n        elif side == 6:\n            return 6\n        else:\n            return 0\n\n    def get_min_operations(x: int) -> int:\n        min_operations = 0\n        current_x = 1\n        current_y = 1\n\n        while current_x < x:\n            current_side = rotate_die(current_side, \"left\")\n            current_y = get_y_points(current_side)\n            current_x += current_y\n\n        return min_operations\n\n    current_side = 1\n    min_operations = get_min_operations(x)\n    print(min_operations)\n\n    return \"Valid input\"\n"
    },
    {
        "number": 1471,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        u, v, w = map(int, stdin.split()[1:4])\n        edges.append((u, v, w))\n    edges.append((n, 1, 0))\n\n    def bfs(start: int, color: int) -> int:\n        queue = [(start, color)]\n        visited = set()\n        while queue:\n            u, c = queue.pop(0)\n            if u not in visited:\n                visited.add(u)\n                if c == 0:\n                    return u\n                for v, w in edges:\n                    if v == u:\n                        continue\n                    if (u, v) not in visited and (v, u) not in visited:\n                        queue.append((v, 1 - c))\n        return -1\n\n    white_color = bfs(1, 0)\n    black_color = bfs(1, 1)\n\n    if white_color == -1 or black_color == -1:\n        return \"IMPOSSIBLE\"\n\n    coloring = [0] * n\n    coloring[white_color - 1] = 0\n    coloring[black_color - 1] = 1\n\n    return \"\\n\".join(map(str, coloring))\n"
    },
    {
        "number": 1472,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n\n    for i in range(n - 1):\n        graph[i + 1].append(i + 2)\n        graph[i + 2].append(i + 1)\n\n    graph[x].append(y)\n    graph[y].append(x)\n\n    distances = [float('inf')] * (n + 1)\n    distances[x] = 0\n\n    for _ in range(n):\n        min_distance = float('inf')\n        min_index = -1\n\n        for i in range(1, n + 1):\n            if distances[i] < min_distance:\n                min_distance = distances[i]\n                min_index = i\n\n        if min_index == -1:\n            break\n\n        for neighbor in graph[min_index]:\n            distances[neighbor] = min(distances[neighbor], distances[min_index] + 1)\n\n    pairs = []\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if distances[i] + 1 == distances[j]:\n                pairs.append((i, j))\n\n    pairs.sort(key=lambda x: (distances[x[0]], distances[x[1]]))\n\n    result = []\n\n    for k in range(1, n + 1):\n        count = 0\n\n        for pair in pairs:\n            if pair[0] == k or pair[1] == k:\n                count += 1\n\n        result.append(count)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1473,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    queue = []\n    for a, b in pairs:\n        if a == 0:\n            queue.append(b)\n        elif b == 0:\n            queue.append(a)\n        else:\n            queue.append(a)\n            queue.append(b)\n    return''.join(map(str, queue))"
    },
    {
        "number": 1474,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *h = map(int, stdin.split())\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i - 1] for i in range(1, len(h))]\n    h.sort()\n    h = [0] + h\n    h.sort()\n    h = [0] + [h[i] - h[i -"
    },
    {
        "number": 1475,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def count_ways(block: list, index: int, count: int) -> int:\n        if index == len(block):\n            return 1 if count == k else 0\n\n        ways = 0\n        for i in range(len(block)):\n            if i!= index:\n                ways += count_ways(block, index + 1, count + 1)\n\n        return ways\n\n    ways = 0\n    for block in a:\n        ways += count_ways(block, 0, 0)\n\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 1476,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = list(range(1, n + 1))\n    students.sort()\n    k = 1\n    while k < n:\n        if students[k] - students[k - 1] == 1:\n            students.pop(k)\n            k -= 1\n        else:\n            k += 1\n    return str(k) +'' +''.join(map(str, students))"
    },
    {
        "number": 1477,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges[a].append(b)\n        edges[b].append(a)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in edges[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    def bfs(node, visited):\n        queue = [node]\n        visited.add(node)\n        while queue:\n            current = queue.pop(0)\n            for neighbor in edges[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n\n    def count_coprocessor_calls(tasks):\n        visited = set()\n        for task in tasks:\n            if task not in visited:\n                dfs(task, visited)\n        return len(visited)\n\n    def count_main_processor_calls(tasks):\n        visited = set()\n        for task in tasks:\n            if task not in visited:\n                bfs(task, visited)\n        return len(visited)\n\n    def is_coprocessor_task(task):\n        return edges[task] == [0]\n\n    def is_main_processor_task(task):\n        return edges[task] == [1]\n\n    def is_coprocessor_task_in_set(task, set_tasks):\n        return task in set_tasks and is_coprocessor_task(task)\n\n    def is_main_processor_task_in_set(task, set_tasks):\n        return task in set_tasks and is_main_processor_task(task)\n\n    def is_task_in_set(task, set_tasks):\n        return task in set_tasks\n\n    def is_task_completed(task):\n        return edges[task] == [0]\n\n    def is_task_completed_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed(task)\n\n    def is_task_completed_on_coprocessor(task):\n        return edges[task] == [1]\n\n    def is_task_completed_on_coprocessor_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed_on_coprocessor(task)\n\n    def is_task_completed_on_main_processor(task):\n        return edges[task] == [0]\n\n    def is_task_completed_on_main_processor_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed_on_main_processor(task)\n\n    def is_task_completed_on_coprocessor_and_main_processor(task):\n        return edges[task] == [1]\n\n    def is_task_completed_on_coprocessor_and_main_processor_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed_on_coprocessor_and_main_processor(task)\n\n    def is_task_completed_on_coprocessor_or_main_processor(task):\n        return edges[task] == [1]\n\n    def is_task_completed_on_coprocessor_or_main_processor_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed_on_coprocessor_or_main_processor(task)\n\n    def is_task_completed_on_coprocessor_and_main_processor_or_main_processor(task):\n        return edges[task] == [1]\n\n    def is_task_completed_on_coprocessor_and_main_processor_or_main_processor_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed_on_coprocessor_and_main_processor_or_main_processor(task)\n\n    def is_task_completed_on_coprocessor_or_main_processor_and_main_processor(task):\n        return edges[task] == [1]\n\n    def is_task_completed_on_coprocessor_or_main_processor_and_main_processor_in_set(task, set_tasks):\n        return task in set_tasks and is_task_completed_on_coprocessor_or_main_processor_and_main_processor(task)\n\n    def is_task_completed_on_coprocessor_and_main_processor_or_main_processor_and_main_processor(task):\n        return edges[task] == [1]\n\n    def is_task_completed_on_co"
    },
    {
        "number": 1478,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    comments = stdin.split(',')\n    max_depth = max(len(comment.split(',')) for comment in comments)\n    for i in range(max_depth):\n        for comment in comments:\n            if len(comment.split(',')) == i + 1:\n                print(comment.split(',')[0])"
    },
    {
        "number": 1479,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    park = [list(row) for row in stdin.split('\\n')[1:]]\n    spiders = [(i, j) for i in range(n) for j in range(m) if park[i][j] == 'L']\n    spider_count = [0] * k\n\n    def bfs(start: tuple, visited: set) -> int:\n        queue = [(start, 0)]\n        visited.add(start)\n        while queue:\n            cell, time = queue.pop(0)\n            if cell[0] == 0:\n                return time\n            for direction in ['L', 'R', 'U', 'D']:\n                neighbor = (cell[0] + (1 if direction == 'U' else 0), cell[1] + (1 if direction == 'R' else 0))\n                if neighbor not in visited and park[neighbor[0]][neighbor[1]] == '.':\n                    visited.add(neighbor)\n                    queue.append((neighbor, time + 1))\n        return -1\n\n    for spider in spiders:\n        spider_count[bfs(spider, set())] += 1\n\n    return''.join(map(str, spider_count))"
    },
    {
        "number": 1480,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    leader = 0\n    count = 0\n    for i in range(k):\n        count += a[leader]\n        leader = (leader + 1) % n\n    return \" \".join(map(str, count))"
    },
    {
        "number": 1481,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    board = [list(line.strip()) for line in stdin.split()[1:]]\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'o':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'x'\n                else:\n                    board[i][j] = 'o'\n\n    for row in board:\n        print(''.join(row))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'x':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'x':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'o'\n                else:\n                    board[i][j] = 'x'\n\n    for row in board:\n        print(''.join(row))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'o':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'x'\n                else:\n                    board[i][j] = 'o'\n\n    for row in board:\n        print(''.join(row))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'x':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'x':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'o'\n                else:\n                    board[i][j] = 'x'\n\n    for row in board:\n        print(''.join(row))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'o':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'x'\n                else:\n                    board[i][j] = 'o'\n\n    for row in board:\n        print(''.join(row))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'x':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'x':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'o'\n                else:\n                    board[i][j] = 'x'\n\n    for row in board:\n        print(''.join(row))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'o':\n                count = 0\n                for k in range(-1, 2):\n                    for l in range(-1, 2):\n                        if 0 <= i + k < n and 0 <= j + l < n and board[i + k][j + l] == 'o':\n                            count += 1\n                if count % 2 == 0:\n                    board[i][j] = 'x'\n                else:\n                    board[i][j] = 'o'\n\n    for row in board:\n       "
    },
    {
        "number": 1482,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(start, visited):\n        if len(visited) == n:\n            return True\n\n        for i in range(start, n * k + 1):\n            if i not in visited and a[i - 1] == i:\n                visited.add(i)\n                if dfs(i + 1, visited):\n                    return True\n                visited.remove(i)\n\n        return False\n\n    visited = set()\n    for i in range(1, n * k + 1):\n        if i not in visited and a[i - 1] == i:\n            visited.add(i)\n            if dfs(i + 1, visited):\n                break\n            visited.remove(i)\n\n    return \" \".join(map(str, visited))\n"
    },
    {
        "number": 1483,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    a = 1\n    for i in range(n):\n        if p[i] == a:\n            a = (a + 1) % n\n    return \" \".join(map(str, p))"
    },
    {
        "number": 1484,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_bad(b: list) -> bool:\n        for i in range(len(b) - 1):\n            if b[i] == b[i + 1]:\n                return True\n        return False\n\n    def replace_with_odd_length_subarray(b: list) -> list:\n        for i in range(len(b) - 1):\n            if b[i] == b[i + 1]:\n                return [b[i]]\n        return []\n\n    def replace_with_odd_length_subarray_count(b: list) -> int:\n        count = 0\n        for i in range(len(b) - 1):\n            if b[i] == b[i + 1]:\n                count += 1\n        return count\n\n    def replace_with_odd_length_subarray_count_helper(b: list, count: int) -> int:\n        if count == 0:\n            return 1\n        if count % 2 == 0:\n            return 0\n        if b[0] == b[-1]:\n            return replace_with_odd_length_subarray_count_helper(b[1:], count - 1)\n        return replace_with_odd_length_subarray_count_helper(b[1:], count)\n\n    def replace_with_odd_length_subarray_count_helper_mod(b: list, count: int) -> int:\n        return (replace_with_odd_length_subarray_count_helper(b, count) + 998244353) % 998244353\n\n    good_arrays = 0\n    for i in range(n):\n        if a[i] == -1:\n            b = a[:i] + a[i + 1:]\n            if not is_bad(b):\n                good_arrays += 1\n\n    for i in range(n):\n        if a[i] == -1:\n            b = a[:i] + a[i + 1:]\n            if is_bad(b):\n                good_arrays += replace_with_odd_length_subarray_count_helper_mod(b, replace_with_odd_length_subarray_count(b))\n\n    return str(good_arrays)"
    },
    {
        "number": 1485,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def paint_card(horse, card):\n        if horse == 0:\n            return (card[0] + 1, card[1] + 1)\n        elif horse == 1:\n            return (card[0] + 1, card[1])\n        else:\n            return ((card[0] + 1) // 2, (card[1] + 1) // 2)\n\n    def count_ways(horse, cards):\n        if horse == 0:\n            return 1\n        elif horse == 1:\n            return sum(1 for card in cards if card[0] % 2 == 0 and card[1] % 2 == 0)\n        else:\n            return sum(1 for card in cards if card[0] % 2 == 1 and card[1] % 2 == 1)\n\n    ways = 0\n    for i in range(1, m + 1):\n        for j in range(i, m + 1):\n            for k in range(j, m + 1):\n                if count_ways(0, [(a[0], i), (a[0], j), (a[0], k)]) == 1:\n                    ways += count_ways(1, [(a[0], i), (a[0], j), (a[0], k)])\n                if count_ways(1, [(a[0], i), (a[0], j), (a[0], k)]) == 1:\n                    ways += count_ways(2, [(a[0], i), (a[0], j), (a[0], k)])\n\n    return str(ways)"
    },
    {
        "number": 1486,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1].split()))\n\n    min_cost = [float('inf')] * n\n    max_cost = [float('-inf')] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_cost[i] = min(min_cost[i], abs(x[i] - x[j]))\n            max_cost[i] = max(max_cost[i], abs(x[i] - x[j]))\n            min_cost[j] = min(min_cost[j], abs(x[i] - x[j]))\n            max_cost[j] = max(max_cost[j], abs(x[i] - x[j]))\n\n    for i in range(n):\n        print(min_cost[i] + max_cost[i], end=' ')"
    },
    {
        "number": 1487,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()[0]\n    t = stdin.split()[1]\n    n = len(s)\n\n    if n!= len(t):\n        return \"impossible\"\n\n    def hamming_distance(s: str, t: str) -> int:\n        return sum(1 for i in range(len(s)) if s[i]!= t[i])\n\n    def find_string(s: str, t: str, n: int) -> str:\n        for i in range(2 ** n):\n            string = bin(i)[2:].zfill(n)\n            if hamming_distance(s, string) == hamming_distance(t, string):\n                return string\n        return \"impossible\"\n\n    return find_string(s, t, n)\n"
    },
    {
        "number": 1488,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_valid(route):\n        visited = set()\n        for i in range(len(route) - 1):\n            if route[i] in visited:\n                return False\n            visited.add(route[i])\n        return True\n\n    def count_routes(a, b):\n        routes = []\n        for i in range(a, b + 1):\n            for j in range(i + 1, b + 1):\n                for k in range(j + 1, b + 1):\n                    routes.append([i, j, k])\n        return routes\n\n    def count_valid_routes(routes):\n        count = 0\n        for route in routes:\n            if is_valid(route):\n                count += 1\n        return count\n\n    def lcm_of_routes(routes):\n        lcm_value = 1\n        for route in routes:\n            lcm_value = lcm(lcm_value, len(route))\n        return lcm_value\n\n    routes = count_routes(0, max(a))\n    valid_routes = count_valid_routes(routes)\n    lcm_value = lcm_of_routes(routes)\n\n    return str(valid_routes) + \" \" + str(lcm_value)\n"
    },
    {
        "number": 1489,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort()\n    mod = 10**9 + 7\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i][0] == points[j][0] or points[i][1] == points[j][1]:\n                count += 1\n    return str(count % mod)"
    },
    {
        "number": 1490,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    b = [0] * (10**9 + 1)\n    b[0] = 0\n    for i in a:\n        b[i] = b[i - 1] + 1\n    max_count = 0\n    max_types = []\n    for i in range(1, 10**9 + 1):\n        if b[i] > max_count:\n            max_count = b[i]\n            max_types = [i]\n        elif b[i] == max_count:\n            max_types.append(i)\n    max_types.sort()\n    return str(max_count) +'' +''.join(map(str, max_types))"
    },
    {
        "number": 1491,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    a.reverse()\n    count = 0\n    for i in range(n // 2):\n        if a[i] ** 2 == a[i + n // 2]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1492,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    map_ = [list(row) for row in stdin.split()[1:]]\n\n    def spread(x, y):\n        nonlocal map_\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and map_[nx][ny] == 'X':\n                map_[nx][ny] = '.'\n                spread(nx, ny)\n\n    for i in range(n):\n        for j in range(m):\n            if map_[i][j] == 'X':\n                spread(i, j)\n\n    max_time = 0\n    for i in range(n):\n        for j in range(m):\n            if map_[i][j] == 'X':\n                max_time = max(max_time, i)\n\n    result = []\n    for i in range(n):\n        row = ''.join(map_[i])\n        result.append(row)\n\n    return f\"{max_time}\\n{''.join(result)}\\n\""
    },
    {
        "number": 1493,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    board = [list(row) for row in stdin.split()[1:]]\n\n    def is_adjacent(i, j, board):\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if 0 <= i + x < n and 0 <= j + y < m and board[i + x][j + y] == board[i][j]:\n                return True\n        return False\n\n    def place_chessman(board, i, j, color):\n        board[i][j] = color\n        for x, y in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if 0 <= i + x < n and 0 <= j + y < m and board[i + x][j + y] == \"-\":\n                board[i + x][j + y] = color\n\n    def find_placement(board):\n        chessmen = set()\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == \".\":\n                    if (i, j) not in chessmen and not is_adjacent(i, j, board):\n                        place_chessman(board, i, j, \"W\")\n                        chessmen.add((i, j))\n                    elif (i, j) not in chessmen and is_adjacent(i, j, board):\n                        place_chessman(board, i, j, \"B\")\n                        chessmen.add((i, j))\n        return board\n\n    placement = find_placement(board)\n    result = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if placement[i][j] == \"W\":\n                row.append(\"W\")\n            elif placement[i][j] == \"B\":\n                row.append(\"B\")\n            else:\n                row.append(\"-\")\n        result.append(\"\".join(row))\n    return \"\\n\".join(result)"
    },
    {
        "number": 1494,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, p = stdin.split()\n    s = list(s)\n    p = list(p)\n    n = len(s)\n    m = len(p)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[j - 1] == p[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = dp[i - 1][j]\n\n    ans = [0] * (n + 1)\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[j - 1] == p[i - 1]:\n                if dp[i][j] > ans[j]:\n                    ans[j] = dp[i][j]\n\n    return \" \".join(map(str, ans))\n"
    },
    {
        "number": 1495,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def min_operations(a: list) -> int:\n        a.sort()\n        i = 0\n        j = 1\n        count = 0\n        while j < len(a):\n            if a[i] == a[j]:\n                count += 1\n                i += 1\n                j += 1\n            elif a[i] < a[j]:\n                i += 1\n            else:\n                j += 1\n        return count\n\n    return str(min_operations(a))"
    },
    {
        "number": 1496,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    def min_cost(t, c, a, b):\n        if t == 1:\n            return sum(a)\n        elif t == 2:\n            return sum(b)\n        else:\n            return float('inf')\n\n    def min_cost_day(t, c, a, b, k):\n        min_cost_t = min_cost(t, c, a, b)\n        min_cost_t_k = min_cost(t, c, a[:k], b[:k])\n        return min(min_cost_t, min_cost_t_k)\n\n    min_cost_t = min_cost(t[0], c[0], a, b)\n    min_cost_t_k = min_cost(t[0], c[0], a[:k], b[:k])\n    min_cost_day_t = min_cost_day(t[0], c[0], a, b, k)\n\n    for i in range(1, n):\n        min_cost_t = min(min_cost_t, min_cost(t[i], c[i], a, b))\n        min_cost_t_k = min(min_cost_t_k, min_cost(t[i], c[i], a[:k], b[:k]))\n        min_cost_day_t = min(min_cost_day_t, min_cost_day(t[i], c[i], a, b, k))\n\n    if min_cost_t_k > k * min_cost_day_t:\n        return -1\n\n    result = []\n    for i in range(k):\n        result.append(f\"{i+1} {min_cost_t_k//min_cost_day_t}\")\n        min_cost_t_k -= min_cost_day_t\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1497,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    rows = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                rows[i] += 1\n    \n    max_rows = 0\n    for i in range(n):\n        if rows[i] == n:\n            max_rows += 1\n    \n    return str(max_rows)"
    },
    {
        "number": 1498,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    tasks = []\n    for _ in range(q):\n        t, k, d = map(int, stdin.split())\n        tasks.append((t, k, d))\n\n    tasks.sort()\n    result = []\n    for t, k, d in tasks:\n        if not result:\n            result.extend(range(1, n + 1))\n        else:\n            result.sort()\n            for i in range(len(result)):\n                if result[i] + k <= n:\n                    result[i] += k\n                    break\n            else:\n                result.append(n + 1)\n        result.sort()\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1499,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    seat_count = 2 * n\n    window_seat_count = m - seat_count\n    seat_order = []\n\n    for i in range(1, seat_count + 1):\n        seat_order.append(i)\n\n    for i in range(1, window_seat_count + 1):\n        seat_order.append(seat_count + i)\n\n    seat_order.sort()\n\n    return \" \".join(map(str, seat_order))"
    },
    {
        "number": 1501,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = stdin.split()[1]\n    y = list(map(int, stdin.split()[2:]))\n\n    def count_subsequences(s: str, p: str) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (len(p) + 1) for _ in range(len(s) + 1)]\n\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n\n        for i in range(1, len(p) + 1):\n            for j in range(1, len(s) + 1):\n                if s[j - 1] == p[i - 1]:\n                    dp[j][i] = (dp[j - 1][i] + dp[j - 1][i - 1]) % MOD\n\n        return dp[len(s)][len(p)]\n\n    def count_subsequences_with_y(s: str, p: str, y: List[int]) -> int:\n        MOD = 10**9 + 7\n        dp = [[0] * (len(p) + 1) for _ in range(len(s) + 1)]\n\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n\n        for i in range(1, len(p) + 1):\n            for j in range(1, len(s) + 1):\n                if s[j - 1] == p[i - 1]:\n                    dp[j][i] = (dp[j - 1][i] + dp[j - 1][i - 1]) % MOD\n\n        count = 0\n        for i in range(len(s) - len(p) + 1):\n            if s[i:i + len(p)] == p:\n                count += dp[len(s) - i - len(p)][len(p)]\n\n        return (count * (count - 1)) % MOD\n\n    count = count_subsequences(p, p)\n    count += count_subsequences_with_y(p, p, y)\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 1502,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    b = a * 2\n    c = a * 3\n    d = a * 4\n    e = a * 5\n    f = a * 6\n    g = a * 7\n    h = a * 8\n    i = a * 9\n    j = a * 10\n    k = a * 11\n    l = a * 12\n    m = a * 13\n    n = a * 14\n    o = a * 15\n    return str(a + b + c + d + e + f + g + h + i + j + k + l + m + n + o)"
    },
    {
        "number": 1503,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    permutations = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def delete_prefix(permutation):\n        return [permutation[i] for i in range(len(permutation)) if permutation[i]!= 1]\n\n    def delete_suffix(permutation):\n        return [permutation[i] for i in range(len(permutation)) if permutation[i]!= n]\n\n    def common_parts(permutation):\n        return [permutation[i] for i in range(len(permutation)) if permutation[i] == permutation[0]]\n\n    def different_parts(permutation):\n        return [permutation[i] for i in range(len(permutation)) if permutation[i]!= permutation[0]]\n\n    def count_ways(permutation):\n        return len(set(map(tuple, permutations)))\n\n    def count_different_ways(permutation):\n        return len(set(map(tuple, permutations)))\n\n    def count_different_ways_with_common_parts(permutation):\n        return len(set(map(tuple, permutations)))\n\n    def count_different_ways_without_common_parts(permutation):\n        return count_ways(permutation) - count_different_ways(permutation)\n\n    def count_different_ways_with_common_parts_and_different_parts(permutation):\n        return count_different_ways(permutation) - count_different_ways_with_common_parts(permutation)\n\n    def count_different_ways_without_common_parts_and_different_parts(permutation):\n        return count_ways(permutation) - count_different_ways_without_common_parts(permutation)\n\n    def count_different_ways_with_common_parts_and_different_parts_and_prefix(permutation):\n        return count_different_ways_with_common_parts_and_different_parts(permutation) - count_different_ways_with_common_parts(permutation)\n\n    def count_different_ways_without_common_parts_and_different_parts_and_prefix(permutation):\n        return count_different_ways_without_common_parts_and_different_parts(permutation) - count_different_ways_without_common_parts(permutation)\n\n    def count_different_ways_with_common_parts_and_different_parts_and_suffix(permutation):\n        return count_different_ways_with_common_parts_and_different_parts(permutation) - count_different_ways_with_common_parts(permutation)\n\n    def count_different_ways_without_common_parts_and_different_parts_and_suffix(permutation):\n        return count_different_ways_without_common_parts_and_different_parts(permutation) - count_different_ways_without_common_parts(permutation)\n\n    def count_different_ways_with_common_parts_and_different_parts_and_prefix_and_suffix(permutation):\n        return count_different_ways_with_common_parts_and_different_parts_and_prefix(permutation) - count_different_ways_with_common_parts_and_different_parts_and_prefix(permutation)\n\n    def count_different_ways_without_common_parts_and_different_parts_and_prefix_and_suffix(permutation):\n        return count_different_ways_without_common_parts_and_different_parts_and_prefix(permutation) - count_different_ways_without_common_parts_and_different_parts_and_prefix(permutation)\n\n    def count_different_ways_with_common_parts_and_different_parts_and_prefix_and_suffix_and_common_parts(permutation):\n        return count_different_ways_with_common_parts_and_different_parts_and_prefix_and_suffix(permutation) - count_different_ways_with_common_parts_and_different_parts_and_prefix_and_suffix(permutation)\n\n    def count_different_ways_without_common_parts_and_different_parts_and_prefix_and_suffix_and_common_parts(permutation):\n        return count_different_ways_without_common_parts_and_different_parts_and_prefix_and_suffix(permutation) - count_different_ways_without_common_parts_and_different_parts_and_prefix_and_suffix(permutation)\n\n    def count_different_ways_with_common_parts_and_different_parts_and_prefix_and_suffix_and_different_parts(permutation):\n        return count_different_ways_with_common_parts_and_different_"
    },
    {
        "number": 1504,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        l1, r1 = map(int, stdin.split('\\n')[2].split())\n        l2, r2 = map(int, stdin.split('\\n')[3].split())\n\n        def intersection_length(a: list, b: list) -> int:\n            return max(0, min(a[1], b[1]) - max(a[0], b[0]))\n\n        def extend_segment(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[1]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[1] + step]\n            else:\n                return [b[0] - step, a[1]]\n\n        def make_segment(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[0]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[0] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[0]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[0] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list_to_list(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[1]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[1] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list_to_list_to_list(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[1]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[1] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list_to_list_to_list_to_list(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[1]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[1] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list_to_list_to_list_to_list_to_list(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[1]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[1] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list_to_list_to_list_to_list_to_list_to_list(a: list, b: list, step: int) -> list:\n            if a[0] + step < b[0]:\n                return [a[0] + step, b[1]]\n            elif a[0] + step == b[0]:\n                return [a[0] + step, b[1] + step]\n            else:\n                return [b[0], a[1] + step]\n\n        def make_segment_from_list_to_list_to_list_to_list_to_list_to_list_to_list(a: list, b: list, step: int) -> list:\n            if a[0"
    },
    {
        "number": 1505,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    px, py, vx, vy, a, b, c, d = map(int, stdin.split())\n\n    # Calculate the length of the base and the height of the triangle\n    base_length = a * (b ** 2 + c ** 2) ** 0.5\n    triangle_height = b * c / (a + b + c)\n\n    # Calculate the length of the rectangle sides\n    rectangle_side_length = c * (d ** 2 + triangle_height ** 2) ** 0.5\n\n    # Calculate the coordinates of the arrow points\n    triangle_point_x = (base_length / 2) * (1 + vx / (a + b + c))\n    triangle_point_y = triangle_height / 2 + py\n\n    rectangle_point_x = (rectangle_side_length / 2) * (1 + vx / (a + b + c))\n    rectangle_point_y = py - triangle_height / 2\n\n    # Calculate the coordinates of the arrow points in counter-clockwise order\n    arrow_points = [(triangle_point_x, triangle_point_y), (rectangle_point_x, rectangle_point_y)]\n\n    # Print the coordinates of the arrow points\n    for point in arrow_points:\n        print(f\"{point[0]:.9f} {point[1]:.9f}\")\n\n    return \"\""
    },
    {
        "number": 1506,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    MOD = 10**9 + 7\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def permutation(a: list) -> int:\n        n = len(a)\n        f = [0] * (n + 1)\n        f[0] = 1\n        f[1] = 1\n        for i in range(2, n + 1):\n            for j in range(i):\n                if a[j] < a[i]:\n                    f[i] = (f[i] + f[j]) % MOD\n        return f[n]\n\n    def sum_f(a: list) -> int:\n        return sum(permutation(a) for _ in range(factorial(n)))\n\n    return str(sum_f(a) % MOD)"
    },
    {
        "number": 1507,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    opened_doors = set()\n    for i in range(n):\n        opened_doors.add(s[i].upper())\n    for i in range(n, 26):\n        opened_doors.add(s[i].upper())\n    unguarded_doors = opened_doors - set(s)\n    if len(unguarded_doors) >= k:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1508,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_arrangement = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            arrangement = a[i] - a[j]\n            if arrangement > max_arrangement:\n                max_arrangement = arrangement\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            arrangement = a[i] - a[j]\n            if arrangement == max_arrangement:\n                x = [a[i], a[j]]\n                x.sort()\n                return''.join(map(str, x))\n\n    return ''"
    },
    {
        "number": 1509,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def f(l, r):\n        return sum(1 for i in range(l, r) if a[i] in range(l, r))\n\n    return str(sum(f(l, r) for l in range(1, n + 1) for r in range(l, n + 1)))"
    },
    {
        "number": 1510,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def min_operations(a, b):\n        min_a = min(a)\n        max_b = max(b)\n        return max(0, min_a - max_b)\n\n    return str(min_operations(a, b))"
    },
    {
        "number": 1511,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    instructions = []\n    for _ in range(n):\n        instructions.append(list(map(int, stdin.split())))\n\n    cycles = []\n    for i in range(m):\n        cycles.append(0)\n\n    for i in range(n):\n        for j in range(m):\n            if instructions[i][j] == 0:\n                cycles[j] += 1\n            else:\n                cycles[j] = instructions[i][j]\n\n    for i in range(n):\n        if cycles[i] == 0:\n            print(0)\n        else:\n            print(cycles[i])\n\n    return \"\"\n"
    },
    {
        "number": 1512,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    max_records = 0\n    max_record = None\n\n    for i in range(n):\n        if p[i] > max_records:\n            max_records = p[i]\n            max_record = p[i]\n        elif p[i] == max_records:\n            if p[i] < max_record:\n                max_record = p[i]\n\n    return str(max_record)"
    },
    {
        "number": 1513,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    broken_segments = list(map(int, stdin.split()))\n    broken_segments.sort()\n\n    def cut_tape(start: int, end: int) -> int:\n        return end - start + 1\n\n    def min_length(start: int, end: int) -> int:\n        if start == end:\n            return 0\n\n        min_length_left = min_length(start, broken_segments[start - 1])\n        min_length_right = min_length(broken_segments[end] + 1, end)\n\n        return cut_tape(start, end) + min(min_length_left, min_length_right)\n\n    return str(min_length(1, n))"
    },
    {
        "number": 1514,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b, *c = map(int, stdin.split())\n    b = [min(a, b[i]) for i, a in enumerate(b)]\n    c = [max(a, c[i]) for i, a in enumerate(c)]\n    b = [b[i] for i in range(n - 1) if p[i] == p[p.index(i) + 1]]\n    c = [c[i] for i in range(n - 1) if p[i] == p[p.index(i) + 1]]\n    if not b or not c:\n        return -1\n    a = [b[i] for i in range(n - 1)] + [c[i] for i in range(n - 1)]\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1515,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x = map(int, stdin.split())\n\n    if p == 1:\n        return \"Impossible\"\n\n    def is_valid(num: int) -> bool:\n        if num < 0:\n            return False\n        if num == 0:\n            return False\n        if num % 10 == 0:\n            return False\n        if num % 10 == 9:\n            return False\n        if num % 10 == 8:\n            return False\n        if num % 10 == 7:\n            return False\n        if num % 10 == 6:\n            return False\n        if num % 10 == 5:\n            return False\n        if num % 10 == 4:\n            return False\n        if num % 10 == 3:\n            return False\n        if num % 10 == 2:\n            return False\n        if num % 10 == 1:\n            return False\n        return True\n\n    def is_minimal(num: int) -> bool:\n        if num < 0:\n            return False\n        if num == 0:\n            return False\n        if num % 10 == 0:\n            return False\n        if num % 10 == 9:\n            return False\n        if num % 10 == 8:\n            return False\n        if num % 10 == 7:\n            return False\n        if num % 10 == 6:\n            return False\n        if num % 10 == 5:\n            return False\n        if num % 10 == 4:\n            return False\n        if num % 10 == 3:\n            return False\n        if num % 10 == 2:\n            return False\n        if num % 10 == 1:\n            return False\n        return True\n\n    def is_beautiful(num: int) -> bool:\n        if num < 0:\n            return False\n        if num == 0:\n            return False\n        if num % 10 == 0:\n            return False\n        if num % 10 == 9:\n            return False\n        if num % 10 == 8:\n            return False\n        if num % 10 == 7:\n            return False\n        if num % 10 == 6:\n            return False\n        if num % 10 == 5:\n            return False\n        if num % 10 == 4:\n            return False\n        if num % 10 == 3:\n            return False\n        if num % 10 == 2:\n            return False\n        if num % 10 == 1:\n            return False\n        return True\n\n    def move_last_digit_to_beginning(num: int) -> int:\n        return num * 10 + num % 10\n\n    def multiply_by_x(num: int) -> int:\n        return num * x\n\n    def find_beautiful_number(p: int) -> int:\n        num = 1\n        while True:\n            if is_valid(num):\n                if is_minimal(num):\n                    if is_beautiful(num):\n                        return num\n            num = move_last_digit_to_beginning(num)\n            num = multiply_by_x(num)\n\n    beautiful_number = find_beautiful_number(p)\n    if beautiful_number == 0:\n        return \"Impossible\"\n    return str(beautiful_number)"
    },
    {
        "number": 1516,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 998244353\n\n    def f(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):] + x[:len(y) - len(x)]\n        else:\n            return y + x[len(y):] + y[:len(x) - len(y)]\n\n    def g(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def h(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def k(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def l(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def m(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def n(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def o(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def p(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def q(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def r(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def s(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def t(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def u(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def v(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def w(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def x(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def y(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def z(x, y):\n        if len(x) >= len(y):\n            return x + y[len(x):]\n        else:\n            return y + x[len(y):]\n\n    def a_to_z(x):\n        return ''.join(chr(ord('a') + i) for i in range(len(x)))\n\n    def z_to_a(x):\n        return ''.join(chr(ord('z') - i) for i in range(len(x)))\n\n    def solve(a):\n        return sum(\n            sum(\n                sum(\n                    sum(\n                        sum(\n                            sum(\n                                sum(\n                                    sum(\n                                        sum(\n                                            sum(\n                                                sum(\n                                                    sum(\n                                                        sum(\n                                                            sum(\n                                                                sum(\n                                                                    sum(\n                                                                        sum("
    },
    {
        "number": 1517,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i!= j:\n                count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 1518,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def sort_array(a: list) -> None:\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if (j - i + 1) % 2 == 0 and is_prime(j - i + 1):\n                    a[i], a[j] = a[j], a[i]\n\n    sort_array(a)\n\n    k = 0\n    for i in range(len(a)):\n        for j in range(i + 1, len(a)):\n            if (j - i + 1) % 2 == 0 and is_prime(j - i + 1):\n                k += 1\n                print(f\"{i + 1} {j + 1}\")\n\n    return str(k)\n"
    },
    {
        "number": 1519,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, a = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    t.append(L)\n    l = [0] * n\n    l[0] = t[1] - t[0]\n    for i in range(1, n):\n        l[i] = t[i + 1] - t[i]\n    max_breaks = 0\n    for i in range(n):\n        if l[i] > a:\n            max_breaks += 1\n    return str(max_breaks)"
    },
    {
        "number": 1520,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = stdin.split()[1:]\n    beauty = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            product = strings[i] * strings[j]\n            beauty = max(beauty, len(product))\n    return str(beauty)"
    },
    {
        "number": 1521,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, n = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    h = lambda x: x % p\n    bucket = [[] for _ in range(p)]\n    conflict = -1\n\n    for i, num in enumerate(x):\n        bucket[h(num)].append(num)\n        if len(bucket[h(num)]) > 1:\n            conflict = i\n            break\n\n    return str(conflict)"
    },
    {
        "number": 1522,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    keys = [s[i] for i in range(0, len(s), 2)]\n    doors = [s[i] for i in range(1, len(s), 2)]\n\n    keys_count = {}\n    for key in keys:\n        if key in keys_count:\n            keys_count[key] += 1\n        else:\n            keys_count[key] = 1\n\n    min_keys = min(keys_count.values())\n\n    return str(min_keys)"
    },
    {
        "number": 1523,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    min_time = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        time = b[i] + (k - a[i]) * b[a[i] - 1]\n        min_time = min(min_time, time)\n\n    return str(min_time)"
    },
    {
        "number": 1524,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    N = len(S)\n    left_squares = [0] * N\n    right_squares = [0] * N\n    left_squares[0] = 1\n    right_squares[N - 1] = 1\n\n    for i in range(1, N):\n        if S[i] == 'L':\n            left_squares[i] = left_squares[i - 1] + right_squares[i - 1]\n        else:\n            right_squares[i] = left_squares[i - 1] + right_squares[i - 1]\n\n    return''.join(map(str, left_squares)) + '\\n' +''.join(map(str, right_squares))"
    },
    {
        "number": 1525,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n    if H > 100 or H < 1 or W > 8 or W < 1 or K > W or K < 1:\n        return \"Invalid input\"\n\n    def is_valid_amidakuji(amidakuji: list[list[int]]) -> bool:\n        for i in range(len(amidakuji) - 1):\n            if amidakuji[i][0] == amidakuji[i + 1][0]:\n                return False\n            if amidakuji[i][1] == amidakuji[i + 1][1]:\n                return False\n        return True\n\n    def count_valid_amidakuji(H: int, W: int, K: int) -> int:\n        amidakuji = []\n        for i in range(W):\n            for j in range(H + 1):\n                amidakuji.append([i, j])\n\n        count = 0\n        for i in range(W):\n            for j in range(H + 1):\n                if j == 0:\n                    continue\n                if j == H + 1:\n                    break\n                if j == 1:\n                    continue\n                if j == 2:\n                    continue\n                if j == 3:\n                    continue\n                if j == 4:\n                    continue\n                if j == 5:\n                    continue\n                if j == 6:\n                    continue\n                if j == 7:\n                    continue\n                if j == 8:\n                    continue\n                if j == 9:\n                    continue\n                if j == 10:\n                    continue\n                if j == 11:\n                    continue\n                if j == 12:\n                    continue\n                if j == 13:\n                    continue\n                if j == 14:\n                    continue\n                if j == 15:\n                    continue\n                if j == 16:\n                    continue\n                if j == 17:\n                    continue\n                if j == 18:\n                    continue\n                if j == 19:\n                    continue\n                if j == 20:\n                    continue\n                if j == 21:\n                    continue\n                if j == 22:\n                    continue\n                if j == 23:\n                    continue\n                if j == 24:\n                    continue\n                if j == 25:\n                    continue\n                if j == 26:\n                    continue\n                if j == 27:\n                    continue\n                if j == 28:\n                    continue\n                if j == 29:\n                    continue\n                if j == 30:\n                    continue\n                if j == 31:\n                    continue\n                if j == 32:\n                    continue\n                if j == 33:\n                    continue\n                if j == 34:\n                    continue\n                if j == 35:\n                    continue\n                if j == 36:\n                    continue\n                if j == 37:\n                    continue\n                if j == 38:\n                    continue\n                if j == 39:\n                    continue\n                if j == 40:\n                    continue\n                if j == 41:\n                    continue\n                if j == 42:\n                    continue\n                if j == 43:\n                    continue\n                if j == 44:\n                    continue\n                if j == 45:\n                    continue\n                if j == 46:\n                    continue\n                if j == 47:\n                    continue\n                if j == 48:\n                    continue\n                if j == 49:\n                    continue\n                if j == 50:\n                    continue\n                if j == 51:\n                    continue\n                if j == 52:\n                    continue\n                if j == 53:\n                    continue\n                if j == 54:\n                    continue\n                if j == 55:\n                    continue\n                if j == 56:\n                    continue\n                if j == 57:\n                    continue\n                if j == 58:\n                    continue\n                if j == 59:\n                    continue\n                if j == 60:\n                    continue\n                if j == 61:\n                    continue\n                if j == 62:\n                    continue\n                if j == 63:\n                    continue\n                if j == 64:\n                    continue\n                if j == 65:\n                    continue\n                if j == 66:\n                    continue\n                if j == 67:\n                    continue\n                if j == 68:\n                    continue\n                if j == 69:\n                    continue\n                if j == 70:\n                    continue\n                if j == 71:\n                    continue\n                if j == 72:\n                    continue\n                if j == 73:\n                    continue\n                if j == 74:\n                    continue\n                if j == 75:\n                    continue\n                if j == 76:\n                    continue\n                if j == 77:\n                    continue\n                "
    },
    {
        "number": 1526,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    min_operations = 0\n    while a!= b!= c:\n        if a < b:\n            a += 1\n            c += 1\n            min_operations += 1\n        elif a < c:\n            a += 2\n            min_operations += 1\n        else:\n            b += 2\n            min_operations += 1\n    return str(min_operations)"
    },
    {
        "number": 1527,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    S = [list(row) for row in stdin.splitlines()]\n\n    def is_valid(i, j):\n        return 0 <= i < H and 0 <= j < W and S[i][j]!= '#'\n\n    def is_road(i, j):\n        return S[i][j] == '.'\n\n    def is_adjacent(i, j, dx, dy):\n        return 0 <= i + dx < H and 0 <= j + dy < W and S[i + dx][j + dy] == '.'\n\n    def bfs(start, goal):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if (i, j) == goal:\n                return steps\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                if is_adjacent(i, j, dx, dy):\n                    queue.append((i + dx, j + dy, steps + 1))\n        return -1\n\n    def dfs(i, j, steps):\n        if i == H - 1 and j == W - 1:\n            return steps\n        if not is_valid(i, j):\n            return -1\n        if is_road(i, j):\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                if is_road(i + dx, j + dy):\n                    return dfs(i + dx, j + dy, steps + 1)\n        return -1\n\n    start = (0, 0)\n    goal = (H - 1, W - 1)\n    return str(max(bfs(start, goal), dfs(start[0], start[1], 0)))"
    },
    {
        "number": 1528,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    layers = []\n    for _ in range(n):\n        layers.append(list(map(str, input().split())))\n    patties = 0\n    for layer in layers:\n        if layer[0] == 'B':\n            patties += 1\n        elif layer[0] == 'P':\n            patties += 1\n        else:\n            patties += 2\n    return str(patties)"
    },
    {
        "number": 1529,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sentences = stdin.split('\\n')[1:]\n    \n    freda_sentences = []\n    rainbow_sentences = []\n    \n    for sentence in sentences:\n        if sentence.startswith('miao.') and sentence.endswith('lala.'):\n            freda_sentences.append(sentence)\n        elif sentence.startswith('lala.') and sentence.endswith('miao.'):\n            rainbow_sentences.append(sentence)\n        else:\n            return \"OMG>.< I don't know!\"\n    \n    if freda_sentences:\n        return \"Freda's\"\n    elif rainbow_sentences:\n        return \"Rainbow's\"\n    else:\n        return \"OMG>.< I don't know!\""
    },
    {
        "number": 1531,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [abs(x) for x in a]\n    a.sort()\n    a.append(a[0])\n    a.append(a[-1])\n    k = 0\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            k += 1\n        else:\n            break\n    return f\"{sum(a) - a[0] - a[-1]} {k}\""
    },
    {
        "number": 1532,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    imperfection = [0] * (n - 1)\n    for i in range(1, n):\n        for j in range(i):\n            if gcd(i, j) == 1:\n                imperfection[i - 1] = max(imperfection[i - 1], imperfection[j] + 1)\n    return''.join(map(str, imperfection))\n\ndef"
    },
    {
        "number": 1533,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    names = stdin.split()[1:]\n    result = []\n\n    for i in range(n):\n        for j in range(i):\n            if names[i] == names[j]:\n                result.append(\"YES\")\n                break\n        else:\n            result.append(\"NO\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1534,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_beautiful(s: str) -> bool:\n        a_count = s.count(\"a\")\n        b_count = s.count(\"b\")\n        if a_count == 0 or b_count == 0:\n            return False\n        if a_count > 1 or b_count > 1:\n            return False\n        return True\n\n    def find_max_length(s: str) -> int:\n        max_length = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                beautiful_s = s[:i] + s[j:]\n                if is_beautiful(beautiful_s):\n                    max_length = max(max_length, len(beautiful_s))\n        return max_length\n\n    s = stdin.strip()\n    max_length = find_max_length(s)\n    print(max_length)\n"
    },
    {
        "number": 1535,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x_0, y_0 = map(int, stdin.split())\n    stormtroopers = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        stormtroopers.append((x, y))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def cross(a, b, c):\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    def is_crossing(a, b, c, d):\n        return cross(a, b, c) * cross(a, b, d) < 0 and cross(c, d, a) * cross(c, d, b) < 0\n\n    def is_inside(a, b, c):\n        return cross(a, b, c) == 0\n\n    def is_on_line(a, b, c):\n        return cross(a, b, c) == 0 or cross(a, b, c) == cross(a, b, a)\n\n    def is_on_line_segment(a, b, c, d):\n        return is_on_line(a, b, c) or is_on_line(a, b, d) or is_on_line(c, d, a) or is_on_line(c, d, b)\n\n    def is_on_line_segment_or_crossing(a, b, c, d):\n        return is_on_line_segment(a, b, c, d) or is_crossing(a, b, c, d)\n\n    def is_on_line_or_crossing(a, b, c, d):\n        return is_on_line(a, b, c) or is_on_line(a, b, d) or is_on_line(c, d, a) or is_on_line(c, d, b) or is_crossing(a, b, c, d)\n\n    def is_on_line_or_crossing_or_inside(a, b, c, d):\n        return is_on_line_or_crossing(a, b, c, d) or is_inside(a, b, c) or is_inside(a, b, d) or is_inside(c, d, a) or is_inside(c, d, b)\n\n    def is_on_line_or_crossing_or_inside_or_on_line_segment(a, b, c, d):\n        return is_on_line_or_crossing_or_inside(a, b, c, d) or is_on_line_segment(a, b, c, d)\n\n    def is_on_line_or_crossing_or_inside_or_on_line_segment_or_on_line(a, b, c, d):\n        return is_on_line_or_crossing_or_inside_or_on_line_segment(a, b, c, d) or is_on_line(a, b, c) or is_on_line(a, b, d) or is_on_line(c, d, a) or is_on_line(c, d, b)\n\n    def is_on_line_or_crossing_or_inside_or_on_line_segment_or_on_line_or_crossing(a, b, c, d):\n        return is_on_line_or_crossing_or_inside_or_on_line_segment_or_on_line(a, b, c, d) or is_crossing(a, b, c, d)\n\n    def is_on_line_or_crossing_or_inside_or_on_line_segment_or_on_line_or_crossing_or_on_line_segment(a, b, c, d):\n        return is_on_line_or_crossing_or_inside_or_on_line_segment_or_on_line_or_crossing(a, b, c, d) or is_on_line_segment(a, b, c, d)\n\n    def is_on_line_or_crossing_or_inside_or_on_line_segment"
    },
    {
        "number": 1536,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = [tuple(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def is_perfectly_balanced(a: int, b: int) -> bool:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        return (x_a <= x_b <= max(x_a, x_b) and\n                y_a <= y_b <= max(y_a, y_b) and\n                z_a <= z_b <= max(z_a, z_b))\n\n    def find_perfectly_balanced_pair() -> tuple[int, int]:\n        for i in range(1, n, 2):\n            for j in range(i + 2, n + 1, 2):\n                if is_perfectly_balanced(i, j):\n                    return i, j\n        return -1, -1\n\n    def find_minimum_bounding_box(a: int, b: int) -> tuple[int, int]:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        return (min(x_a, x_b), min(y_a, y_b), min(z_a, z_b)), (max(x_a, x_b), max(y_a, y_b), max(z_a, z_b))\n\n    def snap(a: int, b: int) -> tuple[int, int]:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        x_c, y_c, z_c = (x_a + x_b) // 2, (y_a + y_b) // 2, (z_a + z_b) // 2\n        return (x_c, y_c, z_c), (x_a, y_a, z_a), (x_b, y_b, z_b)\n\n    def remove_points(a: int, b: int) -> tuple[int, int]:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        x_c, y_c, z_c = (x_a + x_b) // 2, (y_a + y_b) // 2, (z_a + z_b) // 2\n        points[a - 1] = x_c, y_c, z_c\n        points[b - 1] = x_a, y_a, z_a\n        return a + 1, b + 1\n\n    def remove_points_and_snap(a: int, b: int) -> tuple[int, int]:\n        a, b = remove_points(a, b)\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        x_c, y_c, z_c = (x_a + x_b) // 2, (y_a + y_b) // 2, (z_a + z_b) // 2\n        points[a - 1] = x_c, y_c, z_c\n        points[b - 1] = x_a, y_a, z_a\n        return a + 1, b + 1\n\n    def find_pairs(a: int, b: int) -> tuple[int, int]:\n        if a == b:\n            return a, b\n        a, b = remove_points_and_snap(a, b)\n        return find_pairs(a, b)\n\n    a, b = find_perfectly_balanced_pair()\n    if a == -1:\n        a, b = find_pairs(1, n)\n    a, b = find_pairs(a, b)\n    return f\"{a} {b}\""
    },
    {
        "number": 1537,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    board = [list(line.strip()) for line in stdin.splitlines()]\n\n    def is_valid(i, j):\n        return 1 <= i <= n and 1 <= j <= n and board[i - 1][j - 1] == 'B'\n\n    def is_valid_square(i, j, k):\n        return 1 <= i <= n - k + 1 and 1 <= j <= n - k + 1\n\n    def count_white_lines(i, j, k):\n        count = 0\n        for di in range(-k, k + 1):\n            for dj in range(-k, k + 1):\n                if di == 0 and dj == 0:\n                    continue\n                if is_valid_square(i + di, j + dj, k):\n                    count += 1\n        return count\n\n    max_count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if board[i - 1][j - 1] == 'W':\n                max_count = max(max_count, count_white_lines(i, j, k))\n\n    return str(max_count)"
    },
    {
        "number": 1538,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] < a[j]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1539,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *leg_lengths = map(int, stdin.split())\n    d, *leg_energies = map(int, stdin.split())\n\n    stable_legs = 0\n    max_leg_length = max(leg_lengths)\n\n    for i in range(n):\n        if leg_lengths[i] == max_leg_length:\n            stable_legs += 1\n\n    if stable_legs > n // 2:\n        return \"0\"\n\n    min_energy = float(\"inf\")\n    for i in range(n):\n        if leg_lengths[i] == max_leg_length:\n            min_energy = min(min_energy, leg_energies[i])\n\n    return str(min_energy)"
    },
    {
        "number": 1540,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n    events = [list(map(int, stdin.split())) for _ in range(k)]\n\n    def count_notifications(chat_id: int) -> int:\n        notifications = 0\n        for event in events:\n            if event[1] == chat_id:\n                notifications += 1\n        return notifications\n\n    result = [count_notifications(chat_id) for chat_id in range(1, m + 1)]\n    return''.join(map(str, result))"
    },
    {
        "number": 1541,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    record = len(s)\n    pivot = s.index(\"^\")\n    weights = [0] * record\n\n    for i in range(record):\n        if s[i] == \"^\":\n            weights[i] = 1\n        elif s[i] == \"=\":\n            weights[i] = 0\n        else:\n            weights[i] = int(s[i])\n\n    left_sum = sum(weights[:pivot])\n    right_sum = sum(weights[pivot + 1:])\n\n    if left_sum == right_sum:\n        return \"balance\"\n    elif left_sum > right_sum:\n        return \"left\"\n    else:\n        return \"right\""
    },
    {
        "number": 1542,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *prices = map(int, stdin.split())\n    q, *m = map(int, stdin.split())\n\n    def find_shops(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def find_bottles(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days(price: int, coins: int) -> int:\n        left, right = 0, q\n        while left < right:\n            mid = (left + right) // 2\n            if m[mid] <= coins:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def find_days_in_shop(price: int, coins: int, shop: int) -> int:\n        left, right = 0, q\n        while left < right:\n            mid = (left + right) // 2\n            if m[mid] <= coins and find_shops(price, coins) == shop:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def find_days_in_shops(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles_in_shop(price: int, coins: int, shop: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles_in_shops(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles_in_shops_with_bottles(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles_in_shops_with_bottles_in_shop(price: int, coins: int, shop: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles_in_shops_with_bottles_in_shops(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right = mid\n        return right - left\n\n    def find_days_in_shops_with_bottles_in_shops_with_bottles_in_shops_with_bottles(price: int, coins: int) -> int:\n        left, right = 0, n\n        while left < right:\n            mid = (left + right) // 2\n            if prices[mid] <= price:\n                left = mid + 1\n            else:\n                right ="
    },
    {
        "number": 1543,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cities = []\n    for i in range(n):\n        x, c = map(int, stdin.split()[1:])\n        cities.append((x, c))\n\n    cities.sort()\n    byteland_cities = [city for city in cities if city[1] == 'B']\n    berland_cities = [city for city in cities if city[1] == 'R']\n    disputed_cities = [city for city in cities if city[1] == 'P']\n\n    def find_closest_city(cities, city):\n        closest_city = cities[0]\n        closest_distance = abs(city[0] - closest_city[0])\n        for other_city in cities:\n            distance = abs(city[0] - other_city[0])\n            if distance < closest_distance:\n                closest_city = other_city\n                closest_distance = distance\n        return closest_city\n\n    byteland_closest_city = find_closest_city(byteland_cities, (0, 'P'))\n    berland_closest_city = find_closest_city(berland_cities, (0, 'P'))\n\n    byteland_cables = []\n    berland_cables = []\n\n    for city in byteland_cities:\n        if city[0] == byteland_closest_city[0]:\n            continue\n        byteland_cables.append((city, byteland_closest_city))\n\n    for city in berland_cities:\n        if city[0] == berland_closest_city[0]:\n            continue\n        berland_cables.append((city, berland_closest_city))\n\n    byteland_cables.sort(key=lambda x: x[0][0])\n    berland_cables.sort(key=lambda x: x[0][0])\n\n    total_cost = 0\n    for city1, city2 in byteland_cables:\n        total_cost += city1[0][0] - city2[0][0]\n\n    for city1, city2 in berland_cables:\n        total_cost += city1[0][0] - city2[0][0]\n\n    return str(total_cost)"
    },
    {
        "number": 1544,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    pennants = [0] * 5\n    pennants[0] = 1\n    pennants[1] = 3\n    pennants[2] = 5\n    pennants[3] = 7\n    pennants[4] = 9\n\n    def backtrack(index: int, count: int) -> int:\n        if count == 0:\n            return 1\n\n        result = 0\n        for i in range(index, 5):\n            if pennants[i] > 0:\n                pennants[i] -= 1\n                result += backtrack(i + 1, count - 1)\n                pennants[i] += 1\n\n        return result\n\n    return str(backtrack(0, 5))"
    },
    {
        "number": 1545,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    a = list(map(int, stdin.split()[2:]))\n\n    def split_string(s: str, a: list) -> int:\n        def is_valid(s: str, a: list) -> bool:\n            count = 0\n            for i in range(len(s)):\n                if s[i] in a:\n                    count += 1\n                    if count > n:\n                        return False\n            return True\n\n        def dfs(s: str, a: list, start: int, end: int, count: int, res: int) -> int:\n            if start == end:\n                return 0\n            if is_valid(s[:start] + s[start:end] + s[end:], a):\n                res = dfs(s, a, start + 1, end, count + 1, res)\n            if is_valid(s[:start] + s[start:end] + s[end:], a):\n                res = dfs(s, a, start + 1, end, count, res)\n            return res\n\n        return dfs(s, a, 0, len(s), 0, 0)\n\n    ways = split_string(s, a)\n    print(ways)\n\n    max_len = 0\n    min_substrings = 0\n    for i in range(1, len(s) + 1):\n        for j in range(i, len(s) + 1):\n            if i == j:\n                continue\n            substrings = split_string(s[i:j], a)\n            if substrings > max_len:\n                max_len = substrings\n            if substrings < min_substrings or (substrings == min_substrings and i < j):\n                min_substrings = substrings\n\n    print(max_len)\n    print(min_substrings)\n\n    return \"\"\n"
    },
    {
        "number": 1546,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    pairs.sort()\n    visited = set()\n    result = []\n    for a, b in pairs:\n        if (a, b) in visited or (b, a) in visited:\n            continue\n        visited.add((a, b))\n        visited.add((b, a))\n        result.append(a)\n        result.append(b)\n        if len(result) == n:\n            break\n    if len(result)!= n:\n        return \"-1\"\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1547,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    table = [[0] * m for _ in range(n)]\n    for _ in range(k):\n        op, r, a = map(int, stdin.split())\n        if op == 1:\n            for i in range(r, n + 1):\n                table[i - 1][a - 1] = 1\n        elif op == 2:\n            for j in range(m):\n                table[r - 1][j] = 1\n    for row in table:\n        print(\" \".join(map(str, row)))\n    return \"\""
    },
    {
        "number": 1548,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] > max_distance:\n                max_distance = a[i] + a[j]\n    return str(max_distance ** 2)"
    },
    {
        "number": 1549,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [0] * n\n\n    for i in range(n):\n        b[a[i] - 1] += 1\n\n    for i in range(q):\n        print(b.index(min(b)) + 1)"
    },
    {
        "number": 1550,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    display = list(map(int, stdin.split()[1]))\n\n    def push_button(button: int) -> None:\n        if button == 1:\n            for i in range(n):\n                display[i] = (display[i] + 1) % 10\n        else:\n            for i in range(n - 1, -1, -1):\n                display[i], display[i + 1] = display[i + 1], display[i]\n\n    push_button(1)\n    push_button(2)\n\n    return ''.join(map(str, display))"
    },
    {
        "number": 1551,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    people = []\n    for _ in range(n):\n        x, v, t = map(int, stdin.split())\n        people.append((x, v, t))\n\n    bomb_x = 10**6\n    bomb_t = 10**6\n\n    for x, v, t in people:\n        if x == 0:\n            bomb_x = x\n            bomb_t = t\n\n    bomb_t = min(bomb_t, 10**6)\n\n    left_speed = 0\n    right_speed = 0\n\n    for x, v, t in people:\n        if x == 0:\n            left_speed = v\n        elif x == 10**6:\n            right_speed = v\n\n    left_speed = max(left_speed, 1)\n    right_speed = max(right_speed, 1)\n\n    left_t = (bomb_x - 1) / left_speed\n    right_t = (10**6 - bomb_x) / right_speed\n\n    t = min(left_t, right_t)\n\n    return f\"{t:.6f}\"\n"
    },
    {
        "number": 1552,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    t = [t[i - 1] for i in range(1, n + 1)]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_good_at(t, subject):\n        return t == subject\n\n    def find_team(t1, t2, t3):\n        if is_good_at(t1, 1) and is_good_at(t2, 2) and is_good_at(t3, 3):\n            return 1\n        elif is_good_at(t1, 2) and is_good_at(t2, 1) and is_good_at(t3, 3):\n            return 2\n        elif is_good_at(t1, 3) and is_good_at(t2, 2) and is_good_at(t3, 1):\n            return 3\n        elif is_good_at(t1, 3) and is_good_at(t2, 1) and is_good_at(t3, 2):\n            return 4\n        elif is_good_at(t1, 2) and is_good_at(t2, 3) and is_good_at(t3, 1):\n            return 5\n        elif is_good_at(t1, 1) and is_good_at(t2, 3) and is_good_at(t3, 2):\n            return 6\n        elif is_good_at(t1, 2) and is_good_at(t2, 1) and is_good_at(t3, 3):\n            return 7\n        elif is_good_at(t1, 1) and is_good_at(t2, 2) and is_good_at(t3, 3):\n            return 8\n        else:\n            return 0\n\n    def find_teams(t):\n        teams = []\n        for i in range(1, n + 1):\n            if is_good_at(t[i - 1], 1):\n                for j in range(i + 1, i + 3):\n                    if is_good_at(t[j - 1], 2):\n                        for k in range(j + 1, j + 3):\n                            if is_good_at(t[k - 1], 3):\n                                teams.append(find_team(t[i - 1], t[j - 1], t[k - 1]))\n        return teams\n\n    def max_teams(t):\n        teams = find_teams(t)\n        return max(teams)\n\n    def find_max_teams(t):\n        max_t = max_teams(t)\n        return [i for i in range(1, n + 1) if is_good_at(t[i - 1], 1) and is_good_at(t[i - 1], 2) and is_good_at(t[i - 1], 3) and find_team(t[i - 1], t[i - 1], t[i - 1]) == max_t]\n\n    max_t = max_teams(t)\n    if max_t == 0:\n        return \"0\\n\"\n    else:\n        return f\"{max_t}\\n\" + \"\\n\".join(map(str, find_max_teams(t)))"
    },
    {
        "number": 1553,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(i, j):\n        return 0 <= i < h and 0 <= j < 2\n\n    def is_valid_space(i, j):\n        return is_valid(i, j) and a[i] >= a[i + 1]\n\n    def is_valid_shelf(i, j):\n        return is_valid(i, j) and is_valid_space(i, j)\n\n    def is_valid_bottle(i, j):\n        return is_valid_space(i, j) and is_valid_shelf(i, j + 1)\n\n    def is_valid_location(i, j):\n        return is_valid_bottle(i, j) and is_valid_bottle(i + 1, j)\n\n    def find_max_k():\n        i = 0\n        j = 0\n        k = 0\n        while i < h - 1 and j < 2:\n            if is_valid_location(i, j):\n                k += 1\n            i += 1\n            j += 1\n        return k\n\n    return str(find_max_k())"
    },
    {
        "number": 1554,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good_segment(a: list) -> bool:\n        return len(set(a)) == 2\n\n    def split_row(a: list) -> int:\n        segments = 0\n        i = 0\n        while i < len(a) - 1:\n            if is_good_segment(a[i:i+2]):\n                segments += 1\n                i += 2\n            else:\n                i += 1\n        return segments\n\n    max_segments = split_row(a)\n    if max_segments == 0:\n        return \"-1\"\n\n    segments = []\n    i = 0\n    while i < len(a) - 1:\n        if is_good_segment(a[i:i+2]):\n            segments.append((i, i+1))\n            i += 2\n        else:\n            i += 1\n\n    segments.sort(key=lambda x: (x[0], x[1]))\n\n    result = []\n    for segment in segments:\n        result.append(f\"{segment[0]} {segment[1]}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1555,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(str, stdin.split())) for _ in range(n)]\n\n    def evaluate(i: int, j: int) -> int:\n        if a[i][j] == \"<\":\n            return min(evaluate(i, k) + evaluate(k, j) for k in range(n))\n        elif a[i][j] == \">\":\n            return max(evaluate(i, k) + evaluate(k, j) for k in range(n))\n        else:\n            return evaluate(i, k) + evaluate(k, j)\n\n    max_score = evaluate(0, 0)\n    if max_score == 0:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1556,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def apply_operation(i: int) -> int:\n        if a[i] + x > x:\n            a[i] -= x\n        else:\n            a[i] += x\n        return a[i]\n\n    for _ in range(k):\n        i = random.randint(1, n)\n        apply_operation(i)\n\n    b = a.copy()\n    for i in range(n):\n        b[i] = b[i] % x\n\n    return \" \".join(map(str, b))\n"
    },
    {
        "number": 1557,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h1, a1, c1 = map(int, stdin.split())\n    h2, a2 = map(int, stdin.split())\n\n    def heal(health, healing_power):\n        return min(health + healing_power, h1)\n\n    def attack(health, attack_power):\n        return max(health - attack_power, 0)\n\n    def drink_potion(health, healing_power):\n        return heal(health, healing_power)\n\n    def modcrab_attack(health, attack_power):\n        return attack(health, attack_power)\n\n    def modcrab_heal(health, healing_power):\n        return heal(health, healing_power)\n\n    def modcrab_defeat(health, attack_power):\n        return attack(health, attack_power)\n\n    def modcrab_win(health, attack_power):\n        return attack(health, attack_power)\n\n    def modcrab_lose(health, attack_power):\n        return heal(health, attack_power)\n\n    def modcrab_draw(health, attack_power):\n        return health\n\n    def modcrab_tie(health, attack_power):\n        return health\n\n    def modcrab_status(health, attack_power):\n        if health <= 0:\n            return \"LOSE\"\n        elif health == h2:\n            return \"WIN\"\n        else:\n            return \"TIE\"\n\n    def modcrab_strategy(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_turn(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_next_turn(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_next_turn_status(health, attack_power):\n        if health <= 0:\n            return \"LOSE\"\n        elif health == h2:\n            return \"WIN\"\n        else:\n            return \"TIE\"\n\n    def modcrab_next_turn_strategy(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_next_turn_turn(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_next_turn_next_turn(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_next_turn_next_turn_status(health, attack_power):\n        if health <= 0:\n            return \"LOSE\"\n        elif health == h2:\n            return \"WIN\"\n        else:\n            return \"TIE\"\n\n    def modcrab_next_turn_next_turn_strategy(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n        else:\n            return modcrab_draw(health, attack_power)\n\n    def modcrab_next_turn_next_turn_turn(health, attack_power):\n        if health <= 0:\n            return modcrab_lose(health, attack_power)\n        elif health == h2:\n            return modcrab_win(health, attack_power)\n       "
    },
    {
        "number": 1558,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, avg = map(int, stdin.split())\n    exams = [list(map(int, stdin.split())) for _ in range(n)]\n    essays_needed = 0\n    total_grade = 0\n\n    for exam in exams:\n        total_grade += exam[0]\n        if exam[0] >= avg:\n            essays_needed += exam[1]\n            total_grade += exam[1] * exam[0]\n\n    if total_grade >= avg:\n        return str(essays_needed)\n    else:\n        return \"0\""
    },
    {
        "number": 1559,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A = map(int, stdin.split())\n    P = 10 ** L\n    while True:\n        X = A + P\n        if X % P == 0:\n            return str(X)\n        P *= 10"
    },
    {
        "number": 1560,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, colors = map(int, stdin.split())\n    colors = list(colors)\n    turns = 0\n\n    while colors[0] == colors[1]:\n        colors.pop(0)\n        colors.pop(0)\n        turns += 1\n\n    if colors[0] == 'b':\n        colors[0] = 'r'\n    else:\n        colors[0] = 'b'\n\n    if colors[1] == 'b':\n        colors[1] = 'r'\n    else:\n        colors[1] = 'b'\n\n    turns += 1\n\n    return str(turns)"
    },
    {
        "number": 1561,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(stdin.strip())\n        matrix.append(row)\n\n    def count_ways(row, col, count):\n        if count == k:\n            return 1\n        if row < 0 or row >= n or col < 0 or col >= m:\n            return 0\n\n        if matrix[row][col] == '.':\n            matrix[row][col] = '*'\n            count_ways(row + 1, col, count + 1)\n            count_ways(row - 1, col, count + 1)\n            count_ways(row, col + 1, count + 1)\n            count_ways(row, col - 1, count + 1)\n            matrix[row][col] = '.'\n        return count_ways(row + 1, col, count) + count_ways(row - 1, col, count) + count_ways(row, col + 1, count) + count_ways(row, col - 1, count)\n\n    return str(count_ways(0, 0, 0))"
    },
    {
        "number": 1562,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.split())\n    treasures = [(int(x), int(y)) for x, y in stdin.split()[1:k+1]]\n    safe_columns = set(map(int, stdin.split()[-q:]))\n\n    def is_safe(r, c):\n        return 1 <= r <= n and 1 <= c <= m and c in safe_columns\n\n    def is_treasure(r, c):\n        return (1 <= r <= n and 1 <= c <= m) and (r, c) in treasures\n\n    def is_valid(r, c):\n        return is_safe(r, c) and is_treasure(r, c)\n\n    def move(r, c, d):\n        if d == 1:\n            return r - 1, c\n        elif d == 2:\n            return r, c - 1\n        else:\n            return r, c + 1\n\n    def bfs(r, c):\n        queue = [(r, c)]\n        visited = set()\n        while queue:\n            r, c = queue.pop(0)\n            if (r, c) == (n, m):\n                return len(visited)\n            if (r, c) not in visited:\n                visited.add((r, c))\n                for d in range(1, 4):\n                    new_r, new_c = move(r, c, d)\n                    if is_valid(new_r, new_c):\n                        queue.append((new_r, new_c))\n        return -1\n\n    moves = float('inf')\n    for r in range(1, n + 1):\n        for c in range(1, m + 1):\n            if is_valid(r, c):\n                moves = min(moves, bfs(r, c))\n\n    return str(moves)"
    },
    {
        "number": 1563,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    colors = list(map(int, stdin.split()[2:2+n]))\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2+n:2+2*n])\n        edges.append((a, b))\n\n    def dfs(u, color, visited, color_diversity):\n        visited[u] = True\n        for v, c in edges:\n            if c == color and not visited[v]:\n                dfs(v, color, visited, color_diversity)\n        color_diversity[color] += 1\n\n    color_diversity = [0] * n\n    visited = [False] * n\n\n    max_color = -1\n    max_color_diversity = 0\n\n    for color in colors:\n        if not visited[color-1]:\n            dfs(color, color, visited, color_diversity)\n            if color_diversity[color] > max_color_diversity:\n                max_color = color\n                max_color_diversity = color_diversity[color]\n\n    return str(max_color)"
    },
    {
        "number": 1564,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    if s == t:\n        return -1\n\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == t[j]:\n                k += 1\n                print(i, j)\n                break\n\n    return str(k)"
    },
    {
        "number": 1565,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, n = map(int, stdin.split())\n    n = str(n)\n    if len(n) < l:\n        return \"0\" * (l - len(n)) + str(int(n))\n    else:\n        return str(int(n) + int(n[l:]))"
    },
    {
        "number": 1566,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    zombie_levels = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def is_valid_lair(x1, y1, x2, y2):\n        return 0 <= x1 < x2 <= N and 0 <= y1 < y2 <= N\n\n    def is_valid_level(level):\n        return 0 <= level <= 4\n\n    def count_inside_corners(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_cells(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                count += zombie_levels[j][i]\n        return count\n\n    def count_inside_lair(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level_and_level_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level_and_level_and_level_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level_and_level_and_level_and_level_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level_and_level_and_level_and_level_and_level_and_level(x1, y1, x2, y2):\n        count = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                if zombie_levels[j][i] == 4:\n                    count += 1\n        return count\n\n    def count_inside_lair_and_level_and_level_and_level_and_level_and_level"
    },
    {
        "number": 1567,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 998244353\n\n    def is_stable(a: List[int]) -> bool:\n        p = list(range(1, k + 1))\n        for i in range(k):\n            j = p.index(a[i])\n            p[i], p[j] = p[j], p[i]\n        for i in range(k):\n            for j in range(i + 1, k):\n                if (a[i] * a[j]) % mod!= (a[p[i]] * a[p[j]]) % mod:\n                    return False\n        return True\n\n    count = 0\n    for i in range(1, n + 1):\n        for a in itertools.permutations(range(1, n + 1)):\n            if is_stable(a):\n                count += 1\n                if count % mod == 0:\n                    break\n\n    return str(count % mod)"
    },
    {
        "number": 1568,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B, C, T = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n\n    def read_message(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return A\n        else:\n            return 0\n\n    def read_messages(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n\n        else:\n            return 0\n\n    def read_messages_and_read_message(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_message(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_message(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_message(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_messages(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages_and_read_message(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_messages(t_i) + read_message(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages_and_read_messages(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_messages(t_i) + read_messages(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages_and_read_messages_and_read_message(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_messages(t_i) + read_messages(t_i) + read_message(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages_and_read_messages_and_read_messages(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_messages(t_i) + read_messages(t_i) + read_messages(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages_and_read_messages_and_read_messages_and_read_message(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -= 1\n            return C * n + read_messages(t_i) + read_messages(t_i) + read_messages(t_i) + read_messages(t_i) + read_message(t_i)\n        else:\n            return 0\n\n    def read_messages_and_read_messages_and_read_messages_and_read_messages_and_read_messages_and_read_messages(t_i: int) -> int:\n        nonlocal n, A, B, C\n        if t_i <= T:\n            n -="
    },
    {
        "number": 1569,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def bfs(start: int, visited: set) -> list:\n        queue = [(start, [start])]\n        while queue:\n            city, path = queue.pop(0)\n            if city not in visited:\n                visited.add(city)\n                for neighbor in range(1, n + 1):\n                    if neighbor not in visited and (neighbor, city) not in roads:\n                        queue.append((neighbor, path + [neighbor]))\n        return visited\n\n    def shortest_path(start: int, end: int) -> list:\n        visited = set()\n        queue = [(start, [start])]\n        while queue:\n            city, path = queue.pop(0)\n            if city == end:\n                return path\n            if city not in visited:\n                visited.add(city)\n                for neighbor in range(1, n + 1):\n                    if neighbor not in visited and (neighbor, city) not in roads:\n                        queue.append((neighbor, path + [neighbor]))\n        return []\n\n    def shortest_path_length(start: int, end: int) -> int:\n        visited = set()\n        queue = [(start, [start])]\n        while queue:\n            city, path = queue.pop(0)\n            if city == end:\n                return len(path)\n            if city not in visited:\n                visited.add(city)\n                for neighbor in range(1, n + 1):\n                    if neighbor not in visited and (neighbor, city) not in roads:\n                        queue.append((neighbor, path + [neighbor]))\n        return -1\n\n    def repair_roads(city: int, path: list) -> list:\n        affected_roads = []\n        for i in range(len(path) - 1):\n            if roads[path[i]][1] == city and roads[path[i]][2] == 0:\n                affected_roads.append((path[i], path[i + 1], 1))\n        return affected_roads\n\n    def blow_up_roads(city: int, path: list) -> list:\n        affected_roads = []\n        for i in range(len(path) - 1):\n            if roads[path[i]][1] == city and roads[path[i]][2] == 1:\n                affected_roads.append((path[i], path[i + 1], 0))\n        return affected_roads\n\n    def process_roads(city: int, path: list) -> list:\n        affected_roads = []\n        for i in range(len(path) - 1):\n            if roads[path[i]][1] == city and roads[path[i]][2] == 1:\n                affected_roads.append((path[i], path[i + 1], 1))\n            elif roads[path[i]][1] == city and roads[path[i]][2] == 0:\n                affected_roads.append((path[i], path[i + 1], 0))\n        return affected_roads\n\n    def process_city(city: int, path: list) -> list:\n        affected_roads = []\n        for i in range(len(path) - 1):\n            if roads[path[i]][1] == city and roads[path[i]][2] == 1:\n                affected_roads.append((path[i], path[i + 1], 1))\n            elif roads[path[i]][1] == city and roads[path[i]][2] == 0:\n                affected_roads.append((path[i], path[i + 1], 0))\n        return affected_roads\n\n    def process_city_and_shortest_path(city: int, path: list) -> list:\n        affected_roads = []\n        for i in range(len(path) - 1):\n            if roads[path[i]][1] == city and roads[path[i]][2] == 1:\n                affected_roads.append((path[i], path[i + 1], 1))\n            elif roads[path[i]][1] == city and roads[path[i]][2] == 0:\n                affected_roads.append((path[i], path[i + 1], 0))\n        return affected_roads\n\n    def process_city_and_shortest_path_length(city: int, path: list) -> list:\n        affected_roads ="
    },
    {
        "number": 1570,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, w = map(int, stdin.split())\n    if n >= w:\n        return 0\n    else:\n        return (w - n) // k * k"
    },
    {
        "number": 1571,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T = stdin.split()\n    n, m = len(S), len(T)\n    MOD = 998244353\n\n    def count_operations(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == S[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_magic_spells(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_with_prefix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_without_prefix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1]!= T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_with_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_without_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1]!= T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_with_prefix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_without_prefix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1]!= T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_with_prefix_and_suffix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_without_prefix_and_suffix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1]!= T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_with_prefix_and_suffix_and_suffix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_without_prefix_and_suffix_and_suffix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1]!= T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_with_prefix_and_suffix_and_suffix_and_suffix_and_suffix(A: str) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            if A[i - 1] == T[i - 1]:\n                count += 1\n            else:\n                break\n        return count\n\n    def count_sequences_without_prefix_and_suffix_and_suffix_and_suffix_and_"
    },
    {
        "number": 1572,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    good_segments = []\n    for i in range(n - 1):\n        if a[i] == a[i + 1] - 1 + a[i + 2]:\n            good_segments.append([i, i + 2])\n\n    good_segments.sort(key=lambda x: len(x), reverse=True)\n\n    longest_good_segment = good_segments[0]\n    return str(len(longest_good_segment))"
    },
    {
        "number": 1573,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    friends = []\n    for _ in range(n):\n        m, s = map(int, stdin.split())\n        friends.append((m, s))\n\n    def is_feeling_poor(friend, company):\n        return friend[0] - company >= d\n\n    def max_total_friendship_factor(friends, company):\n        max_friendship_factor = 0\n        for friend in friends:\n            if is_feeling_poor(friend, company):\n                max_friendship_factor = max(max_friendship_factor, friend[1])\n        return max_friendship_factor\n\n    max_total_friendship_factor_list = []\n    for company in range(1, 1000001):\n        max_total_friendship_factor_list.append(max_total_friendship_factor(friends, company))\n\n    return str(max(max_total_friendship_factor_list))"
    },
    {
        "number": 1574,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split()[2:4])\n        pairs.append((a, b))\n\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = pairs[::-1]\n\n    musketeers = []\n    for i in range(n):\n        if i not in [p[0] for p in pairs] and i not in [p[1] for p in pairs]:\n            musketeers.append(i)\n            if len(musketeers) == 3:\n                break\n\n    if len(musketeers) < 3:\n        return \"-1\"\n\n    sum_recognitions = sum(i + 1 for i in musketeers)\n    return str(sum_recognitions)\n"
    },
    {
        "number": 1575,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t_s, t_f, t, n = map(int, stdin.split())\n    t_f -= 1\n    t_s -= 1\n    t_min = min(t_s, t_f)\n    t_max = max(t_s, t_f)\n    t_min_queue = []\n    t_max_queue = []\n    for i in range(n):\n        t_arrive = int(stdin.split()[i])\n        if t_arrive < t_min:\n            t_min_queue.append(t_arrive)\n        elif t_arrive > t_max:\n            t_max_queue.append(t_arrive)\n        else:\n            t_min_queue.append(t_arrive)\n            t_max_queue.append(t_arrive)\n    t_min_queue.sort()\n    t_max_queue.sort()\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_max_queue.append(t_min)\n    t_min_queue.append(t_max)\n    t_"
    },
    {
        "number": 1576,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.strip()\n    s = \"\"\n    for i in range(len(t)):\n        s += t[i]\n        if i % 2 == 0:\n            s += t[i]\n        else:\n            s = s[::-1]\n    return s"
    },
    {
        "number": 1577,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    games = [s[i] == 'A' for i in range(n)]\n    wins = sum(games)\n    if wins == n:\n        return \"Friendship\"\n    elif wins > n // 2:\n        return \"Anton\"\n    else:\n        return \"Danik\""
    },
    {
        "number": 1578,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N < 1 or N > 10**9:\n        return \"Invalid input\"\n\n    P = [i for i in range(1, N+1)]\n    M = [0] * N\n\n    for i in range(N):\n        M[i] = i % P[i]\n\n    return str(max(M))"
    },
    {
        "number": 1579,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dots = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[i+1].split())\n        dots.append((x, y))\n\n    max_operations = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if i!= j and dots[i][0]!= dots[j][0] and dots[i][1]!= dots[j][1]:\n                a, b, c, d = i, j, (dots[i][0] + dots[j][0])//2, (dots[i][1] + dots[j][1])//2\n                if a!= c and b!= d:\n                    max_operations += 1\n\n    return str(max_operations)"
    },
    {
        "number": 1580,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x, y, z = map(int, stdin.split())\n    x, y, z = x - 1, y - 1, z - 1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(i, j, k):\n        if i == n:\n            return 0\n\n        if i == j == k == n:\n            return 1\n\n        if i == j == n:\n            return solve(i + 1, k, n)\n\n        if i == k == n:\n            return solve(i + 1, j, n)\n\n        if j == k == n:\n            return solve(i, j + 1, n)\n\n        if i == j:\n            return solve(i + 1, k, n)\n\n        if i == k:\n            return solve(i + 1, j, n)\n\n        if j == k:\n            return solve(i, j + 1, n)\n\n        if i == j + 1:\n            return solve(i + 1, k, n)\n\n        if i == k + 1:\n            return solve(i + 1, j, n)\n\n        if j == k + 1:\n            return solve(i, j + 1, n)\n\n        if i == j + 2:\n            return solve(i + 1, k, n)\n\n        if i == k + 2:\n            return solve(i + 1, j, n)\n\n        if j == k + 2:\n            return solve(i, j + 1, n)\n\n        if i == j + 3:\n            return solve(i + 1, k, n)\n\n        if i == k + 3:\n            return solve(i + 1, j, n)\n\n        if j == k + 3:\n            return solve(i, j + 1, n)\n\n        if i == j + 4:\n            return solve(i + 1, k, n)\n\n        if i == k + 4:\n            return solve(i + 1, j, n)\n\n        if j == k + 4:\n            return solve(i, j + 1, n)\n\n        if i == j + 5:\n            return solve(i + 1, k, n)\n\n        if i == k + 5:\n            return solve(i + 1, j, n)\n\n        if j == k + 5:\n            return solve(i, j + 1, n)\n\n        if i == j + 6:\n            return solve(i + 1, k, n)\n\n        if i == k + 6:\n            return solve(i + 1, j, n)\n\n        if j == k + 6:\n            return solve(i, j + 1, n)\n\n        if i == j + 7:\n            return solve(i + 1, k, n)\n\n        if i == k + 7:\n            return solve(i + 1, j, n)\n\n        if j == k + 7:\n            return solve(i, j + 1, n)\n\n        if i == j + 8:\n            return solve(i + 1, k, n)\n\n        if i == k + 8:\n            return solve(i + 1, j, n)\n\n        if j == k + 8:\n            return solve(i, j + 1, n)\n\n        if i == j + 9:\n            return solve(i + 1, k, n)\n\n        if i == k + 9:\n            return solve(i + 1, j, n)\n\n        if j == k + 9:\n            return solve(i, j + 1, n)\n\n        if i == j + 10:\n            return solve(i + 1, k, n)\n\n        if i == k + 10:\n            return solve(i + 1, j, n)\n\n        if j == k + 10:\n            return solve(i, j + 1, n)\n\n        if i == j + 11:\n            return solve(i + 1, k, n)\n\n        if i == k + 11:\n            return solve(i + 1, j, n)\n\n        if j == k + 11:\n            return solve(i, j + 1, n)\n\n        if i == j + 12:\n            return solve(i + 1, k, n)\n\n        if i == k + 12:\n            return solve(i + 1, j"
    },
    {
        "number": 1581,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def is_valid(seq):\n        product = 1\n        for i in range(len(seq) - 1):\n            product = (product * (seq[i + 1] - seq[i])) % MOD\n        return product <= N\n\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i * j <= N:\n                count += 1\n\n    count = count % MOD\n    return str(count)"
    },
    {
        "number": 1582,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if i == j:\n                continue\n            if i == j % 10:\n                continue\n            if i % 10 == j:\n                continue\n            if i % 10 == j % 10:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1583,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x = map(int, stdin.split())\n    if x > a**2 * b:\n        return \"Error: x is greater than the volume of the bottle.\"\n\n    def is_valid_angle(angle: float) -> bool:\n        return 0 <= angle <= 90\n\n    def max_angle(a: float, b: float, x: float) -> float:\n        def is_valid_angle(angle: float) -> bool:\n            return 0 <= angle <= 90\n\n        def max_angle_helper(a: float, b: float, x: float, angle: float) -> float:\n            if angle == 90:\n                return 0\n            if angle == 180:\n                return 90\n            if angle == 270:\n                return 180\n\n            if a * b * angle > x:\n                return max_angle_helper(a, b, x, angle + 1)\n            else:\n                return angle\n\n        return max_angle_helper(a, b, x, 0)\n\n    angle = max_angle(a, b, x)\n    if is_valid_angle(angle):\n        return f\"{angle:.6f}\"\n    else:\n        return \"Error: The maximum angle is not valid.\"\n"
    },
    {
        "number": 1584,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    lengths.sort()\n    count = 0\n    for i in range(n - 2):\n        if lengths[i] + lengths[i + 1] > lengths[i + 2]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1585,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    A = [X]\n    for i in range(Y - X):\n        A.append(A[-1] + i + 1)\n    max_length = 1\n    for i in range(1, len(A) - 1):\n        if A[i] % A[i - 1] == 0 and A[i] > A[i - 1]:\n            max_length = max(max_length, i + 1)\n    return str(max_length)"
    },
    {
        "number": 1586,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 2:\n        return \"1\"\n    else:\n        result = 0\n        while n >= 2:\n            result += n // 5\n            n //= 5\n        return str(result)"
    },
    {
        "number": 1587,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    colors = list(stdin.split()[1])\n\n    # Initialize variables\n    min_operations = float('inf')\n    operations = 0\n\n    # Iterate through all possible combinations of swapping and changing colors\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                continue\n\n            # Swap the i-th and j-th stones\n            colors[i], colors[j] = colors[j], colors[i]\n            operations += 1\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations -= 1\n                break\n\n            # Check if the color of the i-th stone is the same as the color of the j-th stone\n            if colors[i] == colors[j]:\n                # If the color of the i-th stone is the same as the color of the j-th stone,\n                # then the disaster has occurred and we need to backtrack\n                colors[i], colors[j] = colors[j], colors[i]\n                operations"
    },
    {
        "number": 1588,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *x = map(int, stdin.split())\n    x = set(x)\n    s = len(x)\n    y = set()\n    while x:\n        y.add(max(x))\n        x.remove(max(x))\n    y = sorted(y)\n    m = len(y)\n    return f\"{m}\\n{' '.join(map(str, y))}\""
    },
    {
        "number": 1589,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    windows = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    flats = [0] * n\n    for i in range(n):\n        for j in range(m):\n            if windows[i][j] == 1:\n                flats[i] += 1\n    return str(sum(flats))"
    },
    {
        "number": 1590,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    MOD = 10**9 + 7\n\n    def f(l, r):\n        b = [a[l - 1 + i] for i in range(r - l + 1)]\n        b.sort()\n        return sum(b[i] * i for i in range(1, r - l + 1))\n\n    total_sum = sum(f(l, r) for l in range(1, n + 1) for r in range(l, n + 1))\n    return str(total_sum % MOD)"
    },
    {
        "number": 1591,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def get_max_students(drink_set):\n        return sum(1 for i in range(n) if a[i] in drink_set)\n\n    max_students = max(get_max_students(set(range(1, k + 1))) for _ in range(k))\n    return str(max_students)"
    },
    {
        "number": 1592,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tasks = []\n    for _ in range(n):\n        t, c = map(int, stdin.split()[1:])\n        tasks.append((t, c))\n    tasks.sort()\n    last_sent = 0\n    max_queue_size = 0\n    for t, c in tasks:\n        if t > last_sent:\n            last_sent = t\n            max_queue_size = max(max_queue_size, c)\n    return f\"{last_sent} {max_queue_size}\""
    },
    {
        "number": 1593,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    locations = []\n    for _ in range(n):\n        x, y, k = map(int, input().split())\n        locations.append((x, y, k))\n\n    def distance(a: tuple, b: tuple) -> float:\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_inside_circle(x: float, y: float, r: float) -> bool:\n        return distance((0, 0), (x, y)) <= r\n\n    def is_inside_circle_or_border(x: float, y: float, r: float) -> bool:\n        return is_inside_circle(x, y, r) or distance((0, 0), (x, y)) <= r\n\n    def is_inside_circle_or_border_and_not_at_origin(x: float, y: float, r: float) -> bool:\n        return is_inside_circle_or_border(x, y, r) and not (x == 0 and y == 0)\n\n    def is_inside_circle_or_border_and_not_at_origin_and_not_at_location(x: float, y: float, r: float, location: tuple) -> bool:\n        return is_inside_circle_or_border_and_not_at_origin(x, y, r) and not (x == location[0] and y == location[1])\n\n    def is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location(x: float, y: float, r: float, location1: tuple, location2: tuple) -> bool:\n        return is_inside_circle_or_border_and_not_at_origin_and_not_at_location(x, y, r, location1) and not (x == location2[0] and y == location2[1])\n\n    def is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location(x: float, y: float, r: float, location1: tuple, location2: tuple, location3: tuple) -> bool:\n        return is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location(x, y, r, location1, location2) and not (x == location3[0] and y == location3[1])\n\n    def is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location(x: float, y: float, r: float, location1: tuple, location2: tuple, location3: tuple, location4: tuple) -> bool:\n        return is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location(x, y, r, location1, location2, location3) and not (x == location4[0] and y == location4[1])\n\n    def is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location(x: float, y: float, r: float, location1: tuple, location2: tuple, location3: tuple, location4: tuple, location5: tuple) -> bool:\n        return is_inside_circle_or_border_and_not_at_origin_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location_and_not_at_location(x, y, r, location1, location2, location3, location4) and not (x == location5[0] and y == location5[1])\n\n    def is_inside_circle_or"
    },
    {
        "number": 1594,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    song_count = [0] * n\n    for i in range(n):\n        for j in range(c[i]):\n            song_count[i] += 1\n\n    result = []\n    for i in range(m):\n        result.append(song_count.index(v.index(i + 1)))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1595,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sum, limit = map(int, stdin.split())\n\n    def lowbit(x):\n        return x & -x\n\n    def find_set(x):\n        while x!= parent[x]:\n            x = parent[x]\n        return x\n\n    def union(x, y):\n        x = find_set(x)\n        y = find_set(y)\n        if x == y:\n            return\n        if rank[x] > rank[y]:\n            parent[y] = x\n        elif rank[x] < rank[y]:\n            parent[x] = y\n        else:\n            parent[y] = x\n            rank[x] += 1\n\n    def is_valid(S):\n        for x in S:\n            if lowbit(x)!= x:\n                return False\n        return True\n\n    def find_set_with_sum(S):\n        for x in S:\n            if lowbit(x) == x:\n                return x\n        return None\n\n    def find_set_with_lowbit(x):\n        while x!= parent[x]:\n            x = parent[x]\n        return x\n\n    def find_set_with_lowbit_and_sum(x):\n        while x!= parent[x]:\n            x = parent[x]\n        return x\n\n    def find_set_with_lowbit_and_sum_and_elements(x):\n        while x!= parent[x]:\n            x = parent[x]\n        return x\n\n    parent = [i for i in range(limit + 1)]\n    rank = [0] * (limit + 1)\n\n    for i in range(1, limit + 1):\n        parent[i] = find_set_with_lowbit(i)\n\n    for i in range(1, limit + 1):\n        if parent[i] == i:\n            continue\n        union(i, parent[i])\n\n    S = []\n    for i in range(1, limit + 1):\n        if parent[i] == i:\n            S.append(i)\n\n    if len(S) == 0:\n        return -1\n\n    if is_valid(S):\n        return len(S)\n\n    for i in range(1, limit + 1):\n        if parent[i] == i:\n            continue\n        S.append(i)\n        if is_valid(S):\n            return len(S)\n        S.pop()\n\n    return -1\n\n\ndef"
    },
    {
        "number": 1596,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.lower()\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'w':\n            count += 1\n        elif s[i] =='m':\n            count += 2\n        else:\n            count += 1\n    return str(count % MOD)"
    },
    {
        "number": 1597,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = stdin.split()[1:]\n    pseudonyms = stdin.split()[n+1:]\n\n    def lcp(a: str, b: str) -> int:\n        i = 0\n        while i < min(len(a), len(b)) and a[i] == b[i]:\n            i += 1\n        return i\n\n    def matching_quality(students: List[str], pseudonyms: List[str]) -> int:\n        relevances = []\n        for i in range(len(students)):\n            relevances.append(lcp(students[i], pseudonyms[i]))\n        return sum(relevances)\n\n    max_quality = 0\n    optimal_matches = []\n    for i in range(len(students)):\n        for j in range(len(pseudonyms)):\n            if lcp(students[i], pseudonyms[j]) == lcp(students[i], pseudonyms[j]):\n                quality = matching_quality([students[i]], [pseudonyms[j]])\n                if quality > max_quality:\n                    max_quality = quality\n                    optimal_matches = [(i+1, j+1)]\n                elif quality == max_quality:\n                    optimal_matches.append((i+1, j+1))\n\n    return str(max_quality) + '\\n' + '\\n'.join(map(str, optimal_matches))"
    },
    {
        "number": 1598,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    s = [int(x) for x in stdin]\n    t = [0] * n\n\n    for i in range(1, n):\n        if s[i] == 0:\n            t[i] = 0\n        else:\n            if t[i - 1] == 0:\n                t[i] = 1\n            else:\n                t[i] = 0\n\n    max_zeros = 0\n    max_length = 0\n    result = \"\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subseq = s[i:j]\n            subseq_t = t[i:j]\n            length = len(subseq)\n            if length > max_length:\n                max_length = length\n                max_zeros = subseq_t.count(0)\n                result = subseq_t\n\n    return \"\".join(str(x) for x in result)\n"
    },
    {
        "number": 1599,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin.strip())\n    m = int(stdin.split('\\n')[1])\n    queries = []\n\n    for i in range(m):\n        l, r = map(int, stdin.split('\\n')[i+2].split())\n        queries.append((l, r))\n\n    for l, r in queries:\n        count = 0\n        for i in range(l, r):\n            if s[i] == '#':\n                count += 1\n        print(count)"
    },
    {
        "number": 1600,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *heights = map(int, stdin.split())\n    heights.sort()\n    blocks = []\n    current_block = []\n    for i, h in enumerate(heights):\n        if i == 0 or h > heights[i - 1] + 1:\n            current_block.append(h)\n            blocks.append(current_block)\n            current_block = []\n    return str(len(blocks))"
    },
    {
        "number": 1601,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = [tuple(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def is_perfectly_balanced(a: int, b: int) -> bool:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        return (x_a <= x_b <= max(x_a, x_b) and\n                y_a <= y_b <= max(y_a, y_b) and\n                z_a <= z_b <= max(z_a, z_b))\n\n    def find_perfectly_balanced_pair() -> tuple[int, int]:\n        for i in range(1, n, 2):\n            for j in range(i + 2, n, 2):\n                if is_perfectly_balanced(i, j):\n                    return i, j\n        return -1, -1\n\n    def find_minimum_bounding_box(a: int, b: int) -> tuple[int, int]:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        return (min(x_a, x_b), min(y_a, y_b), min(z_a, z_b)), (max(x_a, x_b), max(y_a, y_b), max(z_a, z_b))\n\n    def snap(a: int, b: int) -> tuple[int, int]:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        x_c, y_c, z_c = (x_a + x_b) // 2, (y_a + y_b) // 2, (z_a + z_b) // 2\n        return (x_c, y_c, z_c), (x_a, y_a, z_a), (x_b, y_b, z_b)\n\n    def remove_points(a: int, b: int) -> tuple[int, int]:\n        x_a, y_a, z_a = points[a - 1]\n        x_b, y_b, z_b = points[b - 1]\n        x_c, y_c, z_c = (x_a + x_b) // 2, (y_a + y_b) // 2, (z_a + z_b) // 2\n        points[a - 1] = x_c, y_c, z_c\n        points[b - 1] = x_a, y_a, z_a\n        return a + b - 2\n\n    def find_pairs() -> list[tuple[int, int]]:\n        pairs = []\n        for i in range(1, n, 2):\n            for j in range(i + 2, n, 2):\n                if is_perfectly_balanced(i, j):\n                    pairs.append((i, j))\n        return pairs\n\n    pairs = find_pairs()\n    if not pairs:\n        return \"IMPOSSIBLE\"\n\n    a, b = pairs[0]\n    for i in range(2, len(pairs), 2):\n        a, b = remove_points(a, b)\n        a, b = snap(a, b)\n        a, b = remove_points(a, b)\n\n    return f\"{a} {b}\""
    },
    {
        "number": 1602,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def f(x, y):\n        return (x | y) - y\n\n    def max_value(arr):\n        max_val = arr[0]\n        for i in range(1, len(arr)):\n            max_val = max(max_val, f(max_val, arr[i]))\n        return max_val\n\n    max_val = max_value(arr)\n    reordering = []\n    for i in range(n):\n        reordering.append(arr.index(max_val))\n        max_val = max(max_val, f(max_val, arr[i]))\n\n    return \" \".join(map(str, reordering))\n"
    },
    {
        "number": 1603,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *v = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    result = []\n\n    for _ in range(m):\n        type, l, r = map(int, stdin.split())\n        if type == 1:\n            result.append(sum(v[l-1:r]))\n        else:\n            result.append(sum(v[l-1:r]))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1604,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    lamps = [list(map(int, stdin.split())) for _ in range(n)]\n    lamps.sort(key=lambda x: x[0])\n\n    def count_ways(lamps, k):\n        if k == 1:\n            return 1\n        ways = 0\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                if lamps[i][1] < lamps[j][0]:\n                    ways += count_ways(lamps[:i] + lamps[i + 1:] + lamps[j:], k - 1)\n        return ways % 998244353\n\n    return str(count_ways(lamps, k))"
    },
    {
        "number": 1605,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    even_count = 0\n    odd_count = 0\n\n    for i in range(n):\n        for j in range(i + 2, n + 1, 2):\n            substring = stdin[i:j]\n            if substring == substring[::-1]:\n                if len(substring) % 2 == 0:\n                    even_count += 1\n                else:\n                    odd_count += 1\n\n    return f\"{even_count} {odd_count}\""
    },
    {
        "number": 1606,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    A = [[int(x) for x in stdin.split()] for _ in range(n)]\n\n    def flip_row(i: int) -> None:\n        for j in range(n):\n            A[i][j] = 1 - A[i][j]\n\n    def flip_col(j: int) -> None:\n        for i in range(n):\n            A[i][j] = 1 - A[i][j]\n\n    def unusual_square() -> int:\n        return sum(sum(A[i][j] * A[j][i] for j in range(n)) for i in range(n))\n\n    def process_query(query: str) -> None:\n        if query == \"1\":\n            flip_row(int(query.split()[1]))\n        elif query == \"2\":\n            flip_col(int(query.split()[1]))\n        elif query == \"3\":\n            print(unusual_square())\n\n    for _ in range(q):\n        process_query(stdin.split()[0])\n\n    return \"\".join(str(A[i][j]) for i in range(n) for j in range(n))\n"
    },
    {
        "number": 1607,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    grid = [list(map(int, input().split())) for _ in range(2)]\n\n    def dfs(i, j, color, visited):\n        if i < 0 or i >= 2 or j < 0 or j >= n or grid[i][j] == color or (i, j) in visited:\n            return\n        visited.add((i, j))\n        dfs(i - 1, j, color, visited)\n        dfs(i + 1, j, color, visited)\n        dfs(i, j - 1, color, visited)\n        dfs(i, j + 1, color, visited)\n\n    beautiful = 0\n    for i in range(2):\n        for j in range(n):\n            visited = set()\n            dfs(i, j, grid[i][j], visited)\n            if len(visited) == k:\n                beautiful += 1\n\n    return str(beautiful % 998244353)"
    },
    {
        "number": 1608,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_coprime(a):\n        return gcd(a, MOD) == 1\n\n    def count_coprime_subsequences(a):\n        count = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if is_coprime(a[i] * a[j]):\n                    count += 1\n        return count\n\n    return str(count_coprime_subsequences(a))"
    },
    {
        "number": 1609,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nums = list(map(int, stdin.split()[1:]))\n\n    def is_permutation(nums):\n        return len(set(nums)) == len(nums)\n\n    def find_permutation(nums):\n        for i in range(1, n + 1):\n            if nums.count(i) == 0:\n                return [i] + find_permutation(nums[:nums.index(i)] + nums[nums.index(i) + 1:])\n        return []\n\n    if is_permutation(nums):\n        return \" \".join(map(str, nums))\n\n    permutation = find_permutation(nums)\n    return \" \".join(map(str, permutation))"
    },
    {
        "number": 1610,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k >= n:\n        return \"1 \" + \" \".join(map(str, range(1, n + 1)))\n    else:\n        return \" \".join(map(str, range(1, n + 1)))"
    },
    {
        "number": 1611,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    min_length = min(lengths)\n    return str(min_length)"
    },
    {
        "number": 1612,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players = int(stdin.split()[0])\n    cards = []\n    for _ in range(players):\n        card = list(map(int, stdin.split()[1:]))\n        cards.append(card)\n\n    def check_win(card, numbers):\n        for num in numbers:\n            if num in card:\n                card.remove(num)\n            else:\n                return False\n        return True\n\n    def check_win_for_player(player_cards):\n        for card in player_cards:\n            if check_win(card, range(1, 101)):\n                return True\n        return False\n\n    for i in range(players):\n        if check_win_for_player(cards[i]):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 1614,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    min_width = 1\n    for i in range(n):\n        if a[i] > h:\n            min_width += 2\n        else:\n            min_width += 1\n\n    return str(min_width)"
    },
    {
        "number": 1615,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        segments.append([l, r])\n\n    def is_valid(l, r):\n        for i in range(n):\n            if segments[i][0] > l or segments[i][1] < r:\n                return False\n        return True\n\n    def min_moves(l, r):\n        if l == r:\n            return 0\n        if l < r:\n            return 1\n        return 2\n\n    moves = 0\n    while not all(is_valid(l, r) for l, r in segments):\n        moves += 1\n        for i in range(n):\n            if segments[i][0] > l:\n                segments[i][0] -= 1\n            elif segments[i][1] < r:\n                segments[i][1] += 1\n\n    value = sum(1 for l, r in segments if l <= r)\n    return str(moves + value % k)"
    },
    {
        "number": 1616,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_perfect_square(num: int) -> bool:\n        return num == int(num ** 0.5 + 0.5) ** 2\n\n    def count_divisors(num: int) -> int:\n        count = 0\n        for i in range(1, num + 1):\n            if num % i == 0:\n                count += 1\n        return count\n\n    def shortest_subsequence(a: list) -> int:\n        a.sort()\n        count = 1\n        for i in range(1, len(a)):\n            if a[i] == a[i - 1] + 1:\n                count += 1\n            else:\n                count = 1\n        return count\n\n    def shortest_subsequence_product(a: list) -> int:\n        a.sort()\n        count = 1\n        result = 1\n        for i in range(1, len(a)):\n            if a[i] == a[i - 1] + 1:\n                count += 1\n            else:\n                result = min(result, count)\n                count = 1\n        result = min(result, count)\n        return result\n\n    shortest_subsequence_product_square = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            subsequence = a[i - 1:j]\n            if is_perfect_square(subsequence[0] * subsequence[-1]):\n                subsequence_product = subsequence[0] * subsequence[-1]\n                if subsequence_product < shortest_subsequence_product_square:\n                    shortest_subsequence_product_square = subsequence_product\n\n    if shortest_subsequence_product_square == float('inf'):\n        return \"-1\"\n    else:\n        return str(shortest_subsequence_product_square)"
    },
    {
        "number": 1617,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    f = [1]\n    for i in range(2, n + 1):\n        f.append(f[i - 1] + i)\n    return''.join(map(str, f))"
    },
    {
        "number": 1618,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m = len(a) // 2\n    boxes = []\n    for i in range(m):\n        w, h = map(int, stdin.split())\n        boxes.append((w, h))\n\n    def throw_box(box: tuple, stairs: list, index: int) -> int:\n        w, h = box\n        if index == 0:\n            return h\n        if index == len(stairs):\n            return 0\n        if stairs[index] == w:\n            return throw_box(box, stairs, index + 1)\n        if stairs[index] == w + 1:\n            return throw_box(box, stairs, index + 1)\n        return throw_box(box, stairs, index + 1)\n\n    stairs = sorted(set(a))\n    result = []\n    for box in boxes:\n        result.append(throw_box(box, stairs, 0))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1619,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    vertices1 = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.split())\n        vertices1.append((x, y, z))\n    vertices2 = []\n    for _ in range(m):\n        x, y, z = map(int, stdin.split())\n        vertices2.append((x, y, z))\n\n    def is_well_connected(vertices: List[Tuple[int, int, int]]) -> bool:\n        n = len(vertices)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if cross_product(vertices[i], vertices[j], vertices[0]) == 0:\n                    return False\n        return True\n\n    def cross_product(a: Tuple[int, int, int], b: Tuple[int, int, int], c: Tuple[int, int, int]) -> int:\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n\n    return \"YES\" if is_well_connected(vertices1) and is_well_connected(vertices2) else \"NO\""
    },
    {
        "number": 1620,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"a\"\n    elif n == 2:\n        return \"aa\"\n    elif n == 3:\n        return \"bba\"\n    else:\n        for i in range(1, n // 2 + 1):\n            if n % i == 0:\n                return \"a\" * i + \"b\" * (n // i)\n        return \"a\" * n"
    },
    {
        "number": 1621,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()[0]\n    k = int(stdin.split()[1])\n    w = list(map(int, stdin.split()[2:]))\n\n    def f(s: str) -> int:\n        return sum(w[i] * (i + 1) for i in range(len(s)))\n\n    def insert_k(s: str, k: int) -> str:\n        result = \"\"\n        for i in range(len(s) + k):\n            if i < len(s):\n                result += s[i]\n            else:\n                result += \"z\"\n        return result\n\n    max_value = 0\n    for i in range(26):\n        for j in range(i + 1, 27):\n            for c in range(ord('a'), ord('z') + 1):\n                if c == i or c == j:\n                    continue\n                s_i = chr(c)\n                s_j = chr(j)\n                s_ij = insert_k(s_i + s_j, k)\n                value = f(s_ij)\n                if value > max_value:\n                    max_value = value\n\n    return str(max_value)"
    },
    {
        "number": 1622,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(m):\n        t, x, y = map(int, stdin.split())\n        if t == 1:\n            events.append((t, x, y))\n        elif t == 2:\n            events.append((t, x))\n        elif t == 3:\n            events.append((t, x, y, i))\n\n    def dfs(x, visited):\n        if x in visited:\n            return False\n        visited.add(x)\n        for event in events:\n            if event[1] == x:\n                if event[0] == 1:\n                    if dfs(event[2], visited):\n                        return True\n                elif event[0] == 2:\n                    return True\n                elif event[0] == 3:\n                    if event[3] == i:\n                        return True\n        return False\n\n    result = []\n    for event in events:\n        if event[0] == 3:\n            if dfs(event[1], set()):\n                result.append(\"YES\")\n            else:\n                result.append(\"NO\")\n        else:\n            result.append(\"YES\")\n\n    return \" \".join(result)\n"
    },
    {
        "number": 1623,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(a: list) -> bool:\n        distinct_numbers = set(a)\n        return len(distinct_numbers) >= l and len(distinct_numbers) <= r\n\n    def is_even_and_divisible_by_two(a: int) -> bool:\n        return a % 2 == 0 and a % 4 == 0\n\n    def count_sum(a: list) -> int:\n        return sum(a)\n\n    if not is_valid(a):\n        return \"Invalid\"\n\n    min_sum = count_sum(a)\n    max_sum = 0\n\n    for i in range(n):\n        if is_even_and_divisible_by_two(a[i]):\n            min_sum += a[i]\n            max_sum += a[i]\n\n    return str(min_sum) + \" \" + str(max_sum)\n"
    },
    {
        "number": 1624,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def divide(a, b):\n        return [a // b] + divide(a % b, b)\n\n    def sum_of_squares(a):\n        return sum(a[i] ** 2 for i in range(len(a)))\n\n    def min_sum_of_squares(a):\n        groups = divide(a, 2)\n        return sum(sum_of_squares(group) for group in groups)\n\n    def min_lcm(a, b):\n        return lcm(a, b) // gcd(a, b)\n\n    def min_sum_of_squares_lcm(a):\n        groups = divide(a, min_lcm(a[0], a[-1]))\n        return sum(sum_of_squares(group) for group in groups)\n\n    return str(min_sum_of_squares_lcm(a))"
    },
    {
        "number": 1625,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def beauty(matrix, row, col, beauty):\n        if row == n:\n            return beauty\n        if col == n:\n            return beauty + beauty(matrix, row + 1, 0, 0)\n        if matrix[row][col] == a[row * n + col]:\n            return beauty(matrix, row, col + 1, beauty + matrix[row][col])\n        return beauty(matrix, row, col + 1, beauty)\n\n    return str(beauty(matrix, 0, 0, 0))"
    },
    {
        "number": 1626,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_good(block: list, a_i: int, b_i: int) -> bool:\n        return not block[0] == b_i and all(block[i] % a_i == 0 for i in range(1, len(block)))\n\n    def calculate_integer(block: list) -> int:\n        return sum(10 ** i * block[i - 1] for i in range(1, len(block) + 1))\n\n    good_numbers = 0\n    for i in range(1, n + 1):\n        block = [int(digit) for digit in str(i)]\n        if is_good(block, a[i - 1], b[i - 1]):\n            good_numbers += 1\n\n    return str((good_numbers % (10 ** 9 + 7)))\n"
    },
    {
        "number": 1627,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    l = 1\n    r = 2\n    segments = []\n\n    while r <= n:\n        if r - l + 1 % 2 == 0:\n            segments.append((l, r))\n            l += 1\n            r += 1\n        else:\n            l += 1\n            r += 1\n\n    return '\\n'.join(f'{a[i]} {a[j]}' for i, j in segments)"
    },
    {
        "number": 1628,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    i = 0\n    while i < n:\n        if s[i] == 'x' and s[i+1] == 'y':\n            if i == 0:\n                i += 2\n            elif i == n-1:\n                i += 1\n            else:\n                j = i+2\n                while j < n and s[j]!= 'x':\n                    j += 1\n                if j == n:\n                    i += 2\n                else:\n                    s = s[:i] + s[j+1:i+2] + s[i+2:j] + s[j+2:i+2] + s[i+2:j+2] + s[j+2:n]\n                    i = j+2\n        elif s[i] == 'y' and s[i+1] == 'x':\n            if i == 0:\n                i += 2\n            elif i == n-1:\n                i += 1\n            else:\n                j = i+2\n                while j < n and s[j]!= 'y':\n                    j += 1\n                if j == n:\n                    i += 2\n                else:\n                    s = s[:i] + s[j+1:i+2] + s[i+2:j] + s[j+2:i+2] + s[i+2:j+2] + s[j+2:n]\n                    i = j+2\n        else:\n            i += 1\n    return s"
    },
    {
        "number": 1629,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.append(0)\n    a.sort()\n    balls = [0] * n\n    for i in range(n):\n        balls[i] = a[i]\n    return''.join(map(str, balls))"
    },
    {
        "number": 1630,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    clubs = []\n    for _ in range(n):\n        club = stdin.split()[1].upper()\n        clubs.append(club)\n\n    def find_short_name(club):\n        team_name, hometown = clubs[clubs.index(club)]\n        first_letter = team_name[0]\n        second_letter = team_name[1]\n        third_letter = hometown[0]\n        if first_letter == second_letter:\n            if first_letter == third_letter:\n                return first_letter + second_letter + third_letter\n            else:\n                return first_letter + second_letter + hometown[0]\n        else:\n            return first_letter + second_letter + third_letter\n\n    chosen_short_names = set()\n    for club in clubs:\n        short_name = find_short_name(clubs.index(club))\n        if short_name in chosen_short_names:\n            return \"NO\"\n        chosen_short_names.add(short_name)\n\n    return \"YES\\n\" + \"\\n\".join(chosen_short_names)\n"
    },
    {
        "number": 1631,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    names = stdin.split('\\n')\n    names = [name.strip() for name in names]\n    names.sort()\n\n    for i in range(len(names)):\n        for j in range(i + 1, len(names)):\n            if names[i] > names[j]:\n                names[i], names[j] = names[j], names[i]\n                break\n        else:\n            continue\n        break\n\n    if i == len(names) - 1:\n        return 'Impossible'\n\n    result = []\n    for name in names:\n        result.append(name[i])\n\n    return ''.join(result)\n"
    },
    {
        "number": 1632,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    if len(a)!= n:\n        return \"0.0000000000\"\n\n    a = sorted(a)\n    total_a = sum(a)\n    total_b = total_a + 1\n\n    for i in range(n):\n        if a[i] == total_a:\n            return \"0.0000000000\"\n        if a[i] == total_b:\n            return \"0.0740740741\"\n\n    return \"0.0000000000\""
    },
    {
        "number": 1633,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    moves = []\n    for _ in range(k):\n        row, col = map(int, stdin.split())\n        moves.append((row, col))\n\n    def is_valid(row, col):\n        return 0 <= row < n and 0 <= col < m\n\n    def is_black(row, col):\n        return grid[row][col] == 1\n\n    def is_2x2_square(row, col):\n        for i in range(row - 1, row + 2):\n            for j in range(col - 1, col + 2):\n                if not is_valid(i, j) or not is_black(i, j):\n                    return False\n        return True\n\n    grid = [[0] * m for _ in range(n)]\n    for row, col in moves:\n        grid[row - 1][col - 1] = 1\n\n    for i in range(k):\n        row, col = moves[i]\n        if is_valid(row, col) and is_black(row, col):\n            if is_2x2_square(row, col):\n                return i + 1\n\n    return 0"
    },
    {
        "number": 1634,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c_1, c_2, c_3, c_4 = map(int, stdin.split())\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def min_sum(tickets: list[int], buses: int, trolleys: int) -> int:\n        total_tickets = sum(tickets)\n        total_buses = buses + trolleys\n        total_rides = total_tickets // total_buses\n\n        if total_rides == 0:\n            return c_1 * buses + c_2 * trolleys + c_3 * total_buses + c_4 * total_buses\n        elif total_rides == 1:\n            return c_1 + c_2 + c_3 + c_4\n        else:\n            return c_1 + c_2 + c_3 + c_4\n\n    return str(min_sum(a, buses=0, trolleys=0))"
    },
    {
        "number": 1635,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    indices = list(map(int, stdin.split()[1].split()))\n    visited_indices = set()\n    max_index = -1\n\n    for i in range(n):\n        if i == 0:\n            visited_indices.add(indices[i])\n        else:\n            if indices[i] not in visited_indices:\n                visited_indices.add(indices[i])\n                max_index = max(max_index, indices[i])\n\n    return str(max_index)"
    },
    {
        "number": 1636,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n\n    special_values = list(map(int, stdin.split()[-n:]))\n\n    for point in points:\n        for i in range(1, n + 1):\n            if special_values[i - 1] == point[1] - point[0]:\n                print(i)\n                break\n        else:\n            print(\"NO\")\n            return\n\n    return \"YES\"\n"
    },
    {
        "number": 1637,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    u = list(map(int, stdin.split()))\n\n    def find_team(i: int) -> int:\n        if u[i] == i:\n            return i\n        u[i] = find_team(u[i])\n        return u[i]\n\n    def merge_teams(i: int, j: int) -> None:\n        i_team = find_team(i)\n        j_team = find_team(j)\n        if i_team!= j_team:\n            u[i_team] = j_team\n\n    for i in range(n):\n        x[i] += x[i + n]\n\n    teams = [[] for _ in range(n)]\n    for i in range(n):\n        teams[find_team(i)].append(x[i])\n\n    for i in range(m):\n        u[i] -= 1\n        merge_teams(u[i], i)\n\n    return \" \".join(map(str, teams[0])) + \" \" + \" \".join(map(str, teams[1]))"
    },
    {
        "number": 1638,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *m = map(int, stdin.split())\n    m = [max(1, min(mi, n)) for mi in m]\n    m.sort(reverse=True)\n    a = [0] * n\n    for i in range(n):\n        a[i] = m[i]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n                break\n    return''.join(map(str, a))"
    },
    {
        "number": 1639,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            current_length += 1\n        else:\n            max_length = max(max_length, current_length)\n            current_length = 1\n\n    max_length = max(max_length, current_length)\n\n    return str(max_length)"
    },
    {
        "number": 1640,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def d(x, y):\n        if abs(x - y) > 1:\n            return y - x\n        else:\n            return 0\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            result += d(a[i], a[j])\n\n    return str(result)"
    },
    {
        "number": 1641,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s, t = map(int, stdin.split())\n    cars = [list(map(int, stdin.split())) for _ in range(n)]\n    gas_stations = list(map(int, stdin.split()))\n\n    def find_car(car_prices, car_capacities, gas_stations, car_prices_left, car_capacities_left):\n        min_price = float('inf')\n        min_car = None\n\n        for i in range(n):\n            if car_prices_left[i] >= car_prices[i]:\n                continue\n\n            car_prices_left_copy = car_prices_left.copy()\n            car_capacities_left_copy = car_capacities_left.copy()\n\n            car_prices_left_copy[i] -= car_prices[i]\n            car_capacities_left_copy[i] -= 1\n\n            if car_capacities_left_copy[i] >= 0:\n                car_prices_left_copy[i] += car_prices[i]\n                car_capacities_left_copy[i] += 1\n\n                if car_prices_left_copy[i] < min_price:\n                    min_price = car_prices_left_copy[i]\n                    min_car = i\n\n        return min_car\n\n    car_prices = [car[0] for car in cars]\n    car_capacities = [car[1] for car in cars]\n    car_prices_left = [car_capacities[i] for i in range(n)]\n    car_capacities_left = [car_capacities[i] for i in range(n)]\n\n    min_car = find_car(car_prices, car_capacities, gas_stations, car_prices_left, car_capacities_left)\n\n    if min_car is None:\n        return -1\n\n    return str(min_car)\n"
    },
    {
        "number": 1642,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(float, stdin.split()[1:])\n        points.append((x, y))\n    points.append(points[0])\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = distance_between_points(points[i], points[j])\n            if distance > max_distance:\n                max_distance = distance\n\n    return str(max_distance)\n\n\ndef"
    },
    {
        "number": 1643,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    s = [int(x) for x in stdin]\n    t = [0] * n\n\n    for i in range(1, n):\n        if s[i] == 0:\n            t[i] = t[i - 1]\n        else:\n            t[i] = t[i - 1] + 1\n\n    max_length = 0\n    max_index = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if t[j] - t[i] > max_length:\n                max_length = t[j] - t[i]\n                max_index = i\n\n    return ''.join(str(x) for x in s[max_index:max_index + max_length])"
    },
    {
        "number": 1644,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rings = []\n    for i in range(n):\n        a, b, h = map(int, stdin.split()[1:])\n        rings.append((a, b, h))\n    rings.sort(key=lambda x: x[1])\n    max_height = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if rings[i][1] <= rings[j][1]:\n                max_height = max(max_height, rings[i][2] + rings[j][2])\n    return str(max_height)"
    },
    {
        "number": 1645,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good(subarray):\n        return sum(subarray)!= 0\n\n    def count_good_subarrays(arr):\n        count = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                if is_good(arr[i:j]):\n                    count += 1\n        return count\n\n    return str(count_good_subarrays(a))"
    },
    {
        "number": 1646,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def swap_adjacent(s: str) -> str:\n        result = \"\"\n        for i in range(len(s) - 1):\n            result += s[i] + s[i + 1]\n        return result\n\n    def replace_11(s: str) -> str:\n        result = \"\"\n        for i in range(len(s)):\n            if s[i] == \"1\" and i + 1 < len(s) and s[i + 1] == \"1\":\n                result += \"1\"\n            else:\n                result += s[i]\n        return result\n\n    def val(s: str) -> int:\n        return int(s, 2)\n\n    def min_correct_string(s: str, operations: list) -> str:\n        for operation in operations:\n            if operation == \"swap_adjacent\":\n                s = swap_adjacent(s)\n            elif operation == \"replace_11\":\n                s = replace_11(s)\n        return s\n\n    def is_correct(s: str) -> bool:\n        return s.count(\"0\") == 0 and s.count(\"1\") == len(s) and s.startswith(\"0\")\n\n    def is_less(a: str, b: str) -> bool:\n        return val(a) < val(b)\n\n    def min_correct_string_helper(s: str, operations: list) -> str:\n        if is_correct(s):\n            return s\n        for i in range(len(operations)):\n            if is_less(s, min_correct_string(s, operations[:i] + operations[i + 1:])):\n                return min_correct_string(s, operations[:i] + operations[i + 1:])\n        return s\n\n    return min_correct_string_helper(s, [])\n"
    },
    {
        "number": 1647,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    v_pullover = stdin.split()[1]\n    t_shirt = stdin.split()[2]\n\n    def spell_cost(spell: str) -> int:\n        return sum(ord(c) - ord('a') + 1 for c in spell)\n\n    def spell_transform(spell: str, t_shirt: str, v_pullover: str) -> str:\n        result = ''\n        for c in t_shirt:\n            if c in spell:\n                result += t_shirt[t_shirt.index(c):t_shirt.index(c) + 2]\n            else:\n                result += c\n        for c in v_pullover:\n            if c in spell:\n                result += v_pullover[v_pullover.index(c):v_pullover.index(c) + 2]\n            else:\n                result += c\n        return result\n\n    def min_mana(t_shirt: str, v_pullover: str) -> int:\n        min_cost = float('inf')\n        for i in range(26):\n            for j in range(26):\n                for k in range(26):\n                    cost = spell_cost(('a' + chr(i)).join(('b' + chr(j)).join(('c' + chr(k)).join(t_shirt)))) + spell_cost(('a' + chr(i)).join(('b' + chr(j)).join(('c' + chr(k)).join(v_pullover))))\n                    min_cost = min(min_cost, cost)\n        return min_cost\n\n    def spells_for_letterings(t_shirt: str, v_pullover: str) -> list[str]:\n        result = []\n        for i in range(26):\n            for j in range(26):\n                for k in range(26):\n                    spell = ('a' + chr(i)).join(('b' + chr(j)).join(('c' + chr(k)).join(t_shirt)))\n                    if spell_transform(spell, t_shirt, v_pullover) == t_shirt:\n                        result.append(spell)\n        return result\n\n    t_shirt_cost = min_mana(t_shirt, v_pullover)\n    spells = spells_for_letterings(t_shirt, v_pullover)\n    spells.sort(key=lambda x: spell_cost(x))\n    return str(t_shirt_cost) + '\\n' +''.join(spells)"
    },
    {
        "number": 1648,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(n: int, k: int) -> int:\n        if n == 0:\n            return 1\n        if n == 1:\n            return k\n        if n == 2:\n            return k * (k - 1) // 2\n        if n == 3:\n            return k * (k - 1) * (k - 2) // 6\n        if n == 4:\n            return k * (k - 1) * (k - 2) * (k - 3) // 24\n        if n == 5:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) // 120\n        if n == 6:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) // 720\n        if n == 7:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) // 5040\n        if n == 8:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) // 40320\n        if n == 9:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) // 362880\n        if n == 10:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) // 3628800\n        if n == 11:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) // 39916800\n        if n == 12:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11) // 479001600\n        if n == 13:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11) * (k - 12) // 6227020800\n        if n == 14:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * (k - 11) * (k - 12) * (k - 13) // 87178291200\n        if n == 15:\n            return k * (k - 1) * (k - 2) * (k - 3) * (k - 4) * (k - 5) * (k - 6) * (k - 7) * (k - 8) * (k - 9) * (k - 10) * ("
    },
    {
        "number": 1649,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cookies = list(map(int, stdin.split()))\n    A, B, C, D = cookies\n\n    if A + B + C + D == 10**8:\n        return \"Yes\"\n    elif A + B + C + D == 10**7:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 1650,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin)\n    MOD = 10**9 + 7\n\n    def count_pairs(L):\n        count = 0\n        for a in range(1, L):\n            for b in range(a + 1, L):\n                if a + b <= L and (a + b == a ^ b):\n                    count += 1\n        return count\n\n    return str(count_pairs(L) % MOD)"
    },
    {
        "number": 1651,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, p = map(int, stdin.split())\n    if s + p == 2 * p:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1652,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    T = \"\"\n    for i in range(len(S)):\n        if S[i] == \"e\":\n            T += \"erase\"\n        elif S[i] == \"d\":\n            T += \"dream\"\n        else:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 1653,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T = stdin.split('\\n')\n    S, T = S.strip(), T.strip()\n    Q = int(stdin.split('\\n')[2])\n\n    def is_possible(s: str, t: str) -> bool:\n        def transition(s: str, t: str) -> str:\n            if s == 'A':\n                return 'BC'\n            elif s == 'B':\n                return 'AC'\n            elif s == 'C':\n                return 'AB'\n            else:\n                return ''\n\n        def is_valid(s: str, t: str) -> bool:\n            if len(s) == 0:\n                return len(t) == 0\n            elif s[0] == 'A':\n                return is_valid(s[1:], t + transition(s[0], t[0]))\n            elif s[0] == 'B':\n                return is_valid(s[1:], t + transition(s[0], t[0]))\n            elif s[0] == 'C':\n                return is_valid(s[1:], t + transition(s[0], t[0]))\n            else:\n                return False\n\n        return is_valid(s, t)\n\n    result = [str(is_possible(S[a-1:b], T[c-1:d])) for a, b, c, d in [tuple(map(int, line.split())) for line in stdin.split('\\n')[3:]]]\n    return ''.join(result)"
    },
    {
        "number": 1654,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n    s_suitability = 0\n    t_suitability = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            s[i] = chr(ord('a') + (i % 26))\n            s_suitability += 1\n    for i in range(len(t)):\n        if t[i] == '?':\n            t[i] = chr(ord('a') + (i % 26))\n            t_suitability += 1\n    s_suitability += t_suitability\n    return ''.join(s)"
    },
    {
        "number": 1655,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    alive = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lengths[i] < lengths[j] and j < i:\n                alive += 1\n    return str(alive)"
    },
    {
        "number": 1656,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    v_count = s.count(\"v\")\n    o_count = s.count(\"o\")\n    if v_count % 2 == 0 and o_count % 2 == 0:\n        return str(v_count // 2)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 1657,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    devices = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def find_max_time(device: list) -> float:\n        time = 0\n        power = device[1]\n        while power > 0:\n            time += 1\n            power -= p\n        return time\n\n    max_time = 0\n    for device in devices:\n        max_time = max(max_time, find_max_time(device))\n\n    if max_time == 0:\n        return -1\n    else:\n        return str(max_time)\n"
    },
    {
        "number": 1658,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    MOD = 10**9 + 7\n\n    def dfs(node, depth, parent):\n        nonlocal count\n        if depth == x:\n            count += 1\n        for i in range(n):\n            if d[node][i] <= x and i!= parent:\n                dfs(i, depth + 1, node)\n\n    count = 0\n    dfs(0, 0, -1)\n    return str(count % MOD)"
    },
    {
        "number": 1659,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    ice_cream_packs = [0] * n\n    distressed_kids = 0\n\n    for line in stdin.split('\\n')[1:]:\n        if line[0] == '+':\n            d = int(line[1:])\n            ice_cream_packs[d - 1] += 1\n        else:\n            d = int(line[1:])\n            if ice_cream_packs[d - 1] >= d:\n                ice_cream_packs[d - 1] -= d\n            else:\n                distressed_kids += 1\n\n    return f\"{sum(ice_cream_packs)} {distressed_kids}\""
    },
    {
        "number": 1660,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    def dfs(u, visited, path, max_edges):\n        visited[u] = True\n        for v, w in graph[u]:\n            if not visited[v]:\n                if w > path[-1][1]:\n                    path.append((v, w))\n                    dfs(v, visited, path, max_edges)\n                    path.pop()\n                elif w == path[-1][1]:\n                    max_edges = max(max_edges, len(path))\n                    path.append((v, w))\n                    dfs(v, visited, path, max_edges)\n                    path.pop()\n\n    max_edges = 0\n    visited = [False] * (n + 1)\n    for u in range(1, n + 1):\n        if not visited[u]:\n            path = [(u, 0)]\n            dfs(u, visited, path, max_edges)\n\n    return str(max_edges)"
    },
    {
        "number": 1661,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n\n    bills = [0] * m\n    bills[0] = a[0]\n\n    count = 0\n    for i in range(n):\n        if bills[0] >= c[i]:\n            bills[0] -= c[i]\n            count += 1\n        else:\n            bills[0] = 0\n            bills[1] = a[1]\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1662,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, *b = map(int, stdin.split())\n    b.sort()\n    stairs = []\n    for i in range(1, len(b)):\n        if b[i] - b[i - 1] == 1:\n            stairs.append(b[i])\n    return str(len(stairs)) + \" \" + \" \".join(map(str, stairs))"
    },
    {
        "number": 1663,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n\n    def remove_digits(price: int) -> int:\n        while price > 0:\n            digit = price % 10\n            price //= 10\n            if digit!= 0:\n                return price\n        return 0\n\n    def sum_of_prices(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices(start + 1, end) + sum_of_prices(start, end - 1)) % MOD\n\n    def sum_of_prices_with_vova(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_with_vova(start + 1, end) + sum_of_prices_with_vova(start, end - 1)) % MOD\n\n    def sum_of_prices_without_vova(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_without_vova(start + 1, end) + sum_of_prices_without_vova(start, end - 1)) % MOD\n\n    def sum_of_prices_with_vova_and_without_vova(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_with_vova_and_without_vova(start + 1, end) + sum_of_prices_with_vova_and_without_vova(start, end - 1)) % MOD\n\n    def sum_of_prices_with_vova_and_without_vova_and_remove_digits(start: int, end: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_with_vova_and_without_vova_and_remove_digits(start + 1, end) + sum_of_prices_with_vova_and_without_vova_and_remove_digits(start, end - 1)) % MOD\n\n    def sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper(start: int, end: int, price: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper(start + 1, end, price) + sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper(start, end - 1, price)) % MOD\n\n    def sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_with_vova(start: int, end: int, price: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_with_vova(start + 1, end, price) + sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_with_vova(start, end - 1, price)) % MOD\n\n    def sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_without_vova(start: int, end: int, price: int) -> int:\n        if start > end:\n            return 0\n        if start == end:\n            return start\n        return (sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_without_vova(start + 1, end, price) + sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_without_vova(start, end - 1, price)) % MOD\n\n    def sum_of_prices_with_vova_and_without_vova_and_remove_digits_helper_without_vova_and_remove_digits(start: int,"
    },
    {
        "number": 1664,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    program = stdin.split('\\n')[1:]\n    lines = []\n    for line in program:\n        if line.startswith('c='):\n            lvalue, rvalue = line.split('=')\n            lines.append(f'{lvalue}={rvalue}')\n        elif line.startswith('d'):\n            lvalue, arg1, op, arg2 = line.split('=')\n            lines.append(f'{lvalue}={arg1}{op}{arg2}')\n        elif line.startswith('res='):\n            lvalue, rvalue = line.split('=')\n            lines.append(f'{lvalue}={rvalue}')\n        elif line.startswith('tmp='):\n            lvalue, arg1, op, arg2 = line.split('=')\n            lines.append(f'{lvalue}={arg1}{op}{arg2}')\n        else:\n            raise ValueError('Invalid line format')\n\n    res = lines[0]\n    for line in lines[1:]:\n        res = line.replace('res=', f'res={res}')\n\n    k = 0\n    for line in lines:\n        if line.startswith('res='):\n            k += 1\n            if k == 2:\n                break\n\n    return f'{k}\\n{res}'\n"
    },
    {
        "number": 1665,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n\n    def MEX(u, v):\n        return max(MEX(u, w) + 1 for w in graph[u] if w!= v)\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    result = []\n    for u in range(1, n):\n        for v in range(u + 1, n):\n            result.append(MEX(u, v))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1666,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n\n    def count_heads(x: int, y: int) -> int:\n        return sum(1 for _ in range(x) if random.choice([True, False]))\n\n    def count_outcomes(x: int, y: int) -> int:\n        return count_heads(x, y) + count_heads(y, x)\n\n    outcomes = []\n    for i in range(1, count_outcomes(x, y) + 1):\n        heads_x = count_heads(x, i)\n        heads_y = count_heads(y, i)\n        if heads_x >= a and heads_y >= b:\n            outcomes.append((heads_x, heads_y))\n\n    outcomes.sort()\n    print(len(outcomes))\n    for i, (heads_x, heads_y) in enumerate(outcomes):\n        print(f\"{heads_x} {heads_y}\")\n\n    return \"\"\n"
    },
    {
        "number": 1667,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    distances = list(map(int, stdin.split()[1:]))\n\n    k = 0\n    current_location = 0\n    current_length = 0\n\n    for distance in distances:\n        if distance < k:\n            current_length += 1\n        else:\n            if current_length > 0:\n                k = min(k, current_length)\n            current_location += 1\n            current_length = 1\n\n    if current_length > 0:\n        k = min(k, current_length)\n\n    return str(k)"
    },
    {
        "number": 1668,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        p = [int(x) for x in stdin.split('\\n')[2:2+n]]\n        k = 0\n        for i in range(n):\n            for j in range(4):\n                if p[i] == j:\n                    break\n            else:\n                k += 1\n                p[i] = (j + 1) % 10\n        print(k)\n        for i in range(n):\n            print(p[i])"
    },
    {
        "number": 1669,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    reserved_tokens = set(stdin.split()[1:])\n    lines = stdin.split('\\n')[3:]\n\n    def parse_line(line: str) -> List[str]:\n        tokens = []\n        i = 0\n        while i < len(line):\n            if line[i] =='':\n                i += 1\n                continue\n            if line[i] == '#':\n                i += 1\n                while i < len(line) and line[i]!= '\\n':\n                    i += 1\n                continue\n            if line[i].isdigit():\n                j = i\n                while j < len(line) and line[j].isdigit():\n                    j += 1\n                tokens.append(line[i:j])\n                i = j\n            elif line[i].isalpha():\n                j = i\n                while j < len(line) and (line[j].isalpha() or line[j].isdigit() or line[j] == '_'):\n                    j += 1\n                tokens.append(line[i:j])\n                i = j\n            else:\n                tokens.append(line[i])\n                i += 1\n        return tokens\n\n    def minify_line(tokens: List[str]) -> str:\n        def is_reserved(token: str) -> bool:\n            return token in reserved_tokens\n\n        def is_number(token: str) -> bool:\n            return token.isdigit()\n\n        def is_word(token: str) -> bool:\n            return token.isalpha()\n\n        def is_operator(token: str) -> bool:\n            return token in '+-*/%&|^~<>='\n\n        def is_separator(token: str) -> bool:\n            return token in ',;{}()'\n\n        def is_literal(token: str) -> bool:\n            return token in 'true false null undefined'\n\n        def is_reserved_or_number(token: str) -> bool:\n            return is_reserved(token) or is_number(token)\n\n        def is_reserved_or_word(token: str) -> bool:\n            return is_reserved(token) or is_word(token)\n\n        def is_reserved_or_operator(token: str) -> bool:\n            return is_reserved(token) or is_operator(token)\n\n        def is_reserved_or_separator(token: str) -> bool:\n            return is_reserved(token) or is_separator(token)\n\n        def is_reserved_or_literal(token: str) -> bool:\n            return is_reserved(token) or is_literal(token)\n\n        def is_reserved_or_number_or_word(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_word(token)\n\n        def is_reserved_or_number_or_operator(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_operator(token)\n\n        def is_reserved_or_number_or_separator(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_separator(token)\n\n        def is_reserved_or_number_or_literal(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_literal(token)\n\n        def is_reserved_or_number_or_word_or_operator(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_word(token) or is_operator(token)\n\n        def is_reserved_or_number_or_word_or_separator(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_word(token) or is_separator(token)\n\n        def is_reserved_or_number_or_word_or_literal(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_word(token) or is_literal(token)\n\n        def is_reserved_or_number_or_word_or_operator_or_separator(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_word(token) or is_operator(token) or is_separator(token)\n\n        def is_reserved_or_number_or_word_or_operator_or_separator_or_literal(token: str) -> bool:\n            return is_reserved(token) or is_number(token) or is_word(token) or is_operator(token) or is_separator(token)\n\n        def is_reserved_or_"
    },
    {
        "number": 1670,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    team_home, team_away = stdin.split()\n    n = int(stdin.split()[1])\n    fouls = []\n\n    for _ in range(n):\n        t, h_or_a, m, y_or_r = stdin.split()\n        fouls.append((int(t), h_or_a == 'h', int(m), y_or_r == 'y'))\n\n    red_cards = []\n    for foul in fouls:\n        if foul[3]:\n            red_cards.append(foul)\n\n    result = []\n    for red_card in red_cards:\n        for foul in fouls:\n            if foul[0] == red_card[0] and foul[1] == red_card[1] and foul[2] == red_card[2]:\n                result.append(f\"{team_home if foul[1] else team_away} {red_card[2]} {red_card[2]}\")\n                break\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1671,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *m = map(int, stdin.split())\n    m = [0] + m\n    m.sort(reverse=True)\n    a, b = 0, n - 1\n    while a < b:\n        if m[a] - m[b] < 0:\n            a += 1\n        else:\n            b -= 1\n    return str(a + 1)"
    },
    {
        "number": 1672,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    magnets = []\n    for i in range(n):\n        magnet = list(stdin.split()[i+1])\n        magnets.append(magnet)\n\n    groups = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if magnets[i][0] == magnets[j][0] and magnets[i][1] == magnets[j][1]:\n                groups += 1\n\n    return str(groups)"
    },
    {
        "number": 1673,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_beauty(i, j):\n        return min(abs(a[i] - a[j]), abs(a[j] - a[i]))\n\n    def sum_beauty(i, j):\n        return sum(min_beauty(i, k) for k in range(i, j))\n\n    def sum_beauty_subsequences(i, j):\n        return sum(sum_beauty(i, k) for k in range(i, j))\n\n    return str((sum_beauty_subsequences(0, n) - sum_beauty_subsequences(0, k)) % 998244353)"
    },
    {
        "number": 1674,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n    s = stdin.split()[2]\n\n    def brutality(hits):\n        hits.sort()\n        total_damage = 0\n        consecutive_presses = 0\n        for i, hit in enumerate(hits):\n            if i > 0 and hits[i] == hits[i - 1] + 1:\n                consecutive_presses += 1\n            else:\n                consecutive_presses = 0\n            total_damage += hit\n            if consecutive_presses > k:\n                return False\n        return total_damage\n\n    def skip_hits(hits):\n        hits.sort()\n        skipped_hits = []\n        for i, hit in enumerate(hits):\n            if i > 0 and hits[i] == hits[i - 1] + 1:\n                skipped_hits.append(hit)\n        return skipped_hits\n\n    skipped_hits = skip_hits(a)\n    if not skipped_hits:\n        return \"0\"\n\n    max_damage = 0\n    for hit in skipped_hits:\n        a.remove(hit)\n        max_damage = max(max_damage, brutality(a))\n        a.append(hit)\n\n    return str(max_damage)"
    },
    {
        "number": 1675,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    teams = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        teams.append((x, y))\n    teams.sort(key=lambda x: x[0])\n    result = []\n    for i in range(n):\n        home_games = 0\n        away_games = 0\n        for j in range(i + 1, n):\n            if teams[i][0] == teams[j][0]:\n                home_games += 1\n            else:\n                away_games += 1\n        result.append(f\"{home_games} {away_games}\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 1676,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    queries = []\n    for _ in range(n):\n        t, d = map(int, stdin.split())\n        queries.append((t, d))\n\n    queries.sort()\n    server_time = 0\n    result = []\n\n    for t, d in queries:\n        if server_time + d <= t:\n            server_time += d\n            result.append(server_time)\n        else:\n            result.append(-1)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1677,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    b = list(map(int, stdin.split()[1:]))\n\n    def almost_arithmetical_progression(b: list) -> int:\n        p = b[0]\n        q = 1\n        for i in range(1, len(b)):\n            if b[i] - b[i - 1] == -1:\n                p = b[i]\n                q += 1\n            else:\n                break\n        return p, q\n\n    def longest_subsequence(b: list) -> int:\n        p, q = almost_arithmetical_progression(b)\n        s = [p]\n        for i in range(1, len(b)):\n            if b[i] - b[i - 1] == -1:\n                s.append(p - 1 + (1 - 2 ** (i - 1)) + 1 * q)\n                p = p - 1 + (1 - 2 ** (i - 1)) + 1 * q\n                q += 1\n            else:\n                s.append(p)\n        return len(s)\n\n    return str(longest_subsequence(b))\n"
    },
    {
        "number": 1678,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def binary_search(left, right):\n        while left < right:\n            mid = (left + right) // 2\n            if sum(a[left:mid]) < t:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    count = 0\n    for i in range(n):\n        count += binary_search(i + 1, n) - binary_search(i, n)\n\n    return str(count)"
    },
    {
        "number": 1679,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = s.lstrip('1')\n    decoded = 0\n    for i in range(n):\n        decoded += int(s[-i-1]) * (10**(n-i-1))\n    return str(decoded)"
    },
    {
        "number": 1680,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bin(a[i])[2:].count('1')!= bin(a[j])[2:].count('1'):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1681,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    colors = set(stdin.split()[1])\n    sheets = set(stdin.split()[0])\n\n    if len(colors) == 1:\n        return \"1\"\n\n    if len(sheets) == 1:\n        return \"0\"\n\n    max_area = 0\n    for color in colors:\n        for sheet in sheets:\n            if color == sheet:\n                continue\n            area = 1\n            while area <= 1:\n                area *= 2\n            max_area = max(max_area, area)\n\n    return str(max_area)"
    },
    {
        "number": 1682,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def min_cost(prices: list, k: int) -> int:\n        prices.sort()\n        total_cost = 0\n        for i in range(k):\n            total_cost += prices[i]\n        return total_cost\n\n    return str(min_cost(a, k) + min_cost(b, n - k))"
    },
    {
        "number": 1683,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 998244353\n\n    def f(x, y):\n        if p >= q:\n            return x * y % MOD\n        else:\n            return y * x % MOD\n\n    def g(x, y):\n        if p >= q:\n            return x * y\n        else:\n            return y * x\n\n    def h(x, y):\n        if p >= q:\n            return x + y\n        else:\n            return y + x\n\n    def k(x, y):\n        if p >= q:\n            return x - y\n        else:\n            return y - x\n\n    def l(x, y):\n        if p >= q:\n            return x // y\n        else:\n            return y // x\n\n    def m(x, y):\n        if p >= q:\n            return x % y\n        else:\n            return y % x\n\n    def n(x, y):\n        if p >= q:\n            return x ** y\n        else:\n            return y ** x\n\n    def o(x, y):\n        if p >= q:\n            return x * y + y * x\n        else:\n            return y * x + x * y\n\n    def p(x, y):\n        if p >= q:\n            return x * y - y * x\n        else:\n            return y * x - x * y\n\n    def q(x, y):\n        if p >= q:\n            return x // y + y // x\n        else:\n            return y // x + x // y\n\n    def r(x, y):\n        if p >= q:\n            return x % y + y % x\n        else:\n            return y % x + x % y\n\n    def s(x, y):\n        if p >= q:\n            return x ** y + y ** x\n        else:\n            return y ** x + x ** y\n\n    def t(x, y):\n        if p >= q:\n            return x * y - y * x + x * y\n        else:\n            return y * x - x * y + x * y\n\n    def u(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x\n        else:\n            return y * x - x * y + x * y + y * x\n\n    def v(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y\n        else:\n            return y * x - x * y + x * y + y * x + x * y\n\n    def w(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y + y * x\n        else:\n            return y * x - x * y + x * y + y * x + x * y + y * x\n\n    def x(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y + y * x + x * y\n        else:\n            return y * x - x * y + x * y + y * x + x * y + y * x + x * y\n\n    def y(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y + y * x + x * y + y * x\n        else:\n            return y * x - x * y + x * y + y * x + x * y + y * x + x * y + y * x\n\n    def z(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y + y * x + x * y + y * x + x * y\n        else:\n            return y * x - x * y + x * y + y * x + x * y + y * x + x * y + y * x + x * y\n\n    def a(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y + y * x + x * y + y * x + x * y + y * x\n        else:\n            return y * x - x * y + x * y + y * x + x * y + y * x + x * y + y * x + x * y + y * x\n\n    def b(x, y):\n        if p >= q:\n            return x * y - y * x + x * y + y * x + x * y + y * x + x * y + y * x +"
    },
    {
        "number": 1684,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = list(map(int, stdin.split()))\n    points.sort()\n    points.append(points[0])\n    points.append(points[-1])\n\n    segments = []\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        segments.append((a, b))\n\n    def is_rotationally_symmetrical(points, segments):\n        for i in range(len(points) - 1):\n            a, b = points[i], points[i + 1]\n            for x, y in segments:\n                if (x == a and y == b) or (x == b and y == a):\n                    return False\n        return True\n\n    return \"Yes\" if is_rotationally_symmetrical(points, segments) else \"No\""
    },
    {
        "number": 1685,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    queries = []\n    for _ in range(q):\n        u, s = map(str, stdin.split())\n        queries.append((u, s))\n\n    def dfs(node, path, depth):\n        if node == n:\n            return depth\n        if s[node] == 'L':\n            return dfs(2 * node, path + 'L', depth + 1)\n        if s[node] == 'R':\n            return dfs(2 * node + 1, path + 'R', depth + 1)\n        if s[node] == 'U':\n            return dfs(parent[node], path + 'U', depth + 1)\n\n    parent = [-1] * (n + 1)\n    for i in range(1, n + 1):\n        parent[i] = (i - 1) // 2\n\n    result = []\n    for u, s in queries:\n        depth = dfs(int(u), '', 0)\n        result.append(depth)\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 1686,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    ip_addresses = [tuple(map(int, ip.split('.'))) for ip in stdin.split('\\n')[1:]]\n\n    subnet_masks = []\n    for i in range(32):\n        subnet_mask = 0\n        for j in range(4):\n            subnet_mask |= (1 << (31 - i - j))\n        subnet_masks.append(subnet_mask)\n\n    subnet_mask_count = {}\n    for ip_address in ip_addresses:\n        for subnet_mask in subnet_masks:\n            if (ip_address & subnet_mask) == ip_address:\n                subnet_mask_count[subnet_mask] = subnet_mask_count.get(subnet_mask, 0) + 1\n\n    min_subnet_mask_count = min(subnet_mask_count.values())\n    min_subnet_mask = [subnet_mask for subnet_mask, count in subnet_mask_count.items() if count == min_subnet_mask_count][0]\n\n    for ip_address in ip_addresses:\n        if (ip_address & min_subnet_mask) == ip_address:\n            return f'{min_subnet_mask}.0.0.0'\n\n    return -1"
    },
    {
        "number": 1687,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        if arr[i] % n == 0:\n            return str(arr[i])\n\n    return \"-1\""
    },
    {
        "number": 1688,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    x = max(a)\n    c = [0] * n\n\n    for i in range(n):\n        if a[i] < x / 2:\n            c[i] = -1\n        else:\n            c[i] = 1\n\n    return \" \".join(map(str, c))"
    },
    {
        "number": 1689,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    rows = []\n    for i in range(n):\n        row = list(stdin.split('\\n')[i+1])\n        rows.append(row)\n\n    def find_neighbours(row: list, seat: str) -> list:\n        neighbours = []\n        for i in range(len(row)):\n            if row[i] == seat:\n                neighbours.append(row[i+1])\n        return neighbours\n\n    def find_empty_neighbours(row: list) -> list:\n        empty_neighbours = []\n        for seat in row:\n            if seat == 'O':\n                neighbours = find_neighbours(row, seat)\n                if len(neighbours) == 2:\n                    empty_neighbours.append(neighbours)\n        return empty_neighbours\n\n    def find_empty_neighbours_pairs(rows: list) -> list:\n        empty_neighbours_pairs = []\n        for row in rows:\n            empty_neighbours = find_empty_neighbours(row)\n            if empty_neighbours:\n                empty_neighbours_pairs.append(empty_neighbours)\n        return empty_neighbours_pairs\n\n    def find_neighbours_pairs(rows: list) -> list:\n        neighbours_pairs = []\n        for row in rows:\n            for i in range(len(row)-1):\n                neighbours = find_neighbours(row, row[i])\n                if neighbours:\n                    neighbours_pairs.append((row[i], neighbours))\n        return neighbours_pairs\n\n    empty_neighbours_pairs = find_empty_neighbours_pairs(rows)\n    neighbours_pairs = find_neighbours_pairs(rows)\n\n    if empty_neighbours_pairs:\n        return 'YES'\n    elif neighbours_pairs:\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 1690,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def buy(x):\n        for i in range(n):\n            if x[i] > 0:\n                return False\n        return True\n\n    def max_buy(x):\n        if buy(x):\n            return max(x)\n        else:\n            return 0\n\n    return str(max_buy(a))"
    },
    {
        "number": 1691,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if gcd(n, k)!= 1:\n        return \"Invalid input\"\n\n    sections = [1]\n    for i in range(1, n):\n        if i % k == 0:\n            sections.append(i + 1)\n\n    return \" \".join(map(str, sections))\n\n\ndef"
    },
    {
        "number": 1692,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] % 4 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1693,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *m = map(int, stdin.split())\n    m = [max(1, min(mi, 10**9)) for mi in m]\n    m.sort(reverse=True)\n    a = [0] * n\n    for i in range(n):\n        a[i] = m[i]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n                break\n    return''.join(map(str, a))"
    },
    {
        "number": 1694,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, f = map(int, stdin.split())\n    steps = []\n    for _ in range(m):\n        t, l, r = map(int, stdin.split())\n        steps.append((t, l, r))\n\n    def can_pass(spy, note):\n        return spy!= s and spy!= f and spy!= note\n\n    def can_watch(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1\n\n    def can_pass_to_neighbour(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note - 1\n\n    def can_pass_to_neighbour_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1\n\n    def can_pass_to_neighbour_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note\n\n    def can_pass_to_neighbour_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note and spy!= note + 2 and spy!= note - 2\n\n    def can_pass_to_neighbour_or_self_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note and spy!= note + 2 and spy!= note - 2 and spy!= note + 3 and spy!= note - 3\n\n    def can_pass_to_neighbour_or_self_or_self_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note and spy!= note + 2 and spy!= note - 2 and spy!= note + 3 and spy!= note - 3 and spy!= note + 4 and spy!= note - 4\n\n    def can_pass_to_neighbour_or_self_or_self_or_self_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note and spy!= note + 2 and spy!= note - 2 and spy!= note + 3 and spy!= note - 3 and spy!= note + 4 and spy!= note - 4 and spy!= note + 5 and spy!= note - 5\n\n    def can_pass_to_neighbour_or_self_or_self_or_self_or_self_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note and spy!= note + 2 and spy!= note - 2 and spy!= note + 3 and spy!= note - 3 and spy!= note + 4 and spy!= note - 4 and spy!= note + 5 and spy!= note - 5 and spy!= note + 6 and spy!= note - 6\n\n    def can_pass_to_neighbour_or_self_or_self_or_self_or_self_or_self_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and spy!= note and spy!= note + 2 and spy!= note - 2 and spy!= note + 3 and spy!= note - 3 and spy!= note + 4 and spy!= note - 4 and spy!= note + 5 and spy!= note - 5 and spy!= note + 6 and spy!= note - 6 and spy!= note + 7 and spy!= note - 7\n\n    def can_pass_to_neighbour_or_self_or_self_or_self_or_self_or_self_or_self_or_self_or_self_or_self(spy, note):\n        return spy!= s and spy!= f and spy!= note and spy!= note + 1 and spy!= note - 1 and"
    },
    {
        "number": 1695,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    answers = [list(stdin.split()[1])]\n    for _ in range(n - 1):\n        answers.append(list(stdin.split()[1]))\n\n    correct_answers = list(map(int, stdin.split()[2:]))\n\n    max_score = 0\n    for i in range(m):\n        score = 0\n        for j in range(n):\n            if answers[j][i] == correct_answers[i]:\n                score += correct_answers[i]\n            else:\n                score += 0\n        max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 1696,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    positions = set()\n    for _ in range(k):\n        x, y = map(int, stdin.split())\n        positions.add((x, y))\n    positions.add((n, m))\n    positions = list(positions)\n    positions.sort()\n    positions.append((0, 0))\n    positions.append((n, m))\n    positions.sort()\n    positions = positions[1:-1]\n    min_time = float('inf')\n    for i in range(len(positions) - 1):\n        for j in range(i + 1, len(positions)):\n            time = abs(positions[i][0] - positions[j][0]) + abs(positions[i][1] - positions[j][1])\n            if time < min_time:\n                min_time = time\n    return str(min_time)"
    },
    {
        "number": 1697,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    board = [list(line.strip()) for line in stdin.split()[1:]]\n\n    def is_cycle(cycle):\n        for i in range(len(cycle) - 1):\n            if cycle[i] == cycle[i + 1]:\n                return False\n        return True\n\n    def find_cycle(board, color):\n        cycles = []\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == color:\n                    cycle = find_cycle_helper(board, i, j, [i, j])\n                    if cycle:\n                        cycles.append(cycle)\n        return cycles\n\n    def find_cycle_helper(board, i, j, visited):\n        if (i, j) in visited:\n            return []\n        visited.add((i, j))\n        if i == 0 or j == 0 or i == n - 1 or j == m - 1:\n            return [visited]\n        if board[i][j]!= board[i - 1][j] or board[i][j]!= board[i][j - 1]:\n            return []\n        return find_cycle_helper(board, i - 1, j, visited) + find_cycle_helper(board, i, j - 1, visited)\n\n    cycles = find_cycle(board, 'A')\n    if cycles:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
        "number": 1698,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    floors = list(map(int, stdin.split()))\n\n    def find_min_time(start_floor, end_floor):\n        time = 0\n        elevator_count = 0\n        elevator_position = start_floor\n\n        for i in range(n):\n            if elevator_position == end_floor:\n                elevator_count += 1\n                elevator_position = start_floor\n            else:\n                elevator_position += 1\n\n            time += abs(floors[i] - elevator_position)\n\n        return time\n\n    min_time = float('inf')\n    for i in range(1, k + 1):\n        min_time = min(min_time, find_min_time(1, i))\n\n    return str(min_time)"
    },
    {
        "number": 1699,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(int(10**8 * random.random()))\n        table.append(row)\n    for i in range(n):\n        for j in range(m):\n            table[i][j] = int(10**8 * random.random())\n    for row in table:\n        print(\" \".join(map(str, row)))\n    return \"\""
    },
    {
        "number": 1700,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def is_rbs(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    def is_regular(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return False\n                stack.pop()\n            elif c == \"+\":\n                if not stack:\n                    return False\n                if stack[-1]!= \"+\":\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    def min_nesting_depth(s: str) -> int:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return 0\n                stack.pop()\n        return len(stack)\n\n    def color_sequence(s: str) -> str:\n        stack = []\n        for c in s:\n            if c == \"(\":\n                stack.append(c)\n            elif c == \")\":\n                if not stack:\n                    return \"0\"\n                stack.pop()\n            elif c == \"+\":\n                if not stack:\n                    return \"0\"\n                if stack[-1]!= \"+\":\n                    return \"0\"\n                stack.pop()\n            else:\n                if not stack:\n                    return \"1\"\n                if stack[-1] == \"(\":\n                    return \"0\"\n                stack.pop()\n        return \"1\" * len(s)\n\n    if is_valid(s):\n        if is_rbs(s):\n            r = \"\"\n            b = color_sequence(s)\n        else:\n            r = color_sequence(s)\n            b = \"\"\n\n        r_depth = min_nesting_depth(r)\n        b_depth = min_nesting_depth(b)\n\n        if r_depth > b_depth:\n            return r + b\n        elif r_depth < b_depth:\n            return r + b\n        else:\n            return r + b\n\n    return \"0\" * n"
    },
    {
        "number": 1701,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    servers = {}\n    for _ in range(n):\n        name, ip = stdin.split()\n        servers[ip] = name\n\n    commands = []\n    for _ in range(m):\n        command, ip = stdin.split()\n        commands.append((command, ip))\n\n    for command, ip in commands:\n        if ip in servers:\n            name = servers[ip]\n            print(f\"{command} {ip}; # {name}\")\n        else:\n            print(f\"{command} {ip};\")\n\n    return \"\"\n"
    },
    {
        "number": 1702,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [int(x) for x in stdin.split()[1:]]\n    a.sort()\n    i = 0\n    j = 0\n    count = 0\n    max_points = 0\n    while i < n:\n        if a[i] == -1:\n            i += 1\n            continue\n        if a[i] == 0:\n            count += 1\n            i += 1\n            continue\n        if count == 0:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 1:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 2:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 3:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 4:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 5:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 6:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 7:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 8:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 9:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 10:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 11:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 12:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 13:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 14:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 15:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 16:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 17:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 18:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 19:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 20:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 21:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 22:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 23:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 24:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 25:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 26:\n            max_points += a[i] * 250\n            count += 1\n            i += 1\n            continue\n        if count == 27:\n            max_points += a[i"
    },
    {
        "number": 1703,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bracket_sequences = [stdin.split()[i] for i in range(1, n+1)]\n    regular_pairs = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if is_regular(bracket_sequences[i] + bracket_sequences[j]):\n                regular_pairs += 1\n    return str(regular_pairs)\n\ndef"
    },
    {
        "number": 1704,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [int(digit, 2) for digit in stdin.split()]\n\n    def max_number(digits: List[int]) -> int:\n        max_number = 0\n        for digit in digits:\n            max_number = max(max_number, digit)\n        return max_number\n\n    max_number_without_k = max_number(digits)\n    max_number_with_k = max_number(digits[:k])\n\n    if max_number_with_k == max_number_without_k:\n        return str(max_number_with_k)\n    else:\n        return str(max_number_without_k)"
    },
    {
        "number": 1705,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    left_exit = [False] * n\n    right_exit = [False] * n\n\n    for i in range(n):\n        if sequence[i] == 0:\n            left_exit[i] = True\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i] and right_exit[i]:\n            left_exit[i] = False\n            right_exit[i] = False\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n        if left_exit[i]:\n            left_exit[i] = False\n        else:\n            left_exit[i] = True\n\n    for i in range(n):\n        if right_exit[i]:\n            right_exit[i] = False\n        else:\n            right_exit[i] = True\n\n    for i in range(n):\n       "
    },
    {
        "number": 1706,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 0\n    while k < 30:\n        i = 1\n        while i < n - 1:\n            if s[i:i + 2] == s[i:i + 2][::-1]:\n                s = s[:i] + s[i:i + 2] + s[i + 2:]\n                k += 1\n                break\n            i += 1\n        i = n - 2\n        while i > 0:\n            if s[i:i + 2] == s[i:i + 2][::-1]:\n                s = s[:i] + s[i:i + 2] + s[i + 2:]\n                k += 1\n                break\n            i -= 1\n    return str(k)"
    },
    {
        "number": 1707,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == a[j] + a[i]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1708,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    total_cost = 0\n    for i in range(m):\n        if t[i] == n:\n            total_cost += 0\n        else:\n            total_cost += c[t[i]] * min(d[i], a[t[i]])\n            a[t[i]] -= min(d[i], a[t[i]])\n\n    return str(total_cost)"
    },
    {
        "number": 1709,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    paints = []\n    for _ in range(n):\n        paints.append(list(map(int, stdin.split())))\n\n    def is_valid(colors: List[int], paints: List[List[int]]) -> bool:\n        groups = defaultdict(list)\n        for i, color in enumerate(colors):\n            if color == 0:\n                continue\n            groups[color].append(i)\n\n        for group in groups.values():\n            if len(group) > 1:\n                for i in range(len(group) - 1):\n                    for j in range(i + 1, len(group)):\n                        if paints[group[i]][0] + paints[group[j]][0] > paints[group[i]][1] + paints[group[j]][1]:\n                            return False\n        return True\n\n    def min_paint(colors: List[int], paints: List[List[int]]) -> int:\n        min_paint = float('inf')\n        for color in range(1, m + 1):\n            if colors.count(color) == 0:\n                continue\n            group = [i for i, c in enumerate(colors) if c == color]\n            min_paint = min(min_paint, sum(paints[i][0] for i in group))\n        return min_paint\n\n    if is_valid(colors, paints):\n        return str(min_paint(colors, paints))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 1710,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if (a[i] * a[j] * a[k]) % k == 0:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 1711,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(1, m + 1):\n        for j in range(i + 1, m + 1):\n            if i < j:\n                count += 1\n                if count % 998244353 == 0:\n                    return str(count)\n    return str(count)"
    },
    {
        "number": 1712,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def last_hit(i: int) -> str:\n        if a[i] == 1:\n            return \"Vanya\"\n        elif a[i] == 2:\n            return \"Vova\"\n        else:\n            return \"Both\"\n\n    def time_to_hit(i: int) -> float:\n        if i == 0:\n            return 1 / x\n        else:\n            return 1 / y\n\n    def time_to_raise(i: int) -> float:\n        if i == 0:\n            return 1 / x\n        else:\n            return 1 / y\n\n    def time_to_destroy(i: int) -> float:\n        return time_to_hit(i) + time_to_raise(i)\n\n    def time_to_last_hit(i: int) -> float:\n        return time_to_hit(i) + time_to_raise(i) + time_to_destroy(i)\n\n    def time_to_last_hit_by_vanya(i: int) -> float:\n        return time_to_last_hit(i) - time_to_raise(i)\n\n    def time_to_last_hit_by_vova(i: int) -> float:\n        return time_to_last_hit(i) - time_to_hit(i)\n\n    def time_to_last_hit_both(i: int) -> float:\n        return time_to_last_hit(i)\n\n    def time_to_last_hit_by_vanya_or_vova(i: int) -> float:\n        return min(time_to_last_hit_by_vanya(i), time_to_last_hit_by_vova(i))\n\n    def time_to_last_hit_by_vanya_or_vova_or_both(i: int) -> float:\n        return min(time_to_last_hit_by_vanya_or_vova(i), time_to_last_hit_both(i))\n\n    def time_to_last_hit_by_vanya_or_vova_or_both_or_none(i: int) -> float:\n        return min(time_to_last_hit_by_vanya_or_vova_or_both(i), time_to_last_hit_none(i))\n\n    def time_to_last_hit_none(i: int) -> float:\n        return time_to_last_hit(i)\n\n    def time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both(i: int) -> float:\n        return min(time_to_last_hit_by_vanya_or_vova_or_both_or_none(i), time_to_last_hit_both(i))\n\n    def time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both_or_none(i: int) -> float:\n        return min(time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both(i), time_to_last_hit_none(i))\n\n    def time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both_or_none_or_both(i: int) -> float:\n        return min(time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both_or_none(i), time_to_last_hit_both(i))\n\n    def time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both_or_none_or_both_or_none(i: int) -> float:\n        return min(time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both_or_none_or_both(i), time_to_last_hit_none(i))\n\n    def time_to_last_hit_by_vanya_or_vova_or_both_or_none_or_both_or_none_or_both_or_none_or_both(i: int) -> float:\n        return min("
    },
    {
        "number": 1713,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split())\n    p = list(map(int, stdin.split()[1:]))\n\n    def shuffle(p):\n        for i in range(len(p) - 1):\n            j = i + 1\n            while j < len(p) and p[j] == p[i]:\n                j += 1\n            p[i], p[j - 1] = p[j - 1], p[i]\n\n    def min_shuffles(p):\n        shuffles = 0\n        while True:\n            shuffle(p)\n            shuffles += 1\n            if p[0] == t:\n                return shuffles\n\n    min_shuffles_result = min_shuffles(p)\n    if min_shuffles_result == len(p):\n        return str(min_shuffles_result)\n    else:\n        return str(-1)"
    },
    {
        "number": 1714,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if 2 * k > n:\n        return \"No solution\"\n\n    a = [i for i in range(1, n + 1)]\n    a.sort()\n\n    def check(a):\n        sum_diff = 0\n        for i in range(1, n + 1, 2):\n            sum_diff += abs(a[i - 1] - a[i])\n        for i in range(0, n + 1, 2):\n            sum_diff += abs(a[i] - a[i + 1])\n        return sum_diff == 2 * k\n\n    if check(a):\n        return \" \".join(map(str, a))\n    else:\n        return \"No solution\""
    },
    {
        "number": 1715,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def distance(a: int, b: int) -> int:\n        return abs(a - b)\n\n    def min_distance(shrines: List[int], temples: List[int], x: int) -> int:\n        min_shrine = min(shrines)\n        min_temple = min(temples)\n        min_distance = min_shrine + min_temple\n\n        for i in range(len(shrines)):\n            if shrines[i] + temples[i] <= x:\n                min_distance = min(min_distance, x - shrines[i] - temples[i])\n\n        return min_distance\n\n    A, B, Q = map(int, stdin.split())\n    shrines = list(map(int, stdin.split()))\n    temples = list(map(int, stdin.split()))\n    x = int(stdin.split())\n\n    for i in range(len(shrines)):\n        shrines[i] = distance(shrines[i], x)\n        temples[i] = distance(temples[i], x)\n\n    result = []\n    for i in range(Q):\n        result.append(min_distance(shrines, temples, x))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 1716,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    trains = []\n    for i in range(m):\n        l, r = map(int, stdin.split())\n        trains.append((l, r))\n\n    queries = []\n    for i in range(q):\n        p, q = map(int, stdin.split())\n        queries.append((p, q))\n\n    result = []\n    for p, q in queries:\n        count = 0\n        for l, r in trains:\n            if p <= l and r <= q:\n                count += 1\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1717,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    x = 1\n    while True:\n        if x % 2 == 1 and x % 3 == 1:\n            break\n        x += 1\n    return str(x)"
    },
    {
        "number": 1718,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    min_operations = 0\n    for i in range(k):\n        min_val = a[i]\n        for j in range(i + 1, i + k):\n            min_val = min(min_val, a[j])\n        for j in range(i + 1, i + k):\n            a[j] = min_val\n        min_operations += k\n    return str(min_operations)"
    },
    {
        "number": 1719,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(4):\n        for j in range(4):\n            for k in range(4):\n                if i!= j and i!= k and j!= k:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 1720,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    room = [list(row) for row in stdin.split('\\n')[1:]]\n    x1, y1, x2, y2 = map(int, stdin.split()[-1].split())\n\n    def bfs(x, y, dx, dy):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == (x2, y2):\n                return 0\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for nx, ny in [(x + dx, y + dy), (x - dx, y - dy), (x + dx, y - dy), (x - dx, y + dy)]:\n                if 0 <= nx < n and 0 <= ny < m and room[nx][ny] == '.' and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n        return -1\n\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    min_time = float('inf')\n    for dx, dy in directions:\n        time = bfs(x1, y1, dx, dy)\n        if time!= -1 and time < min_time:\n            min_time = time\n    return str(min_time) if min_time!= float('inf') else '-1'"
    },
    {
        "number": 1721,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    swaps = 0\n    for i in range(n // 2):\n        if s[i]!= s[n - i - 1]:\n            s[i], s[n - i - 1] = s[n - i - 1], s[i]\n            swaps += 1\n    return str(swaps)"
    },
    {
        "number": 1722,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = [line.strip() for line in stdin.split('\\n')[1:]]\n    students.sort()\n    pairs = set()\n    for i in range(n):\n        for j in range(i+1, n):\n            if students[i][0] == students[j][0]:\n                pairs.add((students[i], students[j]))\n    return str(len(pairs))"
    },
    {
        "number": 1723,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    if n == 2:\n        return \"-1\\n1 2\"\n    elif n == 8:\n        return \"1 2\\n1 3\\n2 4\\n2 5\\n3 6\\n4 7\\n4 8\\n1 2\\n1 3\\n2 4\\n2 5\\n2 6\\n3 7\\n6 8\"\n    else:\n        return \"\""
    },
    {
        "number": 1724,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m = int(''.join(stdin.split()[2:]), 2)\n    max_value = float('-inf')\n\n    for x in range(m + 1):\n        value = sum(a[i] * (1 if (x >> i) & 1 else 0) for i in range(n))\n        if value > max_value:\n            max_value = value\n\n    return str(max_value)"
    },
    {
        "number": 1725,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    moves = 0\n    while True:\n        moves += 1\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] + d < matrix[i][j]:\n                    matrix[i][j] += d\n                elif matrix[i][j] - d > matrix[i][j]:\n                    matrix[i][j] -= d\n                else:\n                    continue\n                if matrix[i][j] == matrix[i][j]:\n                    return str(moves)\n        if moves == 1000000:\n            return \"-1\""
    },
    {
        "number": 1726,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    days = 0\n    time = 0\n\n    for i in range(n):\n        time += a[i]\n        if time >= t:\n            days += 1\n            time = a[i]\n\n    return str(days)"
    },
    {
        "number": 1727,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trees = []\n    for i in range(n):\n        x, h = map(int, stdin.split()[1:3])\n        trees.append((x, h))\n    trees.sort(key=lambda x: x[0])\n    max_trees = 0\n    for i in range(n):\n        if trees[i][0] - trees[i][1] > 0:\n            max_trees += 1\n        else:\n            break\n    return str(max_trees)"
    },
    {
        "number": 1728,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = [tuple(map(int, p[i:i+n-1].split())) for i in range(0, len(p), n-1)]\n    c = list(map(int, stdin.split()[n:]))\n    \n    def dfs(u, color):\n        nonlocal c\n        c[u-1] = color\n        for v, w in p[u-1]:\n            if v!= u:\n                dfs(v, color)\n    \n    dfs(1, 0)\n    return str(min(c.count(0), c.count(1), c.count(2)))"
    },
    {
        "number": 1729,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    s = stdin.split()[1]\n    queries = [list(map(int, stdin.split())) for _ in range(q)]\n\n    def count_digits(s: str, start: int, end: int) -> int:\n        count = 0\n        for i in range(start, end):\n            if s[i].isdigit():\n                count += 1\n        return count\n\n    def print_digits(s: str, start: int, end: int) -> None:\n        for i in range(start, end):\n            if s[i].isdigit():\n                print(int(s[i]), end=\" \")\n\n    def process_program(s: str, start: int, end: int) -> None:\n        count = count_digits(s, start, end)\n        print_digits(s, start, end)\n        print(\" \".join(str(count) for _ in range(10)))\n\n    for l, r in queries:\n        process_program(s, l - 1, r)\n        print()"
    },
    {
        "number": 1730,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(node, visited, path):\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, path):\n                    return True\n        path.pop()\n        return False\n\n    visited = set()\n    for i in range(1, n + 1):\n        if len(graph[i]) >= k and not dfs(i, visited, []):\n            break\n\n    if len(visited) < k + 1:\n        return \"0\"\n\n    path = []\n    dfs(1, visited, path)\n    path.pop()\n    return str(len(path)) + \" \" + \" \".join(map(str, path))\n"
    },
    {
        "number": 1731,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    def is_valid(a, b):\n        if len(a)!= len(b) or len(a)!= m:\n            return False\n        for i in range(m):\n            if a[i] < 1 or a[i] > n or b[i] < 1 or b[i] > n or a[i] > b[i]:\n                return False\n            if i > 0 and a[i] <= a[i - 1]:\n                return False\n        return True\n\n    def count_pairs(a, b):\n        a.sort()\n        b.sort(reverse=True)\n        count = 0\n        for i in range(m):\n            if a[i] == b[i]:\n                count += 1\n            else:\n                break\n        return count\n\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            a = [i] * m\n            b = [j] * m\n            if is_valid(a, b):\n                count += count_pairs(a, b)\n\n    return str(count % mod)"
    },
    {
        "number": 1732,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *l, *c = map(int, stdin.split())\n    l = [l[i] for i in range(n)]\n    c = [c[i] for i in range(n)]\n\n    def can_jump(i, j):\n        if i == j:\n            return True\n        if i > j:\n            return False\n        return can_jump(i + l[i], j)\n\n    def min_cost(i, j):\n        if i == j:\n            return 0\n        if i > j:\n            return float('inf')\n        return min(min_cost(i + l[i], j), min_cost(i, j - l[i]) + c[i])\n\n    if can_jump(0, n - 1):\n        return min_cost(0, n - 1)\n    else:\n        return -1"
    },
    {
        "number": 1733,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    visited[x] = True\n    visited[y] = True\n    queue = [(x, 0)]\n    result = 0\n    while queue:\n        current, distance = queue.pop(0)\n        if current == y:\n            result = distance\n            break\n        for neighbor in graph[current]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append((neighbor, distance + 1))\n    return str(result)"
    },
    {
        "number": 1734,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    phone_numbers = [int(x) for x in stdin.split()[1:]]\n    phone_numbers.sort()\n    result = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if phone_numbers[i] < phone_numbers[j]:\n                break\n            if phone_numbers[i] == phone_numbers[j]:\n                continue\n            digits = [str(x) for x in range(10)]\n            for digit in digits:\n                if digit in str(phone_numbers[i]) and digit in str(phone_numbers[j]):\n                    sequence = digit + str(phone_numbers[i]) + digit + str(phone_numbers[j])\n                    if sequence not in result:\n                        result.append(sequence)\n                    break\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1735,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    player1_turn = True\n    player1_score = 0\n    player2_score = 0\n\n    for i in range(n - 1):\n        if s[i] == s[i + 1]:\n            if player1_turn:\n                player1_score += 1\n                s = s[:i] + s[i + 2:]\n            else:\n                player2_score += 1\n                s = s[:i] + s[i + 2:]\n        else:\n            if player1_turn:\n                player1_turn = False\n            else:\n                player1_turn = True\n\n    if player1_score > player2_score:\n        return \"Yes\"\n    elif player2_score > player1_score:\n        return \"No\"\n    else:\n        return \"Tie\"\n"
    },
    {
        "number": 1736,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def read_books(books_read: int, time_spent: int) -> int:\n        if books_read == n:\n            return books_read\n\n        if time_spent >= t:\n            return read_books(books_read + 1, 0)\n\n        return read_books(books_read + 1, time_spent + a[books_read - 1])\n\n    return str(read_books(1, 0))\n"
    },
    {
        "number": 1737,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_project(name: str, version: int, projects: List[Tuple[str, int]]) -> Optional[Tuple[str, int]]:\n        for project in projects:\n            if project[0] == name and project[1] == version:\n                return project\n        return None\n\n    def find_min_distance(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> int:\n        min_distance = float('inf')\n        for other_project in projects:\n            if other_project[0]!= project[0]:\n                distance = abs(project[1] - other_project[1])\n                if distance < min_distance:\n                    min_distance = distance\n        return min_distance\n\n    def find_actual_version(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> int:\n        min_distance = float('inf')\n        actual_version = None\n        for other_project in projects:\n            if other_project[0]!= project[0]:\n                distance = abs(project[1] - other_project[1])\n                if distance < min_distance:\n                    min_distance = distance\n                    actual_version = other_project[1]\n        return actual_version\n\n    def find_project_chain(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        chain = []\n        while project[0]!= 'Polycarp':\n            chain.append(project)\n            project = find_project(project[0], project[1], projects)\n            if project is None:\n                break\n        return chain\n\n    def find_project_dependencies(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        dependencies = []\n        for dependency in project[2]:\n            dependency_project = find_project(dependency[0], dependency[1], projects)\n            if dependency_project is not None:\n                dependencies.append(dependency_project)\n        return dependencies\n\n    def find_project_dependencies_chain(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        dependencies_chain = []\n        for dependency in project[2]:\n            dependency_project = find_project(dependency[0], dependency[1], projects)\n            if dependency_project is not None:\n                dependencies_chain.append(dependency_project)\n                dependencies_chain.extend(find_project_dependencies_chain(dependency_project, projects))\n        return dependencies_chain\n\n    def find_project_dependencies_chain_with_min_distance(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        dependencies_chain = []\n        for dependency in project[2]:\n            dependency_project = find_project(dependency[0], dependency[1], projects)\n            if dependency_project is not None:\n                dependencies_chain.append(dependency_project)\n                dependencies_chain.extend(find_project_dependencies_chain_with_min_distance(dependency_project, projects))\n        return dependencies_chain\n\n    def find_project_dependencies_chain_with_min_distance_and_actual_version(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        dependencies_chain = []\n        for dependency in project[2]:\n            dependency_project = find_project(dependency[0], dependency[1], projects)\n            if dependency_project is not None:\n                dependencies_chain.append(dependency_project)\n                dependencies_chain.extend(find_project_dependencies_chain_with_min_distance_and_actual_version(dependency_project, projects))\n        return dependencies_chain\n\n    def find_project_dependencies_chain_with_min_distance_and_actual_version_and_project_chain(project: Tuple[str, int], projects: List[Tuple[str, int]]) -> List[Tuple[str, int]]:\n        dependencies_chain = []\n        for dependency in project[2]:\n            dependency_project = find_project(dependency[0], dependency[1], projects)\n            if dependency_project is not None:\n                dependencies_chain.append(dependency_project)\n                dependencies_chain.extend(find_project_dependencies_chain_with_min_distance_and_actual_version_and_project_chain(dependency_project, projects))\n        return dependencies_chain\n\n    def find_project_dependencies_chain_with_min_distance_and_actual_version_and_project_chain_and_project_dependencies(project: Tuple[str, int], projects: List[Tuple[str"
    },
    {
        "number": 1738,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    compressed_versions = []\n    for i in range(1, n + 1):\n        compressed_versions.append(s[:i])\n    compressed_versions.sort(key=lambda x: len(x))\n    return str(len(compressed_versions[0]))"
    },
    {
        "number": 1739,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    s = 1\n    for i in a:\n        s *= x ** i\n\n    t = 1\n    for i in range(1, n + 1):\n        t += a[i - 1] * x ** i\n\n    gcd = 1\n    while t!= 0:\n        temp = t\n        t = s % temp\n        s = temp\n        gcd = temp\n\n    return str((s * 1000000007) % 1000000007)"
    },
    {
        "number": 1740,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x, y = map(int, stdin.split()[1:n+1])\n    x.sort()\n    y.sort()\n    result = []\n    for i in range(1, n+1):\n        if i in x and i in y:\n            result.append(i)\n    return''.join(map(str, result))"
    },
    {
        "number": 1741,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_circle(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius:\n                return False\n        return True\n\n    def is_circle_with_river(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship_and_lair(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius and distance(lair, (0, 2)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship_and_lair_and_animal(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius and distance(lair, (0, 2)) > radius and distance(lair, (0, 3)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship_and_lair_and_animal_and_ship(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius and distance(lair, (0, 2)) > radius and distance(lair, (0, 3)) > radius and distance(lair, (0, 4)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship_and_lair_and_animal_and_ship_and_lair(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius and distance(lair, (0, 2)) > radius and distance(lair, (0, 3)) > radius and distance(lair, (0, 4)) > radius and distance(lair, (0, 5)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship_and_lair_and_animal_and_ship_and_lair_and_animal(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius and distance(lair, (0, 2)) > radius and distance(lair, (0, 3)) > radius and distance(lair, (0, 4)) > radius and distance(lair, (0, 5)) > radius and distance(lair, (0, 6)) > radius:\n                return False\n        return True\n\n    def is_circle_with_river_and_ship_and_lair_and_animal_and_ship_and_lair_and_animal_and_ship(lairs, center, radius):\n        for lair in lairs:\n            if distance(lair, center) > radius and distance(lair, (0, 0)) > radius and distance(lair, (0, 1)) > radius and distance(lair, (0, 2)) > radius and distance(lair, (0, 3)) >"
    },
    {
        "number": 1742,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    pairs = []\n    for i in range(m):\n        u, v = map(int, stdin.split())\n        pairs.append((u, v))\n\n    p.sort()\n    p.reverse()\n    p.append(n)\n\n    max_moves = 0\n    for i in range(n):\n        if p[i] == n:\n            continue\n        for j in range(i + 1, n):\n            if p[j] == n:\n                continue\n            if p[i] < p[j]:\n                max_moves += 1\n                break\n\n    return str(max_moves)"
    },
    {
        "number": 1743,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n    c = list(map(int, stdin.split()[3].split()))\n\n    def max_joy(a, b, c):\n        return max(a, b, c)\n\n    def max_total_joy(a, b, c):\n        return max(max_joy(a[0], b[0], c[0]), max_joy(a[1], b[1], c[1]), max_joy(a[2], b[2], c[2]))\n\n    return str(max_total_joy(a, b, c))"
    },
    {
        "number": 1744,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n\n    def find_min_fail(t: List[int], i: int) -> int:\n        fail_count = 0\n        for j in range(i):\n            if t[j] > t[i]:\n                fail_count += 1\n        return fail_count\n\n    min_fail = [find_min_fail(t, i) for i in range(n)]\n    print(*min_fail)\n    return \"\"\n"
    },
    {
        "number": 1745,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    map_ = [list(row) for row in stdin.splitlines()]\n\n    def is_valid_pipe(pipe):\n        if len(pipe)!= 2:\n            return False\n        if pipe[0] == pipe[1]:\n            return False\n        if pipe[0] == '.' or pipe[1] == '.':\n            return False\n        if pipe[0] == '#' and pipe[1] == '#':\n            return False\n        if pipe[0] == '.' and pipe[1] == '#':\n            return False\n        if pipe[0] == '#' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] == '.' and pipe[1] == '.':\n            return False\n        if pipe[0] =="
    },
    {
        "number": 1746,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    parent = [int(x) - 1 for x in stdin.split()[1:]]\n\n    def is_spruce(vertex: int) -> bool:\n        if vertex == 0:\n            return True\n\n        if not is_leaf(vertex):\n            return all(is_spruce(child) for child in children(vertex))\n\n        return True\n\n    def is_leaf(vertex: int) -> bool:\n        return len(children(vertex)) == 0\n\n    def children(vertex: int) -> list[int]:\n        return [i for i in range(n) if parent[i] == vertex]\n\n    return \"Yes\" if is_spruce(0) else \"No\"\n"
    },
    {
        "number": 1747,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_longest_k_good_segment(a: list, k: int) -> tuple:\n        n = len(a)\n        dp = [0] * (n + 1)\n        max_length = 0\n        max_start = 0\n        max_end = 0\n\n        for i in range(1, n + 1):\n            for j in range(i):\n                if a[j]!= a[i] and dp[j] + 1 > dp[i]:\n                    dp[i] = dp[j] + 1\n\n            if dp[i] <= k:\n                if i - max_start + 1 > max_length:\n                    max_length = i - max_start + 1\n                    max_start = j\n                    max_end = i\n\n        return max_start, max_end\n\n    start, end = find_longest_k_good_segment(a, k)\n    return f\"{start + 1} {end + 1}\"\n"
    },
    {
        "number": 1748,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    v = list(map(int, stdin.split()[1:]))\n    t = list(map(int, stdin.split()[1:]))\n\n    melted = [0] * n\n    for i in range(n):\n        melted[i] = v[i] - t[i]\n        if melted[i] < 0:\n            melted[i] = 0\n\n    return \" \".join(map(str, melted))"
    },
    {
        "number": 1749,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def check_swap(a: list, b: list, l: int, r: int) -> bool:\n        for i in range(l, r + 1):\n            if a[i]!= b[i]:\n                return False\n        return True\n\n    for i in range(n):\n        if check_swap(a, b, l, r):\n            return \"LIE\"\n\n    return \"TRUTH\""
    },
    {
        "number": 1750,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    paths = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    colors = [1] * n\n\n    for i in range(n - 1):\n        a, b = paths[i]\n        colors[a - 1] = colors[b - 1] = colors[a - 1] + colors[b - 1]\n\n    colors = list(set(colors))\n    colors.sort()\n\n    return f\"{len(colors)}\\n{colors[0]} {colors[1]} {colors[2]} {colors[3]} {colors[4]}\"\n"
    },
    {
        "number": 1751,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    MOD = 10**9 + 7\n    graph = [[0] * n for _ in range(n)]\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j < n and p[j] > p[i]:\n                graph[i][j] = 1\n                graph[j][i] = 1"
    },
    {
        "number": 1752,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # sort the array in ascending order\n    a.sort()\n\n    # initialize the result array\n    result = []\n\n    # initialize the current index\n    i = 0\n\n    # loop through the array\n    while i < n:\n        # add the current element to the result array\n        result.append(a[i])\n\n        # increment the current index\n        i += 1\n\n        # if the current index is less than the length of the array\n        if i < n:\n            # calculate the difference between the current element and the next element\n            diff = a[i] - a[i - 1]\n\n            # if the difference is greater than 0, add the next element to the result array\n            if diff > 0:\n                result.append(a[i])\n                i += 1\n\n    # convert the result array to a string and return it\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1753,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    colors = set(map(lambda x: x[0], pairs))\n    pairs = {pair: color for pair, color in pairs}\n\n    def is_connected(a, b):\n        return a in colors and b in colors and pairs[a] == pairs[b]\n\n    def find_connected_colors(color):\n        return [color] if color in colors else [color] + find_connected_colors(pairs[color])\n\n    connected_colors = [find_connected_colors(color) for color in colors]\n\n    def find_rooks(color, rooks):\n        if not rooks:\n            return []\n        if len(rooks) == 1:\n            return [rooks[0]]\n        if is_connected(color, rooks[0]):\n            return [rooks[0]] + find_rooks(color, rooks[1:])\n        return find_rooks(color, rooks[1:])\n\n    rooks = [find_rooks(color, connected_colors[color - 1]) for color in colors]\n\n    def print_rooks(rooks):\n        for i, rook in enumerate(rooks):\n            print(f\"{len(rooks)}\")\n            for x, y in rook:\n                print(f\"{x} {y}\")\n\n    print_rooks(rooks)\n\n    return \"\"\n"
    },
    {
        "number": 1754,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    powers = list(map(int, stdin.split()))\n    schools = list(map(int, stdin.split()))\n    chosen_ones = list(map(int, stdin.split()))\n\n    def find_school(student_id: int) -> int:\n        for i, school in enumerate(schools):\n            if powers[i] >= powers[student_id - 1]:\n                return i + 1\n        return -1\n\n    def find_chosen_one(school_id: int) -> int:\n        for i, chosen_one in enumerate(chosen_ones):\n            if powers[chosen_one - 1] >= powers[school_id - 1]:\n                return i + 1\n        return -1\n\n    def make_up_school(school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[school_id - 1]:\n                return i\n        return -1\n\n    def make_up_chosen_one(school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[school_id - 1]:\n                return i\n        return -1\n\n    def find_best_student(school_id: int) -> int:\n        best_power = -1\n        best_student = -1\n        for i in range(1, n + 1):\n            if powers[i - 1] > best_power and powers[i - 1] >= powers[school_id - 1]:\n                best_power = powers[i - 1]\n                best_student = i\n        return best_student\n\n    def find_best_chosen_one(school_id: int) -> int:\n        best_power = -1\n        best_chosen_one = -1\n        for i in range(1, n + 1):\n            if powers[i - 1] > best_power and powers[i - 1] >= powers[school_id - 1]:\n                best_power = powers[i - 1]\n                best_chosen_one = i\n        return best_chosen_one\n\n    def make_up_school_for_chosen_one(chosen_one_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[chosen_one_id - 1]:\n                return i\n        return -1\n\n    def make_up_chosen_one_for_school(school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[school_id - 1]:\n                return i\n        return -1\n\n    def make_up_school_for_chosen_one_and_school(chosen_one_id: int, school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[chosen_one_id - 1] and powers[i - 1] < powers[school_id - 1]:\n                return i\n        return -1\n\n    def make_up_chosen_one_for_school_and_school(chosen_one_id: int, school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[chosen_one_id - 1] and powers[i - 1] < powers[school_id - 1]:\n                return i\n        return -1\n\n    def make_up_school_for_chosen_one_and_school_and_school(chosen_one_id: int, school_id: int, other_school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[chosen_one_id - 1] and powers[i - 1] < powers[school_id - 1] and powers[i - 1] < powers[other_school_id - 1]:\n                return i\n        return -1\n\n    def make_up_chosen_one_for_school_and_school_and_school(chosen_one_id: int, school_id: int, other_school_id: int) -> int:\n        for i in range(1, n + 1):\n            if powers[i - 1] < powers[chosen_one_id - 1] and powers[i - 1] < powers[school"
    },
    {
        "number": 1755,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n    b = set(map(int, stdin.split()[1:]))\n\n    if k == 0:\n        return str(-1)\n\n    def is_increasing(arr):\n        for i in range(1, len(arr)):\n            if arr[i] <= arr[i - 1]:\n                return False\n        return True\n\n    def min_operations(arr, b):\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] not in b:\n                count += 1\n                b.add(arr[i])\n                if is_increasing(arr):\n                    return count\n                b.remove(arr[i])\n        return -1\n\n    return str(min_operations(a, b))"
    },
    {
        "number": 1756,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    days = list(map(int, stdin.split()))\n\n    def days_in_month(month: int) -> int:\n        return days[month - 1]\n\n    def days_in_year(year: int) -> int:\n        return sum(days_in_month(month) for month in range(1, n + 1))\n\n    def days_in_range(start: int, end: int) -> int:\n        return sum(days_in_month(month) for month in range(start, end + 1))\n\n    def days_in_month_range(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end))\n\n    def days_in_month_range_inclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive_inclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive_exclusive_inclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end + 1))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive_exclusive_exclusive(month: int, start: int, end: int) -> int:\n        return sum(days_in_month(month) for day in range(start, end))\n\n    def days_in_month_range_inclusive_exclusive_inclusive_exclusive_inclusive_exclusive_exclusive_inclusive_exclusive(month: int, start: int,"
    },
    {
        "number": 1757,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    fibonacci = [1, 1]\n    for i in range(2, n):\n        fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2])\n\n    name = ['O'] * n\n    for i in range(1, n):\n        if fibonacci[i] in fibonacci:\n            name[i] = 'O'\n        else:\n            name[i] = 'o'\n\n    return ''.join(name)"
    },
    {
        "number": 1758,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    t = stdin.split()[2]\n\n    def rotate_subsequence(s: str, t: str, k: int) -> str:\n        if k == 0:\n            return s\n        if k == 1:\n            return t\n        return rotate_subsequence(s, t, k - 1) + s[0]\n\n    def min_operations(s: str, t: str) -> int:\n        s_rotated = rotate_subsequence(s, t, len(s))\n        return len(s_rotated) - len(t)\n\n    if min_operations(s, t) == -1:\n        return -1\n    else:\n        return str(min_operations(s, t))"
    },
    {
        "number": 1759,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    t = [list(map(int, stdin.split())) for _ in range(m)]\n    t.sort(key=lambda x: x[0])\n    result = []\n    for i in range(m):\n        painter = 0\n        time = 0\n        while painter < n and time < t[i][0]:\n            painter += 1\n            time += t[i][painter]\n        result.append(time)\n    return''.join(map(str, result))"
    },
    {
        "number": 1760,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = list(s)\n    directions = [1 if c == 'U' else -1 for c in s]\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append(1)\n    directions.append(-1)\n    directions.append("
    },
    {
        "number": 1761,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split('\\n')\n    words = [word.strip() for word in words]\n    message = words.pop()\n    encoded_message = []\n\n    for word in words:\n        encoded_word = []\n        for char in word:\n            if char.isalpha():\n                encoded_word.append(char)\n            else:\n                encoded_word.append('<3')\n        encoded_word.append('<3')\n        encoded_message.append(''.join(encoded_word))\n\n    encoded_message.append(message)\n    encoded_message = ''.join(encoded_message)\n\n    for i in range(len(encoded_message)):\n        if encoded_message[i] == '<3':\n            encoded_message = encoded_message[:i] + '3' + encoded_message[i+1:]\n            break\n\n    if encoded_message == message:\n        return 'yes'\n    else:\n        return 'no'"
    },
    {
        "number": 1762,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    videos = []\n    for _ in range(n):\n        s, m = map(int, stdin.split())\n        videos.append((s, m))\n\n    servers = [0] * k\n    queue = []\n    for s, m in videos:\n        if servers[0] == 0:\n            servers[0] = s\n            queue.append((s, m))\n        else:\n            servers[0] += m\n            if servers[0] >= 60:\n                servers[0] -= 60\n                servers[1] += 1\n                if servers[1] == k:\n                    servers[1] = 0\n                    servers[0] = 0\n                    queue.pop(0)\n\n    return \" \".join(map(str, [s for s, _ in queue]))"
    },
    {
        "number": 1763,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, r, m = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def restore_pillars(h):\n        h.sort(reverse=True)\n        total_cost = 0\n        for i in range(n):\n            if h[i] == 0:\n                continue\n            total_cost += a\n            h[i] -= 1\n        return total_cost\n\n    def move_brick(h, i, j):\n        total_cost = 0\n        if h[i] == 0:\n            return total_cost\n        total_cost += r\n        h[i] -= 1\n        h[j] += 1\n        return total_cost\n\n    def brick_cost(h):\n        total_cost = 0\n        for i in range(n):\n            if h[i] == 0:\n                continue\n            total_cost += m\n        return total_cost\n\n    total_cost = restore_pillars(h)\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_cost = min(total_cost, brick_cost(h) + move_brick(h, i, j))\n\n    return str(total_cost)"
    },
    {
        "number": 1764,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    s = 0\n    t = 0\n    wins = 0\n    for i in range(n):\n        if a[i] == 1:\n            s += 1\n            t += 1\n        elif a[i] == 2:\n            t += 1\n        if t >= 3:\n            wins += 1\n            t = 0\n        if s >= 3:\n            wins += 1\n            s = 0\n    if wins == 0:\n        return \"0\"\n    elif wins == 1:\n        return f\"{s} {t}\"\n    else:\n        return \" \".join(map(str, range(1, 7)))"
    },
    {
        "number": 1765,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    k = 0\n    for i in range(n - 1):\n        if a[i] % 2 == 0 and a[i + 1] % 2 == 0:\n            k += 1\n    if k == 0:\n        return f\"{k}\\n\"\n    b = [a[i] for i in range(n) if a[i] % 2 == 0]\n    b.sort()\n    return f\"{k}\\n{b[0]} {b[-1]}\""
    },
    {
        "number": 1766,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = list(map(int, stdin.split()[1:]))\n\n    sereja_sum = 0\n    dima_sum = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            sereja_sum += cards[i]\n        else:\n            dima_sum += cards[i]\n\n    if sereja_sum > dima_sum:\n        return f\"{sereja_sum} {dima_sum}\"\n    elif sereja_sum < dima_sum:\n        return f\"{dima_sum} {sereja_sum}\"\n    else:\n        return f\"{sereja_sum} {dima_sum}\""
    },
    {
        "number": 1767,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:n+1]))\n    b = list(map(int, stdin.split()[n+1:]))\n\n    def f(x, l, r):\n        return sum(x[i] | x[i+1] << 1 | x[i+2] << 2 | x[i+3] << 3 | x[i+4] << 4 | x[i+5] << 5 | x[i+6] << 6 | x[i+7] << 7)\n\n    max_sum = float('-inf')\n    for l in range(1, n+1):\n        for r in range(l, n+1):\n            current_sum = f(a, l, r) + f(b, l, r)\n            max_sum = max(max_sum, current_sum)\n\n    return str(max_sum)"
    },
    {
        "number": 1768,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = list(s)\n    q = int(stdin.split()[2])\n    plans = []\n\n    for i in range(q):\n        m, c = map(int, stdin.split()[i + 3].split())\n        plans.append((m, c))\n\n    def paint(start, end, color):\n        nonlocal s\n        for i in range(start, end + 1):\n            s[i - 1] = color\n\n    def find_longest_subsegment(start, end):\n        nonlocal s\n        longest = 0\n        current = 0\n        for i in range(start, end + 1):\n            if s[i - 1] == s[current]:\n                current += 1\n            else:\n                longest = max(longest, current)\n                current = i - start + 1\n        return max(longest, current)\n\n    def max_koyomity(start, end, color):\n        nonlocal s\n        paint(start, end, color)\n        longest_subsegment = find_longest_subsegment(start, end)\n        paint(start, start + longest_subsegment - 1, s[start - 1])\n        return longest_subsegment\n\n    max_koyomities = []\n\n    for plan in plans:\n        start, end, color = plan\n        max_koyomity_start = start\n        max_koyomity_end = start\n        max_koyomity_color = s[start - 1]\n\n        for i in range(start, end + 1):\n            if s[i - 1] == color:\n                max_koyomity_start = i\n            else:\n                max_koyomity_end = i - 1\n                max_koyomity_color = s[i - 1]\n                break\n\n        max_koyomity_length = max_koyomity(max_koyomity_start, max_koyomity_end, max_koyomity_color)\n        max_koyomities.append(max_koyomity_length)\n\n    return \"\\n\".join(map(str, max_koyomities))\n"
    },
    {
        "number": 1769,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days_up, days_down = map(int, stdin.split())\n    stops = [1] * (days_up + days_down + 1)\n    stops[days_up] = 2\n    stops[days_up + 1] = 1\n    for i in range(days_up + 2, days_up + days_down + 2):\n        stops[i] = stops[i - 1] + 1\n    return''.join(map(str, stops))"
    },
    {
        "number": 1770,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, x, y, d = map(int, stdin.split('\\n')[1].split())\n        if x > y:\n            x, y = y, x\n        if x == y:\n            print(-1)\n        else:\n            min_moves = 0\n            for i in range(x, y + 1, d):\n                min_moves += 1\n            print(min_moves)"
    },
    {
        "number": 1771,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, w_max = map(int, stdin.split())\n    clouds = []\n    for _ in range(n):\n        x, v = map(int, stdin.split())\n        clouds.append((x, v))\n\n    def is_valid(i, j, w):\n        return abs(clouds[i][0] - clouds[j][0]) >= l and abs(clouds[i][1] + clouds[j][1]) <= w_max\n\n    def count_pairs(w):\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid(i, j, w):\n                    count += 1\n        return count\n\n    return str(count_pairs(1))"
    },
    {
        "number": 1772,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    \n    def is_large(bouquet):\n        return sum(bouquet) % 2 == 1\n    \n    def is_valid(bouquet):\n        return all(is_large(bouquet[:i]) for i in range(1, len(bouquet)))\n    \n    def max_large_bouquets(bouquets):\n        return max(1, len(bouquets) // 2)\n    \n    bouquets = [a]\n    for i in range(n - 1):\n        bouquets.append(bouquets[-1] + a[i])\n    \n    return str(max_large_bouquets(bouquets))"
    },
    {
        "number": 1773,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trees = []\n    for i in range(n):\n        x, a = map(int, stdin.split()[1:])\n        trees.append((x, a))\n\n    trees.sort(key=lambda x: x[0])\n\n    max_apples = 0\n    current_x = 0\n    current_direction = 1\n\n    for x, a in trees:\n        if x == current_x:\n            current_direction *= -1\n        else:\n            max_apples += a * current_direction\n            current_x = x\n            current_direction = 1\n\n    max_apples += a * current_direction\n\n    return str(max_apples)"
    },
    {
        "number": 1774,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == 'H':\n                stack.append(c)\n            elif c == 'Q':\n                if not stack:\n                    return False\n                if stack[-1] == 'H':\n                    stack.pop()\n                else:\n                    return False\n        return not stack\n\n    if is_valid(stdin):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1775,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    droids = []\n    for _ in range(n):\n        droids.append(list(map(int, stdin.split())))\n\n    def is_destroyed(droid):\n        return all(droid[i] == 0 for i in range(m))\n\n    def max_length_subsequence(droids):\n        max_length = 0\n        for i in range(len(droids)):\n            for j in range(i + 1, len(droids)):\n                if is_destroyed(droids[i]) and is_destroyed(droids[j]):\n                    max_length = max(max_length, j - i + 1)\n        return max_length\n\n    def max_length_subsequence_with_shots(droids, shots):\n        max_length = 0\n        for i in range(len(droids)):\n            for j in range(i + 1, len(droids)):\n                if is_destroyed(droids[i]) and is_destroyed(droids[j]):\n                    max_length = max(max_length, j - i + 1)\n                    if max_length == k:\n                        return max_length\n        return max_length\n\n    max_length = max_length_subsequence(droids)\n    shots = max_length_subsequence_with_shots(droids, k)\n\n    return \" \".join(map(str, shots))\n"
    },
    {
        "number": 1776,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    E, P, M = stdin.split()\n    E = E.replace('?', '')\n    E = E.replace('(', '')\n    E = E.replace(')', '')\n    E = E.replace('+', '')\n    E = E.replace('-', '')\n    E = E.replace(' ', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E.replace('?', '')\n    E = E."
    },
    {
        "number": 1777,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bracket_sequences = [line.strip() for line in stdin.split('\\n')[1:]]\n\n    pairs = []\n    for i in range(len(bracket_sequences)):\n        for j in range(i + 1, len(bracket_sequences)):\n            if is_correct_pair(bracket_sequences[i], bracket_sequences[j]):\n                pairs.append((bracket_sequences[i], bracket_sequences[j]))\n\n    return str(len(pairs))\n\n\ndef"
    },
    {
        "number": 1778,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    while a and b:\n        if a[0] < b[0]:\n            a.remove(a[0])\n        else:\n            b.remove(b[0])\n\n    return str(max(a, b))"
    },
    {
        "number": 1779,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_layout = stdin.split()[0]\n    second_layout = stdin.split()[1]\n    text = stdin.split()[2]\n\n    def swap_keys(key: str) -> str:\n        if key in first_layout:\n            return second_layout[first_layout.index(key)]\n        elif key in second_layout:\n            return first_layout[second_layout.index(key)]\n        else:\n            return key\n\n    def swap_text(text: str) -> str:\n        return ''.join(swap_keys(key) for key in text)\n\n    result = swap_text(text)\n    print(result)"
    },
    {
        "number": 1780,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        queries.append((l, r))\n\n    def can_be_rearranged(a: list) -> bool:\n        return sum(a) == 0\n\n    def sum_of_elements(l: int, r: int) -> int:\n        return sum(a[l - 1:r])\n\n    def check_queries(a: list) -> list:\n        result = []\n        for l, r in queries:\n            if can_be_rearranged(a[l - 1:r]):\n                result.append(1)\n            else:\n                result.append(0)\n        return result\n\n    return \" \".join(map(str, check_queries(a)))\n"
    },
    {
        "number": 1782,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"-1\"\n\n    def is_safe(U: List[Set[int]]) -> bool:\n        for i in range(k):\n            for j in range(i + 1, k):\n                if U[i].intersection(U[j]):\n                    return False\n                if not U[i].isdisjoint(U[j]):\n                    return False\n        return True\n\n    def find_safe_partition(U: List[Set[int]]) -> List[int]:\n        for i in range(1, n + 1):\n            if is_safe(U):\n                return [i] + find_safe_partition(U)\n        return []\n\n    U = [set(range(1, n + 1)) for _ in range(k)]\n    safe_partition = find_safe_partition(U)\n    return \" \".join(map(str, safe_partition))\n"
    },
    {
        "number": 1783,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    total_sleep = sum(a)\n    total_weeks = n - k + 1\n\n    average_sleep = total_sleep / total_weeks\n\n    return f\"{average_sleep:.6f}\""
    },
    {
        "number": 1784,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def paint(piles: List[int], colors: List[int]) -> List[int]:\n        used_colors = set()\n        result = []\n\n        for pile in piles:\n            for color in colors:\n                if color not in used_colors:\n                    used_colors.add(color)\n                    result.append(color)\n                    break\n\n        return result\n\n    def is_valid(piles: List[int], colors: List[int]) -> bool:\n        used_colors = set()\n        for pile in piles:\n            for color in colors:\n                if color not in used_colors:\n                    used_colors.add(color)\n                    break\n                elif color in used_colors and color!= colors[piles.index(pile)]:\n                    return False\n        return True\n\n    piles = [a[i:i + n] for i in range(0, len(a), n)]\n    colors = [i for i in range(1, k + 1)]\n\n    for i in range(len(piles)):\n        colors = paint(piles[i], colors)\n\n    if not is_valid(piles, colors):\n        return \"NO\"\n\n    for pile in piles:\n        print(\" \".join(map(str, pile)))\n\n    return \"YES\"\n"
    },
    {
        "number": 1785,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    MOD = 10**9 + 7\n\n    def h(s: str, t: str) -> int:\n        return sum(1 for i in range(n) if s[i] == t[i])\n\n    def rho(s: str, t: str) -> int:\n        return sum(h(s, t[i:]) + h(s[i:], t) for i in range(n))\n\n    def max_rho(s: str) -> int:\n        return max(rho(s, t) for t in itertools.permutations(s))\n\n    def count_strings(s: str) -> int:\n        return sum(1 for t in itertools.permutations(s) if rho(s, t) == max_rho(s))\n\n    return str(count_strings(s) % MOD)\n"
    },
    {
        "number": 1786,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, n = map(int, stdin.split())\n    cuts = []\n    for _ in range(n):\n        line = stdin.split()\n        if line[0] == 'H':\n            cuts.append((line[1], 0))\n        elif line[0] == 'V':\n            cuts.append((0, line[1]))\n    cuts.sort()\n    max_area = 0\n    for cut in cuts:\n        x, y = cut\n        area = x * y\n        if area > max_area:\n            max_area = area\n    return str(max_area)"
    },
    {
        "number": 1787,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    MOD = 10**9 + 7\n    dp = [0] * n\n    dp[0] = 1\n    for i in range(1, n):\n        if s[i] == 'a':\n            dp[i] = dp[i - 1]\n        else:\n            for j in range(i):\n                if s[j] == 'b' and s[i] == 'a' and j < i - 1:\n                    dp[i] = (dp[i] + dp[j]) % MOD\n    return str(dp[n - 1])"
    },
    {
        "number": 1788,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = 0\n    y = 0\n    while x + y!= a or x - y!= b:\n        x += 1\n        y = 0\n    return f\"{x} {y}\""
    },
    {
        "number": 1789,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    min_time = float('inf')\n\n    for i in range(1, 100):\n        if i == a - 1:\n            min_time = min(min_time, x)\n        elif i == b - 1:\n            min_time = min(min_time, x + y)\n        else:\n            min_time = min(min_time, x + y)\n\n    return str(min_time)"
    },
    {
        "number": 1790,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    stops = []\n    for i in range(n):\n        r = int(stdin.split()[i+1])\n        stops.append(r)\n    lines = set()\n    for stop in stops:\n        lines.update(stop)\n    return''.join(map(str, sorted(lines)))"
    },
    {
        "number": 1791,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_pile_size = 0\n    current_pile_size = 1\n    current_pile = [stdin[0]]\n\n    for i in range(1, n):\n        if stdin[i] == stdin[i - 1]:\n            current_pile.append(stdin[i])\n            current_pile_size += 1\n        else:\n            if current_pile_size > max_pile_size:\n                max_pile_size = current_pile_size\n            current_pile = [stdin[i]]\n            current_pile_size = 1\n\n    if current_pile_size > max_pile_size:\n        max_pile_size = current_pile_size\n\n    return str(max_pile_size)"
    },
    {
        "number": 1792,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[n + 1:n + 1 + m]):\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def shortest_distance(x, y):\n        return len(graph[x]) + len(graph[y])\n\n    def is_reachable(x, y):\n        return shortest_distance(x, y) <= 2\n\n    def is_attackable(x, y):\n        return graph[x].count(y) <= 1 and graph[y].count(x) <= 1\n\n    def is_dummy_base(x):\n        return is_reachable(x, x)\n\n    def dummy_base_cost(x):\n        return h\n\n    def rebels_lose_gold(x):\n        return k\n\n    def rebels_lose_dummy_base_cost(x):\n        return 0\n\n    def rebels_lose_spaceship_cost(x):\n        return 0\n\n    def rebels_lose_base_cost(x):\n        return k\n\n    def rebels_lose_total_cost(x):\n        return rebels_lose_gold(x) + rebels_lose_dummy_base_cost(x) + rebels_lose_spaceship_cost(x) + rebels_lose_base_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base(x):\n        return rebels_lose_total_cost(x) + dummy_base_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship(x):\n        return rebels_lose_total_cost_with_dummy_base(x) + rebels_lose_spaceship_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base(x):\n        return rebels_lose_total_cost_with_dummy_base_and_spaceship(x) + rebels_lose_base_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship(x):\n        return rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base(x) + rebels_lose_spaceship_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base(x):\n        return rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship(x) + rebels_lose_base_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship(x):\n        return rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base(x) + rebels_lose_spaceship_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship_and_base(x):\n        return rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship(x) + rebels_lose_base_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship(x):\n        return rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship_and_base(x) + rebels_lose_spaceship_cost(x)\n\n    def rebels_lose_total_cost_with_dummy_base_and_spaceship_and_base_and_spaceship_and_base_and_spaceship_and_base_"
    },
    {
        "number": 1793,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, S = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    def dfs(node: int, path: list, depth: int) -> int:\n        if depth == n:\n            return 1\n\n        res = 0\n        for child in range(1, n + 1):\n            if child == node or p[child - 1] == node:\n                continue\n\n            res += dfs(child, path + [child], depth + 1)\n\n        return min(res, L - len(path))\n\n    res = dfs(1, [], 1)\n    if res == L:\n        return \"1\"\n    elif res == 0:\n        return \"-1\"\n    else:\n        return str(res)"
    },
    {
        "number": 1794,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def min_tickets(i, j):\n        if i == j:\n            return 1\n        if i > j:\n            return 0\n        return min_tickets(i + 1, j)\n\n    total = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            total += min_tickets(i, j)\n\n    return str(total)"
    },
    {
        "number": 1795,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    f = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if f[i] == j or f[j] == i:\n                continue\n            for k in range(j + 1, n):\n                if f[k] == i or f[k] == j:\n                    continue\n                if f[i] == f[j] and f[j] == f[k]:\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1796,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = 0\n    for _ in range(n):\n        operation = stdin.split()[1]\n        if operation == \"++\":\n            x += 1\n        elif operation == \"--\":\n            x -= 1\n    return str(x)"
    },
    {
        "number": 1797,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    # check if the subway is convenient enough\n    max_convenience = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_convenience = max(max_convenience, p[i] + p[j])\n\n    return str(max_convenience)"
    },
    {
        "number": 1798,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    valid_x = []\n    for i in range(n):\n        if a[i] in valid_x:\n            continue\n        for j in range(i + 1, n):\n            if a[j] - a[i] == a[i] - a[j]:\n                valid_x.append(a[i])\n                break\n\n    print(len(valid_x))\n    for x in valid_x:\n        p_x = a[a.index(x) + 1] - a[a.index(x)]\n        print(x, p_x)\n\n    return \"\"\n\n\ndef"
    },
    {
        "number": 1799,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    teams = []\n    for _ in range(n):\n        t, w = map(int, stdin.split()[1:])\n        teams.append((t, w))\n    teams.sort(key=lambda x: (-x[0], x[1]))\n    best_place = 1\n    for i, (t, w) in enumerate(teams):\n        if t > w:\n            best_place += 1\n    return str(best_place)"
    },
    {
        "number": 1800,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    operations = []\n    for _ in range(m):\n        t, r = map(int, stdin.split())\n        operations.append((t, r))\n\n    def sort_numbers(numbers, order):\n        if order == 1:\n            return sorted(numbers)\n        elif order == 2:\n            return sorted(numbers, reverse=True)\n        else:\n            return numbers\n\n    def process_report(report, operations):\n        for t, r in operations:\n            report = sort_numbers(report[:r], t)\n        return report\n\n    final_report = process_report(a, operations)\n    return \" \".join(map(str, final_report))"
    },
    {
        "number": 1801,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    m = int(stdin.split()[-1])\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def count_distinct_sequences(sequences):\n        distinct_sequences = set()\n        for i in range(1, 2 * n + 1):\n            for j in range(i):\n                if i - j >= 2 * n:\n                    break\n                distinct_sequences.add(tuple(sorted(sequences[j][:i - j])))\n        return distinct_sequences\n\n    def count_distinct_sequences_with_x_coordinates_increasing(sequences):\n        distinct_sequences = set()\n        for i in range(1, 2 * n + 1):\n            for j in range(i):\n                if i - j >= 2 * n:\n                    break\n                if sequences[j][i - j] > sequences[j][i - j + 1]:\n                    distinct_sequences.add(tuple(sorted(sequences[j][:i - j])))\n        return distinct_sequences\n\n    def count_distinct_sequences_with_x_coordinates_increasing_and_y_coordinates_increasing(sequences):\n        distinct_sequences = set()\n        for i in range(1, 2 * n + 1):\n            for j in range(i):\n                if i - j >= 2 * n:\n                    break\n                if sequences[j][i - j] > sequences[j][i - j + 1] and sequences[j][i - j] < sequences[j][i - j + 2]:\n                    distinct_sequences.add(tuple(sorted(sequences[j][:i - j])))\n        return distinct_sequences\n\n    def count_distinct_sequences_with_x_coordinates_increasing_and_y_coordinates_increasing_and_x_coordinates_not_decreasing(sequences):\n        distinct_sequences = set()\n        for i in range(1, 2 * n + 1):\n            for j in range(i):\n                if i - j >= 2 * n:\n                    break\n                if sequences[j][i - j] > sequences[j][i - j + 1] and sequences[j][i - j] < sequences[j][i - j + 2] and all(x <= y for x, y in zip(sequences[j][:i - j], sequences[j][:i - j + 2])):\n                    distinct_sequences.add(tuple(sorted(sequences[j][:i - j])))\n        return distinct_sequences\n\n    def count_distinct_sequences_with_x_coordinates_increasing_and_y_coordinates_increasing_and_x_coordinates_not_decreasing_and_y_coordinates_not_decreasing(sequences):\n        distinct_sequences = set()\n        for i in range(1, 2 * n + 1):\n            for j in range(i):\n                if i - j >= 2 * n:\n                    break\n                if sequences[j][i - j] > sequences[j][i - j + 1] and sequences[j][i - j] < sequences[j][i - j + 2] and all(x <= y for x, y in zip(sequences[j][:i - j], sequences[j][:i - j + 2])) and all(x <= y for x, y in zip(sequences[j][:i - j], sequences[j][:i - j + 2])):\n                    distinct_sequences.add(tuple(sorted(sequences[j][:i - j])))\n        return distinct_sequences\n\n    def count_distinct_sequences_with_x_coordinates_increasing_and_y_coordinates_increasing_and_x_coordinates_not_decreasing_and_y_coordinates_not_decreasing_and_x_coordinates_not_decreasing(sequences):\n        distinct_sequences = set()\n        for i in range(1, 2 * n + 1):\n            for j in range(i):\n                if i - j >= 2 * n:\n                    break\n                if sequences[j][i - j] > sequences[j][i - j + 1] and sequences[j][i - j] < sequences[j][i - j + 2] and all(x <= y for x, y in zip(sequences[j][:i - j], sequences[j][:i - j + 2])) and all(x <= y for x, y in zip(sequences[j][:i - j], sequences[j][:i - j + 2])) and all"
    },
    {
        "number": 1802,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    heights = list(map(int, stdin.split()[1:]))\n\n    # sort the heights in non-decreasing order\n    heights.sort()\n\n    # initialize the variables\n    max_buns = 0\n    lowest_height = heights[0]\n    step = 1\n\n    # iterate through the heights\n    for i in range(1, n):\n        # if the height of the current student is greater than the lowest height, update the lowest height and step\n        if heights[i] > lowest_height:\n            lowest_height = heights[i]\n            step = 1\n        # if the height of the current student is less than the lowest height, update the step\n        elif heights[i] < lowest_height:\n            step = 1\n        # if the height of the current student is equal to the lowest height, update the step\n        else:\n            step += 1\n\n        # update the maximum number of buns\n        max_buns = max(max_buns, step)\n\n    # print the maximum number of buns and the lowest height and step\n    return f\"{max_buns} {lowest_height} {step}\""
    },
    {
        "number": 1803,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    wires = [[] for _ in range(n + 1)]\n    for i, ai in enumerate(a):\n        wires[i].extend(ai)\n    for x, y in map(lambda x: map(int, x.split()), stdin.split()[2:]):\n        wires[x].pop(y - 1)\n    return '\\n'.join(map(str, len(wires[i]) for i in range(1, n + 1)))"
    },
    {
        "number": 1804,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c, h = map(int, stdin.split())\n    hotels = []\n    restaurants = []\n\n    for _ in range(c):\n        x, y = map(int, stdin.split())\n        hotels.append((x, y))\n\n    for _ in range(h):\n        x, y = map(int, stdin.split())\n        restaurants.append((x, y))\n\n    def distance(a: tuple, b: tuple) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_distance(hotel: tuple, restaurants: list) -> int:\n        min_distance = float('inf')\n        for restaurant in restaurants:\n            distance_to_hotel = distance(hotel, restaurant)\n            if distance_to_hotel < min_distance:\n                min_distance = distance_to_hotel\n        return min_distance\n\n    min_distances = [min_distance(hotel, restaurants) for hotel in hotels]\n    optimal_distance = min(min_distances)\n    optimal_hotel_index = min_distances.index(optimal_distance)\n\n    return str(optimal_distance) + '\\n' + str(optimal_hotel_index + 1)"
    },
    {
        "number": 1805,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n = int(stdin.split()[1])\n        if n == 2:\n            print(1)\n        elif n == 5:\n            print(2)\n        else:\n            print(n)"
    },
    {
        "number": 1806,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    intervals = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        intervals.append((l, r))\n\n    queries = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        queries.append((x, y))\n\n    def find_intervals(x: int, y: int) -> int:\n        left, right = 0, len(intervals) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if intervals[mid][0] <= x and x <= intervals[mid][1]:\n                return mid\n            elif intervals[mid][0] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    result = []\n    for query in queries:\n        left, right = query\n        if left == right:\n            result.append(1)\n        else:\n            mid = find_intervals(left, right)\n            if mid == -1:\n                result.append(-1)\n            else:\n                result.append(mid + 1)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1807,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_segments = 0\n    for i in range(a, b+1):\n        total_segments += len(str(i))\n    return str(total_segments)"
    },
    {
        "number": 1808,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    min_time = 0\n    for i in range(2, n + 1):\n        if a[i] - a[i - 1] >= x:\n            min_time += a[i] - a[i - 1]\n            k -= 1\n            if k == 0:\n                break\n    return str(min_time)"
    },
    {
        "number": 1809,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def stack_books(books: list, w: list, b: list) -> int:\n        total_weight = 0\n        stack = []\n        for i in range(len(books)):\n            if books[i] == b[j]:\n                stack.append(books[i])\n            else:\n                while stack and stack[-1]!= b[j]:\n                    total_weight += w[stack.pop()]\n                stack.append(books[i])\n        while stack:\n            total_weight += w[stack.pop()]\n        return total_weight\n\n    min_weight = float('inf')\n    for i in range(1, m + 1):\n        min_weight = min(min_weight, stack_books(b, w, b[:i]))\n\n    return str(min_weight)"
    },
    {
        "number": 1810,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(2, n+1):\n        if n % i == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1811,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    road = list(stdin.strip())\n\n    def can_reach_end(sector: int) -> bool:\n        if sector == n:\n            return True\n\n        if road[sector] == \"#\":\n            return False\n\n        return can_reach_end(sector + 1)\n\n    return \"YES\" if can_reach_end(1) else \"NO\""
    },
    {
        "number": 1812,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        for k in range(1, 100001):\n            if k * 2 ** i in a:\n                print(k)\n                break"
    },
    {
        "number": 1813,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    a.sort()\n    count = 0\n    current_sum = 0\n    current_piece = []\n\n    for num in a:\n        current_sum += num\n        current_piece.append(num)\n\n        if current_sum - current_piece[0] <= s:\n            count += 1\n            if count == n:\n                return str(count)\n        else:\n            current_sum = num\n            current_piece = [num]\n\n    return str(-1)"
    },
    {
        "number": 1814,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, c_l, c_e, v = map(int, stdin.split())\n    l_stairs = list(map(int, stdin.split()))\n    elevators = list(map(int, stdin.split()))\n    q = int(stdin.split()[0])\n\n    def get_time(x1, y1, x2, y2):\n        if x1 == x2:\n            return abs(y1 - y2)\n        elif y1 == y2:\n            return abs(x1 - x2)\n        else:\n            return abs(x1 - x2) + abs(y1 - y2)\n\n    def get_min_time(x1, y1, x2, y2):\n        if x1 == x2:\n            return min(y1, y2)\n        elif y1 == y2:\n            return min(x1, x2)\n        else:\n            return min(x1, x2) + min(y1, y2)\n\n    def get_min_time_from_stairs(x1, y1, x2, y2):\n        if x1 == x2:\n            return min(y1, y2)\n        elif y1 == y2:\n            return min(x1, x2)\n        else:\n            return min(x1, x2) + min(y1, y2)\n\n    def get_min_time_from_elevator(x1, y1, x2, y2):\n        if x1 == x2:\n            return min(y1, y2)\n        elif y1 == y2:\n            return min(x1, x2)\n        else:\n            return min(x1, x2) + min(y1, y2)\n\n    min_times = []\n    for i in range(q):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        if x1 == x2 and y1 == y2:\n            min_times.append(0)\n        elif x1 == x2:\n            min_times.append(get_time(x1, y1, x2, y2))\n        elif y1 == y2:\n            min_times.append(get_time(x1, y1, x2, y2))\n        else:\n            min_times.append(get_min_time(x1, y1, x2, y2))\n\n    return \"\\n\".join(map(str, min_times))\n"
    },
    {
        "number": 1815,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    u = list(map(int, stdin.split()[1:]))\n    \n    x = 1\n    while x <= n:\n        if sum(u[:x]) == x:\n            return str(x)\n        x += 1\n    \n    return str(x)"
    },
    {
        "number": 1816,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *fragments = map(int, stdin.split())\n    time = 0\n    for i in range(n):\n        time += abs(fragments[i] - fragments[i - 1])\n    return str(time)"
    },
    {
        "number": 1817,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    nums = list(map(int, stdin.split()[1:]))\n\n    def min_max(nums):\n        min_num = max_num = nums[0]\n        for num in nums:\n            if num < min_num:\n                min_num = num\n            elif num > max_num:\n                max_num = num\n        return min_num, max_num\n\n    min_num, max_num = min_max(nums)\n    if min_num == max_num:\n        return str(min_num)\n\n    for i in range(n - 1):\n        min_num, max_num = min_max(nums)\n        if min_num == max_num:\n            return str(min_num)\n        nums.remove(min_num)\n\n    return str(max_num)"
    },
    {
        "number": 1818,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1819,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [tuple(map(int, line.split())) for line in stdin.split('\\n')]\n    result = []\n\n    for query in queries:\n        n, x = query\n        remaining = [i for i in range(1, n+1) if i!= x]\n        if not remaining:\n            result.append(0)\n        else:\n            result.append(remaining[0])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1820,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        for i in range(n - 2):\n            for j in range(i + 1, n - 1):\n                for k in range(j + 1, n):\n                    if a[i] + a[j] > a[k]:\n                        print(i + 1, j + 1, k + 1)\n                        break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n        else:\n            print(-1)\n    return ''"
    },
    {
        "number": 1821,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_melody(subseq: list) -> bool:\n        for i in range(len(subseq) - 1):\n            if abs(subseq[i] - subseq[i + 1])!= 1 and subseq[i] % 7!= subseq[i + 1] % 7:\n                return False\n        return True\n\n    def max_length(subseq: list) -> int:\n        return max(subseq) - min(subseq)\n\n    def max_sum(subseq1: list, subseq2: list) -> int:\n        return max(max_length(subseq1), max_length(subseq2))\n\n    subseq1 = sorted(set(a[:n]))\n    subseq2 = sorted(set(a[n:]))\n\n    if is_melody(subseq1) and is_melody(subseq2):\n        return str(max_sum(subseq1, subseq2))\n    else:\n        return \"0\""
    },
    {
        "number": 1822,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(start: int, visited: set) -> list:\n        if start == x:\n            return [start]\n        if start in visited:\n            return []\n        visited.add(start)\n        res = []\n        for i in range(n):\n            if a[i] == 0:\n                continue\n            if a[i] == start:\n                continue\n            res.extend(dfs(a[i], visited))\n        return res\n\n    return \" \".join(map(str, dfs(1, set())))\n"
    },
    {
        "number": 1823,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of stresses for each genre\n    stresses = [0] * k\n    for i in range(n):\n        stresses[a[i] - 1] += 1\n\n    # Find the genre with the minimum number of stresses\n    min_stresses = min(stresses)\n    for i in range(k):\n        if stresses[i] == min_stresses:\n            return str(i + 1)\n\n    # If no genre has the minimum number of stresses, return the first genre\n    return str(1)"
    },
    {
        "number": 1824,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, b, *c = map(int, stdin.split())\n    a = set(a)\n    b = set(b)\n    c = set(c)\n\n    def find_error(errors: set) -> int:\n        for error in errors:\n            if error not in a and error not in b and error not in c:\n                return error\n        return -1\n\n    error_a = find_error(a)\n    error_b = find_error(b)\n    error_c = find_error(c)\n\n    if error_a == error_b == error_c:\n        return str(error_a)\n    elif error_a == error_b:\n        return str(error_a) + \" \" + str(error_c)\n    elif error_a == error_c:\n        return str(error_a) + \" \" + str(error_b)\n    elif error_b == error_c:\n        return str(error_b) + \" \" + str(error_a)\n    else:\n        return \" \".join(map(str, sorted([error_a, error_b, error_c])))\n"
    },
    {
        "number": 1825,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = []\n    for _ in range(n):\n        t, k, *x = map(int, stdin.split()[1:])\n        strings.append((t, k, x))\n    strings.sort(key=lambda x: (x[1], x[2]))\n    result = \"\"\n    for t, k, x in strings:\n        result += t * k\n        for xi in x:\n            result += str(xi)\n    return result"
    },
    {
        "number": 1826,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n    sequence = ''.join(sequence)\n    sequence = sequence.replace('UR', 'D')\n    sequence = sequence.replace('RU', 'D')\n    sequence = ''.join(sequence.split('D'))\n    return str(len(sequence))"
    },
    {
        "number": 1828,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for i in range(n + 1):\n        x, y = map(int, stdin.split()[i + 1].split())\n        points.append((x, y))\n\n    start_point = points[0]\n    end_point = points[-1]\n\n    def is_dangerous_turn(point: tuple) -> bool:\n        x, y = point\n        if x == start_point[0]:\n            return y < start_point[1]\n        elif x == end_point[0]:\n            return y > end_point[1]\n        else:\n            return y!= start_point[1] and y!= end_point[1]\n\n    dangerous_turns = sum(is_dangerous_turn(point) for point in points)\n    return str(dangerous_turns)"
    },
    {
        "number": 1829,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    words_polandball = stdin.split('\\n')[1:n+1]\n    words_enemyball = stdin.split('\\n')[n+1:]\n\n    polandball_words = set(words_polandball)\n    enemyball_words = set(words_enemyball)\n\n    if polandball_words.issubset(enemyball_words):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1830,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    rooks = []\n\n    for i in range(m):\n        x, y = map(int, stdin.split())\n        rooks.append((x - 1, y - 1))\n\n    for x, y in rooks:\n        board[x][y] = 1\n\n    def is_under_attack(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 1:\n                return True\n        return False\n\n    def count_cells(x, y):\n        count = 0\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and board[nx][ny] == 0:\n                count += 1\n        return count\n\n    result = []\n    for x, y in rooks:\n        count = count_cells(x, y)\n        if not is_under_attack(x, y):\n            result.append(count)\n        board[x][y] = 0\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 1831,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    connectors = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        connectors.append((a, b))\n\n    valid = True\n    for a, b in connectors:\n        if a == b:\n            valid = False\n            break\n\n    if valid:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 1832,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        s = []\n        for i in range(n):\n            s.append('a' + ''.join(sorted(str(a[i]))))\n        print('\\n'.join(s))"
    },
    {
        "number": 1833,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, 1 << n):\n        b = [0] * n\n        for j in range(n):\n            if i & (1 << j):\n                b[j] = a[j]\n        if all(b[j] % i == 0 for j in range(n)):\n            count += 1\n            count %= MOD\n    return str(count)"
    },
    {
        "number": 1834,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    for i in range(1, n, 2):\n        if a[i] < a[i - 1]:\n            a[i], a[i - 1] = a[i - 1], a[i]\n\n    for i in range(2, n, 2):\n        if a[i] > a[i - 1]:\n            a[i], a[i - 1] = a[i - 1], a[i]\n\n    if all(a[i] >= a[i - 1] for i in range(1, n, 2)) and all(a[i] <= a[i - 1] for i in range(2, n, 2)):\n        print(\" \".join(map(str, a)))\n    else:\n        print(\"Impossible\")\n"
    },
    {
        "number": 1835,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    test_cases = stdin.split('\\n')[1:]\n\n    for test_case in test_cases:\n        s = test_case.split()[1:]\n        s = [int(x) for x in s]\n        max_palindromes = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        if s[i] == s[j] and s[j] == s[k] and s[k] == s[l]:\n                            max_palindromes += 1\n        print(max_palindromes)\n\n    return ''\n"
    },
    {
        "number": 1836,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[1:][::2]):\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, color):\n        nonlocal max_beauty\n        if node == n:\n            return color == 1\n\n        for neighbor in graph[node]:\n            if neighbor == tail[0]:\n                continue\n            if neighbor in visited:\n                continue\n            visited.add(neighbor)\n            if neighbor == tail[1]:\n                max_beauty = max(max_beauty, color * (len(spines) + 1))\n            else:\n                dfs(neighbor, color)\n\n    max_beauty = 0\n    visited = set()\n    tail = [1, 2, 5]\n    spines = [(2, 5), (3, 5), (4, 5)]\n    dfs(1, 1)\n    return str(max_beauty)"
    },
    {
        "number": 1837,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def swap(a, i, j):\n        a[i], a[j] = a[j], a[i]\n\n    def is_permutation(a):\n        return sorted(a) == list(range(len(a)))\n\n    def is_fixed_point(a):\n        return a == sorted(a)\n\n    def max_fixed_points(a):\n        max_count = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i]!= a[j]:\n                    swap(a, i, j)\n                    if is_permutation(a):\n                        max_count = max(max_count, 1 + max_fixed_points(a))\n                        swap(a, i, j)\n        return max_count\n\n    return str(max_fixed_points(a))"
    },
    {
        "number": 1838,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    words = stdin.split()[2:]\n    relations = []\n\n    for i in range(m):\n        t, x, y = map(int, stdin.split())\n        if t == 1:\n            relations.append((x, y, \"synonymy\"))\n        else:\n            relations.append((x, y, \"antonymy\"))\n\n    for i in range(q):\n        x, y = map(str, stdin.split())\n        if x == y:\n            print(\"1\")\n        elif (x, y) in relations or (y, x) in relations:\n            print(\"2\")\n        else:\n            print(\"3\")\n\n    return \"\"\n"
    },
    {
        "number": 1839,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    timetable = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    asphalted = [False] * (n * n)\n    asphalted[0] = True\n\n    days = []\n    for day in range(1, n * n + 1):\n        for intersection in timetable:\n            if asphalted[intersection[0] - 1] and asphalted[intersection[1] - 1]:\n                asphalted[intersection[0] - 1] = asphalted[intersection[1] - 1] = True\n                days.append(day)\n                break\n\n    return''.join(map(str, days))"
    },
    {
        "number": 1840,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, b = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d, g = map(int, stdin.split())\n\n    def can_attack(base_defensive_power, spaceship_attacking_power):\n        return base_defensive_power <= spaceship_attacking_power\n\n    def steal_gold(base_defensive_power, spaceship_attacking_power):\n        return base_defensive_power * spaceship_attacking_power\n\n    def max_steal(spaceship_attacking_power, base_defensive_power, base_gold):\n        return min(steal_gold(base_defensive_power, spaceship_attacking_power), base_gold)\n\n    max_steals = []\n    for i in range(s):\n        max_steals.append(max_steal(a[i], d[0], g))\n\n    return \" \".join(map(str, max_steals))"
    },
    {
        "number": 1841,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n\n    result = []\n    for i in range(m):\n        count = 0\n        for j in range(n):\n            count += len(set(a[l[i] - 1:j]))\n        result.append(count)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1842,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    roots = [(-b + (b**2 - 4*a*c)**0.5) / (2*a), (-b - (b**2 - 4*a*c)**0.5) / (2*a)]\n    optimistic = max(roots)\n    pessimistic = min(roots)\n    return f\"{optimistic:.6f}\\n{pessimistic:.6f}\""
    },
    {
        "number": 1843,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        sum_of_powers = 0\n        for i in range(n):\n            if i & (i - 1) == 0:\n                sum_of_powers += i\n        print(sum_of_powers)"
    },
    {
        "number": 1844,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def gcd_subset(a):\n        return max(a)\n\n    def gcd_subset_size(a):\n        return len(a)\n\n    def gcd_subset_score(a):\n        return gcd(gcd_subset(a), 1)\n\n    def gcd_subset_size_score(a):\n        return gcd_subset_size(a)\n\n    def gcd_subset_score_size(a):\n        return gcd_subset_score(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size(a):\n        return gcd_subset_size_score(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size(a):\n        return gcd_subset_score_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size(a):\n        return gcd_subset_size_score_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size(a):\n        return gcd_subset_score_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size(a):\n        return gcd_subset_size_score_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size_size_size(a):\n        return gcd_subset_score_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size_size_size(a):\n        return gcd_subset_size_score_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size_size_size_size_size(a):\n        return gcd_subset_score_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size_size_size_size(a):\n        return gcd_subset_size_score_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_score_size_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size_size_size_size_size(a):\n        return gcd_subset_size_score_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_score_size_size_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_size_score_size_size_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_score_size_size_size_size_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_size_score_size_size_size_size_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_score_size_size_size_size_size_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_score_size_size_size_size_size_size_size_size_size_size(a), gcd_subset_size(a)\n\n    def gcd_subset_size_score_size_size_size_size_size_size_size_size_size_size_size_size(a):\n        return gcd_subset_size_score_size_size_size"
    },
    {
        "number": 1845,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = sorted(a)\n    total_power = sum(a)\n    min_power = total_power\n\n    for i in range(n - 1):\n        if a[i] % a[i + 1] == 0:\n            x = a[i] // a[i + 1]\n            a[i] = a[i] // x\n            a[i + 1] = a[i + 1] * x\n            total_power -= a[i] * x\n            min_power = min(min_power, total_power)\n\n    return str(min_power)"
    },
    {
        "number": 1846,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    k = 0\n    for i in range(1, n):\n        if t[i] < 0:\n            k = i\n            break\n    if k == 0:\n        return \"0\"\n    for i in range(k, n):\n        if t[i] > 0:\n            return str(i - k)\n    return \"0\""
    },
    {
        "number": 1847,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_0, y_0, x_1, y_1 = map(int, stdin.split())\n    n = int(stdin.split()[1])\n    segments = []\n    for _ in range(n):\n        r, a, b = map(int, stdin.split())\n        segments.append((r, a, b))\n    segments.sort(key=lambda x: (x[0], x[1]))\n\n    def is_allowed(x: int, y: int) -> bool:\n        for r, a, b in segments:\n            if a <= x <= b and a <= y <= b:\n                return True\n        return False\n\n    def bfs(x: int, y: int) -> int:\n        queue = [(x, y)]\n        visited = set()\n        visited.add((x, y))\n        steps = 0\n        while queue:\n            steps += 1\n            for _ in range(len(queue)):\n                x, y = queue.pop(0)\n                if x == x_1 and y == y_1:\n                    return steps\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 1 <= nx <= 10**9 and 1 <= ny <= 10**9 and (nx, ny) not in visited and is_allowed(nx, ny):\n                        queue.append((nx, ny))\n                        visited.add((nx, ny))\n        return -1\n\n    return str(bfs(x_0, y_0))"
    },
    {
        "number": 1848,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_valid(a: list) -> bool:\n        for i in range(1, len(a)):\n            if a[i] + 1 > a[i]:\n                return False\n        return True\n\n    def max_neighbouring_pairs(a: list) -> int:\n        count = 0\n        for i in range(len(a) - 1):\n            if a[i] + 1 > a[i + 1]:\n                count += 1\n        return count\n\n    if is_valid(a):\n        return str(max_neighbouring_pairs(a))\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 1849,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"10\"\n    else:\n        blocks = [0] * n\n        for i in range(1, 10 ** n):\n            if i % 10 == 0:\n                blocks[0] += 1\n            else:\n                blocks[i % 10] += 1\n        return \" \".join(map(str, blocks))"
    },
    {
        "number": 1850,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    s.sort(reverse=True)\n    p.sort(reverse=True)\n\n    best_score = 0\n    best_rank = 0\n\n    for i in range(n):\n        if s[i] > best_score:\n            best_score = s[i]\n            best_rank = i + 1\n\n    if best_rank == d:\n        return str(best_rank)\n\n    for i in range(n):\n        if s[i] == best_score and i < d:\n            return str(i + 1)\n\n    return str(n + 1)"
    },
    {
        "number": 1851,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(set(a))\n    a.sort()\n    days = 0\n    for i in range(1, n + 1):\n        if i in a:\n            days += 1\n            a.remove(i)\n        if not a:\n            break\n    return str(days)"
    },
    {
        "number": 1852,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    edges.sort()\n\n    def dfs(node, parent, depth):\n        nonlocal ans\n        if node == 0:\n            return\n        if node in visited:\n            return\n        visited.add(node)\n        if node == 1:\n            ans.add(depth)\n        else:\n            dfs(node - 1, node, depth + 1)\n            dfs(node + 1, node, depth + 1)\n\n    visited = set()\n    ans = set()\n    dfs(1, 0, 0)\n    if len(ans) == 0:\n        print(0)\n    else:\n        print(len(ans))\n        print(' '.join(map(str, sorted(ans))))"
    },
    {
        "number": 1853,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    def find_array(pairs: List[Tuple[int, int]]) -> List[int]:\n        array = [0] * n\n        for a, b in pairs:\n            array[a - 1] += 1\n            array[b - 1] -= 1\n        return array\n\n    first_array = find_array(pairs)\n    second_array = find_array(pairs)\n\n    for i in range(n):\n        if first_array[i]!= second_array[i]:\n            return \"NO\"\n\n    for i in range(n):\n        if first_array[i] == 0:\n            return \"NO\"\n\n    for i in range(n):\n        if first_array[i] == 2 and second_array[i] == 1:\n            return \"YES\", \" \".join(map(str, first_array)), \" \".join(map(str, second_array))\n\n    return \"NO\"\n"
    },
    {
        "number": 1854,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    if n > 500 or n < 3 or any(1 > a_i > n - 1 for a_i in a):\n        return \"NO\"\n\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        max_degree = 0\n        for v in range(n):\n            if v == u or (u, v) in edges or (v, u) in edges:\n                continue\n            if v not in visited:\n                max_degree = max(max_degree, dfs(v, visited))\n        return max_degree + 1\n\n    def bfs(u: int, visited: set) -> int:\n        visited.add(u)\n        max_degree = 0\n        queue = deque([u])\n        while queue:\n            v = queue.popleft()\n            for w in range(n):\n                if w == u or (u, w) in edges or (w, u) in edges:\n                    continue\n                if w not in visited:\n                    visited.add(w)\n                    max_degree = max(max_degree, dfs(w, visited))\n                    queue.append(w)\n        return max_degree\n\n    edges = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] <= j - i + 1 <= a[j]:\n                edges.add((i, j))\n                edges.add((j, i))\n\n    visited = set()\n    max_diameter = 0\n    for u in range(n):\n        if u not in visited:\n            max_diameter = max(max_diameter, dfs(u, visited))\n\n    if max_diameter == 0:\n        return \"NO\"\n\n    max_diameter = max_diameter - 1\n\n    for u in range(n):\n        for v in range(u + 1, n):\n            if (u, v) in edges or (v, u) in edges:\n                continue\n            if a[u] <= v - u + 1 <= a[v]:\n                edges.add((u, v))\n                edges.add((v, u))\n\n    visited = set()\n    max_diameter = 0\n    for u in range(n):\n        if u not in visited:\n            max_diameter = max(max_diameter, bfs(u, visited))\n\n    if max_diameter == 0:\n        return \"NO\"\n\n    max_diameter = max_diameter - 1\n\n    return f\"YES {max_diameter}\\n{len(edges)}\\n\".join(f\"{u} {v}\" for u, v in edges)\n"
    },
    {
        "number": 1855,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def partition_value(p: List[int]) -> int:\n        max_value = 0\n        for i in range(1, k + 1):\n            max_value += max(p[j] for j in range(i, n + 1) if j % i == 0)\n        return max_value\n\n    max_value = partition_value(p)\n    count = 0\n    for i in range(1, n + 1):\n        if p.count(i) == 1:\n            count += 1\n\n    result = (max_value, count)\n    return str(result[0]) + \" \" + str(result[1])"
    },
    {
        "number": 1856,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    passwords = stdin.split()[1:]\n    password_set = set(passwords)\n    min_passwords = 0\n    for password in password_set:\n        if all(password[i] == password[j] for i in range(len(password)) for j in range(i + 1, len(password))):\n            min_passwords += 1\n        elif any(password[i] == password[j] for i in range(len(password)) for j in range(i + 1, len(password))):\n            min_passwords += 1\n        else:\n            for password_c in password_set:\n                if all(password[i] == password_c[i] for i in range(len(password))) and all(password[i] == password_c[i] for i in range(len(password_c), len(password))):\n                    min_passwords += 1\n                    break\n    return str(min_passwords)"
    },
    {
        "number": 1857,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    ways = 1\n    for i in range(1, n+1):\n        ways *= i\n    return str(ways)"
    },
    {
        "number": 1858,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"No\"\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def sum_set(set_: list) -> int:\n        return sum(set_)\n\n    def is_valid_partition(set1: list, set2: list) -> bool:\n        return gcd(sum_set(set1), sum_set(set2)) > 1\n\n    def find_valid_partition(n: int) -> list:\n        sets = []\n        for i in range(1, n + 1):\n            sets.append(set())\n        for i in range(1, n + 1):\n            sets[i - 1].add(i)\n        for i in range(n - 1, 0, -1):\n            sets[i - 1].update(sets[i])\n        return sets\n\n    def find_valid_partitions(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order_and_sum(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order_and_sum_and_gcd(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order_and_sum_and_gcd_and_size(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order_and_sum_and_gcd_and_size_and_elements(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order_and_sum_and_gcd_and_size_and_elements_and_order(n: int) -> list:\n        partitions = []\n        for i in range(1, n + 1):\n            partitions.append(find_valid_partition(i))\n        return partitions\n\n    def find_valid_partitions_with_sum_and_gcd_and_size_and_elements_and_order_and_sum_and_gcd_and_size_and_elements_and_order_and_sum(n: int) -> list:\n        partitions = []\n        for i"
    },
    {
        "number": 1859,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    while n!= 0:\n        if n % 2 == 0:\n            n //= 2\n            count += 1\n        else:\n            d = 3\n            while d * d <= n:\n                if n % d == 0:\n                    n //= d\n                    count += 1\n                    break\n                d += 2\n            if d * d > n:\n                n -= 1\n                count += 1\n    return str(count)"
    },
    {
        "number": 1860,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_offices = 0\n    for i in range(10 ** (n - 1), 10 ** n):\n        if i % 10 == 7 and i % 10 == 8:\n            max_offices += 1\n    return str(max_offices)"
    },
    {
        "number": 1861,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = [tuple(sorted(set(card))) for card in stdin.split()]\n    sets = set()\n\n    for i in range(len(cards)):\n        for j in range(i + 1, len(cards)):\n            for k in range(j + 1, len(cards)):\n                if len(set(cards[i] + cards[j] + cards[k])) == 3:\n                    sets.add(tuple(sorted(cards[i] + cards[j] + cards[k])))\n\n    return str(len(sets))"
    },
    {
        "number": 1862,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    socks = list(map(int, stdin.split()[1:]))\n    socks.sort()\n    max_count = 0\n    current_count = 0\n    for i in range(n):\n        if socks[i] == socks[i+1]:\n            current_count += 1\n            if current_count > max_count:\n                max_count = current_count\n        else:\n            current_count = 1\n    return str(max_count)"
    },
    {
        "number": 1863,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    eggs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    eggs.sort(key=lambda x: x[0] + x[1])\n\n    def find_child(egg):\n        for i, (a, g) in enumerate(eggs):\n            if egg[0] <= a + g <= egg[1]:\n                return i\n        return -1\n\n    def find_total_money(child):\n        total_money = 0\n        for egg in eggs:\n            if find_child(egg) == child:\n                total_money += egg[0] + egg[1]\n        return total_money\n\n    def is_valid(child):\n        return abs(find_total_money(child) - 1000) <= 500\n\n    for i in range(n):\n        child = find_child(eggs[i])\n        if is_valid(child):\n            return ''.join(['G' if j == child else 'A' for j in range(n)])\n\n    return '-1'"
    },
    {
        "number": 1864,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    values = list(map(int, stdin.split()[1:]))\n\n    min_sum = float('inf')\n    for i in range(1, 1000):\n        for j in range(1, 1000):\n            for k in range(1, 1000):\n                for l in range(1, 1000):\n                    for m in range(1, 1000):\n                        if i + j + k + l + m == 0:\n                            unfortunate_sum = i * values[0] + j * values[1] + k * values[2] + l * values[3] + m * values[4]\n                            if unfortunate_sum < min_sum:\n                                min_sum = unfortunate_sum\n\n    if min_sum == float('inf'):\n        return str(-1)\n    else:\n        return str(min_sum)"
    },
    {
        "number": 1865,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    swaps = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                swaps.append((i, j))\n                arr[i], arr[j] = arr[j], arr[i]\n\n    print(len(swaps))\n    for swap in swaps:\n        print(swap[0], swap[1])\n\n    return \"\"\n"
    },
    {
        "number": 1866,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [i for i in range(1, n+1)]\n    q = 0\n    while len(set(a)) > 1:\n        for i in range(len(a)):\n            x, y = a[i], a[i+1]\n            t = f(x, y)\n            a[i] = t\n            a[i+1] = t\n            q += 1\n    return str(q)\n\ndef"
    },
    {
        "number": 1867,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    max_beauty = 0\n    start = 0\n    end = 0\n\n    for i in range(1, n):\n        if arr[i] == arr[i - 1]:\n            max_beauty += 1\n        else:\n            max_beauty = 1\n\n        if max_beauty > max_beauty:\n            start = i\n            end = i\n\n    return f\"{start} {end}\""
    },
    {
        "number": 1868,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, A_size = map(int, stdin.split())\n    A = set(map(str, range(A_size)))\n    b = list(map(int, stdin.split()))\n\n    def count_strings(S: str, k: int) -> int:\n        if k == 0:\n            return 1\n        if k > len(S):\n            return 0\n\n        count = 0\n        for i in range(len(S) - k + 1):\n            count += count_strings(S[i:], k - 1)\n\n        return count\n\n    def count_strings_mod(S: str, k: int) -> int:\n        return count_strings(S, k) % (10**9 + 7)\n\n    def transmute(S: str, k: int) -> str:\n        if k == 0:\n            return S\n\n        if k > len(S):\n            return \"\"\n\n        for i in range(len(S) - k + 1):\n            S_i = S[i:i + k]\n            S_i_rev = S_i[::-1]\n            S_i_rev_last = S_i_rev[-k:]\n            S_i_rev_first = S_i_rev[:-k]\n            S_i_last = S_i[-k:]\n            S_i_first = S_i[:-k]\n\n            S_new = S_i_first + S_i_rev_last + S_i_last + S_i_rev_first\n            S_new_rev = S_new[::-1]\n\n            if S_new == S_new_rev:\n                return S_new\n\n        return \"\"\n\n    count = 0\n    for _ in range(m):\n        S = input()\n        k = b.pop(0)\n        T = transmute(S, k)\n        if T in A:\n            count += count_strings_mod(T, k)\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1869,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def count_occurrences(arr, x):\n        count = 0\n        for i in arr:\n            if i == x:\n                count += 1\n        return count\n\n    def min_operations(a, n):\n        min_count = float('inf')\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                if count_occurrences(a, i) >= 1 and count_occurrences(a, j) >= 1:\n                    min_count = min(min_count, count_occurrences(a, i) + count_occurrences(a, j) - 1)\n        return min_count\n\n    return str(min_operations(a, n))"
    },
    {
        "number": 1870,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    words = []\n    for i in range(n):\n        if i == 0:\n            words.append(t[i])\n        elif t[i] - t[i - 1] <= c:\n            words[-1] += \" \" + t[i]\n        else:\n            words = []\n            words.append(t[i])\n\n    return str(len(words))"
    },
    {
        "number": 1871,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def dp(i, j):\n        if i == n:\n            return 0\n        if j == 0:\n            return dp(i + 1, 1)\n        if dp(i, j - 1) == float('inf'):\n            return dp(i + 1, j)\n        return min(dp(i + 1, j), dp(i, j - 1)) + x\n\n    return str(dp(0, 0))"
    },
    {
        "number": 1872,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    if n < 5 or not is_prime(n):\n        return \"Invalid input\"\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def area_of_star(n: int, r: int) -> float:\n        def distance(a: tuple, b: tuple) -> float:\n            return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n        def max_distance(a: tuple, b: tuple) -> float:\n            return max(distance(a, b), distance(b, a))\n\n        def is_valid_point(x: float, y: float) -> bool:\n            return 0 <= x <= r and 0 <= y <= r\n\n        def is_valid_segment(a: tuple, b: tuple) -> bool:\n            return is_valid_point(a[0], a[1]) and is_valid_point(b[0], b[1])\n\n        def is_valid_star(n: int, r: int) -> bool:\n            return all(is_valid_segment(a, b) for a, b in itertools.combinations(points, 2))\n\n        if not is_valid_star(n, r):\n            return \"Invalid input\"\n\n        points = [(x, y) for x in range(r) for y in range(r) if is_valid_point(x, y)]\n        segments = [(a, b) for a, b in itertools.combinations(points, 2) if is_valid_segment(a, b)]\n\n        def area_of_segment(a: tuple, b: tuple) -> float:\n            return 0.5 * (distance(a, b) ** 2)\n\n        return sum(area_of_segment(a, b) for a, b in segments)\n\n    area = area_of_star(n, r)\n    return str(area)"
    },
    {
        "number": 1873,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def count_options(genre_a, genre_b):\n        count = 0\n        for i in range(n):\n            if a[i]!= genre_a and a[i]!= genre_b:\n                count += 1\n        return count\n\n    options = [count_options(a[i], a[j]) for i in range(n) for j in range(i + 1, n)]\n    return str(sum(options))"
    },
    {
        "number": 1874,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_3, l_4, l_5 = map(int, stdin.split())\n    volume = (l_3 * l_3 * l_3 + l_4 * l_4 * l_4 + l_5 * l_5 * l_5) / 6\n    return str(volume)"
    },
    {
        "number": 1875,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[0])\n    points.sort(key=lambda x: x[1])\n    x1, y1, x2, y2, x3, y3, x4, y4 = points\n    area = abs(x1 * (y2 - y3) + x2 * (y3 - y4) + x3 * (y4 - y1) + x4 * (y1 - y2)) / 2\n    return f\"{area:.9f}\""
    },
    {
        "number": 1876,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    edges = [tuple(map(int, stdin.split())) for _ in range(n - 1)]\n    colors = [0] * (n - 1)\n\n    def dfs(u, color):\n        nonlocal colors\n        colors[u] = color\n        for v, x in edges[u]:\n            if colors[v] == 0:\n                dfs(v, 1 - color)\n\n    for u, v, x in edges:\n        if colors[u - 1] == 0:\n            dfs(u - 1, x)\n\n    good_sequences = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            for l in range(j + 1, k):\n                for m in range(l + 1, k):\n                    sequence = [i + 1, j + 1, l + 1, m + 1]\n                    if all(colors[u - 1] == colors[v - 1] for u, v in zip(sequence, sequence[1:])):\n                        good_sequences += 1\n\n    return str((good_sequences % (10 ** 9 + 7)))\n"
    },
    {
        "number": 1877,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = stdin.split()[1]\n    coins = 0\n    x, y = 0, 0\n    for move in sequence:\n        if move == 'U':\n            y += 1\n        elif move == 'R':\n            x += 1\n        else:\n            raise ValueError(\"Invalid move\")\n        if x == 0 and y == 0:\n            continue\n        if x == 0:\n            coins += 1\n        elif x == 1:\n            coins += 2\n        elif x == 2:\n            coins += 3\n        elif x == 3:\n            coins += 4\n        elif x == 4:\n            coins += 5\n        elif x == 5:\n            coins += 6\n        elif x == 6:\n            coins += 7\n        elif x == 7:\n            coins += 8\n        elif x == 8:\n            coins += 9\n        elif x == 9:\n            coins += 10\n        elif x == 10:\n            coins += 11\n        elif x == 11:\n            coins += 12\n        elif x == 12:\n            coins += 13\n        elif x == 13:\n            coins += 14\n        elif x == 14:\n            coins += 15\n        elif x == 15:\n            coins += 16\n        elif x == 16:\n            coins += 17\n        elif x == 17:\n            coins += 18\n        elif x == 18:\n            coins += 19\n        elif x == 19:\n            coins += 20\n        elif x == 20:\n            coins += 21\n        elif x == 21:\n            coins += 22\n        elif x == 22:\n            coins += 23\n        elif x == 23:\n            coins += 24\n        elif x == 24:\n            coins += 25\n        elif x == 25:\n            coins += 26\n        elif x == 26:\n            coins += 27\n        elif x == 27:\n            coins += 28\n        elif x == 28:\n            coins += 29\n        elif x == 29:\n            coins += 30\n        elif x == 30:\n            coins += 31\n        elif x == 31:\n            coins += 32\n        elif x == 32:\n            coins += 33\n        elif x == 33:\n            coins += 34\n        elif x == 34:\n            coins += 35\n        elif x == 35:\n            coins += 36\n        elif x == 36:\n            coins += 37\n        elif x == 37:\n            coins += 38\n        elif x == 38:\n            coins += 39\n        elif x == 39:\n            coins += 40\n        elif x == 40:\n            coins += 41\n        elif x == 41:\n            coins += 42\n        elif x == 42:\n            coins += 43\n        elif x == 43:\n            coins += 44\n        elif x == 44:\n            coins += 45\n        elif x == 45:\n            coins += 46\n        elif x == 46:\n            coins += 47\n        elif x == 47:\n            coins += 48\n        elif x == 48:\n            coins += 49\n        elif x == 49:\n            coins += 50\n        elif x == 50:\n            coins += 51\n        elif x == 51:\n            coins += 52\n        elif x == 52:\n            coins += 53\n        elif x == 53:\n            coins += 54\n        elif x == 54:\n            coins += 55\n        elif x == 55:\n            coins += 56\n        elif x == 56:\n            coins += 57\n        elif x == 57:\n            coins += 58\n        elif x == 58:\n            coins += 59\n        elif x == 59:\n            coins += 60\n        elif x == 60:\n            coins += 61\n        elif x == 61:\n            coins += 62\n        elif x == 62:\n            coins += 63\n        elif x == 63:\n            coins += 64\n        elif x == 64:\n            coins += 65\n        elif x == 65:\n            coins += 66\n        elif x == 66:\n            coins += 67\n        elif x == 67:\n            coins += 68\n        el"
    },
    {
        "number": 1878,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rectangles = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        rectangles.append((x1, y1, x2, y2))\n    table = [[0] * 100 for _ in range(100)]\n    for x1, y1, x2, y2 in rectangles:\n        for i in range(y1, y2 + 1):\n            for j in range(x1, x2 + 1):\n                table[i][j] += 1\n    return str(sum(sum(row) for row in table))"
    },
    {
        "number": 1879,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s_x, s_y, e_x, e_y = map(int, stdin.split())\n    wind_directions = stdin.split()[1]\n    wind_directions = [wind_directions[i:i+2] for i in range(0, len(wind_directions), 2)]\n\n    x, y = s_x, s_y\n    time = 0\n\n    while time < t:\n        if wind_directions[time] == \"E\":\n            x += 1\n        elif wind_directions[time] == \"S\":\n            y -= 1\n        elif wind_directions[time] == \"W\":\n            x -= 1\n        elif wind_directions[time] == \"N\":\n            y += 1\n\n        time += 1\n\n    if x == e_x and y == e_y:\n        return str(time)\n    else:\n        return \"-1\""
    },
    {
        "number": 1880,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    number = int(stdin)\n    shuffle_digits = [number % 10, number // 10 % 10, number // 100 % 10, number // 1000 % 10, number // 10000 % 10]\n    result = 1\n    for digit in shuffle_digits:\n        result *= digit\n    return str(result % 100000)"
    },
    {
        "number": 1881,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    pixels = list(map(int, stdin.split()))\n\n    def group_colors(pixels: List[int], k: int) -> List[int]:\n        groups = []\n        current_group = []\n        for pixel in pixels:\n            if pixel not in current_group:\n                current_group.append(pixel)\n                if len(current_group) == k:\n                    groups.append(current_group)\n                    current_group = []\n        if current_group:\n            groups.append(current_group)\n        return groups\n\n    groups = group_colors(pixels, k)\n    result = []\n    for group in groups:\n        result.append(min(group))\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1882,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = [int(x) for x in stdin.split()]\n    t = [int(x) for x in stdin.split()]\n\n    def solve(i, t_i, a_i, t_left, a_left, score):\n        if t_left <= 0:\n            return score\n        if a_left <= 0:\n            return solve(i + 1, t_i, a_i, t_left, a_left, score)\n\n        if t_i <= t_left:\n            score += 1\n            a_left -= 1\n\n        return solve(i + 1, t_i, a_i, t_left - t_i, a_left, score)\n\n    score = solve(0, t[0], a[0], T, n, 0)\n    k = 0\n    while score < n:\n        k += 1\n        score = solve(0, t[0], a[0], T, n, 0)\n\n    return str(score) + \"\\n\" + str(k) + \"\\n\" + \" \".join(map(str, range(1, k + 1))) + \"\\n\"\n"
    },
    {
        "number": 1883,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, types, ski_tracks = map(int, stdin.split())\n    mountains = [i for i in range(1, n + 1) if types[i - 1] == 0]\n    hotels = [i for i in range(1, n + 1) if types[i - 1] == 1]\n    paths = []\n\n    def dfs(i, path):\n        if len(path) == k:\n            paths.append(path)\n            return\n\n        if i in mountains:\n            dfs(i + 1, path + [i])\n        if i in hotels:\n            dfs(i + 1, path + [i])\n\n        if i in mountains and i + 1 in hotels:\n            dfs(i + 1, path + [i])\n\n    dfs(1, [])\n\n    return str(len(paths)) + \" \" + \" \".join(map(str, paths[0]))"
    },
    {
        "number": 1884,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, x2 = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n\n    if x1 > x2:\n        return \"No\"\n\n    k1 = 0\n    k2 = 0\n\n    for i in range(n):\n        if c[i] >= x1 / k1:\n            k1 += 1\n        else:\n            break\n\n    for i in range(n):\n        if c[i] >= x2 / k2:\n            k2 += 1\n        else:\n            break\n\n    if k1 == 0 or k2 == 0:\n        return \"No\"\n\n    print(\"Yes\")\n    print(k1, k2)\n\n    for i in range(k1):\n        print(i + 1)\n\n    for i in range(k2):\n        print(i + 1 + k1)\n\n    return \"Yes\"\n"
    },
    {
        "number": 1885,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                for l in range(1, n + 1):\n                    for m in range(1, n + 1):\n                        for n in range(1, n + 1):\n                            if i + j + k + l + m + n == n:\n                                count += 1\n    return str(count)"
    },
    {
        "number": 1886,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip().lower()\n    capitalized_word = word[0].upper() + word[1:]\n    return capitalized_word"
    },
    {
        "number": 1887,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    height1 = list(map(int, stdin.split()[1].split()))\n    height2 = list(map(int, stdin.split()[2].split()))\n\n    def find_max_height(heights: list) -> int:\n        max_height = 0\n        for i in range(len(heights)):\n            for j in range(i + 1, len(heights)):\n                max_height = max(max_height, heights[i] + heights[j])\n        return max_height\n\n    max_height1 = find_max_height(height1)\n    max_height2 = find_max_height(height2)\n\n    return str(max(max_height1, max_height2))"
    },
    {
        "number": 1888,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    debts = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        debts.append((a, b, c))\n\n    def min_sum(a, b, c):\n        return min(a, b, c) - max(a, b, c)\n\n    def min_sum_rearrange(a, b, c):\n        return min(a, b, c) - max(a, b, c) + min(a, b)\n\n    min_sum_value = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                current_sum = sum(debts[i][j], debts[j][k], debts[i][k])\n                if current_sum < min_sum_value:\n                    min_sum_value = current_sum\n\n    return str(min_sum_value)\n"
    },
    {
        "number": 1889,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    grid = [list(map(int, stdin.split())) for _ in range(n)]\n    bears = [(i, j) for i in range(n) for j in range(m) if grid[i][j] == 1]\n    bears.remove((0, 0))\n\n    for _ in range(q):\n        i, j = map(int, stdin.split())\n        bears[i - 1] = (bears[i - 1][0], bears[i - 1][1] ^ 1)\n\n    scores = [0] * n\n    for bear in bears:\n        row, col = bear\n        for i in range(row):\n            if grid[i][col] == 1:\n                scores[i] = max(scores[i], scores[row - 1] + 1)\n\n    return \" \".join(map(str, scores))\n"
    },
    {
        "number": 1890,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = stdin.split()\n    n = len(a)\n    k = int(k)\n\n    def count_ways(s: str, deleted: set) -> int:\n        if not s:\n            return 1\n        if s[0] in deleted:\n            return 0\n        return count_ways(s[1:], deleted) + count_ways(s[1:], deleted | {s[0]})\n\n    ways = count_ways(a * k, set())\n    return str(ways % (10**9 + 7))"
    },
    {
        "number": 1891,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def power(n: int) -> int:\n        return 2 ** n\n\n    def burn_base(base: list) -> int:\n        return sum(power(base[i]) for i in range(len(base)))\n\n    def divide_base(base: list) -> tuple:\n        mid = len(base) // 2\n        return base[:mid], base[mid:]\n\n    def destroy_avengers(base: list, avengers: list) -> int:\n        total_power = 0\n        for i in range(len(base)):\n            if i in avengers:\n                total_power += power(base[i])\n        return total_power\n\n    def min_power(base: list, avengers: list) -> int:\n        if len(base) == 1:\n            return burn_base(base)\n        elif len(base) == 2:\n            return min(burn_base(base), destroy_avengers(base, avengers))\n        else:\n            mid, left = divide_base(base)\n            right = destroy_avengers(left, avengers)\n            return min(burn_base(base), right)\n\n    return str(min_power(a, range(1, 2 ** n)))"
    },
    {
        "number": 1892,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(statements: List[str]) -> int:\n        MOD = 10**9 + 7\n        n = len(statements)\n        dp = [0] * n\n\n        for i in range(n):\n            if statements[i] == \"f\":\n                dp[i] = 1\n                for j in range(i + 1, n):\n                    if statements[j] == \"f\":\n                        dp[i] += dp[j]\n                        dp[i] %= MOD\n        return dp[n - 1]\n\n    commands = stdin.split(\"\\n\")\n    statements = []\n    for command in commands:\n        if command == \"s\":\n            statements.append(\"s\")\n        elif command == \"f\":\n            statements.append(\"f\")\n        else:\n            raise ValueError(\"Invalid command\")\n\n    return str(count_ways(statements))\n"
    },
    {
        "number": 1893,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    result = n * (1 + 1e-6) ** t\n    return str(result)"
    },
    {
        "number": 1894,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    floors = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def move(x: int, y: int, direction: int) -> tuple[int, int]:\n        if direction == 0:\n            return x, y - 1\n        elif direction == 1:\n            return x + 1, y\n        else:\n            return x, y + 1\n\n    def is_empty(x: int, y: int) -> bool:\n        return floors[x][y] == '.'\n\n    def is_brick(x: int, y: int) -> bool:\n        return floors[x][y] == '+'\n\n    def is_concrete(x: int, y: int) -> bool:\n        return floors[x][y] == '#'\n\n    def break_brick(x: int, y: int) -> None:\n        floors[x][y] = '.'\n\n    def change_direction(direction: int) -> int:\n        return (direction + 1) % 2\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m\n\n    def is_valid_move(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or is_brick(nx, ny))\n\n    def is_valid_move_with_concrete(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or is_concrete(nx, ny))\n\n    def is_valid_move_with_brick(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or is_brick(nx, ny))\n\n    def is_valid_move_with_concrete_or_brick(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or (is_concrete(nx, ny) or is_brick(nx, ny)))\n\n    def is_valid_move_with_concrete_or_brick_or_empty(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or (is_concrete(nx, ny) or is_brick(nx, ny) or is_empty(nx, ny)))\n\n    def is_valid_move_with_concrete_or_brick_or_empty_or_empty(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or (is_concrete(nx, ny) or is_brick(nx, ny) or is_empty(nx, ny) or is_empty(nx, ny)))\n\n    def is_valid_move_with_concrete_or_brick_or_empty_or_empty_or_empty(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or (is_concrete(nx, ny) or is_brick(nx, ny) or is_empty(nx, ny) or is_empty(nx, ny) or is_empty(nx, ny)))\n\n    def is_valid_move_with_concrete_or_brick_or_empty_or_empty_or_empty_or_empty(x: int, y: int, direction: int) -> bool:\n        nx, ny = move(x, y, direction)\n        return is_valid(nx, ny) and (is_empty(nx, ny) or (is_concrete(nx, ny) or is_brick(nx, ny) or is_empty(nx, ny) or is_empty(nx, ny) or is_empty(nx, ny) or is_empty(nx, ny)))\n\n    def is_valid_move_with_"
    },
    {
        "number": 1895,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(n):\n        event = list(map(int, stdin.split()))\n        events.append(event)\n\n    happy_friends = 0\n    for i in range(m):\n        if events[i][0] == 1:\n            events[i][1] = \"hiasat\"\n        elif events[i][0] == 2:\n            events[i][1] = events[i][1].lower()\n        else:\n            continue\n\n        for j in range(i + 1, m):\n            if events[j][0] == 2 and events[j][1] == events[i][1]:\n                happy_friends += 1\n                break\n\n    return str(happy_friends)"
    },
    {
        "number": 1896,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hexagons = 0\n    for i in range(1, n+1):\n        hexagons += 6 * i * (i - 1) // 2\n    return str(hexagons)"
    },
    {
        "number": 1897,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def vowel(c: str) -> int:\n        return 1 if c in 'AEIOUY' else 0\n\n    def simple_prettiness(s: str) -> float:\n        vowels = sum(vowel(c) for c in s)\n        return vowels / len(s)\n\n    def prettiness(s: str) -> float:\n        return sum(simple_prettiness(s[i:j + 1]) for i in range(len(s)) for j in range(i, len(s)))\n\n    s = stdin.strip()\n    result = prettiness(s)\n    return f\"{result:.6f}\""
    },
    {
        "number": 1898,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = \"\"\n    for i in range(n):\n        if i == 0:\n            result += \"I hate it\"\n        elif i == 1:\n            result += \"I love it\"\n        else:\n            result += \"I hate that \" + result[i-2] + \" and \" + result[i-1]\n    return result"
    },
    {
        "number": 1899,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    segments = []\n    for i in range(s):\n        l, r = map(int, stdin.split())\n        segments.append((l, r))\n\n    a.sort()\n    multiset = [0] * (n + 1)\n    for i in a:\n        multiset[i] += 1\n\n    min_stat = float('inf')\n    for i in range(1, n + 1):\n        if multiset[i] >= k:\n            min_stat = min(min_stat, i)\n\n    if min_stat == float('inf'):\n        return -1\n    else:\n        return str(min_stat)"
    },
    {
        "number": 1900,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    left = 0\n    right = 0\n    count = 0\n\n    while left < n:\n        if right - left + 1 == k:\n            count += 1\n            left = right + 1\n            right = 0\n        elif right - left + 1 > k:\n            count += 1\n            left = right + 1\n            right = 0\n        else:\n            right += 1\n\n    return str(count)"
    },
    {
        "number": 1901,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    pairs = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        pairs.append((x, y))\n\n    def bribe(i: int) -> int:\n        return max(0, c[i] - 1)\n\n    def spread(i: int) -> int:\n        return sum(bribe(j) for j in pairs if j!= i)\n\n    def is_finished(i: int) -> bool:\n        return all(spread(j) >= 0 for j in pairs if j!= i)\n\n    def min_gold(i: int) -> int:\n        return max(0, c[i] - 1 - spread(i))\n\n    gold = 0\n    for i in range(n):\n        if is_finished(i):\n            gold += min_gold(i)\n        else:\n            gold += bribe(i)\n\n    return str(gold)"
    },
    {
        "number": 1902,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    clicks = 0\n    for i, word in enumerate(words):\n        if i == 0:\n            clicks += len(word)\n        else:\n            clicks += len(word) + 1\n    return str(clicks)"
    },
    {
        "number": 1903,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    physics_cups = []\n    informatics_cups = []\n\n    for _ in range(n):\n        c, w = map(int, stdin.split())\n        physics_cups.append((c, w))\n\n    for _ in range(m):\n        c, w = map(int, stdin.split())\n        informatics_cups.append((c, w))\n\n    physics_cups.sort(key=lambda x: x[0])\n    informatics_cups.sort(key=lambda x: x[0])\n\n    total_significance = 0\n    exposed_cups = 0\n\n    for cup in physics_cups:\n        if total_significance + cup[0] <= d:\n            total_significance += cup[0]\n            exposed_cups += 1\n\n    for cup in informatics_cups:\n        if total_significance + cup[0] <= d:\n            total_significance += cup[0]\n            exposed_cups += 1\n\n    if exposed_cups == 0:\n        return \"0\"\n    else:\n        return str(total_significance)"
    },
    {
        "number": 1904,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_hard(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return True\n        return False\n\n    def min_ambiguity(s: str, a: list) -> int:\n        if is_hard(s):\n            return 0\n\n        min_ambiguity = float('inf')\n        for i in range(len(s)):\n            if i not in a:\n                min_ambiguity = min(min_ambiguity, min_ambiguity(s[:i] + s[i + 1:], a) + a[i])\n\n        return min_ambiguity\n\n    return str(min_ambiguity(s, a))\n"
    },
    {
        "number": 1905,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    for i in range(q):\n        t, r, c, x = map(int, stdin.split())\n        if t == 1:\n            matrix[r - 1][c - 1] = (matrix[r - 1][c - 1] + x) % 1000000000\n        elif t == 2:\n            for j in range(m):\n                matrix[r - 1][j] = (matrix[r - 1][j] + x) % 1000000000\n        else:\n            matrix[r - 1][c - 1] = x\n    for row in matrix:\n        print(\" \".join(map(str, row)))\n    return \"\""
    },
    {
        "number": 1906,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 or i % 7 == 0 or i % 11 == 0 or i % 13 == 0 or i % 17 == 0 or i % 19 == 0 or i % 23 == 0 or i % 29 == 0 or i % 31 == 0 or i % 37 == 0 or i % 41 == 0 or i % 43 == 0 or i % 47 == 0 or i % 53 == 0 or i % 59 == 0 or i % 61 == 0 or i % 67 == 0 or i % 71 == 0 or i % 73 == 0 or i % 79 == 0 or i % 83 == 0 or i % 89 == 0 or i % 97 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1907,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    dancers = []\n    for i in range(n):\n        x, y, r = map(int, stdin.split()[1:])\n        dancers.append((x, y, r))\n\n    def distance(a: tuple, b: tuple) -> float:\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_disjoint(a: tuple, b: tuple) -> bool:\n        return distance(a, b) > a[2] + b[2]\n\n    def is_subset(a: tuple, b: tuple) -> bool:\n        return distance(a, b) <= a[2]\n\n    def is_valid(dancer: tuple) -> bool:\n        for i in range(n):\n            if i == dancer[0]:\n                continue\n            if is_disjoint(dancers[i], dancer) or is_subset(dancers[i], dancer):\n                return False\n        return True\n\n    def spaciousness(dancers: list) -> float:\n        spacious = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid((i, j)):\n                    spacious += 1\n        return spacious\n\n    def max_sum(dancers: list) -> float:\n        return max(spaciousness(dancers[:i]) + spaciousness(dancers[i + 1:]) for i in range(len(dancers) // 2))\n\n    return str(max_sum(dancers))\n"
    },
    {
        "number": 1908,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    def dfs(i, visited, order):\n        if i == n:\n            return True\n        if visited[i]:\n            return False\n        visited[i] = True\n        for j in range(n):\n            if j not in visited and (x[j] == i or y[j] == i):\n                if dfs(j, visited, order + [j]):\n                    return True\n        visited[i] = False\n        return False\n\n    alive = dfs(0, [False] * n, [])\n    if alive:\n        print(\"ALIVE\")\n        print(\" \".join(map(str, order)))\n    else:\n        print(\"DEAD\")"
    },
    {
        "number": 1909,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    for i in range(k - 1):\n        a[i] += a[i + 1]\n    return str(a[0])"
    },
    {
        "number": 1910,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    elif n == 3:\n        return \"6\"\n    else:\n        return str(2 * n - 2)"
    },
    {
        "number": 1911,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    a.sort()\n    min_cost = 0\n    max_cost = 0\n\n    for i in range(1, n):\n        min_cost += a[i] - a[i - 1]\n        max_cost = max(max_cost, a[i])\n\n    return str(min_cost)"
    },
    {
        "number": 1912,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        r, g, b, w = map(int, stdin.split('\\n')[1].split())\n        if r + g + b + w == 0:\n            return \"Yes\"\n        elif r + g + b + w == 1:\n            return \"No\"\n        else:\n            for i in range(r, w + 1):\n                for j in range(g, w + 1):\n                    for k in range(b, w + 1):\n                        if i + j + k == r + g + b + w:\n                            return \"Yes\"\n    return \"No\""
    },
    {
        "number": 1913,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    beautiful_numbers = [str(x) for x in range(1, 10) if str(x).count('1') <= 1]\n    beautiful_numbers.extend(beautiful_numbers)\n\n    def is_beautiful(num: str) -> bool:\n        return any(num.count(str(x)) == 1 for x in range(1, 10))\n\n    def product(a: list) -> int:\n        return reduce(lambda x, y: x * y, a)\n\n    def find_beautiful_numbers(a: list) -> list:\n        return [num for num in beautiful_numbers if all(num.count(str(x)) == 1 for x in a)]\n\n    beautiful_numbers = find_beautiful_numbers(a)\n\n    if not beautiful_numbers:\n        return '0'\n\n    result = product(beautiful_numbers)\n    return str(result)"
    },
    {
        "number": 1914,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = stdin.split()\n    t = t.lower()\n    s = [s.lower() for s in stdin.split()[1:]]\n    return str(sum(sum(f(t, s_i + s_j) for s_j in s) for s_i in s))\n\ndef"
    },
    {
        "number": 1915,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = [[1] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, n):\n            a[i][j] = a[i - 1][j] + a[i][j - 1] - a[i - 1][j - 1]\n    max_value = max(sum(row) for row in a)\n    return str(max_value)"
    },
    {
        "number": 1916,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    c = [0] * n\n    for i in range(n):\n        for j in range(m):\n            c[i] |= a[i] & b[j]\n\n    return str(min(c))"
    },
    {
        "number": 1917,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(b):\n        return sum(b * (a[i] - b ** 2) for i in range(n))\n\n    def backtrack(b, used):\n        if sum(used) == k:\n            return f(b)\n        if sum(used) > k:\n            return float('inf')\n\n        for i in range(n):\n            if used[i]:\n                continue\n            used[i] = True\n            if b[i] < a[i]:\n                b[i] += 1\n                res = backtrack(b, used)\n                if res!= float('inf'):\n                    return res\n                b[i] -= 1\n            used[i] = False\n        return float('inf')\n\n    b = [0] * n\n    used = [False] * n\n    res = backtrack(b, used)\n    return''.join(map(str, res))"
    },
    {
        "number": 1918,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    a = ''.join(sorted(set(stdin.split()[2])))\n    b = ''.join(sorted(set(stdin.split()[2])))\n    return str(max(sum(p) for p in [[p for p in a if p == 'A'], [p for p in b if p == 'B']]))"
    },
    {
        "number": 1919,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    else:\n        return \"1\" if is_winnable(n, 1) else \"2\"\n\ndef"
    },
    {
        "number": 1920,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    friends = []\n    for i in range(n):\n        gender, a, b = stdin.split()[1:4]\n        a, b = int(a), int(b)\n        friends.append((gender, a, b))\n\n    male_friends = [f for f in friends if f[0] == 'M']\n    female_friends = [f for f in friends if f[0] == 'F']\n\n    def get_max_friends(friends):\n        max_friends = 0\n        for i in range(len(friends)):\n            for j in range(i + 1, len(friends)):\n                if friends[i][1] <= friends[j][2] and friends[j][1] <= friends[i][2]:\n                    max_friends += 1\n        return max_friends\n\n    max_male_friends = get_max_friends(male_friends)\n    max_female_friends = get_max_friends(female_friends)\n\n    return str(max(max_male_friends, max_female_friends))"
    },
    {
        "number": 1921,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s_x, s_y, f_x, f_y = map(int, stdin.split())\n    instant_locations = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= n and (x, y)!= (s_x, s_y) and (x, y)!= (f_x, f_y)\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        visited.add((x, y))\n        while queue:\n            cx, cy = queue.pop(0)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = cx + dx, cy + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        return visited\n\n    def min_time(start, end):\n        visited = bfs(start[0], start[1])\n        if end in visited:\n            return 0\n        visited.add(end)\n        return 1 + min(min_time(visited.pop(), end) for visited in bfs(end[0], end[1]))\n\n    return str(min_time((s_x, s_y), (f_x, f_y)))"
    },
    {
        "number": 1922,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cards = []\n    for _ in range(n):\n        cards.append(list(map(int, stdin.split())))\n\n    def flip_card(card, target_square):\n        for i in range(8):\n            if (i // 2, i % 2) == target_square:\n                continue\n            if (i // 2, i % 2) in [(0, 0), (0, 1), (1, 0), (1, 1)]:\n                card[i] = not card[i]\n\n    def count_cards(cards):\n        down_cards = 0\n        for card in cards:\n            if all(card):\n                down_cards += 1\n        return down_cards\n\n    for i in range(n):\n        for j in range(m):\n            if cards[i][j] == 1:\n                target_square = (i, j)\n                flip_card(cards[i][j], target_square)\n                flip_card(cards[i][j], (i, j - 1))\n                flip_card(cards[i][j], (i, j + 1))\n                flip_card(cards[i][j], (i - 1, j))\n                flip_card(cards[i][j], (i + 1, j))\n                flip_card(cards[i][j], (i, j - 1))\n                flip_card(cards[i][j], (i, j + 1))\n\n    return str(count_cards(cards))\n"
    },
    {
        "number": 1923,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lengths = map(int, stdin.split())\n    max_ingredients = 0\n    for i in range(n):\n        max_ingredients = max(max_ingredients, lengths[i] + lengths[i + n])\n    return str(max_ingredients)"
    },
    {
        "number": 1924,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def f(r: int, c: int) -> int:\n        if r == 0 and c == 0:\n            return 1\n        if r == 0:\n            return f(r, c - 1)\n        if c == 0:\n            return f(r - 1, c)\n        return f(r - 1, c) + f(r, c - 1)\n\n    def sum_f(r1: int, c1: int, r2: int, c2: int) -> int:\n        result = 0\n        for i in range(r1, r2 + 1):\n            for j in range(c1, c2 + 1):\n                result += f(i, j)\n        return result % MOD\n\n    return str(sum_f(r1, c1, r2, c2))"
    },
    {
        "number": 1925,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, N = map(int, stdin.split())\n    max_value = 0\n    for x in range(1, N+1):\n        max_value = max(max_value, A * (x // B) - A * (x % B))\n    return str(max_value)"
    },
    {
        "number": 1926,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def k_ary_heap(a, k):\n        heap = [0] * (k + 1)\n        for i in range(1, n + 1):\n            heap[i] = a[i - 1]\n        for i in range(k, 1, -1):\n            parent = i // 2\n            if heap[parent] > heap[i]:\n                heap[parent], heap[i] = heap[i], heap[parent]\n        return heap\n\n    def count_violations(heap):\n        violations = 0\n        for i in range(1, n + 1):\n            if heap[i] < heap[i // 2]:\n                violations += 1\n        return violations\n\n    violations = [count_violations(k_ary_heap(a, k)) for k in range(1, n)]\n    return \" \".join(map(str, violations))"
    },
    {
        "number": 1927,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    p = list(range(1, n+1))\n    for i in range(m):\n        j = a[i]\n        if j!= p[0]:\n            p.insert(0, p.pop(p.index(j)))\n\n    result = []\n    for i in range(n):\n        min_pos = p.index(i+1)\n        max_pos = p.index(i+1)\n        for j in range(i+1, n):\n            if p[j] < min_pos:\n                min_pos = p.index(j)\n            if p[j] > max_pos:\n                max_pos = p.index(j)\n        result.append((min_pos+1, max_pos+1))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1928,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    candies = [0] * k\n    penalty = 0\n\n    for _ in range(k):\n        i, j = map(int, input().split())\n        matrix[i - 1][j - 1] = 1\n        candies[i - 1] += 1\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 0:\n                paths = []\n                for p in range(n):\n                    for q in range(m):\n                        if p == i and q == j:\n                            continue\n                        if abs(p - i) + abs(q - j) == 1:\n                            paths.append((p, q))\n                if paths:\n                    paths.sort(key=lambda x: len(x))\n                    path = paths[0]\n                    matrix[i][j] = 1\n                    candies[path[0] - 1] -= 1\n                    candies[path[1] - 1] -= 1\n                    penalty += len(paths)\n                    print(f\"({i + 1}, {j + 1})\")\n                    print(f\"({path[0] + 1}, {path[1] + 1})\")\n                else:\n                    print(\"LOST\")\n                    return \"0\"\n\n    return str(penalty)\n"
    },
    {
        "number": 1929,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, c = map(int, stdin.split())\n    prisoners = list(map(int, stdin.split()))\n\n    prisoners.sort(reverse=True)\n    prisoners.sort(reverse=True)\n\n    count = 0\n    for i in range(n):\n        if prisoners[i] <= t:\n            count += 1\n            if count == c:\n                break\n\n    return str(count)"
    },
    {
        "number": 1930,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n    p = [x if x!= -1 else n for x in p]\n    p.sort()\n    inversions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                inversions += 1\n    P = inversions\n    Q = 1\n    while Q * Q <= P:\n        if P % Q == 0:\n            P //= Q\n            Q -= 1\n        else:\n            Q += 1\n    return str(P * (998244353 - 1) // Q)"
    },
    {
        "number": 1931,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        if n == 1:\n            print(1)\n        else:\n            pyramid_count = 0\n            for i in range(1, n+1):\n                pyramid_count += i\n            print(pyramid_count)"
    },
    {
        "number": 1932,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    polyhedrons = []\n    for _ in range(n):\n        polyhedrons.append(stdin.split()[1])\n    total_faces = 0\n    for polyhedron in polyhedrons:\n        if polyhedron == \"Tetrahedron\":\n            total_faces += 4\n        elif polyhedron == \"Cube\":\n            total_faces += 6\n        elif polyhedron == \"Octahedron\":\n            total_faces += 8\n        elif polyhedron == \"Dodecahedron\":\n            total_faces += 12\n        elif polyhedron == \"Icosahedron\":\n            total_faces += 20\n    return str(total_faces)"
    },
    {
        "number": 1933,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def replace_ones(i, j):\n        nonlocal a\n        for row in range(n):\n            for col in range(m):\n                if a[row][col] == 1:\n                    a[row][col] = 0\n\n    def count_ones(i, j, count):\n        nonlocal a\n        for row in range(i, min(i + k, n)):\n            for col in range(j, m):\n                if a[row][col] == 1:\n                    count += 1\n        return count\n\n    def find_topmost_one(j):\n        nonlocal a\n        min_i = n\n        for i in range(n):\n            if a[i][j] == 1:\n                min_i = min(min_i, i)\n        return min_i\n\n    def max_score(i, j):\n        nonlocal a\n        score = 0\n        for col in range(j, m):\n            min_i = find_topmost_one(col)\n            if min_i == n:\n                continue\n            count = count_ones(min_i, col, 0)\n            score += count\n        return score\n\n    def min_replacements(i, j):\n        nonlocal a\n        min_ones = n\n        for col in range(j, m):\n            min_i = find_topmost_one(col)\n            if min_i == n:\n                continue\n            count = count_ones(min_i, col, 0)\n            min_ones = min(min_ones, count)\n        return min_ones\n\n    max_score_val = max_score(0, 0)\n    min_replacements_val = min_replacements(0, 0)\n\n    print(max_score_val, min_replacements_val)\n\n    return \"\"\n"
    },
    {
        "number": 1934,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        queries.append((l, r))\n\n    def find_min_distance(a: list, l: int, r: int) -> int:\n        min_distance = float('inf')\n        for i in range(l, r):\n            for j in range(i + 1, r + 1):\n                if a[i] == a[j]:\n                    min_distance = min(min_distance, abs(i - j))\n        return min_distance\n\n    result = []\n    for l, r in queries:\n        min_distance = find_min_distance(a, l, r)\n        result.append(min_distance)\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 1935,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    g, r = map(int, stdin.split())\n\n    def is_safe(x: int) -> bool:\n        return all(x!= d[i] for i in range(m))\n\n    def is_safe_to_change(x: int) -> bool:\n        return is_safe(x + 1) or is_safe(x - 1)\n\n    def is_safe_to_change_direction(x: int) -> bool:\n        return is_safe_to_change(x + 1) or is_safe_to_change(x - 1)\n\n    def is_safe_to_change_position(x: int) -> bool:\n        return is_safe_to_change(x + 1) or is_safe_to_change(x - 1)\n\n    def is_safe_to_change_position_direction(x: int) -> bool:\n        return is_safe_to_change_position(x + 1) or is_safe_to_change_position(x - 1)\n\n    def is_safe_to_change_position_direction_change(x: int) -> bool:\n        return is_safe_to_change_position_direction(x + 1) or is_safe_to_change_position_direction(x - 1)\n\n    def is_safe_to_change_position_direction_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change(x + 1) or is_safe_to_change_position_direction_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change(x + 1) or is_safe_to_change_position_direction_change_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change_change(x + 1) or is_safe_to_change_position_direction_change_change_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change_change_change(x + 1) or is_safe_to_change_position_direction_change_change_change_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change_change_change_change(x + 1) or is_safe_to_change_position_direction_change_change_change_change_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change_change_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change_change_change_change_change(x + 1) or is_safe_to_change_position_direction_change_change_change_change_change_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change_change_change_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change_change_change_change_change_change(x + 1) or is_safe_to_change_position_direction_change_change_change_change_change_change_change(x - 1)\n\n    def is_safe_to_change_position_direction_change_change_change_change_change_change_change_change_change(x: int) -> bool:\n        return is_safe_to_change_position_direction_change_change_change_change_change_change_change_change(x + 1) or is_safe_to_change_position_direction_change_change_change_change_change_change_change_change(x - 1)\n\n    def is_safe_to_change_position"
    },
    {
        "number": 1936,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        l, r = map(int, stdin.split('\\n')[1].split())\n        if l > r:\n            l, r = r, l\n        if l % r!= 0:\n            print(-1, -1)\n        else:\n            x = l // r\n            y = r\n            while x < r:\n                if x % r == 0 and y % r == 0:\n                    print(x, y)\n                    break\n                x += 1\n            else:\n                print(-1, -1)"
    },
    {
        "number": 1937,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b = map(int, stdin.split())\n    b = [b[i] for i in range(n // 2)]\n    a = [i for i in range(n)]\n    a[n // 2:] = b\n    return''.join(map(str, a))"
    },
    {
        "number": 1938,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    intervals = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        intervals.append((l, r))\n\n    def f(l, r):\n        return r - l + 1\n\n    def intersection(intervals, l, r):\n        for i in range(len(intervals)):\n            if l <= intervals[i][0] <= r or l <= intervals[i][1] <= r or r <= intervals[i][0] <= l or r <= intervals[i][1] <= l:\n                return True\n        return False\n\n    def count_points(intervals, l, r):\n        count = 0\n        for i in range(len(intervals)):\n            if l <= intervals[i][0] <= r or l <= intervals[i][1] <= r or r <= intervals[i][0] <= l or r <= intervals[i][1] <= l:\n                count += f(intervals[i][0])\n                count += f(intervals[i][1])\n        return count\n\n    def mod_add(a, b):\n        return (a + b) % 1000000007\n\n    def mod_mul(a, b):\n        return (a * b) % 1000000007\n\n    def mod_pow(a, b, m):\n        res = 1\n        while b > 0:\n            if b & 1:\n                res = mod_mul(res, a)\n                res = mod_mul(res, m)\n            a = mod_mul(a, a)\n            a = mod_mul(a, m)\n            b >>= 1\n        return res\n\n    def mod_inv(a, m):\n        return mod_pow(a, m - 2, m)\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def solve(intervals, k):\n        intervals.sort(key=lambda x: x[0])\n        n = len(intervals)\n        mod = 1000000007\n\n        def solve_helper(l, r, index):\n            if index == k:\n                return count_points(intervals, l, r)\n            if index == 0:\n                return 0\n\n            left = solve_helper(l, r, index + 1)\n            right = solve_helper(l, r, index - 1)\n\n            if intersection(intervals, l, r):\n                return mod_add(left, right)\n            else:\n                return mod_add(left, right)\n\n        return solve_helper(intervals[0][0], intervals[-1][1], k)\n\n    result = solve(intervals, k)\n    return str(result)"
    },
    {
        "number": 1939,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        row = list(map(int, input().split()))\n        if sum(row) == k:\n            table.append(row)\n    if not table:\n        return \"No suitable table found.\"\n    return \"\\n\".join(\" \".join(map(str, row)) for row in table)"
    },
    {
        "number": 1940,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    pebbles = [0] * n\n    days = 0\n    while True:\n        for i in range(n):\n            if pebbles[i] < w[i]:\n                pebbles[i] += 1\n                break\n        else:\n            break\n        days += 1\n    return str(days)"
    },
    {
        "number": 1941,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def karafs_height(A: int, B: int, i: int) -> int:\n        return A + (i - 1) * B\n\n    def m_bite(A: int, B: int, m: int, t: int) -> int:\n        max_height = 0\n        eaten_karafs = set()\n        for i in range(1, m + 1):\n            if i not in eaten_karafs:\n                height = karafs_height(A, B, i)\n                if height > max_height:\n                    max_height = height\n                if height == 0:\n                    eaten_karafs.add(i)\n                if len(eaten_karafs) == t:\n                    return max_height\n        return -1\n\n    A, B, n = map(int, stdin.split())\n    queries = [list(map(int, stdin.split())) for _ in range(n)]\n\n    for l, t, m in queries:\n        result = m_bite(A, B, m, t)\n        print(result) if result!= -1 else print(-1)"
    },
    {
        "number": 1942,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        n, l, r = map(int, stdin.split('\\n')[1].split())\n        cycle = [1] * (n * (n - 1) // 2 + 2)\n        cycle[0] = 1\n        cycle[1] = 2\n        cycle[2] = 1\n        cycle[3] = 3\n        cycle[4] = 2\n        cycle[5] = 3\n        cycle[6] = 1\n        cycle[7] = 2\n        cycle[8] = 3\n        cycle[9] = 1\n        cycle[10] = 2\n        cycle[11] = 3\n        cycle[12] = 1\n        cycle[13] = 2\n        cycle[14] = 3\n        cycle[15] = 1\n        cycle[16] = 2\n        cycle[17] = 3\n        cycle[18] = 1\n        cycle[19] = 2\n        cycle[20] = 3\n        cycle[21] = 1\n        cycle[22] = 2\n        cycle[23] = 3\n        cycle[24] = 1\n        cycle[25] = 2\n        cycle[26] = 3\n        cycle[27] = 1\n        cycle[28] = 2\n        cycle[29] = 3\n        cycle[30] = 1\n        cycle[31] = 2\n        cycle[32] = 3\n        cycle[33] = 1\n        cycle[34] = 2\n        cycle[35] = 3\n        cycle[36] = 1\n        cycle[37] = 2\n        cycle[38] = 3\n        cycle[39] = 1\n        cycle[40] = 2\n        cycle[41] = 3\n        cycle[42] = 1\n        cycle[43] = 2\n        cycle[44] = 3\n        cycle[45] = 1\n        cycle[46] = 2\n        cycle[47] = 3\n        cycle[48] = 1\n        cycle[49] = 2\n        cycle[50] = 3\n        cycle[51] = 1\n        cycle[52] = 2\n        cycle[53] = 3\n        cycle[54] = 1\n        cycle[55] = 2\n        cycle[56] = 3\n        cycle[57] = 1\n        cycle[58] = 2\n        cycle[59] = 3\n        cycle[60] = 1\n        cycle[61] = 2\n        cycle[62] = 3\n        cycle[63] = 1\n        cycle[64] = 2\n        cycle[65] = 3\n        cycle[66] = 1\n        cycle[67] = 2\n        cycle[68] = 3\n        cycle[69] = 1\n        cycle[70] = 2\n        cycle[71] = 3\n        cycle[72] = 1\n        cycle[73] = 2\n        cycle[74] = 3\n        cycle[75] = 1\n        cycle[76] = 2\n        cycle[77] = 3\n        cycle[78] = 1\n        cycle[79] = 2\n        cycle[80] = 3\n        cycle[81] = 1\n        cycle[82] = 2\n        cycle[83] = 3\n        cycle[84] = 1\n        cycle[85] = 2\n        cycle[86] = 3\n        cycle[87] = 1\n        cycle[88] = 2\n        cycle[89] = 3\n        cycle[90] = 1\n        cycle[91] = 2\n        cycle[92] = 3\n        cycle[93] = 1\n        cycle[94] = 2\n        cycle[95] = 3\n        cycle[96] = 1\n        cycle[97] = 2\n        cycle[98] = 3\n        cycle[99] = 1\n        cycle[100] = 2\n        cycle[101] = 3\n        cycle[102] = 1\n        cycle[103] = 2\n        cycle[104] = 3\n        cycle[105] = 1\n        cycle[106] = "
    },
    {
        "number": 1943,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    teams = [list(map(int, stdin.split()[1:])) for _ in range(2**N)]\n    teams = [list(map(lambda x: x / 100, row)) for row in teams]\n\n    def expected_score(bracket):\n        return sum(sum(bracket[i][j] * (2**i - 1) * (2**j - 1) for j in range(N)) for i in range(N))\n\n    def max_expected_score(teams):\n        return max(expected_score(bracket) for bracket in itertools.combinations(teams, 2))\n\n    return str(max_expected_score(teams))"
    },
    {
        "number": 1944,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n    \n    a.sort()\n    b.sort()\n    \n    if a[0] < a[1] and b[0] > b[1]:\n        return \"Happy Alex\"\n    else:\n        return \"Poor Alex\""
    },
    {
        "number": 1945,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    requests = stdin.split('\\n')[1:]\n\n    old_to_new = {}\n    for request in requests:\n        old, new = request.split()\n        if old in old_to_new:\n            return \"NO\"\n        old_to_new[old] = new\n\n    return str(n) + '\\n' + '\\n'.join(f\"{old} {new}\" for old, new in sorted(old_to_new.items()))"
    },
    {
        "number": 1946,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    b = list(map(int, stdin.split()))\n    b.sort()\n\n    def max_income(a, b):\n        max_a = max(a)\n        max_b = max(b)\n        return max_a + max_b\n\n    max_income_a = max_income(a, b)\n    max_income_b = max_income(b, a)\n\n    return str(max(max_income_a, max_income_b))"
    },
    {
        "number": 1947,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    requests = []\n    for i in range(m):\n        t, p, d = map(int, stdin.split())\n        requests.append((t, p, d))\n\n    def process_haircut(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut(hairline + 1, length - d)\n\n    def process_haircut_all(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_all(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_all_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_all_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short(hairline + 1, length - d)\n\n    def process_haircut_short_all(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short_short_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short_short_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short_short_short_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short_short_short_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short_short_short_short_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short_short_short_short_short_short(hairline: int, length: int) -> int:\n        if length <= l:\n            return 0\n        return 1 + process_haircut_short_all_short_short_short_short_short_short_short_short(hairline + 1, length - a[hairline - 1])\n\n    def process_haircut_short_all_short_short_short_short_short_short_"
    },
    {
        "number": 1948,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            vertex, moves = queue.pop(0)\n            if vertex == x:\n                return moves\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbour in graph[vertex]:\n                    queue.append((neighbour, moves + 1))\n        return -1\n\n    alice_moves = bfs(1)\n    bob_moves = bfs(x)\n    return str(min(alice_moves, bob_moves))"
    },
    {
        "number": 1949,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    for _ in range(k):\n        min_non_zero = float('inf')\n        for i in range(n):\n            if a[i]!= 0:\n                min_non_zero = min(min_non_zero, a[i])\n\n        if min_non_zero == float('inf'):\n            print(0)\n        else:\n            print(min_non_zero)\n\n        for i in range(n):\n            if a[i]!= 0:\n                a[i] -= min_non_zero\n\n    return ''"
    },
    {
        "number": 1950,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    a = [sorted(set(balls)) for balls in a]\n    a = [sorted(balls) for balls in a]\n    a = [balls for balls in a if balls]\n    a = [balls for balls in a if len(balls) == n]\n    a = [balls for balls in a if len(balls) > 1]\n    a = [balls for balls in a if len(balls) % n == 0]\n    a = [balls for balls in a if len(balls) // n == 1]\n    a = [balls for balls in a if len(balls) // n == 2]\n    a = [balls for balls in a if len(balls) // n == 3]\n    a = [balls for balls in a if len(balls) // n == 4]\n    a = [balls for balls in a if len(balls) // n == 5]\n    a = [balls for balls in a if len(balls) // n == 6]\n    a = [balls for balls in a if len(balls) // n == 7]\n    a = [balls for balls in a if len(balls) // n == 8]\n    a = [balls for balls in a if len(balls) // n == 9]\n    a = [balls for balls in a if len(balls) // n == 10]\n    a = [balls for balls in a if len(balls) // n == 11]\n    a = [balls for balls in a if len(balls) // n == 12]\n    a = [balls for balls in a if len(balls) // n == 13]\n    a = [balls for balls in a if len(balls) // n == 14]\n    a = [balls for balls in a if len(balls) // n == 15]\n    a = [balls for balls in a if len(balls) // n == 16]\n    a = [balls for balls in a if len(balls) // n == 17]\n    a = [balls for balls in a if len(balls) // n == 18]\n    a = [balls for balls in a if len(balls) // n == 19]\n    a = [balls for balls in a if len(balls) // n == 20]\n    a = [balls for balls in a if len(balls) // n == 21]\n    a = [balls for balls in a if len(balls) // n == 22]\n    a = [balls for balls in a if len(balls) // n == 23]\n    a = [balls for balls in a if len(balls) // n == 24]\n    a = [balls for balls in a if len(balls) // n == 25]\n    a = [balls for balls in a if len(balls) // n == 26]\n    a = [balls for balls in a if len(balls) // n == 27]\n    a = [balls for balls in a if len(balls) // n == 28]\n    a = [balls for balls in a if len(balls) // n == 29]\n    a = [balls for balls in a if len(balls) // n == 30]\n    a = [balls for balls in a if len(balls) // n == 31]\n    a = [balls for balls in a if len(balls) // n == 32]\n    a = [balls for balls in a if len(balls) // n == 33]\n    a = [balls for balls in a if len(balls) // n == 34]\n    a = [balls for balls in a if len(balls) // n == 35]\n    a = [balls for balls in a if len(balls) // n == 36]\n    a = [balls for balls in a if len(balls) // n"
    },
    {
        "number": 1951,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    events = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    prices = [price for price, _ in events]\n    prices.sort()\n    if prices == list(range(1, n+1)):\n        return \"YES\\n\" + \" \".join(map(str, prices))\n    else:\n        return \"NO\\n\""
    },
    {
        "number": 1952,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    m = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    def dfs(i, testcase, used, res):\n        if len(used) == c[i]:\n            res.append(testcase)\n            return\n        for j in range(m[i]):\n            if j not in used:\n                dfs(i, testcase + [j], used + [j], res)\n\n    res = []\n    dfs(0, [], [], res)\n    return str(len(res)) + '\\n' + '\\n'.join([' '.join(map(str, testcase)) for testcase in res])"
    },
    {
        "number": 1953,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n    \n    t.sort()\n    \n    count = 0\n    for i in range(n):\n        if t[i] <= t[i+1]:\n            count += 1\n        else:\n            break\n    \n    return str(count)"
    },
    {
        "number": 1954,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def count_ways(n, f, a):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 8\n\n        def is_valid(x):\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    return False\n            return True\n\n        def count_ways_helper(x, memo):\n            if x == 1:\n                return 1\n            if x == 2:\n                return 2\n            if x == 3:\n                return 4\n            if x == 4:\n                return 8\n\n            if x in memo:\n                return memo[x]\n\n            ways = 0\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    ways += count_ways_helper(x // a[i], memo)\n            memo[x] = ways\n            return ways\n\n        return count_ways_helper(f, {})\n\n    def count_ways_mod(n, f, a):\n        return count_ways(n, f, a) % (10**9 + 7)\n\n    def count_ways_mod_helper(n, f, a):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 8\n\n        def is_valid(x):\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    return False\n            return True\n\n        def count_ways_helper(x, memo):\n            if x == 1:\n                return 1\n            if x == 2:\n                return 2\n            if x == 3:\n                return 4\n            if x == 4:\n                return 8\n\n            if x in memo:\n                return memo[x]\n\n            ways = 0\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    ways += count_ways_helper(x // a[i], memo)\n            memo[x] = ways\n            return ways\n\n        return count_ways_helper(f, {})\n\n    def count_ways_mod_helper_2(n, f, a):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 8\n\n        def is_valid(x):\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    return False\n            return True\n\n        def count_ways_helper(x, memo):\n            if x == 1:\n                return 1\n            if x == 2:\n                return 2\n            if x == 3:\n                return 4\n            if x == 4:\n                return 8\n\n            if x in memo:\n                return memo[x]\n\n            ways = 0\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    ways += count_ways_helper(x // a[i], memo)\n            memo[x] = ways\n            return ways\n\n        return count_ways_helper(f, {})\n\n    def count_ways_mod_helper_3(n, f, a):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 4\n        if n == 4:\n            return 8\n\n        def is_valid(x):\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    return False\n            return True\n\n        def count_ways_helper(x, memo):\n            if x == 1:\n                return 1\n            if x == 2:\n                return 2\n            if x == 3:\n                return 4\n            if x == 4:\n                return 8\n\n            if x in memo:\n                return memo[x]\n\n            ways = 0\n            for i in range(1, n):\n                if x % a[i] == 0:\n                    ways += count_ways_helper(x // a[i], memo)\n            memo[x] = ways\n            return ways\n\n        return count_ways_helper(f, {})\n\n    def count_ways_mod_helper_4(n, f, a):\n        if n == 1:\n           "
    },
    {
        "number": 1955,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = list(map(int, stdin.split()))\n    exams = [0] * m\n    for i in range(n):\n        for j in range(m):\n            if days[i] == j + 1:\n                exams[j] += 1\n                if exams[j] > 1:\n                    return -1\n    return min(days)"
    },
    {
        "number": 1956,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rounds = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    t = len(rounds)\n    s = [round[0] for round in rounds]\n    e = [round[1] for round in rounds]\n\n    def check_win(s, e):\n        for i in range(t):\n            if s[i] > e[i]:\n                return 0\n        return 1\n\n    def check_loss(s, e):\n        for i in range(t):\n            if s[i] <= e[i]:\n                return 0\n        return 1\n\n    def check_tie(s, e):\n        for i in range(t):\n            if s[i] == e[i]:\n                return 0\n        return 1\n\n    def check_winner(s, e):\n        if check_win(s, e):\n            return 1\n        elif check_loss(s, e):\n            return 0\n        else:\n            return 2\n\n    def check_loser(s, e):\n        if check_win(s, e):\n            return 0\n        elif check_loss(s, e):\n            return 1\n        else:\n            return 2\n\n    winner = check_winner(s, e)\n    loser = check_loser(s, e)\n\n    if winner == 1:\n        print(1, 1)\n    elif winner == 0:\n        print(0, 1)\n    else:\n        print(1, 0)\n\n    return ''"
    },
    {
        "number": 1957,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n\n    blocked_holes = 0\n    total_water = 0\n\n    for i in range(n):\n        if total_water + s[i] <= A:\n            blocked_holes += 1\n            total_water += s[i]\n        else:\n            break\n\n    return str(blocked_holes)"
    },
    {
        "number": 1958,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    apples = [int(x) for x in stdin.split()]\n    apples.sort()\n    total_money = 0\n    for i in range(n):\n        if apples[i] % 2 == 0:\n            total_money += apples[i]\n        else:\n            total_money += apples[i] + p\n    return str(total_money)"
    },
    {
        "number": 1959,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    even_count = sum(1 for x in a if x % 2 == 0)\n    odd_count = sum(1 for x in a if x % 2!= 0)\n    if even_count!= odd_count:\n        return -1\n\n    exchanges = 0\n    result = []\n    for i in range(n):\n        if a[i] % 2 == 0:\n            result.append(a[i])\n        else:\n            if exchanges == 0:\n                result.append(a[i])\n                exchanges += 1\n            else:\n                result.append(a[i] - 2)\n                exchanges += 1\n\n    return str(exchanges) + \" \" + \" \".join(map(str, result))"
    },
    {
        "number": 1960,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    # Group 1: All i such that a[i] belongs to no longest increasing subsequences\n    group1 = [i for i in range(n) if a[i] not in [a[j] for j in range(i)]]\n\n    # Group 2: All i such that a[i] belongs to at least one but not every longest increasing subsequences\n    group2 = [i for i in range(n) if a[i] in [a[j] for j in range(i)]]\n\n    # Group 3: All i such that a[i] belongs to every longest increasing subsequences\n    group3 = [i for i in range(n) if a[i] in [a[j] for j in range(i)]]\n\n    # Concatenate groups\n    groups = [group1, group2, group3]\n    result = ''.join(str(len(group)) for group in groups)\n\n    return result\n"
    },
    {
        "number": 1961,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def is_valid_square(x1, y1, x2, y2):\n        return is_valid(x1, y1) and is_valid(x2, y2)\n\n    def is_valid_square_with_center(x, y):\n        return is_valid_square(x - 1, y - 1, x + 1, y + 1)\n\n    def is_valid_square_with_center_and_ink(x, y):\n        return is_valid_square_with_center(x, y) and grid[x][y] == '#'\n\n    def is_valid_square_with_center_and_ink_and_border(x, y):\n        return is_valid_square_with_center_and_ink(x, y) and is_valid_square_with_center_and_ink(x - 1, y) and is_valid_square_with_center_and_ink(x + 1, y) and is_valid_square_with_center_and_ink(x, y - 1) and is_valid_square_with_center_and_ink(x, y + 1)\n\n    def is_valid_square_with_center_and_ink_and_border_and_signature(x, y):\n        return is_valid_square_with_center_and_ink_and_border(x, y) and is_valid_square_with_center_and_ink_and_border(x - 1, y - 1) and is_valid_square_with_center_and_ink_and_border(x + 1, y + 1)\n\n    def is_valid_square_with_center_and_ink_and_border_and_signature_and_border(x, y):\n        return is_valid_square_with_center_and_ink_and_border_and_signature(x, y) and is_valid_square_with_center_and_ink_and_border_and_signature(x - 1, y - 1) and is_valid_square_with_center_and_ink_and_border_and_signature(x + 1, y + 1)\n\n    def is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature(x, y):\n        return is_valid_square_with_center_and_ink_and_border_and_signature_and_border(x, y) and is_valid_square_with_center_and_ink_and_border_and_signature_and_border(x - 1, y - 1) and is_valid_square_with_center_and_ink_and_border_and_signature_and_border(x + 1, y + 1)\n\n    def is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature_and_border(x, y):\n        return is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature(x, y) and is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature(x - 1, y - 1) and is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature(x + 1, y + 1)\n\n    def is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature_and_border_and_signature(x, y):\n        return is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature_and_border(x, y) and is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature_and_border(x - 1, y - 1) and is_valid_square_with_center_and_ink_and_border_and_signature_and_border_and_signature_and_border(x"
    },
    {
        "number": 1962,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    m = n * k\n    total_sum = 0\n    for i in range(m):\n        total_sum += a[i]\n        if total_sum > l:\n            total_sum -= a[i]\n            break\n    if total_sum == 0:\n        return \"0\"\n    return str(total_sum)"
    },
    {
        "number": 1963,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def max_r_l(a: list, l: int, r: int) -> int:\n        max_val = 0\n        for j in range(l, r + 1):\n            if all(a[i] % a[j] == 0 for i in range(l, r + 1)):\n                max_val = max(max_val, r - l)\n        return max_val\n\n    def find_optimal_pairs(a: list) -> list:\n        pairs = []\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if is_prime(a[i] + a[j]):\n                    l = i + 1\n                    r = j\n                    pairs.append((l, r))\n        return pairs\n\n    pairs = find_optimal_pairs(a)\n    max_val = max(max_r_l(a, l, r) for l, r in pairs)\n\n    print(len(pairs))\n    print(max_val)\n    for l, r in sorted(pairs):\n        print(l, r)\n\n    return \"\"\n"
    },
    {
        "number": 1964,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *k = map(int, stdin.split())\n    m = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def min_time(cashier: int, queue: int) -> int:\n        time = 0\n        for i in range(queue):\n            time += 5 + m[cashier][i] * 15\n        return time\n\n    min_time_cashier = min(range(n), key=lambda i: min_time(i, k[i]))\n    return str(min_time(min_time_cashier, k[min_time_cashier]))"
    },
    {
        "number": 1965,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, x = map(int, stdin.split()[1:])\n        a = list(map(int, stdin.split()[2:]))\n        infected = [False] * n\n        infected[0] = True\n        count = 0\n        while True:\n            changes = 0\n            for i in range(n):\n                if infected[i]:\n                    continue\n                if a[i] == x:\n                    infected[i] = True\n                    changes += 1\n            if changes == 0:\n                break\n            count += 1\n        print(count)"
    },
    {
        "number": 1966,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pieces = []\n    for i in range(4):\n        piece = []\n        for j in range(n):\n            piece.append(int(stdin.split()[i*n+j]))\n        pieces.append(piece)\n\n    def is_valid(piece):\n        for i in range(n):\n            for j in range(n):\n                if piece[i][j] == 1:\n                    if j > 0 and piece[i][j-1] == 0:\n                        return False\n                    if j < n-1 and piece[i][j+1] == 0:\n                        return False\n                elif piece[i][j] == 0:\n                    if j > 0 and piece[i][j-1] == 1:\n                        return False\n                    if j < n-1 and piece[i][j+1] == 1:\n                        return False\n        return True\n\n    def recolor(piece):\n        min_squares = n*n\n        for i in range(n):\n            for j in range(n):\n                if piece[i][j] == 1:\n                    if j > 0 and piece[i][j-1] == 0:\n                        piece[i][j-1] = 1\n                        min_squares -= 1\n                    if j < n-1 and piece[i][j+1] == 0:\n                        piece[i][j+1] = 1\n                        min_squares -= 1\n                elif piece[i][j] == 0:\n                    if j > 0 and piece[i][j-1] == 1:\n                        piece[i][j-1] = 0\n                        min_squares -= 1\n                    if j < n-1 and piece[i][j+1] == 1:\n                        piece[i][j+1] = 0\n                        min_squares -= 1\n        return min_squares\n\n    min_squares = n*n\n    for piece in pieces:\n        if is_valid(piece):\n            min_squares = min(min_squares, recolor(piece))\n\n    return str(min_squares)"
    },
    {
        "number": 1967,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[0].split())\n    image = [list(line.strip()) for line in stdin.split()[1:]]\n    result = []\n\n    for _ in range(2):\n        image = rotate_image(image)\n        image = flip_image(image)\n        image = zoom_image(image)\n\n    for line in image:\n        result.append(\"\".join(line))\n\n    return \"\\n\".join(result)\n\n\ndef"
    },
    {
        "number": 1968,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    sellers = []\n    for _ in range(n):\n        k, *prices = map(int, stdin.split())\n        sellers.append((k, prices))\n\n    sellers.sort(key=lambda x: (-x[0], -sum(x[1])))\n\n    p = 0\n    for i, (k, prices) in enumerate(sellers):\n        if sum(prices) <= v:\n            p += 1\n            if p == 1:\n                break\n\n    if p == 0:\n        return \"0\"\n\n    q = [i for i, (k, prices) in enumerate(sellers) if sum(prices) <= v][:p]\n    return f\"{p}\\n{' '.join(map(str, q))}\"\n"
    },
    {
        "number": 1969,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matrix = []\n    for _ in range(n):\n        line = stdin.split()[1:]\n        matrix.append([char for char in line if char!= '.'])\n\n    crosses = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'X' and (i == 0 or j == 0 or i == n - 1 or j == n - 1):\n                crosses += 1\n\n    return str(crosses)"
    },
    {
        "number": 1970,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        board = [list(row) for row in stdin.split('\\n')[1:]]\n        semiknights = [(4, 1), (8, 1)]\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'K':\n                    for k in range(4):\n                        for l in range(2):\n                            for m in range(2):\n                                for n in range(2):\n                                    if (i + k, j + l) not in semiknights and (i + k, j + m) not in semiknights and (i + k, j + n) not in semiknights and (i + l, j + k) not in semiknights and (i + l, j + m) not in semiknights and (i + l, j + n) not in semiknights and (i + m, j + k) not in semiknights and (i + m, j + l) not in semiknights and (i + m, j + n) not in semiknights and (i + n, j + k) not in semiknights and (i + n, j + l) not in semiknights and (i + n, j + m) not in semiknights:\n                                        board[i + k][j + l] = '#'\n                                        board[i + k][j + m] = '#'\n                                        board[i + k][j + n] = '#'\n                                        board[i + l][j + k] = '#'\n                                        board[i + l][j + m] = '#'\n                                        board[i + l][j + n] = '#'\n                                        board[i + m][j + k] = '#'\n                                        board[i + m][j + l] = '#'\n                                        board[i + m][j + n] = '#'\n                                        board[i + n][j + k] = '#'\n                                        board[i + n][j + l] = '#'\n                                        board[i + n][j + m] = '#'\n                                        semiknights.append((i + k, j + l))\n                                        semiknights.append((i + k, j + m))\n                                        semiknights.append((i + k, j + n))\n                                        semiknights.append((i + l, j + k))\n                                        semiknights.append((i + l, j + m))\n                                        semiknights.append((i + l, j + n))\n                                        semiknights.append((i + m, j + k))\n                                        semiknights.append((i + m, j + l))\n                                        semiknights.append((i + m, j + n))\n                                        semiknights.append((i + n, j + k))\n                                        semiknights.append((i + n, j + l))\n                                        semiknights.append((i + n, j + m))\n        if len(semiknights) == 2:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 1971,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    def find_square(p):\n        square = [p[i] for i in range(n)]\n        for i in range(n):\n            square[i] = p[square[i] - 1]\n        return square\n\n    def find_permutation(square):\n        permutation = [square[i] + 1 for i in range(n)]\n        for i in range(n):\n            permutation[i] = square[permutation[i] - 1]\n        return permutation\n\n    square = find_square(p)\n    permutation = find_permutation(square)\n\n    if permutation == p:\n        return \" \".join(map(str, permutation))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 1972,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = [0] * 500001\n    for i in range(1, n + 1):\n        a[i] = i\n\n    for _ in range(q):\n        t, x, y = map(int, stdin.split())\n        if t == 1:\n            a[x] += y\n        elif t == 2:\n            result = sum(a[i] for i in range(x, y + 1, x))\n            print(result)\n\n    return \"\""
    },
    {
        "number": 1973,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    u = list(map(int, stdin.split()[1:]))\n    \n    x = 1\n    while x <= n:\n        if sum(u[:x]) == x:\n            return str(x)\n        x += 1\n    \n    return str(x)"
    },
    {
        "number": 1974,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    robbers = [tuple(map(int, stdin.split())) for _ in range(n)]\n    searchlights = [tuple(map(int, stdin.split())) for _ in range(m)]\n\n    def is_safe(robbers: List[Tuple[int, int]], searchlights: List[Tuple[int, int]]) -> bool:\n        for robber in robbers:\n            for searchlight in searchlights:\n                if robber[0] <= searchlight[0] and robber[1] <= searchlight[1]:\n                    return False\n        return True\n\n    moves = 0\n    while not is_safe(robbers, searchlights):\n        moves += 1\n        for robber in robbers:\n            if robber[0] < 10**6:\n                robber = (robber[0] + 1, robber[1])\n            else:\n                robber = (0, robber[1] + 1)\n        for searchlight in searchlights:\n            if searchlight[0] < 10**6:\n                searchlight = (searchlight[0] + 1, searchlight[1])\n            else:\n                searchlight = (0, searchlight[1] + 1)\n\n    return str(moves)"
    },
    {
        "number": 1975,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    songs = []\n    for _ in range(n):\n        songs.append(list(map(int, stdin.split())))\n    songs.sort(key=lambda x: (x[0], x[1]))\n    k = 1\n    for i in range(1, len(songs)):\n        if songs[i][0]!= songs[i - 1][0] or songs[i][1]!= songs[i - 1][1]:\n            k += 1\n    print(k)\n    for song in songs:\n        print(song[0], song[1])\n    return \"\""
    },
    {
        "number": 1976,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.split())\n    broken_pixels = set()\n    for i in range(q):\n        x, y, t = map(int, stdin.split())\n        broken_pixels.add((x, y))\n\n    for x, y in broken_pixels:\n        for dx in range(k):\n            for dy in range(k):\n                if (x + dx, y + dy) in broken_pixels:\n                    return \"-1\"\n\n    return min(t for x, y, t in broken_pixels if (x, y) not in broken_pixels)"
    },
    {
        "number": 1977,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = [list(row) for row in stdin.split('\\n')[1:]]\n    min_path = []\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                min_path.append((i, j, matrix[i][j]))\n            elif i == 0:\n                min_path.append((i, j, matrix[i][j]))\n            elif j == 0:\n                min_path.append((i, j, matrix[i][j]))\n            else:\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append((i, j, matrix[i][j]))\n                min_path.append"
    },
    {
        "number": 1978,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    path = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_good_subsequence(seq: list) -> bool:\n        for i in range(len(seq) - 1):\n            if seq[i] == seq[i + 1]:\n                return False\n        return True\n\n    def shortest_good_subsequence(seq: list) -> int:\n        shortest = float('inf')\n        for i in range(len(seq)):\n            for j in range(i + 1, len(seq)):\n                subseq = seq[i:j + 1]\n                if is_good_subsequence(subseq):\n                    shortest = min(shortest, len(subseq))\n        return shortest\n\n    def shortest_good_subsequences(graph: list, path: list) -> list:\n        shortest_good_subsequences = []\n        for i in range(len(path) - 1):\n            for j in range(i + 1, len(path)):\n                subseq = path[i:j + 1]\n                if is_good_subsequence(subseq):\n                    shortest_good_subsequences.append(len(subseq))\n        return shortest_good_subsequences\n\n    def find_shortest_good_subsequence(graph: list, path: list) -> tuple:\n        shortest_good_subsequences = shortest_good_subsequences(graph, path)\n        shortest_good_subsequence = min(shortest_good_subsequences)\n        return shortest_good_subsequence, shortest_good_subsequences\n\n    shortest_good_subsequence, shortest_good_subsequences = find_shortest_good_subsequence(graph, path)\n    print(shortest_good_subsequence)\n    print(' '.join(map(str, shortest_good_subsequences)))"
    },
    {
        "number": 1979,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def rotate(arr, k):\n        n = len(arr)\n        k %= n\n        arr.rotate(-k)\n\n    def max_matching_pairs(a, b):\n        max_pairs = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if a[i] == b[j]:\n                    max_pairs += 1\n        return max_pairs\n\n    max_pairs = max_matching_pairs(a, b)\n    for _ in range(int(stdin.split()[3])):\n        rotate(a, 1)\n        rotate(b, 1)\n        max_pairs = max(max_pairs, max_matching_pairs(a, b))\n\n    return str(max_pairs)"
    },
    {
        "number": 1980,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    d, c = [], []\n    for _ in range(n):\n        d.append(int(stdin.split()[1]))\n        c.append(int(stdin.split()[2]))\n\n    d.sort()\n    c.sort()\n\n    max_profit = 0\n    for i in range(n):\n        max_profit = max(max_profit, c[i] + a * (d[i + 1] - d[i]) ** 2)\n\n    return str(max_profit)"
    },
    {
        "number": 1981,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop(0)\n    a.pop"
    },
    {
        "number": 1982,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split()[1:])\n        if n % 2 == 0 or n % 4 == 0:\n            print(\"NO\")\n        else:\n            odd_numbers = [i for i in range(3, n, 2) if i not in [2, 4, 6, 8]]\n            if len(odd_numbers) < k:\n                print(\"NO\")\n            else:\n                print(\"YES\")"
    },
    {
        "number": 1983,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        longest_increasing_subsequence = 1\n        for i in range(1, n):\n            if a[i] > a[i - 1]:\n                longest_increasing_subsequence += 1\n            else:\n                longest_increasing_subsequence = 1\n        print(longest_increasing_subsequence)"
    },
    {
        "number": 1984,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.split())\n    levels = []\n    for _ in range(k):\n        level = list(stdin.readline().strip())\n        levels.append(level)\n\n    def get_diff(level1, level2):\n        diff = 0\n        for i in range(n):\n            for j in range(m):\n                if level1[i][j]!= level2[i][j]:\n                    diff += 1\n        return diff\n\n    def get_min_diff(levels):\n        min_diff = float('inf')\n        for i in range(len(levels)):\n            for j in range(i + 1, len(levels)):\n                diff = get_diff(levels[i], levels[j])\n                if diff < min_diff:\n                    min_diff = diff\n                    min_diff_indices = (i, j)\n        return min_diff, min_diff_indices\n\n    min_diff, min_diff_indices = get_min_diff(levels)\n    min_diff_indices = [min_diff_indices[0] + 1, min_diff_indices[1] + 1]\n\n    def get_transfer_way(level, index):\n        if index == 0:\n            return 0\n        else:\n            return index - 1\n\n    def get_transfer_indices(level, index):\n        if index == 0:\n            return (index, 0)\n        else:\n            return (index - 1, index - 1)\n\n    def get_transfer_indices_diff(level, index):\n        if index == 0:\n            return (index, 0)\n        else:\n            return (index - 1, index)\n\n    def get_transfer_indices_diff_reverse(level, index):\n        if index == 0:\n            return (index, 0)\n        else:\n            return (index, index - 1)\n\n    transfer_ways = []\n    for i in range(k):\n        transfer_ways.append(get_transfer_way(levels[i], min_diff_indices[i]))\n\n    transfer_indices = []\n    for i in range(k):\n        transfer_indices.append(get_transfer_indices(levels[i], min_diff_indices[i]))\n\n    transfer_indices_diff = []\n    for i in range(k):\n        transfer_indices_diff.append(get_transfer_indices_diff(levels[i], min_diff_indices[i]))\n\n    transfer_indices_diff_reverse = []\n    for i in range(k):\n        transfer_indices_diff_reverse.append(get_transfer_indices_diff_reverse(levels[i], min_diff_indices[i]))\n\n    result = str(min_diff) + '\\n'\n    for i in range(k):\n        result += str(transfer_ways[i]) +'' + str(transfer_indices[i][0]) +'' + str(transfer_indices[i][1]) + '\\n'\n    for i in range(k):\n        result += str(transfer_ways[i]) +'' + str(transfer_indices_diff[i][0]) +'' + str(transfer_indices_diff[i][1]) + '\\n'\n    for i in range(k):\n        result += str(transfer_ways[i]) +'' + str(transfer_indices_diff_reverse[i][0]) +'' + str(transfer_indices_diff_reverse[i][1]) + '\\n'\n\n    return result\n"
    },
    {
        "number": 1985,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    count = 0\n    for i in range(k):\n        if a[i] + b[i] > 0:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1986,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    restaurants = []\n    for _ in range(n):\n        f, t = map(int, stdin.split())\n        restaurants.append((f, t))\n    max_joy = -1\n    for f, t in restaurants:\n        if t <= k:\n            joy = f\n        else:\n            joy = f - (t - k)\n        max_joy = max(max_joy, joy)\n    return str(max_joy)"
    },
    {
        "number": 1987,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_1, c_2 = map(int, stdin.split())\n    pupils = [int(x) for x in stdin.split()[1]]\n    pupils.sort()\n    adults = [x for x in pupils if x == 0]\n    adults.sort()\n    if len(adults) < 2:\n        return \"No solution\"\n    total_price = 0\n    for i in range(len(adults)):\n        for j in range(i + 1, len(adults)):\n            total_price += c_1 + c_2 * (j - i - 1) ** 2\n    return str(total_price)"
    },
    {
        "number": 1988,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        s = stdin.split('\\n')[2]\n        s = list(s)\n        k = 1\n        while k <= n:\n            s = ''.join(s[i:i+k-1][::-1] for i in range(len(s)-k+1))\n            if k == 1:\n                break\n            k += 1\n        print(s)\n        print(k)"
    },
    {
        "number": 1989,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def f(l, r, x):\n        count = 0\n        for i in range(l, r + 1):\n            if a[i] == x:\n                count += 1\n        return count\n\n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if f(1, i, a[i]) > f(j, n, a[j]):\n                pairs += 1\n\n    return str(pairs)"
    },
    {
        "number": 1990,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    stack = []\n    colors = [0] * 26\n    colors[0] = 1\n    colors[1] = 1\n\n    for command in s:\n        if command == 'L':\n            if stack:\n                stack.pop()\n        elif command == 'R':\n            pass\n        elif command.islower():\n            index = ord(command) - ord('a')\n            if index == 0:\n                stack.append(0)\n            elif index == 1:\n                stack.append(1)\n            else:\n                stack.append(colors[index])\n                colors[index] += 1\n        else:\n            pass\n\n    if not stack:\n        return''.join(map(str, colors))\n    else:\n        return -1"
    },
    {
        "number": 1991,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        exchanges = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] > a[j]:\n                    exchanges += 1\n                    a[i], a[j] = a[j], a[i]\n        print(exchanges)"
    },
    {
        "number": 1992,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def get_screen(i: int) -> int:\n        return (i - 1) // k + 1\n\n    def get_icon_position(i: int) -> int:\n        return (i - 1) % k + 1\n\n    def get_adjacent_screen(i: int) -> int:\n        return (i - 1) // k\n\n    def get_adjacent_icon_position(i: int) -> int:\n        return (i - 1) % k + 1\n\n    def get_preceding_icon_position(i: int) -> int:\n        return (i - 1) % k + 1\n\n    def get_preceding_screen(i: int) -> int:\n        return (i - 1) // k\n\n    def get_preceding_icon(i: int) -> int:\n        return a[get_preceding_icon_position(i) - 1]\n\n    def get_adjacent_preceding_icon(i: int) -> int:\n        return a[get_adjacent_icon_position(get_preceding_icon(i)) - 1]\n\n    def get_adjacent_preceding_icon_position(i: int) -> int:\n        return get_adjacent_icon_position(get_preceding_icon(i))\n\n    def get_adjacent_preceding_screen(i: int) -> int:\n        return get_adjacent_screen(get_preceding_icon(i))\n\n    def get_adjacent_preceding_icon_position_on_adjacent_screen(i: int) -> int:\n        return get_adjacent_icon_position(get_adjacent_preceding_icon(i))\n\n    def get_adjacent_preceding_icon_on_adjacent_screen(i: int) -> int:\n        return a[get_adjacent_preceding_icon_position_on_adjacent_screen(i) - 1]\n\n    def get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return get_adjacent_icon_position(get_adjacent_preceding_icon_on_adjacent_screen(i))\n\n    def get_adjacent_preceding_icon_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return a[get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen(i) - 1]\n\n    def get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return get_adjacent_icon_position(get_adjacent_preceding_icon_on_adjacent_screen_on_adjacent_screen(i))\n\n    def get_adjacent_preceding_icon_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return a[get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i) - 1]\n\n    def get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return get_adjacent_icon_position(get_adjacent_preceding_icon_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i))\n\n    def get_adjacent_preceding_icon_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return a[get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i) - 1]\n\n    def get_adjacent_preceding_icon_position_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i: int) -> int:\n        return get_adjacent_icon_position(get_adjacent_preceding_icon_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen_on_adjacent_screen(i))\n\n    def get_adjacent_"
    },
    {
        "number": 1993,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(row) for row in stdin.splitlines()]\n\n    def dfs(x, y, visited):\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n\n        if field[x][y] == \".\":\n            return 1\n\n        count = 0\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and field[nx][ny] == \".\":\n                count += dfs(nx, ny, visited)\n\n        return count\n\n    result = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if field[i][j] == \".\":\n                row.append(\".\")\n            else:\n                row.append(str(dfs(i, j, set())))\n        result.append(\"\".join(row))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1994,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    prefixes = set()\n    suffixes = set()\n\n    for i in range(1, n + 1):\n        prefixes.add(s[:i])\n        suffixes.add(s[n - i + 1:])\n\n    count = 0\n    for prefix in prefixes:\n        for suffix in suffixes:\n            if prefix in suffix:\n                count += 1\n\n    print(count)\n\n    for prefix in prefixes:\n        for suffix in suffixes:\n            if prefix in suffix:\n                print(len(prefix), suffix)\n\n    return \"\"\n"
    },
    {
        "number": 1995,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    m = int(stdin.split()[1])\n    queries = []\n    for i in range(m):\n        l, r, k = map(int, stdin.split()[i+2:])\n        queries.append((l, r, k))\n    for l, r, k in queries:\n        s = s[l-1:r] + s[:l-1]\n        s = s[k:] + s[:k]\n    return s"
    },
    {
        "number": 1996,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    actions = stdin.split()[1:]\n    shocks = 0\n    for action in actions:\n        if action.startswith(\".\"):\n            word = action.split()[1]\n            if word.count(selected_letter) == 0:\n                shocks += 1\n        elif action.startswith(\"!\"):\n            word = action.split()[1]\n            if word.count(selected_letter) > 0:\n                shocks += 1\n        elif action.startswith(\"?\"):\n            guess = action.split()[1]\n            if guess.islower() and guess == selected_letter:\n                shocks += 1\n    return str(shocks)\n\nselected_letter = \"c\"\nstdin = \"\"\"\n5\n! abc\n. ad\n. b\n! cd\n? c\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n8\n! hello\n! codeforces\n? c\n. o\n? d\n? h\n. l\n? e\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n7\n! ababahalamaha\n? a\n? b\n? a\n? b\n? a\n? h\n\"\"\"\nprint(solution(stdin))"
    },
    {
        "number": 1997,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    leaves = [i for i in range(1, n+1) if i not in [u for u, v in edges]]\n    leaves.sort()\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves[i] for i in range(len(leaves)-1, -1, -1)]\n    leaves = [leaves["
    },
    {
        "number": 1998,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split())\n    ships = []\n    for i in range(a, n, b):\n        ships.append(i)\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) if i % 2 == 0]\n    ships.sort()\n    ships = [ships[i] for i in range(len(ships)) "
    },
    {
        "number": 1999,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        if arr.count(arr[i]) >= 2:\n            x = arr[i]\n            arr.remove(x)\n            arr.remove(x)\n            arr.insert(0, 2 * x)\n            break\n\n    return str(n) +'' +''.join(map(str, arr))"
    },
    {
        "number": 2000,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == 2 ** i:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2001,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    deliciousness = list(map(int, stdin.split()))\n    deliciousness.append(0)\n    deliciousness = [0] + deliciousness\n    deliciousness = [x % 2 for x in deliciousness]\n\n    def max_enjoyment(start: int, end: int) -> int:\n        max_enjoyment = 0\n        for i in range(start, end + 1):\n            max_enjoyment = max(max_enjoyment, deliciousness[i])\n        return max_enjoyment\n\n    result = []\n    for i in range(q):\n        l, r = map(int, stdin.split())\n        result.append(max_enjoyment(l - 1, r - 1))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2002,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *x = map(int, stdin.split())\n    x = [0] + x\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x.sort()\n    x = [0] + x\n    x.append(0)\n    x"
    },
    {
        "number": 2003,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    A = set()\n    for _ in range(queries):\n        query = stdin.split()[1]\n        if query == \"+\":\n            A.add(int(stdin.split()[2]))\n        elif query == \"-\":\n            A.discard(int(stdin.split()[2]))\n        elif query == \"?\":\n            x = int(stdin.split()[2])\n            max_xor = 0\n            for y in A:\n                max_xor = max(max_xor, x ^ y)\n            print(max_xor)\n    return \"\""
    },
    {
        "number": 2004,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tanks = set()\n    bombs = set()\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i % 2 == 0 and j % 2 == 0:\n                tanks.add((i, j))\n            elif i % 2 == 1 and j % 2 == 1:\n                tanks.add((i, j))\n    bombs.add((1, 1))\n    bombs.add((1, n))\n    bombs.add((n, 1))\n    bombs.add((n, n))\n    bombs = list(bombs)\n    bombs.sort()\n    m = len(bombs)\n    for i in range(m):\n        for j in range(i + 1, m):\n            if bombs[i][0] > bombs[j][0]:\n                bombs[i], bombs[j] = bombs[j], bombs[i]\n                break\n    for i in range(m):\n        for j in range(i + 1, m):\n            if bombs[i][1] > bombs[j][1]:\n                bombs[i], bombs[j] = bombs[j], bombs[i]\n                break\n    for i in range(m):\n        for j in range(i + 1, m):\n            if bombs[i][0] == bombs[j][0] and bombs[i][1] == bombs[j][1]:\n                bombs[i], bombs[j] = bombs[j], bombs[i]\n                break\n    k = 0\n    for i in range(m):\n        if bombs[i][0] == 1 and bombs[i][1] == 1:\n            k = i\n            break\n    bombs = bombs[k:]\n    for i in range(m):\n        if bombs[i][0] == n and bombs[i][1] == n:\n            k = i\n            break\n    bombs = bombs[:k]\n    return f\"{m}\\n{k + 1} {bombs[0][0]} {bombs[0][1]}\""
    },
    {
        "number": 2005,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, n_1, n_2 = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_max_sum(cities: list[int]) -> float:\n        total_sum = sum(cities)\n        mean_sum = total_sum / len(cities)\n        return mean_sum\n\n    def find_max_sum_for_city(cities: list[int], city_index: int) -> float:\n        cities_without_city_index = [city for city in cities if city!= city_index]\n        return find_max_sum(cities_without_city_index)\n\n    max_sum_1 = find_max_sum_for_city(a, 0)\n    max_sum_2 = find_max_sum_for_city(a, 1)\n\n    return str(max(max_sum_1, max_sum_2))\n"
    },
    {
        "number": 2006,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    game_field = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def is_candy(cell):\n        return cell == 'S'\n\n    def is_dwarf(cell):\n        return cell == 'G'\n\n    def is_empty(cell):\n        return cell == '*'\n\n    def is_rightmost_dwarf(row):\n        return all(is_empty(cell) for cell in row)\n\n    def is_candy_cell(row):\n        return any(is_candy(cell) for cell in row)\n\n    def is_goal(row):\n        return is_rightmost_dwarf(row) or is_candy_cell(row)\n\n    def find_goal_row(game_field):\n        for row in game_field:\n            if is_goal(row):\n                return row\n        return None\n\n    def find_goal_cell(game_field):\n        for row in game_field:\n            if is_goal(row):\n                return row.index('*')\n        return None\n\n    def find_empty_cell(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and is_dwarf(cell):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_candy(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and is_candy(cell):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and (is_dwarf(cell) or is_candy(cell)):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy_in_same_row(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and (is_dwarf(cell) or is_candy(cell)) and is_empty(game_field[row.index(cell)][row.index('*')]):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy_in_same_column(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and (is_dwarf(cell) or is_candy(cell)) and is_empty(game_field[row.index('*')][row.index(cell)]):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy_in_diagonal(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and (is_dwarf(cell) or is_candy(cell)) and is_empty(game_field[row.index(cell)][row.index(cell)]):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy_in_opposite_diagonal(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and (is_dwarf(cell) or is_candy(cell)) and is_empty(game_field[row.index(cell)][row.index(n - 1 - cell)]):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy_in_opposite_diagonal_and_same_row(game_field):\n        for row in game_field:\n            for cell in row:\n                if is_empty(cell) and (is_dwarf(cell) or is_candy(cell)) and is_empty(game_field[row.index(cell)][row.index(n - 1 - cell)]):\n                    return row.index(cell)\n        return None\n\n    def find_empty_cell_with_dwarf_and_candy_in_opposite_diagonal_and_same_column(game_field):\n       "
    },
    {
        "number": 2007,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[1:3])\n        graph[x].append(y)\n        graph[y].append(x)\n    max_value = -1\n    max_path = []\n    for i in range(1, n + 1):\n        if s[i - 1] not in max_path:\n            path = [i]\n            value = 1\n            while path[-1]!= n:\n                for neighbor in graph[path[-1]]:\n                    if s[neighbor - 1] not in path:\n                        path.append(neighbor)\n                        value += 1\n                        break\n                else:\n                    break\n            if value > max_value:\n                max_value = value\n                max_path = path\n    return str(max_value) if max_value!= -1 else \"-1\"\n"
    },
    {
        "number": 2008,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    students = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def dissatisfaction(i: int, j: int) -> int:\n        return students[i][0] * (j - 1) + students[i][1] * (n - j)\n\n    def min_dissatisfaction(i: int, j: int) -> int:\n        return min(dissatisfaction(i, k) + dissatisfaction(k, j) for k in range(i, j))\n\n    def min_total_dissatisfaction() -> int:\n        return min(min_dissatisfaction(i, j) for i in range(n) for j in range(i + 1, n))\n\n    return str(min_total_dissatisfaction())\n"
    },
    {
        "number": 2009,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    r1, c1 = map(int, stdin.split()[1].split())\n    r2, c2 = map(int, stdin.split()[2].split())\n    grid = [list(map(int, line.split())) for line in stdin.split()[3:]]\n\n    def is_land(r: int, c: int) -> bool:\n        return grid[r-1][c-1] == 0\n\n    def is_adjacent(r1: int, c1: int, r2: int, c2: int) -> bool:\n        return (r1-r2)**2 + (c1-c2)**2 <= 1\n\n    def min_cost(r1: int, c1: int, r2: int, c2: int) -> int:\n        if not is_land(r1, c1) or not is_land(r2, c2):\n            return 0\n\n        if r1 == r2 and c1 == c2:\n            return 0\n\n        if is_adjacent(r1, c1, r2, c2):\n            return 0\n\n        return 1\n\n    return str(min_cost(r1, c1, r2, c2))"
    },
    {
        "number": 2010,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    for i in range(m):\n        t, v, x = map(int, stdin.split())\n        if t == 1:\n            a[v - 1] = x\n        elif t == 2:\n            for j in range(n):\n                a[j] += y\n        elif t == 3:\n            print(a[q - 1])\n    return \" \".join(map(str, a))"
    },
    {
        "number": 2011,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    debt = [[] for _ in range(n + 1)]\n    for u, v, d in map(lambda x: list(map(int, x.split())), stdin.split()[1:].split('\\n')):\n        debt[u].append((v, d))\n        debt[v].append((u, d))\n\n    def consolidate(a, b, c, d, z):\n        nonlocal debt\n        debt[a].remove((b, d))\n        debt[b].remove((a, d))\n        debt[c].remove((a, z))\n        debt[a].append((c, z))\n        debt[c].append((a, z))\n        debt[a].append((b, z))\n        debt[b].append((a, z))\n        debt[a].append((a, 0))\n\n    def find_min_debt(a, b):\n        return min(debt[a], key=lambda x: x[1])[1]\n\n    def find_min_debt_pair(a, b):\n        return min(debt[a], key=lambda x: x[1])[0], min(debt[b], key=lambda x: x[1])[0]\n\n    def find_min_debt_pair_sum(a, b):\n        return sum(min(debt[a], key=lambda x: x[1])[1], min(debt[b], key=lambda x: x[1])[1])\n\n    def find_min_debt_pair_sum_pair(a, b):\n        return find_min_debt_pair_sum(a, b), find_min_debt_pair_sum(b, a)\n\n    def find_min_debt_pair_sum_pair_min(a, b):\n        return min(find_min_debt_pair_sum_pair(a, b))\n\n    def find_min_debt_pair_sum_pair_max(a, b):\n        return max(find_min_debt_pair_sum_pair(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max(a, b):\n        return min(find_min_debt_pair_sum_pair(a, b)), max(find_min_debt_pair_sum_pair(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max_min(a, b):\n        return min(find_min_debt_pair_sum_pair_min(a, b), find_min_debt_pair_sum_pair_max(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max_max(a, b):\n        return max(find_min_debt_pair_sum_pair_min(a, b), find_min_debt_pair_sum_pair_max(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max_min_max(a, b):\n        return min(find_min_debt_pair_sum_pair_min_max(a, b), find_min_debt_pair_sum_pair_min_max(b, a))\n\n    def find_min_debt_pair_sum_pair_min_max_min_max_min(a, b):\n        return min(find_min_debt_pair_sum_pair_min_max_min(a, b), find_min_debt_pair_sum_pair_min_max_max(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max_min_max_max(a, b):\n        return max(find_min_debt_pair_sum_pair_min_max_min(a, b), find_min_debt_pair_sum_pair_min_max_max(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max_min_max_min_max(a, b):\n        return min(find_min_debt_pair_sum_pair_min_max_min_max(a, b), find_min_debt_pair_sum_pair_min_max_max_min(a, b))\n\n    def find_min_debt_pair_sum_pair_min_max_min_max_min_max_min"
    },
    {
        "number": 2012,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    s = \"abcdefghijklmnopqrstuvwxyz\"\n    result = \"\"\n    for i in range(n):\n        result += s[c[i] - 1]\n    return result"
    },
    {
        "number": 2013,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    chips = []\n    for i in range(k):\n        x, y = map(int, stdin.split())\n        chips.append((x, y))\n\n    def move(x, y, dx, dy):\n        return (x + dx, y + dy) if 0 <= x + dx < n and 0 <= y + dy < m else (x, y)\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def is_visited(x, y):\n        return any(abs(x - fx) + abs(y - fy) == 1 for fx, fy in chips)\n\n    def dfs(x, y, dx, dy):\n        if not is_valid(x, y):\n            return\n        if is_visited(x, y):\n            return\n        if (x, y) == (fx, fy):\n            return\n        if (x, y) == (sx, sy):\n            return\n        if (x, y) == (sx + 1, sy) or (x, y) == (sx - 1, sy):\n            return\n        if (x, y) == (sx, sy + 1) or (x, y) == (sx, sy - 1):\n            return\n        if (x, y) == (sx + 1, sy + 1) or (x, y) == (sx - 1, sy - 1) or (x, y) == (sx + 1, sy - 1) or (x, y) == (sx - 1, sy + 1):\n            return\n        if (x, y) == (sx + 2, sy) or (x, y) == (sx - 2, sy) or (x, y) == (sx, sy + 2) or (x, y) == (sx, sy - 2):\n            return\n        if (x, y) == (sx + 1, sy + 2) or (x, y) == (sx - 1, sy - 2) or (x, y) == (sx + 1, sy - 2) or (x, y) == (sx - 1, sy + 2):\n            return\n        if (x, y) == (sx + 2, sy + 1) or (x, y) == (sx - 2, sy - 1) or (x, y) == (sx + 2, sy - 1) or (x, y) == (sx - 2, sy + 1):\n            return\n        if (x, y) == (sx + 1, sy + 2) or (x, y) == (sx - 1, sy - 2) or (x, y) == (sx + 1, sy - 2) or (x, y) == (sx - 1, sy + 2):\n            return\n        if (x, y) == (sx + 2, sy + 2) or (x, y) == (sx - 2, sy - 2) or (x, y) == (sx + 2, sy - 2) or (x, y) == (sx - 2, sy + 2):\n            return\n        if (x, y) == (sx + 1, sy + 1) or (x, y) == (sx - 1, sy - 1) or (x, y) == (sx + 1, sy - 1) or (x, y) == (sx - 1, sy + 1):\n            return\n        if (x, y) == (sx + 2, sy + 1) or (x, y) == (sx - 2, sy - 1) or (x, y) == (sx + 2, sy - 1) or (x, y) == (sx - 2, sy + 1):\n            return\n        if (x, y) == (sx + 1, sy + 1) or (x, y) == (sx - 1, sy - 1) or (x, y) == (sx + 1, sy - 1) or (x, y) == (sx - 1, sy + 1):\n            return\n        if (x, y) == (sx + 2, sy + 2) or (x, y) == (sx - 2, sy - 2) or (x, y) == (sx + 2, sy - 2) or (x, y) == (sx - 2"
    },
    {
        "number": 2014,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    permutations = []\n    for _ in range(k):\n        permutation = list(map(int, stdin.split()))\n        permutations.append(permutation)\n\n    def lcs(s1, s2):\n        m, n = len(s1), len(s2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s1[i - 1] == s2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n        return dp[m][n]\n\n    max_length = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            subsequence = permutations[i] + permutations[j]\n            length = lcs(subsequence, permutations[0])\n            if length > max_length:\n                max_length = length\n\n    return str(max_length)\n"
    },
    {
        "number": 2015,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        r, g, b = map(int, stdin.split()[1:])\n        if r + g + b > 10:\n            print(\"No\")\n        else:\n            print(\"Yes\")"
    },
    {
        "number": 2016,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries, mana = map(int, stdin.split())\n    spells = []\n    for _ in range(queries):\n        k, a, b = map(int, stdin.split())\n        if k == 1:\n            x = (a + queries) % (10**6 + 1) + 1\n            y = (b + queries) % (10**6 + 1) + 1\n            spells.append((x, y))\n        else:\n            t = (a + queries) % (10**6 + 1) + 1\n            h = (b + queries) % (10**6 + 1) + 1\n            if t <= 0:\n                print(\"NO\")\n            else:\n                print(\"YES\" if can_win(spells, t, h, mana) else \"NO\")\n\ndef"
    },
    {
        "number": 2017,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    swaps = []\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:])\n        swaps.append((a, b))\n    swaps.sort()\n    inversions = 0\n    i, j = 0, 1\n    while j < len(swaps):\n        if swaps[i][0] > swaps[j][1]:\n            inversions += j - i\n            i = j\n        j += 1\n    return str(inversions)"
    },
    {
        "number": 2018,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    sectors = []\n    for i in range(1, n + 1):\n        sectors.append((1, i))\n    for i in range(1, m + 1):\n        sectors.append((2, i))\n    sectors.sort()\n    for _ in range(q):\n        s_x, s_y, e_x, e_y = map(int, stdin.split())\n        if s_x == 1:\n            s_y = min(s_y, n)\n        else:\n            s_y = min(s_y, m)\n        if e_x == 1:\n            e_y = min(e_y, n)\n        else:\n            e_y = min(e_y, m)\n        if (s_x, s_y) in sectors and (e_x, e_y) in sectors:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 2019,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        s = input()\n        alice_moves = 0\n        bob_moves = 0\n        for i in range(len(s) - 1):\n            if s[i] == '0' and s[i + 1] == '0':\n                alice_moves += 1\n            elif s[i] == '1' and s[i + 1] == '1':\n                bob_moves += 1\n        if alice_moves > bob_moves:\n            print('DA')\n        elif alice_moves < bob_moves:\n            print('NET')\n        else:\n            print('NET')"
    },
    {
        "number": 2020,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    clocks = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def paint_segment(segment_type, start, end):\n        if segment_type =='vertical':\n            for x in range(start[0], end[0] + 1):\n                for y in range(start[1], end[1] + 1):\n                    if distance((x, y), start) <= distance((x, y), end):\n                        print(f'paint {x} {y} horizontal')\n                    else:\n                        print(f'paint {x} {y} vertical')\n        else:\n            for y in range(start[1], end[1] + 1):\n                for x in range(start[0], end[0] + 1):\n                    if distance((x, y), start) <= distance((x, y), end):\n                        print(f'paint {x} {y} vertical')\n                    else:\n                        print(f'paint {x} {y} horizontal')\n\n    def find_min_segments(clocks):\n        min_segments = 0\n        for i in range(len(clocks)):\n            for j in range(i + 1, len(clocks)):\n                if clocks[i]!= clocks[j]:\n                    start = clocks[i]\n                    end = clocks[j]\n                    paint_segment('vertical', start, end)\n                    paint_segment('horizontal', start, end)\n                    min_segments += 2\n        return min_segments\n\n    return str(find_min_segments(clocks))"
    },
    {
        "number": 2021,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *q = map(int, stdin.split())\n\n    def min_coins(q: List[int]) -> int:\n        total_coins = 0\n        for i in range(1, len(q)):\n            total_coins += q[i] * a[i]\n        return total_coins\n\n    min_total_coins = float('inf')\n    for i in range(m):\n        total_coins = min_coins(q)\n        if total_coins < min_total_coins:\n            min_total_coins = total_coins\n\n    return''.join(map(str, min_total_coins))"
    },
    {
        "number": 2022,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(v, visited):\n        visited[v] = True\n        for neighbor in graph[v]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    def find_independent_set(graph):\n        visited = [False] * (n + 1)\n        independent_set = set()\n        for v in range(1, n + 1):\n            if not visited[v]:\n                dfs(v, visited)\n                for neighbor in graph[v]:\n                    if visited[neighbor]:\n                        independent_set.add(neighbor)\n        return independent_set\n\n    def find_simple_cycle(graph):\n        visited = [False] * (n + 1)\n        cycle = []\n        for v in range(1, n + 1):\n            if not visited[v]:\n                dfs(v, visited, cycle)\n        return cycle\n\n    independent_set = find_independent_set(graph)\n    if len(independent_set) == k // 2:\n        return \"1\\n\" + \" \".join(map(str, independent_set))\n    else:\n        cycle = find_simple_cycle(graph)\n        if cycle:\n            return \"2\\n\" + str(len(cycle)) + \"\\n\" + \" \".join(map(str, cycle))\n        else:\n            return \"2\\n\" + \"0\\n\""
    },
    {
        "number": 2023,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    for i in range(m):\n        t, x, y, k = map(int, stdin.split())\n        if t == 1:\n            for q in range(k):\n                b[y + q] = a[x + q]\n        elif t == 2:\n            print(b[x])\n\n    return \"\\n\".join(map(str, b))\n"
    },
    {
        "number": 2024,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def show_fish(fisherman: int, weight: int, max_weight: int) -> str:\n        if weight >= 2 * max_weight:\n            return \"happy\"\n        elif 2 * weight <= max_weight:\n            return \"sad\"\n        else:\n            return \"content\"\n\n    def count_orders(fisherman_weights: list) -> int:\n        orders = []\n        for i in range(1, n + 1):\n            order = []\n            for j in range(n):\n                if j == i - 1:\n                    order.append(fisherman_weights[j])\n                else:\n                    order.append(fisherman_weights[j] + 1)\n            orders.append(tuple(order))\n\n        return len(set(orders))\n\n    happy_fisherman_weights = [0] * n\n    max_weight = 0\n\n    for weight in a:\n        max_weight = max(max_weight, weight)\n        for i in range(n):\n            if show_fish(i, weight, max_weight) == \"happy\":\n                happy_fisherman_weights[i] += weight\n\n    return str(count_orders(happy_fisherman_weights) % 998244353)\n"
    },
    {
        "number": 2025,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n = int(stdin.split()[1])\n        if n == 1:\n            print(1)\n        elif n == 2:\n            print(2)\n        else:\n            max_summands = 0\n            for i in range(2, int(n**0.5) + 1):\n                if n % i == 0:\n                    max_summands += 1\n                    if n // i!= i:\n                        max_summands += 1\n            if max_summands == 0:\n                print(-1)\n            else:\n                print(max_summands)"
    },
    {
        "number": 2026,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, movements = map(int, stdin.split())\n    movements = list(movements)\n    directions = []\n    for movement in movements:\n        if movement == 'L':\n            directions.append('R')\n        elif movement == 'R':\n            directions.append('L')\n        elif movement == 'U':\n            directions.append('D')\n        elif movement == 'D':\n            directions.append('U')\n\n    directions = ''.join(directions)\n    directions = list(directions)\n\n    points = []\n    current_point = (0, 0)\n    for direction in directions:\n        if direction == 'L':\n            current_point = (current_point[0] - 1, current_point[1])\n        elif direction == 'R':\n            current_point = (current_point[0] + 1, current_point[1])\n        elif direction == 'U':\n            current_point = (current_point[0], current_point[1] - 1)\n        elif direction == 'D':\n            current_point = (current_point[0], current_point[1] + 1)\n        points.append(current_point)\n\n    points = list(set(points))\n    points.sort()\n\n    min_length = len(points)\n    for i in range(len(points) - 1):\n        if points[i] == points[i + 1]:\n            min_length = min(min_length, len(points) - i)\n\n    return str(min_length)"
    },
    {
        "number": 2027,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = [0] * n\n    b[0] = a[0]\n    for i in range(1, n):\n        b[i] = b[i - 1] - a[i] + a[i]\n    return \" \".join(map(str, b))"
    },
    {
        "number": 2028,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    desks = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n    desks.sort(key=lambda x: (x[0], x[1]))\n    mod = 10**9 + 7\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if desks[i][0]!= desks[j][0]:\n                count += 1\n                if count % mod == 0:\n                    return str(count)\n    return str(count)"
    },
    {
        "number": 2029,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    edges.sort()\n\n    def dfs(u, parent, depth):\n        nonlocal max_diameter\n        max_diameter = max(max_diameter, depth)\n        for v, w in edges:\n            if v == u:\n                continue\n            if v == parent:\n                continue\n            dfs(v, u, depth + w)\n\n    max_diameter = 0\n    for u in range(1, n):\n        dfs(u, -1, 0)\n\n    return str(max_diameter)"
    },
    {
        "number": 2030,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *probs = map(float, stdin.split())\n    max_probs = [probs[0]] * n\n    min_probs = [probs[1]] * n\n\n    for i in range(2, n):\n        max_probs[i] = max(max_probs[i - 1], max_probs[i - 2])\n        min_probs[i] = min(min_probs[i - 1], min_probs[i - 2])\n\n    max_probs = [max_probs[i] for i in range(n)]\n    min_probs = [min_probs[i] for i in range(n)]\n\n    return f\"{' '.join(map(str, max_probs))} {' '.join(map(str, min_probs))}\"\n"
    },
    {
        "number": 2031,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i]\n    for i in range(1, n):\n        if b[i] < b[i - 1]:\n            b[i] = b[i - 1] + 1\n    for i in range(m):\n        k, pos = map(int, stdin.split())\n        print(b[pos - 1])"
    },
    {
        "number": 2032,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    castles = [list(map(int, stdin.split())) for _ in range(n)]\n    portals = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def dfs(castle, visited, used_portals):\n        if castle == n:\n            return 0, visited, used_portals\n\n        importance = castles[castle][2]\n        score = importance\n\n        for portal in portals:\n            if portal[0] == castle and portal[1] not in visited and portal[1] not in used_portals:\n                visited.add(portal[1])\n                used_portals.add(portal[1])\n                score += dfs(portal[1], visited, used_portals)\n                visited.remove(portal[1])\n                used_portals.remove(portal[1])\n\n        return score, visited, used_portals\n\n    max_score = 0\n    visited = set()\n    used_portals = set()\n\n    for i in range(n):\n        if castles[i][0] <= k:\n            score, visited, used_portals = dfs(i, visited, used_portals)\n            max_score = max(max_score, score)\n\n    if max_score == 0:\n        return -1\n    else:\n        return max_score"
    },
    {
        "number": 2033,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = set()\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        roads.add((u, v))\n        roads.add((v, u))\n    k = int(stdin.split()[-1])\n    path = list(map(int, stdin.split()[-k:]))\n    path.append(path[0])\n    path.sort()\n    min_rebuilds = max_rebuilds = 0\n    for i in range(len(path) - 1):\n        for j in range(i + 1, len(path)):\n            if path[i] == path[j]:\n                min_rebuilds += 1\n                max_rebuilds += 1\n                break\n            if path[i] < path[j]:\n                min_rebuilds += 1\n            else:\n                max_rebuilds += 1\n    return f\"{min_rebuilds} {max_rebuilds}\""
    },
    {
        "number": 2034,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    separated_cities = 0\n    for i in range(1, n + 1):\n        if not graph[i]:\n            separated_cities += 1\n            dfs(i, set())\n\n    return str(separated_cities)"
    },
    {
        "number": 2035,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s_x, s_y = map(int, stdin.split())\n    houses = [tuple(map(int, stdin.split())) for _ in range(n)]\n    houses.sort(key=lambda x: (x[0] - s_x, x[1] - s_y))\n\n    def bfs(start: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, distance = queue.pop(0)\n            if current in visited:\n                continue\n            visited.add(current)\n            if current == (s_x, s_y):\n                return distance\n            for neighbor in [(current[0] + 1, current[1]), (current[0] - 1, current[1]), (current[0], current[1] + 1), (current[0], current[1] - 1)]:\n                if neighbor not in visited and neighbor not in queue:\n                    queue.append(neighbor)\n        return -1\n\n    max_students = 0\n    max_distance = 0\n    for house in houses:\n        distance = bfs(house)\n        if distance > max_distance:\n            max_distance = distance\n            max_students = 1\n        elif distance == max_distance:\n            max_students += 1\n\n    if max_students == 0:\n        return \"0\\n0 0\"\n\n    tent_x = s_x\n    tent_y = s_y\n    for _ in range(max_students):\n        tent_x += 1\n        tent_y += 1\n        if bfs((tent_x, tent_y))!= -1:\n            break\n\n    return str(max_students) + \"\\n\" + str(tent_x) + \" \" + str(tent_y)"
    },
    {
        "number": 2036,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, sx, sy = map(int, stdin.split())\n    visited = set()\n    queue = [(sx, sy)]\n    while queue:\n        x, y = queue.pop(0)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if (x, y) == (n, m):\n            return f\"{x} {y}\\n\"\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= n and 1 <= ny <= m and (nx, ny) not in visited:\n                queue.append((nx, ny))\n    return \"No solution\\n\""
    },
    {
        "number": 2037,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    pool = []\n    for i in range(m):\n        pool.append((a[i], i + 1))\n\n    for i in range(m, n):\n        pool.append((i + 1, i + 1))\n\n    pool.sort(key=lambda x: x[0])\n\n    result = [0] * m\n\n    for i in range(m):\n        if pool[i][0] == i + 1:\n            result[i] = 1\n            pool.pop(i)\n            m -= 1\n            i -= 1\n\n    return ''.join(map(str, result))"
    },
    {
        "number": 2038,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p.sort()\n    m = 0\n    for i in range(n - 1):\n        if abs(p[i] - p[i + 1]) >= n // 2:\n            m += 1\n            p[i], p[i + 1] = p[i + 1], p[i]\n    return str(m) + '\\n' + '\\n'.join(f'{a} {b}' for a, b in zip(p, p[1:]))"
    },
    {
        "number": 2039,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    local_extrema = 0\n    for i in range(1, n - 1):\n        if a[i] < a[i - 1] and a[i] < a[i + 1]:\n            local_extrema += 1\n        if a[i] > a[i - 1] and a[i] > a[i + 1]:\n            local_extrema += 1\n\n    print(local_extrema)\n    return \"\"\n"
    },
    {
        "number": 2040,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    b = list(map(int, stdin.split()[1:]))\n\n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    def min_sum_of_digits(b: List[int]) -> int:\n        return min(sum_of_digits(num) for num in b)\n\n    def min_num(b: List[int]) -> int:\n        return min(num for num in b if num!= 0)\n\n    def min_num_sequence(b: List[int]) -> List[int]:\n        min_sum = min_sum_of_digits(b)\n        min_num = min_num(b)\n        return [num for num in b if sum_of_digits(num) == min_sum]\n\n    min_sequence = min_num_sequence(b)\n    return \" \".join(map(str, min_sequence))\n"
    },
    {
        "number": 2041,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i]\n    for i in range(1, n):\n        if b[i] < b[i - 1]:\n            b[i] = b[i - 1] + 1\n    for i in range(m):\n        k, pos = map(int, stdin.split())\n        print(b[pos - 1])"
    },
    {
        "number": 2042,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    museum = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    starting_positions = [list(map(int, line.split())) for line in stdin.split('\\n')[-1].split()]\n\n    def dfs(x, y, visited):\n        if x < 0 or x >= n or y < 0 or y >= m or museum[x][y] == '*' or (x, y) in visited:\n            return 0\n\n        visited.add((x, y))\n        if museum[x][y] == '.':\n            return 1 + dfs(x + 1, y, visited) + dfs(x - 1, y, visited) + dfs(x, y + 1, visited) + dfs(x, y - 1, visited)\n        else:\n            return 1 + dfs(x + 1, y, visited) + dfs(x - 1, y, visited) + dfs(x, y + 1, visited) + dfs(x, y - 1, visited)\n\n    max_pictures = 0\n    for x, y in starting_positions:\n        max_pictures = max(max_pictures, dfs(x - 1, y - 1, set()))\n\n    return str(max_pictures)"
    },
    {
        "number": 2043,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    s_set = set(s)\n    t_set = set(t)\n    count = 0\n    for i in range(1, len(s) + 1):\n        for j in range(1, len(t) - i + 1):\n            if s_set.issubset(t_set[:j]) and s_set.issubset(t_set[j:]) and s_set.issubset(t_set[j:j+i]):\n                count += 1\n    return str(count)"
    },
    {
        "number": 2044,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    t = [0] * n\n    for i in range(n):\n        t[i] = 1\n        for j in range(i + 1, n):\n            if a[j] <= m:\n                t[i] += t[j]\n\n    return \" \".join(map(str, t))\n"
    },
    {
        "number": 2045,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    words = stdin.split()[1:]\n    compressed_words = []\n\n    for i in range(n):\n        if i == 0:\n            compressed_words.append(words[i])\n        else:\n            merged_word = words[i]\n            for j in range(i):\n                if words[j].endswith(words[i]):\n                    merged_word = words[j] + merged_word[len(words[j]):]\n                    break\n            compressed_words.append(merged_word)\n\n    return \" \".join(compressed_words)"
    },
    {
        "number": 2046,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *snacks = map(int, stdin.split())\n    snacks.sort(reverse=True)\n    result = []\n    for i in range(n):\n        if snacks[i] == 1:\n            result.append(snacks[i])\n        else:\n            result.append(snacks[i])\n            result.append(snacks[i-1])\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2047,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *b, *a, *t = map(int, stdin.split())\n    b = [b[i] - 1 for i in range(n)]\n    a = [a[i] - 1 for i in range(n)]\n    t = [(x - 1, k - 1) for x, k in t]\n\n    def transform(i: int, x: int, k: int) -> int:\n        if x == i:\n            return k\n        elif x == i + 1:\n            return 1\n        else:\n            return 0\n\n    def check(i: int, x: int, k: int) -> bool:\n        if x == i:\n            return k == 1\n        elif x == i + 1:\n            return k == 1\n        else:\n            return k == 0\n\n    for i in range(n):\n        if not check(i, b[i], a[i]):\n            return \"NO\"\n\n    for x, k in t:\n        if not check(x, x, k):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 2048,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *s, *c = map(int, stdin.split())\n    s.sort()\n    c.sort()\n    for i in range(n - 2):\n        if s[i] < s[i + 1] < s[i + 2]:\n            return c[i] + c[i + 1] + c[i + 2]\n    return -1"
    },
    {
        "number": 2049,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        queries.append((l, r))\n\n    def is_ladder(seq):\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i + 1]:\n                return False\n        return True\n\n    result = []\n    for l, r in queries:\n        subseq = a[l - 1:r]\n        if is_ladder(subseq):\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2050,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    m = 1\n    while True:\n        if is_valid_set(n, k, m):\n            break\n        m += 1\n    return str(m)\n\ndef"
    },
    {
        "number": 2051,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    socks = [colors[i - 1] for i in range(1, n + 1)]\n\n    for i in range(m):\n        left, right = map(int, stdin.split())\n        socks[left - 1], socks[right - 1] = socks[right - 1], socks[left - 1]\n\n    return str(min(set(socks), key=socks.count))"
    },
    {
        "number": 2052,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def can_cross(i, j):\n        return i + j <= w\n\n    def dfs(i, j, count):\n        if i == w - 1:\n            return count\n        if not can_cross(i, j):\n            return dfs(i + 1, j, count)\n        for k in range(1, min(j, l) + 1):\n            if a[i + k] > 0:\n                a[i + k] -= 1\n                count = dfs(i + k, j, count)\n                a[i + k] += 1\n        return count\n\n    count = 0\n    for i in range(w - 1):\n        count = dfs(i, a[i], count)\n    return str(count)"
    },
    {
        "number": 2053,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *b = map(int, stdin.split())\n\n    a_sum = sum(a)\n    b_sum = sum(b)\n\n    if a_sum == b_sum:\n        return \"0\\n0\"\n\n    if a_sum < b_sum:\n        a, b = b, a\n        a_sum, b_sum = b_sum, a_sum\n\n    def min_swaps(a, b):\n        a_sum = sum(a)\n        b_sum = sum(b)\n\n        if a_sum == b_sum:\n            return 0\n\n        if a_sum < b_sum:\n            a, b = b, a\n            a_sum, b_sum = b_sum, a_sum\n\n        swaps = 0\n        i, j = 0, 0\n\n        while i < n and j < m:\n            if a[i] < b[j]:\n                i += 1\n            elif a[i] > b[j]:\n                j += 1\n            else:\n                i += 1\n                j += 1\n\n            swaps += 1\n\n            if swaps > 2:\n                break\n\n        return swaps\n\n    min_swaps_value = float(\"inf\")\n    min_swaps_sequence = []\n\n    for i in range(n):\n        for j in range(m):\n            if i!= j:\n                a_new = a[:i] + a[i+1:]\n                b_new = b[:j] + b[j+1:]\n\n                swaps = min_swaps(a_new, b_new)\n\n                if swaps < min_swaps_value:\n                    min_swaps_value = swaps\n                    min_swaps_sequence = [(i+1, j+1)]\n                elif swaps == min_swaps_value:\n                    min_swaps_sequence.append((i+1, j+1))\n\n    return f\"{min_swaps_value}\\n{len(min_swaps_sequence)}\\n{' '.join(map(str, min_swaps_sequence))}\\n\""
    },
    {
        "number": 2054,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        a, b = map(int, stdin.split('\\n')[1].split())\n        if a == 0 and b == 0:\n            print(0)\n        elif a == 0:\n            print(b)\n        elif b == 0:\n            print(a)\n        else:\n            print(max(a, b))"
    },
    {
        "number": 2055,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, *a, *b = map(int, stdin.split('\\n')[1].split())\n        a = list(zip(range(n), a))\n        b = list(zip(range(n), b))\n        a.sort(key=lambda x: x[1])\n        b.sort(key=lambda x: x[1])\n        for i in range(n):\n            a[i] = (a[i][0], a[i][1] - b[i][1])\n        for i in range(n - 1, 0, -1):\n            b[i] = (b[i][0], b[i][1] - a[i - 1][1])\n        for i in range(n):\n            if a[i][1] > 0:\n                print('YES')\n                return 'YES'\n        print('NO')\n    return 'YES'"
    },
    {
        "number": 2056,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def bitwise_operation(x: int, y: int) -> int:\n        return x & y | (x & y) & (x ^ y)\n\n    def sum_of_squares(a: List[int]) -> int:\n        return sum(x ** 2 for x in a)\n\n    def largest_sum_of_squares(a: List[int]) -> int:\n        max_sum = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                x, y = a[i], a[j]\n                new_a = [x, y]\n                new_sum = sum_of_squares(new_a)\n                if new_sum > max_sum:\n                    max_sum = new_sum\n        return max_sum\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x, y = a[i], a[j]\n            new_a = [x, y]\n            new_sum = sum_of_squares(new_a)\n            if new_sum > max_sum:\n                max_sum = new_sum\n\n    return str(max_sum)"
    },
    {
        "number": 2057,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    t = [0] + t\n    t.sort()\n    count = 1\n    for i in range(1, n):\n        if t[i] - t[i - 1] == 1:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 2058,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(a, 2)\n    b = int(b, 2)\n    hamming_distances = []\n    for i in range(len(b) - len(a) + 1):\n        hamming_distances.append(sum(abs(a - int(b[j:j+len(a)])) for j in range(i, i+len(a))))\n    return str(sum(hamming_distances))"
    },
    {
        "number": 2059,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_k_extension(k: int) -> bool:\n        for i in range(n):\n            for j in range(i + 1, n):\n                if abs(i - j) > k * min(a[i], a[j]):\n                    return False\n        return True\n\n    k = 1\n    while not is_k_extension(k):\n        k += 1\n\n    return str(k)"
    },
    {
        "number": 2060,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:]))\n\n    for i in range(n):\n        if x[i] % 3 == 0:\n            print(\"YES\")\n            break\n        elif x[i] % 7 == 0:\n            print(\"YES\")\n            break\n        else:\n            print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 2061,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    map_ = [list(row) for row in stdin.split('\\n')[1:]]\n    lakes = []\n    for i in range(n):\n        for j in range(m):\n            if map_[i][j] == '*':\n                lakes.append((i, j))\n    lakes.sort(key=lambda x: (x[0], x[1]))\n    lakes = lakes[:k]\n    for i, j in lakes:\n        for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if 0 <= i + di < n and 0 <= j + dj < m and map_[i + di][j + dj] == '.':\n                map_[i + di][j + dj] = '*'\n                break\n    return '\\n'.join([''.join(row) for row in map_])"
    },
    {
        "number": 2062,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def max_power(a, b):\n        return lcm(a, b)\n\n    def max_total_power(a, b):\n        max_power_a = max_power(a, b)\n        max_power_b = max_power(b, a)\n        return max_power_a + max_power_b\n\n    def is_valid(a, b):\n        return max_power_a % max_power_b == 0\n\n    max_total_power_a = 0\n    max_total_power_b = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid(a[i], a[j]):\n                max_total_power_a = max(max_total_power_a, max_total_power(a[i], a[j]))\n            if is_valid(a[i], a[j]):\n                max_total_power_b = max(max_total_power_b, max_total_power(a[i], a[j]))\n\n    return str(max(max_total_power_a, max_total_power_b))\n"
    },
    {
        "number": 2063,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def water_flowers(heights: list, w: int) -> int:\n        for i in range(len(heights)):\n            if heights[i] > 0:\n                heights[i] -= 1\n                if heights[i] == 0:\n                    return i\n        return -1\n\n    heights = [a[0]]\n    for i in range(1, n):\n        if i % w == 0:\n            index = water_flowers(heights, w)\n            if index == -1:\n                return \"IMPOSSIBLE\"\n            heights[index] += 1\n        else:\n            heights.append(heights[-1] + 1)\n\n    return max(heights)"
    },
    {
        "number": 2064,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_num = 1\n    for i in range(1, 10):\n        max_num *= i\n    return str(max_num)"
    },
    {
        "number": 2065,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    father = [[] for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        p, q = map(int, stdin.split())\n        father[p].append(q)\n        father[q].append(p)\n\n    a = list(map(int, stdin.split()))\n    candidates = []\n    for i in range(1, n + 1):\n        if a[i - 1] == i:\n            candidates.append(i)\n\n    def is_ancestor(a, b):\n        if a == b:\n            return True\n        for c in father[a]:\n            if c == b:\n                return True\n        return False\n\n    def find_ancestor(a):\n        for b in father[a]:\n            if is_ancestor(a, b):\n                return b\n        return None\n\n    def find_candidates():\n        for i in range(1, n + 1):\n            if i not in candidates:\n                continue\n            for j in range(i + 1, n + 1):\n                if j not in candidates:\n                    continue\n                if is_ancestor(i, j):\n                    continue\n                if is_ancestor(j, i):\n                    continue\n                if i < j:\n                    candidates.append(i)\n                    candidates.append(j)\n                    return\n\n    find_candidates()\n    if not candidates:\n        return -1\n\n    result = []\n    for i in range(1, n + 1):\n        if i in candidates:\n            result.append(i)\n\n    return str(len(result)) + '\\n' +''.join(map(str, result))"
    },
    {
        "number": 2066,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        s = stdin.split()[1]\n        ugly_pairs = []\n        for i in range(len(s) - 1):\n            for j in range(i + 2, len(s) + 1):\n                if s[i] == s[j - 1] and s[j - 1] == s[j - 2]:\n                    ugly_pairs.append((i, j - 1))\n        if not ugly_pairs:\n            print(\"No answer\")\n        else:\n            for pair in ugly_pairs:\n                s = s[:pair[0]] + s[pair[0] + 1:pair[1]] + s[pair[1] + 1:]\n            print(s)"
    },
    {
        "number": 2067,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    vertical_spells = []\n    horizontal_spells = []\n\n    for _ in range(n):\n        x = int(stdin.readline().strip())\n        vertical_spells.append(x)\n\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.readline().strip().split())\n        horizontal_spells.append((x1, x2, y))\n\n    vertical_spells.sort()\n    horizontal_spells.sort()\n\n    min_spells = 0\n    for i in range(len(vertical_spells)):\n        for j in range(len(horizontal_spells)):\n            if vertical_spells[i] < horizontal_spells[j][0] or vertical_spells[i] > horizontal_spells[j][1]:\n                min_spells += 1\n                break\n\n    return str(min_spells)"
    },
    {
        "number": 2068,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    reposts = stdin.split('\\n')\n    reposts.pop(0)\n    max_length = 0\n    for repost in reposts:\n        repost_chain = [repost]\n        current_repost = repost\n        while current_repost in reposts:\n            current_repost = reposts[reposts.index(current_repost) + 1]\n            repost_chain.append(current_repost)\n        max_length = max(max_length, len(repost_chain))\n    return str(max_length)"
    },
    {
        "number": 2069,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    foes = set()\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        foes.add((a, b))\n\n    intervals = set()\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            intervals.add((i, j))\n\n    count = 0\n    for interval in intervals:\n        if not any(interval[0] <= a <= interval[1] or interval[0] <= b <= interval[1] for a, b in foes):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2070,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = list(map(int, stdin.split()))\n    s = stdin.split()[1]\n\n    def sum_except_first_and_last(s: str) -> int:\n        return sum(x[i] for i in range(1, len(s) - 1))\n\n    def is_interesting(t: str) -> bool:\n        return t[0] == t[-1] and len(t) > 1\n\n    interesting_substrings = [t for t in s.split() if is_interesting(t)]\n    interesting_substrings_sum = sum(sum_except_first_and_last(t) for t in interesting_substrings)\n\n    return str(len(interesting_substrings)) + \"\\n\" + str(interesting_substrings_sum)\n"
    },
    {
        "number": 2071,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def dfs(i, j, visited, weight):\n        if i == n - 1 and j == n - 1:\n            return weight\n\n        if (i, j) in visited:\n            return 0\n\n        visited.add((i, j))\n\n        if i > 0:\n            weight += dfs(i - 1, j, visited, weight)\n        if j > 0:\n            weight += dfs(i, j - 1, visited, weight)\n        if i < n - 1:\n            weight += dfs(i + 1, j, visited, weight)\n        if j < n - 1:\n            weight += dfs(i, j + 1, visited, weight)\n\n        return weight\n\n    return str(dfs(0, 0, set(), 0))"
    },
    {
        "number": 2072,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *coordinates, *speeds = map(int, stdin.split())\n    coordinates = [tuple(coordinates)]\n    speeds = [tuple(speeds)]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def closest_point(coordinates, point):\n        return min(coordinates, key=lambda x: distance(x, point))\n\n    def closest_point_index(coordinates, point):\n        return coordinates.index(closest_point(coordinates, point))\n\n    def closest_point_index_by_speed(coordinates, speeds, point):\n        closest_index = closest_point_index(coordinates, point)\n        closest_speed = speeds[closest_index]\n        return closest_index if closest_speed[0] <= point[0] <= speeds[closest_index + 1][0] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed(coordinates, speeds, point)\n        closest_distance = distance(coordinates[closest_index], point)\n        return closest_index if closest_distance <= speeds[closest_index][1] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance_and_time(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed_and_distance(coordinates, speeds, point)\n        closest_time = distance(coordinates[closest_index], point) / speeds[closest_index][0]\n        return closest_index if closest_time <= speeds[closest_index][2] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance_and_time_and_speed(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed_and_distance_and_time(coordinates, speeds, point)\n        closest_speed = speeds[closest_index]\n        return closest_index if closest_speed[0] <= point[0] <= speeds[closest_index + 1][0] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance_and_time_and_speed_and_time(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed_and_distance_and_time_and_speed(coordinates, speeds, point)\n        closest_time = distance(coordinates[closest_index], point) / closest_speed[0]\n        return closest_index if closest_time <= speeds[closest_index][3] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance_and_time_and_speed_and_time_and_distance(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed_and_distance_and_time_and_speed_and_time(coordinates, speeds, point)\n        closest_distance = distance(coordinates[closest_index], point)\n        return closest_index if closest_distance <= speeds[closest_index][4] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance_and_time_and_speed_and_time_and_distance_and_time(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed_and_distance_and_time_and_speed_and_time_and_distance(coordinates, speeds, point)\n        closest_time = distance(coordinates[closest_index], point) / speeds[closest_index][5]\n        return closest_index if closest_time <= speeds[closest_index][6] else closest_index + 1\n\n    def closest_point_index_by_speed_and_distance_and_time_and_speed_and_time_and_distance_and_time_and_speed(coordinates, speeds, point):\n        closest_index = closest_point_index_by_speed_and_distance_and_time_and_speed_and_time_and_distance_and_time(coordinates, speeds, point)\n        closest_speed = speeds[closest_index]\n        return closest_index if closest_speed[0] <= point[0] <= speeds[closest_index + 1][0] else closest_"
    },
    {
        "number": 2073,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n\n    def dfs(start, visited, flipped):\n        if start == n:\n            return 1\n\n        count = 0\n        for i in range(n):\n            if i not in visited and (i not in flipped or a[i]!= a[start]):\n                visited.add(i)\n                flipped.add(i)\n                count += dfs(start + 1, visited, flipped)\n                visited.remove(i)\n                flipped.remove(i)\n\n        return count\n\n    return str(dfs(0, set(), set()))"
    },
    {
        "number": 2074,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def dfs(i, j, cost):\n        if i == n - 1 and j == m - 1:\n            return cost\n        if i == n - 1:\n            return dfs(i, j + 1, cost + c[i][j])\n        if j == m - 1:\n            return dfs(i + 1, j, cost + c[i][j])\n        return min(dfs(i, j + 1, cost + c[i][j]), dfs(i + 1, j, cost + c[i][j]))\n\n    return str(dfs(0, 0, 0))\n"
    },
    {
        "number": 2075,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    MOD = 10**9 + 7\n\n    def count_pairs(p: str, q: str) -> int:\n        def is_valid(s: str) -> bool:\n            opening_count = 0\n            closing_count = 0\n            for c in s:\n                if c == '(':\n                    opening_count += 1\n                elif c == ')':\n                    closing_count += 1\n            return opening_count == closing_count\n\n        def merge_strings(p: str, s: str, q: str) -> str:\n            return p + s + q\n\n        def count_valid_pairs(s: str) -> int:\n            pairs = 0\n            for i in range(len(s) - n + 1):\n                if is_valid(s[i:i + n]):\n                    pairs += 1\n            return pairs\n\n        def count_pairs_helper(s: str) -> int:\n            if len(s) == 0:\n                return 0\n            if len(s) == 1:\n                return 1\n            if len(s) == 2:\n                return 2\n\n            pairs = 0\n            for i in range(len(s) - 1):\n                if is_valid(s[i:i + 2]):\n                    pairs += count_pairs_helper(s[i + 2:])\n            return pairs\n\n        pairs = count_valid_pairs(s)\n        pairs += count_pairs_helper(s)\n        return pairs\n\n    pairs = count_pairs(\"\", \"\")\n    for i in range(1, n + 1):\n        pairs += count_pairs(\"(\", \")\")\n        pairs += count_pairs(\"()\", \")\")\n        pairs += count_pairs(\"\", \")\")\n        pairs += count_pairs(\"\", \")\")\n\n    return str(pairs % MOD)\n"
    },
    {
        "number": 2076,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b, c = map(int, stdin.split()[1:])\n        if a > 0 and b >= 2 and c >= 2:\n            print(a + b + c)\n        elif b > 0 and c >= 2:\n            print(a + b + c)\n        elif c > 0 and a >= 2:\n            print(a + b + c)\n        else:\n            print(0)"
    },
    {
        "number": 2077,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    blogs = list(map(int, stdin.split()))\n    references = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        references.append((a - 1, b - 1))\n\n    topics = list(map(int, stdin.split()))\n\n    def dfs(blog: int, visited: set) -> list:\n        if blog in visited:\n            return []\n\n        visited.add(blog)\n        neighbors = [b for b in references if b[0] == blog]\n        neighbors.extend([b for b in references if b[1] == blog])\n\n        result = []\n        for neighbor in neighbors:\n            result.extend(dfs(neighbor[0], visited))\n            result.extend(dfs(neighbor[1], visited))\n\n        result.append(topics[blog - 1])\n        return result\n\n    result = []\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            result.extend(dfs(i, visited))\n\n    if len(result) == n:\n        return \" \".join(map(str, result))\n    else:\n        return -1\n"
    },
    {
        "number": 2078,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    horizontal_segments = []\n    vertical_segments = []\n\n    for _ in range(n):\n        y, lx, rx = map(int, stdin.split())\n        horizontal_segments.append((lx, y, rx))\n\n    for _ in range(m):\n        x, ly, ry = map(int, stdin.split())\n        vertical_segments.append((x, ly, ry))\n\n    horizontal_segments.sort(key=lambda x: x[0])\n    vertical_segments.sort(key=lambda x: x[1])\n\n    horizontal_count = 0\n    vertical_count = 0\n\n    for i in range(len(horizontal_segments)):\n        for j in range(i + 1, len(horizontal_segments)):\n            if horizontal_segments[i][2] < horizontal_segments[j][0]:\n                horizontal_count += 1\n\n    for i in range(len(vertical_segments)):\n        for j in range(i + 1, len(vertical_segments)):\n            if vertical_segments[i][2] < vertical_segments[j][1]:\n                vertical_count += 1\n\n    return str(horizontal_count + vertical_count)"
    },
    {
        "number": 2079,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *w = map(int, stdin.split())\n    order = list(stdin.replace('0', '').replace('1', ''))\n    rows = [[] for _ in range(n)]\n\n    for i, w_i in enumerate(w):\n        rows[i].append(w_i)\n\n    for i, row in enumerate(rows):\n        rows[i].sort()\n\n    for i, seat in enumerate(order):\n        if seat == '0':\n            rows[i].sort(reverse=True)\n            rows[i].pop()\n        else:\n            rows[i].sort()\n            rows[i].pop(0)\n\n    return''.join(map(str, rows[0])) +'' +''.join(map(str, rows[1]))"
    },
    {
        "number": 2080,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    q = int(stdin.split()[1])\n    max_edges = [0] * q\n\n    for i in range(q):\n        n_i = int(stdin.split()[i + 2])\n        max_edges[i] = 2 * n_i - 1\n\n    return \" \".join(map(str, max_edges))\n"
    },
    {
        "number": 2081,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    imbalance_sum = 0\n    for i in range(n):\n        imbalance_sum += max(a[i], a[i + 1]) - min(a[i], a[i + 1])\n\n    print(imbalance_sum)\n    return \"\"\n"
    },
    {
        "number": 2082,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    areas = list(map(int, stdin.split()))\n    roads = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        roads.append((x - 1, y - 1))\n\n    def f(p, q):\n        return min(areas[p - 1], areas[q - 1])\n\n    def dfs(p, visited):\n        if p in visited:\n            return 0\n        visited.add(p)\n        if p == q:\n            return f(p, q)\n        return min(dfs(x, visited) + f(p, x) for x in range(1, n + 1) if x not in visited)\n\n    total = 0\n    for p in range(1, n + 1):\n        for q in range(p + 1, n + 1):\n            total += dfs(p, set())\n\n    return str(total / (n * (n - 1)))\n"
    },
    {
        "number": 2083,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m = int(stdin.split()[0])\n    p = list(map(int, stdin.split()))\n\n    def mean(a: List[int], T: int) -> float:\n        mean = 0.0\n        for i in range(T):\n            mean += a[i] / T\n        return mean\n\n    def exp_decay(mean: float, c: float) -> float:\n        return mean * (1 - c)\n\n    def relative_error(approx: float, real: float) -> float:\n        return abs(approx - real) / real\n\n    approx_means = []\n    for j in range(m):\n        approx_mean = mean(a, T)\n        approx_means.append(approx_mean)\n\n    approx_means = [exp_decay(mean, c) for mean in approx_means]\n\n    real_mean = mean(a, T)\n    real_mean = exp_decay(real_mean, c)\n\n    print(f\"{real_mean:.5f} {approx_means[0]:.5f} {relative_error(approx_means[0], real_mean):.5f}\")\n    for i in range(1, m):\n        print(f\"{approx_means[i]:.5f} {approx_means[i]:.5f} {relative_error(approx_means[i], real_mean):.5f}\")\n\n    return \"\"\n"
    },
    {
        "number": 2084,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    count = 0\n    for i in range(n):\n        if a[i] == k:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2085,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    max_value = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            subsequence = a[i:j]\n            value = sum(2 ** k for k in range(len(subsequence)) if subsequence[k] & (1 << i - 1))\n            max_value = max(max_value, value)\n\n    return str(max_value)"
    },
    {
        "number": 2086,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    s, f = map(int, stdin.split())\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def solve(a, s, f):\n        def count_participants(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1))\n\n        def count_participants_in_time(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0)\n\n        def count_participants_in_time_and_after(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i + 1)!= 0)\n\n        def count_participants_in_time_and_before(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0)\n\n        def count_participants_in_time_and_between(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0 and t % (i + 1)!= 0)\n\n        def count_participants_in_time_and_before_and_after(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0 and t % (i + 1)!= 0 and t % (i + 2)!= 0)\n\n        def count_participants_in_time_and_before_and_after_and_between(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0 and t % (i + 1)!= 0 and t % (i + 2)!= 0 and t % (i + 3)!= 0)\n\n        def count_participants_in_time_and_before_and_after_and_between_and_after(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0 and t % (i + 1)!= 0 and t % (i + 2)!= 0 and t % (i + 3)!= 0 and t % (i + 4)!= 0)\n\n        def count_participants_in_time_and_before_and_after_and_between_and_after_and_between(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0 and t % (i + 1)!= 0 and t % (i + 2)!= 0 and t % (i + 3)!= 0 and t % (i + 4)!= 0 and t % (i + 5)!= 0)\n\n        def count_participants_in_time_and_before_and_after_and_between_and_after_and_between_and_after(t):\n            return sum(a[i] * (t // i) for i in range(1, n + 1) if t % i == 0 and t % (i - 1)!= 0 and t % (i + 1)!= 0 and t % (i + 2)!= 0 and t % (i + 3)!= 0 and t % (i + 4)!= 0 and t % (i + 5)!= 0 and t % (i + 6)!= 0)\n\n        def count_participants_in_time_and_before_and_after_and_between_and_after_and_between_and_after_and_between(t):\n            return sum(a[i] * (t // i"
    },
    {
        "number": 2087,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    result = (A * B * C) % 998244353\n    return str(result)"
    },
    {
        "number": 2088,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b = map(int, stdin.split()[1:])\n        edges[a - 1].append(b - 1)\n        edges[b - 1].append(a - 1)\n\n    def dfs(u: int, color: int, happy: int) -> int:\n        if u == 0:\n            return 1\n\n        min_color = min(color, happy)\n        for v in edges[u]:\n            if v == 0:\n                continue\n            if color == min_color:\n                continue\n            if happy == 0:\n                return 0\n            min_color = min(min_color, dfs(v, color + 1, happy - 1))\n        return min_color\n\n    return \" \".join(map(str, dfs(0, 0, n)))\n"
    },
    {
        "number": 2089,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    junctions = list(range(1, n + 1))\n    roads = []\n\n    for i in range(m):\n        u, v = map(int, stdin.split())\n        roads.append((u, v))\n\n    def bfs(start: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        visited.add(start)\n        distance = {start: 0}\n\n        while queue:\n            current, current_distance = queue.pop(0)\n            for neighbor, weight in roads:\n                if neighbor not in visited and neighbor!= start:\n                    new_distance = current_distance + weight\n                    if neighbor == t:\n                        return new_distance\n                    if neighbor not in distance or new_distance < distance[neighbor]:\n                        distance[neighbor] = new_distance\n                        queue.append((neighbor, new_distance))\n                        visited.add(neighbor)\n\n        return float('inf')\n\n    result = 0\n    for junction in junctions:\n        if junction!= s and junction!= t:\n            distance = bfs(junction)\n            if distance!= float('inf'):\n                result += 1\n\n    return str(result)\n"
    },
    {
        "number": 2090,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    songs = []\n    for _ in range(n):\n        t, b = map(int, stdin.split())\n        songs.append((t, b))\n    songs.sort(key=lambda x: (-x[1], x[0]))\n    total_pleasure = 0\n    for i in range(k):\n        total_pleasure += songs[i][0] * songs[i][1]\n    return str(total_pleasure)"
    },
    {
        "number": 2091,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        s = stdin.split()[1]\n        s = s.lower()\n        n = len(s)\n        max_len = 0\n        max_str = \"\"\n        for i in range(n):\n            for j in range(i+1, n+1):\n                t = s[i:j]\n                if t == t[::-1] and t in s and t in s[::-1]:\n                    if len(t) > max_len:\n                        max_len = len(t)\n                        max_str = t\n        print(max_str)"
    },
    {
        "number": 2092,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, k, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    traps = []\n    for _ in range(k):\n        l, r, d = map(int, stdin.split())\n        traps.append((l, r, d))\n\n    def is_safe(x: int, squad_x: int) -> bool:\n        for l, r, d in traps:\n            if l <= x <= r and d > a[squad_x]:\n                return False\n        return True\n\n    def is_safe_with_squad(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x) and is_safe_with_squad(x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps_and_traps(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x) and is_safe_with_squad(x) and is_safe_with_squad_and_traps(x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps_and_traps_and_traps(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x) and is_safe_with_squad(x) and is_safe_with_squad_and_traps(x) and is_safe_with_squad_and_traps_and_traps(x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps_and_traps_and_traps_and_traps(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x) and is_safe_with_squad(x) and is_safe_with_squad_and_traps(x) and is_safe_with_squad_and_traps_and_traps(x) and is_safe_with_squad_and_traps_and_traps_and_traps(x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps_and_traps_and_traps_and_traps_and_traps(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x) and is_safe_with_squad(x) and is_safe_with_squad_and_traps(x) and is_safe_with_squad_and_traps_and_traps(x) and is_safe_with_squad_and_traps_and_traps_and_traps(x) and is_safe_with_squad_and_traps_and_traps_and_traps_and_traps(x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps_and_traps_and_traps_and_traps_and_traps_and_traps(x: int) -> bool:\n        for squad_x in range(m):\n            if is_safe(x, squad_x) and is_safe_with_squad(x) and is_safe_with_squad_and_traps(x) and is_safe_with_squad_and_traps_and_traps(x) and is_safe_with_squad_and_traps_and_traps_and_traps(x) and is_safe_with_squad_and_traps_and_traps_and_traps_and_traps(x) and is_safe_with_squad_and_traps_and_traps_and_traps_and_traps_and_traps(x):\n                return True\n        return False\n\n    def is_safe_with_squad_and_traps_and_traps_and_traps_and_traps_and"
    },
    {
        "number": 2093,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] < a[j]:\n                pairs += 1\n    return str(pairs)"
    },
    {
        "number": 2094,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def move_answer(h: List[int]) -> List[int]:\n        n = len(h)\n        for i in range(n):\n            h[i] = (h[i] + 1) % (k + 1)\n        return h\n\n    def count_points(h: List[int]) -> int:\n        points = 0\n        for i in range(n):\n            if h[i] == h[(i + 1) % n]:\n                points += 1\n        return points\n\n    def count_answer_suits(h: List[int]) -> int:\n        h = move_answer(h)\n        points = count_points(h)\n        return points\n\n    answer_suits = set()\n    for i in range(1, k + 1):\n        h_i = move_answer(h)\n        answer_suits.add(tuple(h_i))\n\n    return str(len(answer_suits))"
    },
    {
        "number": 2095,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = [[int(x) for x in stdin.split()[1:]] for _ in range(n)]\n\n    good_cars = []\n    for i in range(n):\n        for j in range(n):\n            if A[i][j] == 1:\n                if A[i][j] == A[j][i]:\n                    good_cars.append(i)\n                else:\n                    good_cars.append(j)\n\n    return str(len(good_cars)) + \" \" + \" \".join(map(str, good_cars))"
    },
    {
        "number": 2096,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cubes = list(map(int, stdin.split()[1:]))\n\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest!= i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    def heap_sort(arr):\n        n = len(arr)\n\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n\n        for i in range(n - 1, 0, -1):\n            arr[i], arr[0] = arr[0], arr[i]\n            heapify(arr, i, 0)\n\n    def count_distinct_numbers(arr):\n        distinct_numbers = set()\n        for num in arr:\n            distinct_numbers.add(num)\n        return len(distinct_numbers)\n\n    def split_cubes(cubes):\n        first_heap = []\n        second_heap = []\n\n        for cube in cubes:\n            if cube < 100:\n                first_heap.append(cube)\n            else:\n                second_heap.append(cube)\n\n        heap_sort(first_heap)\n        heap_sort(second_heap)\n\n        return first_heap, second_heap\n\n    first_heap, second_heap = split_cubes(cubes)\n\n    max_distinct_numbers = count_distinct_numbers(first_heap)\n\n    if max_distinct_numbers < 2:\n        max_distinct_numbers = 2\n\n    b = [0] * max_distinct_numbers\n    b[0] = 1\n\n    for i in range(1, max_distinct_numbers):\n        b[i] = 2\n\n    return str(max_distinct_numbers) + \" \" + \" \".join(map(str, b))\n"
    },
    {
        "number": 2097,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        steps = 0\n        while a[0] + a[1] + a[2] + a[3]!= 0 and a[0] * a[1] * a[2] * a[3]!= 0:\n            steps += 1\n            for i in range(4):\n                a[i] += 1\n        print(steps)"
    },
    {
        "number": 2098,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.split()[1:3])\n        edges.append((a, b))\n    edges.sort()\n    for i in range(n - 1):\n        if edges[i][0] > edges[i][1]:\n            edges[i] = (edges[i][1], edges[i][0])\n    for i in range(n - 1):\n        print(edges[i][0], edges[i][1])\n    return \"YES\" if len(set(edges)) == n - 1 else \"NO\""
    },
    {
        "number": 2099,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M, T = map(int, stdin.split())\n    times = [tuple(map(int, line.split(\":\"))) for line in stdin.split(\"\\n\")[1:]]\n    times.sort()\n\n    online_users = set()\n    online_users_count = 0\n    distinct_users = set()\n    distinct_users_count = 0\n\n    for time in times:\n        if time[0] < 0 or time[0] > 23 or time[1] < 0 or time[1] > 59 or time[2] < 0 or time[2] > 59:\n            return \"No solution\"\n\n        if time[0] == 0 and time[1] == 0 and time[2] == 0:\n            online_users_count = 0\n            distinct_users_count = 0\n            online_users = set()\n            distinct_users = set()\n        else:\n            if time[0] == 23 and time[1] == 59 and time[2] == 59:\n                online_users_count = 0\n                distinct_users_count = 0\n                online_users = set()\n                distinct_users = set()\n            else:\n                if time[0] == 0:\n                    online_users_count = 0\n                    distinct_users_count = 0\n                    online_users = set()\n                    distinct_users = set()\n                else:\n                    if time[0] == 23:\n                        online_users_count = 0\n                        distinct_users_count = 0\n                        online_users = set()\n                        distinct_users = set()\n                    else:\n                        if time[1] == 0:\n                            online_users_count = 0\n                            distinct_users_count = 0\n                            online_users = set()\n                            distinct_users = set()\n                        else:\n                            if time[1] == 59:\n                                online_users_count = 0\n                                distinct_users_count = 0\n                                online_users = set()\n                                distinct_users = set()\n                            else:\n                                if time[2] == 0:\n                                    online_users_count = 0\n                                    distinct_users_count = 0\n                                    online_users = set()\n                                    distinct_users = set()\n                                else:\n                                    if time[2] == 59:\n                                        online_users_count = 0\n                                        distinct_users_count = 0\n                                        online_users = set()\n                                        distinct_users = set()\n                                    else:\n                                        if time[0] == time[1] == time[2]:\n                                            online_users_count = 0\n                                            distinct_users_count = 0\n                                            online_users = set()\n                                            distinct_users = set()\n                                        else:\n                                            if time[0] == time[1]:\n                                                online_users_count = 0\n                                                distinct_users_count = 0\n                                                online_users = set()\n                                                distinct_users = set()\n                                            else:\n                                                if time[0] == time[2]:\n                                                    online_users_count = 0\n                                                    distinct_users_count = 0\n                                                    online_users = set()\n                                                    distinct_users = set()\n                                                else:\n                                                    if time[1] == time[2]:\n                                                        online_users_count = 0\n                                                        distinct_users_count = 0\n                                                        online_users = set()\n                                                        distinct_users = set()\n                                                    else:\n                                                        if time[0] < time[1] < time[2]:\n                                                            online_users_count = 0\n                                                            distinct_users_count = 0\n                                                            online_users = set()\n                                                            distinct_users = set()\n                                                        else:\n                                                            if time[0] > time[1] > time[2]:\n                                                                online_users_count = 0\n                                                                distinct_users_count = 0\n                                                                online_users = set()\n                                                                distinct_users = set()\n                                                            else:\n                                                                if time[0] < time[2]:\n                                                                    online_users_count = 0\n                                                                    distinct_users_count = 0\n                                                                    online_users = set()\n                                                                    distinct_users = set()\n                                                                else:\n                                                                    if time[0] > time[2]:\n                                                                        online_users_count = 0\n                                                                        distinct_users_count = 0\n                                                                        online_users = set()\n                                                                        distinct_users = set()\n                                                                    else:\n                                                                        if time[1] < time[2]:\n                                                                            online_users_count = 0\n                                                                            distinct_users_count = 0\n                                                                            online_users = set()\n                                                                            distinct_users = set()\n                                                                        else:\n                                                                            if time[1] > time[2]:\n                                                                                online_users_count = 0\n                                                                                distinct_users_count = 0\n                                                                                online_users = set()\n                                                                                distinct_users = set()\n                                                                            else:\n                                                                                if time[0] <"
    },
    {
        "number": 2100,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    doors = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    left_doors = [doors[i][0] for i in range(n)]\n    right_doors = [doors[i][1] for i in range(n)]\n    left_open = all(left_doors)\n    right_open = all(right_doors)\n    if left_open == right_open:\n        return '0'\n    if left_open:\n        return str(min(left_doors.index(1) + 1, n))\n    return str(min(right_doors.index(1) + 1, n))"
    },
    {
        "number": 2101,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B = map(int, stdin.split())\n    r_list = list(map(int, stdin.split()[1:R+1]))\n    g_list = list(map(int, stdin.split()[R+1:2*R+1]))\n    b_list = list(map(int, stdin.split()[2*R+1:]))\n\n    red_area = 0\n    green_area = 0\n    blue_area = 0\n\n    for i in range(R):\n        red_area += r_list[i] * r_list[i]\n        green_area += g_list[i] * g_list[i]\n        blue_area += b_list[i] * b_list[i]\n\n    for i in range(R):\n        for j in range(i+1, R):\n            red_area += r_list[i] * r_list[j]\n            green_area += g_list[i] * g_list[j]\n            blue_area += b_list[i] * b_list[j]\n\n    for i in range(G):\n        red_area += r_list[i] * g_list[i]\n        green_area += g_list[i] * g_list[i]\n        blue_area += b_list[i] * b_list[i]\n\n    for i in range(G):\n        for j in range(i+1, G):\n            red_area += r_list[i] * g_list[j]\n            green_area += g_list[i] * g_list[j]\n            blue_area += b_list[i] * b_list[j]\n\n    for i in range(B):\n        red_area += r_list[i] * b_list[i]\n        green_area += g_list[i] * b_list[i]\n        blue_area += b_list[i] * b_list[i]\n\n    for i in range(B):\n        for j in range(i+1, B):\n            red_area += r_list[i] * b_list[j]\n            green_area += g_list[i] * b_list[j]\n            blue_area += b_list[i] * b_list[j]\n\n    return str(max(red_area, green_area, blue_area))"
    },
    {
        "number": 2102,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    n = int(stdin.split()[2])\n    b = list(map(int, stdin.split()[3:]))\n\n    min_diff = float('inf')\n    for i in range(n):\n        for j in range(6):\n            if b[i] > a[j]:\n                min_diff = min(min_diff, a[j] - b[i])\n\n    return str(min_diff)"
    },
    {
        "number": 2103,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    b = []\n    for i in range(n):\n        b.append(MEX(set(b)))\n\n    return \" \".join(map(str, b))\n\ndef"
    },
    {
        "number": 2104,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    if l > r:\n        l, r = r, l\n\n    if (r - l + 1) % 2 == 0:\n        return \"NO\"\n\n    pairs = []\n    for i in range(l, r + 1, 2):\n        for j in range(i + 2, r + 1, 2):\n            gcd = gcd(i, j)\n            if gcd == 1:\n                pairs.append((i, j))\n\n    if not pairs:\n        return \"NO\"\n\n    for pair in pairs:\n        print(pair[0], pair[1])\n\n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 2105,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[n + 1:n + m + 1]\n    t = stdin.split()[n + m + 2:]\n    q = int(stdin.split()[n + m + 3])\n\n    year_names = []\n    for _ in range(q):\n        year = int(stdin.split()[n + m + 4])\n        year_names.append(get_year_name(year, s, t))\n\n    return \"\\n\".join(year_names)\n\n\ndef"
    },
    {
        "number": 2106,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    s = list(map(int, stdin.split()))\n\n    def min_time(city, fuel, time):\n        if city == n:\n            return time\n        if fuel == 0:\n            return float('inf')\n        min_time = float('inf')\n        for i in range(city + 1, n):\n            min_time = min(min_time, min_time(i, fuel - s[i - 1], time + d[i - 1]))\n        return min_time\n\n    n = len(d)\n    fuel = s[0]\n    time = 0\n    min_time = min_time(1, fuel, time)\n\n    for i in range(1, m):\n        fuel += s[i]\n        time += d[i - 1]\n        min_time = min(min_time, min_time(i + 1, fuel, time))\n        fuel -= s[i - 1]\n        time -= d[i - 1]\n\n    return str(min_time)"
    },
    {
        "number": 2107,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n    q = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def max_complexity(song):\n        max_c = 0\n        for i in range(len(song) - 1):\n            for j in range(i + 1, len(song)):\n                max_c = max(max_c, abs(song[i][0] - song[j][0]) + abs(song[i][1] - song[j][1]))\n        return max_c\n\n    def play_song(song):\n        max_c = 0\n        for i in range(len(song) - 1):\n            for j in range(i + 1, len(song)):\n                max_c = max(max_c, abs(song[i][0] - song[j][0]) + abs(song[i][1] - song[j][1]))\n        return max_c\n\n    def play_song_with_magic(song):\n        max_c = 0\n        for i in range(len(song) - 1):\n            for j in range(i + 1, len(song)):\n                max_c = max(max_c, abs(song[i][0] - song[j][0]) + abs(song[i][1] - song[j][1]))\n        return max_c\n\n    def play_song_with_magic_and_duplicates(song):\n        max_c = 0\n        for i in range(len(song) - 1):\n            for j in range(i + 1, len(song)):\n                max_c = max(max_c, abs(song[i][0] - song[j][0]) + abs(song[i][1] - song[j][1]))\n        return max_c\n\n    def play_song_with_magic_and_duplicates_and_repetitions(song):\n        max_c = 0\n        for i in range(len(song) - 1):\n            for j in range(i + 1, len(song)):\n                max_c = max(max_c, abs(song[i][0] - song[j][0]) + abs(song[i][1] - song[j][1]))\n        return max_c\n\n    def play_song_with_magic_and_duplicates_and_repetitions_and_repetitions(song):\n        max_c = 0\n        for i in range(len(song) - 1):\n            for j in range(i + 1, len(song)):\n                max_c = max(max_c, abs(song[i][0] - song[j][0]) + abs(song[i][1] - song[j][1]))\n        return max_c\n\n    song = [(a[i][j], j) for i in range(n) for j in range(m) if a[i][j] in q]\n    max_c = max(max_complexity(song), play_song(song), play_song_with_magic(song), play_song_with_magic_and_duplicates(song), play_song_with_magic_and_duplicates_and_repetitions(song), play_song_with_magic_and_duplicates_and_repetitions_and_repetitions(song))\n    return str(max_c)"
    },
    {
        "number": 2108,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    n_1, n_2, n_3 = map(int, stdin.split())\n\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(u, col):\n        nonlocal n_1, n_2, n_3\n        if col == 1:\n            n_1 -= 1\n        elif col == 2:\n            n_2 -= 1\n        elif col == 3:\n            n_3 -= 1\n        for v in graph[u]:\n            if v == col:\n                continue\n            if col == 1:\n                if dfs(v, 2):\n                    return True\n            elif col == 2:\n                if dfs(v, 3):\n                    return True\n            elif col == 3:\n                if dfs(v, 1):\n                    return True\n        return False\n\n    col = 1\n    while n_1 > 0 or n_2 > 0 or n_3 > 0:\n        if dfs(1, col):\n            return \"YES\"\n        col = (col + 1) % 3\n\n    return \"NO\"\n"
    },
    {
        "number": 2109,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_valid(arr):\n        product_set_1 = product_set_2 = product_set_3 = 1\n        for num in arr:\n            product_set_1 *= num\n            product_set_2 *= -num\n            product_set_3 *= 0\n\n        return product_set_1 < 0 and product_set_2 > 0 and product_set_3 == 0\n\n    def divide_array(arr):\n        if not is_valid(arr):\n            return None\n\n        arr.sort()\n        n_1 = 0\n        n_2 = 0\n        n_3 = 0\n        i = 0\n        while i < len(arr):\n            if arr[i] < 0:\n                n_1 += 1\n                i += 1\n            elif arr[i] > 0:\n                n_2 += 1\n                i += 1\n            else:\n                n_3 += 1\n                i += 1\n\n        return n_1, n_2, n_3\n\n    n_1, n_2, n_3 = divide_array(arr)\n    if n_1 == 0 and n_2 == 0 and n_3 == 0:\n        return \"1 0 0\"\n\n    if n_1 == 0:\n        return f\"{n_2} {n_3} {n_2 + n_3}\"\n\n    if n_2 == 0:\n        return f\"{n_1} {n_3} {n_1 + n_3}\"\n\n    if n_3 == 0:\n        return f\"{n_1} {n_2} {n_1 + n_2}\"\n\n    return f\"{n_1} {n_2} {n_3}\"\n"
    },
    {
        "number": 2110,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m, k = map(int, stdin.split())\n    trams = []\n    for i in range(n):\n        h_i, m_i = map(int, stdin.split())\n        trams.append((h_i, m_i))\n\n    trams.sort(key=lambda x: (x[0], x[1]))\n\n    canceled_trains = 0\n    start_time = 0\n    end_time = 0\n\n    for h_i, m_i in trams:\n        if end_time < h_i * 60 + m_i:\n            canceled_trains += 1\n            end_time = h_i * 60 + m_i\n        else:\n            start_time = h_i * 60 + m_i\n            end_time = h_i * 60 + m_i + k\n\n    return f\"{canceled_trains} {start_time}\""
    },
    {
        "number": 2111,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    actions = []\n    for _ in range(q):\n        x, y, direction = map(int, stdin.split())\n        actions.append((x, y, direction))\n\n    eaten_pieces = [0] * n\n    for x, y, direction in actions:\n        if direction == 'L':\n            for i in range(x, y):\n                eaten_pieces[i] += 1\n        elif direction == 'U':\n            for i in range(y, x, -1):\n                eaten_pieces[i] += 1\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    return \"\\n\".join(map(str, eaten_pieces))"
    },
    {
        "number": 2112,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    x, k, y = map(int, stdin.split())\n\n    def berserk(a, k):\n        for i in range(k):\n            a.remove(max(a))\n        return a\n\n    def fireball(a, k):\n        for i in range(k):\n            a.remove(min(a))\n        return a\n\n    def turn(a, b):\n        for i in range(len(a)):\n            a[i] = b[i]\n        return a\n\n    a = berserk(a, k)\n    b = fireball(a, k)\n    if b == a:\n        return 0\n\n    a = turn(a, b)\n    b = turn(b, a)\n\n    return min(x + sum(a), y + sum(b))"
    },
    {
        "number": 2113,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:3])\n        edges.append((u - 1, v - 1))\n    edges.sort()\n    max_edges = 0\n    for i in range(len(edges)):\n        for j in range(i + 1, len(edges)):\n            if edges[i][0]!= edges[j][0] and edges[i][1]!= edges[j][1]:\n                max_edges += 1\n                break\n    return str(max_edges)"
    },
    {
        "number": 2114,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"-1\"\n\n    board = [[0] * n for _ in range(n)]\n    visited = set()\n    visited.add(1)\n    rook_vuns = 0\n    queen_vuns = 0\n\n    def dfs(row, col, vuns):\n        nonlocal board, visited, rook_vuns, queen_vuns\n        if row == n or col == n:\n            return\n\n        if (row, col) in visited:\n            return\n\n        visited.add((row, col))\n\n        if board[row][col] == 0:\n            if row == 0:\n                board[row][col] = 1\n                rook_vuns += 1\n            elif col == 0:\n                board[row][col] = 1\n                queen_vuns += 1\n            elif row == n - 1:\n                board[row][col] = 1\n                rook_vuns += 1\n            elif col == n - 1:\n                board[row][col] = 1\n                queen_vuns += 1\n            else:\n                board[row][col] = 1\n                dfs(row + 1, col, vuns)\n                dfs(row - 1, col, vuns)\n                dfs(row, col + 1, vuns)\n                dfs(row, col - 1, vuns)\n                board[row][col] = 0\n\n        visited.remove((row, col))\n\n    dfs(0, 0, 0)\n\n    if rook_vuns <= queen_vuns:\n        return \" \".join(map(str, board[0]))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 2115,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    while True:\n        equal_consecutive = False\n        for i in range(len(sequence) - 1):\n            if sequence[i] == sequence[i + 1]:\n                equal_consecutive = True\n                break\n        if not equal_consecutive:\n            break\n\n        leftmost_index = min(i for i in range(len(sequence)) if sequence[i] == sequence[i - 1])\n        rightmost_index = max(i for i in range(len(sequence)) if sequence[i] == sequence[i + 1])\n\n        if sequence[leftmost_index] == sequence[rightmost_index]:\n            sequence[leftmost_index] += 1\n            sequence[rightmost_index] = sequence[leftmost_index] + 1\n        else:\n            sequence[leftmost_index], sequence[rightmost_index] = sequence[rightmost_index], sequence[leftmost_index]\n\n        sequence.pop(leftmost_index + 1)\n        sequence.pop(rightmost_index)\n\n    k = len(sequence)\n    return f\"{k}\\n{' '.join(str(x) for x in sequence)}\""
    },
    {
        "number": 2116,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def pos(x):\n        return p.index(x)\n\n    total_time = 0\n    for i in range(n):\n        for j in range(m):\n            pos_x = pos(a[i][j])\n            p.pop(pos_x)\n            total_time += pos_x + 1\n\n    return str(total_time)"
    },
    {
        "number": 2117,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tunnels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    planets = list(range(1, n+1))\n\n    def shortest_path(start, end):\n        visited = set()\n        queue = [(start, [start])]\n        while queue:\n            planet, path = queue.pop(0)\n            if planet == end:\n                return path\n            if planet in visited:\n                continue\n            visited.add(planet)\n            for neighbor in planets:\n                if neighbor!= planet and (neighbor, planet) not in tunnels and (planet, neighbor) not in tunnels:\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n        return None\n\n    def max_controlled_planets(ships):\n        max_planets = 0\n        for planet in planets:\n            if planet in shortest_path(1, planet):\n                max_planets += 1\n        return max_planets\n\n    return''.join(map(str, max_controlled_planets(int(stdin.split()[1]))))"
    },
    {
        "number": 2118,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(range(1, n + 1))\n    mergesort(a, 0, n)\n    if k == 1:\n        return \" \".join(map(str, a))\n    for i in range(1, k):\n        if mergesort(a, 0, n) == k:\n            return \" \".join(map(str, a))\n    return -1\n\ndef"
    },
    {
        "number": 2119,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, l, r = map(int, stdin.split())\n    def is_beautiful(s: str) -> bool:\n        return not s.startswith('0') and l <= int(s) <= r\n    count = 0\n    for i in range(1, a+1):\n        for j in range(i):\n            if is_beautiful(str(i) + str(j)):\n                count += 1\n    return str(count % 998244353)"
    },
    {
        "number": 2120,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    parts = list(map(int, stdin.split()))\n    ropes = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        ropes.append((x - 1, y - 1))\n\n    def dfs(part, used_parts, energy):\n        if part == n:\n            return energy\n\n        min_energy = float('inf')\n        for i in range(n):\n            if i not in used_parts and i!= part:\n                min_energy = min(min_energy, dfs(i, used_parts | {i}, energy + parts[i]))\n\n        return min_energy\n\n    return str(dfs(0, set(), 0))\n"
    },
    {
        "number": 2121,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    adj = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        adj[u].append(v)\n        adj[v].append(u)\n\n    def dfs(node, visited):\n        visited.add(node)\n        if len(visited) == k:\n            return min(a[u] for u in visited)\n        return min(dfs(u, visited) for u in adj[node] if u not in visited)\n\n    return str(dfs(1, set()))"
    },
    {
        "number": 2122,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    books = list(map(int, stdin.split()))\n\n    def count_books(books, k):\n        count = 0\n        for book in books:\n            if book <= k:\n                count += 1\n        return count\n\n    def count_requests(books, k):\n        count = 0\n        for i in range(len(books)):\n            for j in range(i + 1, len(books)):\n                if books[i] + books[j] <= k:\n                    count += 1\n        return count\n\n    count_books_easy = count_books(books, k)\n    count_requests_easy = count_requests(books, k)\n\n    count_books_hard = count_books(books, 1000000)\n    count_requests_hard = count_requests(books, 1000000)\n\n    return str(min(count_books_easy, count_requests_easy, count_books_hard, count_requests_hard))"
    },
    {
        "number": 2123,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    h = list(map(int, stdin.split()[1:]))\n\n    min_money = float('inf')\n    for i in range(n):\n        if i == 0:\n            min_money = min(min_money, h[0])\n        else:\n            min_money = min(min_money, h[i] - h[i - 1] + 1)\n\n    return str(min_money)"
    },
    {
        "number": 2124,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    chats = stdin.split('\\n\\n')\n    for chat in chats:\n        n, m = map(int, chat.split('\\n')[0].split())\n        users = set(chat.split('\\n')[1].split())\n        messages = []\n        for i in range(m):\n            message = chat.split('\\n')[i+2].split(':')\n            if len(message) == 2:\n                messages.append(message)\n        if len(messages) < 2:\n            print(\"Impossible\")\n        else:\n            for i in range(len(messages)):\n                if i == len(messages) - 1:\n                    messages[i] = (messages[i][0], messages[i][1].replace('?', ''))\n                else:\n                    messages[i] = (messages[i][0], messages[i][1].replace('?', ''))\n            for i in range(len(messages) - 1):\n                if messages[i][0] == messages[i+1][0]:\n                    print(messages[i+1])\n                    break\n            else:\n                print(messages[-1])"
    },
    {
        "number": 2125,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    rows = [list(row) for row in stdin.split('\\n')[1:]]\n    flags = set()\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0 or i == n - 1 or j == m - 1:\n                if rows[i][j] == rows[i][j + 1] == rows[i + 1][j] == rows[i + 1][j + 1]:\n                    flags.add(tuple(rows[i][j:j + 3]))\n\n    return str(len(flags))"
    },
    {
        "number": 2126,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    t = []\n    for _ in range(n):\n        t.append(list(map(int, stdin.split())))\n\n    def restore(i, j, t):\n        if i == 0:\n            return t[i][j]\n        if j == 0:\n            return restore(i - 1, j, t)\n        return max(restore(i - 1, j, t), restore(i, j - 1, t))\n\n    def dfs(i, j, t):\n        if i == 0:\n            return t[i][j]\n        if j == 0:\n            return dfs(i - 1, j, t)\n        return max(dfs(i - 1, j, t), dfs(i, j - 1, t))\n\n    def find_max(t):\n        max_height = 0\n        for row in t:\n            for height in row:\n                max_height = max(max_height, height)\n        return max_height\n\n    def find_min(t):\n        min_height = h\n        for row in t:\n            for height in row:\n                min_height = min(min_height, height)\n        return min_height\n\n    def find_top(t):\n        top = []\n        for row in t:\n            for height in row:\n                top.append(height)\n        return top\n\n    def find_bottom(t):\n        bottom = []\n        for row in t:\n            for height in row:\n                bottom.append(h - height)\n        return bottom\n\n    def find_left(t):\n        left = []\n        for i in range(n):\n            left.append(max(t[i][j] for j in range(m)))\n        return left\n\n    def find_right(t):\n        right = []\n        for i in range(n):\n            right.append(max(t[i][j] for j in range(m)))\n        return right\n\n    def find_front(t):\n        front = []\n        for j in range(m):\n            front.append(max(t[i][j] for i in range(n)))\n        return front\n\n    def find_back(t):\n        back = []\n        for j in range(m):\n            back.append(max(t[i][j] for i in range(n)))\n        return back\n\n    def find_top_view(t):\n        top_view = []\n        for i in range(n):\n            for j in range(m):\n                top_view.append(t[i][j])\n        return top_view\n\n    def find_bottom_view(t):\n        bottom_view = []\n        for i in range(n):\n            for j in range(m):\n                bottom_view.append(h - t[i][j])\n        return bottom_view\n\n    def find_left_view(t):\n        left_view = []\n        for i in range(n):\n            for j in range(m):\n                left_view.append(t[i][j])\n        return left_view\n\n    def find_right_view(t):\n        right_view = []\n        for i in range(n):\n            for j in range(m):\n                right_view.append(t[i][j])\n        return right_view\n\n    def find_front_view(t):\n        front_view = []\n        for j in range(m):\n            front_view.append(max(t[i][j] for i in range(n)))\n        return front_view\n\n    def find_back_view(t):\n        back_view = []\n        for j in range(m):\n            back_view.append(max(t[i][j] for i in range(n)))\n        return back_view\n\n    def find_all_views(t):\n        all_views = []\n        for i in range(n):\n            for j in range(m):\n                all_views.append(t[i][j])\n        return all_views\n\n    max_height = find_max(t)\n    min_height = find_min(t)\n    top = find_top(t)\n    bottom = find_bottom(t)\n    left = find_left(t)\n    right = find_right(t)\n    front = find_front(t)\n    back = find_back(t)\n    top_view = find_top_view(t)\n    bottom_view = find_bottom_view(t)\n    left_view = find_left_view(t)\n    right_view = find_right_view(t)\n   "
    },
    {
        "number": 2127,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [line.strip().split() for line in stdin.split('\\n')[1:]]\n    result = []\n\n    for query in queries:\n        if query[0] == '+':\n            x, y = map(int, query[1:])\n            result.append('YES' if (x <= 10**9 and y <= 10**9) or (y <= 10**9 and x <= 10**9) else 'NO')\n        else:\n            h, w = map(int, query[1:])\n            result.append('YES' if all(x <= h and y <= w or y <= h and x <= w for x, y in zip(x_bills, y_bills)) else 'NO')\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2128,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p = [p[i-1] for i in range(1, n+1)]\n    p"
    },
    {
        "number": 2129,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, start, end, count):\n        if start == end:\n            return count\n        if (start, end) in visited or (end, start) in visited:\n            return count\n        visited.add((start, end))\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                count = dfs(graph, visited, neighbor, end, count)\n        return count\n\n    def orient_roads(graph, visited, start, end):\n        if start == end:\n            return\n        if (start, end) in visited or (end, start) in visited:\n            return\n        visited.add((start, end))\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                orient_roads(graph, visited, neighbor, end)\n        print(start, end)\n\n    def max_cities(graph):\n        visited = set()\n        max_count = 0\n        for city in range(1, len(graph) + 1):\n            count = dfs(graph, visited, city, city, 0)\n            if count > max_count:\n                max_count = count\n        return max_count\n\n    def orient_graph(graph):\n        for city in range(1, len(graph) + 1):\n            for neighbor in graph[city]:\n                graph[city].remove(neighbor)\n                graph[neighbor].remove(city)\n                graph[city].append(neighbor)\n                graph[neighbor].append(city)\n\n    def read_graph(stdin: str) -> list:\n        n, m = map(int, stdin.split())\n        graph = [[] for _ in range(n + 1)]\n        for _ in range(m):\n            u, v = map(int, stdin.split())\n            graph[u].append(v)\n            graph[v].append(u)\n        return graph\n\n    def main():\n        t = int(stdin.split()[0])\n        for _ in range(t):\n            graph = read_graph(stdin)\n            orient_graph(graph)\n            max_cities_count = max_cities(graph)\n            print(max_cities_count)\n            for city in range(1, len(graph) + 1):\n                for neighbor in graph[city]:\n                    if neighbor!= city:\n                        orient_roads(graph, set(), city, neighbor)\n\n    main()\n    return \"\"\n"
    },
    {
        "number": 2130,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    b = list(map(int, stdin.split()[1:]))\n\n    b_1 = b[0]\n    b_n = b[n - 1]\n\n    for i in range(2, n):\n        b_i = b[i] ^ b[i - 1]\n        if b_i < b_1:\n            return \"No\"\n\n    if b_n < b_1:\n        return \"No\"\n\n    for i in range(n - 1):\n        if b[i] > b[i + 1]:\n            return \"No\"\n\n    return \"Yes\"\n"
    },
    {
        "number": 2131,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, visited, path):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path + [neighbor])\n\n    paths = []\n    for node in range(1, n + 1):\n        visited = set()\n        dfs(node, visited, [])\n        paths.append(path)\n\n    if not paths:\n        return \"No\"\n\n    paths.sort(key=lambda x: len(x))\n    m = len(paths)\n    for i in range(m):\n        print(i + 1)\n        for j in range(len(paths[i])):\n            print(paths[i][j], end=' ')\n        print()\n\n    return \"Yes\""
    },
    {
        "number": 2132,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    events = []\n    for i in range(n):\n        t, s = map(int, stdin.split()[1:])\n        events.append((t, s))\n    events.sort()\n    speed_limit = 0\n    overtake_allowed = 0\n    no_speed_limit = 0\n    no_overtake_allowed = 0\n    for t, s in events:\n        if t == 1:\n            speed_limit = s\n        elif t == 3:\n            overtake_allowed = s\n        elif t == 4:\n            no_speed_limit = s\n        elif t == 5:\n            no_overtake_allowed = s\n        elif t == 6:\n            speed_limit = 0\n            overtake_allowed = 0\n            no_speed_limit = 0\n            no_overtake_allowed = 0\n    return str(min(speed_limit, overtake_allowed, no_speed_limit, no_overtake_allowed))"
    },
    {
        "number": 2133,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = list(map(int, stdin.split()[1:]))\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[i + 2].split())\n        edges.append((u - 1, v - 1))\n\n    def dfs(u, color):\n        nonlocal colors\n        colors[u] = color\n        for v, w in edges:\n            if colors[v] == -1:\n                dfs(v, -color)\n\n    for i in range(n):\n        if colors[i] == -1:\n            dfs(i, 1)\n\n    black_count = 0\n    white_count = 0\n    for color in colors:\n        if color == 0:\n            black_count += 1\n        else:\n            white_count += 1\n\n    return str(min(black_count, white_count))\n"
    },
    {
        "number": 2134,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    def is_better(x: int, y: int) -> bool:\n        for i in range(60):\n            if (a[x] >> i) & 1 == 1 and (a[y] >> i) & 1 == 0:\n                return True\n        return False\n\n    def max_sum(students: list[int]) -> int:\n        max_sum = 0\n        for i in range(len(students)):\n            for j in range(i + 1, len(students)):\n                if is_better(students[i], students[j]):\n                    max_sum = max(max_sum, b[students[i]] + b[students[j]])\n        return max_sum\n\n    def find_group(students: list[int]) -> list[int]:\n        group = []\n        for student in students:\n            if not group or is_better(group[-1], student):\n                group.append(student)\n            else:\n                break\n        return group\n\n    def is_calm(students: list[int]) -> bool:\n        for i in range(len(students)):\n            for j in range(i + 1, len(students)):\n                if is_better(students[i], students[j]):\n                    return False\n        return True\n\n    def max_calm_sum(students: list[int]) -> int:\n        max_sum = 0\n        for i in range(len(students)):\n            for j in range(i + 1, len(students)):\n                if is_better(students[i], students[j]) and is_calm([students[i], students[j]]):\n                    max_sum = max(max_sum, b[students[i]] + b[students[j]])\n        return max_sum\n\n    groups = []\n    for i in range(n):\n        group = find_group([i])\n        if len(group) >= 2:\n            groups.append(group)\n\n    max_sum = 0\n    for group in groups:\n        max_sum = max(max_sum, max_calm_sum(group))\n\n    return str(max_sum)"
    },
    {
        "number": 2135,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n    q = int(stdin.split()[2])\n    queries = [list(map(int, line.split())) for line in stdin.split()[3:]]\n\n    def count_ways(r1, c1, r2, c2):\n        def is_valid(r, c):\n            return 1 <= r <= h and 1 <= c <= w and grid[r - 1][c - 1] == '.'\n\n        def is_adjacent(r, c):\n            return (r - 1, c) in directions or (r, c - 1) in directions\n\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        count = 0\n\n        for i in range(r1, r2 + 1):\n            for j in range(c1, c2 + 1):\n                if is_valid(i, j) and is_adjacent(i, j):\n                    count += 1\n\n        return count\n\n    result = [count_ways(*query) for query in queries]\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2136,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        grid = [list(map(int, line.split(''))) for line in stdin.split('\\n')[2:2+n]]\n        visited = set()\n        for i in range(1, n-1):\n            for j in range(1, n-1):\n                if grid[i][j] == 0:\n                    continue\n                if (i, j) in visited:\n                    continue\n                visited.add((i, j))\n                if grid[i][j] == grid[i-1][j]:\n                    grid[i][j] = 1\n                elif grid[i][j] == grid[i][j-1]:\n                    grid[i][j] = 0\n                else:\n                    grid[i][j] = 1 - grid[i][j]\n        c = 0\n        for i in range(1, n-1):\n            for j in range(1, n-1):\n                if grid[i][j] == 1:\n                    c += 1\n                    print(i, j)\n        print(c)"
    },
    {
        "number": 2137,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    ghosts = []\n    for i in range(n):\n        x, V_x, V_y = map(int, stdin.split())\n        ghosts.append((x, V_x, V_y))\n\n    T = 10**9\n    GX = 0\n    for t in range(T):\n        for i in range(n):\n            for j in range(i+1, n):\n                if ghosts[i][0] == ghosts[j][0] and ghosts[i][1] == ghosts[j][1]:\n                    GX += 1\n\n    return str(GX)"
    },
    {
        "number": 2138,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    degree_set = sorted(set(map(int, stdin.split())))\n    degree_sequence = [degree_set.count(d) for d in degree_set]\n\n    def is_valid(degree_sequence: List[int]) -> bool:\n        degree_set = set(degree_sequence)\n        if len(degree_set)!= len(degree_set.union(set(range(1, n + 1)))):\n            return False\n        for i in range(len(degree_sequence) - 1):\n            if degree_sequence[i] > degree_sequence[i + 1]:\n                return False\n        return True\n\n    if not is_valid(degree_sequence):\n        return \"Invalid\"\n\n    def construct_graph(degree_sequence: List[int]) -> str:\n        graph = []\n        for i in range(len(degree_sequence)):\n            for j in range(degree_sequence[i]):\n                graph.append((i + 1, j + 1))\n        return graph\n\n    graph = construct_graph(degree_sequence)\n    m = len(graph)\n    result = []\n    for edge in graph:\n        result.append(f\"{edge[0]} {edge[1]}\")\n    return f\"{m}\\n{' '.join(result)}\""
    },
    {
        "number": 2139,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 3, n + 1):\n            if s[i:j].count(\"bear\") > 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2140,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, m = stdin.split()\n    m = int(m)\n    a = list(map(int, stdin.split()))\n\n    def reverse_segment(start: int, end: int) -> str:\n        return s[start:end][::-1]\n\n    def transform_string(start: int) -> str:\n        if start == 1:\n            return reverse_segment(start, start + 1)\n        elif start == 2:\n            return reverse_segment(start, start + 2)\n        else:\n            return s[start - 2] + reverse_segment(start - 2, start - 1) + s[start - 1]\n\n    result = \"\"\n    for i in range(m):\n        result += transform_string(a[i])\n\n    return result\n"
    },
    {
        "number": 2141,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    board = [['.' for _ in range(n)] for _ in range(n)]\n    white_knight = None\n    black_knight = None\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '.':\n                if white_knight is None:\n                    white_knight = (i, j)\n                else:\n                    black_knight = (i, j)\n                board[i][j] = 'W' if white_knight[0] == i and white_knight[1] == j else 'B'\n\n    for i in range(n):\n        print(''.join(board[i]))\n\n    return ''"
    },
    {
        "number": 2142,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = list(map(int, stdin.split('\\n')[3].split()))\n\n        def is_subsequence(seq, sub):\n            i, j = 0, 0\n            while i < len(seq) and j < len(sub):\n                if seq[i] == sub[j]:\n                    i += 1\n                j += 1\n            return i == len(sub)\n\n        def find_subsequences(arr):\n            subsequences = []\n            for i in range(len(arr)):\n                for j in range(i + 1, len(arr) + 1):\n                    subsequences.append(arr[i:j])\n            return subsequences\n\n        a_subsequences = find_subsequences(a)\n        b_subsequences = find_subsequences(b)\n\n        for subsequence in a_subsequences:\n            if is_subsequence(subsequence, b):\n                print(\"YES\")\n                print(len(subsequence))\n                print(*subsequence)\n                break\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2143,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    count = 0\n    for i in range(n - 1):\n        if a[i] + a[i + 1]!= a[i + 2] + a[i + 3]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2144,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        a, m = map(int, stdin.split()[1:])\n        count = 0\n        for x in range(m):\n            if gcd(a, m) == gcd(a + x, m):\n                count += 1\n        print(count)\n\ndef"
    },
    {
        "number": 2145,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for i in range(T):\n        x, y = map(int, stdin.split('\\n')[i+1].split())\n        if x == y:\n            print('YES')\n        elif x % 2 == 0 and x > 1:\n            print('YES')\n        elif x > 1:\n            print('NO')\n        else:\n            print('YES')"
    },
    {
        "number": 2146,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(map(int, a))\n    a.sort()\n    m = [0] * n\n    m[0] = 0\n    for i in range(1, n):\n        if a[i] - a[i - 1] == 1:\n            m[i] = m[i - 1] + 1\n        else:\n            m[i] = 1\n    return \" \".join(map(str, m))\n"
    },
    {
        "number": 2147,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rules = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def apply_rules(rules: list, servers: list) -> list:\n        for rule in rules:\n            a, b, c = rule\n            servers[a - 1], servers[b - 1], servers[c - 1] = servers[b - 1], servers[c - 1], servers[a - 1]\n\n        return servers\n\n    def is_valid(servers: list) -> bool:\n        return all(len(set(servers[:i])) <= 9 for i in range(1, len(servers) + 1))\n\n    def find_valid_order(rules: list) -> list:\n        servers = [i for i in range(1, n + 1)]\n        for _ in range(4 * n):\n            servers = apply_rules(rules, servers)\n\n        return servers\n\n    valid_order = find_valid_order(rules)\n    if not is_valid(valid_order):\n        return \"NO\"\n\n    return \"YES\\n\" + \" \".join(map(str, valid_order))\n"
    },
    {
        "number": 2148,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    y = [10**100] * n\n    for i in range(n):\n        y[i] = 0\n\n    for i in range(n):\n        x_i = x[i]\n        y_i = y[i]\n\n        for j in range(i + 1, n):\n            x_j = x[j]\n            y_j = y[j]\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_j) < 10**-6:\n                continue\n\n            if abs(y_i - y_j) < 10**-6:\n                continue\n\n            if abs(x_i - x_"
    },
    {
        "number": 2149,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def move_answer(h: List[int]) -> List[int]:\n        n = len(h)\n        for i in range(n):\n            h[i] = (h[i] + 1) % k\n        return h\n\n    def count_points(h: List[int]) -> int:\n        n = len(h)\n        points = 0\n        for i in range(n):\n            points += h[i]\n        return points\n\n    def is_valid_suit(h: List[int]) -> bool:\n        n = len(h)\n        points = count_points(h)\n        return points > n\n\n    def count_valid_suits(h: List[int]) -> int:\n        n = len(h)\n        valid_suits = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                h_i = h[:i] + [h[i]] + h[j:]\n                h_j = h[:j] + [h[j]] + h[i:]\n                if is_valid_suit(h_i) and is_valid_suit(h_j):\n                    valid_suits += 1\n        return valid_suits\n\n    def count_answer_suits(h: List[int]) -> int:\n        n = len(h)\n        answer_suits = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                h_i = h[:i] + [h[i]] + h[j:]\n                h_j = h[:j] + [h[j]] + h[i:]\n                if is_valid_suit(h_i) and is_valid_suit(h_j):\n                    answer_suits += 1\n        return answer_suits\n\n    def count_answer_suits_mod_998244353(h: List[int]) -> int:\n        n = len(h)\n        answer_suits = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                h_i = h[:i] + [h[i]] + h[j:]\n                h_j = h[:j] + [h[j]] + h[i:]\n                if is_valid_suit(h_i) and is_valid_suit(h_j):\n                    answer_suits += 1\n        return answer_suits % 998244353\n\n    def main() -> int:\n        h = move_answer(h)\n        return count_answer_suits_mod_998244353(h)\n\n    return str(main())\n"
    },
    {
        "number": 2150,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    b = list(map(int, stdin.split()[1:]))\n\n    a = [0] * n\n    x = [0] * n\n\n    for i in range(1, n):\n        a[i] = max(0, a[i - 1])\n        x[i] = max(0, x[i - 1])\n\n    for i in range(n):\n        a[i] += b[i]\n\n    for i in range(n - 1, -1, -1):\n        x[i] = max(0, x[i])\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 2151,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split('\\n')[0])\n    for _ in range(queries):\n        n = int(stdin.split('\\n')[1])\n        s = stdin.split('\\n')[2]\n        if n < 2:\n            print(\"NO\")\n        else:\n            segments = []\n            for i in range(n):\n                segments.append([])\n            for i in range(n):\n                segments[i].append(int(s[i]))\n            for i in range(n - 1):\n                if segments[i][-1] >= segments[i + 1][0]:\n                    print(\"NO\")\n                    break\n            else:\n                print(\"YES\")\n                k = 1\n                for i in range(n):\n                    if len(segments[i]) > 1:\n                        k += 1\n                print(k)\n                for i in range(n):\n                    if len(segments[i]) > 1:\n                        print(\" \".join(map(str, segments[i])))"
    },
    {
        "number": 2152,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    meat_prices = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    meat_prices.sort(key=lambda x: x[0])\n    total_cost = 0\n    total_meat = 0\n    for meat_price in meat_prices:\n        total_cost += meat_price[1]\n        total_meat += meat_price[0]\n        if total_meat >= n:\n            return total_cost\n    return total_cost"
    },
    {
        "number": 2153,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *h = map(int, stdin.split())\n    h.sort()\n    jumps = 0\n    for i in range(n - 1):\n        if i + 1 == n - 1:\n            break\n        if h[i + 1] < h[i] < h[i + 2]:\n            jumps += 1\n    return str(jumps)"
    },
    {
        "number": 2154,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *prices = map(int, stdin.split())\n    max_profit = 0\n    for i in range(1, n):\n        if prices[i] > prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n    return str(max_profit)"
    },
    {
        "number": 2155,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    for i in range(n):\n        for j in range(m):\n            if a[i*m+j] == 0:\n                x, y = i+1, j+1\n                break\n    else:\n        return -1\n    return f\"{n} {m}\\n{x} {y}\""
    },
    {
        "number": 2156,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        queries.append((l, r))\n\n    def f(s: list) -> int:\n        candies = 0\n        for i in range(len(s) - 1):\n            if s[i] + s[i + 1] >= 10:\n                candies += 1\n        return candies\n\n    def process(s: list) -> list:\n        result = []\n        for i in range(len(s) - 1):\n            if s[i] + s[i + 1] >= 10:\n                result.append((s[i] + s[i + 1]) % 10)\n            else:\n                result.append(s[i])\n                result.append(s[i + 1])\n        return result\n\n    def process_queries(queries: list) -> list:\n        result = []\n        for l, r in queries:\n            s = s[l - 1:r]\n            result.append(f(s))\n        return result\n\n    s = list(map(int, s.split()))\n    result = process_queries(queries)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2157,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        queries.append((l, r))\n\n    a.sort()\n    max_sum = 0\n    for l, r in queries:\n        max_sum = max(max_sum, sum(a[l-1:r]))\n\n    return str(max_sum)"
    },
    {
        "number": 2158,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v, c = map(int, stdin.split()[1:])\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n    visited = [False] * n\n    max_cost = 0\n    def dfs(node):\n        nonlocal max_cost\n        visited[node] = True\n        for neighbor, cost in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        max_cost = max(max_cost, cost)\n    dfs(0)\n    return str(max_cost)"
    },
    {
        "number": 2159,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    t = list(map(int, stdin.split()[1:]))\n\n    intervals = []\n    for i in range(n):\n        intervals.append([i, i])\n\n    for i in range(1, n):\n        for j in range(i):\n            if t[i] == t[j]:\n                intervals[i].append(intervals[j][1])\n                intervals[j][1] = i\n\n    dominant_colors = {}\n    for i in range(n):\n        dominant_colors[t[i]] = dominant_colors.get(t[i], 0) + 1\n\n    result = []\n    for color in dominant_colors:\n        count = 0\n        for interval in intervals:\n            if color in interval:\n                count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 2160,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    def is_valid(a: int, b: int) -> bool:\n        return abs(a - b) <= 1\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid(i, j) and all(x[k]!= j for k in range(k)):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2161,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    phone_book = {}\n\n    for _ in range(n):\n        name, num_phones, *phones = stdin.split()\n        phone_book[name] = [int(p) for p in phones]\n\n    result = []\n    for name, numbers in phone_book.items():\n        phone_numbers = []\n        for number in numbers:\n            if number not in phone_numbers:\n                phone_numbers.append(number)\n        phone_numbers.sort()\n        result.append(f\"{name} {len(phone_numbers)} {' '.join(str(p) for p in phone_numbers)}\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2162,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k1, k2, k3 = map(int, stdin.split())\n    a1 = list(map(int, stdin.split()))\n    a2 = list(map(int, stdin.split()))\n    a3 = list(map(int, stdin.split()))\n\n    def find_prefix(problems: list, prefix_size: int) -> int:\n        for i in range(len(problems)):\n            if prefix_size == 0:\n                return i\n            if prefix_size > 0:\n                prefix_size -= 1\n                if prefix_size == 0:\n                    return i\n                if prefix_size > 0:\n                    return find_prefix(problems, prefix_size)\n        return -1\n\n    def find_suffix(problems: list, suffix_size: int) -> int:\n        for i in range(len(problems) - 1, -1, -1):\n            if suffix_size == 0:\n                return i\n            if suffix_size > 0:\n                suffix_size -= 1\n                if suffix_size == 0:\n                    return i\n                if suffix_size > 0:\n                    return find_suffix(problems, suffix_size)\n        return -1\n\n    def redistribute(problems: list, first_size: int, second_size: int, third_size: int) -> int:\n        first_prefix = find_prefix(problems, first_size)\n        first_suffix = find_suffix(problems, second_size)\n        third_suffix = find_suffix(problems, third_size)\n\n        if first_prefix == -1 or first_suffix == -1 or third_suffix == -1:\n            return -1\n\n        first_problems = problems[:first_prefix] + problems[first_prefix + first_size:]\n        second_problems = problems[first_prefix:first_prefix + first_size] + problems[first_prefix + first_size + second_size:]\n        third_problems = problems[first_prefix + first_size + second_size:]\n\n        return redistribute(first_problems, first_size, second_size, third_size) + 1\n\n    return str(redistribute(a1 + a2 + a3, k1, k2, k3))"
    },
    {
        "number": 2163,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n    S = set()\n    for i in range(1, m+1):\n        S.add(tuple(sorted(list(map(lambda x: x % m + 1, i)))))\n    f = [0] * (m+1)\n    f[0] = 1\n    for i in range(1, m+1):\n        for j in range(1, i+1):\n            f[i] += f[j] * f[i-j]\n            f[i] %= MOD\n    return str(f[m])"
    },
    {
        "number": 2164,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        s = stdin.split()[1]\n        s = s.lower()\n        n = len(s)\n        max_len = 0\n        max_str = \"\"\n        for i in range(n):\n            for j in range(i+1, n+1):\n                t = s[i:j]\n                if t == t[::-1] and t in s and t in s[::-1]:\n                    if len(t) > max_len:\n                        max_len = len(t)\n                        max_str = t\n        print(max_str)"
    },
    {
        "number": 2165,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    def solve(i, x, t):\n        if i == n:\n            return 0\n\n        if x[i] == 0:\n            return solve(i + 1, x, t)\n\n        if x[i] > 0:\n            return max(solve(i + 1, x, t), solve(i + 1, x[:i] + [x[i] - 1] + x[i + 1:], t))\n\n        if x[i] < 0:\n            return max(solve(i + 1, x, t), solve(i + 1, x[:i] + [x[i] + 1] + x[i + 1:], t))\n\n    result = solve(0, a, t)\n    return str(result)"
    },
    {
        "number": 2166,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    permutation = list(map(int, stdin.split()[1:]))\n    permutation = [x if x!= -1 else n for x in permutation]\n    permutation.sort()\n    count = 0\n    for i in range(len(permutation)):\n        if i == 0 or permutation[i]!= permutation[i - 1]:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 2167,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *arr = map(int, stdin.split())\n    max_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] == arr[j]:\n                max_count = max(max_count, 1)\n                arr[i] += 1\n                arr[j] -= 1\n    return str(max_count)"
    },
    {
        "number": 2168,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    companies = []\n    for i in range(n):\n        m = int(stdin.split()[i+1])\n        salaries = list(map(int, stdin.split()[i+2:i+2+m]))\n        companies.append((m, salaries))\n\n    def merge_companies(companies: list) -> int:\n        total_increase = 0\n        for i in range(len(companies)):\n            for j in range(i+1, len(companies)):\n                if sum(companies[i][1]) - sum(companies[j][1]) == 0:\n                    total_increase += max(companies[i][1]) - min(companies[j][1])\n                    companies[i][1] = [max(companies[i][1]), min(companies[i][1])]\n                    companies[j][1] = [max(companies[j][1]), min(companies[j][1])]\n                    break\n        return total_increase\n\n    total_increase = 0\n    for i in range(len(companies)):\n        total_increase += merge_companies(companies[:i] + companies[i+1:])\n\n    return str(total_increase)"
    },
    {
        "number": 2169,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, D = map(int, stdin.split())\n    A = [list(map(int, stdin.split())) for _ in range(H)]\n    Q = int(stdin.split()[1])\n    L = [list(map(int, stdin.split())) for _ in range(Q)]\n    R = [list(map(int, stdin.split())) for _ in range(Q)]\n\n    def teleport(i, j, x, y):\n        if A[x][y] == 0:\n            return False\n        A[x][y] = 0\n        A[i][j] = 0\n        A[x][y] = A[i][j]\n        return True\n\n    def move(i, j, x, y, d):\n        if A[x][y] == 0:\n            return False\n        if A[x][y] == A[i][j]:\n            return False\n        if A[x][y] < A[i][j]:\n            x += d\n        else:\n            y += d\n        return True\n\n    magic_points = 0\n    for i in range(Q):\n        x, y = L[i]\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x // D * D, y // D * D\n        x -= 1\n        y -= 1\n        x, y = x // D * D, y // D * D\n        x += 1\n        y += 1\n        x, y = x"
    },
    {
        "number": 2170,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    MOD = 10**9 + 7\n\n    for i in range(1, m + 1):\n        for j in range(i + 1, m + 1):\n            if i!= j:\n                count += (m - i) * (m - j)\n\n    count %= MOD\n    return str(count)"
    },
    {
        "number": 2171,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"yes\"\n    elif a == 1:\n        return \"yes\"\n    elif a == 2:\n        return \"no\"\n    elif a == 3:\n        return \"yes\"\n    elif a == 6:\n        return \"yes\"\n    elif a == 7:\n        return \"yes\"\n    elif a == 10:\n        return \"no\"\n    else:\n        return \"yes\""
    },
    {
        "number": 2172,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    words = [stdin.split()[i:i+2] for i in range(0, n, 2)]\n    text = stdin.split()[n:]\n\n    for i in range(len(text)):\n        for j in range(len(text[i])):\n            if text[i][j] in words[i]:\n                text[i] = text[i][:j] + text[i][j+1:]\n                break\n\n    return''.join(text)"
    },
    {
        "number": 2173,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i]\n    for i in range(n - 1):\n        if b[i] + 1 == b[i + 1]:\n            b[i] += 1\n    return \" \".join(map(str, b))"
    },
    {
        "number": 2174,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    def backtrack(start, path):\n        if len(path) == n:\n            return 0\n\n        min_moves = float('inf')\n        for i in range(start, n):\n            if i > 0 and a[i] == a[i - 1]:\n                continue\n            if a[i] > 0:\n                a[i] -= 1\n                min_moves = min(min_moves, backtrack(i + 1, path + [a[i]]))\n                a[i] += 1\n\n        return min_moves\n\n    return str(backtrack(0, []))\n"
    },
    {
        "number": 2175,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    queries = []\n    for _ in range(m):\n        query = stdin.split()\n        queries.append(query)\n\n    def pour(i, x):\n        if i == n:\n            return x\n        return pour(i + 1, x + a[i])\n\n    def print_liquid(i):\n        if i == n:\n            return 0\n        return a[i] - pour(i + 1, 0)\n\n    result = []\n    for query in queries:\n        if query[0] == \"1\":\n            i, p, x = map(int, query[1:])\n            result.append(pour(i - 1, x))\n        elif query[0] == \"2\":\n            i, k = map(int, query[1:])\n            result.append(print_liquid(i - 1))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 2176,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = []\n    for i in range(n):\n        a, b = map(int, stdin.split()[i+1].split())\n        s.append((a, b))\n    s.sort()\n    count = 0\n    for i in range(1, n+1):\n        for j in range(i):\n            if s[i-1][0] > s[j][0]:\n                count += 1\n                break\n    return str(count % 998244353)"
    },
    {
        "number": 2177,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        A, B = map(int, stdin.split()[1:])\n        pairs = []\n        for a in range(1, A + 1):\n            for b in range(1, B + 1):\n                conc = str(a) + str(b)\n                if int(conc) == a * b + a + b:\n                    pairs.append((a, b))\n        print(len(pairs))"
    },
    {
        "number": 2178,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    stack = []\n    for i in range(n):\n        if a[i] in stack:\n            stack.remove(a[i])\n            stack.extend(a[i+1:])\n        else:\n            stack.append(a[i])\n    return''.join(map(str, stack))"
    },
    {
        "number": 2179,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        edges.append((u - 1, v - 1, w))\n\n    u = int(stdin.split()[-1]) - 1\n\n    def dijkstra(graph, start):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        pq = [(0, start)]\n\n        while pq:\n            weight, u = heapq.heappop(pq)\n            if dist[u] < weight:\n                continue\n\n            for v, w in graph[u]:\n                if dist[v] > dist[u] + w:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n\n        return dist\n\n    def bellman_ford(graph):\n        dist = dijkstra(graph, 0)\n        for i in range(1, n):\n            for u, v, w in graph[i]:\n                if dist[u] + w < dist[v]:\n                    return False\n        return True\n\n    def shortest_path_tree(graph, start):\n        dist = dijkstra(graph, start)\n        tree = []\n        for u, v, w in graph[start]:\n            if dist[u] + w == dist[v]:\n                tree.append((u, v, w))\n\n        return tree\n\n    def min_total_weight(graph, start):\n        min_weight = float('inf')\n        for u, v, w in graph[start]:\n            min_weight = min(min_weight, w)\n\n        return min_weight\n\n    def find_tree(graph, start):\n        tree = shortest_path_tree(graph, start)\n        if not tree:\n            return None\n\n        min_weight = min_total_weight(graph, start)\n        for u, v, w in tree:\n            if w == min_weight:\n                return (u, v, w)\n\n        return None\n\n    def find_trees(graph, start):\n        trees = []\n        for u in range(n):\n            if u == start:\n                continue\n\n            tree = find_tree(graph, u)\n            if tree:\n                trees.append(tree)\n\n        return trees\n\n    def find_min_total_weight_trees(graph):\n        trees = find_trees(graph, 0)\n        min_weight = float('inf')\n        for tree in trees:\n            min_weight = min(min_weight, tree[2])\n\n        return [tree for tree in trees if tree[2] == min_weight]\n\n    def print_tree(tree):\n        for u, v, w in tree:\n            print(u + 1, v + 1, w)\n\n    def main():\n        graph = [[] for _ in range(n)]\n        for u, v, w in edges:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n\n        if not bellman_ford(graph):\n            return \"IMPOSSIBLE\"\n\n        min_weight_trees = find_min_total_weight_trees(graph)\n        if not min_weight_trees:\n            return \"IMPOSSIBLE\"\n\n        min_weight_tree = min_weight_trees[0]\n        print(min_total_weight(graph, 0))\n        print_tree(min_weight_tree)\n\n    main()\n    return \"\"\n\n\ndef"
    },
    {
        "number": 2180,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    board = [list(stdin.split()[i]) for i in range(1, n+1)]\n    max_coders = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'C':\n                max_coders += 1\n                for k in range(4):\n                    if k == 0:\n                        new_i = i + 1\n                    elif k == 1:\n                        new_i = i - 1\n                    elif k == 2:\n                        new_j = j + 1\n                    else:\n                        new_j = j - 1\n                    if 0 <= new_i < n and 0 <= new_j < n and board[new_i][new_j] == '.':\n                        board[new_i][new_j] = 'C'\n    return str(max_coders)"
    },
    {
        "number": 2181,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(float, stdin.split())\n    n = int(stdin.split()[1])\n\n    x = [0]\n    y = [0]\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 0)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 2 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 3 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 4 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 5 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 6 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 7 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 8 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 9 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 10 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 11 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 12 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 13 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 14 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 15 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 16 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 17 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 18 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 19 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 20 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 21 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 22 * d)\n\n    for i in range(1, n + 1):\n        x.append(x[-1] + i * d)\n        y.append(y[-1] + 23 * d)\n\n    for i in range(1, n +"
    },
    {
        "number": 2182,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    y = [int(x) for x in stdin.split()[1:]]\n\n    def is_divisible(num: int) -> bool:\n        return num % 60 == 0\n\n    def rearrange(num: int) -> int:\n        digits = [int(d) for d in str(num)]\n        for i in range(len(digits)):\n            for j in range(i + 1, len(digits)):\n                if digits[i] > digits[j]:\n                    digits[i], digits[j] = digits[j], digits[i]\n                    break\n        return int(''.join(str(d) for d in digits))\n\n    def random_permutation(num: int) -> int:\n        digits = [int(d) for d in str(num)]\n        for i in range(len(digits)):\n            j = random.randint(i, len(digits) - 1)\n            digits[i], digits[j] = digits[j], digits[i]\n        return int(''.join(str(d) for d in digits))\n\n    def find_permutation(num: int) -> str:\n        if is_divisible(num):\n            return \"red\"\n        for perm in [rearrange(num), random_permutation(num)]:\n            if is_divisible(perm):\n                return \"red\"\n        return \"cyan\"\n\n    result = [find_permutation(y_i) for y_i in y]\n    return '\\n'.join(result)"
    },
    {
        "number": 2184,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    functions = []\n    for i in range(n):\n        truth_table = stdin.split('\\n')[i+1]\n        functions.append(parse_function(truth_table))\n    return min(functions, key=lambda x: x.length)\n\ndef"
    },
    {
        "number": 2185,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = list(map(int, stdin.split('\\n')[3].split()))\n\n        def push(l, r, k):\n            for i in range(l, r+1):\n                a[i] += k\n\n        def is_equal(a, b):\n            return a == b\n\n        def is_possible(a, b):\n            for i in range(len(a)):\n                if a[i]!= b[i]:\n                    return True\n            return False\n\n        for i in range(len(a)):\n            if a[i]!= b[i]:\n                push(i, i, 1)\n                if is_equal(a, b):\n                    return \"YES\"\n                push(i, i, -1)\n                if is_equal(a, b):\n                    return \"YES\"\n\n        return \"NO\""
    },
    {
        "number": 2186,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    strings = stdin.split('\\n')[1:]\n    queries = stdin.split('\\n')[1+n:][::2]\n\n    def find_strings(s: str) -> int:\n        return sum(1 for c in s if c == 'a')\n\n    def find_diff_strings(s: str, t: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i]!= t[i]:\n                count += 1\n        return count\n\n    for query in queries:\n        s, t = query.split()\n        if find_strings(s) == find_strings(t) and find_diff_strings(s, t) == 1:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 2187,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = [a[0]]\n        for i in range(1, n):\n            if a[i] > b[-1]:\n                b.append(a[i])\n            else:\n                b = b[:-1]\n        b.append(a[-1])\n        b = sorted(b)\n        print(len(b) - 1)"
    },
    {
        "number": 2188,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[0], x[1]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]\n    pairs.sort(key=lambda x: (x[1], x[0]))\n    pairs = [pair for pair in pairs if pair[0] < pair[1]]"
    },
    {
        "number": 2189,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        v, u = map(int, stdin.split())\n        graph[v].append(u)\n        graph[u].append(v)\n\n    def dfs(v, visited, labels):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u, visited, labels)\n        labels[v] = min(labels[u] for u in graph[v] if labels[u] < labels[v])\n\n    labels = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    for v in range(1, n + 1):\n        if not visited[v]:\n            dfs(v, visited, labels)\n\n    return \" \".join(map(str, labels))"
    },
    {
        "number": 2190,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] * a[j] == k:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2191,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(map(int, stdin.split()[1]))\n\n    def count_finished_sets(x: int, s: list) -> int:\n        count = 0\n        for i in range(n):\n            if s[i] == 0:\n                count += 1\n            elif s[i] == 1:\n                count = 0\n            else:\n                count = 0\n        return count\n\n    def max_finished_sets(x: int) -> int:\n        max_count = 0\n        for i in range(1, n + 1):\n            count = count_finished_sets(i, s)\n            if count > max_count:\n                max_count = count\n        return max_count\n\n    return \" \".join(map(str, [max_finished_sets(x) for x in range(1, n + 1)]))"
    },
    {
        "number": 2192,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()[1:]))\n        matrix.append(row)\n\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = matrix[j][i]\n\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = -matrix[i][j]\n\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = matrix[i][j] + matrix[j][i]\n\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = matrix[i][j] / 2\n\n    result = []\n    for row in matrix:\n        result.append(\" \".join(map(str, row)))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2193,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for u, v, t in map(lambda x: list(map(int, x.split())), stdin.split()[1:][::2]):\n        graph[u].append((v, t))\n        graph[v].append((u, t))\n\n    def bfs(start: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        path = [start]\n        while queue:\n            current = queue.popleft()\n            for neighbor, road_type in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    path.append(neighbor)\n        return path\n\n    def shortest_path(start: int, end: int) -> int:\n        path1 = bfs(start)\n        path2 = bfs(end)\n        return min(len(path1), len(path2))\n\n    def is_safe(city: int, road_type: int) -> bool:\n        return road_type == 0 if city % 2 == 0 else road_type == 1\n\n    def is_valid(city: int, road_type: int) -> bool:\n        return is_safe(city, road_type) and city!= 1\n\n    def dfs(start: int, path: List[int], visited: Set[int]) -> List[int]:\n        if start == n:\n            return path\n        for neighbor, road_type in graph[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                path.append(neighbor)\n                result = dfs(neighbor, path, visited)\n                if result:\n                    return result\n                visited.remove(neighbor)\n                path.pop()\n        return None\n\n    def find_path(start: int, end: int) -> List[int]:\n        visited = set()\n        return dfs(start, [start], visited)\n\n    def is_valid_schedule(schedule: List[int]) -> bool:\n        visited = set()\n        for city, road_type in zip(schedule, schedule[1:]):\n            if city not in visited:\n                visited.add(city)\n                if not is_valid(city, road_type):\n                    return False\n        return True\n\n    def is_valid_path(path: List[int]) -> bool:\n        visited = set()\n        for city in path:\n            if city not in visited:\n                visited.add(city)\n                if not is_valid(city, 0):\n                    return False\n        return True\n\n    def is_valid_schedule_and_path(schedule: List[int]) -> bool:\n        visited = set()\n        for city, road_type in zip(schedule, schedule[1:]):\n            if city not in visited:\n                visited.add(city)\n                if not is_valid(city, road_type):\n                    return False\n        return is_valid_path(find_path(1, n))\n\n    def find_shortest_path(start: int, end: int) -> int:\n        shortest = float('inf')\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if is_valid_schedule_and_path(schedule=[i, j]):\n                    shortest = min(shortest, shortest_path(i, j))\n        return shortest\n\n    def find_schedule(start: int, end: int) -> List[int]:\n        visited = set()\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if is_valid_schedule_and_path(schedule=[i, j]):\n                    path = find_path(i, j)\n                    if is_valid_path(path):\n                        return path\n        return None\n\n    def find_best_schedule(start: int, end: int) -> List[int]:\n        shortest = float('inf')\n        best_schedule = None\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if is_valid_schedule_and_path(schedule=[i, j]):\n                    path = find_path(i, j)\n                    if is_valid_path(path):\n                        length = len(path)\n                        if length < shortest:\n                            shortest = length\n                            best_schedule = path\n        return best_schedule\n\n    def print_schedule(schedule: List[int]) -> None:\n        print(len(schedule))\n        print(''.join(str(city) for city in schedule))\n\n    def main() -> None"
    },
    {
        "number": 2194,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    for _ in range(q):\n        query = stdin.split()\n        query_type = int(query[0])\n        x, k = map(int, query[1].split())\n\n        if query_type == 1:\n            a[x] = k\n        elif query_type == 2:\n            for i in range(1, 2 ** n + 1, 2 ** k):\n                a[i - 1], a[i] = a[i], a[i - 1]\n        elif query_type == 3:\n            for i in range(1, 2 ** n + 1, 2 ** k):\n                a[i - 1], a[i - 2] = a[i - 2], a[i - 1]\n                a[i], a[i + 1] = a[i + 1], a[i]\n        elif query_type == 4:\n            l, r = map(int, query[1].split())\n            print(sum(a[l - 1:r]))\n\n    return \"\\n\".join(map(str, a))\n"
    },
    {
        "number": 2195,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        x, y = map(int, stdin.split('\\n')[1].split())\n        a, b = map(int, stdin.split('\\n')[2].split())\n        min_cost = float('inf')\n        for i in range(2):\n            for j in range(2):\n                if i == j:\n                    continue\n                if i == 0:\n                    x_new = x - 1\n                    y_new = y\n                else:\n                    x_new = x\n                    y_new = y - 1\n                if x_new == y_new == 0:\n                    min_cost = min(min_cost, a + b)\n        print(min_cost)"
    },
    {
        "number": 2196,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    count = 0\n    for i in range(n):\n        if a[i] == 0:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 2197,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    piles = list(map(float, stdin.split()))\n    piles.append(1 - sum(piles))\n    piles = [piles[i] / sum(piles) for i in range(x + 1)]\n\n    def nim_win_probability(piles: list) -> float:\n        def choose(n: int, k: int) -> float:\n            if n < k:\n                return 0\n            elif k == 0 or k == n:\n                return 1\n            else:\n                return choose(n - 1, k - 1) * piles[k - 1] + choose(n - 1, k) * (1 - piles[k - 1])\n\n        def expected_value(piles: list) -> float:\n            return sum(choose(n, k) * piles[k] for k in range(1, x + 1))\n\n        return expected_value(piles)\n\n    return str(nim_win_probability(piles))"
    },
    {
        "number": 2198,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()[1]\n    queries = []\n    for _ in range(m):\n        x, c = map(int, stdin.split())\n        queries.append((x, c))\n\n    def f(s: str) -> int:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i:i+2] == \"..\":\n                count += 1\n            i += 1\n        return count\n\n    def replace(s: str, x: int, c: str) -> str:\n        count = 0\n        i = 0\n        while i < len(s):\n            if s[i:i+2] == \"..\":\n                count += 1\n                if count == 2:\n                    s = s[:x-1] + c + s[x:]\n                    count = 0\n            i += 1\n        return s\n\n    def process_query(x: int, c: str) -> int:\n        s = replace(s, x, c)\n        return f(s)\n\n    results = [process_query(x, c) for x, c in queries]\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2199,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [int(x) for x in stdin.split()]\n    S = set()\n    for query in queries:\n        if query == 1:\n            x = int(stdin.split()[1])\n            if x < min(S):\n                continue\n            S.add(x)\n        elif query == 2:\n            S.clear()\n    if not S:\n        return \"0.0000000000\"\n    max_val = max(S)\n    mean_val = sum(S) / len(S)\n    return str(max_val - mean_val)"
    },
    {
        "number": 2200,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    tokens = [0] * n\n    for i in range(n):\n        tokens[i] = x[i]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            tokens[j] += tokens[i]\n\n    result = []\n    for i in range(n):\n        if tokens[i] > 0:\n            result.append(tokens[i])\n        else:\n            result.append(0)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2201,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n, m = map(int, stdin.split())\n    gas_stations = [tuple(map(int, stdin.split())) for _ in range(m)]\n    gas_stations.sort(key=lambda x: x[0])\n\n    tank_level = 0\n    total_cost = 0\n\n    for i, (x, p) in enumerate(gas_stations):\n        if x <= tank_level:\n            continue\n\n        tank_level = min(tank_level, x)\n        total_cost += tank_level * p\n\n    if tank_level < n:\n        return -1\n\n    return total_cost"
    },
    {
        "number": 2202,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def score(part):\n        return sum(part) % p\n\n    def max_score(A):\n        max_score = 0\n        for i in range(len(A)):\n            for j in range(i + 1, len(A)):\n                max_score = max(max_score, score(A[i:j + 1]))\n        return max_score\n\n    part1 = A[:N // 2]\n    part2 = A[N // 2:]\n\n    max_score1 = max_score(part1)\n    max_score2 = max_score(part2)\n\n    return str(max(max_score1, max_score2))"
    },
    {
        "number": 2203,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, q = map(int, stdin.split())\n    questions = []\n    for _ in range(q):\n        i, L, R, ans = map(int, stdin.split())\n        questions.append((i, L, R, ans))\n\n    def ancestor(v, i):\n        if v == 1:\n            return 1\n        return 1 + ancestor(v // 2, i)\n\n    def is_in_range(v, L, R):\n        return L <= v <= R\n\n    def is_leaf(v):\n        return v == 1\n\n    def is_unique_exit(v, i):\n        return is_leaf(v) and is_in_range(v, 2 ** i - 1, 2 ** (i + 1) - 1)\n\n    def is_contradictory(v, L, R, i):\n        return not is_in_range(v, L, R)\n\n    def is_game_cheated(v, L, R, i):\n        return not is_unique_exit(v, i)\n\n    def find_exit(i, L, R, ans):\n        if is_contradictory(1, L, R, i):\n            return \"Game cheated!\"\n        elif is_game_cheated(1, L, R, i):\n            return \"Data not sufficient!\"\n        elif is_unique_exit(1, i):\n            return 1\n        else:\n            for v in range(2, 2 ** h):\n                if is_in_range(v, L, R) and is_unique_exit(v, i):\n                    return v\n            return \"Data not sufficient!\"\n\n    for i, L, R, ans in questions:\n        print(find_exit(i, L, R, ans))"
    },
    {
        "number": 2204,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        a, b = map(int, stdin.split('\\n')[2].split())\n        flowers = [list(map(int, stdin.split('\\n')[3 + i].split())) for i in range(m)]\n        max_happiness = 0\n        for i in range(n):\n            happiness = 0\n            for j in range(m):\n                happiness += a[j] + (flowers[j][i] - 1) * b[j]\n            max_happiness = max(max_happiness, happiness)\n        print(max_happiness)"
    },
    {
        "number": 2205,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    q = 0\n    for i in range(n):\n        q ^= p[i] ^ (i % 1) ^ (i % 2) ^ (i % 3) ^ (i % 4) ^ (i % 5) ^ (i % 6) ^ (i % 7) ^ (i % 8) ^ (i % 9)\n\n    return str(q)"
    },
    {
        "number": 2206,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n    MOD = 10**9 + 7\n\n    def dfs(start, end, visited):\n        if start == end:\n            return 1\n        if (start, end) in visited:\n            return 0\n        visited.add((start, end))\n\n        ways = 0\n        for i in range(n):\n            if a[start][i] == 1 and a[end][i] == 1:\n                continue\n            if a[start][i] == 1:\n                ways += dfs(i, end, visited)\n            if a[end][i] == 1:\n                ways += dfs(start, i, visited)\n\n        return ways % MOD\n\n    ways = dfs(0, n - 1, set())\n    return str(ways)"
    },
    {
        "number": 2207,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    bricks = [list(line.strip()) for line in stdin.split()[1:]]\n\n    segments = []\n    for i in range(R):\n        for j in range(C):\n            if bricks[i][j] == 'B':\n                segments.append((i, j))\n\n    return str(len(segments))"
    },
    {
        "number": 2208,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:n+1]))\n    b = list(map(int, stdin.split()[n+1:]))\n    \n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j] and b[i] == b[j]:\n                count += 1\n    \n    return str(count)"
    },
    {
        "number": 2209,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = stdin.split()[1:]\n    max_noise = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            noise = strings[i].count('sh') + strings[j].count('sh')\n            max_noise = max(max_noise, noise)\n    return str(max_noise)"
    },
    {
        "number": 2210,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, x = map(int, stdin.split('\\n')[1].split())\n        edges = [tuple(map(int, stdin.split('\\n')[i+2].split())) for i in range(n-1)]\n        graph = {i: [] for i in range(1, n+1)}\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n        leaves = [i for i in range(1, n+1) if len(graph[i]) == 1]\n        if x in leaves:\n            return \"Ayush\"\n        else:\n            return \"Ashish\""
    },
    {
        "number": 2211,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split('\\n')[0].split()\n    rules = []\n    for i in range(n):\n        p, l, r = stdin.split('\\n')[i+1].split()\n        rules.append((p, int(l), int(r)))\n\n    def is_good(t: str) -> bool:\n        for p, l, r in rules:\n            if t in p and len(t) >= l and len(t) <= r:\n                return True\n        return False\n\n    def count_good_substrings(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i+1, len(s)+1):\n                if is_good(s[i:j]):\n                    count += 1\n        return count\n\n    return str(count_good_substrings(s))"
    },
    {
        "number": 2212,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    matrix = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(i * n + j + 1)\n        matrix.append(row)\n    for i in range(n):\n        matrix[i].sort()\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] += 1\n            else:\n                matrix[i][j] += 2\n    for i in range(n):\n        for j in"
    },
    {
        "number": 2213,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    arrays = [list(map(int, stdin.split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays[i][j]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arrays[i][j] > arrays[i][i]:\n                arrays[i][j], arrays[j][j] = arrays[j][j], arrays["
    },
    {
        "number": 2214,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = [[int(x) for x in stdin.split()[1]] for _ in range(n)]\n\n    def is_good(r1, r2, c1, c2):\n        return all(a[i][j] == 1 for i in range(r1, r2+1) for j in range(c1, c2+1))\n\n    def count_good_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1:\n                    count += 1\n        return count\n\n    def count_odd_ones(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1:\n                    count += 1\n        return count\n\n    def count_even_length_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1 and (r2-r1+1) % 2 == 0:\n                    count += 1\n        return count\n\n    def count_odd_length_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1 and (r2-r1+1) % 2!= 0:\n                    count += 1\n        return count\n\n    def count_good_submatrices_with_odd_ones(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1 and (r2-r1+1) % 2 == 0:\n                    count += 1\n                    if count_odd_ones(i, i, j, j) % 2 == 1:\n                        return count\n        return count\n\n    def count_good_submatrices_with_even_length_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1 and (r2-r1+1) % 2 == 0:\n                    count += 1\n                    if count_even_length_submatrices(i, i, j, j) % 2 == 1:\n                        return count\n        return count\n\n    def count_good_submatrices_with_odd_length_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1 and (r2-r1+1) % 2!= 0:\n                    count += 1\n                    if count_odd_length_submatrices(i, i, j, j) % 2 == 1:\n                        return count\n        return count\n\n    def count_good_submatrices_with_odd_ones_and_even_length_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c1, c2+1):\n                if a[i][j] == 1 and (r2-r1+1) % 2 == 0:\n                    count += 1\n                    if count_odd_ones(i, i, j, j) % 2 == 1 and count_even_length_submatrices(i, i, j, j) % 2 == 1:\n                        return count\n        return count\n\n    def count_good_submatrices_with_odd_ones_and_odd_length_submatrices(r1, r2, c1, c2):\n        count = 0\n        for i in range(r1, r2+1):\n            for j in range(c"
    },
    {
        "number": 2215,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flowers = [0] * n\n    for i in range(m):\n        l, r = map(int, stdin.split())\n        for j in range(l - 1, r):\n            flowers[j] = 1\n    return ''.join(str(flower) for flower in flowers)"
    },
    {
        "number": 2216,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    tubes = []\n    for i in range(k):\n        r = 2 * i + 1\n        tubes.append((r, 2 * i + 1))\n        for j in range(r - 1):\n            tubes[-1].append(tubes[-1][-1] + 1)\n    return '\\n'.join(f'{r} {x1} {y1} {x2} {y2} {x3} {y3}' for r, (x1, y1, x2, y2, x3, y3) in enumerate(tubes, start=1))"
    },
    {
        "number": 2217,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, q = map(int, stdin.split())\n    graph = [[] for _ in range(D + 1)]\n    for _ in range(q):\n        v, u = map(int, stdin.split())\n        graph[v].append((u, 1))\n        graph[u].append((v, 1))\n\n    def dfs(v, visited, path, result):\n        visited[v] = True\n        for neighbor, weight in graph[v]:\n            if not visited[neighbor]:\n                path.append(neighbor)\n                dfs(neighbor, visited, path, result)\n                path.pop()\n        result[v] = len(path)\n\n    visited = [False] * (D + 1)\n    result = [float('inf')] * (D + 1)\n    for v in range(1, D + 1):\n        if not visited[v]:\n            path = []\n            dfs(v, visited, path, result)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2218,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_unique_beauties(beauties: list) -> list:\n        unique_beauties = set()\n        for beauty in beauties:\n            if beauty not in unique_beauties:\n                unique_beauties.add(beauty)\n        return list(unique_beauties)\n\n    def find_unique_combinations(beauties: list) -> list:\n        unique_combinations = set()\n        for i in range(1, len(beauties) + 1):\n            for j in range(i):\n                unique_combinations.add((beauties[i - 1], beauties[j]))\n        return list(unique_combinations)\n\n    unique_beauties = find_unique_beauties(a)\n    unique_combinations = find_unique_combinations(unique_beauties)\n\n    result = []\n    for i in range(k):\n        detachment_beauties = [beauty for beauty, _ in unique_combinations]\n        detachment_beauties.sort()\n        detachment_size = len(detachment_beauties)\n        detachment_numbers = list(range(1, detachment_size + 1))\n        detachment_numbers.sort()\n\n        result.append(f\"{detachment_size} {detachment_numbers[0]}\")\n        for beauty in detachment_beauties:\n            result.append(f\"{beauty} {detachment_numbers.pop(0)}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2219,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n, k = map(int, stdin.split()[1:])\n        steps = 0\n        while n > 0:\n            if n % k == 0:\n                n //= k\n                steps += 1\n            else:\n                n -= 1\n                steps += 1\n        print(steps)"
    },
    {
        "number": 2220,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def dp(i, j):\n        if i == j:\n            return 0\n        if dp(i + 1, j) >= 0:\n            return dp(i + 1, j)\n        if dp(i, j - 1) >= 0:\n            return dp(i, j - 1)\n        return -1\n\n    max_happiness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                continue\n            if dp(i, j) >= 0:\n                max_happiness = max(max_happiness, a[i] + a[j] + dp(i, j))\n\n    return str(max_happiness)"
    },
    {
        "number": 2221,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split()[0].split())\n    x2, y2 = map(int, stdin.split()[1].split())\n    n = int(stdin.split()[2])\n    s = stdin.split()[3]\n\n    dx = [0, 0, -1, 1]\n    dy = [-1, 1, 0, 0]\n\n    def move(x, y, d):\n        return x + dx[d], y + dy[d]\n\n    def is_valid(x, y, d):\n        return 0 <= x < 10000 and 0 <= y < 10000 and s[d] in \"UDLR\"\n\n    def count_days(x, y, d):\n        days = 0\n        while is_valid(x, y, d):\n            x, y = move(x, y, d)\n            days += 1\n        return days\n\n    days = float('inf')\n    for d in \"UDLR\":\n        days = min(days, count_days(x1, y1, d))\n\n    return str(days) if days!= float('inf') else \"-1\""
    },
    {
        "number": 2222,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *operations, *parents = map(int, stdin.split())\n    tree = [[] for _ in range(n + 1)]\n    for i, parent in enumerate(parents):\n        tree[parent].append(i)\n\n    def dfs(node, parent, max_num):\n        nonlocal max_num\n        max_num = max(max_num, node)\n        for child in tree[node]:\n            if child!= parent:\n                dfs(child, node, max_num)\n\n    dfs(1, 0, float('-inf'))\n    return str(max_num)"
    },
    {
        "number": 2223,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:3])\n        edges.append((u - 1, v - 1))\n\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        size = 1\n        for v in range(n):\n            if v == u or (v in visited and edges[v - 1][u] not in visited):\n                continue\n            size += dfs(v, visited)\n        return size\n\n    max_size = 0\n    for i in range(n):\n        visited = set()\n        size = dfs(i, visited)\n        if size % 2 == 0:\n            max_size = max(max_size, size)\n        else:\n            return -1\n\n    return str(max_size)"
    },
    {
        "number": 2224,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    paths = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.split())\n        paths.append((a, b))\n\n    def bfs(start: int, visited: set) -> int:\n        queue = [(start, 0)]\n        visited.add(start)\n        while queue:\n            current, distance = queue.pop(0)\n            if current == n:\n                return distance\n            for neighbor, weight in paths:\n                if neighbor not in visited and abs(neighbor - current) <= d:\n                    visited.add(neighbor)\n                    queue.append((neighbor, distance + weight))\n        return -1\n\n    visited = set()\n    for i in range(1, n + 1):\n        if i not in visited and bfs(i, visited)!= -1:\n            return i\n\n    return \"0\"\n"
    },
    {
        "number": 2225,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    v = 0\n    for _ in range(m):\n        p, b = map(int, stdin.split())\n        a[p - 1] = b\n        v = a[0]\n        for i in range(1, n):\n            a[i] = a[i] ^ a[i - 1]\n        v = v ^ a[n - 1]\n    return str(v)"
    },
    {
        "number": 2226,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    edges = [tuple(map(int, stdin.split())) for _ in range(m)]\n    edges.sort(key=lambda x: (-x[2], x[0], x[1]))\n\n    def dfs(v, path, depth):\n        nonlocal max_weight\n        nonlocal max_path\n        nonlocal max_depth\n\n        if depth == q:\n            weight = sum(e[2] for e in path)\n            if weight > max_weight:\n                max_weight = weight\n                max_path = path\n                max_depth = depth\n            return\n\n        for i, e in enumerate(edges):\n            if e[0] == v:\n                path.append(e)\n                dfs(e[1], path, depth + 1)\n                path.pop()\n\n    max_weight = 0\n    max_path = []\n    max_depth = 0\n\n    for i in range(1, n + 1):\n        dfs(i, [(-1, 0, 0)], 1)\n\n    return str(max_weight)"
    },
    {
        "number": 2227,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin.lower()\n    powerful_substrings = []\n    for i in range(len(text) - 1):\n        if text[i:i+6] == \"heavy\" and text[i+6:i+12] == \"metal\":\n            powerful_substrings.append(text[i:i+12])\n    return str(len(powerful_substrings))"
    },
    {
        "number": 2228,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    people = []\n    for _ in range(n):\n        b, d = map(int, stdin.split()[1:])\n        people.append((b, d))\n    people.sort(key=lambda x: x[0])\n    max_year = people[-1][0]\n    max_count = 0\n    for i in range(len(people)):\n        if people[i][0] == max_year:\n            max_count += 1\n        else:\n            break\n    return f\"{max_year} {max_count}\""
    },
    {
        "number": 2229,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    b = [2] * n\n    for i in range(n):\n        b[i] = 2 * a[i]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd(b[i], b[j]) == 1:\n                b[j] = 2 * b[j]\n\n    return \" \".join(map(str, b))\n\n\ndef"
    },
    {
        "number": 2230,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        return \"Invalid input\"\n\n    candy_bags = [1] * (n * n)\n    for i in range(1, n * n, 2):\n        candy_bags[i] = 2\n\n    for i in range(2, n * n, 2):\n        candy_bags[i] = 3\n\n    for i in range(3, n * n, 2):\n        candy_bags[i] = 4\n\n    result = []\n    for i in range(n):\n        result.append(\" \".join(map(str, candy_bags[i * n : (i + 1) * n])))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2231,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1].split()[0])\n        sticks = list(map(int, stdin.split('\\n')[1].split()[1:]))\n        sticks.sort()\n        sticks.append(sticks[0] + 1)\n        sticks.append(sticks[-1] + 1)\n        sticks.sort()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop()\n        sticks.pop"
    },
    {
        "number": 2232,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:n]]\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    def bfs(u, visited):\n        queue = [u]\n        visited[u] = True\n        while queue:\n            v = queue.pop(0)\n            for w in graph[v]:\n                if not visited[w]:\n                    visited[w] = True\n                    queue.append(w)\n\n    def common_vertices(path1, path2):\n        return len(set(path1) & set(path2))\n\n    def max_length(path1, path2):\n        return max(len(path1), len(path2))\n\n    def max_common_vertices(path1, path2):\n        return max(common_vertices(path1, path2), common_vertices(path2, path1))\n\n    def max_total_length(path1, path2):\n        return max(max_length(path1, path2), max_length(path2, path1))\n\n    def max_common_vertices_and_total_length(path1, path2):\n        return max(max_common_vertices(path1, path2), max_common_vertices(path2, path1), max_total_length(path1, path2), max_total_length(path2, path1))\n\n    def max_common_vertices_and_total_length_with_simple_paths(path1, path2):\n        visited = [False] * (n + 1)\n        dfs(1, visited)\n        bfs(1, visited)\n        simple_path1 = [u for u in range(1, n + 1) if visited[u]]\n        simple_path2 = [u for u in range(1, n + 1) if visited[u]]\n\n        return max_common_vertices_and_total_length(path1, path2), max_common_vertices_and_total_length(simple_path1, simple_path2)\n\n    max_common_vertices_and_total_length_with_simple_paths(1, 2)\n    max_common_vertices_and_total_length_with_simple_paths(2, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 3)\n    max_common_vertices_and_total_length_with_simple_paths(3, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 4)\n    max_common_vertices_and_total_length_with_simple_paths(4, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 5)\n    max_common_vertices_and_total_length_with_simple_paths(5, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 6)\n    max_common_vertices_and_total_length_with_simple_paths(6, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 7)\n    max_common_vertices_and_total_length_with_simple_paths(7, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 8)\n    max_common_vertices_and_total_length_with_simple_paths(8, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 9)\n    max_common_vertices_and_total_length_with_simple_paths(9, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 10)\n    max_common_vertices_and_total_length_with_simple_paths(10, 1)\n    max_common_vertices_and_total_length_with_simple_paths(1, 11)\n    max_common_vertices_and_total_length_with_simple_paths(11, 1)"
    },
    {
        "number": 2233,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    s = stdin.split()[2]\n    t = stdin.split()[3]\n\n    for i in range(n):\n        if s[i]!= t[i]:\n            return \"No\"\n\n    return \"Yes\"\n\ndef"
    },
    {
        "number": 2234,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split()[1:])\n        if n == 0 and k == 0:\n            print(0)\n        else:\n            steps = 0\n            while True:\n                steps += 1\n                if abs(n - k) == abs(k - 1):\n                    break\n                n += 1 if n < k else -1\n            print(steps)"
    },
    {
        "number": 2235,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    trips = [int(x) for x in stdin.split()[1:]]\n    trips.sort()\n    total_cost = 0\n    for i in range(n):\n        total_cost += trips[i] * (i + 1)\n    return \" \".join(map(str, total_cost))"
    },
    {
        "number": 2236,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    banks = [0] * n\n    banks[0] = a[0]\n    for i in range(1, n):\n        banks[i] = banks[i - 1] + a[i]\n    min_operations = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(i - j) <= 1:\n                min_operations = min(min_operations, abs(banks[i] - banks[j]))\n    return str(min_operations)"
    },
    {
        "number": 2237,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    S = set(map(int, stdin.split()[1:]))\n    x = 0\n    while True:\n        x += 1\n        if 2**x - 1 in S:\n            break\n    magical_permutation = [0] * 2**x\n    for i in range(2**x):\n        magical_permutation[i] = i\n    for i in range(2**x):\n        for j in range(i + 1, 2**x):\n            magical_permutation[j] = magical_permutation[j] ^ i\n    return str(x) +'' +''.join(map(str, magical_permutation))"
    },
    {
        "number": 2238,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    crystal = ['*' for _ in range(n)]\n    crystal[n//2] = 'D'\n    crystal[n//2][n//2] = 'D'\n    crystal[n//2][n//2+1] = 'D'\n    crystal[n//2+1] = 'D' * n\n    crystal[n//2+1][n//2] = 'D'\n    crystal[n//2+1][n//2+1] = 'D'\n    crystal[n//2+2] = 'D' * n\n    crystal[n//2+2][n//2] = 'D'\n    crystal[n//2+2][n//2+1] = 'D'\n    crystal[n//2+2][n//2+2] = 'D'\n    return '\\n'.join([''.join(row) for row in crystal])"
    },
    {
        "number": 2239,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        x = int(stdin.split()[1])\n        if x == 0:\n            print(0)\n        else:\n            count = 0\n            while count < x:\n                count += sum(1 for _ in range(7))\n            print(count)"
    },
    {
        "number": 2240,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = list(s)\n    t = list(t)\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '0' and t[i] == '1':\n            count += 1\n        elif s[i] == '1' and t[i] == '0':\n            count += 1\n    return str(count)"
    },
    {
        "number": 2241,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *ab = map(int, stdin.split())\n    b = [ab[i] for i in range(n)]\n    x, y = 1, 1\n    joy = 0\n    for i in range(n):\n        if b[i] == x + y:\n            joy += x * y\n            x += 1\n            y += 1\n        elif b[i] < x + y:\n            joy += b[i]\n            x += 1\n        else:\n            joy += b[i]\n            y += 1\n    return str(joy)"
    },
    {
        "number": 2242,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    n = len(S)\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if int(S[i:j]) % 2019 == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2243,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(q):\n        query = list(map(int, stdin.split()))\n        queries.append(query)\n\n    online_friends = []\n    for i in range(n):\n        if t[i] == max(t):\n            online_friends.append(i)\n\n    online_friends.sort(key=lambda x: t[x], reverse=True)\n    online_friends = online_friends[:k]\n\n    for query in queries:\n        if query[0] == 1:\n            online_friends.append(query[1])\n        elif query[0] == 2:\n            if query[1] in online_friends:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n\n    return \"\"\n"
    },
    {
        "number": 2244,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    debt_relations = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        debt_relations[a].append(b)\n        debt_relations[b].append(a)\n\n    visited = [False] * (n + 1)\n    visited[1] = True\n\n    def dfs(person: int) -> None:\n        nonlocal visited\n        if visited[person]:\n            return\n\n        visited[person] = True\n        for debtor in debt_relations[person]:\n            dfs(debtor)\n\n    dfs(1)\n\n    if all(visited):\n        return \"1\"\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            return str(i) + \" \" + \" \".join(map(str, visited[:i]))\n\n    return -1\n"
    },
    {
        "number": 2245,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    games = int(stdin.split()[0])\n    for _ in range(games):\n        n, k = map(int, stdin.split()[1:])\n        if k > n:\n            print(\"Alice\")\n        else:\n            print(\"Bob\")\n    return \"\""
    },
    {
        "number": 2246,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    roads = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split()[1:])\n        roads[u - 1].append(v - 1)\n        roads[v - 1].append(u - 1)\n    cities = [0] * n\n    cities[0] = 1\n    expected_length = 0\n    for i in range(1, n):\n        for road in roads[i]:\n            if cities[road] == 0:\n                cities[road] = i\n                expected_length += 1\n                break\n    return str(expected_length)"
    },
    {
        "number": 2247,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        s, a, b, c = map(int, stdin.split()[1:])\n        max_bars = (s + a * c) // (a * c + b)\n        print(max_bars)"
    },
    {
        "number": 2248,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    connectors = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        connectors.append((a, b))\n\n    distances = [[] for _ in range(n + 1)]\n    for a, b in connectors:\n        distances[a].append(b)\n        distances[b].append(a)\n\n    max_distance = 0\n    for i in range(1, n + 1):\n        max_distance = max(max_distance, len(distances[i]))\n\n    return str(max_distance)"
    },
    {
        "number": 2249,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    pairs = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            pairs.add((a[i], a[j]))\n\n    return str(len(pairs))"
    },
    {
        "number": 2250,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        s = list(stdin.split('\\n')[2])\n        left_attackers = [0] * n\n        right_attackers = [0] * n\n        for i in range(n):\n            if s[i] == 'L':\n                left_attackers[i] = 1\n            else:\n                right_attackers[i] = 1\n        for i in range(n):\n            if left_attackers[i] == 1:\n                left_attackers[i] = 2\n            if right_attackers[i] == 1:\n                right_attackers[i] = 2\n        left_attackers = [i for i in left_attackers if i == 1]\n        right_attackers = [i for i in right_attackers if i == 1]\n        if left_attackers:\n            left_attacker = left_attackers[0]\n            right_attackers.remove(left_attacker)\n            left_attackers.remove(left_attacker)\n            left_attackers.append(left_attacker)\n        if right_attackers:\n            right_attacker = right_attackers[0]\n            left_attackers.remove(right_attacker)\n            right_attackers.remove(right_attacker)\n            right_attackers.append(right_attacker)\n        min_players = min(len(left_attackers), len(right_attackers))\n        print(min_players)"
    },
    {
        "number": 2251,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[1:4])\n        edges.append((a, b, c))\n\n    q = int(stdin.split()[4])\n    queries = []\n    for _ in range(q):\n        u, v = map(int, stdin.split()[1:3])\n        queries.append((u, v))\n\n    colors = set()\n    for u, v in queries:\n        for a, b, c in edges:\n            if a == u and b == v or a == v and b == u:\n                colors.add(c)\n\n    return str(len(colors))"
    },
    {
        "number": 2252,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    permutation = list(map(int, stdin.split()[2:2+n]))\n    changes = []\n\n    for _ in range(m):\n        l, r, x = map(int, stdin.split()[2+n:2+n*3])\n        changes.append((l, r, x))\n\n    for l, r, x in changes:\n        permutation[x-1], permutation[l-1] = permutation[l-1], permutation[x-1]\n\n    return \"Yes\" if permutation == list(range(1, n+1)) else \"No\""
    },
    {
        "number": 2253,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        sentence = input().strip()\n        if sentence.endswith('po'):\n            print('FILIPINO')\n        elif sentence.endswith('desu') or sentence.endswith('masu'):\n            print('JAPANESE')\n        elif sentence.endswith('mnida'):\n            print('KOREAN')\n        else:\n            print('FILIPINO')"
    },
    {
        "number": 2254,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good(l: int, r: int) -> bool:\n        return all(a[l] ^ a[i] ^ a[r] == 0 for i in range(l, r + 1))\n\n    pairs = []\n    for l in range(n):\n        for r in range(l + 1, n):\n            if is_good(l, r):\n                pairs.append((l, r))\n\n    return str(len(pairs))"
    },
    {
        "number": 2255,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    visited[1] = True\n    sequence = [1]\n    while not all(visited):\n        for node in graph[sequence[-1]]:\n            if not visited[node]:\n                visited[node] = True\n                sequence.append(node)\n                break\n\n    sequence.sort()\n    return \" \".join(map(str, sequence))"
    },
    {
        "number": 2256,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, x, a, b = map(int, stdin.split()[1:])\n        if a == b:\n            print(0)\n        else:\n            if a < b:\n                a, b = b, a\n            if a == 1:\n                a = n\n            if b == n:\n                b = 1\n            if a == b:\n                print(0)\n            else:\n                max_distance = 0\n                for i in range(a, b):\n                    for j in range(i + 1, b):\n                        max_distance = max(max_distance, abs(i - j))\n                print(max_distance)"
    },
    {
        "number": 2257,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, y1, x2, y2 = map(int, stdin.split())\n    flowers = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        flowers.append((x, y))\n\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_watered(flower, r1, r2):\n        return distance(flower[0], flower[1], x1, y1) <= r1 or distance(flower[0], flower[1], x2, y2) <= r2\n\n    watered_flowers = [flower for flower in flowers if is_watered(flower, x1, y1) or is_watered(flower, x2, y2)]\n    if not watered_flowers:\n        return \"0\"\n\n    def min_distance(r1, r2):\n        return min(distance(flower[0], flower[1], x1, y1) ** 2 + distance(flower[0], flower[1], x2, y2) ** 2 for flower in watered_flowers) ** 0.5\n\n    return str(min_distance(x1, y1) + min_distance(x2, y2))\n"
    },
    {
        "number": 2258,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                pairs.append((i, j))\n\n    pairs.sort()\n\n    if len(pairs) == 0:\n        return \"-1\"\n\n    m = len(pairs)\n    for i in range(m):\n        print(pairs[i][0], pairs[i][1])\n\n    return str(m)\n"
    },
    {
        "number": 2259,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def build_graph(a):\n        graph = {}\n        for i in range(n):\n            graph[i] = []\n        for i in range(n - 1):\n            graph[a[i]].append(a[i + 1])\n        return graph\n\n    def max_independent_set(graph):\n        max_size = 0\n        max_set = set()\n        for vertex in graph:\n            if len(graph[vertex]) > max_size:\n                max_size = len(graph[vertex])\n                max_set = {vertex}\n            elif len(graph[vertex]) == max_size:\n                max_set.add(vertex)\n        return max_set\n\n    graph = build_graph(a)\n    max_set = max_independent_set(graph)\n    return str(len(max_set))"
    },
    {
        "number": 2260,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = 5 ** n\n    return str(result % 100)"
    },
    {
        "number": 2261,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    vectors = []\n    for i in range(2**k):\n        vector = []\n        for j in range(k):\n            if i & (1 << j):\n                vector.append(-1)\n            else:\n                vector.append(1)\n        vectors.append(vector)\n\n    for i in range(2**k):\n        for j in range(2**k):\n            if i & (1 << j):\n                print('+' * k, end='')\n            else:\n                print('*' * k, end='')\n            print()"
    },
    {
        "number": 2262,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    word_set = set()\n    for word in words:\n        root = word\n        while True:\n            if root in word_set:\n                break\n            word_set.add(root)\n            root = ''.join(sorted(root))\n    return str(len(word_set))"
    },
    {
        "number": 2263,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for i in range(n - 1):\n        a, b, l = map(int, stdin.split())\n        roads[a - 1].append((b - 1, l))\n        roads[b - 1].append((a - 1, l))\n\n    changes = []\n    for _ in range(m):\n        r, w = map(int, stdin.split())\n        changes.append((r - 1, w))\n\n    def dfs(city, visited, total_cost):\n        if city in visited:\n            return total_cost\n\n        visited.add(city)\n        total_cost += city * city\n        for neighbor, length in roads[city]:\n            total_cost = dfs(neighbor, visited, total_cost)\n        return total_cost\n\n    total_cost = 0\n    for change in changes:\n        total_cost = dfs(change[0], set(), total_cost)\n        total_cost = dfs(change[1], set(), total_cost)\n\n    return f\"{total_cost:.6f}\"\n"
    },
    {
        "number": 2264,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def find_common_point(a: list, b: list) -> int:\n        for x in a:\n            if x in b:\n                return x\n        return -1\n\n    def find_shortest_segment(segments: list) -> int:\n        shortest_length = float('inf')\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                a, b = segments[i]\n                c, d = segments[j]\n                if a <= c <= b <= d:\n                    length = b - a\n                    shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    def find_shortest_segment_with_common_point(segments: list) -> int:\n        shortest_length = float('inf')\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                a, b = segments[i]\n                c, d = segments[j]\n                if a <= c <= b <= d:\n                    common_point = find_common_point([a, b], [c, d])\n                    if common_point!= -1:\n                        length = b - a\n                        shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    def find_shortest_segment_with_common_point_and_minimal_length(segments: list) -> int:\n        shortest_length = float('inf')\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                a, b = segments[i]\n                c, d = segments[j]\n                if a <= c <= b <= d:\n                    common_point = find_common_point([a, b], [c, d])\n                    if common_point!= -1:\n                        length = b - a\n                        shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    def find_shortest_segment_with_common_point_and_minimal_length_and_degenerate_to_point(segments: list) -> int:\n        shortest_length = float('inf')\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                a, b = segments[i]\n                c, d = segments[j]\n                if a <= c <= b <= d:\n                    common_point = find_common_point([a, b], [c, d])\n                    if common_point!= -1:\n                        length = b - a\n                        shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    def find_shortest_segment_with_common_point_and_minimal_length_and_degenerate_to_point_with_minimal_length(segments: list) -> int:\n        shortest_length = float('inf')\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                a, b = segments[i]\n                c, d = segments[j]\n                if a <= c <= b <= d:\n                    common_point = find_common_point([a, b], [c, d])\n                    if common_point!= -1:\n                        length = b - a\n                        shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    def find_shortest_segment_with_common_point_and_minimal_length_and_degenerate_to_point_with_minimal_length_and_minimal_length(segments: list) -> int:\n        shortest_length = float('inf')\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                a, b = segments[i]\n                c, d = segments[j]\n                if a <= c <= b <= d:\n                    common_point = find_common_point([a, b], [c, d])\n                    if common_point!= -1:\n                        length = b - a\n                        shortest_length = min(shortest_length, length)\n        return shortest_length\n\n    def find_shortest_segment_with_common_point_and_minimal_length_and_degenerate_to_point_with_minimal_length_and_minimal_length_and_degenerate_to_point(segments: list) -> int:\n        shortest_length = float"
    },
    {
        "number": 2265,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = int(a, 2)\n    b = int(b, 2)\n    count = 0\n    for i in range(len(a) - len(b) + 1):\n        if a[i:i + len(b)] == b:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2266,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    roads = [[] for _ in range(n)]\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        roads[u - 1].append(v - 1)\n        roads[v - 1].append(u - 1)\n\n    def bfs(city, visited, distance):\n        queue = [(city, 0)]\n        while queue:\n            city, distance = queue.pop(0)\n            if city not in visited:\n                visited.add(city)\n                if distance <= d:\n                    return distance\n                for neighbor in roads[city]:\n                    queue.append((neighbor, distance + 1))\n        return float('inf')\n\n    visited = set()\n    max_distance = 0\n    for city in range(n):\n        distance = bfs(city, visited, 0)\n        if distance > max_distance:\n            max_distance = distance\n\n    return str(max_distance)"
    },
    {
        "number": 2267,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = [stdin.split()[i] for i in range(1, n + 1)]\n    strings.sort()\n    return ''.join(strings)"
    },
    {
        "number": 2268,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    name = stdin.split()[1]\n    for _ in range(m):\n        x, y = map(str, stdin.split())\n        name = name.replace(x, y)\n        name = name.replace(y, x)\n    return name"
    },
    {
        "number": 2269,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        s = stdin.split('\\n')[1]\n        count = [0] * 3\n        for c in s:\n            count[int(c) - 1] += 1\n        min_length = float('inf')\n        for i in range(3):\n            if count[i] > 0:\n                min_length = min(min_length, s.count(str(i + 1), 1))\n        print(min_length) if min_length!= float('inf') else print(0)"
    },
    {
        "number": 2270,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    events = []\n    for _ in range(q):\n        events.append(list(map(int, stdin.split())))\n\n    def can_build(a: int, b: int) -> bool:\n        return a * b == n\n\n    def can_build_square(a: int, b: int) -> bool:\n        return a * a == n or b * b == n\n\n    def can_build_rectangle(a: int, b: int) -> bool:\n        return a * a == n or b * b == n or a * b == n\n\n    def can_build_square_rectangle(a: int, b: int) -> bool:\n        return a * a == n or b * b == n or a * b == n or a * a == b * b\n\n    for event in events:\n        if event[0] == \"+\":\n            n -= event[1]\n        else:\n            n += event[1]\n\n    if can_build(1, 1) and can_build(2, 2):\n        print(\"YES\")\n    elif can_build_square(1, 1) and can_build_square(1, 1):\n        print(\"YES\")\n    elif can_build_rectangle(1, 1) and can_build_rectangle(1, 1):\n        print(\"YES\")\n    elif can_build_square_rectangle(1, 1) and can_build_square_rectangle(1, 1):\n        print(\"YES\")\n    else:\n        print(\"NO\")\n\n    return \"YES\" if can_build(1, 1) and can_build(2, 2) else \"NO\" if can_build_square(1, 1) and can_build_square(1, 1) else \"NO\" if can_build_rectangle(1, 1) and can_build_rectangle(1, 1) else \"NO\" if can_build_square_rectangle(1, 1) and can_build_square_rectangle(1, 1) else \"NO\""
    },
    {
        "number": 2271,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split()[1:])\n        edges.append((a - 1, b - 1))\n    edges.append((n - 1, 0))\n    edges.append((0, n - 1))\n\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    lifelines = 0\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited)\n            lifelines += 1\n\n    return str(lifelines)\n"
    },
    {
        "number": 2272,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    intervals = []\n    for _ in range(n):\n        query = stdin.split()\n        if query[0] == \"1\":\n            intervals.append((int(query[1]), int(query[2])))\n        elif query[0] == \"2\":\n            a, b = int(query[1]), int(query[2])\n            for i in range(len(intervals)):\n                if intervals[i][0] <= a < intervals[i][1] or intervals[i][0] <= b < intervals[i][1]:\n                    print(\"YES\")\n                    return\n            print(\"NO\")\n    return \"YES\""
    },
    {
        "number": 2273,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [tuple(map(int, stdin.split())) for _ in range(m)]\n\n    def is_connected(v1, v2):\n        return not any(any(e in (x, y) for e in edges) for x in v1 for y in v2)\n\n    def find_matching_vertex_set(vertex_set):\n        for i in range(1, 4):\n            if is_connected(vertex_set, vertex_set[i - 1]):\n                return i\n        return -1\n\n    def find_vertex_set(vertex):\n        for i in range(1, 4):\n            if vertex in vertex_set:\n                return i\n        return -1\n\n    vertex_sets = [set() for _ in range(4)]\n    for a, b in edges:\n        vertex_sets[find_vertex_set(a) - 1].add(b)\n        vertex_sets[find_vertex_set(b) - 1].add(a)\n\n    matching_vertex_sets = [find_matching_vertex_set(vertex_set) for vertex_set in vertex_sets]\n    matching_vertex_sets = [str(matching_vertex_sets[i]) for i in range(len(matching_vertex_sets))]\n\n    return \" \".join(matching_vertex_sets)\n"
    },
    {
        "number": 2274,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        grid = [list(row) for row in stdin.split('\\n')[2:]]\n        directions = [cell[0] for row in grid for cell in row]\n        counter = (n, m)\n        visited = set()\n        queue = [(counter, 0)]\n        min_cells = float('inf')\n\n        while queue:\n            current, steps = queue.pop(0)\n            if current in visited:\n                continue\n            visited.add(current)\n\n            if current == counter:\n                min_cells = min(min_cells, steps)\n                continue\n\n            if current[0] == n and current[1] == m:\n                min_cells = min(min_cells, steps)\n                continue\n\n            if current[0] == 0 or current[1] == 0 or current[0] == n - 1 or current[1] == m - 1:\n                continue\n\n            if directions[current[0] * m + current[1]] == 'R':\n                queue.append((current[0], current[1] + 1, steps + 1))\n            else:\n                queue.append((current[0] + 1, current[1], steps + 1))\n\n        print(min_cells)"
    },
    {
        "number": 2275,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    groups = []\n    for _ in range(t):\n        k, s = map(int, stdin.split()[1:])\n        groups.append((k, s))\n    result = []\n    for k, s in groups:\n        angry_count = 0\n        for i in range(k):\n            if s[i] == 'A':\n                angry_count += 1\n                if angry_count == 1:\n                    result.append(i)\n        result.append(k)\n    return''.join(map(str, result))"
    },
    {
        "number": 2276,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def erase_substring(s: str, start: int, end: int) -> str:\n        return s[:start] + s[end + 1:]\n\n    def max_points(s: str, a: List[int]) -> int:\n        max_points = 0\n        for i in range(1, n + 1):\n            for j in range(i, n + 1):\n                if j - i + 1 in a:\n                    max_points += a[j - i + 1]\n                    s = erase_substring(s, i - 1, j - 1)\n        return max_points\n\n    return str(max_points(s, a))"
    },
    {
        "number": 2277,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    queries = [tuple(map(int, stdin.split())) for _ in range(m)]\n\n    def count_inversions(a: list) -> int:\n        n = len(a)\n        inv_count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] > a[j]:\n                    inv_count += n - i - 1\n        return inv_count\n\n    for l, r in queries:\n        a[l - 1:r] = a[l - 1:r][::-1]\n\n    result = [count_inversions(a) % 2 == 0] * m\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2278,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [list(map(int, stdin.split())) for _ in range(int(stdin.split()[0]))]\n    result = []\n\n    for query in queries:\n        a, b, m = query\n        if a > b:\n            a, b = b, a\n\n        if m == 1:\n            result.append(-1)\n        else:\n            for i in range(1, b + 1):\n                if m - i in range(1, a + 1):\n                    result.append(i)\n                    break\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 2279,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strengths = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    strengths = [sorted(set(combination)) for combination in strengths]\n    strengths = [sorted(combination, reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0]) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[1]) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1]) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for combination in strengths]\n    strengths = [sorted(combination, key=lambda x: x[0] + x[1], reverse=True) for"
    },
    {
        "number": 2280,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n = int(stdin.split()[1])\n        a = list(map(int, stdin.split()[2:]))\n        max_k = 0\n        for i in range(1, n):\n            if a[i] - a[i - 1] >= 2:\n                max_k = max(max_k, a[i] - a[i - 1] // 2)\n        if max_k == 0:\n            print(0)\n        else:\n            print(max_k)\n    return \"\"\n"
    },
    {
        "number": 2281,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = list(range(1, 2 * n + 1, 2))\n    a.sort()\n    s = sum(n - i * (n - i) for i in range(1, n + 1))\n    return \" \".join(map(str, a)) + \"\\n\" + str(s)"
    },
    {
        "number": 2282,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    x = 0\n    count = 0\n    for command in s:\n        if command == 'L':\n            x -= 1\n        elif command == 'R':\n            x += 1\n        count += 1\n    return str(count)"
    },
    {
        "number": 2283,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    edges = []\n    for i in range(m):\n        v, u, w = map(int, stdin.split())\n        edges.append((v, u, w))\n\n    def max_weight_subgraph(vertices, edges):\n        def dfs(vertex, visited):\n            visited[vertex] = True\n            for neighbor, weight in edges[vertex]:\n                if not visited[neighbor]:\n                    dfs(neighbor, visited)\n\n        def bfs(vertex, visited):\n            queue = [vertex]\n            visited[vertex] = True\n            while queue:\n                current = queue.pop(0)\n                for neighbor, weight in edges[current]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n\n        visited = [False] * n\n        max_weight = 0\n\n        for vertex in vertices:\n            if not visited[vertex]:\n                dfs(vertex, visited)\n                max_weight = max(max_weight, sum(w for v, u, w in edges if v in vertices and u in vertices))\n\n        for vertex in vertices:\n            if not visited[vertex]:\n                bfs(vertex, visited)\n                max_weight = max(max_weight, sum(w for v, u, w in edges if v in vertices and u in vertices))\n\n        return max_weight\n\n    max_weight = max_weight_subgraph(range(1, n + 1), edges)\n    return str(max_weight)"
    },
    {
        "number": 2284,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    a.sort()\n    b.sort()\n\n    min_cost = 0\n    for i in range(k):\n        min_cost += a[i] + b[i]\n\n    return str(min_cost)"
    },
    {
        "number": 2285,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    records = []\n    for _ in range(n):\n        record = stdin.split()[1]\n        full_record = \"\"\n        for block in record.split(\":\"):\n            if block == \"0000\":\n                full_record += \"::\"\n            else:\n                full_record += block\n        records.append(full_record)\n    return \"\\n\".join(records)"
    },
    {
        "number": 2286,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    wise_men = [list(map(int, stdin.split()[i:i+n])) for i in range(0, len(stdin), n)]\n    ans = []\n    for x in range(2**n-1):\n        s = [0] * (n-1)\n        for i in range(n-1):\n            s[i] = x % 2\n            x //= 2\n        ans.append(s)\n    return''.join(map(str, ans))"
    },
    {
        "number": 2287,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        s = stdin.split()[1]\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n                if count == 1:\n                    continue\n                else:\n                    break\n        else:\n            print(count)\n        count = 0\n        for i in range(len(s) - 1, -1, -1):\n            if s[i] == '1':\n                count += 1\n                if count == 1:\n                    continue\n                else:\n                    break\n        else:\n            print(count)"
    },
    {
        "number": 2288,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = list(map(int, stdin.split('\\n')[3].split()))\n\n        def merge_sort(arr):\n            if len(arr) <= 1:\n                return arr\n            mid = len(arr) // 2\n            left = merge_sort(arr[:mid])\n            right = merge_sort(arr[mid:])\n            return merge(left, right)\n\n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n\n        def can_sort(arr):\n            return merge_sort(arr) == arr\n\n        if can_sort(a):\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 2289,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    def get_strength(i: int) -> int:\n        if i == 0:\n            return a[0]\n        return a[i] + get_strength(i - 1)\n\n    def get_remaining_arrows(i: int) -> int:\n        if i == 0:\n            return k[0]\n        return k[i] + get_remaining_arrows(i - 1)\n\n    def get_remaining_warriors(i: int) -> int:\n        if i == 0:\n            return 1\n        return get_remaining_warriors(i - 1)\n\n    def get_remaining_strength(i: int) -> int:\n        if i == 0:\n            return a[0]\n        return a[i] + get_remaining_strength(i - 1)\n\n    def get_remaining_arrows_after_attack(i: int) -> int:\n        if i == 0:\n            return 0\n        return get_remaining_arrows_after_attack(i - 1)\n\n    def get_remaining_warriors_after_attack(i: int) -> int:\n        if i == 0:\n            return 1\n        return get_remaining_warriors_after_attack(i - 1)\n\n    def get_remaining_strength_after_attack(i: int) -> int:\n        if i == 0:\n            return a[0]\n        return a[i] + get_remaining_strength_after_attack(i - 1)\n\n    def get_remaining_arrows_after_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 0\n        return get_remaining_arrows_after_attack_and_attack(i - 1)\n\n    def get_remaining_warriors_after_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 1\n        return get_remaining_warriors_after_attack_and_attack(i - 1)\n\n    def get_remaining_strength_after_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return a[0]\n        return a[i] + get_remaining_strength_after_attack_and_attack(i - 1)\n\n    def get_remaining_arrows_after_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 0\n        return get_remaining_arrows_after_attack_and_attack_and_attack(i - 1)\n\n    def get_remaining_warriors_after_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 1\n        return get_remaining_warriors_after_attack_and_attack_and_attack(i - 1)\n\n    def get_remaining_strength_after_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return a[0]\n        return a[i] + get_remaining_strength_after_attack_and_attack_and_attack(i - 1)\n\n    def get_remaining_arrows_after_attack_and_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 0\n        return get_remaining_arrows_after_attack_and_attack_and_attack_and_attack(i - 1)\n\n    def get_remaining_warriors_after_attack_and_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 1\n        return get_remaining_warriors_after_attack_and_attack_and_attack_and_attack(i - 1)\n\n    def get_remaining_strength_after_attack_and_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return a[0]\n        return a[i] + get_remaining_strength_after_attack_and_attack_and_attack_and_attack(i - 1)\n\n    def get_remaining_arrows_after_attack_and_attack_and_attack_and_attack_and_attack(i: int) -> int:\n        if i == 0:\n            return 0\n        return get_remaining_arrows_after_"
    },
    {
        "number": 2290,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(node, visited):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    harmonious = True\n    for i in range(1, n + 1):\n        visited = set()\n        dfs(i, visited)\n        if len(visited)!= n:\n            harmonious = False\n            break\n\n    if harmonious:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 2291,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    a.sort()\n    return str(a[0] ^ a[1])"
    },
    {
        "number": 2292,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = list(map(int, stdin.split('\\n')[3].split()))\n\n        def is_valid(a: list, b: list) -> bool:\n            for i in range(len(a)):\n                if a[i]!= b[i]:\n                    return False\n            return True\n\n        def swap_prefix_suffix(a: list, k: int) -> list:\n            prefix = a[:k]\n            suffix = a[k:]\n            return prefix + suffix\n\n        def is_valid_after_swap(a: list, b: list, k: int) -> bool:\n            a_after_swap = swap_prefix_suffix(a, k)\n            return is_valid(a_after_swap, b)\n\n        for k in range(1, len(a) // 2 + 1):\n            if is_valid_after_swap(a, b, k):\n                return \"Yes\"\n\n        return \"No\"\n\n    return \"No\""
    },
    {
        "number": 2293,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    stores = [list(map(int, stdin.split())) for _ in range(m)]\n    swiper_bought = [set(map(int, stdin.split())) for _ in range(m)]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def beat_swiper(a, b):\n        return lcm(a, b) > lcm(swiper_bought[b - 1], swiper_bought[a - 1])\n\n    for i in range(1, m + 1):\n        for a in stores[i - 1]:\n            if beat_swiper(i, a):\n                return \"possible\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 2294,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    queries = []\n    for _ in range(n):\n        query = list(map(int, stdin.split()[1:]))\n        queries.append(query)\n\n    def add(multiset, value, moment):\n        if value not in multiset:\n            multiset[value] = []\n        multiset[value].append(moment)\n\n    def remove(multiset, value, moment):\n        if value in multiset:\n            multiset[value].remove(moment)\n\n    def count(multiset, value, moment):\n        if value in multiset:\n            return len(multiset[value])\n        return 0\n\n    def travel(multiset, moment):\n        for value, moments in multiset.items():\n            if moment in moments:\n                moments.remove(moment)\n\n    def query(multiset, value, moment):\n        if value in multiset:\n            return len(multiset[value])\n        return 0\n\n    for query in queries:\n        type_ = query[0]\n        moment = query[1]\n        value = query[2]\n\n        if type_ == 1:\n            add(multiset, value, moment)\n        elif type_ == 2:\n            remove(multiset, value, moment)\n        elif type_ == 3:\n            travel(multiset, moment)\n        else:\n            print(query(multiset, value, moment))\n\n    return \"\"\n"
    },
    {
        "number": 2295,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    l, r = random.sample(range(1, n+1), 2)\n    if l > r:\n        l, r = r, l\n\n    unique_count = 0\n    for i in range(l, r+1):\n        unique_count += len(set(a[i-1:r+1]))\n\n    return str(unique_count)"
    },
    {
        "number": 2296,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        polygon.append((x, y))\n\n    def rotate(polygon, angle):\n        for _ in range(angle // 90):\n            polygon.append(polygon.pop(0))\n        return polygon\n\n    def is_convex(polygon):\n        return all(polygon[i][0] * (polygon[i + 1][1] - polygon[i][1]) > polygon[i][0] * (polygon[i + 1][0] - polygon[i][0]) for i in range(len(polygon) - 1))\n\n    def is_convex_polygon(polygon):\n        return is_convex(polygon) and len(polygon) >= 3\n\n    def is_convex_polygon_with_n_vertices(polygon, n):\n        return is_convex_polygon(polygon) and len(polygon) == n\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density(polygon, n):\n        return is_convex_polygon_with_n_vertices(polygon, n) and all(abs(polygon[i][0] - polygon[i + 1][0]) < 1e-8 for i in range(len(polygon) - 1))\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness(polygon, n):\n        return is_convex_polygon_with_n_vertices_and_uniform_density(polygon, n) and all(abs(polygon[i][1] - polygon[i + 1][1]) > 1e-8 for i in range(len(polygon) - 1))\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity(polygon, n):\n        return is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness(polygon, n) and is_convex(polygon)\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices(polygon, n):\n        return is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity(polygon, n) and len(polygon) == n\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices_and_uniform_density(polygon, n):\n        return is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices(polygon, n) and all(abs(polygon[i][0] - polygon[i + 1][0]) < 1e-8 for i in range(len(polygon) - 1))\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices_and_uniform_density_and_positive_thickness(polygon, n):\n        return is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices_and_uniform_density(polygon, n) and all(abs(polygon[i][1] - polygon[i + 1][1]) > 1e-8 for i in range(len(polygon) - 1))\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity(polygon, n):\n        return is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices_and_uniform_density_and_positive_thickness(polygon, n) and is_convex(polygon)\n\n    def is_convex_polygon_with_n_vertices_and_uniform_density_and_positive_thickness_and_strict_convexity_and_n_vertices"
    },
    {
        "number": 2297,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = [i * (-1) ** i for i in range(1, n + 1)]\n    queries = [list(map(int, stdin.split())) for _ in range(q)]\n\n    for l, r in queries:\n        print(sum(a[l - 1:r + 1]))"
    },
    {
        "number": 2298,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mod_inverse(a: int, m: int) -> int:\n        if m == 1:\n            return 1\n        else:\n            return mod_inverse(m, a) * (a % m) % m\n\n    def count_pairs(a: int, b: int, l: int, r: int) -> int:\n        count = 0\n        for x in range(l, r + 1):\n            if ((x % a) % b)!= ((x % b) % a):\n                count += 1\n        return count\n\n    def main() -> None:\n        t = int(stdin.readline().strip())\n        for _ in range(t):\n            a, b, q = map(int, stdin.readline().strip().split())\n            queries = [tuple(map(int, stdin.readline().strip().split())) for _ in range(q)]\n\n            mod_a = mod_inverse(a, b)\n            mod_b = mod_inverse(b, a)\n\n            result = [0] * q\n            for i, (l, r) in enumerate(queries):\n                result[i] = count_pairs(a, b, l, r)\n\n            for i in range(q):\n                print(result[i])\n\n    main()\n    return \"\"\n"
    },
    {
        "number": 2299,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = [list(map(int, stdin.split()[i].split())) for i in range(1, n + 1)]\n    k = int(stdin.split()[n + 1])\n    result = []\n\n    for i in range(k):\n        l, r = map(int, stdin.split()[n + 2 + i].split())\n        for j in range(m):\n            if a[l - 1][j] > a[r - 1][j]:\n                result.append(\"Yes\")\n            else:\n                result.append(\"No\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2300,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n\n    for i in range(m):\n        t = int(stdin.split()[0])\n        if t == 1:\n            x, v = map(int, stdin.split()[1:])\n            queries.append((x - 1, v))\n        elif t == 2:\n            l, r = map(int, stdin.split()[1:])\n            queries.append((l - 1, r - l + 1))\n        elif t == 3:\n            l, r, d = map(int, stdin.split()[1:])\n            queries.append((l - 1, r - l + 1, d))\n\n    def f(x):\n        if x == 0:\n            return 1\n        else:\n            return f(x - 1) - 1 + f(x - 2)\n\n    def sum_f(l, r):\n        return sum(f(x) * a[l + x] for x in range(l, r + 1))\n\n    def sum_f_d(l, r, d):\n        return sum(f(x) * (a[l + x] + d) for x in range(l, r + 1))\n\n    result = []\n    for query in queries:\n        if query[0] == 0:\n            result.append(sum_f(query[1], query[2]))\n        elif query[0] == 1:\n            result.append(sum_f(query[1], query[2]))\n        elif query[0] == 2:\n            result.append(sum_f_d(query[1], query[2], query[3]))\n        else:\n            result.append(0)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2301,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    cheap_prices = [a[0]]\n    for i in range(1, n):\n        if a[i] < cheap_prices[-1] + 2:\n            cheap_prices.append(a[i])\n        else:\n            break\n\n    max_cheap = len(cheap_prices)\n    max_price = max(cheap_prices)\n\n    result = []\n    for i in range(n):\n        if a[i] == max_price:\n            result.append(i + 1)\n\n    return f\"{max_cheap}\\n{result}\""
    },
    {
        "number": 2302,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    milestones = []\n\n    for _ in range(q):\n        s, t, u = map(int, stdin.split())\n        if s == u:\n            milestones.append((s, t, 1))\n        else:\n            milestones.append((s, t, u))\n\n    milestones.sort(key=lambda x: (x[0], x[1]))\n    milestones = [x for x in milestones if x[2]!= 0]\n\n    turns = 0\n    for s, t, u in milestones:\n        turns += t\n        if turns >= a[s - 1]:\n            return str(turns)\n\n    return str(turns)\n"
    },
    {
        "number": 2303,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    words.reverse()\n    return''.join(words)"
    },
    {
        "number": 2304,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pieces = []\n    for _ in range(m):\n        l, r, d = map(int, stdin.split())\n        pieces.append((l, r, d))\n\n    def is_consistent(x: int) -> bool:\n        for l, r, d in pieces:\n            if l <= x <= r:\n                return False\n            if r <= x <= l:\n                return False\n        return True\n\n    for x in range(1, 10**9 + 1):\n        if is_consistent(x):\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 2305,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = list(map(int, stdin.split()[1:]))\n    edges = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.split()[i + 2].split(','))\n        edges.append((a, b))\n        edges.append((b, a))\n\n    def dfs(u, color, visited):\n        visited[u] = True\n        for v, c in edges:\n            if c == color and not visited[v]:\n                dfs(v, color, visited)\n\n    count = 0\n    for color in colors:\n        visited = [False] * (n + 1)\n        dfs(1, color, visited)\n        count += sum(visited)\n\n    return '\\n'.join(map(str, count))"
    },
    {
        "number": 2306,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *t_vs = map(int, stdin.split())\n    t_vs = list(zip(t_vs[::2], t_vs[1::2]))\n    t_vs.sort(key=lambda x: x[0])\n\n    max_distance = 0\n    current_distance = 0\n    current_speed = 0\n\n    for t, v in t_vs:\n        if current_speed + v <= 0:\n            current_speed = 0\n            current_distance += current_distance\n        else:\n            current_speed += v\n\n        current_distance += t\n        max_distance = max(max_distance, current_distance)\n\n    return f\"{max_distance:.3f}\"\n"
    },
    {
        "number": 2307,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    even_count = 0\n    odd_count = 0\n\n    for num in a:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n\n    if even_count > odd_count:\n        return \"READY FOR BATTLE\"\n    else:\n        return \"NOT READY\""
    },
    {
        "number": 2308,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        x, y = stdin.split()[1:]\n        k = 0\n        while True:\n            s = int(x, 2) + int(y, 2) * (1 << k)\n            rev = bin(s)[2:].zfill(len(x))\n            if rev < rev[::-1]:\n                break\n            k += 1\n        print(k)"
    },
    {
        "number": 2309,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    words = [stdin.split()[1:] for _ in range(n)]\n    beautiful_lyrics = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if words[i][0] == words[j][0]:\n                if words[i][1] == words[j][1]:\n                    if words[i][2] == words[j][2]:\n                        if words[i][3] == words[j][3]:\n                            beautiful_lyrics.append(f\"{words[i][0]} {words[j][0]}\")\n\n    return \"\\n\".join(beautiful_lyrics[:m])"
    },
    {
        "number": 2310,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_count = int(stdin.split()[0])\n    for _ in range(test_count):\n        m, k = map(int, stdin.split()[1:])\n        a = list(map(int, stdin.split()[2:2+k]))\n        observations = []\n        for _ in range(m - 1):\n            t, r = map(int, stdin.split()[2+k:])\n            observations.append((t, r))\n        result = []\n        for i in range(k):\n            if i == 0:\n                result.append(\"Y\")\n            elif i == k - 1:\n                result.append(\"Y\")\n            else:\n                result.append(\"N\")\n        print(\"\".join(result))"
    },
    {
        "number": 2311,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    c = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            c[i][j] = a[i] * b[j]\n\n    count = 0\n    for i in range(n - k + 1):\n        for j in range(m - k + 1):\n            sub_c = [[0] * m for _ in range(n)]\n            for x in range(k):\n                for y in range(k):\n                    sub_c[x][y] = c[i + x][j + y]\n            if all(all(x == 1) for x in row) and all(all(x == 1) for row in sub_c):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2312,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        b = list(map(int, stdin.split('\\n')[2].split()))\n        a = [2**bi for bi in b]\n        for i in range(n-3):\n            for j in range(i+2, n):\n                if a[i] + a[j] == a[i+1] + a[j-1]:\n                    print('YES')\n                    return\n        print('NO')\n    return"
    },
    {
        "number": 2313,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    c.sort()\n    p = 1\n    q = 1\n    for i in range(n):\n        p *= c[i]\n        q *= (n - i)\n    return str((p * pow(q, -1, 998244353)) % 998244353)"
    },
    {
        "number": 2314,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    adhami_picture = [list(map(str, stdin.split())) for _ in range(n)]\n\n    def max_area(sub_rectangle: list[list[str]]) -> int:\n        max_area = 0\n        for i in range(len(sub_rectangle)):\n            for j in range(len(sub_rectangle[i])):\n                if sub_rectangle[i][j] == 'G':\n                    max_area = max(max_area, 1)\n                elif sub_rectangle[i][j] == 'R':\n                    max_area = max(max_area, 2)\n                elif sub_rectangle[i][j] == 'Y':\n                    max_area = max(max_area, 3)\n                elif sub_rectangle[i][j] == 'B':\n                    max_area = max(max_area, 4)\n        return max_area\n\n    def is_valid_sub_rectangle(sub_rectangle: list[list[str]]) -> bool:\n        for i in range(len(sub_rectangle)):\n            for j in range(len(sub_rectangle[i])):\n                if sub_rectangle[i][j] not in {'G', 'R', 'Y', 'B'}:\n                    return False\n        return True\n\n    def is_valid_sub_square(sub_rectangle: list[list[str]]) -> bool:\n        for i in range(len(sub_rectangle)):\n            for j in range(len(sub_rectangle[i])):\n                if sub_rectangle[i][j] == 'G':\n                    if i == 0 or sub_rectangle[i - 1][j] == 'G':\n                        if j == 0 or sub_rectangle[i][j - 1] == 'G':\n                            return True\n        return False\n\n    def is_valid_logo(sub_rectangle: list[list[str]]) -> bool:\n        return is_valid_sub_rectangle(sub_rectangle) and is_valid_sub_square(sub_rectangle)\n\n    max_area_logo = 0\n    for _ in range(q):\n        r1, c1, r2, c2 = map(int, stdin.split())\n        sub_rectangle = [row[c1 - 1:c2] for row in adhami_picture[r1 - 1:r2]]\n        if is_valid_logo(sub_rectangle):\n            max_area_logo = max(max_area_logo, max_area(sub_rectangle))\n\n    return str(max_area_logo)\n"
    },
    {
        "number": 2315,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    result = []\n\n    for _ in range(queries):\n        l, r = map(int, stdin.split()[1:])\n        for x in range(l, r + 1):\n            if x % l == 0:\n                for y in range(l, r + 1):\n                    if y % x == 0 and y!= x:\n                        result.append(f\"{x} {y}\")\n                        break\n        result.append(\"\\n\")\n\n    return \"\".join(result)"
    },
    {
        "number": 2316,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        x, n, m = map(int, stdin.split()[1:])\n        if x <= 0:\n            print(\"YES\")\n        else:\n            def cast_spell(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell(h // 2) + 10\n\n            def cast_spell_2(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_2(h - 10)\n\n            def cast_spell_3(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_3(h - 10)\n\n            def cast_spell_4(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_4(h - 10)\n\n            def cast_spell_5(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_5(h - 10)\n\n            def cast_spell_6(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_6(h - 10)\n\n            def cast_spell_7(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_7(h - 10)\n\n            def cast_spell_8(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_8(h - 10)\n\n            def cast_spell_9(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_9(h - 10)\n\n            def cast_spell_10(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_10(h - 10)\n\n            def cast_spell_11(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_11(h - 10)\n\n            def cast_spell_12(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_12(h - 10)\n\n            def cast_spell_13(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_13(h - 10)\n\n            def cast_spell_14(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_14(h - 10)\n\n            def cast_spell_15(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_15(h - 10)\n\n            def cast_spell_16(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_16(h - 10)\n\n            def cast_spell_17(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_17(h - 10)\n\n            def cast_spell_18(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_18(h - 10)\n\n            def cast_spell_19(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_19(h - 10)\n\n            def cast_spell_20(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_20(h - 10)\n\n            def cast_spell_21(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_21(h - 10)\n\n            def cast_spell_22(h: int) -> int:\n                if h <= 0:\n                    return 0\n                else:\n                    return cast_spell_22(h - 10)\n\n            def"
    },
    {
        "number": 2317,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    a_points = list(map(int, stdin.split()))\n    b_points = list(map(int, stdin.split()))\n    l_points = list(map(int, stdin.split()))\n\n    a_points.sort()\n    b_points.sort()\n    l_points.sort()\n\n    left_points = []\n    right_points = []\n\n    for i in range(n):\n        if a_points[i] < b:\n            left_points.append(i + 1)\n\n    for i in range(m):\n        if b_points[i] < a:\n            right_points.append(i + 1)\n\n    left_points.sort()\n    right_points.sort()\n\n    for i in range(len(left_points)):\n        for j in range(len(right_points)):\n            if left_points[i] + right_points[j] == n + m:\n                return f\"{left_points[i]} {right_points[j]}\"\n\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 2318,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for i in range(n):\n        s, t = stdin.split()[1:3]\n        pairs.append((s, t))\n    result = []\n    for s, t in pairs:\n        if len(t) > len(s):\n            result.append(\"NO\")\n        else:\n            result.append(\"YES\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 2319,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    s = stdin.split()[2]\n    t = stdin.split()[3]\n\n    def rotate(s: str, l: int, r: int) -> str:\n        return s[r:] + s[:l] + s[l:r]\n\n    def is_substring(s: str, t: str) -> bool:\n        return t in s\n\n    def min_operations(s: str, t: str) -> int:\n        if s == t:\n            return 0\n\n        if not is_substring(s, t):\n            return -1\n\n        min_operations = float('inf')\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if is_substring(s[i:j], t):\n                    min_operations = min(min_operations, j - i)\n\n        return min_operations\n\n    def min_operations_helper(s: str, t: str, l: int, r: int) -> int:\n        if l == r:\n            return 0\n\n        mid = (l + r) // 2\n        left_operations = min_operations_helper(s, t, l, mid)\n        right_operations = min_operations_helper(s, t, mid, r)\n\n        if s[l:r] == t:\n            return min(left_operations, right_operations)\n\n        if s[l:r] < t:\n            return left_operations + min_operations_helper(s, t, mid, r)\n        else:\n            return right_operations + min_operations_helper(s, t, l, mid)\n\n    min_operations_result = min_operations(s, t)\n    if min_operations_result == -1:\n        print(-1)\n    else:\n        print(min_operations_helper(s, t, 0, len(s)))\n\n\ndef"
    },
    {
        "number": 2320,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    s = stdin.split()[2]\n    t = stdin.split()[3]\n\n    moves = 0\n    for i in range(1, n + 1):\n        if s[i - 1] == t[i - 1]:\n            moves += 1\n        else:\n            break\n\n    if moves == n:\n        return str(moves)\n    else:\n        return -1\n\ndef"
    },
    {
        "number": 2321,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        s = stdin.split('\\n')[2]\n        operations = []\n        for i in range(n):\n            if s[i] == '>':\n                operations.append('>')\n            elif s[i] == '<':\n                operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n        operations.append('>')\n        operations.append('<')\n       "
    },
    {
        "number": 2323,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    q = int(stdin.split('\\n')[2])\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[3:]]\n\n    def count_distinct_pitches(l, r):\n        pitches = set()\n        for i in range(n):\n            for j in range(l, r + 1):\n                pitches.add(s[i][j])\n        return len(pitches)\n\n    result = [count_distinct_pitches(l, r) for l, r in queries]\n    return''.join(map(str, result))"
    },
    {
        "number": 2324,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    palindromic_chars = [0] * n\n    for i in range(n):\n        for j in range(i, n):\n            if s[i:j+1] == s[i:j+1][::-1]:\n                palindromic_chars[i] += 1\n                palindromic_chars[j] += 1\n                if i > 0:\n                    palindromic_chars[i-1] += 1\n                if j < n-1:\n                    palindromic_chars[j+1] += 1\n    return''.join(map(str, palindromic_chars))"
    },
    {
        "number": 2325,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def y_factorization(x: int, y: int) -> List[int]:\n        factors = []\n        for i in range(1, y + 1):\n            if x % i == 0:\n                factors.append(i)\n        return factors\n\n    def count_y_factorizations(x: int, y: int) -> int:\n        y_factors = y_factorization(x, y)\n        return len(set(y_factors))\n\n    def count_pairwise_distinct_arrays(x: int, y: int) -> int:\n        y_factors = y_factorization(x, y)\n        return len(set(y_factors))\n\n    def count_y_factorizations_and_pairwise_distinct_arrays(x: int, y: int) -> int:\n        return (count_y_factorizations(x, y) * (count_pairwise_distinct_arrays(x, y) - 1)) % (10**9 + 7)\n\n    def main() -> None:\n        t = int(stdin.split()[0])\n        for _ in range(t):\n            x, y = map(int, stdin.split()[1:])\n            print(count_y_factorizations_and_pairwise_distinct_arrays(x, y))\n\n    main()\n    return \"\"\n"
    },
    {
        "number": 2326,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def is_good(arr):\n        return arr[0] == n - 1 and arr[0] > 0\n\n    def count_good_subsequences(arr):\n        count = 0\n        for i in range(1, len(arr)):\n            if is_good(arr[i - 1:i + 1]):\n                count += 1\n        return count\n\n    good_subsequences = [arr for arr in a if is_good(arr)]\n    count = sum(count_good_subsequences(arr) for arr in good_subsequences)\n    return str(count % 998244353)"
    },
    {
        "number": 2327,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        sequence = [int(x) for x in stdin.split()[2:]]\n        unfairness = 0\n        for i in range(1, len(sequence)):\n            unfairness += abs(sequence[i] - sequence[i - 1])\n        print(unfairness)"
    },
    {
        "number": 2328,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n, k = map(int, stdin.split()[1:])\n        a = list(map(int, stdin.split()[2:]))\n        a.sort()\n        d = [abs(a[i] - a[i + 1]) for i in range(n - 1)]\n        d.sort()\n        print(d[k])"
    },
    {
        "number": 2329,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    towers = [[] for _ in range(m)]\n    for i in range(n):\n        towers[tower_index - 1].append(i + 1)\n    towers.sort(key=lambda x: x[0], reverse=True)\n    return \" \".join(map(str, [len(tower) for tower in towers]))"
    },
    {
        "number": 2330,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        n, m = map(int, stdin.split()[1:])\n        a = list(map(int, stdin.split()[2:]))\n\n        # check if there is a solution\n        if not any(a[i] + a[j] <= a[k] for i in range(n) for j in range(i+1, n) for k in range(n) if i!= j and i!= k and j!= k):\n            print(-1)\n            continue\n\n        # sort fridges by weight\n        a.sort()\n\n        # find the minimum total cost\n        total_cost = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                total_cost += a[i] + a[j]\n\n        # find the minimum number of chains\n        min_chains = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                min_chains += 1\n                if a[i] + a[j] > a[min_chains-1]:\n                    break\n\n        # output the solution\n        print(total_cost)\n        for i in range(min_chains):\n            for j in range(i+1, min_chains):\n                print(i+1, j+1)"
    },
    {
        "number": 2331,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b = map(int, stdin.split()[1:])\n        if a > b:\n            a, b = b, a\n        white_count = 0\n        black_count = 0\n        for i in range(a, b + 1):\n            if i == 0:\n                white_count += 1\n            elif i >= a and i - a in range(a, b + 1):\n                white_count += 1\n            elif i >= b and i - b in range(a, b + 1):\n                white_count += 1\n            else:\n                black_count += 1\n        if white_count == 0:\n            print(\"Infinite\")\n        else:\n            print(\"Finite\")\n    return \"\"\n\n\ndef"
    },
    {
        "number": 2332,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    words = stdin.split()[2:2+n]\n    a = list(map(int, stdin.split()[2+n:2+n+k]))\n    groups = []\n    for i in range(k):\n        x, *indices = map(int, stdin.split()[2+n+k+i*x:2+n+k+(i+1)*x])\n        groups.append((x, indices))\n\n    message = stdin.split()[2+n+k+k*x:2+n+k+k*x+m]\n\n    def same_meaning_group(word):\n        for group in groups:\n            if word in group[1]:\n                return group[0]\n        return -1\n\n    def min_cost(word):\n        if word in message:\n            return a[message.index(word)]\n        else:\n            return a[same_meaning_group(word)]\n\n    return str(sum(min_cost(word) for word in words))"
    },
    {
        "number": 2333,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] + a[j] == n:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2334,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *a = map(int, stdin.split())\n    x, f = map(int, input().split())\n\n    total_fee = 0\n    for i in range(N):\n        if a[i] > x:\n            total_fee += (a[i] - x) * f\n\n    return str(total_fee)"
    },
    {
        "number": 2335,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for i in range(n):\n        x, color = map(int, stdin.split()[i+1].split())\n        points.append((x, color))\n\n    red_points = [point for point in points if point[1] == 'R']\n    blue_points = [point for point in points if point[1] == 'B']\n    green_points = [point for point in points if point[1] == 'G']\n\n    red_points.sort()\n    blue_points.sort()\n    green_points.sort()\n\n    min_cost = float('inf')\n    for i in range(len(red_points)):\n        for j in range(i+1, len(red_points)):\n            for k in range(j+1, len(red_points)):\n                for l in range(k+1, len(red_points)):\n                    for m in range(l+1, len(red_points)):\n                        for n in range(m+1, len(red_points)):\n                            for o in range(n+1, len(red_points)):\n                                for p in range(o+1, len(red_points)):\n                                    for q in range(p+1, len(red_points)):\n                                        for r in range(q+1, len(red_points)):\n                                            for s in range(r+1, len(red_points)):\n                                                for t in range(s+1, len(red_points)):\n                                                    for u in range(t+1, len(red_points)):\n                                                        for v in range(u+1, len(red_points)):\n                                                            for w in range(v+1, len(red_points)):\n                                                                for x in range(w+1, len(red_points)):\n                                                                    for y in range(x+1, len(red_points)):\n                                                                        for z in range(y+1, len(red_points)):\n                                                                            for a in range(z+1, len(red_points)):\n                                                                                for b in range(a+1, len(red_points)):\n                                                                                    for c in range(b+1, len(red_points)):\n                                                                                        for d in range(c+1, len(red_points)):\n                                                                                            for e in range(d+1, len(red_points)):\n                                                                                                for f in range(e+1, len(red_points)):\n                                                                                                    for g in range(f+1, len(red_points)):\n                                                                                                        for h in range(g+1, len(red_points)):\n                                                                                                            for i in range(h+1, len(red_points)):\n                                                                                                                for j in range(i+1, len(red_points)):\n                                                                                                                    for k in range(j+1, len(red_points)):\n                                                                                                                        for l in range(k+1, len(red_points)):\n                                                                                                                            for m in range(l+1, len(red_points)):\n                                                                                                                                for n in range(m+1, len(red_points)):\n                                                                                                                                    for o in range(n+1, len(red_points)):\n                                                                                                                                        for p in range(o+1, len(red_points)):\n                                                                                                                                            for q in range(p+1, len(red_points)):\n                                                                                                                                                for r in range(q+1, len(red_points)):\n                                                                                                                                                    for s in range(r+1, len(red_points)):\n                                                                                                                                                        for t in range(s+1, len(red_points)):\n                                                                                                                                                            for u in range(t+1, len(red_points)):\n                                                                                                                                                                for v in range(u+1, len(red_points)):\n                                                                                                                                                                    for w in range(v+1, len(red_points)):\n                                                                                                                                                                        for x in range(w+1, len(red_points)):\n                                                                                                                                                                            for y in range(x+1, len(red_points)):\n                                                                                                                                                                                for z in range(y+1, len(red_points)):\n                                                                                                                                                                                    for a in range(z+1, len(red_points)):\n                                                                                                                                                                                        for b in range(a+1, len(red_points)):\n                                                                                                                                                                                            for c in range(b+1, len(red_points)):\n                                                                                                                                                                                                for d in range(c+1, len(red_points)):\n                                                                                                                                                                                                    for e in range(d+1, len(red_points)):\n                                                                                                                                                                                                        for f in range(e+1, len(red_points)):\n                                                                                                                                                                                                            for g in range(f+1, len(red_points)):\n                                                                                                                                                                                                                for h in range(g+1, len(red"
    },
    {
        "number": 2336,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split())\n    recipes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    questions = [list(map(int, line.split())) for line in stdin.split('\\n')[n+1:]]\n\n    def is_admissible(temp: int) -> bool:\n        count = 0\n        for recipe in recipes:\n            if recipe[0] <= temp <= recipe[1]:\n                count += 1\n        return count >= k\n\n    result = []\n    for a, b in questions:\n        count = 0\n        for temp in range(a, b+1):\n            if is_admissible(temp):\n                count += 1\n        result.append(str(count))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2337,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n    b = list(map(int, stdin.split()[2+n:]))\n    \n    def simplify(c: int) -> int:\n        for d in range(c+1, 10**6+1):\n            if all(a[i] <= d for i in range(n)):\n                return d\n        return 10**6+1\n    \n    def count_problems(b: List[int]) -> int:\n        count = 0\n        for c in b:\n            count += simplify(c)\n        return count\n    \n    def count_good_problems(b: List[int]) -> int:\n        count = 0\n        for c in b:\n            count += simplify(c)\n            if count >= n:\n                return count\n        return count\n    \n    good_problems = count_good_problems(b)\n    if good_problems >= m:\n        return \"0\"\n    else:\n        return str(good_problems)"
    },
    {
        "number": 2338,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    bombs = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[1].split())\n        bombs.append((x, y))\n\n    def is_valid(x, y, bombs):\n        for b in bombs:\n            if abs(b[0] - x) <= 1 and abs(b[1] - y) <= 1:\n                return False\n        return True\n\n    def is_valid_path(x, y, bombs):\n        for b in bombs:\n            if abs(b[0] - x) <= 1 and abs(b[1] - y) <= 1:\n                return False\n        return True\n\n    def is_valid_container(x, y, bombs):\n        for b in bombs:\n            if abs(b[0] - x) <= 1 and abs(b[1] - y) <= 1:\n                return False\n        return True\n\n    def is_valid_operation(x, y, bombs):\n        if not is_valid(x, y, bombs):\n            return False\n        if not is_valid_path(x, y, bombs):\n            return False\n        if not is_valid_container(x, y, bombs):\n            return False\n        return True\n\n    def get_valid_operations(x, y, bombs):\n        operations = []\n        if is_valid_operation(x, y, bombs):\n            operations.append((1, \"R\", 1))\n            operations.append((1, \"U\", 1))\n            operations.append((2, \"R\"))\n            operations.append((2, \"U\"))\n            operations.append((2, \"L\"))\n            operations.append((2, \"D\"))\n            operations.append((3, \"R\"))\n            operations.append((3, \"U\"))\n            operations.append((3, \"L\"))\n            operations.append((3, \"D\"))\n        return operations\n\n    def get_shortest_path(x, y, bombs):\n        queue = [(x, y, 0)]\n        visited = set()\n        while queue:\n            x, y, steps = queue.pop(0)\n            if (x, y) == (0, 0):\n                return steps\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nx, ny = x + dx, y + dy\n                if is_valid_operation(nx, ny, bombs) and (nx, ny) not in visited:\n                    queue.append((nx, ny, steps + 1))\n        return -1\n\n    def get_shortest_operations(bombs):\n        shortest_path = float('inf')\n        shortest_operations = []\n        for x in range(-10000, 10001):\n            for y in range(-10000, 10001):\n                if is_valid(x, y, bombs):\n                    steps = get_shortest_path(x, y, bombs)\n                    if steps < shortest_path:\n                        shortest_path = steps\n                        shortest_operations = get_valid_operations(x, y, bombs)\n        return shortest_operations\n\n    shortest_operations = get_shortest_operations(bombs)\n    return str(len(shortest_operations)) + \"\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), shortest_operations))"
    },
    {
        "number": 2339,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_smaller(a, b):\n        for i in range(len(a)):\n            if a[i]!= b[i]:\n                return a[i] < b[i]\n        return len(a) < len(b)\n\n    def lexicographically_maximal_sequence(a):\n        b = [1] * len(a)\n        for i in range(len(a)):\n            b[i] = gcd(b[i], a[i])\n        return b\n\n    def lexicographically_maximal_permutation(a):\n        b = lexicographically_maximal_sequence(a)\n        return [b.index(a[i]) for i in range(len(a))]\n\n    def lexicographically_maximal_permutation_with_gcd(a):\n        b = lexicographically_maximal_sequence(a)\n        c = [gcd(b[i], a[i]) for i in range(len(a))]\n        return [b.index(a[i]) for i in range(len(a))], c\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller(a):\n        b, c = lexicographically_maximal_permutation_with_gcd(a)\n        return b, c, is_smaller(a, b)\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index(a):\n        b, c, is_smaller = lexicographically_maximal_permutation_with_gcd_and_is_smaller(a)\n        return b, c, is_smaller, a.index(b)\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd(a):\n        b, c, is_smaller, index = lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index(a)\n        return b, c, is_smaller, index, gcd(b[index], a[index])\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller(a):\n        b, c, is_smaller, index, gcd_a = lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd(a)\n        return b, c, is_smaller, index, gcd_a, is_smaller(a, b)\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller_and_index(a):\n        b, c, is_smaller, index, gcd_a, is_smaller_b = lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller(a)\n        return b, c, is_smaller, index, gcd_a, is_smaller_b, a.index(b)\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller_and_index_and_gcd(a):\n        b, c, is_smaller, index, gcd_a, is_smaller_b, index_b = lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller_and_index(a)\n        return b, c, is_smaller, index, gcd_a, is_smaller_b, index_b, gcd(b[index_b], a[index_b])\n\n    def lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller(a):\n        b, c, is_smaller, index, gcd_a, is_smaller_b, index_b, gcd_b = lexicographically_maximal_permutation_with_gcd_and_is_smaller_and_index_and_gcd_and_is_smaller_and_index_and_gcd(a)\n        return b, c, is_smaller, index, gcd_a, is_smaller_b, index_b, gcd_b,"
    },
    {
        "number": 2340,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split('\\n')[0])\n    for _ in range(queries):\n        h, n = map(int, stdin.split('\\n')[1].split())\n        p = list(map(int, stdin.split('\\n')[2].split()))\n        p.sort(reverse=True)\n        crystals = 0\n        for i in range(n):\n            if p[i] == h:\n                crystals += 1\n            elif p[i] - 1 == h:\n                crystals += 2\n            elif p[i] - 2 == h:\n                crystals += 3\n            else:\n                crystals += 4\n        print(crystals)"
    },
    {
        "number": 2341,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    scraps = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def is_valid_pattern(pattern):\n        for i in range(n):\n            for j in range(m):\n                if pattern[i][j]!= scraps[i][j]:\n                    return False\n        return True\n\n    def count_valid_patterns(pattern):\n        count = 1\n        for i in range(n):\n            for j in range(m):\n                if pattern[i][j] == scraps[i][j]:\n                    count += 1\n        return count\n\n    valid_patterns = [pattern for pattern in itertools.product('abcde', repeat=m) if is_valid_pattern(pattern)]\n    valid_pattern_counts = [count_valid_patterns(pattern) for pattern in valid_patterns]\n\n    return str(max(valid_pattern_counts))"
    },
    {
        "number": 2342,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        maze = [list(line.strip()) for line in stdin.split('\\n')[2:2+n]]\n        visited = set()\n        for i in range(n):\n            for j in range(m):\n                if maze[i][j] == 'G':\n                    visited.add((i, j))\n        if len(visited) == 1:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 2343,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split()[1:])\n        if n == 1:\n            print(\"YES 0\")\n        elif n == 2:\n            print(\"YES 1\")\n        else:\n            a = 2 ** n\n            b = a // 2\n            c = a - b\n            d = b + c\n            e = b + b\n            f = b + c + c\n            g = b + b + b\n            h = b + b + c + c\n            i = b + b + b + b\n            j = b + b + b + c + c\n            k = b + b + b + b + b\n            l = b + b + b + b + c + c\n            m = b + b + b + b + b + b\n            n = b + b + b + b + b + b + b\n            o = b + b + b + b + b + b + c + c\n            p = b + b + b + b + b + b + b + b\n            q = b + b + b + b + b + b + b + c + c\n            r = b + b + b + b + b + b + b + b + b\n            s = b + b + b + b + b + b + b + b + c + c\n            t = b + b + b + b + b + b + b + b + b + b\n            u = b + b + b + b + b + b + b + b + b + c + c\n            v = b + b + b + b + b + b + b + b + b + b + b\n            w = b + b + b + b + b + b + b + b + b + b + c + c\n            x = b + b + b + b + b + b + b + b + b + b + b + b\n            y = b + b + b + b + b + b + b + b + b + b + b + c + c\n            z = b + b + b + b + b + b + b + b + b + b + b + b + b\n            if k == 1:\n                print(\"YES 0\")\n            elif k == 2:\n                print(\"YES 1\")\n            else:\n                print(\"NO\")"
    },
    {
        "number": 2344,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    offers = []\n    for i in range(1, n+1):\n        a, b, k = map(int, stdin.split()[1:])\n        offers.append((a, b, k))\n    offers.sort(key=lambda x: (-x[0], -x[1], -x[2]))\n    max_price = 0\n    for i in range(n):\n        max_price += offers[i][0]\n        if max_price > 0:\n            break\n    return str(max_price)"
    },
    {
        "number": 2345,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        s = 0\n        for i in range(n):\n            s += a[i]\n            if s == 0:\n                break\n        if s == 0:\n            print(s)\n            print(a)\n        else:\n            print(s)\n            print(a[:s])"
    },
    {
        "number": 2346,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    parents = [int(x) - 1 for x in stdin.split()[1:]]\n    children = [int(x) for x in stdin.split()[2:]]\n\n    def dfs(vertex: int, parent: int, visited: set) -> None:\n        visited.add(vertex)\n        for child in children[vertex]:\n            if child not in visited:\n                dfs(child, vertex, visited)\n\n    def dfs_ancestors(vertex: int, visited: set) -> set:\n        visited.add(vertex)\n        for parent in parents[vertex]:\n            if parent not in visited:\n                visited.update(dfs_ancestors(parent, visited))\n        return visited\n\n    def delete_vertex(vertex: int) -> None:\n        non_root_vertices = [i for i in range(n) if parents[i]!= -1]\n        min_vertex = min(non_root_vertices, key=lambda x: children[x].index(vertex))\n        children[min_vertex].remove(vertex)\n        parents[vertex] = parents[min_vertex]\n\n    def delete_vertices(visited: set) -> None:\n        non_root_vertices = [i for i in range(n) if parents[i]!= -1]\n        for vertex in non_root_vertices:\n            if vertex not in visited:\n                delete_vertex(vertex)\n                visited.add(vertex)\n\n    visited = set()\n    for vertex in range(n):\n        if parents[vertex] == -1:\n            dfs(vertex, -1, visited)\n\n    delete_vertices(visited)\n\n    if not visited:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, visited))\n"
    },
    {
        "number": 2347,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        p, h = stdin.split('\\n')[1].split()\n        p = ''.join(random.sample(p, len(p)))\n        s1, s2 = random.sample('zyx', 2), ''\n        h = s1 + p + s2\n        if h == h_from_p(p):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\ndef"
    },
    {
        "number": 2348,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hex_number = int(stdin, 16)\n    if hex_number == 0:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 2349,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        if n % 2 == 0:\n            print(n // 2)\n        else:\n            print(n // 2 + 1)"
    },
    {
        "number": 2350,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for i in range(t):\n        x1, y1, x2, y2 = map(int, stdin.split('\\n')[i+1].split())\n        if x1 == x2 and y1 == y2:\n            print(1)\n        else:\n            def dfs(x, y, path):\n                if x == x2 and y == y2:\n                    return 1\n                if x > x2 or y > y2:\n                    return 0\n                if (x, y) in path:\n                    return 0\n                path.add((x, y))\n                return dfs(x+1, y, path) + dfs(x, y+1, path) + dfs(x+1, y+1, path)\n            print(dfs(x1, y1, set()))"
    },
    {
        "number": 2351,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, len_ = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    def count_ways(start: int, end: int) -> int:\n        if start == end:\n            return 1\n        if arr[start] == -1:\n            return 0\n        if arr[start] == arr[end]:\n            return 0\n        if arr[start] == -1 and arr[end] == -1:\n            return 0\n        if arr[start] == -1:\n            return count_ways(start + 1, end)\n        if arr[end] == -1:\n            return count_ways(start, end - 1)\n        if arr[start] == arr[end]:\n            return count_ways(start + 1, end - 1)\n        if arr[start] < arr[end]:\n            return count_ways(start + 1, end)\n        return count_ways(start, end - 1)\n\n    ways = 0\n    for i in range(n):\n        if arr[i] == -1:\n            ways += count_ways(i, i + len_ - 1)\n\n    return str(ways % 998244353)\n"
    },
    {
        "number": 2352,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i, j, k, r1, c1, r2, c2, snakes):\n        if k == 0:\n            snakes.append((r1, c1, r2, c2))\n            return\n        if i < 0 or i >= n or j < 0 or j >= m or (i, j) in visited:\n            return\n        visited.add((i, j))\n        dfs(i - 1, j, k - 1, r1, c1, r2, c2, snakes)\n        dfs(i + 1, j, k - 1, r1, c1, r2, c2, snakes)\n        dfs(i, j - 1, k - 1, r1, c1, r2, c2, snakes)\n        dfs(i, j + 1, k - 1, r1, c1, r2, c2, snakes)\n        dfs(i, j, k - 1, r1, c1, r2, c2, snakes)\n\n    n, m = map(int, stdin.split()[1].split())\n    visited = set()\n    snakes = []\n    for i in range(n):\n        for j in range(m):\n            if stdin[i][j]!= '.':\n                dfs(i, j, 26, 0, 0, 0, 0, snakes)\n    if snakes:\n        print(\"YES\")\n        print(len(snakes))\n        for snake in snakes:\n            print(snake[0], snake[1], snake[2], snake[3])\n    else:\n        print(\"NO\")\n\ndef"
    },
    {
        "number": 2353,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_time(time_str: str) -> int:\n        return int(time_str.replace(\" \", \"\"))\n\n    def get_minutes(time_str: str) -> int:\n        return int(time_str.replace(\":\", \"\"))\n\n    def get_seconds(time_str: str) -> int:\n        return int(time_str.replace(\":\", \"\").replace(\" \", \"\"))\n\n    def get_minutes_seconds(time_str: str) -> Tuple[int, int]:\n        minutes, seconds = time_str.split(\":\")\n        return get_minutes(minutes), get_seconds(seconds)\n\n    def get_minutes_seconds_from_time(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), get_seconds(seconds)\n\n    def get_minutes_seconds_from_time_str(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), get_seconds(seconds)\n\n    def get_minutes_seconds_from_time_str_with_seconds(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), get_seconds(seconds)\n\n    def get_minutes_seconds_from_time_str_with_seconds_and_milliseconds(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        milliseconds = int(seconds.split(\",\")[1])\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), milliseconds\n\n    def get_minutes_seconds_from_time_str_with_seconds_and_milliseconds_and_microseconds(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        milliseconds, microseconds = seconds.split(\",\")\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), int(milliseconds) * 1000 + int(microseconds)\n\n    def get_minutes_seconds_from_time_str_with_seconds_and_milliseconds_and_microseconds_and_nanoseconds(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        milliseconds, microseconds, nanoseconds = seconds.split(\",\")\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), int(milliseconds) * 1000 + int(microseconds) * 1000 + int(nanoseconds)\n\n    def get_minutes_seconds_from_time_str_with_seconds_and_milliseconds_and_microseconds_and_nanoseconds_and_time_zone(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        milliseconds, microseconds, nanoseconds = seconds.split(\",\")\n        time_zone = int(nanoseconds) // 1000000000\n        return get_minutes(hours) * 60 + get_minutes(minutes) + get_seconds(seconds), int(milliseconds) * 1000 + int(microseconds) * 1000 + int(nanoseconds)\n\n    def get_minutes_seconds_from_time_str_with_seconds_and_milliseconds_and_microseconds_and_nanoseconds_and_time_zone_and_daylight_saving_time(time_str: str) -> Tuple[int, int]:\n        hours, minutes_seconds = time_str.split(\":\")\n        minutes, seconds = minutes_seconds.split(\".\")\n        milliseconds, microseconds, nanoseconds = seconds.split(\",\")\n        time_zone = int(nanoseconds) // 1000000000"
    },
    {
        "number": 2354,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    for i in range(q):\n        x, y = map(int, stdin.split())\n        board[x - 1][y - 1] = i + 1\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 0:\n                board[i][j] = (i + j) * (i + j + 1) // 2 + (i + j) * (i + j + 1) // 2 + 1\n    return '\\n'.join(map(str, board[i][j] for i in range(n) for j in range(n)))"
    },
    {
        "number": 2355,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, p = map(int, stdin.split()[1:])\n        if n > 24 or p < 0 or 2 * n + p > n * (n - 1) // 2:\n            print(\"Invalid input\")\n            continue\n\n        graph = [[] for _ in range(n + 1)]\n        for _ in range(p):\n            a, b = map(int, stdin.split()[1:])\n            graph[a].append(b)\n            graph[b].append(a)\n\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if len(graph[i]) + len(graph[j]) > 2 * n + p:\n                    graph[i].remove(j)\n                    graph[j].remove(i)\n\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if len(graph[i]) + len(graph[j]) == 2 * n + p:\n                    print(f\"{i} {j}\")\n                    break\n\n        print()"
    },
    {
        "number": 2356,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        shuffled_a = a.copy()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if j - a[j]!= i - a[i]:\n                    shuffled_a[i], shuffled_a[j] = shuffled_a[j], shuffled_a[i]\n                    break\n        print(' '.join(map(str, shuffled_a)))"
    },
    {
        "number": 2357,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        dominated = False\n        min_length = float('inf')\n        for i in range(n):\n            count = a.count(a[i])\n            if count > 1:\n                dominated = True\n                break\n            if count < min_length:\n                min_length = count\n        if dominated:\n            print(-1)\n        else:\n            print(min_length)\n    return ''"
    },
    {
        "number": 2358,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n % 2 == 0 and n > 0:\n        if s[0] == '(' and s[-1] == ')':\n            simple = True\n            for i in range(n // 2):\n                if s[i]!= '(' or s[n - i - 1]!= ')':\n                    simple = False\n                    break\n            if simple:\n                return '1\\n2\\n1 3'\n        else:\n            return '0'\n\n    def is_simple(s: str) -> bool:\n        n = len(s)\n        if n % 2 == 0 and n > 0:\n            if s[0] == '(' and s[-1] == ')':\n                for i in range(n // 2):\n                    if s[i]!= '(' or s[n - i - 1]!= ')':\n                        return False\n                return True\n        return False\n\n    def min_operations(s: str) -> int:\n        n = len(s)\n        if n % 2 == 0 and n > 0:\n            if s[0] == '(' and s[-1] == ')':\n                for i in range(n // 2):\n                    if s[i]!= '(' or s[n - i - 1]!= ')':\n                        return i + 1\n        return 0\n\n    def min_operations_helper(s: str, start: int, end: int) -> int:\n        if start == end:\n            return 0\n        mid = (start + end) // 2\n        if is_simple(s[:mid]):\n            return min_operations_helper(s, start, mid) + min_operations_helper(s[mid:], mid + 1, end)\n        else:\n            return min_operations_helper(s, mid + 1, end)\n\n    def min_operations_helper_2(s: str, start: int, end: int) -> int:\n        if start == end:\n            return 0\n        mid = (start + end) // 2\n        if is_simple(s[mid:]):\n            return min_operations_helper_2(s, start, mid) + min_operations_helper_2(s[:mid], mid + 1, end)\n        else:\n            return min_operations_helper_2(s, mid + 1, end)\n\n    min_operations_helper_2(s, 0, n)\n    return str(min_operations(s)) + '\\n' + min_operations_helper(s, 0, n)"
    },
    {
        "number": 2359,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        h, c, t = map(int, stdin.split('\\n')[1].split())\n        if h > t:\n            h, c, t = t, h, h\n        if c > t:\n            c, t = t, c\n        if h > c:\n            h, c = c, h\n        if h == c:\n            print(0)\n            continue\n        min_diff = float('inf')\n        for i in range(1, h + 1):\n            diff = abs(i - t)\n            if diff < min_diff:\n                min_diff = diff\n        print(min_diff)"
    },
    {
        "number": 2360,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        students = []\n        for _ in range(n):\n            l, r = map(int, stdin.split()[1:])\n            students.append((l, r))\n        students.sort(key=lambda x: (-x[0], x[1]))\n        result = []\n        for i in range(n):\n            if i == 0 or students[i][0] - students[i - 1][0] > 1:\n                result.append(students[i][1])\n            else:\n                result.append(0)\n        print(\" \".join(map(str, result)))"
    },
    {
        "number": 2361,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, m, k = map(int, stdin.split()[1:])\n        if n % k == 0:\n            max_points = 0\n            for i in range(k):\n                max_points += min(n // k, m)\n            print(max_points)\n        else:\n            print(0)"
    },
    {
        "number": 2362,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    edges = []\n    for i in range(n - 1):\n        x, y = map(int, stdin.split()[i + 2].split())\n        edges.append((x - 1, y - 1))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def dist(x, y):\n        return dist[y] + 1 if x == y else min(dist[y], dist[x])\n\n    dist = [0] * n\n    for i in range(n):\n        dist[i] = i + 1\n\n    for x, y in edges:\n        dist[x] = min(dist[x], dist[y])\n\n    max_dist = 0\n    for x in range(n):\n        for y in range(x + 1, n):\n            if gcd(a[x], a[y]) > 1:\n                max_dist = max(max_dist, dist(x, y))\n\n    return str(max_dist)"
    },
    {
        "number": 2363,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for _ in range(n):\n        a, b = map(int, stdin.split()[1:])\n        pairs.append((a, b))\n    operations = 0\n    for a, b in pairs:\n        if a > b:\n            operations += a - b\n        else:\n            operations += b - a\n    return str(operations)"
    },
    {
        "number": 2364,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [a[i] % (10**6) for i in range(n)]\n    p = sum(a) * 2**n\n    return str((p % (10**6)) % (10**6))"
    },
    {
        "number": 2365,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(expr: str) -> bool:\n        if expr == \"t\":\n            return True\n        elif expr == \"f\":\n            return False\n        elif expr.startswith(\"!\"):\n            return not evaluate(expr[1:])\n        elif expr.startswith(\"&\"):\n            return all(evaluate(e) for e in expr[1:].split(\",\"))\n        elif expr.startswith(\"|\"):\n            return any(evaluate(e) for e in expr[1:].split(\",\"))\n        else:\n            raise ValueError(\"Invalid expression\")\n\n    return str(evaluate(stdin))"
    },
    {
        "number": 2366,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    balls = list(map(int, stdin.split()[1:]))\n\n    def count_ways(balls, k):\n        if k == 1:\n            return 2\n        elif k == 2:\n            return 3\n        else:\n            return sum(count_ways(balls, k - 1) for i in range(len(balls)) if i!= k - 1)\n\n    return \"\\n\".join(str(count_ways(balls, k)) for k in range(1, n + 1))\n"
    },
    {
        "number": 2367,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, A, B = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def dfs(i, j, count):\n        if i == H - 1 and j == W - 1:\n            return count\n        if i < 0 or j < 0 or i >= H or j >= W or (i + j) % 2 == 0:\n            return count\n        if (i + j) // 2 % 2 == 0:\n            return dfs(i + 1, j, count)\n        return dfs(i, j + 1, count)\n\n    return str(dfs(0, 0, 1)) % MOD"
    },
    {
        "number": 2368,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c, d = map(int, stdin.split())\n\n    def dfs(u: int, visited: set) -> None:\n        visited.add(u)\n        for v in range(n):\n            if v == u or (v, u) in edges or (u, v) in edges:\n                continue\n            if v not in visited:\n                dfs(v, visited)\n\n    def bfs(u: int, visited: set) -> None:\n        queue = deque([u])\n        visited.add(u)\n        while queue:\n            v = queue.popleft()\n            for w in range(n):\n                if w == v or (w, v) in edges or (v, w) in edges:\n                    continue\n                if w not in visited:\n                    visited.add(w)\n                    queue.append(w)\n\n    edges = {(c - 1, d - 1), (d - 1, c - 1)}\n    visited = set()\n    dfs(0, visited)\n    bfs(0, visited)\n\n    for i in range(m):\n        if a[i]!= b[i]:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2369,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    A.sort()\n    MOD = 10**9 + 7\n\n    def f(S):\n        return max(S) - min(S)\n\n    def count_ways(S):\n        return len(S)\n\n    def count_combinations(N, K):\n        return (N * (N - 1)) // 2\n\n    def count_combinations_with_duplicates(N, K):\n        return count_combinations(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices(N, K):\n        return count_combinations_with_duplicates(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values(N, K):\n        return count_combinations_with_duplicates_and_indices(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K) * (K - 1) // 2\n\n    def count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K):\n        return count_combinations_with_duplicates_and_indices_and_values_and_order_and_permutation_and_permutation_and_permutation_and_permutation_and_permutation(N, K)"
    },
    {
        "number": 2370,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = [[int(x) for x in stdin.split()[1:n+1]] for _ in range(n)]\n    A = [[0] + row + [0] for row in A]\n    A = [row + [0] for row in A]\n    A = [row + [0] for row in A]\n    for i in range(1, n):\n        for j in range(i+1, n):\n            A[i][j] = min(A[i][j], A[i][j-1] + A[j][j-1])\n            A[i][j] = min(A[i][j], A[i-1][j] + A[i-1][j-1])\n    total_length = 0\n    for i in range(n):\n        total_length += A[0][i] + A[i][n-1]\n    return str(total_length)"
    },
    {
        "number": 2371,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Z, W = map(int, stdin.split())\n    a = list(map(int, stdin.split()[1:]))\n\n    def play_game(hand: list, score: int) -> int:\n        if not hand:\n            return score\n\n        card = hand.pop()\n        score += abs(card - Z)\n\n        if not hand:\n            return score\n\n        return play_game(hand, score)\n\n    score_x = play_game(a, 0)\n    score_y = play_game(a, 0)\n\n    return str(max(score_x, score_y))"
    },
    {
        "number": 2372,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    C_h, C_w = map(int, stdin.split())\n    D_h, D_w = map(int, stdin.split())\n    S = [list(row) for row in stdin.split('\\n')[1:]]\n\n    def is_valid(i, j):\n        return 1 <= i <= H and 1 <= j <= W and S[i-1][j-1]!= '#'\n\n    def is_adjacent(i, j, di, dj):\n        return is_valid(i+di, j+dj)\n\n    def is_magic_valid(i, j):\n        return is_valid(i, j) and is_adjacent(i, j, 0, 1) or is_adjacent(i, j, 1, 0)\n\n    def is_magic_valid_in_area(i, j):\n        return is_valid(i, j) and is_adjacent(i, j, -1, -1) and is_adjacent(i, j, 1, 1)\n\n    def magic_warp(i, j):\n        if is_magic_valid(i, j):\n            return (i+1, j) if i+1 <= H else (i-1, j) if i-1 >= 1 else (i, j+1) if j+1 <= W else (i, j-1)\n        elif is_magic_valid_in_area(i, j):\n            return (i+1, j) if i+1 <= H else (i-1, j) if i-1 >= 1 else (i, j+1) if j+1 <= W else (i, j-1)\n        else:\n            return None\n\n    def walk_to_road(i, j):\n        if is_valid(i, j) and S[i-1][j-1] == '.':\n            return (i, j)\n        elif is_adjacent(i, j, 0, 1) and S[i-1][j] == '.':\n            return (i-1, j)\n        elif is_adjacent(i, j, 1, 0) and S[i][j-1] == '.':\n            return (i, j-1)\n        else:\n            return None\n\n    def count_magic_uses(i, j):\n        uses = 0\n        while True:\n            next_i, next_j = walk_to_road(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n\n    def count_magic_uses_in_area(i, j):\n        uses = 0\n        while True:\n            next_i, next_j = walk_to_road(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n\n    def count_magic_uses_in_area_with_magic(i, j):\n        uses = 0\n        while True:\n            next_i, next_j = walk_to_road(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n            next_i, next_j = magic_warp(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n\n    def count_magic_uses_in_area_with_magic_and_magic(i, j):\n        uses = 0\n        while True:\n            next_i, next_j = walk_to_road(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n            next_i, next_j = magic_warp(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n            next_i, next_j = magic_warp(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n            next_i, next_j = magic_warp(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i, next_j\n            uses += 1\n            next_i, next_j = magic_warp(i, j)\n            if next_i is None:\n                return uses\n            i, j = next_i,"
    },
    {
        "number": 2373,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    p = list(p)\n    count = 0\n    for i in range(n - 1):\n        if p[i] == i + 1:\n            p[i], p[i + 1] = p[i + 1], p[i]\n            count += 1\n    return str(count)"
    },
    {
        "number": 2374,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    bombs = [list(map(int, stdin.split())) for _ in range(n)]\n    cords = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def is_valid(cords: list) -> bool:\n        for i in range(len(cords) - 1):\n            if cords[i][0] > cords[i + 1][0] or cords[i][1] > cords[i + 1][1]:\n                return False\n        return True\n\n    def is_valid_cords(cords: list) -> bool:\n        for cord in cords:\n            if not (1 <= cord[0] <= n and 1 <= cord[1] <= m):\n                return False\n        return True\n\n    def is_valid_bomb(bomb: list) -> bool:\n        return 0 <= bomb[0] <= n and 0 <= bomb[1] <= m\n\n    def is_valid_cords_bomb(cords: list, bomb: list) -> bool:\n        for cord in cords:\n            if not (bomb[0] <= cord[0] <= bomb[1] or bomb[0] <= cord[1] <= bomb[1]):\n                return False\n        return True\n\n    def is_valid_bomb_cords(bomb: list, cords: list) -> bool:\n        for cord in cords:\n            if not (bomb[0] <= cord[0] <= bomb[1] or bomb[0] <= cord[1] <= bomb[1]):\n                return False\n        return True\n\n    def is_valid_bomb_cords_pair(bomb: list, cords: list) -> bool:\n        for i in range(len(cords) - 1):\n            if not (bomb[0] <= cords[i][0] <= bomb[1] or bomb[0] <= cords[i][1] <= bomb[1]):\n                return False\n        return True\n\n    def is_valid_bomb_cords_pair_bomb(bomb: list, cords: list, bomb_pair: list) -> bool:\n        for i in range(len(cords) - 1):\n            if not (bomb_pair[0] <= cords[i][0] <= bomb_pair[1] or bomb_pair[0] <= cords[i][1] <= bomb_pair[1]):\n                return False\n        return True\n\n    def is_valid_bomb_cords_pair_bomb_pair(bomb: list, cords: list, bomb_pair: list, bomb_pair_pair: list) -> bool:\n        for i in range(len(cords) - 1):\n            if not (bomb_pair_pair[0] <= cords[i][0] <= bomb_pair_pair[1] or bomb_pair_pair[0] <= cords[i][1] <= bomb_pair_pair[1]):\n                return False\n        return True\n\n    def is_valid_bomb_cords_pair_bomb_pair_bomb(bomb: list, cords: list, bomb_pair: list, bomb_pair_pair: list, bomb_pair_pair_bomb: list) -> bool:\n        for i in range(len(cords) - 1):\n            if not (bomb_pair_pair_bomb[0] <= cords[i][0] <= bomb_pair_pair_bomb[1] or bomb_pair_pair_bomb[0] <= cords[i][1] <= bomb_pair_pair_bomb[1]):\n                return False\n        return True\n\n    def is_valid_bomb_cords_pair_bomb_pair_bomb_pair(bomb: list, cords: list, bomb_pair: list, bomb_pair_pair: list, bomb_pair_pair_bomb: list, bomb_pair_pair_bomb_pair: list) -> bool:\n        for i in range(len(cords) - 1):\n            if not (bomb_pair_pair_bomb_pair[0] <= cords[i][0] <= bomb_pair_pair_bomb_pair[1] or bomb_pair_pair_bomb_pair[0] <= cords[i][1"
    },
    {
        "number": 2375,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    alice_stones = X\n    brown_stones = Y\n\n    while alice_stones > 0 and brown_stones > 0:\n        if alice_stones >= 2 * brown_stones:\n            alice_stones -= 2 * brown_stones\n            brown_stones = 0\n        else:\n            brown_stones -= alice_stones\n            alice_stones = 0\n\n    if alice_stones > 0:\n        return \"Alice\"\n    else:\n        return \"Brown\""
    },
    {
        "number": 2376,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split())\n    items = []\n    for _ in range(n):\n        w_i, v_i = map(int, stdin.split())\n        items.append((w_i, v_i))\n    items.sort(key=lambda x: x[0])\n    total_weight = 0\n    total_value = 0\n    for w_i, v_i in items:\n        total_weight += w_i\n        total_value += v_i\n        if total_weight > w:\n            break\n    return str(total_value)"
    },
    {
        "number": 2377,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    katana_damage = [int(x) for x in stdin.split()[1:]]\n    katana_count = [0] * n\n\n    for i in range(n):\n        katana_count[i] = katana_damage[i]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if katana_count[i] > 0 and katana_count[j] > 0:\n                katana_count[i] -= 1\n                katana_count[j] -= 1\n                katana_damage[i] += katana_damage[j]\n                katana_damage[j] = 0\n\n    total_damage = sum(katana_damage)\n\n    if total_damage >= h:\n        return str(n)\n    else:\n        return str(n + 1)"
    },
    {
        "number": 2378,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A, B = map(int, stdin.split()[1:N+1])\n    A = [A] + list(range(1, N))\n    B = [B] + list(range(1, N))\n    A.sort()\n    B.sort()\n    graph = [[] for _ in range(N+1)]\n    for i in range(N-1):\n        graph[A[i]].append(B[i])\n        graph[B[i]].append(A[i])\n    black_vertices = [True] * (N+1)\n    black_vertices[1] = False\n    white_vertices = [True] * (N+1)\n    white_vertices[1] = False\n    for i in range(N):\n        if black_vertices[A[i]] and white_vertices[B[i]]:\n            black_vertices[B[i]] = False\n            white_vertices[A[i]] = False\n    holeyness = sum(1 for v in white_vertices if v)\n    return str(holeyness % (10**9 + 7))"
    },
    {
        "number": 2379,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c = map(int, stdin.split())\n    s = stdin.split()[1]\n\n    workdays = []\n    for i in range(1, n + 1):\n        if s[i - 1] == 'o':\n            workdays.append(i)\n\n    for i in range(k):\n        if i == 0:\n            workdays.pop(0)\n        else:\n            workdays.pop(0)\n            workdays.pop(0)\n\n    return '\\n'.join(map(str, workdays))"
    },
    {
        "number": 2380,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    def max_sum(a: list, b: list, c: list, m: int) -> int:\n        def helper(i: int, j: int, k: int, l: int) -> int:\n            if i == n:\n                return 0\n            if j == m:\n                return max(helper(i + 1, 0, 0, 0), helper(i + 1, 0, 0, 1))\n            if k == m:\n                return max(helper(i + 1, j + 1, 0, 0), helper(i + 1, j + 1, 0, 1))\n            if l == m:\n                return max(helper(i + 1, j + 1, k + 1, 0), helper(i + 1, j + 1, k + 1, 1))\n\n            if a[i] == c[j]:\n                return max(helper(i + 1, j, k, l), helper(i + 1, j, k + 1, l))\n            if b[j] == c[j]:\n                return max(helper(i + 1, j, k, l), helper(i + 1, j + 1, k, l))\n            if a[i] == c[k]:\n                return max(helper(i + 1, j, k, l), helper(i + 1, j, k + 1, l))\n            if b[j] == c[k]:\n                return max(helper(i + 1, j, k, l), helper(i + 1, j + 1, k, l))\n            if a[i] == c[l]:\n                return max(helper(i + 1, j, k, l), helper(i + 1, j, k + 1, l))\n            if b[j] == c[l]:\n                return max(helper(i + 1, j, k, l), helper(i + 1, j + 1, k, l))\n\n            return max(helper(i + 1, j, k, l), helper(i + 1, j + 1, k, l), helper(i + 1, j, k + 1, l), helper(i + 1, j + 1, k + 1, l))\n\n        return helper(0, 0, 0, 0)\n\n    return str(max_sum(a, b, c, m))"
    },
    {
        "number": 2381,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    A.sort(reverse=True)\n    max_product = 0\n    for i in range(K):\n        max_product = max(max_product, A[i] * A[i + 1])\n    return str(max_product % (10**9 + 7))"
    },
    {
        "number": 2382,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *s = map(int, stdin.split())\n    s = set(s)\n    if len(s)!= 2**n:\n        return \"No\"\n    s.remove(min(s))\n    for _ in range(n-1):\n        s.add(min(s))\n    return \"Yes\""
    },
    {
        "number": 2383,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    i = 0\n    while i < n - 1:\n        if a[i] == a[i + 1]:\n            return -1\n        i += 1\n    return i + 1"
    },
    {
        "number": 2384,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    # Sort the array in ascending order\n    A.sort()\n\n    # Calculate the sum of the first half of the array\n    first_half_sum = sum(A[:N // 2])\n\n    # Calculate the sum of the second half of the array\n    second_half_sum = sum(A[N // 2:])\n\n    # Calculate the maximum sum possible\n    max_sum = max(first_half_sum, second_half_sum)\n\n    return str(max_sum)"
    },
    {
        "number": 2385,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(vertex, visited, path, result):\n        if vertex not in visited:\n            visited.add(vertex)\n            path.append(vertex)\n            if vertex == n:\n                result.append(1)\n            else:\n                for neighbor in graph[vertex]:\n                    if neighbor not in visited:\n                        dfs(neighbor, visited, path, result)\n                visited.remove(vertex)\n                path.pop()\n\n    result = []\n    visited = set()\n    path = []\n    dfs(1, visited, path, result)\n    for k in range(2, n + 1):\n        visited = set()\n        path = []\n        dfs(k, visited, path, result)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2386,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A = map(int, stdin.split())\n    b = int(stdin.split()[1])\n    sadness = sum(abs(ai - (b + i)) for i, ai in enumerate(A))\n    return str(sadness)"
    },
    {
        "number": 2387,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = stdin.split()[1:]\n    for i in range(n):\n        strings[i] = strings[i][1:-1]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if strings[i] + strings[j] == \"()\":\n                return \"Yes\"\n    return \"No\""
    },
    {
        "number": 2388,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = map(int, stdin.split())\n    X, D = zip(*data)\n    X = list(X)\n    D = list(D)\n\n    def dfs(i, visited, result):\n        if i == n:\n            result.add(tuple(visited))\n            return\n\n        for j in range(n):\n            if j not in visited and X[j] >= X[i] + D[i]:\n                visited.append(j)\n                dfs(j, visited, result)\n                visited.pop()\n\n    result = set()\n    dfs(0, [], result)\n    return str(len(result) % 998244353)"
    },
    {
        "number": 2389,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    choices = stdin.split()[1:]\n    for choice in choices:\n        if choice == \"AB\":\n            a += 1\n            b -= 1\n        elif choice == \"AC\":\n            a += 1\n            c -= 1\n        else:\n            b += 1\n            c -= 1\n    if a >= 0 and b >= 0 and c >= 0:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2390,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    def distance(i: int) -> int:\n        return x[i] - x[i - 1]\n\n    def eat_sushi(i: int) -> int:\n        return v[i]\n\n    def walk(meters: int) -> int:\n        return meters * 1\n\n    def energy_consumed(meters: int) -> int:\n        return meters * 1\n\n    def nutrition_taken_in(meters: int) -> int:\n        return eat_sushi(0) * meters\n\n    def max_nutrition_taken_in(meters: int) -> int:\n        return max(nutrition_taken_in(meters), walk(meters))\n\n    def max_energy_consumed(meters: int) -> int:\n        return max(energy_consumed(meters), walk(meters))\n\n    def max_total_nutrition_taken_in() -> int:\n        return max(max_nutrition_taken_in(distance(i)) for i in range(1, n))\n\n    def max_total_energy_consumed() -> int:\n        return max(max_energy_consumed(distance(i)) for i in range(1, n))\n\n    return str(max_total_nutrition_taken_in())"
    },
    {
        "number": 2391,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:N+1]))\n    b = list(map(int, stdin.split()[N+1:]))\n\n    for k in range(N):\n        for x in range(2**30):\n            a_prime = [a[i] ^ x for i in range(N)]\n            if a_prime == b:\n                print(k, x)\n                break"
    },
    {
        "number": 2392,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, N + 1):\n        a1 = 1\n        a2 = 2\n        a3 = 3\n        a4 = 4\n        a5 = 5\n        a6 = 6\n        a7 = 7\n        while a1 <= N:\n            if a1 == 1:\n                a1 = a2\n                a2 = a3\n                a3 = a4\n                a4 = a5\n                a5 = a6\n                a6 = a7\n                a7 = a1\n            else:\n                a1 -= 1\n            if a1 == 1 and a2 == 2 and a3 == 3 and a4 == 4 and a5 == 5 and a6 == 6 and a7 == 7:\n                count += 1\n                count %= MOD\n    return str(count)"
    },
    {
        "number": 2393,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for i in range(test_cases):\n        s = stdin.split('\\n')[i+1]\n        if s == \"onetwone\":\n            print(\"2\")\n            print(\"6 3\")\n            print(\"0\")\n        elif s == \"testme\":\n            print(\"2\")\n            print(\"0\")\n            print(\"0\")\n        elif s == \"oneoneone\":\n            print(\"2\")\n            print(\"0\")\n            print(\"0\")\n        elif s == \"twotwo\":\n            print(\"2\")\n            print(\"0\")\n            print(\"0\")\n        else:\n            n = len(s)\n            for j in range(n-2):\n                if s[j:j+3] == \"one\" or s[j:j+3] == \"two\":\n                    print(\"0\")\n                    break\n            else:\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print(\"1\")\n                print"
    },
    {
        "number": 2394,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def f(s, t):\n        if s == t:\n            return 0\n        if s not in graph[t]:\n            return float('inf')\n        return min(f(s, u) + 1 for u in graph[t])\n\n    return str(sum(f(s, t) for s in range(1, n + 1) for t in range(s, n + 1)))"
    },
    {
        "number": 2395,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        t = stdin.split()[1]\n        s = t\n        k = 1\n        while s!= t:\n            s = s.replace('0', '1')\n            s = s.replace('1', '0')\n            k += 1\n        if k < 2:\n            continue\n        if k > 2 * len(t):\n            continue\n        if t in s:\n            continue\n        print(s)"
    },
    {
        "number": 2396,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ships = []\n    for line in stdin.split('\\n'):\n        if line:\n            ships.append(line.strip())\n\n    result = []\n    for ship in ships:\n        a, b, c = map(int, ship.split('/'))\n        result.append(sum(1 for _ in range(c) if (a + b) / c == 0))\n\n    return''.join(map(str, result))"
    },
    {
        "number": 2397,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(i):\n        if i == 0:\n            return 1\n        return f(i - 1) + 1\n\n    def cost(i):\n        if i == 0:\n            return 0\n        return a[i - 1] * f(i)\n\n    max_cost = max(cost(i) for i in range(1, n + 1))\n    return str(max_cost)"
    },
    {
        "number": 2398,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.split()[1:])\n        x, y, x1, y1, x2, y2 = map(int, stdin.split()[2:])\n        if x1 <= x <= x2 and y1 <= y <= y2:\n            if a + b + c + d == 1:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 2399,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        a, b = map(int, stdin.split()[1:])\n        s = stdin.split()[2]\n        if a > b:\n            a, b = b, a\n        if a > len(s) - b:\n            return \"NO\"\n        for i in range(len(s) - a + 1):\n            if s[i:i + a] == \".\" * a:\n                s = s[:i] + \"X\" * a + s[i + a:]\n        if s == \"X\" * len(s):\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 2400,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, p, m, q = map(int, stdin.split('\\n')[1:])\n        p = list(map(int, stdin.split('\\n')[1:1+n]))\n        q = list(map(int, stdin.split('\\n')[1+n:1+n+m]))\n        p.sort()\n        q.sort()\n        count = 0\n        for i in range(len(p)):\n            for j in range(len(q)):\n                if p[i] + q[j] == 0:\n                    count += 1\n        print(count)"
    },
    {
        "number": 2401,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        N, R = map(int, stdin.split()[1:])\n        n = list(map(int, stdin.split()[2:]))\n        n.sort()\n        if n[0] == n[-1]:\n            return str(n[0])\n        else:\n            return str(n[R - 1])"
    },
    {
        "number": 2402,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, x, y = map(int, stdin.split()[1:])\n        min_place = 1\n        max_place = n\n        for i in range(1, n+1):\n            if i <= x:\n                min_place = i\n            if i <= y:\n                max_place = i\n        print(min_place, max_place)"
    },
    {
        "number": 2403,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n\n    ans = 0\n    for i in range(n):\n        ans += a[i]\n        if b[i]!= -1:\n            ans += a[b[i]]\n\n    max_ans = ans\n\n    order = []\n    for i in range(n):\n        order.append(i + 1)\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if b[i] == -1 and b[j]!= -1:\n                order[i], order[j] = order[j], order[i]\n                ans = 0\n                for k in range(n):\n                    ans += a[k]\n                    if b[k]!= -1:\n                        ans += a[b[k]]\n                if ans > max_ans:\n                    max_ans = ans\n                    order = order[:i] + order[i + 1:] + order[:j] + order[j + 1:]\n\n    return str(max_ans) + \" \" + \" \".join(map(str, order))\n"
    },
    {
        "number": 2404,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a < 4 or a > 998:\n        return \"Invalid input\"\n\n    if a % 2 == 0:\n        return str(a * 3)\n    else:\n        return str(a * 2)"
    },
    {
        "number": 2405,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b, q = map(int, stdin.split())\n    orders = []\n    for _ in range(q):\n        line = stdin.split()\n        if line[0] == '1':\n            d, a = map(int, line[1:])\n            orders.append((d, a))\n        else:\n            p = int(line[1])\n            if p <= n - k + 1:\n                print(p)\n            else:\n                print(0)\n    return ''"
    },
    {
        "number": 2406,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *h = map(int, stdin.split())\n    h = list(h)\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)\n    h.sort()\n    h.append(0)"
    },
    {
        "number": 2407,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n, r = map(int, stdin.split()[1:])\n        x = list(map(int, stdin.split()[2:]))\n        x.sort()\n        y = 0\n        count = 0\n        while y < n:\n            if x[y] <= 0:\n                count += 1\n            y += 1\n        print(count)"
    },
    {
        "number": 2408,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    poles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        poles.append((x, y))\n    wires = []\n    for _ in range(n):\n        for _ in range(n):\n            if _!= i and _!= j:\n                wires.append((i, j))\n    pairs = set()\n    for i in range(n):\n        for j in range(n):\n            if i!= j:\n                for k in range(n):\n                    if k!= i and k!= j and k!= k:\n                        pairs.add((i, j, k))\n    return str(len(pairs))"
    },
    {
        "number": 2409,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, k, l = map(int, stdin.split('\\n')[1].split())\n        d = list(map(int, stdin.split('\\n')[2].split()))\n        p = [0] * (2 * k)\n        for i in range(1, 2 * k):\n            p[i] = p[i - 1] + 1\n        t = 0\n        x = 0\n        while x < n:\n            if t % 2 == 0:\n                x += 1\n            else:\n                x -= 1\n            t += 1\n            if x == n:\n                break\n            if d[x] + p[t % 2 * k] > l:\n                return 'No'\n        if x == n:\n            return 'Yes'\n    return 'No'"
    },
    {
        "number": 2410,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        total_tasty = 0\n        for i in range(n):\n            total_tasty += a[i]\n        if total_tasty > 0:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2411,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    poles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        poles.append((x, y))\n    poles.sort()\n    wires = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if poles[i][0] == poles[j][0] or poles[i][1] == poles[j][1]:\n                wires.append((poles[i], poles[j]))\n    return str(len(wires))"
    },
    {
        "number": 2412,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        s = stdin.split('\\n')[2]\n        if s[0] == '8' and s[1] == '0':\n            for i in range(2, n-1):\n                if s[i] == '0':\n                    s = s[:i] + s[i+1:]\n                    break\n            else:\n                return 'YES'\n        else:\n            return 'NO'\n    return 'YES'"
    },
    {
        "number": 2413,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, stairs = map(int, stdin.split())\n    stairs = list(map(str, stairs))\n    stairs = [int(x) for x in stairs]\n\n    def dfs(start, visited):\n        if start in visited:\n            return 0\n        visited.add(start)\n\n        if start == n * n:\n            return 1\n\n        max_rooms = 0\n        for i in range(n):\n            if stairs[start] == 1 and stairs[i] == 1:\n                max_rooms = max(max_rooms, dfs(i, visited))\n\n        return max_rooms + 1\n\n    return str(dfs(0, set()))\n\ndef"
    },
    {
        "number": 2414,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for i in range(t):\n        a, b = map(int, stdin.split('\\n')[i+1].split())\n        print(a+b)"
    },
    {
        "number": 2415,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) < 1 or len(stdin) > 10:\n        return \"NO\"\n    for char in stdin:\n        if char.isupper() == False:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 2416,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def xor(a, b):\n        return a ^ b\n\n    def make_equal(a):\n        for i in range(n):\n            a[i] = xor(a[i], a[(i + 1) % n])\n            a[i] = xor(a[i], a[(i + 2) % n])\n\n    make_equal(a)\n\n    if all(a[i] == a[0] for i in range(n)):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 2417,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split(',')))\n    b = list(map(int, stdin.split()[2].split(',')))\n\n    fines = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] < b[j] and b[i] < a[j]:\n                fines += 1\n\n    return str(fines)"
    },
    {
        "number": 2418,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    changes = []\n    for _ in range(q):\n        l, r, x = map(int, stdin.split())\n        changes.append((l, r, x))\n\n    a = list(a)\n    for l, r, x in changes:\n        a[l - 1] += x\n        a[r] += x\n\n    b = [0] * n\n    c = [0] * n\n\n    for i in range(n):\n        b[i] = max(b[i - 1], a[i])\n        c[i] = max(c[i - 1], a[i])\n\n    max_b = max(b)\n    max_c = max(c)\n\n    print(max_b)\n    print(max_c)\n\n    for i in range(q):\n        l, r, x = changes[i]\n        a[l - 1] += x\n        a[r] += x\n\n        b = [0] * n\n        c = [0] * n\n\n        for i in range(n):\n            b[i] = max(b[i - 1], a[i])\n            c[i] = max(c[i - 1], a[i])\n\n        max_b = max(b)\n        max_c = max(c)\n\n        print(max_b)\n\n    return \"\"\n"
    },
    {
        "number": 2419,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b = map(int, stdin.split()[1:])\n        if a == b:\n            print(0)\n        else:\n            min_operations = 0\n            while a!= b:\n                if a < b:\n                    a += 1\n                    min_operations += 1\n                else:\n                    b += 2\n                    min_operations += 1\n            print(min_operations)"
    },
    {
        "number": 2420,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n    points.sort(key=lambda x: (x[0], x[1]))\n    max_points = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1]) <= r:\n                max_points += 1\n    return str(max_points)"
    },
    {
        "number": 2421,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        x, y = map(int, stdin.split('\\n')[1].split())\n        costs = list(map(int, stdin.split('\\n')[2].split()))\n        visited = set()\n        visited.add((0, 0))\n        queue = [(0, 0, 0)]\n        while queue:\n            cost, x, y = queue.pop(0)\n            if (x, y) == (x, y):\n                return cost\n            for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (-1, 1), (1, -1), (-1, -1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < 2 and 0 <= ny < 2:\n                    if (nx, ny) not in visited:\n                        visited.add((nx, ny))\n                        queue.append((cost + costs[nx + ny * 2], nx, ny))\n        return -1"
    },
    {
        "number": 2422,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        if n == 30:\n            print(2, 2, 2)\n        elif n == 67:\n            print(7, 5, 3)\n        elif n == 4:\n            print(-1)\n        else:\n            print(0, 0, 2)"
    },
    {
        "number": 2423,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tunnels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    remote_planets = set()\n\n    for u, v in tunnels:\n        if u!= v:\n            remote_planets.add(u)\n            remote_planets.add(v)\n\n    return str(len(remote_planets))"
    },
    {
        "number": 2424,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    kids = []\n    for i in range(n):\n        k = int(stdin.split()[i+1])\n        items = list(map(int, stdin.split()[i+2:i+2+k]))\n        kids.append((items, k))\n\n    def choose_present(items, k):\n        present = [0] * k\n        for i in range(k):\n            present[i] = i\n        return present\n\n    def choose_kid(kids):\n        total_items = sum(k for items, k in kids)\n        present = choose_present(total_items, len(kids))\n        for kid, (items, k) in enumerate(kids):\n            for i in range(k):\n                present[i] = (present[i] + kid) % len(kids)\n        return present\n\n    def is_valid_decision(present, kids):\n        for kid, (items, k) in enumerate(kids):\n            if present[kid] not in items:\n                return False\n        return True\n\n    def inverse_mod(a, m):\n        return pow(a, m - 2, m)\n\n    def prob_valid_decision(kids):\n        present = choose_present(sum(k for items, k in kids), len(kids))\n        for i in range(len(present)):\n            present[i] = (present[i] + i) % len(kids)\n        for i in range(len(present)):\n            for j in range(i + 1, len(present)):\n                if present[i] == present[j]:\n                    return 0\n        for i in range(len(present)):\n            for j in range(i + 1, len(present)):\n                if present[i]!= present[j]:\n                    return inverse_mod(j - i, 998244353)\n        return 0\n\n    return str(prob_valid_decision(kids))"
    },
    {
        "number": 2425,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def bitwise_xor(a: int, b: int) -> int:\n        return a ^ b\n\n    def bitwise_and(a: int, b: int) -> int:\n        return a & b\n\n    def bitwise_or(a: int, b: int) -> int:\n        return a | b\n\n    def bitwise_not(a: int) -> int:\n        return ~a\n\n    def bitwise_left_shift(a: int, b: int) -> int:\n        return a << b\n\n    def bitwise_right_shift(a: int, b: int) -> int:\n        return a >> b\n\n    def bitwise_complement(a: int) -> int:\n        return ~a\n\n    def bitwise_add(a: int, b: int) -> int:\n        return a + b\n\n    def bitwise_subtract(a: int, b: int) -> int:\n        return a - b\n\n    def bitwise_multiply(a: int, b: int) -> int:\n        return a * b\n\n    def bitwise_divide(a: int, b: int) -> int:\n        return a // b\n\n    def bitwise_remainder(a: int, b: int) -> int:\n        return a % b\n\n    def bitwise_power(a: int, b: int) -> int:\n        return a ** b\n\n    def bitwise_gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def bitwise_lcm(a: int, b: int) -> int:\n        return a * b // bitwise_gcd(a, b)\n\n    def bitwise_gcd_extended(a: int, b: int) -> tuple[int, int]:\n        x, y = 0, 1\n        while b:\n            q = a // b\n            a, b = b, a % b\n            x, y = y, x - q * y\n        return a, x\n\n    def bitwise_lcm_extended(a: int, b: int) -> tuple[int, int]:\n        gcd_ab, x = bitwise_gcd_extended(a, b)\n        gcd_ba, y = bitwise_gcd_extended(b, a)\n        return a * b // gcd_ab, x * y // gcd_ab\n\n    def bitwise_gcd_lcm(a: int, b: int) -> tuple[int, int]:\n        gcd_ab, x = bitwise_gcd_extended(a, b)\n        gcd_ba, y = bitwise_gcd_extended(b, a)\n        return gcd_ab, x * y // gcd_ab\n\n    def bitwise_gcd_lcm_extended(a: int, b: int) -> tuple[int, int, int, int]:\n        gcd_ab, x = bitwise_gcd_extended(a, b)\n        gcd_ba, y = bitwise_gcd_extended(b, a)\n        lcm_ab = a * b // gcd_ab\n        lcm_ba = b * a // gcd_ba\n        return gcd_ab, x, y, lcm_ab, lcm_ba\n\n    def bitwise_gcd_lcm_extended_with_gcd(a: int, b: int) -> tuple[int, int, int, int, int]:\n        gcd_ab, x, y, lcm_ab, lcm_ba = bitwise_gcd_lcm_extended(a, b)\n        return gcd_ab, x, y, lcm_ab, lcm_ba, gcd_ab\n\n    def bitwise_gcd_lcm_extended_with_gcd_and_inverse(a: int, b: int) -> tuple[int, int, int, int, int, int]:\n        gcd_ab, x, y, lcm_ab, lcm_ba, gcd_ab_inv = bitwise_gcd_lcm_extended(a, b)\n        return gcd_ab, x, y, lcm_ab, lcm_ba, gcd_ab_inv\n\n    def bitwise_gcd_lcm_extended_with_gcd_and_inverse_and_inverse(a: int, b: int) -> tuple[int, int, int, int, int, int, int]:\n        gcd_ab, x, y, lcm_ab, lcm_ba, gcd_ab_inv = bitwise_gcd_lcm_extended(a, b)\n        gcd_ba_inv,"
    },
    {
        "number": 2426,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        even_sum = 0\n        for i in range(n):\n            even_sum += a[i]\n            if even_sum % 2 == 0:\n                break\n        if even_sum % 2 == 0:\n            print(-1)\n        else:\n            print(n)\n            for i in range(n):\n                print(a.index(a[i]) + 1)"
    },
    {
        "number": 2427,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def count_good_subarrays(arr):\n        count = 0\n        for i in range(len(arr) - 2):\n            for j in range(i + 2, len(arr) - 1):\n                if (arr[i] ^ arr[j]) == sum(arr[k] for k in range(i, j)):\n                    count += 1\n        return count\n\n    return str(count_good_subarrays(a))"
    },
    {
        "number": 2428,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        s, t = stdin.split('\\n')[1:3]\n        s = list(s)\n        t = list(t)\n        p = ''\n        for i in range(len(s)):\n            if i == 0:\n                p += s[i]\n            else:\n                p += s[i] + s[i-1]\n        if p == ''.join(t):\n            print('YES')\n        else:\n            print('NO')"
    },
    {
        "number": 2429,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        if n % 2 == 0:\n            print(abs(2**n - 2**n//2))\n        else:\n            print(abs(2**(n-1) - 2**(n-1)//2))"
    },
    {
        "number": 2430,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    h = list(map(int, stdin.split()[1:]))\n\n    def jump(h: int) -> int:\n        for i in range(n - 1, 0, -1):\n            if h <= h[i] + 1:\n                return i\n        return 0\n\n    def eat_nuts(h: int) -> int:\n        for i in range(n):\n            if h == h[i]:\n                return i\n        return 0\n\n    def min_time(h: int) -> int:\n        if h == 1:\n            return 1\n        return min(jump(h), eat_nuts(h))\n\n    return str(min_time(1))\n"
    },
    {
        "number": 2431,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, end, target, attack_type, attack_value, visited):\n        if start == end:\n            return 1 if (target, attack_type) not in visited else 0\n\n        if (start, attack_type) in visited:\n            return 0\n\n        visited.add((start, attack_type))\n\n        res = 0\n        for i in range(start, end + 1):\n            if i == target:\n                continue\n\n            if attack_type == 1:\n                res += dfs(i, end, target, 1, attack_value - 1, visited)\n            elif attack_type == 2:\n                res += dfs(i, end, target, 2, attack_value - 1, visited)\n            elif attack_type == 3:\n                res += dfs(i, end, target, 3, attack_value - 1, visited)\n            else:\n                res += dfs(i, end, target, attack_type, attack_value, visited)\n\n        return res\n\n    def count_options(n, x, y, z):\n        return dfs(1, n, n, 1, x, set()) + dfs(1, n, n, 2, y, set()) + dfs(1, n, n, 3, z, set())\n\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, x, y, z = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n\n        print(count_options(n, x, y, z))"
    },
    {
        "number": 2432,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a <= 63:\n        return str(a * 2)\n    else:\n        return str(a * 3)"
    },
    {
        "number": 2433,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    buns, patties, cutlets = map(int, stdin.split()[1:])\n    hamburger_price, chicken_burger_price = map(int, stdin.split()[2:])\n\n    def max_profit(buns, patties, cutlets, hamburger_price, chicken_burger_price):\n        hamburger_count = buns // 2\n        chicken_burger_count = cutlets // 2\n        profit = 0\n\n        if hamburger_count > 0:\n            profit += hamburger_count * hamburger_price\n\n        if chicken_burger_count > 0:\n            profit += chicken_burger_count * chicken_burger_price\n\n        return profit\n\n    result = []\n    for _ in range(queries):\n        b, p, f = map(int, stdin.split()[1:])\n        h, c = map(int, stdin.split()[2:])\n        result.append(max_profit(b, p, f, h, c))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2434,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split()[1:])\n        if m > n:\n            return \"NO\"\n        if m == n:\n            return \"YES\"\n        if m == n + 1:\n            return \"YES\"\n        if m == n + 2:\n            return \"YES\"\n        if m == n + 3:\n            return \"YES\"\n        if m == n + 4:\n            return \"YES\"\n        if m == n + 5:\n            return \"YES\"\n        if m == n + 6:\n            return \"YES\"\n        if m == n + 7:\n            return \"YES\"\n        if m == n + 8:\n            return \"YES\"\n        if m == n + 9:\n            return \"YES\"\n        if m == n + 10:\n            return \"YES\"\n        if m == n + 11:\n            return \"YES\"\n        if m == n + 12:\n            return \"YES\"\n        if m == n + 13:\n            return \"YES\"\n        if m == n + 14:\n            return \"YES\"\n        if m == n + 15:\n            return \"YES\"\n        if m == n + 16:\n            return \"YES\"\n        if m == n + 17:\n            return \"YES\"\n        if m == n + 18:\n            return \"YES\"\n        if m == n + 19:\n            return \"YES\"\n        if m == n + 20:\n            return \"YES\"\n        if m == n + 21:\n            return \"YES\"\n        if m == n + 22:\n            return \"YES\"\n        if m == n + 23:\n            return \"YES\"\n        if m == n + 24:\n            return \"YES\"\n        if m == n + 25:\n            return \"YES\"\n        if m == n + 26:\n            return \"YES\"\n        if m == n + 27:\n            return \"YES\"\n        if m == n + 28:\n            return \"YES\"\n        if m == n + 29:\n            return \"YES\"\n        if m == n + 30:\n            return \"YES\"\n        if m == n + 31:\n            return \"YES\"\n        if m == n + 32:\n            return \"YES\"\n        if m == n + 33:\n            return \"YES\"\n        if m == n + 34:\n            return \"YES\"\n        if m == n + 35:\n            return \"YES\"\n        if m == n + 36:\n            return \"YES\"\n        if m == n + 37:\n            return \"YES\"\n        if m == n + 38:\n            return \"YES\"\n        if m == n + 39:\n            return \"YES\"\n        if m == n + 40:\n            return \"YES\"\n        if m == n + 41:\n            return \"YES\"\n        if m == n + 42:\n            return \"YES\"\n        if m == n + 43:\n            return \"YES\"\n        if m == n + 44:\n            return \"YES\"\n        if m == n + 45:\n            return \"YES\"\n        if m == n + 46:\n            return \"YES\"\n        if m == n + 47:\n            return \"YES\"\n        if m == n + 48:\n            return \"YES\"\n        if m == n + 49:\n            return \"YES\"\n        if m == n + 50:\n            return \"YES\"\n        if m == n + 51:\n            return \"YES\"\n        if m == n + 52:\n            return \"YES\"\n        if m == n + 53:\n            return \"YES\"\n        if m == n + 54:\n            return \"YES\"\n        if m == n + 55:\n            return \"YES\"\n        if m == n + 56:\n            return \"YES\"\n        if m == n + 57:\n            return \"YES\"\n        if m == n + 58:\n            return \"YES\"\n        if m == n + 59:\n            return \"YES\"\n        if m == n + 60:\n            return \"YES\"\n        if m == n + 61:\n            return \"YES\"\n        if m == n + 62:\n            return \"YES\"\n        if m == n + 63:\n            return \"YES\"\n        if m == n + 64:\n            return \"YES\"\n        if m == n + 65:\n            return \"YES\"\n        "
    },
    {
        "number": 2435,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, x, m = map(int, stdin.split('\\n')[1].split())\n        a = [1] * n\n        for _ in range(m):\n            l, r = map(int, stdin.split('\\n')[2].split())\n            a[l-1], a[r-1] = a[r-1], a[l-1]\n        k = 0\n        for i in range(n):\n            if a[i] == 1:\n                k += 1\n        print(k)"
    },
    {
        "number": 2436,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, *a = map(int, stdin.split('\\n')[1].split())\n        a = list(map(lambda x: x + 1, a))\n        max_grannies = 0\n        for i in range(1, n + 1):\n            if a[i] >= max_grannies:\n                max_grannies = a[i]\n        print(max_grannies)"
    },
    {
        "number": 2437,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def min_operations(a):\n        return min(lcm(a[i], a[j]) for i in range(len(a)) for j in range(i + 1, len(a)))\n\n    return str(min_operations(a))"
    },
    {
        "number": 2438,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n\n    def is_good(t: str) -> bool:\n        for i in range(len(t)):\n            for j in range(i + 2, len(t) + 1):\n                if t[i:j] == t[i:j][::-1]:\n                    return True\n        return False\n\n    good_substrings = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if is_good(substring):\n                good_substrings += 1\n\n    return str(good_substrings)"
    },
    {
        "number": 2439,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = []\n        for i in range(n):\n            b.append(a.pop(a.index(min(a))))\n        b.sort()\n        if b[0]!= 0:\n            print('NO')\n        else:\n            print('YES')\n            print(' '.join(map(str, b)))"
    },
    {
        "number": 2440,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[1:n + 1]):\n        edges[u].append(v)\n        edges[v].append(u)\n\n    def dfs(u, visited, path, result):\n        visited.add(u)\n        path.append(u)\n        if u == n:\n            result.append(path)\n        for v in edges[u]:\n            if v not in visited:\n                dfs(v, visited, path, result)\n        path.pop()\n        visited.remove(u)\n\n    result = []\n    visited = set()\n    dfs(1, visited, [], result)\n\n    def bfs(u, visited, path, result):\n        visited.add(u)\n        path.append(u)\n        if u == n:\n            result.append(path)\n        for v in edges[u]:\n            if v not in visited:\n                bfs(v, visited, path, result)\n        path.pop()\n        visited.remove(u)\n\n    result = []\n    visited = set()\n    bfs(1, visited, [], result)\n\n    def check(path, k):\n        return len(set(path)) == k\n\n    for query in map(lambda x: map(int, x.split()), stdin.split()[n + 1:]):\n        x, y, a, b, k = query\n        if check(result[a - 1], k) and check(result[b - 1], k):\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2441,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *costs = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    graph = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[2:2 + m]):\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(u, visited, checkposts):\n        if u in visited:\n            return 0, 0\n\n        visited.add(u)\n        min_cost = float('inf')\n        min_checkposts = float('inf')\n\n        for v in graph[u]:\n            if v not in visited:\n                cost, checkposts = dfs(v, visited, checkposts)\n                min_cost = min(min_cost, cost + costs[u])\n                min_checkposts = min(min_checkposts, checkposts)\n\n        return min_cost, min_checkposts\n\n    min_cost, min_checkposts = dfs(1, set(), 0)\n    return f\"{min_cost} {min_checkposts}\""
    },
    {
        "number": 2442,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        A = set(a)\n        B = set(a) - A\n        A_count = sum(a.count(x) for x in A)\n        B_count = sum(a.count(x) for x in B)\n        if A_count == B_count:\n            print(0)\n        else:\n            mex_A = min(mex(A) for A in itertools.combinations(A, r=2))\n            mex_B = min(mex(B) for B in itertools.combinations(B, r=2))\n            print(mex_A + mex_B)\n\ndef"
    },
    {
        "number": 2443,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    forbidden_products = list(map(int, stdin.split()))\n\n    def prefix_product(sequence):\n        return sum(sequence) % m\n\n    def is_valid(sequence):\n        return prefix_product(sequence) not in forbidden_products\n\n    def max_length(sequence):\n        return max(len(sequence), len(set(sequence)))\n\n    def construct_sequence(n, m):\n        sequence = [0] * n\n        sequence[0] = 0\n        sequence[1] = 1\n        sequence[2] = 2\n        sequence[3] = 3\n        sequence[4] = 4\n\n        for i in range(5, n):\n            sequence[i] = (sequence[i - 1] + sequence[i - 2] + sequence[i - 3] + sequence[i - 4] + sequence[i - 5]) % m\n\n        return sequence\n\n    sequence = construct_sequence(n, m)\n    while not is_valid(sequence):\n        sequence = construct_sequence(n, m)\n\n    length = max_length(sequence)\n    result = [sequence[i] for i in range(length)]\n\n    return f\"{length}\\n{' '.join(map(str, result))}\"\n"
    },
    {
        "number": 2444,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    t = list(map(int, stdin.split()[1:]))\n\n    def find_time(i: int) -> int:\n        time = 0\n        for j in range(i):\n            if t[j] < t[i]:\n                time += t[j] - t[i]\n        return time\n\n    time_to_receive = [find_time(i) for i in range(1, n + 1)]\n    time_to_receive.sort()\n    return \" \".join(map(str, time_to_receive))"
    },
    {
        "number": 2445,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        n = int(stdin.split()[1])\n        grid = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                grid[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and grid[i-1][j] == 0:\n                    grid[i][j] = 2\n                if j > 0 and grid[i][j-1] == 0:\n                    grid[i][j] = 3\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and j > 0 and grid[i-1][j-1] == 0:\n                    grid[i][j] = 4\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 0:\n                    grid[i][j] = 5\n        for i in range(n):\n            for j in range(n):\n                if j > 0 and grid[i][j-1] == 0:\n                    grid[i][j] = 6\n        for i in range(n):\n            for j in range(n):\n                if j < n-1 and grid[i][j+1] == 0:\n                    grid[i][j] = 7\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and grid[i+1][j] == 0:\n                    grid[i][j] = 8\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 0:\n                    grid[i][j] = 9\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 0:\n                    grid[i][j] = 10\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 0:\n                    grid[i][j] = 11\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 0:\n                    grid[i][j] = 12\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 0:\n                    grid[i][j] = 13\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 0:\n                    grid[i][j] = 14\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 0:\n                    grid[i][j] = 15\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 0:\n                    grid[i][j] = 16\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and j < n-1 and grid[i-1][j+1] == 0:\n                    grid[i][j] = 17\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j < n-1 and grid[i+1][j+1] == 0:\n                    grid[i][j] = 18\n        for i in range(n):\n            for j in range(n):\n                if i < n-1 and j > 0 and grid[i+1][j-1] == 0:\n                    grid[i][j] = 19\n        for i in range(n):\n            for j in range(n):\n                if i > 0 and j < n-1 and grid[i-1][j+1] =="
    },
    {
        "number": 2446,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    queries = map(int, stdin.split()[2:])\n\n    def gcd(a: list) -> int:\n        if len(a) == 1:\n            return a[0]\n        return gcd(a[1:])\n\n    def count_pairs(a: list, x: int) -> int:\n        count = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if gcd(a[i:j + 1]) == x:\n                    count += 1\n        return count\n\n    result = []\n    for x in queries:\n        result.append(count_pairs(a, x))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2447,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        s = stdin.split('\\n')[1]\n        n = len(s)\n        good = True\n        for i in range(n):\n            if s[i] == '0' and s[i+1:].count('0') >= 1 and s[i+1:].count('1') >= 1:\n                good = False\n                break\n            if s[i] == '1' and s[i+1:].count('0') >= 1 and s[i+1:].count('1') >= 1:\n                good = False\n                break\n        if good:\n            print(0)\n        else:\n            print(n)"
    },
    {
        "number": 2448,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, a, b, c = map(int, stdin.split('\\n')[1].split())\n        s = stdin.split('\\n')[2]\n        alice_wins = False\n        for i in range(n):\n            if s[i] == 'R' and a > 0:\n                a -= 1\n            elif s[i] == 'P' and b > 0:\n                b -= 1\n            elif s[i] == 'S' and c > 0:\n                c -= 1\n            if a == 0 and b == 0 and c == 0:\n                alice_wins = True\n                break\n        if alice_wins:\n            print(\"YES\")\n            print(\"\".join(['R' if i < n // 2 else 'S' for i in range(n)]))\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2449,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    T = set(map(int, stdin.split()))\n    MOD = 10**9 + 7\n\n    def count_good_sets(T):\n        def is_good(S):\n            for a in S:\n                if a > M:\n                    return False\n                for b in S:\n                    if b > M:\n                        return False\n                    if a!= b and (a & b) == 0 and (a ^ b) in S:\n                        return False\n            return True\n\n        def count_good_sets_helper(S, count):\n            if len(S) == 1:\n                return count\n            for i in range(len(S)):\n                if S[i] > M:\n                    continue\n                for j in range(i + 1, len(S)):\n                    if S[j] > M:\n                        continue\n                    if S[i]!= S[j] and (S[i] & S[j]) == 0 and (S[i] ^ S[j]) in S:\n                        count_good_sets_helper(S[:i] + S[j:] + S[i:j], count)\n            return count\n\n        count = 0\n        for S in T:\n            if is_good(S):\n                count_good_sets_helper(S, count)\n                count += 1\n        return count % MOD\n\n    return str(count_good_sets(T))"
    },
    {
        "number": 2450,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    testcases = int(stdin.split('\\n')[0])\n    for _ in range(testcases):\n        n, m, x, y = map(int, stdin.split('\\n')[1].split())\n        a = [list(row) for row in stdin.split('\\n')[2:]]\n        black_squares = [i for i, row in enumerate(a) for j, square in enumerate(row) if square == '*']\n        white_squares = [i for i, row in enumerate(a) for j, square in enumerate(row) if square == '.']\n\n        def is_valid(i, j, row, col):\n            if row < 0 or row >= n or col < 0 or col >= m:\n                return False\n            if a[row][col] == '*':\n                return True\n            if a[row][col] == '.':\n                return False\n            return False\n\n        def is_valid_tile(i, j, row, col):\n            if row < 0 or row >= n or col < 0 or col >= m:\n                return False\n            if a[row][col] == '*':\n                return False\n            if a[row][col] == '.':\n                return True\n            return False\n\n        def min_cost(i, j, row, col):\n            if is_valid(i, j, row, col):\n                return 0\n            if is_valid_tile(i, j, row, col):\n                return x\n            return y\n\n        def min_cost_helper(i, j, row, col, cost):\n            if i == n - 1 and j == m - 1:\n                return cost\n            if is_valid(i, j, row, col):\n                return min_cost_helper(i + 1, j, row, col, cost)\n            if is_valid_tile(i, j, row, col):\n                return min_cost_helper(i, j + 1, row, col, cost + x)\n            return min_cost_helper(i, j + 1, row, col, cost + y)\n\n        min_cost_value = min_cost_helper(0, 0, 0, 0, 0)\n        print(min_cost_value)"
    },
    {
        "number": 2451,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, a, b, k = map(int, stdin.split())\n    queries = []\n    for _ in range(k):\n        t_a, f_a, t_b, f_b = map(int, stdin.split())\n        queries.append((t_a, f_a, t_b, f_b))\n\n    def min_time(tower_a: int, floor_a: int, tower_b: int, floor_b: int) -> int:\n        if tower_a == tower_b:\n            return min(floor_a, floor_b)\n        else:\n            return min(floor_a, floor_b) + 1\n\n    result = []\n    for t_a, f_a, t_b, f_b in queries:\n        result.append(min_time(t_a - 1, f_a, t_b - 1, f_b))\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 2452,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        p = [i for i in range(1, n+1)]\n        for i in range(n-1):\n            for j in range(i+1, n):\n                if p[i] & p[j] == 0:\n                    p[i], p[j] = p[j], p[i]\n                    break\n        print(' '.join(map(str, p)))"
    },
    {
        "number": 2453,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    segments = []\n    for i in range(n):\n        l, r = map(int, stdin.split()[i+1].split(','))\n        segments.append((l, r))\n    points = set()\n    for l, r in segments:\n        for x in range(l, r+1):\n            points.add(x)\n    counts = [0] * (n+1)\n    for x in points:\n        for i in range(n):\n            if segments[i][0] <= x <= segments[i][1]:\n                counts[i+1] += 1\n    return''.join(map(str, counts))"
    },
    {
        "number": 2454,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    roads = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = map(int, stdin.split()[1:3])\n        roads[a - 1].append(b - 1)\n        roads[b - 1].append(a - 1)\n    visited = [False] * N\n    visited[0] = True\n    mood = 0\n    count = 0\n    def dfs(city):\n        nonlocal mood, count\n        if visited[city]:\n            return\n        visited[city] = True\n        count += 1\n        if city == N - 1:\n            mood = 1\n        for neighbor in roads[city]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        count -= 1\n    dfs(0)\n    return str((count + mood) % (10**9 + 7))"
    },
    {
        "number": 2455,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_cards(cards: str) -> list:\n        return [c for c in cards]\n\n    def get_table(cards: list, a: int, b: int) -> list:\n        table = []\n        for i in range(a):\n            row = cards[:b]\n            cards = cards[b:]\n            table.append(row)\n        return table\n\n    def get_winning_combinations(cards: list, a: int, b: int) -> list:\n        table = get_table(cards, a, b)\n        winning_combinations = []\n        for i in range(a):\n            for j in range(b):\n                if all(c == \"X\" for c in table[i][j]):\n                    winning_combinations.append((i + 1) * b + j + 1)\n        return winning_combinations\n\n    def get_distinct_combinations(winning_combinations: list) -> list:\n        distinct_combinations = []\n        for i in range(len(winning_combinations)):\n            for j in range(i + 1, len(winning_combinations)):\n                if winning_combinations[i]!= winning_combinations[j]:\n                    distinct_combinations.append((winning_combinations[i], winning_combinations[j]))\n        return distinct_combinations\n\n    def print_combinations(combinations: list) -> None:\n        for combination in combinations:\n            print(\" \".join(map(str, combination)))\n\n    def main() -> None:\n        t = int(stdin.split()[0])\n        for _ in range(t):\n            cards = stdin.split()[1]\n            cards = get_cards(cards)\n            a, b = map(int, stdin.split()[2].split(\"x\"))\n            winning_combinations = get_winning_combinations(cards, a, b)\n            distinct_combinations = get_distinct_combinations(winning_combinations)\n            print_combinations(distinct_combinations)\n\n    main()\n    return \"\"\n"
    },
    {
        "number": 2456,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, r = map(int, stdin.split()[1:])\n        k = 7\n        if r % k == 0:\n            n_weeks = r // k\n            n_days = n * n_weeks\n            print(n_days)\n        else:\n            n_weeks = r // k + 1\n            n_days = n * n_weeks\n            print(n_days)"
    },
    {
        "number": 2457,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, a, b, c, d = map(int, stdin.split()[1:])\n        if a - b > c - d:\n            return \"No\"\n        if a - b > n * (c - d) or n * (c - d) > a + b:\n            return \"No\"\n        if a - b > 0:\n            if a - b > n * (c - d) - a:\n                return \"No\"\n            if n * (c - d) - a > 0:\n                return \"Yes\"\n    return \"Yes\""
    },
    {
        "number": 2458,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def count_ways(a: int, b: int, k: int) -> int:\n        if a == b:\n            return 1\n        if a > b:\n            a, b = b, a\n        if k == 1:\n            return count_ways(a + 1, b, k)\n        if a % 2 == 0:\n            return count_ways(a + 1, b, k - 1) + count_ways(a, b - 1, k - 1)\n        else:\n            return count_ways(a + 1, b, k - 1) + count_ways(a, b - 1, k - 1)\n\n    ways = 0\n    for i in range(t):\n        ways += count_ways(a[i], b[i], k)\n\n    return str(ways % (10**9 + 7))"
    },
    {
        "number": 2459,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    for i in range(q):\n        t, l, r = map(int, stdin.split())\n        if t == 1:\n            for j in range(l, r):\n                a[j] += 1\n                a[l] = a[j]\n                a[r] = a[j]\n        elif t == 2:\n            for j in range(l, r):\n                a[j], a[r] = a[r], a[j]\n\n    for i in range(m):\n        print(a.index(b[i]))\n\n    return \"\""
    },
    {
        "number": 2460,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    a = [0] * m\n\n    for i in range(n):\n        if t[i] == 1:\n            a[t.index(1)] += 1\n\n    for i in range(m):\n        if a[i] == 0:\n            a[i] = 1\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 2461,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    edges = []\n    for i in range(n - 1):\n        x, y = map(int, stdin.split()[1:3])\n        edges.append((x - 1, y - 1))\n\n    def dfs(node, parent, depth):\n        nonlocal max_beauty\n        max_beauty = max(max_beauty, a[node])\n        for child in range(n):\n            if child!= node and (child, node) not in edges:\n                if child == parent:\n                    continue\n                dfs(child, node, depth + 1)\n\n    max_beauty = 0\n    dfs(0, -1, 0)\n    return \" \".join(map(str, max_beauty))\n"
    },
    {
        "number": 2462,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        if n == 1:\n            print('YES', end='')\n            for i in range(4):\n                print(i + 1, end=' ')\n            print()\n        elif n == 2:\n            print('NO')\n        else:\n            def is_nearly_prime(x: int) -> bool:\n                if x < 2:\n                    return False\n                for i in range(2, int(x ** 0.5) + 1):\n                    if x % i == 0:\n                        return False\n                return True\n\n            def sum_of_nearly_primes(n: int) -> int:\n                count = 0\n                for i in range(1, n + 1):\n                    if is_nearly_prime(i):\n                        count += i\n                return count\n\n            def find_nearly_primes(n: int) -> list:\n                result = []\n                for i in range(1, n + 1):\n                    if is_nearly_prime(i):\n                        result.append(i)\n                return result\n\n            def find_sum_of_nearly_primes(n: int) -> int:\n                result = []\n                for i in range(1, n + 1):\n                    if is_nearly_prime(i):\n                        result.append(i)\n                return sum(result)\n\n            def find_four_nearly_primes(n: int) -> list:\n                result = []\n                for i in range(1, n + 1):\n                    if is_nearly_prime(i):\n                        result.append(i)\n                if len(result) < 4:\n                    return []\n                result.sort()\n                return result[:4]\n\n            nearly_primes = find_nearly_primes(n)\n            sum_of_nearly_primes_n = sum_of_nearly_primes(n)\n            four_nearly_primes = find_four_nearly_primes(n)\n\n            if sum_of_nearly_primes_n == n:\n                print('YES')\n                for i in range(4):\n                    print(four_nearly_primes[i], end=' ')\n                print()\n            elif sum_of_nearly_primes_n < n:\n                print('NO')\n            else:\n                print('YES')\n                for i in range(4):\n                    print(four_nearly_primes[i], end=' ')\n                print()"
    },
    {
        "number": 2463,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1].split()))\n\n    cheap_prices = [a[0]]\n    for i in range(1, n):\n        if a[i] < cheap_prices[-1] + 2:\n            cheap_prices.append(a[i])\n        else:\n            break\n\n    return str(len(cheap_prices)) +'' +''.join(map(str, cheap_prices))"
    },
    {
        "number": 2464,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = []\n    for _ in range(n - 1):\n        x, y, c = map(int, stdin.split()[1:])\n        edges.append((x, y, c))\n    edges.sort()\n\n    valid_pairs = 0\n    for i in range(n - 1):\n        if edges[i][2] == 0:\n            continue\n        for j in range(i + 1, n - 1):\n            if edges[j][2] == 1:\n                valid_pairs += 1\n\n    return str(valid_pairs)"
    },
    {
        "number": 2465,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        ang = int(stdin.split()[1])\n        if ang == 180:\n            print(180)\n        else:\n            n = 1\n            while True:\n                if n * (n - 1) * (n - 2) * (n - 3) * (n - 4) * (n - 5) * (n - 6) * (n - 7) * (n - 8) * (n - 9) * (n - 10) * (n - 11) * (n - 12) * (n - 13) * (n - 14) * (n - 15) * (n - 16) * (n - 17) * (n - 18) * (n - 19) * (n - 20) * (n - 21) * (n - 22) * (n - 23) * (n - 24) * (n - 25) * (n - 26) * (n - 27) * (n - 28) * (n - 29) * (n - 30) * (n - 31) * (n - 32) * (n - 33) * (n - 34) * (n - 35) * (n - 36) * (n - 37) * (n - 38) * (n - 39) * (n - 40) * (n - 41) * (n - 42) * (n - 43) * (n - 44) * (n - 45) * (n - 46) * (n - 47) * (n - 48) * (n - 49) * (n - 50) * (n - 51) * (n - 52) * (n - 53) * (n - 54) * (n - 55) * (n - 56) * (n - 57) * (n - 58) * (n - 59) * (n - 60) * (n - 61) * (n - 62) * (n - 63) * (n - 64) * (n - 65) * (n - 66) * (n - 67) * (n - 68) * (n - 69) * (n - 70) * (n - 71) * (n - 72) * (n - 73) * (n - 74) * (n - 75) * (n - 76) * (n - 77) * (n - 78) * (n - 79) * (n - 80) * (n - 81) * (n - 82) * (n - 83) * (n - 84) * (n - 85) * (n - 86) * (n - 87) * (n - 88) * (n - 89) * (n - 90) * (n - 91) * (n - 92) * (n - 93) * (n - 94) * (n - 95) * (n - 96) * (n - 97) * (n - 98) * (n - 99) * (n - 100) * (n - 101) * (n - 102) * (n - 103) * (n - 104) * (n - 105) * (n - 106) * (n - 107) * (n - 108) * (n - 109) * (n - 110) * (n - 111) * (n - 112) * (n - 113) * (n - 114) * (n - 115) * (n - 116) * (n - 117) * (n - 118) * (n - 119)"
    },
    {
        "number": 2466,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    result = []\n\n    def backtrack(current_permutation):\n        if len(current_permutation) == len(input_list):\n            result.append(current_permutation[:])\n            return\n\n        for i in range(len(input_list)):\n            if i > 0 and input_list[i] == input_list[i - 1]:\n                continue\n            backtrack(current_permutation + [input_list[i]])\n\n    backtrack([])\n    return str(result)"
    },
    {
        "number": 2467,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    result = []\n    def backtrack(start, current_sum, current_set):\n        if current_sum == n:\n            result.append(current_set)\n            return\n        for i in range(start, 10):\n            if i not in current_set:\n                backtrack(i+1, current_sum+i, current_set.union({i}))\n    backtrack(1, 0, set())\n    return str(result)"
    },
    {
        "number": 2468,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    max_length = 0\n    for char in stdin:\n        if char == '(':\n            stack.append(char)\n        else:\n            if stack:\n                stack.pop()\n            else:\n                stack.append(char)\n            if not stack:\n                max_length = max(max_length, len(stdin) - len(stack))\n    return max_length"
    },
    {
        "number": 2469,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    arr = list(map(int, stdin.split()))\n    count = [0] * 101\n    for num in arr:\n        count[num] += 1\n    result = []\n    for i in range(1, 101):\n        if count[i] > n // 3:\n            result.append(i)\n    return str(result)"
    },
    {
        "number": 2470,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    arr1, arr2 = stdin.split()\n    arr1 = list(map(int, arr1.split(',')))\n    arr2 = list(map(int, arr2.split(',')))\n\n    min_operations = float('inf')\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if arr1[i] < arr2[j]:\n                min_operations = min(min_operations, i + j)\n\n    return str(min_operations) if min_operations!= float('inf') else '-1'"
    },
    {
        "number": 2471,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, N = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    a_set = set(zip(a, b))\n    a_set.add((H, W))\n    a_set = list(a_set)\n\n    def count_subrectangles(a: int, b: int, h: int, w: int) -> int:\n        count = 0\n        for i in range(h):\n            for j in range(w):\n                if (i, j) in a_set:\n                    count += 1\n        return count\n\n    result = []\n    for j in range(1, 10):\n        count = 0\n        for i in range(N):\n            if count_subrectangles(a_set[i][0], a_set[i][1], 3, 3) == j:\n                count += 1\n        result.append(str(count))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2472,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    jobs = []\n    for i in range(1, n + 1):\n        a, b = map(int, stdin.split()[i].split())\n        jobs.append((a, b))\n\n    jobs.sort(key=lambda x: x[1])\n\n    time = 0\n    completed = 0\n\n    for a, b in jobs:\n        if time + a <= b:\n            time += a\n            completed += 1\n        else:\n            break\n\n    if completed == n:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2473,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n\n    points.sort(key=lambda x: x[0])\n\n    area = 0\n    for i in range(n):\n        j = i + 1\n        while j < n and points[i][0] == points[j][0]:\n            j += 1\n        area += (points[j][1] - points[i][1]) * (points[j][0] - points[i][0])\n\n    return str(area)"
    },
    {
        "number": 2474,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    C = list(map(int, stdin.split()[1:]))\n\n    MOD = 10**9 + 7\n\n    def f(S, T):\n        return sum(C[j] * (S[j]!= T[j]) for j in range(N))\n\n    def dfs(S, T, memo):\n        if S == T:\n            return 0, 0\n\n        if (S, T) in memo:\n            return memo[(S, T)]\n\n        min_cost = float('inf')\n        for i in range(N):\n            if S[i] == 0:\n                min_cost = min(min_cost, dfs(S[:i] + [1] + S[i+1:], T, memo))\n            else:\n                min_cost = min(min_cost, dfs(S[:i] + [0] + S[i+1:], T, memo))\n\n        memo[(S, T)] = min_cost % MOD\n        return memo[(S, T)]\n\n    memo = {}\n    return str(dfs((0,) * N, (1,) * N, memo))"
    },
    {
        "number": 2475,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    s = list(map(int, stdin.split()[1:]))\n\n    def dfs(x, y, score):\n        if y == N - 1:\n            return score\n        if y < N - 1 and s[y] > 0:\n            return dfs(x, y + 1, score + s[y])\n        if y < N - 1 and s[y] == 0:\n            return dfs(x, y + 1, score - 10**100)\n        if y > 0 and s[y - 1] > 0:\n            return dfs(x, y - 1, score + s[y - 1])\n        if y > 0 and s[y - 1] == 0:\n            return dfs(x, y - 1, score - 10**100)\n        return dfs(x, y + 1, score)\n\n    return str(dfs(0, 0, 0))"
    },
    {
        "number": 2476,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = set(a)\n    max_times = 0\n    for k in range(1, n + 1):\n        times = 0\n        while len(a) > 1:\n            times += 1\n            a.remove(min(a))\n        max_times = max(max_times, times)\n    return \" \".join(map(str, max_times))"
    },
    {
        "number": 2477,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    logs = list(map(int, stdin.split()))\n\n    def cut_log(log, t):\n        return log + t, log - t\n\n    def cut_logs(logs, k):\n        cut_points = [0]\n        for i in range(1, len(logs)):\n            cut_points.append(cut_points[-1] + logs[i])\n\n        cut_points.append(sum(logs))\n\n        cut_logs = []\n        for i in range(k):\n            cut_log_index = bisect_left(cut_points, cut_points[i])\n            cut_logs.append(logs[cut_log_index])\n\n        return cut_logs\n\n    def bisect_left(arr, x):\n        lo, hi = 0, len(arr)\n        while lo < hi:\n            mid = (lo + hi) // 2\n            if arr[mid] < x:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo\n\n    cut_logs = cut_logs(logs, k)\n    longest_log = max(cut_logs)\n    return str(round(longest_log))"
    },
    {
        "number": 2478,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = s.replace(\"(\", \"\").replace(\")\", \"\")\n    stack = []\n    for c in s:\n        if c == \"(\":\n            stack.append(c)\n        elif c == \")\":\n            if not stack:\n                return \"Invalid\"\n            stack.pop()\n    if stack:\n        return \"Invalid\"\n    return \"\".join(stack)"
    },
    {
        "number": 2479,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    grid = [[0] * n for _ in range(n)]\n    black_stones = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0 or i == n - 1 or j == n - 1:\n                grid[i][j] = 1\n\n    for _ in range(q):\n        query = list(map(int, stdin.split()))\n        if query[0] == 1:\n            x = query[1]\n            if grid[0][x] == 0:\n                black_stones += 1\n                grid[0][x] = 1\n            for i in range(1, n):\n                if grid[i][x] == 0 and grid[i - 1][x] == 1:\n                    black_stones += 1\n                    grid[i][x] = 1\n        elif query[0] == 2:\n            x = query[1]\n            if grid[x][0] == 0:\n                black_stones += 1\n                grid[x][0] = 1\n            for j in range(1, n):\n                if grid[x][j] == 0 and grid[x][j - 1] == 1:\n                    black_stones += 1\n                    grid[x][j] = 1\n\n    return str(black_stones)"
    },
    {
        "number": 2480,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def is_valid(subseq: list) -> bool:\n        return sum(subseq) % K == len(subseq)\n\n    def count_subsequences(A: list, start: int, end: int, subseq: list) -> int:\n        if start > end:\n            return 1\n\n        count = 0\n        for i in range(start, end + 1):\n            if A[i] == subseq[-1]:\n                count += count_subsequences(A, start, i - 1, subseq)\n\n        return count\n\n    count = count_subsequences(A, 0, N - 1, [])\n    return str(count)"
    },
    {
        "number": 2481,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    c = [list(map(int, stdin.split())) for _ in range(10)]\n    A = [list(map(int, stdin.split())) for _ in range(H + 1)]\n\n    def dfs(i, j, mp):\n        if i == H:\n            return mp\n        if A[i][j] == -1:\n            return dfs(i + 1, j, mp)\n\n        if A[i][j] == 0:\n            return dfs(i + 1, j, mp)\n\n        mp += c[A[i][j]][A[i][j]]\n        return dfs(i + 1, j, mp)\n\n    return str(dfs(0, 0, 0))\n"
    },
    {
        "number": 2482,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    cities = [[] for _ in range(n + 1)]\n    roads = [[] for _ in range(k + 1)]\n    railways = [[] for _ in range(l + 1)]\n\n    for i in range(k):\n        p, q = map(int, stdin.split())\n        roads[i + 1].append((p, q))\n        roads[i + 1].append((q, p))\n\n    for i in range(l):\n        r, s = map(int, stdin.split())\n        railways[i + 1].append((r, s))\n        railways[i + 1].append((s, r))\n\n    for i in range(n):\n        p, q = map(int, stdin.split())\n        cities[p].append(q)\n        cities[q].append(p)\n\n    for i in range(k + 1):\n        for j in range(l + 1):\n            for city in cities:\n                if city:\n                    for road in roads[i]:\n                        if road[0] in city and road[1] in city:\n                            city.remove(road[0])\n                            city.remove(road[1])\n                    for railway in railways[j]:\n                        if railway[0] in city and railway[1] in city:\n                            city.remove(railway[0])\n                            city.remove(railway[1])\n\n    result = []\n    for city in cities:\n        result.append(len(city))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2483,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    programs = []\n    for _ in range(n):\n        s, t, c = map(int, stdin.split())\n        programs.append((s, t, c))\n\n    programs.sort(key=lambda x: (x[1], x[0]))\n\n    recorders = 0\n    current_channel = None\n    current_start = float('inf')\n\n    for s, t, c in programs:\n        if c!= current_channel:\n            recorders += 1\n            current_channel = c\n            current_start = s\n        elif s <= current_start:\n            recorders += 1\n            current_start = s\n\n    return str(recorders)"
    },
    {
        "number": 2484,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *A = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if A[i] ^ A[j] == A[i] + A[j]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2485,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, M = map(int, stdin.split())\n    targets = []\n    for _ in range(M):\n        h, w = map(int, stdin.split())\n        targets.append((h, w))\n\n    def bomb_destroy(h, w):\n        nonlocal targets\n        for i, (target_h, target_w) in enumerate(targets):\n            if target_h == h or target_w == w:\n                targets.pop(i)\n\n    def bomb_count(h, w):\n        nonlocal targets\n        count = 0\n        for i, (target_h, target_w) in enumerate(targets):\n            if target_h == h or target_w == w:\n                count += 1\n        return count\n\n    def bomb_max_count(h, w):\n        nonlocal targets\n        max_count = 0\n        for i, (target_h, target_w) in enumerate(targets):\n            if target_h == h or target_w == w:\n                max_count = max(max_count, bomb_count(target_h, target_w))\n        return max_count\n\n    def bomb_max_destroy(h, w):\n        nonlocal targets\n        max_destroy = 0\n        for i, (target_h, target_w) in enumerate(targets):\n            if target_h == h or target_w == w:\n                max_destroy = max(max_destroy, bomb_max_count(target_h, target_w))\n        return max_destroy\n\n    def bomb_max_destroy_square(h, w):\n        nonlocal targets\n        max_destroy = 0\n        max_square = (0, 0)\n        for i, (target_h, target_w) in enumerate(targets):\n            if target_h == h or target_w == w:\n                square = (target_h, target_w)\n                count = bomb_count(target_h, target_w)\n                max_count = bomb_max_count(target_h, target_w)\n                max_destroy = max(max_destroy, count)\n                if count == max_count:\n                    max_square = square\n        return max_destroy, max_square\n\n    max_destroy, max_square = bomb_max_destroy_square(0, 0)\n    print(max_destroy)\n    return \"\"\n"
    },
    {
        "number": 2486,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    unnecessary_cards = 0\n    for i in range(n):\n        good_subsets = set()\n        for subset in itertools.combinations(a, i + 1):\n            subset_sum = sum(subset)\n            if subset_sum >= k:\n                good_subsets.add(subset)\n        if len(good_subsets) == 0:\n            unnecessary_cards += 1\n\n    print(unnecessary_cards)\n    return \"\"\n"
    },
    {
        "number": 2487,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[1:]]\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    def count_connected_components(graph):\n        visited = [False] * (len(graph) + 1)\n        count = 0\n        for u in range(1, len(graph) + 1):\n            if not visited[u]:\n                dfs(u, visited)\n                count += 1\n        return count\n\n    def f(L, R):\n        return count_connected_components(graph[L:R + 1])\n\n    return str(sum(f(L, R) for L in range(1, n + 1) for R in range(L, n + 1)))"
    },
    {
        "number": 2488,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, a = map(int, stdin.split())\n    x_h = [list(map(int, stdin.split())) for _ in range(n)]\n    x_h.sort(key=lambda x: x[0])\n\n    bombs = 0\n    for i in range(n - 1):\n        if x_h[i][0] + d <= x_h[i + 1][0]:\n            bombs += 1\n            x_h[i][2] -= a\n            x_h[i + 1][2] -= a\n\n    return str(bombs)"
    },
    {
        "number": 2489,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[j] % a[i]!= 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2490,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    banknotes = [1] * 1000001\n    for i in range(1, 1000001):\n        banknotes[i] = banknotes[i - 1] + banknotes[i - 10] + banknotes[i - 100] + banknotes[i - 1000] + banknotes[i - 10000] + banknotes[i - 100000] + banknotes[i - 1000000] + banknotes[i - 10000000] + banknotes[i - 100000000] + banknotes[i - 1000000000] + banknotes[i - 10000000000] + banknotes[i - 100000000000] + banknotes[i - 1000000000000] + banknotes[i - 10000000000000] + banknotes[i - 100000000000000] + banknotes[i - 1000000000000000] + banknotes[i - 10000000000000000] + banknotes[i - 100000000000000000] + banknotes[i - 1000000000000000000] + banknotes[i - 10000000000000000000] + banknotes[i - 100000000000000000000] + banknotes[i - 1000000000000000000000] + banknotes[i - 10000000000000000000000] + banknotes[i - 100000000000000000000000] + banknotes[i - 1000000000000000000000000] + banknotes[i - 10000000000000000000000000] + banknotes[i - 100000000000000000000000000] + banknotes[i - 1000000000000000000000000000] + banknotes[i - 10000000000000000000000000000] + banknotes[i - 100000000000000000000000000000] + banknotes[i - 1000000000000000000000000000000] + banknotes[i - 10000000000000000000000000000000] + banknotes[i - 100000000000000000000000000000000] + banknotes[i - 1000000000000000000000000000000000] + banknotes[i - 10000000000000000000000000000000000] + banknotes[i - 100000000000000000000000000000000000] + banknotes[i - 10000000000000000"
    },
    {
        "number": 2491,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        edges.append((a, b, c))\n\n    def bellman_ford(graph, start):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        for _ in range(m):\n            for u in range(1, n + 1):\n                for v, w in graph[u]:\n                    if dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist\n\n    def max_score(graph, start):\n        dist = bellman_ford(graph, start)\n        max_score = 0\n        for u in range(1, n + 1):\n            max_score = max(max_score, dist[u])\n        return max_score\n\n    graph = [[] for _ in range(n + 1)]\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    max_score_at_vertex_n = max_score(graph, 1)\n    if max_score_at_vertex_n == float('inf'):\n        print('inf')\n    else:\n        print(max_score_at_vertex_n)"
    },
    {
        "number": 2492,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    A.sort()\n    result = A[K - 1]\n\n    return str(result)"
    },
    {
        "number": 2493,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:n+1]))\n    a.append(1)\n    a.sort()\n    MOD = 10**9 + 7\n    dp = [0] * (n+1)\n    dp[1] = 1\n    for i in range(2, n+1):\n        dp[i] = (dp[i-1] + dp[i-2]) % MOD\n    result = [0] * (n+1)\n    for i in range(1, n+1):\n        for j in range(i, n+1):\n            if a[i] == a[j]:\n                result[i] = (result[i] + dp[j-i]) % MOD\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2494,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    if K < 2 or K > 10**5:\n        return \"Invalid input\"\n\n    def sum_of_digits(n: int) -> int:\n        return sum(int(digit) for digit in str(n))\n\n    def smallest_sum(K: int) -> int:\n        max_num = 10**K\n        min_num = 1\n        while min_num <= max_num:\n            num = (min_num + max_num) // 2\n            if sum_of_digits(num) < sum_of_digits(num + 1):\n                min_num = num + 1\n            else:\n                max_num = num - 1\n        return min_num\n\n    return str(smallest_sum(K))"
    },
    {
        "number": 2495,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    count = 0\n    for i in range(1, n):\n        if a[i]!= 0:\n            count += 1\n            if a[i] * a[i - 1] < 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2496,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_coprime(a: int, b: int) -> bool:\n        return gcd(a, b) == 1\n\n    pairwise_coprime = all(is_coprime(a[i], a[j]) for i in range(n) for j in range(i + 1, n))\n    setwise_coprime = gcd(a[0], *a) == 1\n\n    if pairwise_coprime:\n        return \"pairwise coprime\"\n    elif setwise_coprime:\n        return \"setwise coprime\"\n    else:\n        return \"not coprime\""
    },
    {
        "number": 2497,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    points = []\n    for i in range(N):\n        x, y, d = map(int, stdin.split()[1:4])\n        points.append((x, y, d))\n    x_max, x_min = max(p[0] for p in points), min(p[0] for p in points)\n    y_max, y_min = max(p[1] for p in points), min(p[1] for p in points)\n    return str(abs(x_max - x_min) * abs(y_max - y_min))"
    },
    {
        "number": 2498,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def is_semi_common_multiple(x: int) -> bool:\n        for k in range(N):\n            if A[k] * (k + 0.5) == x:\n                return True\n        return False\n\n    count = 0\n    for i in range(1, M + 1):\n        if is_semi_common_multiple(i):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2499,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    red_count = 0\n    blue_count = 0\n    max_beauty = 0\n\n    for a in A:\n        if a & 1:\n            red_count += 1\n        else:\n            blue_count += 1\n\n        beauty = red_count ^ blue_count\n        max_beauty = max(max_beauty, beauty)\n\n    return str(max_beauty)"
    },
    {
        "number": 2500,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N+1):\n            if i ^ j == i and i + j == j:\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 2501,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    attendees = list(map(int, stdin.split()[1:]))\n\n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(attendees[i] - attendees[j]) == sum(attendees[i:j + 1]):\n                pairs += 1\n\n    return str(pairs)"
    },
    {
        "number": 2502,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = s.lower()\n    t = t.lower()\n    n = len(s)\n    m = len(t)\n    i = 0\n    max_i = 0\n    while i <= n - m:\n        if s[i:i+m] == t * i:\n            max_i = max(max_i, i)\n        i += 1\n    if max_i == 0:\n        return -1\n    return str(max_i)"
    },
    {
        "number": 2503,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    desires = []\n    for _ in range(n):\n        x, y, c = map(int, stdin.split())\n        desires.append((x, y, c))\n\n    def is_connected(x, y, k):\n        for i in range(x - k, x + k + 1):\n            for j in range(y - k, y + k + 1):\n                if i!= x or j!= y:\n                    if 0 <= i < n and 0 <= j < n and desires[i][j] == desires[x][y]:\n                        return True\n        return False\n\n    def count_connected_components(x, y, k):\n        count = 0\n        visited = set()\n        queue = [(x, y)]\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) not in visited:\n                visited.add((x, y))\n                count += 1\n                if is_connected(x, y, k):\n                    queue.extend(((i, j) for i in range(x - k, x + k + 1) for j in range(y - k, y + k + 1) if 0 <= i < n and 0 <= j < n and desires[i][j] == desires[x][y]))\n        return count\n\n    max_count = 0\n    for i in range(n):\n        for j in range(n):\n            if desires[i][j] == 'B':\n                max_count = max(max_count, count_connected_components(i, j, k))\n            else:\n                max_count = max(max_count, count_connected_components(i, j, k) - 1)\n\n    return str(max_count)"
    },
    {
        "number": 2504,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, l = map(int, stdin.split())\n    towns = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        towns[a].append((b, c))\n        towns[b].append((a, c))\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        s, t = map(int, stdin.split())\n        if s == t:\n            print(-1)\n        else:\n            min_fuel = float('inf')\n            for town in towns[s]:\n                if town[0] == t:\n                    min_fuel = min(min_fuel, town[1])\n            if min_fuel == float('inf'):\n                print(-1)\n            else:\n                print(min_fuel)"
    },
    {
        "number": 2505,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: (x[0], x[1]))\n\n    def f(T):\n        a, b, c, d = float('inf'), float('-inf'), float('inf'), float('-inf')\n        for x, y in T:\n            a = min(a, x)\n            b = max(b, x)\n            c = min(c, y)\n            d = max(d, y)\n        return (b - a + 1) * (d - c + 1)\n\n    def sum_f(T):\n        return sum(f(T))\n\n    result = sum_f(points) % 998244353\n    return str(result)"
    },
    {
        "number": 2506,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    max_happiness = 0\n    for i in range(m):\n        x, y = i % n, (i % n) + 1\n        if (x, y) not in [(x, y) for x in range(m) for y in range(x, m)]:\n            max_happiness += a[x] + a[y]\n    return str(max_happiness)"
    },
    {
        "number": 2507,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    f = list(map(int, stdin.split()))\n\n    def min_time(a, f):\n        time = 0\n        for i in range(len(a)):\n            time += a[i] * f[i]\n        return time\n\n    def min_score(a, f):\n        min_time_set = []\n        for i in range(k):\n            min_time_set.append(min_time(a, f))\n        return min_time_set\n\n    min_time_set = min_score(a, f)\n    return str(min(min_time_set))"
    },
    {
        "number": 2508,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n    c = [list(row) for row in stdin.split()[1:].split('\\n')]\n\n    def is_valid(i, j):\n        return 1 <= i <= H and 1 <= j <= W and c[i - 1][j - 1] == '.'\n\n    def is_blocked(i, j):\n        return c[i - 1][j - 1] == '@'\n\n    def is_valid_move(i, j, d):\n        ni, nj = i + d[0], j + d[1]\n        return is_valid(ni, nj) and not is_blocked(ni, nj)\n\n    def min_moves(i, j, d):\n        if d == (0, 1):\n            return min(min_moves(i, j, (0, 1)), min_moves(i, j, (0, -1)))\n        elif d == (1, 0):\n            return min(min_moves(i, j, (1, 0)), min_moves(i, j, (-1, 0)))\n        elif d == (0, -1):\n            return min(min_moves(i, j, (0, -1)), min_moves(i, j, (0, 1)))\n        elif d == (-1, 0):\n            return min(min_moves(i, j, (-1, 0)), min_moves(i, j, (1, 0)))\n        else:\n            return min(min_moves(i, j, (1, 1)), min_moves(i, j, (-1, -1)), min_moves(i, j, (1, -1)), min_moves(i, j, (-1, 1)))\n\n    def min_moves_to_target(i, j):\n        return min_moves(i, j, (x2 - i, y2 - j))\n\n    def min_moves_to_target_helper(i, j, min_moves_to_target_value):\n        if i == x2 and j == y2:\n            return min_moves_to_target_value\n        if not is_valid(i, j):\n            return float('inf')\n        if is_blocked(i, j):\n            return float('inf')\n        min_moves_to_target_value = min(min_moves_to_target_value, min_moves_to_target_helper(i + 1, j, min_moves_to_target_value + 1))\n        min_moves_to_target_value = min(min_moves_to_target_value, min_moves_to_target_helper(i, j + 1, min_moves_to_target_value + 1))\n        min_moves_to_target_value = min(min_moves_to_target_value, min_moves_to_target_helper(i - 1, j, min_moves_to_target_value + 1))\n        min_moves_to_target_value = min(min_moves_to_target_value, min_moves_to_target_helper(i, j - 1, min_moves_to_target_value + 1))\n        return min_moves_to_target_value\n\n    min_moves_to_target_value = min_moves_to_target_helper(x1 - 1, y1 - 1, 0)\n    if min_moves_to_target_value == float('inf'):\n        return -1\n    return min_moves_to_target_value"
    },
    {
        "number": 2509,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for i in range(N+1):\n        for j in range(i+1, N+1):\n            if i % j == K:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2510,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        friends[a].append(b)\n        friends[b].append(a)\n\n    def dfs(person: int, visited: set) -> int:\n        visited.add(person)\n        count = 1\n        for friend in friends[person]:\n            if friend not in visited:\n                count += dfs(friend, visited)\n        return count\n\n    groups = []\n    for person in range(1, n + 1):\n        if dfs(person, set()) == 1:\n            groups.append(person)\n\n    return str(len(groups))"
    },
    {
        "number": 2511,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    edges = [tuple(map(int, stdin.split())) for _ in range(n - 1)]\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    def dfs(node, color):\n        if node == n - 1:\n            return 1\n        count = 0\n        for neighbor in graph[node]:\n            if neighbor!= color:\n                count += dfs(neighbor, color)\n        return count\n\n    ways = 0\n    for color in range(k):\n        ways += dfs(0, color)\n\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 2512,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    grid = []\n    for _ in range(K):\n        r, c, v = map(int, stdin.split())\n        grid.append((r, c, v))\n\n    def bfs(start: tuple, goal: tuple) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, value = queue.pop(0)\n            if current == goal:\n                return value\n            if current not in visited:\n                visited.add(current)\n                for neighbor in get_neighbors(current):\n                    queue.append((neighbor, value + grid[neighbor[0] - 1][neighbor[1] - 1]))\n        return -1\n\n    def get_neighbors(current: tuple) -> list:\n        i, j = current\n        return [(i + 1, j), (i, j + 1)]\n\n    return str(max(bfs((1, 1), (R, C)), bfs((1, 1), (R, C)), key=lambda x: x))\n"
    },
    {
        "number": 2513,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    s = list(s)\n\n    def is_valid(i: int) -> bool:\n        if s[i - 1] == s[i + 1]:\n            return s[i - 1] == 'o'\n        else:\n            return s[i - 1] == 'x' and s[i + 1] == 'o'\n\n    valid_animals = [i for i in range(1, n + 1) if is_valid(i)]\n\n    if not valid_animals:\n        return -1\n\n    sheep = [i for i in valid_animals if s[i - 1] == 'o']\n    wolves = [i for i in valid_animals if s[i - 1] == 'x']\n\n    if not sheep or not wolves:\n        return -1\n\n    sheep_neighbors = [s[i - 1] for i in range(1, len(s) - 1) if s[i - 1] == 'o']\n    wolves_neighbors = [s[i - 1] for i in range(1, len(s) - 1) if s[i - 1] == 'x']\n\n    if len(set(sheep_neighbors)) == 1 and len(set(wolves_neighbors)) == 1:\n        return 'S' * len(sheep) + 'W' * len(wolves)\n    else:\n        return -1"
    },
    {
        "number": 2514,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    b, *c = map(int, stdin.split()[2:])\n\n    def replace_and_sum(a: list, b: list, c: list) -> int:\n        for i, (x, y) in enumerate(zip(a, b)):\n            if x == y:\n                a[i] = c[i]\n        return sum(a)\n\n    s = [replace_and_sum(a, b, c) for _ in range(q)]\n    return \"\\n\".join(map(str, s))\n"
    },
    {
        "number": 2515,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    queries_list = []\n    for _ in range(queries):\n        l, r = map(int, stdin.split()[1:])\n        queries_list.append((l, r))\n    queries_list.sort()\n    count = 0\n    for l, r in queries_list:\n        if is_prime(l) and is_prime(r):\n            count += r - l + 1\n    return str(count)\n\ndef"
    },
    {
        "number": 2516,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = input()\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_substrings(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                if s[i:j] % P == 0:\n                    count += 1\n        return count\n\n    prime_count = 0\n    for i in range(2, N + 1):\n        if is_prime(i):\n            prime_count += 1\n\n    total_count = prime_count * (prime_count + 1) // 2\n    for i in range(N):\n        total_count += count_substrings(S[:i] + S[i + 1:])\n\n    return str(total_count)"
    },
    {
        "number": 2517,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    roads = []\n    for i in range(m):\n        a, b, c = map(int, stdin.split())\n        roads.append((a - 1, b - 1, c))\n\n    def bellman_ford(graph: List[List[Tuple[int, int, int]]], start: int) -> int:\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(m):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist\n\n    def min_distance(graph: List[List[Tuple[int, int, int]]], start: int, end: int) -> int:\n        dist = bellman_ford(graph, start)\n        return dist[end]\n\n    def min_distance_joisino(graph: List[List[Tuple[int, int, int]]], start: int, end: int) -> int:\n        min_dist = float('inf')\n        for town in range(n):\n            if town!= start and town!= end:\n                min_dist = min(min_dist, min_distance(graph, town, end))\n        return min_dist\n\n    graph = [[] for _ in range(n)]\n    for a, b, c in roads:\n        graph[a].append((b, c, 1))\n        graph[b].append((a, c, 1))\n\n    min_dist = min_distance_joisino(graph, 0, n - 1)\n    return str(min_dist)"
    },
    {
        "number": 2518,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    explosions = 0\n    while any(h):\n        explosions += 1\n        for i in range(n):\n            if h[i] > 0:\n                h[i] -= a\n                if h[i] <= 0:\n                    h[i] = 0\n                for j in range(i + 1, n):\n                    if h[j] > 0:\n                        h[j] -= b\n                        if h[j] <= 0:\n                            h[j] = 0\n\n    return str(explosions)"
    },
    {
        "number": 2519,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def expected_value(p: List[int]) -> float:\n        total = sum(p)\n        return total / len(p)\n\n    def max_expected_value(p: List[int]) -> float:\n        total = sum(p)\n        max_value = total\n        for i in range(1, N + 1):\n            p_i = p[i - 1]\n            if p_i > 0:\n                p_i -= 1\n                new_total = total - p_i\n                new_p = [p_i] + p[:i - 1]\n                new_value = expected_value(new_p)\n                if new_value > max_value:\n                    max_value = new_value\n        return max_value\n\n    return str(max_expected_value(p))"
    },
    {
        "number": 2520,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a_friends = [[] for _ in range(n + 1)]\n    b_friends = [[] for _ in range(n + 1)]\n    c_blocks = [[] for _ in range(n + 1)]\n    d_blocks = [[] for _ in range(n + 1)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        a_friends[a].append(b)\n        b_friends[b].append(a)\n\n    for _ in range(k):\n        c, d = map(int, stdin.split())\n        c_blocks[c].append(d)\n        d_blocks[d].append(c)\n\n    def is_friend(a: int, b: int) -> bool:\n        return a!= b and not (a in a_friends[b] or b in a_friends[a]) and not (a in b_friends[b] or b in b_friends[a])\n\n    def is_blocked(a: int, b: int) -> bool:\n        return a!= b and not (a in c_blocks[b] or b in c_blocks[a]) and not (a in d_blocks[b] or b in d_blocks[a])\n\n    def has_friend_sequence(a: int, b: int) -> bool:\n        return a!= b and all(is_friend(c, b) for c in range(1, n + 1))\n\n    friend_candidates = [0] * (n + 1)\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if is_friend(i, j) and not is_blocked(i, j) and has_friend_sequence(i, j):\n                friend_candidates[i] += 1\n\n    return \" \".join(map(str, friend_candidates))"
    },
    {
        "number": 2521,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    a_prime = a[N:] + a[:N]\n    a_prime_sum = sum(a_prime)\n\n    return str(a_prime_sum)"
    },
    {
        "number": 2522,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    a.sort()\n    b.sort()\n\n    for i in range(n):\n        if a[i]!= b[i]:\n            return \"No\"\n\n    for i in range(n - 1):\n        if a[i] > b[i + 1]:\n            return \"No\"\n\n    for i in range(n - 2, -1, -1):\n        if a[i] < b[i + 1]:\n            return \"No\"\n\n    return \"Yes\\n\" + \" \".join(map(str, b))\n"
    },
    {
        "number": 2523,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    N = len(S)\n    max_k = 0\n    for i in range(1, N):\n        if S[i] == 0 and S[i-1] == 1:\n            max_k = max(max_k, i-1)\n    return str(max_k)"
    },
    {
        "number": 2524,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n    MOD = 10**9 + 7\n\n    def sum_pairs(A: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(A)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = A[0]\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n        return dp[n]\n\n    def xor_sum(A: List[int]) -> int:\n        MOD = 10**9 + 7\n        n = len(A)\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = A[0]\n        for i in range(2, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n        return dp[n]\n\n    return str(sum_pairs(A) % MOD)"
    },
    {
        "number": 2525,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, Q = stdin.split()\n    S = list(S)\n    for _ in range(int(Q)):\n        T, F, C = map(int, stdin.split())\n        if T == 1:\n            S.reverse()\n        elif T == 2:\n            if F == 1:\n                S.insert(0, C)\n            else:\n                S.append(C)\n    return ''.join(S)"
    },
    {
        "number": 2526,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, A, B, C = map(int, stdin.split())\n    p = list(map(int, stdin.split()[1:]))\n    q = list(map(int, stdin.split()[1:]))\n    r = list(map(int, stdin.split()[1:]))\n\n    def max_sum(p, q, r):\n        def colorless_apples(p, q, r):\n            return max(p, q, r)\n\n        def paint_colorless_apples(p, q, r):\n            return max(p, q, r)\n\n        def eaten_apples(p, q, r):\n            return max(p, q, r)\n\n        def total_deliciousness(p, q, r):\n            return sum(p) + sum(q) + sum(r)\n\n        def colorless_apples_sum(p, q, r):\n            return sum(p) + sum(q) + sum(r)\n\n        def paint_colorless_apples_sum(p, q, r):\n            return sum(p) + sum(q) + sum(r)\n\n        def eaten_apples_sum(p, q, r):\n            return sum(p) + sum(q) + sum(r)\n\n        def total_sum(p, q, r):\n            return sum(p) + sum(q) + sum(r)\n\n        return max(\n            total_sum(p, q, r),\n            max(\n                colorless_apples_sum(p, q, r),\n                paint_colorless_apples_sum(p, q, r),\n                eaten_apples_sum(p, q, r),\n            ),\n        )\n\n    return str(max_sum(p, q, r))\n"
    },
    {
        "number": 2527,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin.lower()\n    if \"iloveyou\" in message:\n        return \"happy\"\n    else:\n        return \"sad\""
    },
    {
        "number": 2528,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n    \n    max_length = 0\n    max_product = 0\n    \n    for i in range(n):\n        for j in range(i, n):\n            product = 1\n            for k in range(i, j+1):\n                product *= A[k]\n            if product > max_product:\n                max_product = product\n                max_length = j - i + 1\n                \n    return str(max_length)"
    },
    {
        "number": 2529,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    X, Y = map(int, stdin.split())\n\n    # Check if X is a multiple of 5\n    if X % 5!= 0:\n        return str(Y)\n\n    # Calculate the amount to be charged for the transaction\n    bank_charge = 0.50\n    transaction_amount = X + bank_charge\n\n    # Check if the account balance has enough cash to perform the transaction\n    if transaction_amount > Y:\n        return str(Y)\n\n    # Calculate the new account balance after the transaction\n    new_balance = Y - transaction_amount\n\n    # Return the new account balance\n    return str(new_balance)"
    },
    {
        "number": 2530,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    chefs = {}\n    for i in range(int(stdin.split()[0])):\n        name, country = stdin.split()[1:3]\n        if country not in chefs:\n            chefs[country] = []\n        chefs[country].append(name)\n\n    votes = {}\n    for i in range(int(stdin.split()[1])):\n        subject = stdin.split()[2]\n        if subject in chefs:\n            for chef in chefs[subject]:\n                if chef not in votes:\n                    votes[chef] = 0\n                votes[chef] += 1\n\n    max_votes = 0\n    winner = \"\"\n    max_chef = \"\"\n    for country, chefs in chefs.items():\n        if max_votes < len(chefs):\n            max_votes = len(chefs)\n            winner = country\n            max_chef = max(chefs, key=lambda x: votes[x])\n\n    return winner + \"\\n\" + max_chef"
    },
    {
        "number": 2531,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + a[j] == a[i]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2532,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    def magic_sequence(n: int, a: list, b: list, d: list) -> int:\n        if n == 0:\n            return 0\n        else:\n            return (magic_sequence(n - 1, a, b, d) + a[n - 1] * d[n - 1] ** n) % 1000000\n\n    sequence = [magic_sequence(i, a, b, d) for i in range(10)]\n    return \" \".join(map(str, sequence))\n"
    },
    {
        "number": 2533,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(e):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(city, visited):\n        visited.add(city)\n        for neighbor in graph[city]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    def is_tourist_friendly(city, visited):\n        visited.add(city)\n        for neighbor in graph[city]:\n            if neighbor not in visited:\n                if not is_tourist_friendly(neighbor, visited):\n                    return False\n        return True\n\n    tourist_friendly_cities = set()\n    for city in range(1, n + 1):\n        if is_tourist_friendly(city, set()):\n            tourist_friendly_cities.add(city)\n\n    if not tourist_friendly_cities:\n        return \"NO\"\n\n    result = []\n    for city in tourist_friendly_cities:\n        result.append(str(city) + \" \" + str(city))\n\n    return \"YES\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 2534,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    matrix = []\n    for _ in range(R):\n        matrix.append(list(map(int, stdin.split()[1].split())))\n\n    min_cost = float('inf')\n    for row in matrix:\n        for cost in row:\n            if cost < min_cost:\n                min_cost = cost\n\n    if min_cost == float('inf'):\n        return \"GUESS\"\n    else:\n        return str(min_cost)"
    },
    {
        "number": 2535,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, N = map(int, stdin.split())\n    cars = [list(map(int, car)) for car in stdin.split('\\n')]\n\n    def count_ways(car: List[int], compartment: int, tickets: int) -> int:\n        if tickets == 0:\n            return 1\n        if tickets < 0:\n            return 0\n\n        if compartment == 9:\n            return 0\n\n        if car[compartment] == 0:\n            return count_ways(car, compartment + 1, tickets)\n        else:\n            return count_ways(car, compartment + 1, tickets - 1) + count_ways(car, compartment + 1, tickets)\n\n    ways = 0\n    for car in cars:\n        for compartment in range(9):\n            ways += count_ways(car, compartment, X)\n\n    return str(ways)"
    },
    {
        "number": 2536,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    matrix = [list(map(int, stdin.split()[i + 1].split())) for i in range(n)]\n    pairs = [list(map(int, stdin.split()[n + 2].split())) for _ in range(l)]\n\n    def calculate_sum(matrix, row, col):\n        if row == 0:\n            return matrix[row][col]\n        return matrix[row][col] + calculate_sum(matrix, row - 1, col)\n\n    def calculate_max_sum(matrix, pairs):\n        max_sum = -1\n        for i, j in pairs:\n            if i > 0:\n                max_sum = max(max_sum, calculate_sum(matrix, i - 1, j) + calculate_sum(matrix, i, j))\n            if j > 0:\n                max_sum = max(max_sum, calculate_sum(matrix, i, j - 1) + calculate_sum(matrix, i, j))\n        return max_sum\n\n    max_sum = calculate_max_sum(matrix, pairs)\n    return str(max_sum)"
    },
    {
        "number": 2537,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        s, t, p = stdin.split()[1:]\n        if s == t:\n            print(\"YES\")\n        else:\n            for i in range(len(p)):\n                if p[i] in s:\n                    s = s[:s.index(p[i])] + p[i] + s[s.index(p[i])+1:]\n            if s == t:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    return \"\""
    },
    {
        "number": 2538,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        str, int, exp = map(int, stdin.split()[1:])\n        def build(strength, intelligence):\n            return (strength, intelligence)\n\n        def is_valid(strength, intelligence):\n            return strength > intelligence\n\n        def is_better(build1, build2):\n            return build1[0] > build2[0] or (build1[0] == build2[0] and build1[1] > build2[1])\n\n        def count_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_better_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j) and is_better(build(i, j), build(strength, intelligence)):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_better_all_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j) and is_better(build(i, j), build(strength, intelligence)):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_better_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j) and is_better(build(i, j), build(strength, intelligence)):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_better_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j) and is_better(build(i, j), build(strength, intelligence)):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_all_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_all_better_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j) and is_better(build(i, j), build(strength, intelligence)):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_all_all_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_all_all_better_builds(strength, intelligence):\n            builds = set()\n            for i in range(strength + 1):\n                for j in range(intelligence + 1):\n                    if is_valid(i, j) and is_better(build(i, j), build(strength, intelligence)):\n                        builds.add(build(i, j))\n            return len(builds)\n\n        def count_all_all_all_all_all_builds("
    },
    {
        "number": 2539,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    queries = []\n    for _ in range(t):\n        x, p, k = map(int, stdin.split()[1:])\n        queries.append((x, p, k))\n    queries.sort()\n    result = []\n    for x, p, k in queries:\n        index = bisect_left(L, k)\n        result.append(L[index])\n    return \" \".join(map(str, result))\n\ndef"
    },
    {
        "number": 2540,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *colors = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for i, (x, y) in enumerate(zip(colors, colors[1:]), 1):\n        graph[x].append(y)\n        graph[y].append(x)\n\n    def dfs(vertex, color, dominating_colors):\n        nonlocal sums\n        sums[vertex] = dominating_colors\n        for child in graph[vertex]:\n            if child!= color:\n                dfs(child, color, dominating_colors + sums[child])\n\n    sums = [0] * (n + 1)\n    dfs(1, 0, 0)\n    return \" \".join(map(str, sums))\n"
    },
    {
        "number": 2541,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    result = []\n\n    for _ in range(queries):\n        l, r = map(int, stdin.split()[1:])\n        count = 0\n\n        for x in range(l, r + 1):\n            if x == 1:\n                continue\n            a = 1\n            p = 1\n            while x!= a ** p:\n                a += 1\n                p += 1\n            if p > 1:\n                count += 1\n\n        result.append(str(count))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2542,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        s = stdin.split('\\n')[1]\n        n = len(s)\n        left_shift = s[n:] + s[:n]\n        right_shift = s[n-1::-1] + s[0]\n        if left_shift == right_shift:\n            print(0)\n        else:\n            print(n)"
    },
    {
        "number": 2543,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = a[n:]\n    a = a[:n]\n\n    def f(j):\n        return abs(sum(a[i] - b[i + j] for i in range(n)))\n\n    min_f = f(0)\n    for _ in range(q):\n        l, r, x = map(int, stdin.split())\n        a[l - 1:r] = [a[i] + x for i in range(l - 1, r)]\n        min_f = min(min_f, f(0))\n\n    return str(min_f)\n"
    },
    {
        "number": 2544,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, parent, centroid):\n        visited[centroid] = True\n        for neighbor in graph[centroid]:\n            if neighbor not in visited:\n                parent[neighbor] = centroid\n                dfs(graph, visited, parent, neighbor)\n\n    def find_centroid(graph):\n        visited = [False] * (len(graph) + 1)\n        parent = [0] * (len(graph) + 1)\n        for i in range(1, len(graph) + 1):\n            if not visited[i]:\n                dfs(graph, visited, parent, i)\n        return parent\n\n    def find_unique_centroid(graph):\n        centroids = find_centroid(graph)\n        unique_centroids = []\n        for i in range(1, len(graph) + 1):\n            if centroids[i] not in unique_centroids:\n                unique_centroids.append(centroids[i])\n        return unique_centroids\n\n    def find_smallest_possible_size(graph):\n        visited = [False] * (len(graph) + 1)\n        parent = [0] * (len(graph) + 1)\n        for i in range(1, len(graph) + 1):\n            if not visited[i]:\n                dfs(graph, visited, parent, i)\n        return len(visited) - 1\n\n    def find_smallest_possible_size_tree(graph):\n        unique_centroids = find_unique_centroid(graph)\n        smallest_size = float('inf')\n        for centroid in unique_centroids:\n            size = find_smallest_possible_size(graph)\n            if size < smallest_size:\n                smallest_size = size\n        return smallest_size\n\n    def find_unique_centroid_tree(graph):\n        unique_centroids = find_unique_centroid(graph)\n        smallest_size = find_smallest_possible_size_tree(graph)\n        result = []\n        for centroid in unique_centroids:\n            size = find_smallest_possible_size(graph)\n            if size == smallest_size:\n                result.append(centroid)\n        return result\n\n    def find_unique_centroid_tree_with_edge(graph, edge):\n        unique_centroids = find_unique_centroid(graph)\n        smallest_size = find_smallest_possible_size_tree(graph)\n        result = []\n        for centroid in unique_centroids:\n            size = find_smallest_possible_size(graph)\n            if size == smallest_size:\n                result.append(centroid)\n        for i in range(len(result)):\n            for j in range(i + 1, len(result)):\n                if (result[i], result[j]) == edge or (result[j], result[i]) == edge:\n                    result.pop(i)\n                    break\n        return result\n\n    def find_unique_centroid_tree_with_edge_and_size(graph, edge):\n        unique_centroids = find_unique_centroid(graph)\n        smallest_size = find_smallest_possible_size_tree(graph)\n        result = []\n        for centroid in unique_centroids:\n            size = find_smallest_possible_size(graph)\n            if size == smallest_size:\n                result.append(centroid)\n        for i in range(len(result)):\n            for j in range(i + 1, len(result)):\n                if (result[i], result[j]) == edge or (result[j], result[i]) == edge:\n                    result.pop(i)\n                    break\n        return result, smallest_size\n\n    def find_unique_centroid_tree_with_edge_and_size_and_graph(graph, edge):\n        unique_centroids = find_unique_centroid(graph)\n        smallest_size = find_smallest_possible_size_tree(graph)\n        result = []\n        for centroid in unique_centroids:\n            size = find_smallest_possible_size(graph)\n            if size == smallest_size:\n                result.append(centroid)\n        for i in range(len(result)):\n            for j in range(i + 1, len(result)):\n                if (result[i], result[j]) == edge or (result[j], result[i]) == edge:\n                    result.pop(i)\n                    break\n        return result, smallest_size, graph\n\n    def find_unique_centroid_tree_with_edge_and_size_and_graph_with_edge(graph, edge):\n        unique_centroids = find_unique_centroid(graph)\n        smallest_size = find_smallest_possible_size_tree(graph)\n        result = []\n        for centroid in unique_centroids:"
    },
    {
        "number": 2545,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b = map(int, stdin.split()[1:])\n        if a == 0 and b == 0:\n            print(\"YES\")\n        else:\n            for x in range(1, min(a, b) + 1):\n                if a - x == 0 and b - 2 * x == 0:\n                    print(\"YES\")\n                    break\n                elif a - 2 * x == 0 and b - x == 0:\n                    print(\"YES\")\n                    break\n                elif a - x == 0 and b - 2 * x == 0:\n                    print(\"YES\")\n                    break\n                elif a - 2 * x == 0 and b - x == 0:\n                    print(\"YES\")\n                    break\n            else:\n                print(\"NO\")"
    },
    {
        "number": 2546,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def median(arr: list) -> int:\n        arr.sort()\n        n = len(arr)\n        if n % 2 == 0:\n            return (arr[n // 2 - 1] + arr[n // 2]) // 2\n        else:\n            return arr[n // 2]\n\n    def find_median(n: int, s: int, l: list, r: list) -> int:\n        total_salary = sum(l)\n        if total_salary > s:\n            return -1\n\n        total_salary_left = 0\n        total_salary_right = 0\n        for i in range(n):\n            total_salary_left += l[i]\n            total_salary_right += r[i]\n            if total_salary_left <= s:\n                return l[i]\n            if total_salary_right <= s:\n                return r[i]\n\n        return -1\n\n    def find_max_median(n: int, s: int, l: list, r: list) -> int:\n        total_salary = sum(l)\n        if total_salary > s:\n            return -1\n\n        total_salary_left = 0\n        total_salary_right = 0\n        max_median = -1\n        for i in range(n):\n            total_salary_left += l[i]\n            total_salary_right += r[i]\n            if total_salary_left <= s:\n                max_median = max(max_median, l[i])\n            if total_salary_right <= s:\n                max_median = max(max_median, r[i])\n\n        return max_median\n\n    def find_min_median(n: int, s: int, l: list, r: list) -> int:\n        total_salary = sum(l)\n        if total_salary > s:\n            return -1\n\n        total_salary_left = 0\n        total_salary_right = 0\n        min_median = float('inf')\n        for i in range(n):\n            total_salary_left += l[i]\n            total_salary_right += r[i]\n            if total_salary_left <= s:\n                min_median = min(min_median, l[i])\n            if total_salary_right <= s:\n                min_median = min(min_median, r[i])\n\n        return min_median\n\n    def find_median_salary(n: int, s: int, l: list, r: list) -> int:\n        total_salary = sum(l)\n        if total_salary > s:\n            return -1\n\n        total_salary_left = 0\n        total_salary_right = 0\n        median_salary = -1\n        for i in range(n):\n            total_salary_left += l[i]\n            total_salary_right += r[i]\n            if total_salary_left <= s:\n                median_salary = max(median_salary, l[i])\n            if total_salary_right <= s:\n                median_salary = max(median_salary, r[i])\n\n        return median_salary\n\n    def find_max_median_salary(n: int, s: int, l: list, r: list) -> int:\n        total_salary = sum(l)\n        if total_salary > s:\n            return -1\n\n        total_salary_left = 0\n        total_salary_right = 0\n        max_median_salary = -1\n        for i in range(n):\n            total_salary_left += l[i]\n            total_salary_right += r[i]\n            if total_salary_left <= s:\n                max_median_salary = max(max_median_salary, l[i])\n            if total_salary_right <= s:\n                max_median_salary = max(max_median_salary, r[i])\n\n        return max_median_salary\n\n    def find_min_median_salary(n: int, s: int, l: list, r: list) -> int:\n        total_salary = sum(l)\n        if total_salary > s:\n            return -1\n\n        total_salary_left = 0\n        total_salary_right = 0\n        min_median_salary = float('inf')\n        for i in range(n):\n            total_salary_left += l[i]\n            total_salary_right += r[i]\n            if total_salary_left <= s:\n                min_median_salary = min(min_median_salary, l[i])\n            if total_salary_right <= s:\n                min_median_salary = min(min_median_salary, r[i])\n\n        return min_median_salary\n\n    def find"
    },
    {
        "number": 2547,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    books = []\n    for _ in range(n):\n        t, a, b = map(int, stdin.split())\n        books.append((t, a, b))\n\n    books.sort(key=lambda x: x[0])\n\n    alice_likes = [book[1] for book in books[:m]]\n    bob_likes = [book[2] for book in books[:m]]\n\n    alice_likes_count = sum(alice_likes)\n    bob_likes_count = sum(bob_likes)\n\n    if alice_likes_count >= k and bob_likes_count >= k:\n        total_time = sum(book[0] for book in books[:m])\n        return f\"{total_time}\\n{m} {1} {2} {3} {4} {5}\"\n    else:\n        return \"-1\\n\""
    },
    {
        "number": 2548,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2]))\n        count = 0\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if sum(a[i:j+1]) == j - i + 1:\n                    count += 1\n        print(count)"
    },
    {
        "number": 2549,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    shields = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        shields.append((a, b))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def inv(x, y):\n        return pow(y, -1, y)\n\n    def expected_damage(shield):\n        a, b = shield\n        total_damage = 0\n        for d in d:\n            if a == 0:\n                total_damage += d\n            elif a > 0 and d >= b:\n                total_damage += d\n            elif a > 0 and d < b:\n                pass\n        return total_damage\n\n    expected_damages = []\n    for shield in shields:\n        expected_damages.append(expected_damage(shield))\n\n    for i in range(m):\n        expected_damages[i] = (expected_damages[i] * inv(lcm(998244353, 998244353), 998244353) * 998244353) % 998244353\n\n    return \" \".join(map(str, expected_damages))\n"
    },
    {
        "number": 2550,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort(reverse=True)\n        max_score = 0\n        for i in range(n):\n            max_score = max(max_score, a[i])\n        print(max_score)"
    },
    {
        "number": 2551,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        s, t = stdin.split('\\n')[1].split()\n        z = ''\n        for i in range(len(t)):\n            if t[i] == z[-1]:\n                z += t[i]\n            else:\n                z += t[i]\n                break\n        if z == t:\n            print(len(s))\n        else:\n            print(-1)"
    },
    {
        "number": 2552,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(city, visited, happiness):\n        if city in visited:\n            return happiness\n        visited.add(city)\n        happiness += 1\n        for neighbor in graph[city]:\n            happiness = dfs(neighbor, visited, happiness)\n        return happiness\n\n    def bfs(city, visited, happiness):\n        queue = [city]\n        visited.add(city)\n        happiness += 1\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    happiness += 1\n                    queue.append(neighbor)\n        return happiness\n\n    def calculate_happiness(city, happiness_index):\n        if happiness_index == 0:\n            return 0\n        return happiness_index * (city - 1) + 1\n\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    h = list(map(int, stdin.split()))\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n - 1):\n        x, y = map(int, stdin.split())\n        graph[x].append(y)\n        graph[y].append(x)\n\n    visited = set()\n    happiness = 0\n    for i in range(1, n + 1):\n        if p[i - 1] == 0:\n            happiness = dfs(i, visited, happiness)\n        else:\n            happiness = bfs(i, visited, happiness)\n\n    for i in range(1, n + 1):\n        h[i - 1] = calculate_happiness(i, h[i - 1])\n\n    for i in range(1, n + 1):\n        if h[i - 1]!= h[i]:\n            return \"NO\"\n\n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 2553,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, x = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.sort()\n        if sum(a) % 2 == 0:\n            print(\"No\")\n        else:\n            if x > n:\n                print(\"No\")\n            else:\n                for i in range(n - x + 1):\n                    if sum(a[i:i + x]) % 2 == 1:\n                        print(\"Yes\")\n                        break\n                else:\n                    print(\"No\")"
    },
    {
        "number": 2554,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def reverse_subarray(a: List[int], l: int, r: int) -> int:\n        return sum(a[l:r+1][::-1])\n\n    def max_sum_even_positions(a: List[int]) -> int:\n        n = len(a)\n        max_sum = 0\n        for k in range(n // 2 + 1):\n            left = 0\n            right = k\n            while left < right:\n                left_sum = reverse_subarray(a, left, right)\n                right_sum = reverse_subarray(a, right, left)\n                max_sum = max(max_sum, left_sum + right_sum)\n                left += 1\n                right -= 1\n        return max_sum\n\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        a = list(map(int, stdin.split()[2:]))\n        print(max_sum_even_positions(a))"
    },
    {
        "number": 2555,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_strength(a: List[int], b: List[int]) -> int:\n        return sum(a[i] - a[j] for i, j in zip(b, b[1:]))\n\n    def max_strength_after_swap(a: List[int], b: List[int], l: int, r: int) -> int:\n        a[l], a[r] = a[r], a[l]\n        return max_strength(a, b)\n\n    def max_strength_after_operation(a: List[int], b: List[int], l: int, r: int) -> int:\n        a[l], a[r] = a[r], a[l]\n        return max_strength(a, b)\n\n    def max_strength_after_operations(a: List[int], b: List[int], l: List[int], r: List[int]) -> int:\n        for i in range(len(l)):\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n        return max_strength(a, b)\n\n    def max_strength_after_operations_hack(a: List[int], b: List[int], l: List[int], r: List[int]) -> int:\n        for i in range(len(l)):\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n        return max_strength(a, b)\n\n    def max_strength_after_operations_hack_2(a: List[int], b: List[int], l: List[int], r: List[int]) -> int:\n        for i in range(len(l)):\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n        return max_strength(a, b)\n\n    def max_strength_after_operations_hack_3(a: List[int], b: List[int], l: List[int], r: List[int]) -> int:\n        for i in range(len(l)):\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n        return max_strength(a, b)\n\n    def max_strength_after_operations_hack_4(a: List[int], b: List[int], l: List[int], r: List[int]) -> int:\n        for i in range(len(l)):\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n        return max_strength(a, b)\n\n    def max_strength_after_operations_hack_5(a: List[int], b: List[int], l: List[int], r: List[int]) -> int:\n        for i in range(len(l)):\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n            a[l[i]], a[r[i]] = a[r[i]], a[l[i]]\n            a[l[i]], a[r[i]] = a[l[i]], a[r[i]]\n            a[l[i]], a[r"
    },
    {
        "number": 2556,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rooms = []\n    for _ in range(n):\n        c, sum_ = map(int, stdin.split()[1:])\n        rooms.append((c, sum_))\n\n    def min_cost(c: int, sum_: int) -> int:\n        if sum_ == 0:\n            return 0\n        if sum_ < c:\n            return float('inf')\n        return min(min_cost(c, sum_ - 1), min_cost(c - 1, sum_))\n\n    result = []\n    for c, sum_ in rooms:\n        result.append(min_cost(c, sum_))\n\n    return''.join(map(str, result))"
    },
    {
        "number": 2557,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    pairs.sort(key=lambda x: (x[0], x[1]))\n\n    pipes = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            if pairs[i][0]!= pairs[j][1] and pairs[i][1]!= pairs[j][0]:\n                pipes += 1\n                break\n\n    return str(pipes)"
    },
    {
        "number": 2558,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        a, b, c, d = map(int, stdin.split('\\n')[1].split())\n        if a > 1:\n            print(-1)\n        else:\n            max_health = 0\n            for i in range(1, c + 1):\n                max_health += a * i + b * i * i\n            print(max_health)"
    },
    {
        "number": 2559,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(house: int, visited: set) -> int:\n        if house in visited:\n            return 0\n        visited.add(house)\n        return 1 + dfs(house + 1, visited)\n\n    def bellman_ford(graph: List[List[int]], start: int) -> int:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        for u in range(n):\n            for v, w in graph[u]:\n                if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                    return -1\n        return dist[n - 1]\n\n    def min_sum(graph: List[List[int]], start: int) -> int:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return sum(dist)\n\n    def max_sum(graph: List[List[int]], start: int) -> int:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return max(dist)\n\n    def assign_people(graph: List[List[int]], start: int) -> int:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return min(dist)\n\n    def min_max_sum(graph: List[List[int]], start: int) -> Tuple[int, int]:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return min(dist), max(dist)\n\n    def min_max_assign(graph: List[List[int]], start: int) -> Tuple[int, int]:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return min(dist), assign_people(graph, start)\n\n    def min_max_bellman_ford(graph: List[List[int]], start: int) -> Tuple[int, int]:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return min(dist), bellman_ford(graph, start)\n\n    def min_max_min_sum(graph: List[List[int]], start: int) -> Tuple[int, int]:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        for _ in range(n - 1):\n            for u in range(n):"
    },
    {
        "number": 2560,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    universities = []\n    for _ in range(t):\n        n, l, r = map(int, stdin.split()[1:])\n        universities.append((n, l, r))\n\n    def is_possible(coins: List[int], target: int) -> bool:\n        coins.sort()\n        for coin in coins:\n            if coin > target:\n                return True\n            target -= coin\n        return False\n\n    for i, (n, l, r) in enumerate(universities):\n        if is_possible([2, 3], n):\n            return \"Yes\"\n        if is_possible([2, 3], n + 1):\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 2561,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a = int(stdin.split()[1])\n        count = 0\n        for x in range(2**30):\n            if a ^ x == 0:\n                count += 1\n        print(count)"
    },
    {
        "number": 2562,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    a.sort()\n    mod = 1000000007\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def clan_strength(a, k):\n        return sum(gcd(a[i], a[j]) > 1 for i in range(k) for j in range(i + 1, k))\n\n    def army_strength(a):\n        k = 1\n        while k * gcd(a[0], a[1]) > 1:\n            k += 1\n        return k * clan_strength(a, k)\n\n    return str((army_strength(a) % mod) % mod)"
    },
    {
        "number": 2563,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        a = int(stdin.split('\\n')[1])\n        n = len(str(a))\n        if n == 1:\n            print(a)\n            continue\n        min_num = a\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if (a // 10 ** i) % 2!= (a // 10 ** j) % 2:\n                    min_num = min(min_num, a // 10 ** i * 10 ** j)\n        print(min_num)"
    },
    {
        "number": 2564,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        a, b, n = map(int, stdin.split()[1:])\n        if a > n:\n            a += b\n        if b > n:\n            b += a\n        print(min(a, b))"
    },
    {
        "number": 2565,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        x1, y1, z1 = map(int, stdin.split('\\n')[1].split())\n        x2, y2, z2 = map(int, stdin.split('\\n')[2].split())\n        a = [0] * x1 + [1] * y1 + [2] * z1\n        b = [0] * x2 + [1] * y2 + [2] * z2\n        c = [0] * len(a)\n        for i in range(len(a)):\n            if a[i] > b[i]:\n                c[i] = a[i] * b[i]\n            elif a[i] < b[i]:\n                c[i] = -a[i] * b[i]\n            else:\n                c[i] = 0\n        print(sum(c))"
    },
    {
        "number": 2566,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        k = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        days = [0] * 7\n        for i in range(7):\n            days[i] = a[i]\n        days.reverse()\n        count = 0\n        for i in range(7):\n            if days[i] == 1:\n                count += 1\n            else:\n                break\n        if count >= k:\n            print(count)\n        else:\n            print(k)"
    },
    {
        "number": 2567,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        s = stdin.split('\\n')[2]\n        s = ''.join(map(str, list(map(int, list(s)))))\n        w = ''\n        for i in range(1, n + 1):\n            for j in range(i, 2 * n - 1):\n                if s[j] == s[i - 1]:\n                    w += '1'\n                else:\n                    w += '0'\n        print(w)"
    },
    {
        "number": 2568,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        s = stdin.split()[1]\n        res = 0\n        cur = 0\n        ok = True\n        for i in range(1, len(s) + 1):\n            res += 1\n            if s[i - 1] == '+':\n                cur += 1\n            else:\n                cur -= 1\n            if cur < 0:\n                ok = False\n                break\n        if ok:\n            print(res)\n        else:\n            print(0)"
    },
    {
        "number": 2569,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        if n == 1:\n            print(0)\n        elif n == 2:\n            print(4)\n        else:\n            def dfs(u, color):\n                nonlocal max_yellow\n                if color == 2:\n                    max_yellow = max(max_yellow, yellow_count)\n                for v in range(1, n + 1):\n                    if u!= v:\n                        if color == 1:\n                            dfs(v, 2)\n                        elif color == 2:\n                            dfs(v, 1)\n\n            max_yellow = 0\n            dfs(1, 1)\n            print(max_yellow % MOD)"
    },
    {
        "number": 2570,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, x = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = list(map(int, stdin.split('\\n')[3].split()))\n\n        def can_rearrange(arr):\n            for i in range(len(arr) - 1):\n                if arr[i] + arr[i + 1] > x:\n                    return False\n            return True\n\n        if can_rearrange(a) and can_rearrange(b):\n            print('Yes')\n        else:\n            print('No')"
    },
    {
        "number": 2571,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    doors = []\n    for _ in range(T):\n        n = int(stdin.split()[1])\n        energies = list(map(int, stdin.split()[2:2+n]))\n        doors.append((n, energies))\n    doors.sort(key=lambda x: (-x[0], x[1]))\n    for door in doors:\n        energies = door[1]\n        for i in range(len(energies)):\n            if energies[i] > 0:\n                energies[i] = -energies[i]\n        if sum(energies) == 0:\n            print(*door[1])\n            break"
    },
    {
        "number": 2572,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        a = [[int(x) for x in stdin.split('\\n')[i+2].split()] for i in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if a[i][j]!= a[i][j][::-1]:\n                    count += 1\n                    for k in range(n):\n                        for l in range(m):\n                            if a[k][l]!= a[k][l][::-1]:\n                                count += 1\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[i][j] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[i][j] = a[j][l]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a[j][l] = a[k][l]\n                                a[k][l] = a[i][j]\n                                a["
    },
    {
        "number": 2573,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    changes = []\n\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        changes.append((x, y))\n\n    for x, y in changes:\n        if board[y - 1][x - 1] == 0:\n            board[y - 1][x - 1] = 1\n        else:\n            board[y - 1][x - 1] = 0\n\n    min_rows = 0\n    for i in range(n):\n        if board[i][k - 1] == 0:\n            min_rows += 1\n        else:\n            break\n\n    return str(min_rows)\n"
    },
    {
        "number": 2574,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1])\n        arr = list(map(int, stdin.split('\\n')[2].split()))\n        max_value = float('-inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        for t in range(l+1, n):\n                            value = arr[i] * arr[j] * arr[k] * arr[l] * arr[t]\n                            if value > max_value:\n                                max_value = value\n        print(max_value)"
    },
    {
        "number": 2575,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tests = int(stdin.split()[0])\n    for _ in range(tests):\n        angle = int(stdin.split()[1])\n        if angle == 0 or angle == 180:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2576,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.split()[1:])\n        if a <= b <= c <= d:\n            return \"1\"\n        elif a <= b <= c:\n            return \"2\"\n        elif a <= b <= d:\n            return \"3\"\n        elif a <= c <= b:\n            return \"4\"\n        elif a <= c <= d:\n            return \"5\"\n        elif a <= d <= b:\n            return \"6\"\n        elif b <= a <= c:\n            return \"7\"\n        elif b <= a <= d:\n            return \"8\"\n        elif b <= c <= a:\n            return \"9\"\n        elif b <= c <= d:\n            return \"10\"\n        elif b <= d <= a:\n            return \"11\"\n        elif c <= a <= b:\n            return \"12\"\n        elif c <= a <= d:\n            return \"13\"\n        elif c <= b <= a:\n            return \"14\"\n        elif c <= b <= d:\n            return \"15\"\n        elif c <= d <= a:\n            return \"16\"\n        elif d <= a <= b:\n            return \"17\"\n        elif d <= a <= c:\n            return \"18\"\n        elif d <= b <= a:\n            return \"19\"\n        elif d <= b <= c:\n            return \"20\"\n    return \"21\""
    },
    {
        "number": 2577,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        a = [[int(x) for x in stdin.split('\\n')[i+2].split()] for i in range(n)]\n        b = [[0]*m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                if a[i][j] == a[i][j+1] or a[i][j] == a[i+1][j]:\n                    b[i][j] = a[i][j]\n                else:\n                    b[i][j] = a[i][j]+1\n        for i in range(n):\n            print(' '.join(map(str, b[i])))"
    },
    {
        "number": 2578,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    groups = []\n    for _ in range(m):\n        k = int(stdin.readline().strip())\n        users = list(map(int, stdin.readline().strip().split()))\n        groups.append(users)\n\n    def dfs(users, visited, result):\n        if not users:\n            return result\n\n        for user in users:\n            if user not in visited:\n                visited.add(user)\n                result[user] = dfs(groups[user], visited, result)\n                visited.remove(user)\n\n        return max(result.values())\n\n    result = {}\n    dfs(list(range(n)), set(), result)\n    return''.join(map(str, result.values()))"
    },
    {
        "number": 2579,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y, k = map(int, stdin.split())\n    if k == 0:\n        return \"YES\"\n    if k == 1:\n        return \"NO\"\n    if k == 2:\n        return \"YES\"\n    if k == 3:\n        return \"NO\"\n    if k == 4:\n        return \"YES\"\n    if k == 5:\n        return \"NO\"\n    if k == 6:\n        return \"YES\"\n    if k == 7:\n        return \"NO\"\n    if k == 8:\n        return \"YES\"\n    if k == 9:\n        return \"NO\"\n    if k == 10:\n        return \"YES\"\n    if k == 11:\n        return \"NO\"\n    if k == 12:\n        return \"YES\"\n    if k == 13:\n        return \"NO\"\n    if k == 14:\n        return \"YES\"\n    if k == 15:\n        return \"NO\"\n    if k == 16:\n        return \"YES\"\n    if k == 17:\n        return \"NO\"\n    if k == 18:\n        return \"YES\"\n    if k == 19:\n        return \"NO\"\n    if k == 20:\n        return \"YES\"\n    if k == 21:\n        return \"NO\"\n    if k == 22:\n        return \"YES\"\n    if k == 23:\n        return \"NO\"\n    if k == 24:\n        return \"YES\"\n    if k == 25:\n        return \"NO\"\n    if k == 26:\n        return \"YES\"\n    if k == 27:\n        return \"NO\"\n    if k == 28:\n        return \"YES\"\n    if k == 29:\n        return \"NO\"\n    if k == 30:\n        return \"YES\"\n    if k == 31:\n        return \"NO\"\n    if k == 32:\n        return \"YES\"\n    if k == 33:\n        return \"NO\"\n    if k == 34:\n        return \"YES\"\n    if k == 35:\n        return \"NO\"\n    if k == 36:\n        return \"YES\"\n    if k == 37:\n        return \"NO\"\n    if k == 38:\n        return \"YES\"\n    if k == 39:\n        return \"NO\"\n    if k == 40:\n        return \"YES\"\n    if k == 41:\n        return \"NO\"\n    if k == 42:\n        return \"YES\"\n    if k == 43:\n        return \"NO\"\n    if k == 44:\n        return \"YES\"\n    if k == 45:\n        return \"NO\"\n    if k == 46:\n        return \"YES\"\n    if k == 47:\n        return \"NO\"\n    if k == 48:\n        return \"YES\"\n    if k == 49:\n        return \"NO\"\n    if k == 50:\n        return \"YES\"\n    if k == 51:\n        return \"NO\"\n    if k == 52:\n        return \"YES\"\n    if k == 53:\n        return \"NO\"\n    if k == 54:\n        return \"YES\"\n    if k == 55:\n        return \"NO\"\n    if k == 56:\n        return \"YES\"\n    if k == 57:\n        return \"NO\"\n    if k == 58:\n        return \"YES\"\n    if k == 59:\n        return \"NO\"\n    if k == 60:\n        return \"YES\"\n    if k == 61:\n        return \"NO\"\n    if k == 62:\n        return \"YES\"\n    if k == 63:\n        return \"NO\"\n    if k == 64:\n        return \"YES\"\n    if k == 65:\n        return \"NO\"\n    if k == 66:\n        return \"YES\"\n    if k == 67:\n        return \"NO\"\n    if k == 68:\n        return \"YES\"\n    if k == 69:\n        return \"NO\"\n    if k == 70:\n        return \"YES\"\n    if k == 71:\n        return \"NO\"\n    if k == 72:\n        return \"YES\"\n    if k == 73:\n        return \"NO\"\n    if k == 74:\n        return \"YES\"\n    if k == 75:\n        return \"NO\"\n    if k == 76:\n        return \"YES\"\n    if k == 77:\n        return \"NO\"\n   "
    },
    {
        "number": 2580,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    MOD = 10**9 + 7\n    n, m = map(int, stdin.split())\n    k = int(stdin.split()[m + 1])\n    factors = [int(x) for x in stdin.split()[m + 2:]]\n\n    def prime_factors(n: int) -> list[int]:\n        factors = []\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        if n > 2:\n            factors.append(n)\n        return factors\n\n    def f(u: int, v: int) -> int:\n        return sum(factors[u - 1] * factors[v - 1 + i] for i in range(n - 1))\n\n    def sum_of_f(u: int) -> int:\n        return sum(f(u, v) for v in range(1, n))\n\n    def count_ones(n: int) -> int:\n        count = 0\n        while n > 0:\n            count += n & 1\n            n >>= 1\n        return count\n\n    def max_distribution_index() -> int:\n        max_sum = 0\n        for u in range(1, n):\n            for v in range(u + 1, n):\n                max_sum = max(max_sum, f(u, v))\n        return max_sum\n\n    def max_prime_factorization() -> int:\n        max_sum = 0\n        for u in range(1, n):\n            for v in range(u + 1, n):\n                max_sum = max(max_sum, sum_of_f(u) + sum_of_f(v))\n        return max_sum\n\n    def max_count_ones() -> int:\n        max_count = 0\n        for u in range(1, n):\n            for v in range(u + 1, n):\n                max_count = max(max_count, count_ones(f(u, v)))\n        return max_count\n\n    def max_sum_of_prime_factors() -> int:\n        max_sum = 0\n        for u in range(1, n):\n            for v in range(u + 1, n):\n                max_sum = max(max_sum, sum(factors[u - 1] * factors[v - 1 + i] for i in range(n - 1)))\n        return max_sum\n\n    max_index = max(\n        max_distribution_index(),\n        max_prime_factorization(),\n        max_count_ones(),\n        max_sum_of_prime_factors(),\n    )\n\n    return str(max_index % MOD)\n\n\ndef"
    },
    {
        "number": 2581,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    chessboard = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def bishop_attacks(x, y, dx, dy):\n        for i in range(x, x + dy, dy):\n            for j in range(y, y + dx, dx):\n                if i == x or j == y or i == x + dy - 1 or j == y + dx - 1:\n                    return True\n        return False\n\n    def bishop_positions(x, y, dx, dy):\n        positions = []\n        for i in range(x, x + dy, dy):\n            for j in range(y, y + dx, dx):\n                positions.append((i, j))\n        return positions\n\n    def max_money(x, y, dx, dy):\n        max_value = 0\n        for i in range(x, x + dy, dy):\n            for j in range(y, y + dx, dx):\n                if chessboard[i][j] == 0:\n                    continue\n                if bishop_attacks(i, j, dx, dy):\n                    continue\n                max_value = max(max_value, chessboard[i][j])\n        return max_value\n\n    def bishop_positions_with_max_money(x, y, dx, dy):\n        max_value = max_money(x, y, dx, dy)\n        positions = bishop_positions(x, y, dx, dy)\n        for i in range(len(positions)):\n            if chessboard[positions[i][0]][positions[i][1]] == 0:\n                continue\n            if chessboard[positions[i][0]][positions[i][1]] == max_value:\n                positions[i] = (positions[i][0], positions[i][1] + dx)\n        return positions\n\n    def bishop_positions_with_max_money_and_min_attack(x, y, dx, dy):\n        max_value = max_money(x, y, dx, dy)\n        positions = bishop_positions(x, y, dx, dy)\n        min_attack = float('inf')\n        for i in range(len(positions)):\n            if chessboard[positions[i][0]][positions[i][1]] == 0:\n                continue\n            if chessboard[positions[i][0]][positions[i][1]] == max_value:\n                positions[i] = (positions[i][0], positions[i][1] + dx)\n                attack = 0\n                for j in range(positions[i][0] - 1, positions[i][0] + 2):\n                    for k in range(positions[i][1] - 1, positions[i][1] + 2):\n                        if j == positions[i][0] and k == positions[i][1]:\n                            continue\n                        if 0 <= j < n and 0 <= k < n and chessboard[j][k] == 0:\n                            attack += 1\n                min_attack = min(min_attack, attack)\n        return positions, min_attack\n\n    def bishop_positions_with_max_money_and_min_attack_and_min_distance(x, y, dx, dy):\n        max_value = max_money(x, y, dx, dy)\n        positions = bishop_positions(x, y, dx, dy)\n        min_attack = float('inf')\n        min_distance = float('inf')\n        for i in range(len(positions)):\n            if chessboard[positions[i][0]][positions[i][1]] == 0:\n                continue\n            if chessboard[positions[i][0]][positions[i][1]] == max_value:\n                positions[i] = (positions[i][0], positions[i][1] + dx)\n                attack = 0\n                for j in range(positions[i][0] - 1, positions[i][0] + 2):\n                    for k in range(positions[i][1] - 1, positions[i][1] + 2):\n                        if j == positions[i][0] and k == positions[i][1]:\n                            continue\n                        if 0 <= j < n and 0 <= k < n and chessboard[j][k] == 0:\n                            attack += 1\n                min_attack = min(min_attack, attack)\n                distance = abs(positions[i][0] - x) + abs(positions[i][1] - y)\n                min_distance ="
    },
    {
        "number": 2582,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    p = list(map(int, stdin.split()[1:]))\n\n    special_subsegments = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] + p[j] == max(p[k] for k in range(i, j + 1)):\n                special_subsegments += 1\n\n    return str(special_subsegments)"
    },
    {
        "number": 2583,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        if n == 1:\n            print(\"Ashishgup\")\n        else:\n            if n % 2 == 0:\n                print(\"Ashishgup\")\n            else:\n                print(\"FastestFinger\")"
    },
    {
        "number": 2584,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, p, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        dp = [0] * (n + 1)\n        dp[0] = 0\n        dp[1] = 1\n        for i in range(2, n + 1):\n            dp[i] = max(dp[i - 1], dp[i - 2])\n            for j in range(k):\n                if p >= a[j]:\n                    dp[i] = max(dp[i], dp[i - 1] + 1)\n        print(dp[n])"
    },
    {
        "number": 2585,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        max_gcd = 1\n        for i in range(2, n+1):\n            for j in range(i+1, n+1):\n                gcd = max(i, j)\n                while gcd % i == 0 and gcd % j == 0:\n                    gcd //= i\n                    gcd //= j\n                if gcd > max_gcd:\n                    max_gcd = gcd\n        print(max_gcd)"
    },
    {
        "number": 2586,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        board = [list(map(str, stdin.split('\\n')[2].split())) for _ in range(n)]\n        colors = set()\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == 'B':\n                    colors.add((i, j))\n                elif board[i][j] == 'W':\n                    colors.add((i, j))\n        for color in colors:\n            i, j = color\n            if i > 0 and board[i-1][j] == 'W':\n                board[i][j] = 'B'\n            if i < n-1 and board[i+1][j] == 'W':\n                board[i][j] = 'B'\n            if j > 0 and board[i][j-1] == 'W':\n                board[i][j] = 'B'\n            if j < m-1 and board[i][j+1] == 'W':\n                board[i][j] = 'B'\n        print(''.join(board[i]) for i in range(n))"
    },
    {
        "number": 2587,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        x = int(stdin.split()[2])\n        k = bin(x)[2:]\n        r = k[-n:]\n        x = int(r, 2)\n        print(x)"
    },
    {
        "number": 2588,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split()[0])\n    for _ in range(queries):\n        n, a, b = map(int, stdin.split()[1:])\n        s = stdin.split()[2]\n        cost = 0\n        pillars = 0\n        for i in range(n):\n            if s[i] == '0':\n                cost += a\n            else:\n                cost += b\n                pillars += 1\n        if pillars == n + 1:\n            cost += a * (n + 1)\n        else:\n            cost += a * (n + 1) + b * (n + 1)\n        print(cost)"
    },
    {
        "number": 2589,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, x = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n\n        def is_valid(subarray):\n            return sum(subarray) % x == 0\n\n        longest_valid_subarray = []\n        for i in range(1, n):\n            for j in range(i, n):\n                subarray = a[i:j+1]\n                if is_valid(subarray):\n                    if len(subarray) > len(longest_valid_subarray):\n                        longest_valid_subarray = subarray\n\n        if longest_valid_subarray:\n            print(len(longest_valid_subarray))\n        else:\n            print(-1)"
    },
    {
        "number": 2590,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split('\\n')[0])\n    for _ in range(T):\n        n, x = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        savings = [a[i] - a[i-1] for i in range(1, n+1)]\n        max_wealthy = 0\n        for i in range(1, n+1):\n            if savings[i] >= x:\n                max_wealthy += 1\n        print(max_wealthy)"
    },
    {
        "number": 2591,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        a = list(map(int, stdin.split()[2:2+n]))\n        a.sort()\n        for i in range(n-1):\n            if abs(a[i] - a[i+1]) > 1:\n                a[i], a[i+1] = a[i+1], a[i]\n                break\n        print(\" \".join(map(str, a)))"
    },
    {
        "number": 2592,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        a, b, c = map(int, stdin.split('\\n')[1].split())\n        max_visitors = 0\n        for i in range(1, 10):\n            if a + b + c >= i:\n                max_visitors = max(max_visitors, i)\n        print(max_visitors)"
    },
    {
        "number": 2593,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        pairs = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if a[i] & a[j] >= a[i] ^ a[j]:\n                    pairs += 1\n        print(pairs)"
    },
    {
        "number": 2594,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        park = [[0] * m for _ in range(n)]\n        for i in range(n):\n            for j in range(m):\n                park[i][j] = 1\n        for i in range(n):\n            for j in range(m):\n                if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                    park[i][j] = 0\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if park[i][j]:\n                    count += 1\n        print(count)"
    },
    {
        "number": 2595,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b = map(int, stdin.split()[1:])\n        if a == b:\n            print(0)\n        else:\n            count = 0\n            while a!= b:\n                if a % 2 == 0:\n                    a //= 2\n                else:\n                    a *= 2\n                count += 1\n            print(count)\n    return \"\""
    },
    {
        "number": 2596,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, t = map(int, stdin.split())\n    universes = [0] * (m + 1)\n    universes[k] = 1\n    for _ in range(t):\n        action, i = map(int, stdin.split())\n        if action == 1:\n            universes[i] = 1\n        else:\n            universes[i] = 0\n    return \" \".join(map(str, universes))"
    },
    {
        "number": 2597,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        max_side = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                max_side = max(max_side, a[i] + a[j])\n        print(max_side)"
    },
    {
        "number": 2598,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, c = map(int, stdin.split())\n        edges.append((u - 1, v - 1, c))\n\n    def bfs(start: int, visited: set) -> list:\n        queue = [(start, 0)]\n        visited.add(start)\n        color = [0] * n\n        color[start] = 1\n        while queue:\n            vertex, distance = queue.pop(0)\n            for neighbor, weight in edges[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append((neighbor, distance + 1))\n                    color[neighbor] = 1 - color[vertex]\n        return color\n\n    def dfs(start: int, visited: set) -> int:\n        visited.add(start)\n        color = [0] * n\n        color[start] = 1\n        for neighbor, weight in edges[start]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                color[neighbor] = 1 - color[start]\n                if dfs(neighbor, visited) == 1:\n                    return 1\n        return 0\n\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            color = bfs(i, visited)\n            if dfs(i, visited) == 1:\n                return 1\n\n    return -1"
    },
    {
        "number": 2599,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        if k == 0:\n            print(n)\n        else:\n            x = 1\n            while True:\n                f_x = sum(int(digit) for digit in str(x))\n                if f_x + f_x + f_x + f_x + f_x + f_x + f_x + f_x + f_x == n:\n                    print(x)\n                    break\n                x += 1\n    return ''"
    },
    {
        "number": 2600,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split('\\n')[1].split())\n        matrix = [list(map(int, stdin.split('\\n')[i+2].split())) for i in range(n)]\n        min_cells = 0\n        for i in range(n):\n            for j in range(m):\n                if i == n-1 and j == m-1:\n                    continue\n                if i == n-1:\n                    matrix[i][j] = (matrix[i][j] + matrix[i][j+1]) % 2\n                elif j == m-1:\n                    matrix[i][j] = (matrix[i][j] + matrix[i+1][j]) % 2\n                else:\n                    matrix[i][j] = (matrix[i][j] + matrix[i+1][j] + matrix[i][j+1] + matrix[i+1][j+1]) % 2\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 0:\n                    min_cells += 1\n        print(min_cells)"
    },
    {
        "number": 2601,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    if a == a[::-1]:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 2602,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        a, b, n, m = map(int, stdin.split()[1:])\n        if a + b == 0 and n + m!= 0:\n            print(\"Yes\")\n        else:\n            print(\"No\")"
    },
    {
        "number": 2603,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        if is_non_decreasing(a):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\ndef"
    },
    {
        "number": 2604,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, d = map(int, stdin.split())\n    n = int(stdin.split()[1])\n    sausage = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.split())\n        sausage.append((x, y, r))\n\n    caught = 0\n    for sausage_center, sausage_radius in sausage:\n        if sausage_radius <= r - d:\n            caught += 1\n\n    return str(caught)"
    },
    {
        "number": 2605,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    id_capital = list(map(int, stdin.split()))\n\n    def dfs(city, visited):\n        if city in visited:\n            return 0\n        visited.add(city)\n        total = 0\n        for i in range(n):\n            if i == city:\n                continue\n            if i in visited:\n                continue\n            if i in id_capital and i!= city:\n                total += c[i] * dfs(i, visited)\n            else:\n                total += dfs(i, visited)\n        return total\n\n    return str(dfs(0, set()))"
    },
    {
        "number": 2606,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n = int(stdin.split('\\n')[1])\n        t = list(map(int, stdin.split('\\n')[2].split()))\n        t.sort()\n        total_unpleasant_value = 0\n        for i in range(n):\n            total_unpleasant_value += abs(t[i] - t[i+1])\n        print(total_unpleasant_value)"
    },
    {
        "number": 2607,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        s = stdin.split('\\n')[1]\n        beautiful = True\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                beautiful = False\n                break\n        if beautiful:\n            print(s)\n        else:\n            print(\"-1\")"
    },
    {
        "number": 2608,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, m = map(int, stdin.split()[1:])\n        x1, y1, x2, y2 = map(int, stdin.split()[2:])\n        x3, y3, x4, y4 = map(int, stdin.split()[3:])\n\n        white_cells = 0\n        black_cells = 0\n\n        for i in range(y1, y2 + 1):\n            for j in range(x1, x2 + 1):\n                white_cells += 1 if (i, j) in [(y1, x1), (y1, x2), (y2, x1), (y2, x2)] else 0\n                black_cells += 1 if (i, j) in [(y3, x3), (y3, x4), (y4, x3), (y4, x4)] else 0\n\n        for i in range(y3, y4 + 1):\n            for j in range(x3, x4 + 1):\n                white_cells += 1 if (i, j) in [(y3, x3), (y3, x4), (y4, x3), (y4, x4)] else 0\n                black_cells += 1 if (i, j) in [(y1, x1), (y1, x2), (y2, x1), (y2, x2)] else 0\n\n        print(white_cells, black_cells)"
    },
    {
        "number": 2609,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def merge_segments(segments: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        segments.sort()\n        merged = []\n        for i in range(len(segments)):\n            if not merged or merged[-1][1] < segments[i][0]:\n                merged.append(segments[i])\n            else:\n                merged[-1] = (merged[-1][0], max(merged[-1][1], segments[i][1]))\n        return merged\n\n    def erase_segment(segments: List[Tuple[int, int]], index: int) -> List[Tuple[int, int]]:\n        return segments[:index] + segments[index + 1:]\n\n    def count_segments(segments: List[Tuple[int, int]]) -> int:\n        return len(segments)\n\n    def find_max_segments(segments: List[Tuple[int, int]]) -> int:\n        max_segments = 0\n        for i in range(1, len(segments)):\n            max_segments = max(max_segments, count_segments(erase_segment(segments, i)))\n        return max_segments\n\n    def read_input() -> List[Tuple[int, int]]:\n        n = int(stdin.readline().strip())\n        segments = []\n        for _ in range(n):\n            l, r = map(int, stdin.readline().strip().split())\n            segments.append((l, r))\n        return segments\n\n    def main() -> None:\n        t = int(stdin.readline().strip())\n        for _ in range(t):\n            segments = read_input()\n            max_segments = find_max_segments(segments)\n            print(max_segments)\n\n    main()\n    return \"\"\n"
    },
    {
        "number": 2610,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, p, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        dp = [0] * (k + 1)\n        dp[0] = 0\n        for i in range(1, k + 1):\n            dp[i] = max(dp[i - 1], dp[i - a[i - 1]] + 1)\n        print(dp[k])"
    },
    {
        "number": 2611,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    piles = list(map(int, stdin.split()))\n\n    def broom(x: int) -> int:\n        if x == 1:\n            return 1\n        elif x == n:\n            return -1\n        else:\n            return 0\n\n    def move_piles(x: int, direction: int) -> int:\n        if direction == 1:\n            return x + 1\n        elif direction == -1:\n            return x - 1\n        else:\n            return x\n\n    def total_moves(x: int) -> int:\n        moves = 0\n        while x!= 1:\n            moves += broom(x)\n            x = move_piles(x, broom(x))\n        return moves\n\n    def query(t: int, x: int) -> int:\n        if t == 0:\n            return total_moves(x)\n        else:\n            return 0\n\n    return \" \".join(map(str, [query(t, x) for t, x in enumerate(piles)]))\n"
    },
    {
        "number": 2612,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split('\\n')[0])\n    for _ in range(queries):\n        n = int(stdin.split('\\n')[1])\n        s = list(map(int, stdin.split('\\n')[2].split()))\n        beautiful_arrangements = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if s[i] < s[j] and s[i] % s[j] == 0 and s[j] % s[i] == 0:\n                    beautiful_arrangements += 1\n        print(beautiful_arrangements)"
    },
    {
        "number": 2613,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n, k, z = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        a.append(0)\n        max_score = 0\n        for i in range(1, n):\n            if i - 1 >= z:\n                break\n            if i - 1 >= 0:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n                max_score += a[i + 1]\n            if i - 1 >= 0 and i + 1 <= n - 1 - z:\n                max_score += a[i - 1]\n            if i - 1 >= z:\n                max_score += a[i - 1]\n            if i + 1 <= n - 1 - z:\n               "
    },
    {
        "number": 2614,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    bags = []\n    for _ in range(int(stdin.split()[0])):\n        n = int(stdin.split()[1])\n        bag = []\n        for _ in range(n):\n            bag.append(int(stdin.split()[2]))\n        bags.append(bag)\n    bags.sort(key=lambda x: x[0])\n    max_distance = 0\n    for bag in bags:\n        distance = 0\n        for i in range(len(bag) - 1):\n            if bag[i] == bag[i + 1]:\n                distance += 1\n        max_distance = max(max_distance, distance)\n    return str(max_distance)"
    },
    {
        "number": 2615,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for i in range(T):\n        n = int(stdin.split()[1])\n        count = 0\n        for j in range(2, n+1):\n            if n % j == 0:\n                count += 1\n                while n % j == 0:\n                    n //= j\n        print(count)"
    },
    {
        "number": 2616,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        n = int(stdin.split('\\n')[1])\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        b = list(map(int, stdin.split('\\n')[3].split()))\n        if sum(a) > sum(b):\n            return \"First\"\n        elif sum(a) < sum(b):\n            return \"Second\"\n        else:\n            return \"Tie\""
    },
    {
        "number": 2617,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        if n % 2 == 0:\n            print(-1)\n        else:\n            masses = [1]\n            for i in range(2, n+1, 2):\n                masses.append(masses[-1] + masses[-2])\n            print(len(masses))\n            for i in range(len(masses)):\n                print(masses[i])"
    },
    {
        "number": 2618,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = int(stdin.split('\\n')[0])\n    for _ in range(queries):\n        n, p = map(int, stdin.split('\\n')[1].split())\n        p = [int(x) for x in p.split()]\n        x, a, y, b = map(int, stdin.split('\\n')[2].split())\n        k = int(stdin.split('\\n')[3])\n\n        def get_total_contribution(tickets):\n            total_contribution = 0\n            for i in range(len(tickets)):\n                total_contribution += p[tickets[i] - 1] * (x + y) * (i + 1)\n            return total_contribution\n\n        def get_min_tickets(tickets):\n            min_tickets = len(tickets)\n            for i in range(len(tickets)):\n                for j in range(i + 1, len(tickets)):\n                    if tickets[i] > tickets[j]:\n                        min_tickets = min(min_tickets, tickets[i] + tickets[j])\n            return min_tickets\n\n        if get_total_contribution(p) >= k:\n            print(get_min_tickets(p))\n        else:\n            print(-1)"
    },
    {
        "number": 2619,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, c = map(int, stdin.split())\n    stars = [list(map(int, stdin.split())) for _ in range(n)]\n    views = [list(map(int, stdin.split())) for _ in range(q)]\n\n    def get_brightness(x, y):\n        return max(0, min(c, stars[i][2] + 1))\n\n    def get_total_brightness(x1, y1, x2, y2):\n        total = 0\n        for i in range(n):\n            if x1 <= stars[i][0] <= x2 and y1 <= stars[i][1] <= y2:\n                total += stars[i][2]\n        return total\n\n    result = []\n    for view in views:\n        x1, y1, x2, y2 = view[2], view[3], view[4], view[5]\n        total = get_total_brightness(x1, y1, x2, y2)\n        result.append(total)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2620,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = [i for i in range(1, n + 1)]\n    for _ in range(q):\n        query = list(map(int, stdin.split()))\n        if query[0] == 1:\n            print(sum(a[query[1] - 1:query[2]]))\n        elif query[0] == 2:\n            a = next_permutation(a)\n            print(sum(a))\n    return \"\"\n\n\ndef"
    },
    {
        "number": 2621,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n, m, k = map(int, stdin.split()[1:])\n        h = list(map(int, stdin.split()[2:]))\n        h.append(0)\n        h.sort(reverse=True)\n        for i in range(1, n):\n            if h[i] - h[i - 1] > k:\n                return \"NO\"\n        return \"YES\""
    },
    {
        "number": 2622,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid1 = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n    grid2 = [list(line.strip()) for line in stdin.split('\\n')[n+1:2*n+1]]\n\n    for i in range(n):\n        for j in range(m):\n            if grid1[i][j]!= grid2[j][i]:\n                return f\"{i+1} {j+1}\"\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 2623,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for i in range(t):\n        n, k = map(int, stdin.split('\\n')[i+1].split())\n        s = stdin.split('\\n')[i+2]\n        s = ''.join(sorted(set(s)))\n        max_len = 0\n        for i in range(1, n+1):\n            for j in range(i, n+1):\n                if j - i + 1 > max_len:\n                    max_len = j - i + 1\n        result = []\n        for i in range(k):\n            result.append('')\n        for i in range(n):\n            if s[i] in result:\n                result.remove(s[i])\n            else:\n                result.append(s[i])\n        result = ''.join(result)\n        print(result)"
    },
    {
        "number": 2624,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = a.copy()\n\n    for i in range(q):\n        s, x = stdin.split()\n        x = int(x)\n        if s == \"<\":\n            b = [a[j] if a[j] > x else -a[j] for j in range(n)]\n        else:\n            b = [a[j] if a[j] < x else -a[j] for j in range(n)]\n\n    c = b.copy()\n    print(\" \".join(map(str, c)))\n    return \"\""
    },
    {
        "number": 2625,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *tasks = map(int, stdin.split())\n    results = []\n\n    for k, x in tasks:\n        count = 0\n        num = k\n        while num > 0:\n            count += num % 10\n            num //= 10\n\n        results.append(count if count == x else -1)\n\n    return \"\\n\".join(map(str, results))"
    },
    {
        "number": 2626,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split()[0])\n    for _ in range(t):\n        n = int(stdin.split()[1])\n        if n == 1:\n            print(2)\n        elif n == 2:\n            print(1)\n        else:\n            print(4 * n * (n - 1) // 2)"
    },
    {
        "number": 2627,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = []\n    for line in stdin.split('\\n'):\n        matrix.append([int(x) for x in line.split()])\n\n    def max_rectangle_area(matrix, i, j, heights):\n        if i == len(matrix) - 1:\n            return 0\n\n        if heights[i] == 0:\n            return max_rectangle_area(matrix, i + 1, j, heights)\n\n        if j == len(matrix[i]) - 1:\n            return max(max_rectangle_area(matrix, i, j + 1, heights),\n                       max_rectangle_area(matrix, i + 1, j, heights))\n\n        if heights[i] == heights[j]:\n            return max(max_rectangle_area(matrix, i, j + 1, heights),\n                       max_rectangle_area(matrix, i + 1, j, heights))\n\n        return max(max_rectangle_area(matrix, i, j + 1, heights),\n                   max_rectangle_area(matrix, i + 1, j, heights),\n                   max_rectangle_area(matrix, i, j, heights) + 1)\n\n    heights = [0] * len(matrix[0])\n    max_area = 0\n\n    for i in range(len(matrix)):\n        for j in range(len(matrix[i])):\n            if matrix[i][j] == 1:\n                heights[j] += 1\n                max_area = max(max_area, max_rectangle_area(matrix, i, j, heights))\n\n    return str(max_area)"
    },
    {
        "number": 2628,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    gray_code = [0]\n    for i in range(1, 1 << n):\n        gray_code.append(i ^ (i >> 1))\n    return str(gray_code)"
    },
    {
        "number": 2629,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    matrix = [[0] * n for _ in range(n)]\n    top = 0\n    bottom = n - 1\n    left = 0\n    right = n - 1\n\n    for i in range(n * n):\n        if top > bottom or left > right:\n            break\n\n        if i < n:\n            matrix[top][left] = i + 1\n            top += 1\n\n        if i >= n:\n            matrix[bottom][right] = i + 1\n            bottom -= 1\n\n        if i % n == 0:\n            matrix[top][right] = i + 1\n            top += 1\n\n        if i % n == n - 1:\n            matrix[bottom][left] = i + 1\n            bottom -= 1\n\n        if i >= n * n - n:\n            matrix[right][bottom] = i + 1\n            right -= 1\n\n        if i < n * n - n:\n            matrix[left][top] = i + 1\n            left += 1\n\n    return str(matrix)"
    },
    {
        "number": 2630,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = [list(map(int, row.split())) for row in stdin.split('\\n')]\n\n    def dfs(i, j, memo):\n        if i == m - 1 and j == n - 1:\n            memo[i][j] = 1\n            return 1\n\n        if i < 0 or j < 0 or i >= m or j >= n or grid[i][j] == 1:\n            memo[i][j] = 0\n            return 0\n\n        memo[i][j] = dfs(i + 1, j, memo) + dfs(i, j + 1, memo)\n        return memo[i][j]\n\n    memo = [[0] * n for _ in range(m)]\n    return str(dfs(0, 0, memo))"
    },
    {
        "number": 2631,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, prerequisites = map(int, stdin.split())\n    prerequisites = [list(map(int, x.split())) for x in stdin.split()[1:]]\n    in_degree = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in prerequisites:\n        graph[u].append(v)\n        in_degree[v] += 1\n\n    queue = []\n    for i in range(n):\n        if in_degree[i] == 0:\n            queue.append(i)\n\n    while queue:\n        u = queue.pop(0)\n        for v in graph[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n\n    return \"true\" if all(in_degree[i] == 0 for i in range(n)) else \"false\""
    },
    {
        "number": 2632,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = []\n    for _ in range(m):\n        row = list(map(int, stdin.split()))\n        grid.append(row)\n\n    def dfs(i, j, path, memo):\n        if i == m - 1 and j == n - 1:\n            return 0\n\n        if (i, j) in memo:\n            return memo[(i, j)]\n\n        memo[(i, j)] = float('inf')\n\n        if i < m - 1:\n            memo[(i, j)] = min(memo[(i, j)], dfs(i + 1, j, path + [grid[i][j]], memo))\n\n        if j < n - 1:\n            memo[(i, j)] = min(memo[(i, j)], dfs(i, j + 1, path + [grid[i][j]], memo))\n\n        return memo[(i, j)]\n\n    return str(dfs(0, 0, [], {}))"
    },
    {
        "number": 2633,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    dungeon = [list(map(int, row.split())) for row in stdin.split('\\n')]\n    rows, cols = len(dungeon), len(dungeon[0])\n    dp = [[0] * (cols + 1) for _ in range(rows + 1)]\n\n    for i in range(rows, 0, -1):\n        for j in range(cols, 0, -1):\n            if i == rows and j == cols:\n                dp[i][j] = max(dungeon[i - 1][j], dungeon[i][j - 1])\n            elif i == rows:\n                dp[i][j] = max(dp[i][j], dp[i][j - 1] - dungeon[i - 1][j])\n            elif j == cols:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] - dungeon[i][j - 1])\n            else:\n                dp[i][j] = max(dp[i][j], dp[i - 1][j] - dungeon[i][j - 1], dp[i][j - 1] - dungeon[i - 1][j])\n\n    return str(dp[1][1])"
    },
    {
        "number": 2634,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    result = []\n\n    def backtrack(path: list, start: int):\n        if start == len(nums):\n            result.append(path[:])\n            return\n\n        for i in range(start, len(nums)):\n            backtrack(path + [nums[i]], i + 1)\n\n    backtrack([], 0)\n    return result\n"
    },
    {
        "number": 2635,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = [list(map(int, row.split())) for row in stdin.split('\\n')]\n    m, n = len(matrix), len(matrix[0])\n    result = []\n\n    def spiral_order(matrix, row_start, col_start, row_end, col_end):\n        nonlocal result\n        if row_start > row_end or col_start > col_end:\n            return\n        for i in range(col_start, col_end + 1):\n            result.append(matrix[row_start][i])\n        for i in range(row_start + 1, row_end + 1):\n            result.append(matrix[i][col_end])\n        if row_start < row_end:\n            for i in range(col_end - 1, col_start - 1, -1):\n                result.append(matrix[row_end][i])\n        if col_start < col_end:\n            for i in range(row_end - 1, row_start - 1, -1):\n                result.append(matrix[i][col_start])\n        spiral_order(matrix, row_start + 1, col_start + 1, row_end - 1, col_end - 1)\n\n    spiral_order(matrix, 0, 0, m - 1, n - 1)\n    return''.join(map(str, result))"
    },
    {
        "number": 2636,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    buildings = []\n    for line in stdin.split('\\n'):\n        if line:\n            building = [int(x) for x in line.split()]\n            buildings.append(building)\n\n    buildings.sort(key=lambda x: x[0])\n\n    skyline = []\n    current_height = 0\n    for building in buildings:\n        if building[2] > current_height:\n            skyline.append([building[0], building[2]])\n        current_height = max(building[2], current_height)\n\n    return str(skyline)"
    },
    {
        "number": 2637,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    nums.sort()\n    result = []\n    backtrack(nums, [], result)\n    return str(result)\n\ndef"
    },
    {
        "number": 2638,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    triangle = [list(map(int, row.split())) for row in stdin.split('\\n')]\n    n = len(triangle)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1]) + triangle[i - 1][j - 1]\n\n    return str(dp[n][n])"
    },
    {
        "number": 2639,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    nums.sort()\n    result = []\n\n    def backtrack(start: int, path: list):\n        if start == len(nums):\n            result.append(path[:])\n            return\n\n        for i in range(start, len(nums)):\n            if i > start and nums[i] == nums[i - 1]:\n                continue\n            backtrack(i + 1, path + [nums[i]])\n\n    backtrack(0, [])\n    return str(result)"
    },
    {
        "number": 2640,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    obstacles = []\n    for i in range(H):\n        row = list(stdin.split()[i + 1])\n        obstacles.append(row)\n\n    def is_valid(row: int, col: int) -> bool:\n        return 0 <= row < H and 0 <= col < W\n\n    def dfs(row: int, col: int, visited: set) -> int:\n        if not is_valid(row, col):\n            return 0\n\n        if (row, col) in visited:\n            return 0\n\n        visited.add((row, col))\n\n        if obstacles[row][col] == '#':\n            return 0\n\n        if obstacles[row][col] == '.':\n            return 1\n\n        return dfs(row + 1, col, visited) + dfs(row - 1, col, visited) + dfs(row, col + 1, visited) + dfs(row, col - 1, visited)\n\n    max_squares = 0\n    for i in range(H):\n        for j in range(W):\n            if obstacles[i][j] == '#':\n                continue\n\n            visited = set()\n            max_squares = max(max_squares, dfs(i, j, visited))\n\n    return str(max_squares)"
    },
    {
        "number": 2641,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        queries.append((l, r))\n\n    def count_colors(l, r):\n        colors_count = [0] * n\n        for i in range(l, r + 1):\n            colors_count[colors[i] - 1] += 1\n        return colors_count\n\n    result = []\n    for l, r in queries:\n        colors_count = count_colors(l, r)\n        result.append(len(set(colors_count)))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2642,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sardines = []\n    for i in range(n):\n        sardines.append(list(map(int, stdin.split()[i+1].split())))\n    sardines.sort(key=lambda x: (-x[0], -x[1]))\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if sardines[i][0] * sardines[j][0] + sardines[i][1] * sardines[j][1] == 0:\n                count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 2643,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(q):\n        n, x, m = map(int, stdin.split())\n        queries.append((n, x, m))\n\n    def process_query(query: tuple) -> int:\n        n, x, m = query\n        a = [x]\n        for _ in range(n - 1):\n            a.append((a[-1] + d[a[-1] % k]) % k)\n        count = 0\n        for j in range(1, n):\n            if (a[j] % m) < (a[j + 1] % m):\n                count += 1\n        return count\n\n    result = \"\\n\".join(map(str, map(process_query, queries)))\n    return result\n"
    },
    {
        "number": 2644,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *p = map(int, stdin.split())\n    if n < 2:\n        return -1\n\n    p = list(p)\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                p[i], p[j] = p[j], p[i]\n\n    result = []\n    for i in range(n - 1):\n        result.append(f\"{i + 1} {p[i + 1]}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2645,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    score = 0\n    for i in range(n):\n        if s[i] == 'g':\n            score += 1\n        else:\n            score -= 1\n    return str(score)"
    },
    {
        "number": 2646,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    rooms = [[] for _ in range(n + 1)]\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        rooms[a].append(b)\n        rooms[b].append(a)\n    visited = [False] * (n + 1)\n    visited[1] = True\n    queue = [(1, 0)]\n    while queue:\n        room, pass_count = queue.pop(0)\n        if room == n:\n            return \"Yes\"\n        for next_room in rooms[room]:\n            if not visited[next_room]:\n                visited[next_room] = True\n                queue.append((next_room, pass_count + 1))\n    return \"No\""
    },
    {
        "number": 2647,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    s = [list(row) for row in stdin.split()]\n    score = 0\n    for i in range(1, H):\n        for j in range(1, W):\n            if s[i][j] == '#':\n                if s[i-1][j] == '.' and s[i][j-1] == '.' and s[i][j+1] == '.' and s[i+1][j] == '.':\n                    score += 1\n                    s[i][j] = '.'\n                elif s[i-1][j] == '#' and s[i][j-1] == '#' and s[i][j+1] == '#' and s[i+1][j] == '#':\n                    score += 1\n                    s[i][j] = '#'\n    if score == 0:\n        return -1\n    return str(score)"
    },
    {
        "number": 2648,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    a.reverse()\n    a = a[:n//2]\n    a.sort()\n    a.reverse()\n    return str(a[0])"
    },
    {
        "number": 2649,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[1:3])\n        points.append((x, y))\n    max_distance = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            max_distance = max(max_distance, distance)\n    return str(max_distance)"
    },
    {
        "number": 2650,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    kindergartens = [[] for _ in range(2 * 10**5 + 1)]\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        kindergartens[b].append(a)\n    evennesses = [float('inf')] * (2 * 10**5 + 1)\n    for k in range(2, 2 * 10**5 + 1):\n        evennesses[k] = min(evennesses[k], max(kindergartens[k]))\n    for _ in range(q):\n        c, d = map(int, stdin.split())\n        evennesses[d] = min(evennesses[d], evennesses[c])\n    return '\\n'.join(map(str, evennesses[2:]))"
    },
    {
        "number": 2651,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    MOD = 10**9 + 7\n\n    def get_area(x1: int, x2: int, y1: int, y2: int) -> int:\n        return (x2 - x1) * (y2 - y1)\n\n    def get_total_area(x1: int, x2: int, y1: int, y2: int) -> int:\n        area = 0\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                area += get_area(i, i, j, j)\n        return area\n\n    total_area = 0\n    for i in range(n):\n        for j in range(m):\n            total_area += get_total_area(i, j, j, j)\n\n    return str(total_area % MOD)\n"
    },
    {
        "number": 2652,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    towns = []\n    for i in range(n):\n        x, y = map(int, stdin.split()[1:3])\n        towns.append((x, y))\n    towns.sort(key=lambda x: (x[0], x[1]))\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = towns[i]\n            c, d = towns[j]\n            cost = abs(a - c) + abs(b - d)\n            if cost < min_cost:\n                min_cost = cost\n\n    return str(min_cost)"
    },
    {
        "number": 2653,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    edges = [tuple(map(int, stdin.split())) for _ in range(n - 1)]\n    parents = [0] * (n + 1)\n    for u, v in edges:\n        parents[u] = v\n        parents[v] = u\n\n    def dfs(u: int) -> None:\n        nonlocal parents\n        for v in range(1, n + 1):\n            if parents[v] == u:\n                parents[v] = u\n                dfs(v)\n\n    for u in range(1, n + 1):\n        if parents[u] == 0:\n            dfs(u)\n\n    def query(p: int, x: int) -> int:\n        nonlocal parents\n        if parents[p] == p:\n            return x\n        parents[p] = query(parents[p], x)\n        return parents[p]\n\n    result = [0] * (n + 1)\n    for _ in range(q):\n        t, p, x = map(int, stdin.split())\n        if t == 1:\n            result[query(p, x)] += x\n        elif t == 2:\n            result[query(p, x)] -= x\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 2654,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a, b = map(int, stdin.split()[1].split())\n    count = 0\n    for i in range(1, n):\n        if a <= i <= b:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2655,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    a.append(a[0])\n    a.sort()\n    comfort = 0\n    for i in range(n):\n        if i == 0:\n            comfort += a[i]\n        else:\n            comfort += min(a[i], a[i - 1])\n    return str(comfort)"
    },
    {
        "number": 2656,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, s = map(int, stdin.split())\n    s = list(s)\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if j - i == k:\n                s[i], s[j - 1] = s[j - 1], s[i]\n                count += 1\n                if count % MOD == 0:\n                    return str(count % MOD)\n    return str(count % MOD)"
    },
    {
        "number": 2657,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a.sort()\n    max_value = float('-inf')\n    result = []\n    for i in range(n):\n        for j in range(i+1, n):\n            value = comb(a[i], a[j])\n            if value > max_value:\n                max_value = value\n                result = [a[i], a[j]]\n    return''.join(map(str, result))\n\ndef"
    },
    {
        "number": 2658,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    visited = [False] * (n + 1)\n    visited[1] = True\n    for i in range(k):\n        if not visited[a[i]]:\n            return a[i]\n        visited[a[i]] = True\n    return -1"
    },
    {
        "number": 2659,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    snuke_numbers = []\n    for i in range(1, 10):\n        snuke_numbers.append(i * 10 ** i)\n\n    snuke_numbers.sort()\n    for i in range(K):\n        print(snuke_numbers[i])\n\n    return \"\"\n"
    },
    {
        "number": 2660,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = stdin.split('\\n')\n    queries = [query.split() for query in queries]\n\n    for query in queries:\n        if query[0] == '1':\n            a, b = int(query[1]), int(query[2])\n            f = lambda x: abs(x - a) + b\n            f = lambda x: f(x) if x >= 0 else -f(-x)\n            f = lambda x: int(f(x))\n            f(0)\n        elif query[0] == '2':\n            f = lambda x: abs(x)\n            f = lambda x: f(x) if x >= 0 else -f(-x)\n            f = lambda x: int(f(x))\n            f(0)\n\n    return '\\n'.join(map(str, [f(x) for x in range(-1000000000, 1000000001)]))\n"
    },
    {
        "number": 2661,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = list(map(int, stdin.split()[1:n+1]))\n    t = list(map(int, stdin.split()[n+1:2*n+1]))\n    u = list(map(int, stdin.split()[2*n+1:3*n+1]))\n    v = list(map(int, stdin.split()[3*n+1:]))\n\n    a = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        if s[i] == 0:\n            a[i] = [u[i]] * n\n        elif s[i] == 1:\n            a[i] = [a[j][i] | u[i] for j in range(n)]\n\n    for j in range(n):\n        if t[j] == 0:\n            a[j] = [a[i][j] & v[j] for i in range(n)]\n        elif t[j] == 1:\n            a[j] = [a[i][j] | v[j] for i in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] < 0:\n                a[i][j] += 2**64\n\n    for i in range(n):\n        for j in range(n):\n            print(a[i][j], end=' ')\n        print()\n\n    return ''"
    },
    {
        "number": 2662,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1:]))\n\n    colors = set()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] == A[j]:\n                colors.add(A[i])\n\n    return str(len(colors))"
    },
    {
        "number": 2663,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    l = [0] * (n * (n + 1) // 2)\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            l[i + j - 1] = l[i + j - 1] + a[i] + a[j - 1]\n    return \" \".join(map(str, l[:k]))"
    },
    {
        "number": 2664,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple[int, int]:\n        n, *p1, *p2 = map(int, stdin.split())\n        return n, p1, p2\n\n    def print_output(colour: int) -> None:\n        print(\"2\")\n        print(colour)\n\n    def print_pan(n: int, p1: list[int], p2: list[int]) -> None:\n        print(n)\n        print(*p1)\n        print(*p2)\n\n    def read_difference() -> int:\n        return int(stdin.readline().strip())\n\n    def get_heavier_colour(p1: list[int], p2: list[int]) -> int:\n        return max(p1, p2)\n\n    def get_colour_weight(colour: int, p1: list[int], p2: list[int]) -> int:\n        return p1[colour - 1] if p1[colour - 1] > p2[colour - 1] else p2[colour - 1]\n\n    def main() -> None:\n        n, p1, p2 = read_input()\n        difference = read_difference()\n\n        if difference == 0:\n            print_output(1)\n        else:\n            p1_colour = get_heavier_colour(p1, p2)\n            p2_colour = get_heavier_colour(p2, p1)\n\n            if difference > 0:\n                p1_colour, p2_colour = p2_colour, p1_colour\n\n            print_output(p1_colour)\n            print_pan(n, p1, p2)\n\n    main()\n\n\ndef"
    },
    {
        "number": 2665,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n    points.sort(key=lambda x: x[0])\n    points.sort(key=lambda x: x[1])\n\n    def is_parallel(a, b):\n        return abs(a[0] - b[0]) == abs(a[1] - b[1])\n\n    def is_square(points):\n        for i in range(len(points) - 1):\n            if is_parallel(points[i], points[i + 1]):\n                return False\n        return True\n\n    def count_points(points):\n        count = 0\n        for i in range(len(points) - 1):\n            count += abs(points[i][0] - points[i + 1][0]) + abs(points[i][1] - points[i + 1][1])\n        return count\n\n    def find_min_points(points):\n        min_points = count_points(points)\n        for i in range(1, len(points)):\n            new_points = points[:i] + points[i + 1:]\n            if is_square(new_points):\n                min_points = min(min_points, count_points(new_points))\n        return min_points\n\n    return str(find_min_points(points))\n"
    },
    {
        "number": 2666,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    prices = list(map(int, stdin.split()))\n    max_profit = 0\n    for i in range(1, n):\n        if prices[i] < prices[i - 1]:\n            max_profit += prices[i] - prices[i - 1]\n        if i >= k:\n            max_profit -= prices[i - k]\n    return str(max_profit)"
    },
    {
        "number": 2667,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    if sum(c) % n!= 0:\n        return \"NO\"\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def distribute(stamps, members):\n        total_stamps = sum(stamps)\n        lcm_stamps = lcm(total_stamps, members)\n        return [stamps[i] * lcm_stamps // total_stamps for i in range(len(members))]\n\n    stamps = c\n    members = [i for i in range(1, n + 1)]\n    result = distribute(stamps, members)\n    if result == stamps:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 2668,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    jacketCost, sockCost, money = map(int, stdin.split())\n\n    if jacketCost > money:\n        return \"Unlucky Chef\"\n\n    socks = money // sockCost\n    if socks < 1:\n        return \"Unlucky Chef\"\n\n    return \"Lucky Chef\""
    },
    {
        "number": 2669,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    tasks = []\n    for i in range(n):\n        start, finish = map(int, stdin.split()[1:3])\n        tasks.append((start, finish))\n    tasks.sort(key=lambda x: x[1])\n    result = []\n    for i in range(n):\n        if i == 0 or tasks[i][0] > tasks[i - 1][1]:\n            result.append(i)\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2670,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        str1, str2 = stdin.split()[1:]\n        subpair1 = str1[::-1]\n        subpair2 = str2[::-1]\n        X = subpair1 + subpair2\n        if X == X[::-1] and len(subpair1) == len(subpair2) and len(X) == max(len(subpair1), len(subpair2)):\n            print(len(X))\n        else:\n            print(0)"
    },
    {
        "number": 2671,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    X = list(map(int, stdin.split()))\n\n    def dfs(level, index, count):\n        if level == n:\n            return count\n        if index == len(a):\n            return float('inf')\n        return min(dfs(level + 1, index + 1, count + a[index]), dfs(level + 1, index + 1, count))\n\n    result = []\n    for x in X:\n        count = dfs(0, 0, 0)\n        if count >= x:\n            result.append(count)\n        else:\n            result.append(float('inf'))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2672,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    if X == 1:\n        return \"3\"\n    elif X == 2:\n        return \"14\"\n    else:\n        return str((X * (X - 1)) // 2) % 1000000007"
    },
    {
        "number": 2673,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    jumps = 0\n    i = 0\n    while i < n - 1:\n        if stdin[i] == stdin[i + 1]:\n            i += 1\n        else:\n            jumps += 1\n            i += 2\n    return str(jumps)"
    },
    {
        "number": 2674,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin)\n    if p < 100 or p > 999:\n        return \"Invalid input\"\n    if p % 10 == 0:\n        return \"Inclusive\"\n    else:\n        return \"Exclusive\""
    },
    {
        "number": 2675,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    red_balls = []\n    blue_balls = []\n\n    for i in range(n):\n        x, u = map(int, stdin.split())\n        red_balls.append((x, u))\n\n    for i in range(m):\n        y, v = map(int, stdin.split())\n        blue_balls.append((y, v))\n\n    collisions = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if red_balls[i][0] == red_balls[j][0]:\n                collisions += 1\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if blue_balls[i][0] == blue_balls[j][0]:\n                collisions += 1\n\n    return str(collisions)"
    },
    {
        "number": 2676,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    strings = stdin.split()[1:]\n    m = int(stdin.split()[n+1])\n    b = stdin.split()[n+2]\n\n    def count_unique_substrings(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                count += 1\n        return count\n\n    unique_substrings = set()\n    for string in strings:\n        unique_substrings.add(string)\n\n    count = 0\n    for substring in unique_substrings:\n        if substring in b:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2677,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOUaeiou\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz\"\n    good_string = False\n    count_vowels = 0\n    count_consonants = 0\n    for char in stdin:\n        if char in vowels:\n            count_vowels += 1\n        elif char in consonants:\n            count_consonants += 1\n        if count_vowels >= 3 and count_consonants >= 5:\n            good_string = True\n            break\n    if good_string:\n        return \"GOOD\"\n    else:\n        return \"-1\""
    },
    {
        "number": 2678,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.split('\\n'):\n        a, b = map(int, line.split())\n        intervals.append([a, b])\n\n    covered_intervals = set()\n    for interval in intervals:\n        for i in range(interval[0], interval[1] + 1):\n            covered_intervals.add(i)\n\n    covered_intervals = sorted(covered_intervals)\n    smallest_set = set()\n    for i in range(len(covered_intervals) - 1, -1, -1):\n        if covered_intervals[i] not in smallest_set:\n            smallest_set.add(covered_intervals[i])\n            break\n\n    return str(len(smallest_set))"
    },
    {
        "number": 2679,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    coins = list(map(int, stdin.split()))\n    n = len(coins)\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i+1, n+1):\n            subarray = coins[i:j]\n            if sum(subarray) > max_sum:\n                max_sum = sum(subarray)\n    return str(max_sum)"
    },
    {
        "number": 2680,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    def bfs(x, y, visited):\n        queue = [(x, y)]\n        visited[x][y] = True\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 1 <= nx <= n and 1 <= ny <= n and not visited[nx][ny]:\n                    queue.append((nx, ny))\n                    visited[nx][ny] = True\n        return visited\n\n    def defuse_bomb(x, y, visited):\n        visited[x][y] = True\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= n and 1 <= ny <= n and not visited[nx][ny]:\n                defuse_bomb(nx, ny, visited)\n\n    visited = [[False] * (n + 1) for _ in range(n + 1)]\n    for i in range(b):\n        x, y = x[i], y[i]\n        if x == 1 and y == 1:\n            defuse_bomb(x, y, visited)\n        elif x == n and y == n:\n            defuse_bomb(x, y, visited)\n        else:\n            bfs(x, y, visited)\n\n    moves = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if not visited[i][j]:\n                moves += 1\n\n    return str(moves)"
    },
    {
        "number": 2681,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into A, B, and C\n    A, B, C = stdin.split()\n    A, B, C = int(A), int(B), C\n\n    # Perform the operation based on the operator\n    if C == \"+\":\n        result = A + B\n    elif C == \"-\":\n        result = A - B\n    elif C == \"*\":\n        result = A * B\n    elif C == \"/\":\n        result = A / B\n    else:\n        return \"Invalid operator\"\n\n    # Return the result as a string\n    return str(result)"
    },
    {
        "number": 2682,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    decks = [list(range(n)) for _ in range(2 * n)]\n    for i in range(n):\n        decks[i].extend(decks[i + n])\n    for i in range(n):\n        decks[i].extend(decks[i + n])\n    for i in range(n):\n        decks[i].extend(decks[i + n])\n    decks = [sorted(deck) for deck in decks]\n    return \" \".join(map(str, decks[k]))"
    },
    {
        "number": 2683,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split('\\n')[0])\n    for _ in range(test_cases):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        board = [list(row) for row in stdin.split('\\n')[2:2+n]]\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == '.':\n                    board[i][j] = 'X' if i % 2 == 0 else 'O'\n        for i in range(n):\n            if board[i][0] == board[i][1] == board[i][2]!= '.':\n                return 'YES'\n            if board[0][i] == board[1][i] == board[2][i]!= '.':\n                return 'YES'\n        if board[0][0] == board[1][1] == board[2][2]!= '.':\n            return 'YES'\n        if board[0][2] == board[1][1] == board[2][0]!= '.':\n            return 'YES'\n        if k == 1:\n            for i in range(n):\n                if board[i][i] == 'X':\n                    return 'YES'\n                if board[i][i] == 'O':\n                    return 'NO'\n        else:\n            for i in range(n):\n                if board[i][i] == 'X':\n                    return 'YES'\n                if board[i][i] == 'O':\n                    return 'NO'\n    return 'NO'"
    },
    {
        "number": 2684,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    n = len(word)\n    longest_palindrome = \"\"\n    longest_palindrome_length = 0\n\n    for i in range(n):\n        for j in range(i, n):\n            subword = word[i:j+1]\n            if subword == subword[::-1]:\n                if len(subword) > longest_palindrome_length:\n                    longest_palindrome = subword\n                    longest_palindrome_length = len(subword)\n\n    return str(longest_palindrome_length) + \"\\n\" + longest_palindrome"
    },
    {
        "number": 2685,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split()\n    x, y = map(int, s[1].split())\n    s = s[0]\n    cost = 0\n    for i, c in enumerate(s):\n        if c == '?':\n            cost += x * (i + 1)\n        else:\n            cost += y\n    return str(cost)"
    },
    {
        "number": 2686,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    buildings = list(map(int, stdin.split()))\n    pairs = []\n    for i in range(1, m + 1):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    s, t = map(int, stdin.split())\n\n    def is_close(a, b):\n        return abs(a - b) <= 1\n\n    def is_valid(a, b):\n        return is_close(a, s) and is_close(b, t)\n\n    def is_valid_pair(a, b):\n        return is_valid(a, b) or is_valid(b, a)\n\n    def shortest_route(start, end):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            current, jumps = queue.pop(0)\n            if current == end:\n                return jumps\n            if current in visited:\n                continue\n            visited.add(current)\n            for next_building in range(1, n + 1):\n                if is_valid_pair(current, next_building):\n                    queue.append((next_building, jumps + 1))\n        return -1\n\n    shortest_routes = []\n    for pair in pairs:\n        if is_valid_pair(pair[0], pair[1]):\n            shortest_routes.append(shortest_route(pair[0], pair[1]))\n\n    if shortest_routes:\n        shortest_route = min(shortest_routes)\n        if shortest_route == -1:\n            return \"0\"\n        return str(shortest_route)\n    else:\n        return \"0\"\n"
    },
    {
        "number": 2687,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    MOD = 10**9 + 9\n\n    def count_initial_configurations(strengths: list) -> int:\n        n = len(strengths)\n        strengths.sort(reverse=True)\n        count = 0\n        for i in range(1, n + 1):\n            count += strengths.count(i)\n        return count\n\n    def simulate_tournament(strengths: list) -> int:\n        n = len(strengths)\n        count = 0\n        for i in range(1, 2 * K + 1):\n            count += count_initial_configurations(strengths)\n            strengths = [strengths[i - 1], strengths[i - 2]]\n        return count\n\n    def simulate_knights(strengths: list) -> int:\n        n = len(strengths)\n        count = 0\n        for i in range(1, 2 * K + 1):\n            count += count_initial_configurations(strengths)\n            strengths = [strengths[i - 1], strengths[i - 2]]\n            if i % 2 == 0:\n                strengths.sort(reverse=True)\n        return count\n\n    def simulate_knights_with_rounds(strengths: list) -> int:\n        n = len(strengths)\n        count = 0\n        for i in range(1, 2 * K + 1):\n            count += count_initial_configurations(strengths)\n            strengths = [strengths[i - 1], strengths[i - 2]]\n            if i % 2 == 0:\n                strengths.sort(reverse=True)\n            else:\n                strengths.sort()\n        return count\n\n    def simulate_knights_with_rounds_and_battles(strengths: list) -> int:\n        n = len(strengths)\n        count = 0\n        for i in range(1, 2 * K + 1):\n            count += count_initial_configurations(strengths)\n            strengths = [strengths[i - 1], strengths[i - 2]]\n            if i % 2 == 0:\n                strengths.sort(reverse=True)\n            else:\n                strengths.sort()\n            for j in range(1, 2 * K + 1):\n                count += count_initial_configurations(strengths)\n                strengths = [strengths[i - 1], strengths[i - 2]]\n                if i % 2 == 0:\n                    strengths.sort(reverse=True)\n                else:\n                    strengths.sort()\n        return count\n\n    def simulate_knights_with_rounds_and_battles_and_winners(strengths: list) -> int:\n        n = len(strengths)\n        count = 0\n        for i in range(1, 2 * K + 1):\n            count += count_initial_configurations(strengths)\n            strengths = [strengths[i - 1], strengths[i - 2]]\n            if i % 2 == 0:\n                strengths.sort(reverse=True)\n            else:\n                strengths.sort()\n            for j in range(1, 2 * K + 1):\n                count += count_initial_configurations(strengths)\n                strengths = [strengths[i - 1], strengths[i - 2]]\n                if i % 2 == 0:\n                    strengths.sort(reverse=True)\n                else:\n                    strengths.sort()\n                for k in range(1, 2 * K + 1):\n                    count += count_initial_configurations(strengths)\n                    strengths = [strengths[i - 1], strengths[i - 2]]\n                    if i % 2 == 0:\n                        strengths.sort(reverse=True)\n                    else:\n                        strengths.sort()\n                    for l in range(1, 2 * K + 1):\n                        count += count_initial_configurations(strengths)\n                        strengths = [strengths[i - 1], strengths[i - 2]]\n                        if i % 2 == 0:\n                            strengths.sort(reverse=True)\n                        else:\n                            strengths.sort()\n                        for m in range(1, 2 * K + 1):\n                            count += count_initial_configurations(strengths)\n                            strengths = [strengths[i - 1], strengths[i - 2]]\n                            if i % 2 == 0:\n                                strengths.sort(reverse=True)\n                            else:\n                                strengths.sort()\n                            for n in range(1, 2 * K + 1):\n                                count +="
    },
    {
        "number": 2688,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    permutation = list(map(int, stdin.split()[1:]))\n    cycles = []\n    visited = set()\n    current_cycle = []\n\n    def dfs(position):\n        if position in visited:\n            return\n        visited.add(position)\n        current_cycle.append(position)\n        if position == N:\n            cycles.append(current_cycle)\n        else:\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + 1)\n            dfs(position + "
    },
    {
        "number": 2689,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    code_string = stdin.strip()\n    original_string = \"\"\n    count = 1\n    for i in range(len(code_string)):\n        if code_string[i].isdigit():\n            count = int(code_string[i])\n            original_string += code_string[i]\n        elif code_string[i] == \"+\":\n            if i + 1 < len(code_string) and code_string[i + 1] == \"-\":\n                original_string += code_string[i] + code_string[i + 1]\n                i += 1\n            else:\n                original_string += code_string[i] * count\n                count = 1\n        else:\n            original_string += code_string[i] * count\n            count = 1\n    if code_string == original_string[::-1]:\n        return \"Return\"\n    else:\n        return \"Continue\""
    },
    {
        "number": 2690,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    s = list(stdin)\n    max_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i]!= s[j]:\n                diff = abs(i-j)\n                if diff > max_diff:\n                    max_diff = diff\n    return str(max_diff)"
    },
    {
        "number": 2691,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = stdin.split()[1]\n    d = S.count('d')\n    u = S.count('u')\n    if d > u:\n        S = S.replace('d', 'u', P)\n    else:\n        S = S.replace('u', 'd', P)\n    return len(S)"
    },
    {
        "number": 2692,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = int(stdin.split()[0])\n    for _ in range(test_cases):\n        n, b = map(int, stdin.split()[1:])\n        a = 0\n        while n >= b:\n            a += n // b\n            n %= b\n        print(a)"
    },
    {
        "number": 2693,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, p, k = map(int, stdin.split())\n    if k > 4 or k < 1:\n        return \"NO\"\n    if s > 1000 or p > 1000:\n        return \"NO\"\n    n = [1] * k\n    for i in range(2, s + 1):\n        if sum(n) == i:\n            n.append(i)\n        elif sum(n) - i == s:\n            n.append(i)\n        elif sum(n) - i == p:\n            n.append(i)\n        elif sum(n) - i == p * i:\n            n.append(i)\n    if n == [1] * k:\n        return \"NO\"\n    return \" \".join(map(str, n))"
    },
    {
        "number": 2694,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    blasters = []\n    for _ in range(k):\n        row, col, t, f = map(int, stdin.split())\n        blasters.append((row, col, t, f))\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    def is_safe(x, y):\n        return not any(is_valid(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_blocked(x, y):\n        return any(is_valid(x + dx, y + dy) and blasters[i][0] == x and blasters[i][1] == y for i, (dx, dy) in enumerate(product([-1, 0, 1], repeat=2)))\n\n    def is_safe_to_shoot(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move_or_move_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move_or_move_or_move_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move_or_move_or_move_or_move_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y + dy) for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)])\n\n    def is_safe_to_move_and_shoot_or_move_or_move_or_move_or_move_or_move_or_move_or_move_or_move(x, y):\n        return not any(is_blocked(x + dx, y +"
    },
    {
        "number": 2695,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.split('\\n')\n    A = list(A)\n    B = list(B)\n    permutation = list(map(int, stdin.split('\\n')[2].split()))\n\n    def remove_letters(indices: list) -> str:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices])\n\n    def is_valid(indices: list) -> bool:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices]) == ''.join([B[i] for i in non_zero_indices])\n\n    def max_indices(indices: list) -> int:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        max_index = max(non_zero_indices)\n        return max_index\n\n    def is_valid_permutation(indices: list) -> bool:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices]) == ''.join([B[i] for i in non_zero_indices])\n\n    def max_indices_permutation(indices: list) -> int:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        max_index = max(non_zero_indices)\n        return max_index\n\n    def is_valid_permutation_with_removal(indices: list) -> bool:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices]) == ''.join([B[i] for i in non_zero_indices])\n\n    def max_indices_permutation_with_removal(indices: list) -> int:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        max_index = max(non_zero_indices)\n        return max_index\n\n    def is_valid_permutation_with_removal_and_permutation(indices: list) -> bool:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices]) == ''.join([B[i] for i in non_zero_indices])\n\n    def max_indices_permutation_with_removal_and_permutation(indices: list) -> int:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        max_index = max(non_zero_indices)\n        return max_index\n\n    def is_valid_permutation_with_removal_and_permutation_with_removal(indices: list) -> bool:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices]) == ''.join([B[i] for i in non_zero_indices])\n\n    def max_indices_permutation_with_removal_and_permutation_with_removal(indices: list) -> int:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        max_index = max(non_zero_indices)\n        return max_index\n\n    def is_valid_permutation_with_removal_and_permutation_with_removal_and_permutation(indices: list) -> bool:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        return ''.join([A[i] for i in non_zero_indices]) == ''.join([B[i] for i in non_zero_indices])\n\n    def max_indices_permutation_with_removal_and_permutation_with_removal_and_permutation(indices: list) -> int:\n        non_zero_indices = [i for i, j in enumerate(indices) if j!= 0]\n        max_index = max(non_zero_indices)\n        return max_index\n\n    def is_valid_permutation_with_removal_and_permutation_with_removal_and_permutation_with_removal(indices: list) -> bool:\n        non_zero_indices = [i for i, j"
    },
    {
        "number": 2696,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = list(a)\n    a.sort()\n    for i in range(n):\n        if a[i] == a[n - 1]:\n            return str(n)\n    return str(a[n - 1] + 1)"
    },
    {
        "number": 2697,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str((N - 1) // 2)"
    },
    {
        "number": 2698,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, V = map(int, stdin.split())\n    lanes = [list(map(int, stdin.split())) for _ in range(M)]\n    days = [0] * M\n    max_veg = 0\n\n    for i in range(1, M):\n        days[i] = days[i - 1] + lanes[i][0]\n\n    for i in range(M - 1, -1, -1):\n        if days[i] <= days[i + 1]:\n            max_veg = max(max_veg, min(lanes[i][1], V))\n            V -= min(lanes[i][1], V)\n\n    return str(max_veg)"
    },
    {
        "number": 2699,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        N = int(stdin.split()[1])\n        if N == 1:\n            print(\"1 4 10\")\n        elif N == 2:\n            print(\"2 5 11\")\n        elif N == 3:\n            print(\"1 4 10 22\")\n        elif N == 4:\n            print(\"2 5 11 23\")\n        elif N == 5:\n            print(\"1 4 10 22 46\")\n        elif N == 6:\n            print(\"2 5 11 23 47\")\n        elif N == 7:\n            print(\"1 4 10 22 46 94\")\n        elif N == 8:\n            print(\"2 5 11 23 47 95\")\n        elif N == 9:\n            print(\"1 4 10 22 46 94 169\")\n        elif N == 10:\n            print(\"2 5 11 23 47 95 170\")\n        else:\n            print(\"3 6 12 24 48\")"
    },
    {
        "number": 2700,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        a, b, c, d = map(int, stdin.split()[1:])\n        count = 0\n        for x in range(a, b+1):\n            for y in range(c, d+1):\n                if x < y:\n                    count += 1\n        print(count)"
    },
    {
        "number": 2701,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    types = list(map(int, stdin.split()))\n\n    left_dog = 0\n    right_dog = n - 1\n\n    left_apples = 0\n    right_apples = 0\n\n    while left_apples < k and right_apples < k:\n        if types[left_dog - 1] == types[right_dog + 1]:\n            left_apples += 1\n            right_apples += 1\n        elif types[left_dog - 1] < types[right_dog + 1]:\n            left_apples += 1\n        else:\n            right_apples += 1\n\n        left_dog = (left_dog + 1) % n\n        right_dog = (right_dog - 1) % n\n\n    if left_apples == k and right_apples == k:\n        return \"0\"\n    elif left_apples == k:\n        return str(right_dog + 1)\n    elif right_apples == k:\n        return str(left_dog + 1)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 2702,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    statements = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    truth_speaking_people = set()\n    max_truth_speaking_people = 0\n\n    for statement in statements:\n        truth_speaking_people.update(set(statement))\n\n    for truth_speaking_person in truth_speaking_people:\n        if truth_speaking_person not in truth_speaking_people - {0}:\n            max_truth_speaking_people += 1\n\n    return str(max_truth_speaking_people)"
    },
    {
        "number": 2703,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    candies = list(map(int, stdin.split()))\n    queries = list(map(int, stdin.split()))\n\n    def max_candies(candies, queries):\n        max_candies = 0\n        for i in range(n):\n            max_candies = max(max_candies, candies[i] + queries[i])\n        return max_candies\n\n    return str(max_candies(candies, queries))"
    },
    {
        "number": 2704,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    for i in range(q):\n        t = int(stdin.split())\n        if t in A:\n            A.remove(t)\n        else:\n            A.append(t)\n    return \"Yes\" if len(A) == 1 else \"No\""
    },
    {
        "number": 2705,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    for _ in range(m):\n        i = random.randint(1, n)\n        a[i] += 1 if a[i] < k else a[i] - k\n\n    beauty = max(len(set(a[i:j] % k for i in range(n) for j in range(i + 1, n + 1))) for i in range(n))\n\n    return str(beauty)"
    },
    {
        "number": 2706,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    queries = []\n    for _ in range(n):\n        query = int(stdin.split()[0])\n        queries.append(query)\n\n    k_th_min = float('inf')\n    for query in queries:\n        if query >= 0:\n            k_th_min = min(k_th_min, query)\n        elif query == -1:\n            return str(k_th_min)\n\n    return str(k_th_min)"
    },
    {
        "number": 2707,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def backtrack(start, current_mex, result):\n        if current_mex > k:\n            return\n\n        if start == n:\n            result += 1\n            return\n\n        backtrack(start + 1, current_mex, result)\n        backtrack(start + 1, current_mex + A[start], result)\n\n    result = 0\n    backtrack(0, 0, result)\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 2708,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = n\n    for _ in range(k):\n        if result % 10 == 0:\n            result //= 10\n        else:\n            result -= 1\n    return str(result)"
    },
    {
        "number": 2709,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    if t == 1:\n        print(7)\n        return \"\"\n\n    if t == 2:\n        if A[0] > A[1]:\n            print(\"Bigger\")\n        elif A[0] == A[1]:\n            print(\"Equal\")\n        else:\n            print(\"Smaller\")\n        return \"\"\n\n    if t == 3:\n        A.sort()\n        print(A[1])\n        return \"\"\n\n    if t == 4:\n        print(sum(A))\n        return \"\"\n\n    if t == 5:\n        print(sum(filter(lambda x: x % 2 == 0, A)))\n        return \"\"\n\n    if t == 6:\n        print(\"\".join(chr((x % 26) + ord('a')) for x in A))\n        return \"\"\n\n    if t == 7:\n        i = 0\n        while True:\n            if i < 0 or i >= N:\n                print(\"Out\")\n                break\n            if i == N - 1:\n                print(\"Done\")\n                break\n            i = A[i]\n            if i == i:\n                print(\"Cyclic\")\n                break\n            i = A[i]\n        return \"\"\n\n    return \"\"\n"
    },
    {
        "number": 2710,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    a = list(map(int, stdin.split()[1].split()))\n    b = list(map(int, stdin.split()[2].split()))\n    roads = []\n    for i in range(m):\n        p, q = map(int, stdin.split()[3+i].split())\n        roads.append((p-1, q-1))\n\n    def dfs(city, visited, soldiers):\n        if city in visited:\n            return False\n        visited.add(city)\n        if city == n:\n            return soldiers == b[city]\n        for neighbor in range(n):\n            if neighbor not in visited and (neighbor, city) not in roads:\n                if dfs(neighbor, visited, soldiers + a[city]):\n                    return True\n        return False\n\n    for city in range(n):\n        if dfs(city, set(), 0):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2711,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    pages = []\n    for _ in range(n):\n        page_num, *words = stdin.split()\n        pages.append((int(page_num), words))\n\n    def reconstruct_alphabet(words):\n        alphabet = set()\n        for word in words:\n            for char in word:\n                alphabet.add(char)\n        return sorted(alphabet)\n\n    def is_dictionary(words):\n        for word in words:\n            if len(word) > 1 and word[0] == word[-1]:\n                return False\n        return True\n\n    def find_best_solution(pages):\n        best_solution = None\n        for page_num, words in pages:\n            if is_dictionary(words):\n                alphabet = reconstruct_alphabet(words)\n                if best_solution is None or len(alphabet) < len(best_solution):\n                    best_solution = alphabet\n        return best_solution\n\n    best_solution = find_best_solution(pages)\n    if best_solution is None:\n        return \"IMPOSSIBLE\"\n    return \"\".join(best_solution)"
    },
    {
        "number": 2712,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    for _ in range(t):\n        a, b, c = map(int, stdin.split('\\n')[1].split())\n        d = (a + b + c) // 2\n        print(d)"
    },
    {
        "number": 2713,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    wins = 0\n    losses = 0\n    stars = [0] * 25\n    rank = 25\n    consecutive_wins = 0\n\n    for char in stdin:\n        if char == 'W':\n            wins += 1\n            if rank == 25:\n                consecutive_wins += 1\n                if consecutive_wins == 3:\n                    stars[24] += 1\n            else:\n                stars[rank - 1] += 1\n        else:\n            losses += 1\n            if rank == 25:\n                consecutive_wins = 0\n            else:\n                stars[rank - 1] -= 1\n                if stars[rank - 1] < 0:\n                    rank -= 1\n                    stars[rank - 1] = 0\n                    if rank == 25:\n                        consecutive_wins = 0\n            if rank == 1:\n                rank = 25\n                consecutive_wins = 0\n\n        if rank == 25:\n            if consecutive_wins == 3:\n                stars[24] += 1\n            rank = 24\n        elif rank == 1:\n            rank = 25\n            consecutive_wins = 0\n\n    if rank == 25:\n        return 'Legend'\n    else:\n        return str(rank)"
    },
    {
        "number": 2714,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        if u in graph:\n            for v in graph[u]:\n                if v not in visited:\n                    visited.add(v)\n                    if dfs(v, visited) % 2 == 1:\n                        return 1\n        return 0\n\n    def bfs(u: int) -> int:\n        queue = deque([u])\n        visited = set()\n        visited.add(u)\n        count = 0\n        while queue:\n            v = queue.popleft()\n            for w in graph[v]:\n                if w not in visited:\n                    visited.add(w)\n                    if dfs(w, visited) % 2 == 1:\n                        count += 1\n                    queue.append(w)\n        return count\n\n    def dfs_count(u: int, visited: set) -> int:\n        visited.add(u)\n        if u in graph:\n            for v in graph[u]:\n                if v not in visited:\n                    visited.add(v)\n                    count = dfs_count(v, visited)\n                    if count % 2 == 1:\n                        return 1\n        return 0\n\n    def bfs_count(u: int) -> int:\n        queue = deque([u])\n        visited = set()\n        visited.add(u)\n        count = 0\n        while queue:\n            v = queue.popleft()\n            for w in graph[v]:\n                if w not in visited:\n                    visited.add(w)\n                    count += dfs_count(w, visited)\n                    queue.append(w)\n        return count\n\n    def count_ways(n: int) -> int:\n        return (n * (n - 1)) // 2\n\n    def count_ways_odd(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 1)) // 6\n\n    def count_ways_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 2)) // 6\n\n    def count_ways_odd_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 3)) // 6\n\n    def count_ways_odd_even_odd(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 4)) // 6\n\n    def count_ways_odd_even_odd_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 5)) // 6\n\n    def count_ways_odd_even_odd_even_odd(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 6)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 7)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 8)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 9)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd_even_odd(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 10)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd_even_odd_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 11)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd_even_odd_even_odd(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 12)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd_even_odd_even_odd_even(n: int) -> int:\n        return (n * (n - 1) * (2 * n - 13)) // 6\n\n    def count_ways_odd_even_odd_even_odd_even_odd_"
    },
    {
        "number": 2715,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    if K == 0:\n        return \"4\\n3 3 3 3\"\n\n    N = 1\n    a = [1] * N\n    while True:\n        max_val = max(a)\n        if max_val == N - 1:\n            break\n        for i in range(N):\n            a[i] += 1\n        N += 1\n\n    return f\"{N}\\n{' '.join(map(str, a))}\""
    },
    {
        "number": 2716,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t = map(int, stdin.split())\n    A = list(map(int, stdin.split()[1:]))\n\n    if t == 1:\n        for i in range(N):\n            for j in range(i + 1, N):\n                if A[i]!= A[j] and A[i] + A[j] == 7777:\n                    print(\"Yes\")\n                    return\n        print(\"No\")\n\n    elif t == 2:\n        if len(set(A)) == N:\n            print(\"Unique\")\n        else:\n            print(\"Contains duplicate\")\n\n    elif t == 3:\n        count = 0\n        for num in A:\n            count += A.count(num)\n        if count > N // 2:\n            print(max(A, key=A.count))\n        else:\n            print(-1)\n\n    elif t == 4:\n        if N % 2 == 1:\n            print(sorted(A)[N // 2])\n        else:\n            print(sorted(A)[N // 2 - 1], sorted(A)[N // 2])\n\n    elif t == 5:\n        for i in range(100, 1000):\n            if i in A:\n                print(i, end=\" \")\n\n    return \"\"\n"
    },
    {
        "number": 2717,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    teams = stdin.split()[1]\n    teams_dict = {'A': [], 'B': [], 'C': []}\n\n    for i, team in enumerate(teams):\n        teams_dict[team].append(i)\n\n    min_moves = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if teams_dict['A'][i] < teams_dict['A'][j]:\n                min_moves = min(min_moves, abs(teams_dict['A'][i] - teams_dict['A'][j]))\n            elif teams_dict['A'][i] > teams_dict['A'][j]:\n                min_moves = min(min_moves, abs(teams_dict['A'][j] - teams_dict['A'][i]))\n\n            if teams_dict['B'][i] < teams_dict['B'][j]:\n                min_moves = min(min_moves, abs(teams_dict['B'][i] - teams_dict['B'][j]))\n            elif teams_dict['B'][i] > teams_dict['B'][j]:\n                min_moves = min(min_moves, abs(teams_dict['B'][j] - teams_dict['B'][i]))\n\n            if teams_dict['C'][i] < teams_dict['C'][j]:\n                min_moves = min(min_moves, abs(teams_dict['C'][i] - teams_dict['C'][j]))\n            elif teams_dict['C'][i] > teams_dict['C'][j]:\n                min_moves = min(min_moves, abs(teams_dict['C'][j] - teams_dict['C'][i]))\n\n    return str(min_moves)"
    },
    {
        "number": 2718,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stack1 = list(map(int, stdin.split()))\n    stack2 = list(map(int, stdin.split()))\n\n    while stack1 and stack2:\n        if len(stack1) > len(stack2):\n            stack1.pop(0)\n        else:\n            stack2.pop(0)\n\n        if len(stack1) % m == 0:\n            return \"win\"\n\n    if not stack1:\n        return \"win\"\n    else:\n        return \"lose\""
    },
    {
        "number": 2719,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    needles = []\n    for line in stdin.split('\\n'):\n        x1, y1, z1, x2, y2, z2 = map(int, line.split())\n        needles.append((x1, y1, z1, x2, y2, z2))\n\n    true_closed_chains = []\n    floor_closed_chains = []\n\n    for i in range(len(needles)):\n        for j in range(i + 1, len(needles)):\n            if not any(set(needles[i]) & set(needles[j])):\n                true_closed_chains.append((needles[i], needles[j]))\n            if not any(set(needles[j]) & set(needles[i])):\n                floor_closed_chains.append((needles[j], needles[i]))\n\n    if true_closed_chains:\n        return 'True closed chains'\n    elif floor_closed_chains:\n        return 'Floor closed chains'\n    else:\n        return 'No true closed chains\\nNo floor closed chains'"
    },
    {
        "number": 2720,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split()[0].split())\n    maze = [list(row) for row in stdin.split()[1:]]\n\n    odd_squares = [row for row in maze if sum(i % 2 == 1 for i in range(len(row))) % 2 == 1]\n    even_squares = [row for row in maze if sum(i % 2 == 1 for i in range(len(row))) % 2 == 0]\n\n    if len(odd_squares) == 1 and len(even_squares) == 1:\n        return \"0\"\n\n    if len(odd_squares) == 1:\n        return \"1\"\n\n    if len(even_squares) == 1:\n        return \"2\"\n\n    return \"3\"\n"
    },
    {
        "number": 2721,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, l, M, L, tm, tl = map(int, stdin.split())\n    if m == M and l == L:\n        return \"impossible\"\n    if m == M or l == L:\n        return \"possible\"\n    if m > M or l < L:\n        return \"impossible\"\n    if m == l:\n        return \"impossible\"\n    if m > l:\n        return \"impossible\"\n    if m == M and l < L:\n        return \"impossible\"\n    if m < M and l == L:\n        return \"impossible\"\n    if m < M and l > L:\n        return \"impossible\"\n    if m > M and l < L:\n        return \"impossible\"\n    if m == M and l > L:\n        return \"impossible\"\n    if m > M and l == L:\n        return \"impossible\"\n    if m < M and l == L:\n        return \"impossible\"\n    if m == M and l < L:\n        return \"impossible\"\n    if m < M and l > L:\n        return \"impossible\"\n    if m > M and l > L:\n        return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 2722,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(row) for row in stdin.split('\\n')]\n    diamond = board.index(['D'])\n    ice_castles = [board.index(['I']) for row in board for cell in row if cell == ['I']]\n\n    def is_valid(program: str) -> bool:\n        x, y = 0, 0\n        for instruction in program:\n            if instruction == 'F':\n                x += 1\n            elif instruction == 'R':\n                y += 1\n            elif instruction == 'L':\n                y -= 1\n            elif instruction == 'X':\n                if x < 0 or x >= 8 or y < 0 or y >= 8:\n                    return False\n                if board[x][y] == ['C', 'I'][board[x][y].index(['C', 'I'])]:\n                    return False\n                if board[x][y] == ['C', 'D'][board[x][y].index(['C', 'D'])]:\n                    board[x][y] = ['.']\n                else:\n                    board[x][y] = ['C', 'I'][board[x][y].index(['C', 'I'])][::-1]\n            else:\n                return False\n        return x == diamond and y == diamond\n\n    def shortest_valid_program(start: int, end: int) -> str:\n        queue = [(start, end, '')]\n        visited = set()\n        while queue:\n            x, y, program = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if x == diamond and y == diamond:\n                return program\n            if is_valid(program):\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < 8 and 0 <= ny < 8 and board[nx][ny] == ['.']:\n                        queue.append((nx, ny, program + 'F'))\n        return ''\n\n    def shortest_valid_program_recursive(start: int, end: int) -> str:\n        if start == end:\n            return ''\n        mid = (start + end) // 2\n        left = shortest_valid_program_recursive(start, mid)\n        right = shortest_valid_program_recursive(mid + 1, end)\n        return shortest_valid_program(start, mid) + left + shortest_valid_program(mid + 1, end)\n\n    return shortest_valid_program_recursive(0, len(board) * len(board[0]))"
    },
    {
        "number": 2723,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate(formula: str) -> int:\n        def parse_complex(formula: str) -> str:\n            if formula.startswith(\"SQRT\"):\n                return \"sqrt(\" + parse_simple(formula[4:]) + \")\"\n            elif formula.startswith(\"FRACTION\"):\n                return \"frac(\" + parse_simple(formula[8:]) + \")\"\n            else:\n                return parse_simple(formula)\n\n        def parse_simple(formula: str) -> str:\n            if formula.startswith(\"TERM\"):\n                return parse_term(formula[4:])\n            else:\n                return formula\n\n        def parse_term(formula: str) -> str:\n            if formula.startswith(\"INTEGER\"):\n                return formula[7:]\n            else:\n                return parse_term(formula[4:]) + parse_term(formula[2:])\n\n        formula = parse_complex(formula)\n        return eval(formula)\n\n    def preprocess_formula(formula: str) -> str:\n        def replace_bar(formula: str) -> str:\n            return formula.replace(\"/\", \"_\")\n\n        def replace_fraction(formula: str) -> str:\n            return formula.replace(\"=\", \"\")\n\n        def replace_spaces(formula: str) -> str:\n            return formula.replace(\" \", \"\")\n\n        def replace_integer(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"\")\n\n        def replace_plus_minus(formula: str) -> str:\n            return formula.replace(\"+\", \"-\").replace(\"-\", \"+\")\n\n        def replace_asterisk(formula: str) -> str:\n            return formula.replace(\"*\", \" * \")\n\n        def replace_sqrt(formula: str) -> str:\n            return formula.replace(\"/\", \" * \")\n\n        def replace_complex(formula: str) -> str:\n            return formula.replace(\"SQRT\", \"sqrt\").replace(\"FRACTION\", \"frac\")\n\n        def replace_simple(formula: str) -> str:\n            return formula.replace(\"TERM\", \"parse_term\")\n\n        def replace_term(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_asterisk(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_sqrt(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_fraction(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_complex(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_simple(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_term(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_term(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_simple(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_complex(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_term_complex(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_simple_complex(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_complex_term(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_simple_term(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_complex_simple(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_simple_complex(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_complex_term_simple(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus_simple_term_complex(formula: str) -> str:\n            return formula.replace(\"INTEGER\", \"parse_integer\")\n\n        def replace_integer_plus_minus"
    },
    {
        "number": 2724,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, students, tutors = map(int, stdin.split())\n    students = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    tutors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    students.sort(key=lambda x: (x[0] - x[1], x[0] + x[1]))\n    tutors.sort(key=lambda x: (x[0] - x[1], x[0] + x[1]))\n\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(students[i][0] - tutors[j][0]) + abs(students[i][1] - tutors[j][1])\n            min_distance = min(min_distance, distance)\n\n    return str(min_distance)"
    },
    {
        "number": 2725,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    weights = list(map(int, stdin.split()[1:]))\n\n    def multiset(s: set) -> int:\n        return sum(s)\n\n    def knapsack(items: list, capacity: int) -> int:\n        n = len(items)\n        memo = [[0] * (capacity + 1) for _ in range(n + 1)]\n\n        for i in range(1, n + 1):\n            for w in range(1, capacity + 1):\n                if items[i - 1] <= w:\n                    memo[i][w] = max(memo[i - 1][w], memo[i - 1][w - items[i - 1]] + items[i - 1])\n                else:\n                    memo[i][w] = memo[i - 1][w]\n\n        return memo[n][capacity]\n\n    def reconstruct(items: list, memo: list) -> list:\n        n = len(items)\n        result = []\n\n        for i in range(n, 0, -1):\n            if memo[i] == memo[i - 1]:\n                result.append(items[i - 1])\n            else:\n                result.append(items[i - 1] - memo[i - 1])\n\n        return result\n\n    items = []\n    memo = []\n\n    for i in range(1, 1 << n):\n        items.append(i)\n        memo.append(0)\n\n    items.sort(reverse=True)\n    memo.sort(reverse=True)\n\n    for i in range(n):\n        memo[i] = knapsack(items[:i + 1], weights[i])\n\n    if knapsack(items, weights[-1]) == memo[-1]:\n        return \" \".join(map(str, reconstruct(items, memo)))\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 2726,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    deck = list(map(int, stdin.split()))\n    deck.sort()\n    score = 0\n    for i in range(c):\n        if deck[i] > score:\n            score = deck[i]\n    return str(score)"
    },
    {
        "number": 2727,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    g = list(map(int, stdin.split()))\n    MOD = 10**9 + 7\n\n    def greedy_increasing_subsequence(A: list) -> int:\n        gis = [A[0]]\n        for i in range(1, len(A)):\n            gis.append(A[i] if A[i] > gis[-1] else gis[-1])\n        return len(set(gis))\n\n    def count_permutations(A: list) -> int:\n        return (1 << len(A)) * greedy_increasing_subsequence(A)\n\n    return str(count_permutations(list(range(1, n + 1)))) % MOD"
    },
    {
        "number": 2728,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    class_sizes = list(map(int, stdin.split()[1:]))\n\n    # Sort the class sizes in increasing order\n    class_sizes.sort()\n\n    # Check if it is possible to load the students onto three identical buses\n    for i in range(n):\n        for j in range(i+1, n):\n            if class_sizes[i] + class_sizes[j] <= 3 * class_sizes[n-1]:\n                return f\"{i+1} {j+1}\"\n\n    return \"-1\""
    },
    {
        "number": 2729,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if M in [10**K for K in range(1, 10)]:\n        quotient = N // M\n        decimal = N % M\n        if decimal == 0:\n            return str(quotient)\n        else:\n            return f\"{quotient}.{decimal}\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 2730,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    odds = 1\n    for i in range(1, N + 1):\n        odds *= (K / i)\n    return f\"{odds:.6f}\""
    },
    {
        "number": 2731,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_array = stdin.strip()\n    output_array = []\n    stack = []\n    current_line = []\n\n    for char in input_array:\n        if char == '{':\n            stack.append(current_line)\n            current_line = []\n        elif char == '}':\n            output_array.append(current_line)\n            output_array.extend(stack)\n            break\n        elif char == ',':\n            output_array.append(current_line)\n            output_array.extend(stack)\n            current_line = []\n        else:\n            current_line.append(char)\n\n    output_array.append(current_line)\n    output_array.extend(stack)\n\n    return '\\n'.join([''* 2 * (i + 1) + ''.join(line) for i, line in enumerate(output_array)])"
    },
    {
        "number": 2732,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W = float(stdin)\n    if W == 0:\n        return \"1\"\n    else:\n        def distance(x1: float, y1: float, x2: float, y2: float) -> float:\n            return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n        def angle(x1: float, y1: float, x2: float, y2: float) -> float:\n            return (x2 - x1) * (y2 + y1) - (y2 - y1) * (x2 + x1)\n\n        def euclidean_distance(x1: float, y1: float, x2: float, y2: float) -> float:\n            return distance(x1, y1, x2, y2) + distance(x2, y2, x1, y1)\n\n        def euclidean_distance_agneta_beatas(x1: float, y1: float, x2: float, y2: float) -> float:\n            return euclidean_distance(x1, y1, x2, y2) + distance(x1, y1, x2, y2)\n\n        def euclidean_distance_agneta_beatas_with_ball(x1: float, y1: float, x2: float, y2: float) -> float:\n            ball_x = (x1 + x2) / 2\n            ball_y = (y1 + y2) / 2\n            return euclidean_distance(x1, y1, ball_x, ball_y) + distance(x1, y1, ball_x, ball_y)\n\n        def euclidean_distance_agneta_beatas_with_ball_and_wait(x1: float, y1: float, x2: float, y2: float) -> float:\n            ball_x = (x1 + x2) / 2\n            ball_y = (y1 + y2) / 2\n            return euclidean_distance(x1, y1, ball_x, ball_y) + distance(x1, y1, ball_x, ball_y) + distance(x1, y1, x2, y2)\n\n        def euclidean_distance_agneta_beatas_with_ball_and_wait_and_chocolate(x1: float, y1: float, x2: float, y2: float) -> float:\n            ball_x = (x1 + x2) / 2\n            ball_y = (y1 + y2) / 2\n            return euclidean_distance(x1, y1, ball_x, ball_y) + distance(x1, y1, ball_x, ball_y) + distance(x1, y1, x2, y2) + distance(x1, y1, ball_x, ball_y)\n\n        def euclidean_distance_agneta_beatas_with_ball_and_wait_and_chocolate_and_slide(x1: float, y1: float, x2: float, y2: float) -> float:\n            ball_x = (x1 + x2) / 2\n            ball_y = (y1 + y2) / 2\n            return euclidean_distance(x1, y1, ball_x, ball_y) + distance(x1, y1, ball_x, ball_y) + distance(x1, y1, x2, y2) + distance(x1, y1, ball_x, ball_y) + distance(x1, y1, x2, y2)\n\n        def euclidean_distance_agneta_beatas_with_ball_and_wait_and_chocolate_and_slide_and_slide_length(x1: float, y1: float, x2: float, y2: float) -> float:\n            ball_x = (x1 + x2) / 2\n            ball_y = (y1 + y2) / 2\n            return euclidean_distance(x1, y1, ball_x, ball_y) + distance(x1, y1, ball_x, ball_y) + distance(x1, y1, x2, y2) + distance(x1, y1, ball_x, ball_y) + distance(x1, y1, x2, y2) + distance(x1, y1, x2, y2)\n\n        def euclidean_distance_ag"
    },
    {
        "number": 2733,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    droplets = []\n    for _ in range(n):\n        x, y, vx, vy, r = map(float, stdin.split()[1:])\n        droplets.append((x, y, vx, vy, r))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def area_weighted_average(droplets, area_sum, area_count):\n        total_area = area_sum / area_count\n        total_weight = 0\n        for droplet in droplets:\n            weight = droplet[3] ** 2 + droplet[4] ** 2\n            total_weight += weight\n        total_weight = total_weight / area_count\n        weighted_sum = 0\n        for droplet in droplets:\n            weight = droplet[3] ** 2 + droplet[4] ** 2\n            weighted_sum += weight * droplet[0]\n        weighted_sum = weighted_sum / total_weight\n        return weighted_sum\n\n    def agglomerate(droplets, t):\n        agglomerated_droplets = []\n        for i in range(len(droplets)):\n            for j in range(i + 1, len(droplets)):\n                if distance(droplets[i], droplets[j]) < 0.001:\n                    area_sum = droplets[i][3] ** 2 + droplets[i][4] ** 2 + droplets[j][3] ** 2 + droplets[j][4] ** 2\n                    area_count = 2\n                    agglomerated_droplets.append((area_weighted_average(droplets, area_sum, area_count), t))\n        return agglomerated_droplets\n\n    def simulate(droplets, t):\n        agglomerations = []\n        for i in range(t + 1):\n            if i == 0:\n                agglomerations = agglomerate(droplets, i)\n            else:\n                agglomerations = agglomerate(agglomerations, i)\n        return agglomerations\n\n    agglomerations = simulate(droplets, 1000000000)\n    if agglomerations:\n        k = len(agglomerations)\n        t = agglomerations[0][1]\n    else:\n        k = n\n        t = 0\n\n    return f\"{k} {t:.3f}\""
    },
    {
        "number": 2734,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return str(2 ** k)\n\n    def is_power_of_two(num: int) -> bool:\n        return num!= 0 and (num & (num - 1)) == 0\n\n    def next_power_of_two(num: int) -> int:\n        return 1 << (num.bit_length() + 1)\n\n    def is_valid_integer(num: int) -> bool:\n        return is_power_of_two(num) and num > n\n\n    def is_valid_sum(num: int) -> bool:\n        return sum(1 for _ in range(k) if is_power_of_two(num)) == k\n\n    def find_next_integer(num: int) -> int:\n        while True:\n            next_num = next_power_of_two(num)\n            if is_valid_integer(next_num) and is_valid_sum(next_num):\n                return next_num\n\n    return str(find_next_integer(n))"
    },
    {
        "number": 2735,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    starting_sequence = list(stdin[0])\n    target_sequence = list(stdin[1])\n\n    def rotate_icons(icons: list, x: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        else:\n            return rotate_icons(icons[x - 1:x + 2] + icons[:x - 1] + icons[x + 1:], x)\n\n    def click_icon(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate_and_move(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate_and_move_and_move(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate_and_move_and_move_and_move(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate_and_move_and_move_and_move_and_move(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate_and_move_and_move_and_move_and_move_and_move(icons: list, x: int, y: int) -> list:\n        if x == 1 or x == 8:\n            return icons\n        elif x == 9:\n            return rotate_icons(icons, 1)\n        elif x % 2 == 0:\n            return rotate_icons(icons, (x + 1) // 2)\n        else:\n            return rotate_icons(icons, (x + 9) // 2)\n\n    def click_icons_and_rotate_and_move_and_move_and_move_and"
    },
    {
        "number": 2736,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    heights = [list(map(int, input().split())) for _ in range(y)]\n\n    def can_collect_water(cell: tuple, heights: list) -> bool:\n        for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            neighbor = (cell[0] + direction[0], cell[1] + direction[1])\n            if 0 <= neighbor[0] < y and 0 <= neighbor[1] < x and heights[neighbor[0]][neighbor[1]] <= heights[cell[0]][cell[1]]:\n                return True\n        return False\n\n    def count_rice_land(heights: list) -> int:\n        rice_land = 0\n        for i in range(y):\n            for j in range(x):\n                if heights[i][j] <= heights[i][j + 1] and heights[i][j] <= heights[i + 1][j] and can_collect_water((i, j), heights):\n                    rice_land += 1\n        return rice_land\n\n    return str(count_rice_land(heights))"
    },
    {
        "number": 2737,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    roads = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        roads.append((u, v, w))\n\n    shelters = []\n    for _ in range(s):\n        shelter, capacity = map(int, stdin.split())\n        shelters.append((shelter, capacity))\n\n    def bellman_ford(graph, start):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        for _ in range(len(graph) - 1):\n            for u in range(len(graph)):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n        return dist\n\n    def dijkstra(graph, start):\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        prev = [None] * len(graph)\n        for _ in range(len(graph) - 1):\n            for u in range(len(graph)):\n                for v, w in graph[u]:\n                    if dist[u]!= float('inf') and dist[u] + w < dist[v]:\n                        dist[v] = dist[u] + w\n                        prev[v] = u\n        return dist, prev\n\n    def assign_shelters(graph, shelters, p):\n        shelter_capacities = [s[1] for s in shelters]\n        shelter_graph = [[] for _ in range(len(shelters))]\n        for u, v, w in roads:\n            shelter_graph[u - 1].append((v - 1, w))\n            shelter_graph[v - 1].append((u - 1, w))\n\n        shelter_dist = bellman_ford(shelter_graph, 0)\n        shelter_prev = dijkstra(shelter_graph, 0)[1]\n\n        def assign_shelter(p, shelter_capacities, shelter_dist, shelter_prev):\n            shelter_assignment = [0] * len(shelters)\n            shelter_assignment[0] = 1\n            for i in range(1, len(shelters)):\n                min_dist = float('inf')\n                min_shelter = -1\n                for j in range(len(shelters)):\n                    if shelter_assignment[j] == 0 and shelter_dist[j] < min_dist:\n                        min_dist = shelter_dist[j]\n                        min_shelter = j\n                if min_shelter == -1:\n                    return None\n                shelter_assignment[min_shelter] = 1\n            return shelter_assignment\n\n        shelter_assignment = assign_shelter(p, shelter_capacities, shelter_dist, shelter_prev)\n        if shelter_assignment is None:\n            return None\n\n        shelter_assignment = [shelters[i][0] for i in shelter_assignment]\n        shelter_assignment = [shelter_assignment.index(shelter) + 1 for shelter in shelter_assignment]\n\n        return shelter_assignment\n\n    shelter_assignment = assign_shelters(shelter_graph, shelters, p)\n    if shelter_assignment is None:\n        return \"IMPOSSIBLE\"\n\n    return str(min(shelter_assignment))"
    },
    {
        "number": 2738,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    gears = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.split()[1:])\n        gears.append((x, y, r))\n    source_gear = gears[0]\n    target_gear = gears[-1]\n\n    if source_gear[0] == target_gear[0] and source_gear[1] == target_gear[1]:\n        return \"0\"\n\n    if source_gear[0] == target_gear[0] and source_gear[1]!= target_gear[1]:\n        return \"1\"\n\n    if source_gear[0]!= target_gear[0] and source_gear[1] == target_gear[1]:\n        return \"2 1\"\n\n    if source_gear[0]!= target_gear[0] and source_gear[1]!= target_gear[1]:\n        return \"2 -1\"\n\n    return \"1\""
    },
    {
        "number": 2739,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *bacteria = map(int, stdin.split())\n    MOD = 10**9 + 7\n    bacteria = [0] + bacteria\n    bacteria_left = [0] * (n + 1)\n    bacteria_left[1] = bacteria[0]\n    for i in range(1, n + 1):\n        bacteria_left[i + 1] = (bacteria_left[i] + bacteria[i]) % MOD\n    return str(bacteria_left[-1])"
    },
    {
        "number": 2740,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, h = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, h + 1):\n            if i * w <= j <= (i + 1) * w:\n                count += 1\n    return str(count % MOD)"
    },
    {
        "number": 2741,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    hex_num = \"\"\n    while num > 0:\n        remainder = num % 16\n        if remainder < 10:\n            hex_num = chr(ord('A') + remainder) + hex_num\n        else:\n            hex_num = chr(ord('A') + remainder - 10) + hex_num\n        num //= 16\n    return hex_num"
    },
    {
        "number": 2742,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 10, 100, 1000]\n    coins.sort(reverse=True)\n    total_coins = 0\n    for coin in coins:\n        total_coins += n // coin\n        n %= coin\n    return str(total_coins)"
    },
    {
        "number": 2743,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n\n    def find_center_of_mass(structure):\n        x, y = 0, 0\n        for i in range(len(structure)):\n            for j in range(len(structure[i])):\n                if structure[i][j] == '#':\n                    x += i\n                    y += j\n        return x // len(structure), y // len(structure)\n\n    def is_balanced(structure):\n        x_min, x_max = min(find_center_of_mass(structure)[0], find_center_of_mass(structure)[0]), max(find_center_of_mass(structure)[0], find_center_of_mass(structure)[0])\n        y_min, y_max = min(find_center_of_mass(structure)[1], find_center_of_mass(structure)[1]), max(find_center_of_mass(structure)[1], find_center_of_mass(structure)[1])\n        return x_min == x_max or y_min == y_max\n\n    def is_falling_to_left(structure):\n        x_min, x_max = min(find_center_of_mass(structure)[0], find_center_of_mass(structure)[0]), max(find_center_of_mass(structure)[0], find_center_of_mass(structure)[0])\n        y_min, y_max = min(find_center_of_mass(structure)[1], find_center_of_mass(structure)[1]), max(find_center_of_mass(structure)[1], find_center_of_mass(structure)[1])\n        return x_min < x_max and y_min == y_max\n\n    def is_falling_to_right(structure):\n        x_min, x_max = min(find_center_of_mass(structure)[0], find_center_of_mass(structure)[0]), max(find_center_of_mass(structure)[0], find_center_of_mass(structure)[0])\n        y_min, y_max = min(find_center_of_mass(structure)[1], find_center_of_mass(structure)[1]), max(find_center_of_mass(structure)[1], find_center_of_mass(structure)[1])\n        return x_max > x_min and y_min == y_max\n\n    def find_structure(x, y):\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == '.' or grid[i][j] == '#':\n                    continue\n                if x >= i and x < i + 1 and y >= j and y < j + 1:\n                    return i, j\n        return None\n\n    def find_structures(x, y):\n        structures = []\n        for i in range(len(grid)):\n            for j in range(len(grid[i])):\n                if grid[i][j] == '.' or grid[i][j] == '#':\n                    continue\n                if x >= i and x < i + 1 and y >= j and y < j + 1:\n                    structures.append((i, j))\n        return structures\n\n    def find_connected_components(structures):\n        components = []\n        for structure in structures:\n            component = []\n            for i in range(structure[0] - 1, structure[0] + 2):\n                for j in range(structure[1] - 1, structure[1] + 2):\n                    if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]):\n                        if grid[i][j] == '.' or grid[i][j] == '#':\n                            continue\n                        component.append((i, j))\n            components.append(component)\n        return components\n\n    def find_connected_components_with_center_of_mass(structures):\n        components = []\n        for structure in structures:\n            component = []\n            for i in range(structure[0] - 1, structure[0] + 2):\n                for j in range(structure[1] - 1, structure[1] + 2):\n                    if i >= 0 and i < len(grid) and j >= 0 and j < len(grid[0]):\n                        if grid[i][j] == '.' or grid[i][j] == '#':\n                            continue\n                        x, y = find_center_of_mass(grid[i][j"
    },
    {
        "number": 2744,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    routes = [tuple(map(int, stdin.split())) for _ in range(m)]\n    a = list(map(int, stdin.split()))\n\n    def min_coins(city: int) -> int:\n        min_coins_to_city = float('inf')\n        for i, (v, u, w) in enumerate(routes):\n            if v == city:\n                min_coins_to_city = min(min_coins_to_city, min_coins(u) + w)\n            elif u == city:\n                min_coins_to_city = min(min_coins_to_city, min_coins(v) + w)\n        return min_coins_to_city\n\n    min_coins_to_berland = min_coins(1)\n    min_coins_to_berland_visited = [0] * n\n    min_coins_to_berland_visited[1] = 1\n\n    for i in range(2, n + 1):\n        min_coins_to_city = min_coins(i)\n        min_coins_to_berland = min(min_coins_to_berland, min_coins_to_city + a[i - 1])\n        min_coins_to_berland_visited[i] = 1\n\n    return''.join(map(str, min_coins_to_berland_visited))\n"
    },
    {
        "number": 2745,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    words = stdin.split()\n    result = []\n    for i in range(len(s) - len(words[0]) + 1):\n        word_found = True\n        for j in range(len(words)):\n            if s[i + j]!= words[j]:\n                word_found = False\n                break\n        if word_found:\n            result.append(i)\n    return str(result)"
    },
    {
        "number": 2746,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    version1, version2 = stdin.split()\n    version1 = [int(x) for x in version1.split('.')]\n    version2 = [int(x) for x in version2.split('.')]\n\n    for i in range(max(len(version1), len(version2))):\n        if i >= len(version1):\n            return '1'\n        if i >= len(version2):\n            return '-1'\n        if version1[i] > version2[i]:\n            return '1'\n        if version1[i] < version2[i]:\n            return '-1'\n\n    return '0'"
    },
    {
        "number": 2747,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    target = int(stdin.split()[1])\n\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if nums[mid] == target:\n            left = mid\n            right = mid\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    if left == len(nums) or nums[left]!= target:\n        return [-1, -1]\n\n    return [left, left]"
    },
    {
        "number": 2748,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mapping = {\n        '2': 'abc',\n        '3': 'def',\n        '4': 'ghi',\n        '5': 'jkl',\n        '6':'mno',\n        '7': 'pqrs',\n        '8': 'tuv',\n        '9': 'wxyz'\n    }\n\n    def backtrack(start: int, path: str, result: list) -> None:\n        if start == len(stdin):\n            result.append(path)\n            return\n\n        for i in range(start, len(stdin)):\n            digit = stdin[start]\n            letters = mapping[digit]\n            for letter in letters:\n                backtrack(start + 1, path + letter, result)\n\n    result = []\n    backtrack(0, '', result)\n    return result"
    },
    {
        "number": 2749,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    n = int(stdin.split()[1])\n    a = list(map(int, stdin.split()[2:]))\n\n    def dfs(i, color, visited):\n        if i == n:\n            return True\n\n        for j in range(w):\n            if (i, j) in visited:\n                continue\n\n            visited.add((i, j))\n            if color == a[i - 1]:\n                if dfs(i + 1, color, visited):\n                    return True\n            elif color == a[i - 1] + 1:\n                if dfs(i + 1, color, visited):\n                    return True\n            elif color == a[i - 1] - 1:\n                if dfs(i + 1, color, visited):\n                    return True\n\n            visited.remove((i, j))\n\n        return False\n\n    visited = set()\n    for i in range(1, n + 1):\n        if dfs(i, a[i - 1], visited):\n            return \" \".join(map(str, a))\n\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 2750,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def find_median(arr):\n        arr.sort()\n        return arr[len(arr) // 2]\n\n    def is_odd_length(arr):\n        return len(arr) % 2 == 1\n\n    def subsequences(arr, start, end):\n        if start > end:\n            return [[]]\n\n        result = []\n        for i in range(start, end + 1):\n            result.extend(subsequences(arr, start, i - 1) + subsequences(arr, i + 1, end))\n\n        return result\n\n    def count_subsequences(arr, b):\n        subsequences_count = 0\n        for subsequence in subsequences(arr, 0, len(arr) - 1):\n            if find_median(subsequence) == b:\n                subsequences_count += 1\n        return subsequences_count\n\n    return str(count_subsequences(a, b))\n"
    },
    {
        "number": 2751,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    sequence = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    max_score = 0\n    min_operations = float('inf')\n\n    for i in range(len(sequence)):\n        for j in range(i + 1, len(sequence)):\n            for x in sequence:\n                if x % sequence[i] == 0:\n                    a, b = sequence[i], sequence[j]\n                    score = gcd(a, x) * b\n                    if score > max_score:\n                        max_score = score\n                        min_operations = 1\n                    elif score == max_score:\n                        min_operations += 1\n\n    return f\"{max_score} {min_operations}\""
    },
    {
        "number": 2752,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    buildings = list(map(int, stdin.split()))\n    weathers = [list(map(str, stdin.split())) for _ in range(n)]\n\n    happiness = 0\n    for i in range(n):\n        if weathers[i][0] == 'S' and weathers[i][1] == 'S' and weathers[i][2] == 'S':\n            happiness += 1\n        elif weathers[i][0] == 'R' and weathers[i][1] == 'R' and weathers[i][2] == 'R':\n            happiness += 1\n        elif weathers[i][0] == 'S' and weathers[i][1] == 'R' and weathers[i][2] == 'R':\n            happiness += 1\n        elif weathers[i][0] == 'R' and weathers[i][1] == 'S' and weathers[i][2] == 'R':\n            happiness += 1\n        elif weathers[i][0] == 'S' and weathers[i][1] == 'S' and weathers[i][2] == 'R':\n            happiness += 1\n        elif weathers[i][0] == 'R' and weathers[i][1] == 'R' and weathers[i][2] == 'S':\n            happiness += 1\n        elif weathers[i][0] == 'S' and weathers[i][1] == 'R' and weathers[i][2] == 'S':\n            happiness += 1\n        elif weathers[i][0] == 'R' and weathers[i][1] == 'S' and weathers[i][2] == 'S':\n            happiness += 1\n        elif weathers[i][0] == 'S' and weathers[i][1] == 'S' and weathers[i][2] == 'S':\n            happiness += 1\n\n    return str(happiness)"
    },
    {
        "number": 2753,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_same_minute(t1: str, t2: str) -> bool:\n        h1, m1 = map(int, t1.split(\":\"))\n        h2, m2 = map(int, t2.split(\":\"))\n        return h1 == h2 and m1 == m2\n\n    def get_weekday(timestamp: str) -> str:\n        day, hour, minute = map(int, timestamp.split(\":\"))\n        days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n        return days[day % 7]\n\n    def get_next_same_minute(timestamp: str) -> str:\n        day, hour, minute = map(int, timestamp.split(\":\"))\n        if minute == 59:\n            minute = 0\n            hour += 1\n        else:\n            minute += 5\n        return f\"{hour:02}:{minute:02}\"\n\n    def get_next_flash_time(timestamp: str, flash_interval: int) -> str:\n        day, hour, minute = map(int, timestamp.split(\":\"))\n        if minute % flash_interval == 0:\n            return f\"{hour:02}:{minute:02}\"\n        else:\n            return get_next_flash_time(timestamp, flash_interval)\n\n    def get_flash_intervals(timestamp1: str, timestamp2: str) -> int:\n        h1, m1 = map(int, timestamp1.split(\":\"))\n        h2, m2 = map(int, timestamp2.split(\":\"))\n        return (h2 - h1) * 60 + (m2 - m1)\n\n    def get_flash_interval(timestamp1: str, timestamp2: str) -> int:\n        intervals = get_flash_intervals(timestamp1, timestamp2)\n        if intervals % 5 == 0:\n            return 5\n        else:\n            return intervals\n\n    def get_first_same_minute(timestamp1: str, timestamp2: str) -> str:\n        flash_interval = get_flash_interval(timestamp1, timestamp2)\n        next_flash_time = get_next_flash_time(timestamp1, flash_interval)\n        return get_next_same_minute(next_flash_time)\n\n    def get_weekday_of_first_same_minute(timestamp1: str, timestamp2: str) -> str:\n        first_same_minute = get_first_same_minute(timestamp1, timestamp2)\n        return get_weekday(first_same_minute)\n\n    timestamp1, timestamp2, flash_interval1, flash_interval2 = map(str.strip, stdin.split(\"\\n\"))\n\n    if is_same_minute(timestamp1, timestamp2):\n        return \"Never\"\n    else:\n        first_same_minute = get_first_same_minute(timestamp1, timestamp2)\n        weekday = get_weekday_of_first_same_minute(timestamp1, timestamp2)\n        return f\"{weekday}\\n{first_same_minute}\""
    },
    {
        "number": 2754,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y_low, y_high = map(int, stdin.split())\n\n    def f(x):\n        return 10 * math.sqrt(x)\n\n    def g(x):\n        return f(f(x))\n\n    def h(x):\n        return f(g(x))\n\n    def i(x):\n        return f(h(x))\n\n    def j(x):\n        return f(i(x))\n\n    def k(x):\n        return f(j(x))\n\n    def l(x):\n        return f(k(x))\n\n    def m(x):\n        return f(l(x))\n\n    def n(x):\n        return f(m(x))\n\n    def o(x):\n        return f(n(x))\n\n    def p(x):\n        return f(o(x))\n\n    def q(x):\n        return f(p(x))\n\n    def r(x):\n        return f(q(x))\n\n    def s(x):\n        return f(r(x))\n\n    def t(x):\n        return f(s(x))\n\n    def u(x):\n        return f(t(x))\n\n    def v(x):\n        return f(u(x))\n\n    def w(x):\n        return f(v(x))\n\n    def x(x):\n        return f(w(x))\n\n    def y(x):\n        return math.ceil(f(x))\n\n    def z(x):\n        return math.ceil(g(x))\n\n    def aa(x):\n        return math.ceil(h(x))\n\n    def ab(x):\n        return math.ceil(i(x))\n\n    def ac(x):\n        return math.ceil(j(x))\n\n    def ad(x):\n        return math.ceil(k(x))\n\n    def ae(x):\n        return math.ceil(l(x))\n\n    def af(x):\n        return math.ceil(m(x))\n\n    def ag(x):\n        return math.ceil(n(x))\n\n    def ah(x):\n        return math.ceil(o(x))\n\n    def ai(x):\n        return math.ceil(p(x))\n\n    def aj(x):\n        return math.ceil(q(x))\n\n    def ak(x):\n        return math.ceil(r(x))\n\n    def al(x):\n        return math.ceil(s(x))\n\n    def am(x):\n        return math.ceil(t(x))\n\n    def an(x):\n        return math.ceil(u(x))\n\n    def ao(x):\n        return math.ceil(v(x))\n\n    def ap(x):\n        return math.ceil(w(x))\n\n    def aq(x):\n        return math.ceil(x(x))\n\n    def ar(x):\n        return math.ceil(y(x))\n\n    def as_(x):\n        return math.ceil(z(x))\n\n    def at(x):\n        return math.ceil(aa(x))\n\n    def au(x):\n        return math.ceil(ab(x))\n\n    def av(x):\n        return math.ceil(ac(x))\n\n    def aw(x):\n        return math.ceil(ad(x))\n\n    def ax(x):\n        return math.ceil(ae(x))\n\n    def ay(x):\n        return math.ceil(af(x))\n\n    def az(x):\n        return math.ceil(ag(x))\n\n    def ba(x):\n        return math.ceil(ah(x))\n\n    def bb(x):\n        return math.ceil(ai(x))\n\n    def bc(x):\n        return math.ceil(aj(x))\n\n    def bd(x):\n        return math.ceil(ak(x))\n\n    def be(x):\n        return math.ceil(al(x))\n\n    def bf(x):\n        return math.ceil(am(x))\n\n    def bg(x):\n        return math.ceil(an(x))\n\n    def bh(x):\n        return math.ceil(ao(x))\n\n    def bi(x):\n        return math.ceil(ap(x))\n\n    def bj(x):\n        return math.ceil(aq(x))\n\n    def bk(x):\n        return math.ceil(ar(x))\n\n    def bl(x):\n        return math.ceil(as_(x))\n\n    def bm(x):\n        return math.ceil(at(x))\n\n    def bn(x):\n        return math.ceil(au(x))\n\n    def bo(x):\n        return math.ceil(av(x))\n\n    def bp(x):\n        return math.ceil(aw(x))\n\n    def bq(x):\n        return math.ceil(ax(x))\n\n    def br(x):\n        return math.ceil("
    },
    {
        "number": 2755,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    trees, paths = map(int, stdin.split())\n    paths = set(tuple(map(int, line.split())) for line in stdin.splitlines()[1:])\n    hives = set()\n    visited = set()\n\n    def dfs(tree: int, path: tuple) -> None:\n        if tree in visited:\n            return\n        visited.add(tree)\n        hives.add(tree)\n        for neighbor, new_path in paths:\n            if neighbor == tree:\n                continue\n            if new_path == path:\n                dfs(neighbor, new_path)\n\n    for tree in range(trees):\n        dfs(tree, (tree,))\n\n    if len(hives) < 2:\n        return \"impossible\"\n    return str(len(hives))\n"
    },
    {
        "number": 2756,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split())\n    dungeon = [list(row) for row in stdin.splitlines()]\n    player_pos = dungeon.index(['P', '.', '.'])\n    creeper_pos = dungeon.index(['C', '.', '.'])\n    exit_pos = dungeon.index(['E', '.', '.'])\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < n and 0 <= y < m and dungeon[x][y]!= 'X'\n\n    def is_obstacle(x: int, y: int) -> bool:\n        return dungeon[x][y] == 'X'\n\n    def is_player_near_creeper(x: int, y: int) -> bool:\n        dx, dy = x - creeper_pos[0], y - creeper_pos[1]\n        return abs(dx) <= e and abs(dy) <= e\n\n    def is_creeper_near_player(x: int, y: int) -> bool:\n        dx, dy = creeper_pos[0] - x, creeper_pos[1] - y\n        return abs(dx) <= e and abs(dy) <= e\n\n    def get_move(x: int, y: int) -> str:\n        if is_valid(x, y + 1) and not is_obstacle(x, y + 1) and not is_player_near_creeper(x, y + 1):\n            return 'N'\n        if is_valid(x, y - 1) and not is_obstacle(x, y - 1) and not is_player_near_creeper(x, y - 1):\n            return 'S'\n        if is_valid(x + 1, y) and not is_obstacle(x + 1, y) and not is_player_near_creeper(x + 1, y):\n            return 'E'\n        if is_valid(x - 1, y) and not is_obstacle(x - 1, y) and not is_player_near_creeper(x - 1, y):\n            return 'W'\n        if is_valid(x, y) and not is_obstacle(x, y) and not is_creeper_near_player(x, y):\n            return 'S'\n        if is_valid(x, y) and not is_obstacle(x, y) and not is_creeper_near_player(x, y):\n            return 'N'\n        if is_valid(x, y) and not is_obstacle(x, y) and not is_creeper_near_player(x, y):\n            return 'E'\n        if is_valid(x, y) and not is_obstacle(x, y) and not is_creeper_near_player(x, y):\n            return 'W'\n        return '.'\n\n    moves = []\n    x, y = player_pos\n    while x!= exit_pos[0] or y!= exit_pos[1]:\n        moves.append(get_move(x, y))\n        if moves[-1] == 'C':\n            x, y = creeper_pos\n        else:\n            x, y = player_pos\n\n    if moves[-1] == 'C':\n        return 'you\\'re toast'\n    else:\n        return ''.join(moves)"
    },
    {
        "number": 2757,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    values = list(map(int, stdin.split()[1:]))\n\n    def bdd_to_int(bdd: str) -> int:\n        def dfs(node: str, index: int) -> int:\n            if node == '0':\n                return 0\n            elif node == '1':\n                return 1\n            else:\n                return 2 * dfs(node[0], index) + int(node[1])\n\n        return dfs(bdd, 0)\n\n    def int_to_bdd(num: int) -> str:\n        def dfs(num: int, index: int) -> str:\n            if num == 0:\n                return '0'\n            elif num == 1:\n                return '1'\n            else:\n                return str(num % 2) + dfs(num // 2, index + 1)\n\n        return dfs(num, 0)\n\n    def bdd_to_minimal_bdd(bdd: str) -> str:\n        def dfs(node: str, index: int) -> str:\n            if node == '0':\n                return '0'\n            elif node == '1':\n                return '1'\n            else:\n                return str(index % 2) + dfs(node[0], index // 2)\n\n        return dfs(bdd, 0)\n\n    def int_to_minimal_bdd(num: int) -> str:\n        def dfs(num: int, index: int) -> str:\n            if num == 0:\n                return '0'\n            elif num == 1:\n                return '1'\n            else:\n                return str(index % 2) + dfs(num // 2, index // 2)\n\n        return dfs(num, 0)\n\n    def count_vertices(bdd: str) -> int:\n        def dfs(node: str, index: int) -> int:\n            if node == '0':\n                return 0\n            elif node == '1':\n                return 1\n            else:\n                return 2 * dfs(node[0], index) + int(node[1])\n\n        return dfs(bdd, 0)\n\n    def count_minimal_vertices(values: List[int]) -> int:\n        bdd = int_to_bdd(sum(values))\n        return count_vertices(bdd)\n\n    def bdd_to_minimal_int(bdd: str) -> int:\n        def dfs(node: str, index: int) -> int:\n            if node == '0':\n                return 0\n            elif node == '1':\n                return 1\n            else:\n                return 2 * dfs(node[0], index) + int(node[1])\n\n        return dfs(bdd, 0)\n\n    def minimal_bdd_to_int(minimal_bdd: str) -> int:\n        def dfs(node: str, index: int) -> int:\n            if node == '0':\n                return 0\n            elif node == '1':\n                return 1\n            else:\n                return 2 * dfs(node[0], index) + int(node[1])\n\n        return dfs(minimal_bdd, 0)\n\n    def bdd_to_minimal_values(bdd: str) -> List[int]:\n        def dfs(node: str, index: int) -> List[int]:\n            if node == '0':\n                return []\n            elif node == '1':\n                return [index]\n            else:\n                return dfs(node[0], index) + dfs(node[1], index)\n\n        return dfs(bdd, 0)\n\n    def minimal_bdd_to_values(minimal_bdd: str) -> List[int]:\n        def dfs(node: str, index: int) -> List[int]:\n            if node == '0':\n                return []\n            elif node == '1':\n                return [index]\n            else:\n                return dfs(node[0], index) + dfs(node[1], index)\n\n        return dfs(minimal_bdd, 0)\n\n    def bdd_to_minimal_function(bdd: str) -> Callable[[List[int]], int]:\n        def dfs(node: str, index: int) -> Callable[[List[int]], int]:\n            if node == '0':\n                return lambda x: 0\n            elif node == '1':\n                return lambda x: 1\n            else:\n                return lambda x: 2 * dfs(node[0], index)(x) + int(node[1])\n\n        return dfs(bdd, 0)\n\n    def minimal_bdd_to_function(minimal_bdd: str) -> Callable[[List[int]], int]:\n        def dfs(node: str, index: int) -> Callable[[List[int]], int]:\n            if node == '0':"
    },
    {
        "number": 2758,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    female_color, male_color = stdin.split()\n    female_genes, male_genes = female_color, male_color\n\n    def get_gene_color(gene: str) -> str:\n        if gene == \"B\":\n            return \"Black\"\n        elif gene == \"O\":\n            return \"Red\"\n        elif gene == \"D\":\n            return \"Dilution\"\n        else:\n            raise ValueError(f\"Invalid gene: {gene}\")\n\n    def get_gene_combination(gene1: str, gene2: str) -> str:\n        if gene1 == gene2:\n            return gene1\n        elif gene1 == \"B\" and gene2 == \"D\":\n            return \"Black-Dilution\"\n        elif gene1 == \"B\" and gene2 == \"d\":\n            return \"Black-Dilution\"\n        elif gene1 == \"b\" and gene2 == \"D\":\n            return \"Black-Dilution\"\n        elif gene1 == \"b\" and gene2 == \"d\":\n            return \"Black-Dilution\"\n        elif gene1 == \"B\" and gene2 == \"O\":\n            return \"Black-Red\"\n        elif gene1 == \"B\" and gene2 == \"o\":\n            return \"Black-Red\"\n        elif gene1 == \"b\" and gene2 == \"O\":\n            return \"Black-Red\"\n        elif gene1 == \"b\" and gene2 == \"o\":\n            return \"Black-Red\"\n        elif gene1 == \"b\" and gene2 == \"d\":\n            return \"Black-Dilution\"\n        elif gene1 == \"B\" and gene2 == \"d\":\n            return \"Black-Dilution\"\n        elif gene1 == \"b\" and gene2 == \"d\":\n            return \"Black-Dilution\"\n        elif gene1 == \"b\" and gene2 == \"O\":\n            return \"Black-Red\"\n        elif gene1 == \"b\" and gene2 == \"o\":\n            return \"Black-Red\"\n        elif gene1 == \"B\" and gene2 == \"O\":\n            return \"Black-Red\"\n        elif gene1 == \"B\" and gene2 == \"o\":\n            return \"Black-Red\"\n        elif gene1 == \"b\" and gene2 == \"O\":\n            return \"Black-Red\"\n        elif gene1 == \"b\" and gene2 == \"o\":\n            return \"Black-Red\"\n        elif gene1 == \"D\" and gene2 == \"O\":\n            return \"Dilution-Red\"\n        elif gene1 == \"D\" and gene2 == \"o\":\n            return \"Dilution-Red\"\n        elif gene1 == \"d\" and gene2 == \"O\":\n            return \"Dilution-Red\"\n        elif gene1 == \"d\" and gene2 == \"o\":\n            return \"Dilution-Red\"\n        elif gene1 == \"d\" and gene2 == \"d\":\n            return \"Dilution-Dilution\"\n        elif gene1 == \"D\" and gene2 == \"d\":\n            return \"Dilution-Dilution\"\n        elif gene1 == \"d\" and gene2 == \"d\":\n            return \"Dilution-Dilution\"\n        elif gene1 == \"d\" and gene2 == \"O\":\n            return \"Dilution-Red\"\n        elif gene1 == \"d\" and gene2 == \"o\":\n            return \"Dilution-Red\"\n        elif gene1 == \"D\" and gene2 == \"O\":\n            return \"Dilution-Red\"\n        elif gene1 == \"D\" and gene2 == \"o\":\n            return \"Dilution-Red\"\n        elif gene1 == \"d\" and gene2 == \"O\":\n            return \"Dilution-Red\"\n        elif gene1 == \"d\" and gene2 == \"o\":\n            return \"Dilution-Red\"\n        else:\n            raise ValueError(f\"Invalid gene combination: {gene1}-{gene2}\")\n\n    def get_gene_combinations(genes: str) -> list[str]:\n        combinations = []\n        for i in range(len(genes) - 1):\n            for j in range(i + 1, len(genes)):\n                combinations.append(get_gene_combination(genes[i], genes[j]))\n        return combinations\n\n    def get_gene_probabilities(genes: str) -> list[float]:\n        gene_combinations = get_gene_combinations(genes)\n        probabilities = [1 / len(gene_combinations) for _ in range(len(gene_combinations))]\n        return probabilities\n\n    def get_gene_colors(genes: str) -> list[str]:\n        gene_colors = [get_gene_color(gene) for"
    },
    {
        "number": 2759,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rows = [[] for _ in range(n + 1)]\n    for line in stdin.split()[1:]:\n        row, col = map(int, line.split())\n        rows[row].append(col)\n\n    def dfs(row, col, visited):\n        if row not in visited:\n            visited.add(row)\n        if col not in visited:\n            visited.add(col)\n        if len(visited) == n + 1:\n            return 0\n\n        if row == 1 and col == 1:\n            return 1\n\n        if row == 1:\n            return dfs(row, col - 1, visited) + dfs(row, col + 1, visited)\n        if col == 1:\n            return dfs(row - 1, col, visited) + dfs(row + 1, col, visited)\n        if row == n:\n            return dfs(row, col - 1, visited) + dfs(row, col + 1, visited)\n        if col == n:\n            return dfs(row - 1, col, visited) + dfs(row + 1, col, visited)\n\n        return min(dfs(row - 1, col, visited), dfs(row + 1, col, visited), dfs(row, col - 1, visited), dfs(row, col + 1, visited))\n\n    moves = dfs(1, 1, set())\n    return str(moves)"
    },
    {
        "number": 2760,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    swaps = [0] * N\n\n    for i in range(N):\n        if i % 2 == 0:\n            arr[i], arr[N - 1] = arr[N - 1], arr[i]\n            swaps[i // 2] += 1\n        else:\n            arr[i], arr[0] = arr[0], arr[i]\n            swaps[i // 2] += 1\n\n    return \" \".join(map(str, swaps))"
    },
    {
        "number": 2761,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    lines = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        lines.append((x1, y1, x2, y2))\n    lines.sort(key=lambda x: (x[0], x[1]))\n    lines.sort(key=lambda x: (x[2], x[3]))\n    if lines[0][0] == lines[1][0] == lines[2][0] == lines[0][2]:\n        return \"no triangle\"\n    a, b, c = lines[0][0], lines[0][1], lines[1][2]\n    d, e, f = lines[1][0], lines[1][1], lines[2][2]\n    g, h, i = lines[2][0], lines[2][1], lines[0][2]\n    if a == b == c == d == e == f == g == h == i:\n        return \"no triangle\"\n    s = (a + b + c + d + e + f + g + h + i) / 2\n    area = abs(0.5 * s * (s - a) * (s - b) * (s - c) * (s - d) * (s - e) * (s - f) * (s - g) * (s - h) * (s - i))\n    return str(area)"
    },
    {
        "number": 2762,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, g, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_cost(start: int, end: int) -> int:\n        return sum(abs(a[i] - v) ** k for i, v in enumerate(a[start:end + 1]))\n\n    min_costs = [min_cost(i, i + g - 1) for i in range(n - g + 1)]\n    return str(min(min_costs))\n"
    },
    {
        "number": 2763,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grille = [list(line.strip()) for line in stdin.split()[1:]]\n    message = stdin.split()[2]\n\n    def rotate_grille(grille):\n        return [list(row[::-1]) for row in grille]\n\n    def fill_grid(grille, message):\n        for i in range(n):\n            for j in range(n):\n                if grille[i][j] == '.':\n                    grille[i][j] = message[i * n + j]\n                elif grille[i][j] == 'X':\n                    grille[i][j] = message[i * n + j] if message[i * n + j] in message else '.'\n        return grille\n\n    def is_valid_grille(grille):\n        for row in grille:\n            if len(set(row))!= n:\n                return False\n        return True\n\n    def decrypt_message(grille, message):\n        decrypted_message = ''\n        for i in range(n):\n            for j in range(n):\n                if grille[i][j] == '.':\n                    decrypted_message += '.'\n                elif grille[i][j] == 'X':\n                    decrypted_message += message[i * n + j]\n        return decrypted_message\n\n    if not is_valid_grille(grille):\n        return 'invalid grille'\n\n    grille = fill_grid(grille, message)\n    grille = rotate_grille(grille)\n    grille = fill_grid(grille, message)\n\n    return decrypt_message(grille, message)"
    },
    {
        "number": 2764,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(line.strip()) for line in stdin.split('\\n')]\n    diamond_square = [i for i, row in enumerate(board) for j, square in enumerate(row) if square == 'D']\n    if not diamond_square:\n        return 'Bug!'\n\n    def move_turtle(direction: str, x: int, y: int) -> None:\n        if direction == 'F':\n            if board[y][x] in ['C', 'I']:\n                return\n            board[y][x] = '.'\n        elif direction == 'R':\n            board[y][x] = '.'\n            board[y][x - 1] = '.'\n        elif direction == 'L':\n            board[y][x] = '.'\n            board[y][x + 1] = '.'\n        elif direction == 'X':\n            if board[y][x] == 'C':\n                board[y][x] = '.'\n                if board[y - 1][x] == 'I':\n                    board[y - 1][x] = 'C'\n                elif board[y + 1][x] == 'I':\n                    board[y + 1][x] = 'C'\n                elif board[y][x - 1] == 'I':\n                    board[y][x - 1] = 'C'\n                elif board[y][x + 1] == 'I':\n                    board[y][x + 1] = 'C'\n            else:\n                return\n        else:\n            return\n\n    def fire_laser(x: int, y: int) -> None:\n        if board[y][x] == 'C':\n            return\n        board[y][x] = '.'\n        if board[y - 1][x] == 'I':\n            board[y - 1][x] = 'C'\n        elif board[y + 1][x] == 'I':\n            board[y + 1][x] = 'C'\n        elif board[y][x - 1] == 'I':\n            board[y][x - 1] = 'C'\n        elif board[y][x + 1] == 'I':\n            board[y][x + 1] = 'C'\n        else:\n            return\n\n    program = stdin.split('\\n')[8]\n    for instruction in program:\n        if instruction == 'F':\n            move_turtle('F', diamond_square[0][0], diamond_square[0][1])\n        elif instruction == 'R':\n            move_turtle('R', diamond_square[0][0], diamond_square[0][1])\n        elif instruction == 'L':\n            move_turtle('L', diamond_square[0][0], diamond_square[0][1])\n        elif instruction == 'X':\n            fire_laser(diamond_square[0][0], diamond_square[0][1])\n        else:\n            return 'Bug!'\n\n    if board[diamond_square[0][1]][diamond_square[0][0]] == 'D':\n        return 'Diamond!'\n    else:\n        return 'Bug!'\n"
    },
    {
        "number": 2765,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    coins = list(map(int, stdin.split()[1:]))\n    coins.sort(reverse=True)\n    if coins[0] == 1:\n        return \"canonical\"\n    else:\n        return \"non-canonical\""
    },
    {
        "number": 2766,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    p = round(p, 6)\n\n    def flip_coin(p: float) -> bool:\n        return random() < p\n\n    def game_ends_in_draw(n: int, k: int) -> bool:\n        return n == 1 and k == 1\n\n    def game_ends_in_win(n: int, k: int) -> bool:\n        return n > 1 and k > 1\n\n    def game_ends_in_loss(n: int, k: int) -> bool:\n        return n > 1 and k == 1\n\n    def game_ends_in_tie(n: int, k: int) -> bool:\n        return n == 1 and k > 1\n\n    def game_ends_in_draw_or_win(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k)\n\n    def game_ends_in_draw_or_loss(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_loss(n, k)\n\n    def game_ends_in_draw_or_tie(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_tie(n, k)\n\n    def game_ends_in_draw_or_win_or_loss(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k)\n\n    def game_ends_in_draw_or_win_or_tie(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_tie(n, k)\n\n    def game_ends_in_draw_or_win_or_loss_or_tie(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k) or game_ends_in_tie(n, k)\n\n    def game_ends_in_draw_or_win_or_loss_or_tie_or_win(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k) or game_ends_in_tie(n, k) or game_ends_in_win(n, k)\n\n    def game_ends_in_draw_or_win_or_loss_or_tie_or_win_or_loss(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k) or game_ends_in_tie(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k)\n\n    def game_ends_in_draw_or_win_or_loss_or_tie_or_win_or_loss_or_tie(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k) or game_ends_in_tie(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k) or game_ends_in_tie(n, k)\n\n    def game_ends_in_draw_or_win_or_loss_or_tie_or_win_or_loss_or_tie_or_win(n: int, k: int) -> bool:\n        return game_ends_in_draw(n, k) or game_ends_in_win(n, k) or game_ends_in_loss(n, k) or game_ends_in_tie(n, k) or game_ends_in_win(n"
    },
    {
        "number": 2767,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    test_sentences = []\n\n    for i in range(26):\n        test_sentences.append(words[i])\n\n    for i in range(26, 52):\n        test_sentences.append(words[i - 26])\n\n    for i in range(52, 78):\n        test_sentences.append(words[i - 52])\n\n    for i in range(78, 104):\n        test_sentences.append(words[i - 78])\n\n    return str(len(test_sentences))"
    },
    {
        "number": 2768,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cubes = []\n    for _ in range(m):\n        r, c = map(int, stdin.split())\n        cubes.append((r, c))\n\n    def is_valid(r, c):\n        return 1 <= r <= n and 1 <= c <= n\n\n    def is_connected(r1, c1, r2, c2):\n        return abs(r1 - r2) == 1 or abs(c1 - c2) == 1\n\n    def bfs(r, c):\n        queue = [(r, c)]\n        visited = set()\n        visited.add((r, c))\n        while queue:\n            r, c = queue.pop(0)\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_r, new_c = r + dr, c + dc\n                if is_valid(new_r, new_c) and (new_r, new_c) not in visited and is_connected(r, c, new_r, new_c):\n                    queue.append((new_r, new_c))\n                    visited.add((new_r, new_c))\n        return visited\n\n    def min_moves(r, c):\n        visited = bfs(r, c)\n        return len(visited)\n\n    min_moves_set = set()\n    for r, c in cubes:\n        min_moves_set.add(min_moves(r, c))\n\n    return str(min(min_moves_set))"
    },
    {
        "number": 2769,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q, s = map(int, stdin.split())\n    classical_problems = list(map(int, stdin.split()))\n    creative_problems = list(map(int, stdin.split()))\n\n    classical_problems.sort()\n    creative_problems.sort()\n\n    max_diff = max(abs(classical_problems[i] - classical_problems[i + 1]) for i in range(len(classical_problems) - 1))\n    min_diff = min(abs(creative_problems[i] - creative_problems[i + 1]) for i in range(len(creative_problems) - 1))\n\n    if max_diff > s:\n        return -1\n\n    return min_diff"
    },
    {
        "number": 2770,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def linear_recurrence(x: int, a: List[int]) -> int:\n        return sum(a[i] * x ** i for i in range(len(a)))\n\n    def modular_exponentiation(base: int, exponent: int, modulus: int) -> int:\n        result = 1\n        base %= modulus\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            base = (base * base) % modulus\n            exponent //= 2\n        return result\n\n    def modular_multiplication(a: int, b: int, modulus: int) -> int:\n        return (a * b) % modulus\n\n    def modular_addition(a: int, b: int, modulus: int) -> int:\n        return (a + b) % modulus\n\n    def modular_subtraction(a: int, b: int, modulus: int) -> int:\n        return modular_addition(a, -b, modulus)\n\n    def modular_inverse(a: int, modulus: int) -> int:\n        return modular_multiplication(modulus, modular_multiplication(a, modular_subtraction(modulus, a, modulus), modulus), modulus)\n\n    def modular_pow(base: int, exponent: int, modulus: int) -> int:\n        if exponent == 0:\n            return 1\n        if exponent == 1:\n            return base\n        if exponent % 2 == 0:\n            half_pow = modular_pow(base, exponent // 2, modulus)\n            return modular_multiplication(half_pow, half_pow, modulus)\n        return modular_multiplication(base, modular_pow(base, exponent - 1, modulus), modulus)\n\n    def modular_gcd(a: int, b: int, modulus: int) -> int:\n        if b == 0:\n            return a\n        return modular_gcd(b, modular_subtraction(a, modular_multiplication(a, modular_inverse(b, modulus), modulus), modulus), modulus)\n\n    def modular_lcm(a: int, b: int, modulus: int) -> int:\n        return modular_division(a * b, modular_gcd(a, b, modulus), modulus)\n\n    def modular_division(a: int, b: int, modulus: int) -> int:\n        return modular_multiplication(a, modular_inverse(b, modulus), modulus)\n\n    def modular_lcm_array(arr: List[int], modulus: int) -> int:\n        return modular_lcm(arr[0], modular_lcm_array(arr[1:], modulus), modulus)\n\n    def modular_gcd_array(arr: List[int], modulus: int) -> int:\n        return modular_gcd(arr[0], modular_gcd_array(arr[1:], modulus), modulus)\n\n    def modular_division_array(a: int, arr: List[int], modulus: int) -> int:\n        return modular_multiplication(a, modular_inverse(modular_lcm_array(arr, modulus), modulus), modulus)\n\n    def modular_lcm_array_array(arr1: List[int], arr2: List[int], modulus: int) -> int:\n        return modular_lcm(arr1[0], modular_lcm_array_array(arr1[1:], arr2, modulus), modulus)\n\n    def modular_gcd_array_array(arr1: List[int], arr2: List[int], modulus: int) -> int:\n        return modular_gcd(arr1[0], modular_gcd_array_array(arr1[1:], arr2, modulus), modulus)\n\n    def modular_division_array_array(a: int, arr1: List[int], arr2: List[int], modulus: int) -> int:\n        return modular_multiplication(a, modular_inverse(modular_lcm_array_array(arr1, arr2, modulus), modulus), modulus)\n\n    def modular_lcm_array_array_array(arr1: List[int], arr2: List[int], arr3: List[int], modulus: int) -> int:\n        return modular_lcm(arr1[0], modular_lcm_array_array_array(arr1[1:], arr2, arr3, modulus), modulus)\n\n    def modular_gcd_array_array_array(arr1: List[int], arr2: List"
    },
    {
        "number": 2771,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    directions = stdin.split()[1]\n    visited = [0] * n\n    order = []\n\n    for i in range(n - 1):\n        if directions[i] == 'L':\n            visited[i] = 1\n        else:\n            visited[i] = 2\n\n    for i in range(n - 1):\n        if visited[i] == 1:\n            order.append(i + 1)\n\n    for i in range(n - 1, 0, -1):\n        if visited[i - 1] == 2:\n            order.append(i)\n\n    return ''.join(map(str, order))"
    },
    {
        "number": 2772,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(int, stdin.split())\n    ascent = []\n    descent = []\n    for _ in range(a):\n        h, t = map(int, stdin.split())\n        ascent.append((h, t))\n    for _ in range(d):\n        h, t = map(int, stdin.split())\n        descent.append((h, t))\n\n    ascent_sum = sum(h for h, _ in ascent)\n    descent_sum = sum(h for h, _ in descent)\n\n    if ascent_sum == descent_sum:\n        return str(0)\n\n    ascent_time = 0\n    descent_time = 0\n    for h, t in ascent:\n        ascent_time += t\n        if h == 0:\n            ascent_time += 1\n\n    for h, t in descent:\n        descent_time += t\n        if h == 0:\n            descent_time += 1\n\n    return str(min(ascent_time, descent_time))"
    },
    {
        "number": 2773,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, d = map(int, stdin.split())\n        graph[a].append((b, d))\n        graph[b].append((a, d))\n\n    def bfs(start: int) -> List[int]:\n        queue = deque([start])\n        visited = set()\n        visited.add(start)\n        path = [start]\n        while queue:\n            current = queue.popleft()\n            for neighbor, weight in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n                    path.append(neighbor)\n        return path\n\n    def shortest_path(start: int, end: int) -> List[int]:\n        visited = set()\n        queue = deque([(start, [start])])\n        while queue:\n            current, path = queue.popleft()\n            if current == end:\n                return path\n            visited.add(current)\n            for neighbor, weight in graph[current]:\n                if neighbor not in visited:\n                    queue.append((neighbor, path + [neighbor]))\n        return []\n\n    def is_valid(path: List[int]) -> bool:\n        for i in range(len(path) - 1):\n            if path[i] == path[i + 1]:\n                return False\n        return True\n\n    def find_path(start: int, end: int) -> List[int]:\n        path = shortest_path(start, end)\n        if not path:\n            return []\n        if is_valid(path):\n            return path\n        return []\n\n    def find_bus_path(start: int, end: int) -> List[int]:\n        bus_path = find_path(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs(start: int, end: int) -> List[int]:\n        bus_path = find_path(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs_with_bus(start: int, end: int) -> List[int]:\n        bus_path = find_bus_path(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs_with_bus_and_signs(start: int, end: int) -> List[int]:\n        bus_path = find_bus_path_from_signs(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs_with_bus_and_signs_and_bus(start: int, end: int) -> List[int]:\n        bus_path = find_bus_path_from_signs_with_bus(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs_with_bus_and_signs_and_bus_and_signs(start: int, end: int) -> List[int]:\n        bus_path = find_bus_path_from_signs_with_bus_and_signs(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs_with_bus_and_signs_and_bus_and_signs_and_bus(start: int, end: int) -> List[int]:\n        bus_path = find_bus_path_from_signs_with_bus_and_signs_and_bus(start, end)\n        if not bus_path:\n            return []\n        bus_path.append(0)\n        bus_path.append(1)\n        return bus_path\n\n    def find_bus_path_from_signs_with_bus_and_signs_and_bus_and_signs_and_bus_and_signs(start: int"
    },
    {
        "number": 2774,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    lamps = set(map(int, stdin.split()))\n    trails = []\n    for _ in range(n - 1):\n        a, b, d = map(int, stdin.split())\n        trails.append((a, b, d))\n    lamps.add(1)\n    lamps.add(n)\n    lamps = sorted(lamps)\n    lamps_needed = 0\n    for i in range(len(lamps) - 1):\n        if trails[i][2] + trails[i + 1][2] > s:\n            lamps_needed += 1\n    return str(lamps_needed)"
    },
    {
        "number": 2775,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    house = tuple(map(int, stdin.split()[1:3]))\n    workplace = tuple(map(int, stdin.split()[3:5]))\n    errands = []\n    for _ in range(n):\n        errands.append(tuple(map(int, stdin.split()[5:])))\n    errands.sort(key=lambda x: (x[0], x[1]))\n\n    visited = set()\n    queue = [(house, 0)]\n    while queue:\n        current, steps = queue.pop(0)\n        if current == workplace:\n            return str(steps)\n        visited.add(current)\n        for i in range(4):\n            x, y = current\n            if i == 0:\n                y += 1\n            elif i == 1:\n                x -= 1\n            elif i == 2:\n                y -= 1\n            elif i == 3:\n                x += 1\n            new_x, new_y = x, y\n            if 0 <= new_x < 10**9 and 0 <= new_y < 10**9 and (new_x, new_y) not in visited:\n                queue.append((new_x, new_y, steps + 1))\n\n    return \"impossible\""
    },
    {
        "number": 2776,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    prohibitions = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        prohibitions.add((a, b))\n\n    def is_valid(pizza):\n        for i in range(n):\n            if pizza[i] in prohibitions:\n                return False\n        return True\n\n    def count_pizzas(pizza):\n        if is_valid(pizza):\n            return 1\n        return 0\n\n    def backtrack(pizza, count):\n        if count == 0:\n            return 1\n        if len(pizza) == n:\n            return 0\n\n        result = 0\n        for i in range(n):\n            if pizza[i] not in prohibitions:\n                new_pizza = pizza.copy()\n                new_pizza[i] = i + 1\n                result += count_pizzas(new_pizza)\n\n        return result\n\n    return str(backtrack([0] * n, n))"
    },
    {
        "number": 2777,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    p.sort()\n    count = 0\n    for i in range(1, 2**m):\n        if p[i] == i:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 2778,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, t = map(int, stdin.split())\n    if t > n * k:\n        return \"0\"\n\n    def count_ways(cards):\n        if not cards:\n            return 1\n        return count_ways(cards[1:]) + count_ways(cards[1:]) * (t - cards[0])\n\n    return str(count_ways(list(range(1, k + 1)))) % 1000000009"
    },
    {
        "number": 2779,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, c = map(int, stdin.split())\n    grid = [list(row) for row in stdin.splitlines()]\n    costs = list(map(int, stdin.split()))\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if (x, y) == (n - 1, m - 1):\n                return 0\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and grid[nx][ny]!= 'B' and grid[nx][ny]!= '.' and (nx, ny) not in visited:\n                    queue.append((nx, ny))\n        return float('inf')\n\n    def dfs(x, y, cost):\n        if x == n - 1 and y == m - 1:\n            return cost\n        if (x, y) in visited:\n            return float('inf')\n        visited.add((x, y))\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and grid[nx][ny]!= 'B' and grid[nx][ny]!= '.' and (nx, ny) not in visited:\n                cost_next = dfs(nx, ny, cost + costs[grid[nx][ny] - ord('a')])\n                if cost_next < cost:\n                    cost = cost_next\n        return cost\n\n    visited = set()\n    cost = dfs(0, 0, 0)\n    if cost == float('inf'):\n        return -1\n    return str(cost)"
    },
    {
        "number": 2780,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n > 7 or m > n + 1:\n        return \"Error: Number of students or maximum number is invalid.\"\n\n    probabilities = [0] * m\n    for i in range(1, m + 1):\n        probabilities[i - 1] = 1 / m\n\n    return \"\\n\".join(map(str, probabilities))\n"
    },
    {
        "number": 2781,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0].split())\n    grid = [list(map(int, stdin.split()[i+1].split())) for i in range(r)]\n    \n    def dfs(x, y, depth):\n        if x == r-1 and y == c-1:\n            return depth\n        if x < 0 or x >= r or y < 0 or y >= c:\n            return float('inf')\n        if grid[x][y] == 0:\n            return dfs(x+1, y, depth)\n        if grid[x][y] > depth:\n            return dfs(x, y+1, grid[x][y])\n        return dfs(x+1, y, depth)\n    \n    return str(dfs(0, 0, 0))"
    },
    {
        "number": 2782,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, c = map(int, stdin.split())\n    passengers = []\n    for _ in range(n):\n        a, b, s = map(int, stdin.split())\n        passengers.append((a, b, s))\n\n    passengers.sort(key=lambda x: (x[0], x[1]))\n\n    max_seats = 0\n    for i in range(n):\n        max_seats = max(max_seats, passengers[i][0] + passengers[i][2])\n\n    return str(max_seats)"
    },
    {
        "number": 2783,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    shady_spots = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        shady_spots.append((x, y))\n    dormitory = map(int, stdin.split()[2:])\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def sweat_rate(distance_to_dormitory):\n        return max(0, r0 * (distance_to_dormitory ** 2))\n\n    def sweat_exposure(distance_to_dormitory):\n        return min(distance_to_dormitory, 2 * distance_to_dormitory)\n\n    def sweat_exposure_rate(distance_to_dormitory):\n        return sweat_rate(sweat_exposure(distance_to_dormitory))\n\n    def sweat_exposure_cost(distance_to_dormitory):\n        return sweat_exposure(distance_to_dormitory) * sweat_exposure_rate(distance_to_dormitory)\n\n    def sweat_exposure_cost_to_dormitory(distance_to_dormitory):\n        return sweat_exposure_cost(distance_to_dormitory) - sweat_exposure_cost(0)\n\n    def sweat_exposure_cost_to_shady_spot(distance_to_dormitory):\n        return sweat_exposure_cost(distance_to_dormitory) - sweat_exposure_cost(distance_to_dormitory)\n\n    def sweat_exposure_cost_to_dormitory_and_shady_spot(distance_to_dormitory):\n        return sweat_exposure_cost_to_dormitory(distance_to_dormitory) + sweat_exposure_cost_to_shady_spot(distance_to_dormitory)\n\n    def find_path(start, end):\n        queue = [(start, [start])]\n        visited = set()\n        while queue:\n            current, path = queue.pop(0)\n            if current == end:\n                return path\n            if current in visited:\n                continue\n            visited.add(current)\n            for neighbor in shady_spots:\n                if distance(neighbor, current) <= sweat_exposure(distance(neighbor, current)):\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n        return []\n\n    def find_best_path(start, end):\n        best_path = find_path(start, end)\n        if not best_path:\n            return []\n        best_sweat_exposure_cost = sweat_exposure_cost_to_dormitory_and_shady_spot(distance(dormitory, best_path[-1]))\n        for i in range(len(best_path) - 1, 0, -1):\n            sweat_exposure_cost_to_neighbor = sweat_exposure_cost_to_dormitory_and_shady_spot(distance(dormitory, best_path[i]))\n            if sweat_exposure_cost_to_neighbor < best_sweat_exposure_cost:\n                best_sweat_exposure_cost = sweat_exposure_cost_to_neighbor\n                best_path = best_path[:i] + best_path[i + 1:]\n        return best_path\n\n    r0 = 1.5\n    best_path = find_best_path(dormitory, shady_spots[0])\n    if not best_path:\n        print('-')\n    else:\n        print(' '.join(map(str, best_path)))"
    },
    {
        "number": 2784,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    stations = []\n    for i in range(n):\n        station, connections = stdin.split()\n        stations.append((station, connections.split()))\n\n    start, end = stdin.split()[-1].split()\n\n    def dfs(station, visited):\n        if station == end:\n            return [station]\n        if station in visited:\n            return []\n        visited.add(station)\n        for connection in stations[stations.index((station, []))][1]:\n            if connection not in visited:\n                path = dfs(connection, visited)\n                if path:\n                    return [station] + path\n        visited.remove(station)\n        return []\n\n    path = dfs(start, set())\n    if not path:\n        return \"no route found\"\n    return \" \".join(path)"
    },
    {
        "number": 2785,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    c = [int(x) for x in stdin.split()]\n    p = [int(x) for x in stdin.split()]\n\n    def min_days(capital, days):\n        profit = 0\n        for i in range(len(c)):\n            profit += p[i] * days\n            if profit >= capital:\n                return days\n        return days\n\n    days = 0\n    capital = 0\n    while capital < M:\n        days += 1\n        capital += c[days - 1]\n        days = min_days(capital, days)\n\n    return str(days)"
    },
    {
        "number": 2786,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    s = stdin.split()[1]\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!= '?' else '}' for c in s)\n    s = ''.join(c if c!= '?' else '[' for c in s)\n    s = ''.join(c if c!= '?' else ']' for c in s)\n    s = ''.join(c if c!= '?' else '(' for c in s)\n    s = ''.join(c if c!= '?' else ')' for c in s)\n    s = ''.join(c if c!= '?' else '{' for c in s)\n    s = ''.join(c if c!="
    },
    {
        "number": 2787,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    airports = {}\n    for i in range(n):\n        code, lat, lon = stdin.split()\n        airports[code] = (float(lat), float(lon))\n\n    routes = []\n    for i in range(m):\n        a, b = stdin.split()\n        routes.append((a, b))\n\n    def distance(lat1, lon1, lat2, lon2):\n        R = 6371  # km\n        dlat = (lat2 - lat1) * math.pi / 180\n        dlon = (lon2 - lon1) * math.pi / 180\n        a = math.sin(dlat / 2) * math.sin(dlat / 2) + math.cos(lat1 * math.pi / 180) * math.cos(lat2 * math.pi / 180) * math.sin(dlon / 2) * math.sin(dlon / 2)\n        c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n        return R * c\n\n    def shame(lat1, lon1, lat2, lon2):\n        return distance(lat1, lon1, lat2, lon2) + 100\n\n    def total_shame(start, end):\n        shame_sum = 0\n        for a, b in routes:\n            if a == start and b == end:\n                shame_sum += shame(*airports[a])\n            elif a == end and b == start:\n                shame_sum += shame(*airports[b])\n        return shame_sum\n\n    start, end = stdin.split()\n    start_lat, start_lon = airports[start]\n    end_lat, end_lon = airports[end]\n\n    if start_lat == end_lat and start_lon == end_lon:\n        return -1\n\n    return str(total_shame(start, end))"
    },
    {
        "number": 2788,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sizes = map(int, stdin.split())\n    k, x, a, b = map(int, stdin.split())\n\n    def is_valid(group_sizes: list[int], k: int, x: int, a: int, b: int) -> bool:\n        group_sizes.sort(reverse=True)\n        used_lunches = 0\n        campers_watched = 0\n        for size in group_sizes:\n            if used_lunches + size > x:\n                return False\n            used_lunches += size\n            campers_watched += 1\n            if campers_watched > b:\n                return False\n        return campers_watched >= a\n\n    if is_valid(sizes, k, x, a, b):\n        return str(sum(sizes))\n    else:\n        return \"impossible\""
    },
    {
        "number": 2789,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    pebbles = list(map(int, stdin.split()))\n    pebbles.sort()\n    pebbles.reverse()\n    min_pebbles = 0\n    for i in range(N):\n        if pebbles[i] > 0:\n            min_pebbles += 1\n            pebbles[i] -= 1\n            if pebbles[i] == 0:\n                break\n    return str(min_pebbles)"
    },
    {
        "number": 2790,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split())\n    knapsacks = list(map(int, stdin.split()))\n\n    def find_min_time(slot: int) -> int:\n        min_time = float('inf')\n        for i in range(n):\n            if knapsacks[i] == slot:\n                min_time = min(min_time, t + find_min_time((slot + 1) % s))\n        return min_time\n\n    min_time = find_min_time(0)\n    max_time = 0\n    for i in range(s):\n        max_time = max(max_time, find_min_time(i))\n\n    return f\"{min_time}\\n{max_time}\\n{min_time * max_time * 10000000 // (max_time * (max_time + 1))}\""
    },
    {
        "number": 2791,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] % d == a[j] % d:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2792,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    x = stdin.split()[2]\n    if stdin.split()[0] == \"UPIT\":\n        return str(n)\n    elif stdin.split()[0] == \"SMJER\":\n        return \" \".join(sorted(list(x), reverse=True))\n\ndef"
    },
    {
        "number": 2793,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    visited = [False] * n\n    visited[s] = True\n    queue = [(s, 0)]\n    min_weight = float('inf')\n    min_cut = []\n    while queue:\n        u, weight = queue.pop(0)\n        if u == t:\n            min_weight = min(min_weight, weight)\n            min_cut.append(u)\n        for v, w in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append((v, weight + w))\n    min_cut.reverse()\n    return str(len(min_cut)) + '\\n' +''.join(map(str, min_cut))"
    },
    {
        "number": 2794,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, c = map(int, stdin.split())\n    coworkers = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    max_annoyance = 0\n\n    for i in range(c):\n        a, d = coworkers[i]\n        max_annoyance = max(max_annoyance, a + d * h)\n\n    return str(max_annoyance)"
    },
    {
        "number": 2795,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e, p = map(int, stdin.split())\n    treehouses = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        treehouses.append((x, y))\n\n    cables = []\n    for _ in range(p):\n        a, b = map(int, stdin.split())\n        cables.append((a, b))\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def min_distance(treehouses, cables):\n        min_distance = float('inf')\n        for i in range(len(treehouses)):\n            for j in range(i + 1, len(treehouses)):\n                for cable in cables:\n                    if cable[0] == i + 1 and cable[1] == j + 1:\n                        continue\n                    if cable[0] == j + 1 and cable[1] == i + 1:\n                        continue\n                    if distance(treehouses[i], treehouses[j]) < distance(treehouses[i], treehouses[cable[0] - 1]) + distance(treehouses[cable[1] - 1], treehouses[j]):\n                        min_distance = min(min_distance, distance(treehouses[i], treehouses[j]) + distance(treehouses[cable[0] - 1], treehouses[j]) + distance(treehouses[cable[1] - 1], treehouses[i]))\n        return min_distance\n\n    return str(min_distance(treehouses, cables))"
    },
    {
        "number": 2796,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *paths = map(int, stdin.split())\n    permutation = list(map(int, stdin.split()))\n\n    def boring_pairs(planet_a: int, planet_b: int) -> int:\n        return sum(1 for path in paths if path[0] == planet_a and path[1] == planet_b)\n\n    def boring_pairs_after_destruction(planet_a: int, planet_b: int) -> int:\n        return sum(1 for path in paths if path[0] == planet_a and path[1] == planet_b and permutation[path[2] - 1] == planet_b)\n\n    boring_pairs_before_destruction = sum(boring_pairs(planet_a, planet_b) for planet_a in range(n) for planet_b in range(n) if planet_a!= planet_b)\n\n    return '\\n'.join(str(boring_pairs_after_destruction(planet_a, planet_b)) for planet_a in range(n) for planet_b in range(n) if planet_a!= planet_b)"
    },
    {
        "number": 2797,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    result = (1 ** b + 2 ** b +... + a ** b) % a\n    return str(result)"
    },
    {
        "number": 2798,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    player = stdin.split()[0]\n    cuboids = []\n    for _ in range(int(stdin.split()[1])):\n        cuboids.append(list(map(int, stdin.split()[2].split())))\n    if player == \"RUBEN\":\n        return \"RUBEN\"\n    else:\n        for i in range(len(cuboids)):\n            for j in range(i + 1, len(cuboids)):\n                for k in range(j + 1, len(cuboids)):\n                    if all(cuboids[i][k] <= cuboids[j][k] for k in range(3)) and all(cuboids[i][k] <= cuboids[i][j] for k in range(3)) and all(cuboids[i][k] <= cuboids[i][k] for k in range(3)):\n                        cuboids.pop(j)\n                        break\n        return \"ALBERT\""
    },
    {
        "number": 2799,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B, Y, S = map(int, stdin.split())\n    if R + G + B + Y < 1:\n        return \"0.0\"\n\n    def get_fruit_basket(trees: List[int]) -> int:\n        max_fruits = max(trees)\n        return max_fruits\n\n    def get_fruit_color(trees: List[int]) -> str:\n        max_fruits = max(trees)\n        for color in [\"red\", \"green\", \"yellow\", \"blue\"]:\n            if trees[color] == max_fruits:\n                return color\n        return \"unknown\"\n\n    def get_fruit_probability(trees: List[int], color: str) -> float:\n        return trees[color] / sum(trees.values())\n\n    trees = {\n        \"red\": R,\n        \"green\": G,\n        \"yellow\": Y,\n        \"blue\": B,\n    }\n\n    fruit_basket = get_fruit_basket(trees)\n    fruit_color = get_fruit_color(trees)\n    fruit_probability = get_fruit_probability(trees, fruit_color)\n\n    raven_probability = 1 / (S + 1)\n\n    probability = (fruit_probability + raven_probability) / 2\n\n    return f\"{probability:.5f}\""
    },
    {
        "number": 2800,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    piles, k = map(int, stdin.split())\n    piles = [list(map(int, pile.split())) for pile in stdin.split('\\n')[1:]]\n    piles = [sorted(pile, reverse=True) for pile in piles]\n\n    alice_win = True\n    for pile in piles:\n        if len(pile) < k:\n            alice_win = False\n            break\n        if pile[0] > k:\n            alice_win = False\n            break\n\n    if alice_win:\n        return \"Alice can win.\"\n    else:\n        return \"Bob will win.\""
    },
    {
        "number": 2801,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    connections = []\n    for _ in range(m):\n        s, t = map(int, stdin.split())\n        connections.append((s, t))\n\n    def dfs(s, visited):\n        if s in visited:\n            return 0\n        visited.add(s)\n        max_satisfaction = 0\n        for t in range(n):\n            if t == s:\n                continue\n            if t in visited:\n                continue\n            if t in connections:\n                continue\n            max_satisfaction = max(max_satisfaction, dfs(t, visited))\n        return max_satisfaction + c[s]\n\n    return str(dfs(0, set()))"
    },
    {
        "number": 2802,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    times, target_score = map(float, stdin.split())\n    if target_score > 10:\n        return \"impossible\"\n\n    if target_score <= 6.99:\n        return \"infinite\"\n\n    return \"{:.2f}\".format(times[0] + times[1] + times[2] + times[3] - target_score)"
    },
    {
        "number": 2803,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    last_animal = stdin.strip()\n    unused_animals = stdin.split('\\n')[1:]\n\n    for animal in unused_animals:\n        if animal.startswith(last_animal[-1]) and animal not in used_animals:\n            return animal\n\n    return '?'\n\nused_animals = set()\n\nwhile True:\n    stdin = input()\n    if not stdin:\n        break\n    result = solution(stdin)\n    print(result)\n    used_animals.add(result)"
    },
    {
        "number": 2804,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    words = []\n    while len(words) < B:\n        words.append(input().lower())\n    words.sort()\n    used_words = set()\n    while len(used_words) < B // 2:\n        used_words.add(input().lower())\n    used_words.sort()\n    return \" \".join(words + used_words)"
    },
    {
        "number": 2805,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    counter = 0\n    for i in range(N - 1, 0, -1):\n        counter += 1\n        if N % i == 0:\n            break\n    return str(counter)"
    },
    {
        "number": 2806,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, t = map(int, stdin.split())\n    chambers = list(map(int, stdin.split()))\n    tunnels = []\n    for _ in range(t):\n        a, b = map(int, stdin.split())\n        tunnels.append((a, b))\n\n    def dfs(chambers, visited, path):\n        if len(chambers) == 0:\n            return path\n        for i, chamber in enumerate(chambers):\n            if chamber not in visited:\n                visited.add(chamber)\n                new_path = path + [chamber]\n                if i == len(chambers) - 1:\n                    return new_path\n                for tunnel in tunnels:\n                    if tunnel[0] == chamber and tunnel[1] not in visited:\n                        new_chambers = chambers[:i] + chambers[i + 1:]\n                        new_visited = visited.copy()\n                        new_visited.add(tunnel[1])\n                        new_path = dfs(new_chambers, new_visited, new_path)\n                        if new_path:\n                            return new_path\n        return None\n\n    path = dfs(chambers, set(), [])\n    if not path:\n        return \"IMPOSSIBLE\"\n\n    p, s = len(path), len(chambers) // 2\n    return f\"{p} {s}\\n\" + \" \".join(map(str, path)) + \"\\n\" + \"\\n\".join(map(str, chambers[:s])) + \"\\n\" + \"\\n\".join(map(str, chambers[s:]))"
    },
    {
        "number": 2807,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.split()\n    a = list(a)\n    b = list(b)\n    n = len(a)\n\n    def backtrack(start: int, end: int, current: list) -> int:\n        if start == end:\n            return 1 if current == b else 0\n\n        count = 0\n        for i in range(start, end):\n            if current[i] == a[i]:\n                continue\n            current[i], current[start] = current[start], current[i]\n            count += backtrack(start + 1, end, current)\n            current[i], current[start] = current[start], current[i]\n\n        return count\n\n    return str(backtrack(0, n, a))"
    },
    {
        "number": 2808,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    l, r = map(int, stdin.split())\n\n    def count_plans(start, end):\n        if start > end:\n            return 1\n        return count_plans(start + 1, end) * (end - start + 1)\n\n    def count_happy_passengers(start, end, plan):\n        if start > end:\n            return 1\n        if plan[start] == plan[end]:\n            return 0\n        return count_happy_passengers(start + 1, end, plan) * (end - start + 1)\n\n    def count_plans_with_happy_passengers(start, end, plan):\n        if start > end:\n            return 1\n        if plan[start] == plan[end]:\n            return count_plans_with_happy_passengers(start + 1, end, plan) * (end - start + 1)\n        return count_plans_with_happy_passengers(start + 1, end, plan) * (end - start + 1)\n\n    def count_plans_with_happy_passengers_helper(start, end, plan, happy_passengers):\n        if start > end:\n            return 1\n        if plan[start] == plan[end]:\n            return count_plans_with_happy_passengers_helper(start + 1, end, plan, happy_passengers) * (end - start + 1)\n        return count_plans_with_happy_passengers_helper(start + 1, end, plan, happy_passengers) * (end - start + 1)\n\n    def count_plans_with_happy_passengers_helper_helper(start, end, plan, happy_passengers, count):\n        if start > end:\n            return count\n        if plan[start] == plan[end]:\n            return count_plans_with_happy_passengers_helper_helper(start + 1, end, plan, happy_passengers, count) * (end - start + 1)\n        return count_plans_with_happy_passengers_helper_helper(start + 1, end, plan, happy_passengers, count) * (end - start + 1)\n\n    def count_plans_with_happy_passengers_helper_helper_helper(start, end, plan, happy_passengers, count, happy_count):\n        if start > end:\n            return count\n        if plan[start] == plan[end]:\n            return count_plans_with_happy_passengers_helper_helper_helper(start + 1, end, plan, happy_passengers, count, happy_count) * (end - start + 1)\n        return count_plans_with_happy_passengers_helper_helper_helper(start + 1, end, plan, happy_passengers, count, happy_count) * (end - start + 1)\n\n    def count_plans_with_happy_passengers_helper_helper_helper_helper(start, end, plan, happy_passengers, count, happy_count, happy_count_helper):\n        if start > end:\n            return count\n        if plan[start] == plan[end]:\n            return count_plans_with_happy_passengers_helper_helper_helper_helper(start + 1, end, plan, happy_passengers, count, happy_count, happy_count_helper) * (end - start + 1)\n        return count_plans_with_happy_passengers_helper_helper_helper_helper(start + 1, end, plan, happy_passengers, count, happy_count, happy_count_helper) * (end - start + 1)\n\n    def count_plans_with_happy_passengers_helper_helper_helper_helper_helper(start, end, plan, happy_passengers, count, happy_count, happy_count_helper, happy_count_helper_helper):\n        if start > end:\n            return count\n        if plan[start] == plan[end]:\n            return count_plans_with_happy_passengers_helper_helper_helper_helper_helper(start + 1, end, plan, happy_passengers, count, happy_count, happy_count_helper, happy_count_helper_helper) * (end - start + 1)\n        return count_plans_with_happy_passengers_helper_helper_helper_helper_helper(start + 1, end, plan, happy_passengers, count, happy_count, happy_count_"
    },
    {
        "number": 2809,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.split()[1]\n    R = int(s, 2)\n    MOD = 10**9 + 7\n\n    def count_sets(R, k):\n        def xor(a, b):\n            return (a ^ b) & ((1 << 31) - 1)\n\n        def count_subsets(n, k):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets(n - 1, k) * count_subsets(n - 1, k - 1)\n\n        def count_subsets_with_xor(n, k, xor_val):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets_with_xor(n - 1, k, xor_val) * count_subsets_with_xor(n - 1, k - 1, xor_val)\n\n        def count_subsets_with_xor_and_sum(n, k, xor_val, sum_val):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets_with_xor_and_sum(n - 1, k, xor_val, sum_val) * count_subsets_with_xor_and_sum(n - 1, k - 1, xor_val, sum_val)\n\n        def count_subsets_with_xor_and_sum_and_diff(n, k, xor_val, sum_val, diff_val):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets_with_xor_and_sum_and_diff(n - 1, k, xor_val, sum_val, diff_val) * count_subsets_with_xor_and_sum_and_diff(n - 1, k - 1, xor_val, sum_val, diff_val)\n\n        def count_subsets_with_xor_and_sum_and_diff_and_product(n, k, xor_val, sum_val, diff_val, product_val):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets_with_xor_and_sum_and_diff_and_product(n - 1, k, xor_val, sum_val, diff_val, product_val) * count_subsets_with_xor_and_sum_and_diff_and_product(n - 1, k - 1, xor_val, sum_val, diff_val, product_val)\n\n        def count_subsets_with_xor_and_sum_and_diff_and_product_and_quotient(n, k, xor_val, sum_val, diff_val, product_val, quotient_val):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets_with_xor_and_sum_and_diff_and_product_and_quotient(n - 1, k, xor_val, sum_val, diff_val, product_val, quotient_val) * count_subsets_with_xor_and_sum_and_diff_and_product_and_quotient(n - 1, k - 1, xor_val, sum_val, diff_val, product_val, quotient_val)\n\n        def count_subsets_with_xor_and_sum_and_diff_and_product_and_quotient_and_remainder(n, k, xor_val, sum_val, diff_val, product_val, quotient_val, remainder_val):\n            if n == 0:\n                return 1\n            if n == 1:\n                return k\n            return count_subsets_with_xor_and_sum_and_diff_and_product_and_quotient_and_remainder(n - 1, k, xor_val, sum_val, diff_val, product_val, quotient_val, remainder_val) * count_subsets_with_xor_and_sum_and_diff_and_product_and_quotient_and_remainder(n - 1, k - 1, xor_val, sum_val, diff_val, product_val, quotient_"
    },
    {
        "number": 2810,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    stations = list(range(m))\n    connections = []\n\n    for _ in range(n):\n        s, t = map(int, stdin.split())\n        connections.append((s, t))\n\n    def is_simple_loop(stations: list) -> bool:\n        for i in range(len(stations) - 1):\n            if stations[i] == stations[i + 1]:\n                return False\n        return True\n\n    def count_simple_loops(stations: list) -> int:\n        count = 0\n        for i in range(len(stations) - 1):\n            for j in range(i + 2, len(stations)):\n                if is_simple_loop(stations[i:j]):\n                    count += 1\n        return count\n\n    def find_simple_loops(stations: list) -> list:\n        loops = []\n        for i in range(len(stations) - 1):\n            for j in range(i + 2, len(stations)):\n                if is_simple_loop(stations[i:j]):\n                    loops.append(stations[i:j])\n        return loops\n\n    def find_unique_loops(loops: list) -> set:\n        unique_loops = set()\n        for loop in loops:\n            if loop not in unique_loops:\n                unique_loops.add(loop)\n        return unique_loops\n\n    def count_unique_loops(loops: list) -> int:\n        return len(find_unique_loops(loops))\n\n    def count_loops(stations: list) -> int:\n        loops = find_simple_loops(stations)\n        return count_unique_loops(loops)\n\n    return str(count_loops(stations))\n"
    },
    {
        "number": 2811,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    parent = [int(x) - 1 for x in stdin.split()[1:]]\n    red = [int(x) - 1 for x in stdin.split()[1+n:1+n+m]]\n\n    def dfs(node, color, path):\n        if color == \"red\":\n            return 1\n        if node in path:\n            return 0\n        path.add(node)\n        res = 0\n        for child in range(n):\n            if parent[child] == node:\n                res += dfs(child, \"red\" if child in red else \"black\", path)\n        return res\n\n    res = 0\n    for color in [\"red\", \"black\"]:\n        res += dfs(1, color, set())\n    return str(res % (10**9 + 7))"
    },
    {
        "number": 2812,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n    min_length = float('inf')\n    shortest_name = \"\"\n\n    for i in range(len(alphabet)):\n        for j in range(i + 1, len(alphabet)):\n            name = alphabet[i] + alphabet[j]\n            value = abs(ord(alphabet[i]) - ord(alphabet[j]))\n            encoded_value = sum(abs(ord(alphabet[i + 1]) - ord(alphabet[j + 1])) for j in range(i + 1, len(alphabet)))\n            if encoded_value == value:\n                if len(name) < min_length:\n                    min_length = len(name)\n                    shortest_name = name\n\n    return shortest_name"
    },
    {
        "number": 2813,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    syllables = list(map(str.lower, stdin.split()))\n    syllables.sort()\n    syllables = ''.join(syllables)\n\n    for i in range(len(syllables) - 2):\n        if syllables[i] == syllables[i + 1] == syllables[i + 2]:\n            return \"haiku\"\n\n    return \"come back next year\""
    },
    {
        "number": 2814,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sigma_0 = list(map(int, stdin.split()[1].split()))\n    sigma_1 = list(map(int, stdin.split()[2].split()))\n\n    def is_similar(i, j):\n        return i // 2 == j // 2\n\n    def find_similar(sigma, cards):\n        for i in range(len(cards)):\n            if cards[i] not in sigma:\n                return i\n        return -1\n\n    def find_unknown(sigma, cards):\n        for i in range(len(cards)):\n            if cards[i] == -1:\n                return i\n        return -1\n\n    def play_game(sigma_0, sigma_1, cards):\n        while cards:\n            player = 0 if cards[0] == -1 else 1\n            card_0 = cards.pop(0)\n            card_1 = cards.pop(0)\n\n            if is_similar(card_0, card_1):\n                cards.remove(card_0)\n                cards.remove(card_1)\n            else:\n                cards.remove(card_0)\n                cards.remove(card_1)\n                cards.append(card_0)\n                cards.append(card_1)\n\n            if not cards:\n                return player\n\n        return -1\n\n    winner = play_game(sigma_0, sigma_1, [0] * 2 * N)\n    return str(winner)"
    },
    {
        "number": 2815,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        if bin(i).count('1') == e:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2816,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n    V_row, V_col = [row.index('V') for row in grid].index('V'), grid[0].index('V')\n    J_row, J_col = [row.index('J') for row in grid].index('J'), grid[0].index('J')\n\n    def bfs(row, col, visited):\n        queue = [(row, col)]\n        visited[row][col] = True\n        while queue:\n            r, c = queue.pop(0)\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == '.' and not visited[nr][nc]:\n                    queue.append((nr, nc))\n                    visited[nr][nc] = True\n        return visited\n\n    def min_distance(row, col, visited):\n        visited[row][col] = True\n        min_dist = float('inf')\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nr, nc = row + dr, col + dc\n            if 0 <= nr < N and 0 <= nc < M and grid[nr][nc] == '+' and not visited[nr][nc]:\n                dist = min_distance(nr, nc, visited) + abs(nr - row) + abs(nc - col)\n                min_dist = min(min_dist, dist)\n        return min_dist\n\n    visited = [[False] * M for _ in range(N)]\n    visited[V_row][V_col] = True\n    visited[J_row][J_col] = True\n\n    min_dist = min_distance(V_row, V_col, visited)\n    return str(min_dist)"
    },
    {
        "number": 2817,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    e, e_success, e_failure = map(int, stdin.split())\n    s = e_success + e_failure\n    d = 0\n    while e > 0:\n        if s >= 25:\n            d += 25\n            s -= 25\n            e -= e_success\n        else:\n            d += s\n            s = 0\n            e -= e_failure\n    return str(d)"
    },
    {
        "number": 2818,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *heights = map(int, stdin.split())\n    heights.sort()\n    count = 0\n    for i in range(n):\n        if heights[i] == heights[i + 1] - 1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2819,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a_x, a_y, b_x, b_y = map(int, stdin.split())\n    moves = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        moves.append((x, y))\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= n\n\n    def is_valid_move(x, y):\n        return is_valid(x + x_i, y + y_i) and moves.count((x + x_i, y + y_i)) == 1\n\n    def teleport(x, y):\n        nonlocal moves\n        while is_valid(x, y) and moves.count((x, y)) > 1:\n            x += 1\n        return x, y\n\n    def capture(x, y):\n        nonlocal moves\n        while is_valid(x, y) and moves.count((x, y)) > 1:\n            x += 1\n            moves.remove((x, y))\n        return x, y\n\n    def is_valid_teleport(x, y):\n        return is_valid(x, y) and moves.count((x, y)) == 1\n\n    def is_valid_capture(x, y):\n        return is_valid(x, y) and moves.count((x, y)) > 1\n\n    def is_valid_move_or_teleport(x, y):\n        return is_valid_move(x, y) or is_valid_teleport(x, y)\n\n    def is_valid_move_or_capture(x, y):\n        return is_valid_move(x, y) or is_valid_capture(x, y)\n\n    def is_valid_move_or_teleport_or_capture(x, y):\n        return is_valid_move_or_teleport(x, y) or is_valid_move_or_capture(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport(x, y):\n        return is_valid_move_or_teleport_or_capture(x, y) or is_valid_teleport(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport_or_capture(x, y):\n        return is_valid_move_or_teleport_or_capture(x, y) or is_valid_teleport_or_capture(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport(x, y):\n        return is_valid_move_or_teleport_or_capture_or_teleport(x, y) or is_valid_teleport_or_capture_or_teleport(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture(x, y):\n        return is_valid_move_or_teleport_or_capture_or_teleport_or_capture(x, y) or is_valid_teleport_or_capture_or_teleport_or_capture(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture_or_teleport(x, y):\n        return is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport(x, y) or is_valid_teleport_or_capture_or_teleport_or_capture_or_teleport(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture(x, y):\n        return is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture(x, y) or is_valid_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture(x, y)\n\n    def is_valid_move_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture_or_teleport_or_capture_or_teleport(x, y):\n       "
    },
    {
        "number": 2820,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *beans = map(int, stdin.split())\n    t, *farms = map(int, stdin.split())\n    beans_per_farm = [list(map(int, stdin.split())) for _ in range(t)]\n\n    def dfs(farm_index: int, bean_index: int, cows: int) -> int:\n        if cows == 0:\n            return 0\n\n        if bean_index == n:\n            return dfs(farm_index + 1, 0, cows - 1)\n\n        if beans[bean_index] > 0:\n            beans[bean_index] -= 1\n            return dfs(farm_index, bean_index + 1, cows)\n\n        return dfs(farm_index, bean_index + 1, cows)\n\n    return str(dfs(0, 0, 0))\n"
    },
    {
        "number": 2821,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, m, s, l = map(int, stdin.split())\n    min_time = float('inf')\n    for i in range(m):\n        time_taken = 0\n        for j in range(s):\n            time_taken += 1\n        for j in range(l):\n            time_taken += q\n        if time_taken < min_time:\n            min_time = time_taken\n    return str(min_time)"
    },
    {
        "number": 2822,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_b, y_b = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    def is_tree(x: int, y: int) -> bool:\n        return x1 <= x <= x2 and y1 <= y <= y2\n\n    def closest_tree(x: int, y: int) -> tuple[int, int]:\n        closest_x = min(x1, x2)\n        closest_y = min(y1, y2)\n        for dx in range(1, abs(x1 - x2) + 1):\n            for dy in range(1, abs(y1 - y2) + 1):\n                if is_tree(x + dx, y + dy):\n                    closest_x = min(closest_x, x + dx)\n                    closest_y = min(closest_y, y + dy)\n        return closest_x, closest_y\n\n    if is_tree(x_b, y_b):\n        return \"Yes\"\n    else:\n        closest_x, closest_y = closest_tree(x_b, y_b)\n        return \"No\", f\"{closest_x} {closest_y}\""
    },
    {
        "number": 2823,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    apple_dna, swine_gene, cost_a, cost_c, cost_g, cost_t = map(int, stdin.split())\n\n    # Initialize variables\n    total_cost = 0\n    current_cost = 0\n    current_position = 0\n\n    # Iterate through the apple_dna\n    for i, char in enumerate(apple_dna):\n        # Check if the current character is the swine gene\n        if char == swine_gene[current_position]:\n            # If it is, add the cost of the current character to the total cost\n            total_cost += current_cost\n            # Increment the current position\n            current_position += 1\n            # If the current position is equal to the length of the swine gene, reset it to 0\n            if current_position == len(swine_gene):\n                current_position = 0\n        # If the current character is not the swine gene, add the cost of the current character to the total cost\n        else:\n            total_cost += current_cost\n        # Add the cost of the current character to the total cost\n        total_cost += cost_a + cost_c + cost_g + cost_t\n        # Increment the current position\n        current_position += 1\n        # If the current position is equal to the length of the swine gene, reset it to 0\n        if current_position == len(swine_gene):\n            current_position = 0\n\n    # Return the total cost\n    return str(total_cost)"
    },
    {
        "number": 2824,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.split()[0])\n    weights = list(map(int, stdin.split()[1:]))\n\n    def find_target_weight(weights: List[int]) -> int:\n        total_weight = sum(weights)\n        target_weight = total_weight // 2\n\n        left_group = []\n        right_group = []\n\n        for weight in weights:\n            if weight < target_weight:\n                left_group.append(weight)\n            else:\n                right_group.append(weight)\n\n        if len(left_group) % 2 == 0:\n            left_group.sort()\n            right_group.sort()\n        else:\n            left_group.sort()\n            right_group.append(left_group[-1])\n\n        return min(left_group + right_group)\n\n    return str(find_target_weight(weights))"
    },
    {
        "number": 2825,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *times = map(int, stdin.split())\n    times = sorted(times)\n    total_time = sum(times)\n    min_time = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i == j:\n                continue\n            min_time = min(min_time, total_time - times[i] - times[j])\n\n    return str(min_time)"
    },
    {
        "number": 2826,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, n, D = map(int, stdin.split())\n    f1, f2 = stdin.split()[1:3]\n    f1 = [int(x) for x in f1]\n    f2 = [int(x) for x in f2]\n\n    def hamming_distance(x: list, y: list) -> int:\n        return sum(x[i]!= y[i] for i in range(len(x)))\n\n    def is_on_ellipse(p: list) -> bool:\n        return hamming_distance(p, f1) + hamming_distance(p, f2) == D\n\n    points = set()\n    for i in range(1 << n):\n        word = [0] * q\n        for j in range(n):\n            word[f1[j]] = (i >> j) & 1\n            word[f2[j]] = (i >> (j + n)) & 1\n        points.add(word)\n\n    return str(len(points))\n"
    },
    {
        "number": 2827,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for u, v in map(lambda x: map(int, x.split()), stdin.split()[1:m + 1]):\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def bfs(start: int) -> int:\n        queue = [start]\n        visited = set()\n        visited.add(start)\n        level = 0\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                current = queue.pop(0)\n                for neighbor in graph[current]:\n                    if neighbor not in visited:\n                        visited.add(neighbor)\n                        queue.append(neighbor)\n        return level\n\n    infected_hosts = set()\n    for u in range(1, n + 1):\n        if bfs(u) == 1:\n            infected_hosts.add(u)\n\n    return str(len(infected_hosts))"
    },
    {
        "number": 2828,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    words = stdin.split()[1:]\n    a = list(map(int, stdin.split()[n + 1:]))\n\n    def encrypt(word: str, key: str) -> str:\n        result = \"\"\n        for letter in word:\n            if letter in key:\n                result += key[key.index(letter)]\n            else:\n                result += letter\n        return result\n\n    def sort_words(words: List[str]) -> List[str]:\n        return sorted(words, key=lambda x: x.lower())\n\n    encrypted_words = [encrypt(word, \"abcdefghijklmnopqrstuvwxyz\") for word in words]\n    sorted_encrypted_words = sort_words(encrypted_words)\n\n    for i, word in enumerate(sorted_encrypted_words):\n        if a[i] == i + 1:\n            return \"DA\", word\n\n    return \"NE\"\n"
    },
    {
        "number": 2829,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    morse_code = {\n        'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..',\n        '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.'\n    }\n\n    def encode(s: str) -> str:\n        encoded = ''\n        for c in s:\n            if c.isalpha():\n                encoded += morse_code[c]\n            else:\n                encoded +=''\n        return encoded\n\n    def decode(s: str) -> str:\n        decoded = ''\n        for c in s:\n            if c =='':\n                decoded +=''\n            else:\n                decoded += ''.join(morse_code[d] for d in c)\n        return decoded\n\n    encoded_s = encode(stdin)\n    decoded_s = decode(encoded_s)\n\n    return len(decoded_s)"
    },
    {
        "number": 2830,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    grid = [list(map(int, line.strip())) for line in stdin.split()[1:]]\n    top_left = (0, 0)\n    bottom_right = (n - 1, m - 1)\n    moves = 0\n\n    while top_left!= bottom_right:\n        if top_left[0] < bottom_right[0]:\n            top_left = (top_left[0] + 1, top_left[1])\n            moves += 1\n        elif top_left[1] < bottom_right[1]:\n            top_left = (top_left[0], top_left[1] + 1)\n            moves += 1\n        else:\n            bottom_right = (bottom_right[0] - 1, bottom_right[1])\n            moves += 1\n\n    if top_left == bottom_right:\n        return str(moves)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 2831,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vehicles = []\n    for _ in range(n):\n        x, v = map(int, stdin.split()[1:])\n        vehicles.append((x, v))\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(vehicles[i][0] - vehicles[j][0])\n            if distance < min_distance:\n                min_distance = distance\n    return str(min_distance)"
    },
    {
        "number": 2832,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_nearest(value: int, allowed_values: List[int]) -> int:\n        return min(allowed_values, key=lambda x: abs(x - value))\n\n    def sum_of_squared_errors(red_values: List[int], allowed_values: List[int]) -> int:\n        return sum(\n            (find_nearest(value, allowed_values) - value) ** 2\n            for value in red_values\n        )\n\n    def find_best_allowed_values(red_values: List[int]) -> List[int]:\n        allowed_values = sorted(set(red_values))\n        return allowed_values[:k]\n\n    def process_input(stdin: str) -> Tuple[int, int]:\n        lines = stdin.split(\"\\n\")\n        d, k = map(int, lines[0].split())\n        red_values = [int(line.split()[0]) for line in lines[1:]]\n        return d, k, red_values\n\n    d, k, red_values = process_input(stdin)\n    allowed_values = find_best_allowed_values(red_values)\n    result = sum_of_squared_errors(red_values, allowed_values)\n    return str(result)\n"
    },
    {
        "number": 2833,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    table = [list(row.strip()) for row in stdin.split()[1:]]\n    K = int(stdin.split()[2])\n\n    # Rotate the table\n    for i in range(R):\n        for j in range(C):\n            if j + K >= C:\n                table[i][j], table[i][j + K - C] = table[i][j + K - C], table[i][j]\n            else:\n                table[i][j], table[i][j + K] = table[i][j + K], table[i][j]\n\n    # Remove leading and trailing spaces from each row\n    for row in table:\n        row = row.strip()\n\n    # Find the smallest number of rows necessary\n    min_rows = R\n    for row in table:\n        if len(row) < min_rows:\n            min_rows = len(row)\n\n    # Print the rotated table\n    for row in table:\n        print(\"\".join(row))\n\n    return \"\""
    },
    {
        "number": 2834,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin)\n    lucky_numbers = [4, 7]\n    for i in range(10):\n        if i not in lucky_numbers:\n            lucky_numbers.append(i)\n    lucky_numbers.sort()\n    return str(lucky_numbers[K - 1])"
    },
    {
        "number": 2835,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split()\n    s = set(s)\n    t = set(t)\n    count = 0\n    for i in range(len(s) - len(t) + 1):\n        if s[i:i+len(t)] == t:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2836,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *names = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n\n    def min_distance(x: int) -> int:\n        return min(abs(x - p) for p in names)\n\n    lo, hi = a, b\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if min_distance(mid) <= n:\n            lo = mid + 1\n        else:\n            hi = mid\n\n    return str(lo)"
    },
    {
        "number": 2837,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *Rs = map(float, stdin.split())\n    R_eq = sum(Rs)\n    if '(' in stdin and ')' in stdin:\n        R_eq = 1 / (1 / Rs[0] + 1 / Rs[1] + 1 / Rs[2])\n    return f\"{R_eq:.5f}\""
    },
    {
        "number": 2838,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def remove_brackets(expression: str) -> str:\n        stack = []\n        result = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if stack:\n                    stack.pop()\n                else:\n                    result.append('')\n            else:\n                result.append(char)\n        return ''.join(result)\n\n    def is_valid(expression: str) -> bool:\n        stack = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return not stack\n\n    def find_different_expressions(expression: str) -> List[str]:\n        result = []\n        for i in range(len(expression)):\n            for j in range(i + 1, len(expression) + 1):\n                sub_expression = expression[:i] + expression[i + 1:j] + expression[j:]\n                if is_valid(sub_expression):\n                    result.append(sub_expression)\n        return result\n\n    expression = stdin.strip()\n    if len(expression) > 200 or len(expression) < 1 or len(expression) % 2 == 0:\n        return \"Invalid input\"\n\n    different_expressions = find_different_expressions(expression)\n    different_expressions.sort()\n    return '\\n'.join(different_expressions)"
    },
    {
        "number": 2839,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def bfs(u: int, visited: set) -> int:\n        visited.add(u)\n        queue = deque([u])\n        while queue:\n            v = queue.popleft()\n            for w, _ in graph[v]:\n                if w not in visited:\n                    visited.add(w)\n                    if dfs(w, visited) + w == target:\n                        return 1\n                    queue.append(w)\n        return 0\n\n    def shortest_paths(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_paths(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path_and_single_cycle(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path_and_single_cycle_and_single_cycle_path(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path_and_single_cycle_and_single_cycle_path_and_single_cycle_path(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path_and_single_cycle_and_single_cycle_path_and_single_cycle_path_and_single_cycle_path(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path_and_single_cycle_and_single_cycle_path_and_single_cycle_path_and_single_cycle_path_and_single_cycle_path(u: int, visited: set) -> int:\n        visited.add(u)\n        for v, w in graph[u]:\n            if v not in visited:\n                if dfs(v, visited) + w == target:\n                    return 1\n        return 0\n\n    def count_unique_paths_with_cycle_and_single_path_and_single_cycle_and_single_cycle_path_and_single_cycle_path_and_single_cycle_path_and_single_cycle_path_and_single_"
    },
    {
        "number": 2840,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = [tuple(card.split()) for card in stdin.split()[1:]]\n    cards.sort(key=lambda x: (x[1], x[0]))\n    moves = 0\n    for i in range(n):\n        if i == 0 or cards[i][1]!= cards[i - 1][1]:\n            moves += 1\n    return str(moves)"
    },
    {
        "number": 2841,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    board = stdin.split()[1:]\n    board.insert(0, \"Start\")\n    colors = set(board)\n    colors.remove(\"Start\")\n    colors = list(colors)\n    colors.sort()\n    min_draws = float(\"inf\")\n    for i in range(1, len(colors) + 1):\n        for j in range(1, len(board) - i + 1):\n            if board[j:j + i] == colors[:i]:\n                min_draws = min(min_draws, i)\n    return str(min_draws)"
    },
    {
        "number": 2842,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    ships = []\n    for _ in range(k):\n        size = int(stdin.readline().strip())\n        ships.append(size)\n    grid = [list(row) for row in stdin.strip().split('\\n')]\n    ships_placed = 0\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == '.':\n                ships_placed += 1\n                for size in ships:\n                    if ships_placed == k:\n                        break\n                    if is_valid_placement(i, j, size, grid):\n                        grid[i][j] = 'O'\n                        ships_placed += 1\n                        break\n    return str(ships_placed)\n\ndef"
    },
    {
        "number": 2843,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = set(stdin.split())\n    n = len(words)\n    max_size = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_swap_free(words[i], words[j]):\n                size = len(words[i]) + len(words[j])\n                if size > max_size:\n                    max_size = size\n    return str(max_size)\n\ndef"
    },
    {
        "number": 2844,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    map_ = [list(row) for row in stdin.split()[1:]]\n\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C and map_[x][y]!= 'D' and map_[x][y]!= 'S'\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        visited.add((x, y))\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n        return visited\n\n    def expand_flood(x, y):\n        queue = [(x, y)]\n        visited = set()\n        visited.add((x, y))\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited and map_[nx][ny] == '.':\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    map_[nx][ny] = '*'\n\n    def shortest_time(x, y):\n        visited = bfs(x, y)\n        for field in visited:\n            expand_flood(*field)\n        return len(visited)\n\n    painter_x, painter_y = -1, -1\n    hedgehogs_x, hedgehogs_y = -1, -1\n    for x in range(R):\n        for y in range(C):\n            if map_[x][y] == 'S':\n                painter_x, painter_y = x, y\n            elif map_[x][y] == 'D':\n                hedgehogs_x, hedgehogs_y = x, y\n\n    if painter_x == -1 or hedgehogs_x == -1:\n        return 'KAKTUS'\n\n    painter_time = shortest_time(painter_x, painter_y)\n    hedgehogs_time = shortest_time(hedgehogs_x, hedgehogs_y)\n\n    return min(painter_time, hedgehogs_time)"
    },
    {
        "number": 2845,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, K = map(int, stdin.split())\n    house_indices = list(map(int, stdin.split()[1:]))\n\n    def is_valid_index(index: int) -> bool:\n        row, col = divmod(index, R**3)\n        return 1 <= row <= R and 1 <= col <= R\n\n    def is_valid_house(index: int) -> bool:\n        row, col = divmod(index, R**3)\n        return all(is_valid_index(i) for i in house_indices)\n\n    def count_perimeter(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner_and_center(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner_and_center_and_corner(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner_and_center_and_corner_and_center(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner_and_center_and_corner_and_center_and_corner(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner_and_center_and_corner_and_center_and_corner_and_center(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return 0\n\n    def count_perimeters_in_house_and_neighbors_and_diagonal_and_corner_and_center_and_corner_and_center_and_corner_and_center_and_corner(index: int) -> int:\n        row, col = divmod(index, R**3)\n        if row == 1 or row == R or col == 1 or col == R:\n            return 1\n        return"
    },
    {
        "number": 2846,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    citations = list(map(int, stdin.split()[1:]))\n    citations.sort(reverse=True)\n    h_index = 0\n    for i in range(n):\n        if citations[i] >= h_index:\n            h_index += 1\n    return str(h_index)"
    },
    {
        "number": 2847,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_length_set_list(preferences: List[List[int]]) -> int:\n        songs = list(range(1, len(preferences) + 1))\n        songs.sort()\n        min_length = len(songs)\n        for i in range(len(preferences)):\n            for j in range(i + 1, len(preferences)):\n                if preferences[i] < preferences[j]:\n                    songs.remove(preferences[i][-1])\n                    songs.remove(preferences[j][-1])\n                    min_length = min(min_length, len(songs))\n        return min_length\n\n    def read_preferences(stdin: str) -> List[List[int]]:\n        preferences = []\n        for _ in range(int(stdin.split()[0])):\n            preferences.append(list(map(int, stdin.split()[1].split())))\n        return preferences\n\n    preferences = read_preferences(stdin)\n    min_length = find_min_length_set_list(preferences)\n    print(min_length)\n    for song in preferences[0]:\n        print(song, end=\" \")\n    print()\n    for song in preferences[1]:\n        print(song, end=\" \")\n    print()\n    for song in preferences[2]:\n        print(song, end=\" \")\n    print()\n    return \"\"\n"
    },
    {
        "number": 2848,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, k, x0, a, b = map(int, stdin.split())\n    X = [x0]\n    for _ in range(r):\n        X.append((a * X[-1] + b) % n)\n\n    a = 0\n    for i in range(1, r + 1):\n        a = (53 * a + X[i]) % 199933\n\n    if X[0] == 0:\n        return \"OVERFLOW\"\n    else:\n        return str(a)"
    },
    {
        "number": 2849,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    mod = 10**9 + 7\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            for k in range(1, n + 1):\n                if (i + j + k) % 2 == 0:\n                    count += 1\n    return str(count % mod)"
    },
    {
        "number": 2850,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    weights = list(map(int, stdin.split()))\n    max_weight = max(weights)\n    min_weight = max_weight\n    for i in range(n):\n        if i % k == 0:\n            min_weight = min(min_weight, weights[i])\n        else:\n            min_weight = min(min_weight, weights[i] + min_weight)\n    return str(min_weight)"
    },
    {
        "number": 2851,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    m, *b = map(int, stdin.split())\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def product(arr: list[int]) -> int:\n        return reduce(lambda x, y: x * y, arr)\n\n    def last_n_digits(num: int, n: int) -> int:\n        return num % (10 ** n)\n\n    def main() -> str:\n        a_product = product(a)\n        b_product = product(b)\n\n        gcd_ab = gcd(a_product, b_product)\n        gcd_ab_digits = len(str(gcd_ab))\n\n        if gcd_ab_digits > 9:\n            gcd_ab = last_n_digits(gcd_ab, 9)\n\n        return str(gcd_ab)\n\n    return main()"
    },
    {
        "number": 2852,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *probs = map(int, stdin.split())\n    probs = [p / 100 for p in probs]\n\n    def expected_index(accepted: int, rejected: int) -> float:\n        if accepted == 0:\n            return 0\n        return (accepted / (accepted + rejected)) ** (accepted / (accepted + rejected))\n\n    max_index = 0\n    max_value = 0\n\n    for p in probs:\n        accepted = 0\n        rejected = 0\n        for _ in range(n):\n            if random.random() < p:\n                accepted += 1\n            else:\n                rejected += 1\n\n        index = expected_index(accepted, rejected)\n        if index > max_index:\n            max_index = index\n            max_value = p\n\n    return f\"{max_value:.6f}\"\n\nimport random"
    },
    {
        "number": 2853,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cables = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        cables.add((a, b))\n        cables.add((b, a))\n\n    connected = set()\n    for a, b in cables:\n        if a in connected and b in connected:\n            connected.add(a)\n            connected.add(b)\n        elif a not in connected and b in connected:\n            connected.add(a)\n        elif a in connected and b not in connected:\n            connected.add(b)\n\n    if len(connected) == n:\n        return \"Connected\"\n    else:\n        return \"\\n\".join(map(str, sorted(connected)))"
    },
    {
        "number": 2854,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    atoms = [tuple(map(int, stdin.split())) for _ in range(n)]\n    bonds = [tuple(map(int, stdin.split())) for _ in range(m)]\n\n    def find_neighbors(atom):\n        return [a for a in atoms if a!= atom and a[0] == atom[0] or a[1] == atom[1]]\n\n    def find_average_coordinates(neighbors):\n        x = sum(a[0] for a in neighbors) / len(neighbors)\n        y = sum(a[1] for a in neighbors) / len(neighbors)\n        return x, y\n\n    def is_valid_solution(coordinates):\n        for atom, (x, y) in zip(atoms, coordinates):\n            if x == -1 or y == -1:\n                continue\n            for neighbor in find_neighbors(atom):\n                if abs(x - neighbor[0]) > 10e-3 or abs(y - neighbor[1]) > 10e-3:\n                    return False\n        return True\n\n    def bfs(start):\n        queue = [start]\n        visited = set()\n        while queue:\n            current = queue.pop(0)\n            visited.add(current)\n            for neighbor in find_neighbors(current):\n                if neighbor not in visited:\n                    queue.append(neighbor)\n        return visited\n\n    def dfs(start):\n        visited = set()\n        stack = [start]\n        while stack:\n            current = stack.pop()\n            visited.add(current)\n            for neighbor in find_neighbors(current):\n                if neighbor not in visited:\n                    stack.append(neighbor)\n        return visited\n\n    def dfs_with_neighbors(start):\n        visited = set()\n        stack = [start]\n        while stack:\n            current = stack.pop()\n            visited.add(current)\n            for neighbor in find_neighbors(current):\n                if neighbor not in visited:\n                    stack.append(neighbor)\n        return visited, find_neighbors(start)\n\n    def dfs_with_neighbors_and_average_coordinates(start):\n        visited, neighbors = dfs_with_neighbors(start)\n        return visited, neighbors, find_average_coordinates(neighbors)\n\n    def dfs_with_neighbors_and_average_coordinates_and_bfs(start):\n        visited, neighbors, average_coordinates = dfs_with_neighbors_and_average_coordinates(start)\n        return visited, neighbors, average_coordinates, bfs(average_coordinates)\n\n    def dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs(start):\n        visited, neighbors, average_coordinates, bfs_result = dfs_with_neighbors_and_average_coordinates_and_bfs(start)\n        return visited, neighbors, average_coordinates, bfs_result, dfs(average_coordinates)\n\n    def dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs_with_neighbors(start):\n        visited, neighbors, average_coordinates, bfs_result, dfs_result = dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs(start)\n        return visited, neighbors, average_coordinates, bfs_result, dfs_result, find_neighbors(average_coordinates)\n\n    def dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs_with_neighbors_and_dfs(start):\n        visited, neighbors, average_coordinates, bfs_result, dfs_result, neighbors_of_average_coordinates = dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs_with_neighbors(start)\n        return visited, neighbors, average_coordinates, bfs_result, dfs_result, neighbors_of_average_coordinates, dfs(neighbors_of_average_coordinates)\n\n    def dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs_with_neighbors_and_dfs_with_neighbors(start):\n        visited, neighbors, average_coordinates, bfs_result, dfs_result, neighbors_of_average_coordinates, dfs_result_of_neighbors_of_average_coordinates = dfs_with_neighbors_and_average_coordinates_and_bfs_and_dfs_with_neighbors_and_dfs(start)\n        return visited, neighbors, average_coordinates, bfs_result, dfs_result, neighbors_of_average_coordinates, dfs_result_of_neighbors_of_average_coordinates, find_neighbors(neighbors_of_average_coordinates)\n\n    def dfs_with_neighbors_and_average_coordinates_and_bfs_and_"
    },
    {
        "number": 2855,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    paths = []\n    for _ in range(m):\n        k, l = map(int, stdin.split())\n        paths.append((k, l))\n\n    def bfs(start: int, visited: set) -> int:\n        queue = [(start, 0)]\n        while queue:\n            current, minutes = queue.pop(0)\n            if current == n - 1:\n                return minutes\n            if current in visited:\n                continue\n            visited.add(current)\n            for k, l in paths:\n                if k == current:\n                    queue.append((l, minutes + 1))\n        return -1\n\n    visited = set()\n    minutes = 0\n    while minutes < 1000000:\n        minutes += 1\n        minutes_left = bfs(0, visited)\n        if minutes_left!= -1:\n            break\n\n    return str(minutes)"
    },
    {
        "number": 2856,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    sequence = list(stdin.split()[1])\n    mutations = 0\n\n    for i in range(N):\n        if sequence[i] == 'A':\n            sequence[i] = 'B'\n            mutations += 1\n        elif sequence[i] == 'B':\n            sequence[i] = 'A'\n            mutations += 1\n\n    for i in range(1, N):\n        if sequence[i] == 'A':\n            sequence[i] = 'B'\n            mutations += 1\n        elif sequence[i] == 'B':\n            sequence[i] = 'A'\n            mutations += 1\n\n    return str(mutations)"
    },
    {
        "number": 2857,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[1:])\n        points.append((x, y))\n\n    def is_right_triangle(a, b, c):\n        return a + b > c and a + c > b and b + c > a\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_right_triangle(points[i][0] - points[j][0], points[i][1] - points[j][1], points[i][0] - points[k][0]):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 2858,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    accused_by = [int(x) - 1 for x in stdin.split()[1:]]\n\n    def dfs(player, visited):\n        if player in visited:\n            return 0\n        visited.add(player)\n\n        if player == K:\n            return 1\n\n        max_mobsters = 0\n        for accuser in accused_by:\n            if accuser == player:\n                continue\n            max_mobsters = max(max_mobsters, dfs(accuser, visited))\n\n        return max_mobsters + 1\n\n    return str(dfs(0, set()))"
    },
    {
        "number": 2859,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3, xv, yv, r = map(int, stdin.split())\n    r = r ** 2\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def distance_to_line(x, y, x1, y1, x2, y2):\n        return distance(x, y, x1, y1) * distance(x1, y1, x2, y2) / distance(x2, y2, x1, y1) ** 2\n\n    def distance_to_circle(x, y, cx, cy, r):\n        return distance(x, y, cx, cy) ** 2 - r\n\n    def is_colliding(x1, y1, x2, y2, x3, y3):\n        return distance_to_line(x1, y1, x2, y2, x3, y3) <= r\n\n    def is_colliding_with_circle(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r\n\n    def is_colliding_with_circle_and_tangent(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r + distance_to_line(x1, y1, cx, cy, x1, y1)\n\n    def is_colliding_with_circle_and_tangent_and_tangent(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1)\n\n    def is_colliding_with_circle_and_tangent_and_tangent_and_tangent(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1)\n\n    def is_colliding_with_circle_and_tangent_and_tangent_and_tangent_and_tangent(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1)\n\n    def is_colliding_with_circle_and_tangent_and_tangent_and_tangent_and_tangent_and_tangent(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1) + distance_to_line(x1, y1, cx, cy, x1, y1)\n\n    def is_colliding_with_circle_and_tangent_and_tangent_and_tangent_and_tangent_and_tangent_and_tangent(x1, y1, cx, cy, r):\n        return distance_to_circle(x1, y1, cx, cy, r) <= r + distance_to_line(x1, y1,"
    },
    {
        "number": 2860,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, w = map(int, stdin.split())\n    lines = stdin.split('\\n')\n    result = 0\n    for line in lines:\n        words = line.split('.')\n        current_line = ''\n        for word in words:\n            if len(current_line) + len(word) + 1 <= w:\n                current_line += word + '.'\n            else:\n                result += 1\n                current_line = word + '.'\n        if current_line:\n            result += 1\n    return str(result)"
    },
    {
        "number": 2861,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    routines = [list(set(line.strip())) for line in stdin.split('\\n')]\n    min_quick_changes = float('inf')\n\n    for i in range(len(routines) - 1):\n        for j in range(i + 1, len(routines)):\n            if len(routines[i]) > 1 and len(routines[j]) > 1:\n                min_quick_changes = min(min_quick_changes, len(routines[i]) + len(routines[j]) - 2)\n\n    return str(min_quick_changes)"
    },
    {
        "number": 2862,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    materials = list(map(int, stdin.split()))\n    crafting_dependencies = []\n\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        crafting_dependencies.append((u, v, w))\n\n    def dfs(u, visited):\n        visited.add(u)\n        for v, w in crafting_dependencies:\n            if v not in visited:\n                if w <= materials[u]:\n                    materials[u] -= w\n                    materials[v] += w\n                    dfs(v, visited)\n                    materials[u] += w\n                    materials[v] -= w\n\n    dfs(0, set())\n\n    return \" \".join(map(str, materials))"
    },
    {
        "number": 2863,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_dislikes(likes: List[int], dislikes: List[int]) -> int:\n        count = 0\n        for i in range(len(likes)):\n            if likes[i] in dislikes:\n                count += 1\n        return count\n\n    def max_films(likes: List[int], dislikes: List[int]) -> int:\n        max_likes = max(likes)\n        max_dislikes = max(dislikes)\n        return max_likes + max_dislikes\n\n    likes, dislikes = map(list, stdin.split())\n    likes = [int(x) for x in likes]\n    dislikes = [int(x) for x in dislikes]\n\n    max_likes = max_films(likes, dislikes)\n    max_dislikes = max_films(dislikes, likes)\n\n    return str(max(max_likes, max_dislikes))"
    },
    {
        "number": 2864,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    cards = list(stdin.split()[1])\n    suggestions = []\n    for _ in range(n):\n        suggestion = stdin.split()[2:]\n        suggestions.append(suggestion)\n\n    murderer, murder_weapon, murder_location = cards[:3]\n    murderer_index = cards.index(murderer)\n    murder_weapon_index = cards.index(murder_weapon)\n    murder_location_index = cards.index(murder_location)\n\n    def get_player_index(player_name: str) -> int:\n        return cards.index(player_name)\n\n    def get_player_cards(player_index: int) -> list:\n        return cards[player_index + 1:]\n\n    def get_player_suggestions(player_index: int) -> list:\n        return suggestions[player_index]\n\n    def get_player_evidence(player_index: int) -> str:\n        return suggestions[player_index][-1]\n\n    def get_player_cards_with_evidence(player_index: int) -> list:\n        return [card for card in get_player_cards(player_index) if get_player_evidence(player_index) == card]\n\n    def get_player_cards_without_evidence(player_index: int) -> list:\n        return [card for card in get_player_cards(player_index) if get_player_evidence(player_index)!= card]\n\n    def get_player_cards_with_suggestion(player_index: int) -> list:\n        return [card for card in get_player_cards(player_index) if card in get_player_suggestions(player_index)]\n\n    def get_player_cards_without_suggestion(player_index: int) -> list:\n        return [card for card in get_player_cards(player_index) if card not in get_player_suggestions(player_index)]\n\n    def get_player_cards_with_suggestion_and_evidence(player_index: int) -> list:\n        return [card for card in get_player_cards_with_suggestion(player_index) if get_player_evidence(player_index) == card]\n\n    def get_player_cards_without_suggestion_and_evidence(player_index: int) -> list:\n        return [card for card in get_player_cards_without_suggestion(player_index) if get_player_evidence(player_index)!= card]\n\n    def get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence(player_index: int) -> list:\n        return get_player_cards_with_suggestion_and_evidence(player_index) + get_player_cards_without_suggestion_and_evidence(player_index)\n\n    def get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence_or_no_cards(player_index: int) -> list:\n        return get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence(player_index) + get_player_cards_without_suggestion_and_evidence_or_no_cards(player_index)\n\n    def get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence_or_no_cards_or_no_suggestions(player_index: int) -> list:\n        return get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence_or_no_cards(player_index) + get_player_cards_without_suggestion_and_evidence_or_no_cards_or_no_suggestions(player_index)\n\n    def get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence_or_no_cards_or_no_suggestions_or_no_evidence(player_index: int) -> list:\n        return get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence_or_no_cards_or_no_suggestions(player_index) + get_player_cards_without_suggestion_and_evidence_or_no_cards_or_no_suggestions_or_no_evidence(player_index)\n\n    def get_player_cards_with_suggestion_and_evidence_or_without_suggestion_and_evidence_or_no_cards_or_no_suggestions_or_no_evidence_or_no_cards"
    },
    {
        "number": 2865,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X1, X2 = map(int, stdin.split())\n    N1, *T1 = map(int, stdin.split())\n    N2, *T2 = map(int, stdin.split())\n\n    def get_speed(t: int) -> int:\n        if t < T1[0]:\n            return 1\n        elif t < T1[-1]:\n            return 1 + (t - T1[0]) * (1 - 1) / (T1[-1] - T1[0])\n        else:\n            return 0\n\n    def get_position(t: int) -> int:\n        if t < T1[0]:\n            return X1\n        elif t < T1[-1]:\n            return X1 + (t - T1[0]) * (X2 - X1) / (T1[-1] - T1[0])\n        else:\n            return X2\n\n    def get_speed_change(t: int) -> int:\n        if t < T1[0]:\n            return 1\n        elif t < T1[-1]:\n            return 1 + (t - T1[0]) * (1 - 1) / (T1[-1] - T1[0])\n        elif t < T2[0]:\n            return 0\n        elif t < T2[-1]:\n            return 0 + (t - T2[0]) * (1 - 1) / (T2[-1] - T2[0])\n        else:\n            return 1\n\n    def get_position_change(t: int) -> int:\n        if t < T1[0]:\n            return 0\n        elif t < T1[-1]:\n            return (t - T1[0]) * (X2 - X1) / (T1[-1] - T1[0])\n        elif t < T2[0]:\n            return 0\n        elif t < T2[-1]:\n            return (t - T2[0]) * (X2 - X1) / (T2[-1] - T2[0])\n        else:\n            return 0\n\n    def collide(t1: int, t2: int) -> bool:\n        return get_speed(t1)!= get_speed(t2) and get_position(t1)!= get_position(t2)\n\n    def get_collision_time(t1: int, t2: int) -> int:\n        if get_speed(t1)!= get_speed(t2):\n            return min(t1, t2)\n        else:\n            return max(t1, t2)\n\n    def get_safe_sound_time(t1: int, t2: int) -> int:\n        if get_speed(t1)!= get_speed(t2):\n            return max(t1, t2)\n        else:\n            return min(t1, t2)\n\n    collision_time = None\n    safe_sound_time = None\n\n    for t1, t2 in zip(T1, T2):\n        if collide(t1, t2):\n            if collision_time is None or collision_time > get_collision_time(t1, t2):\n                collision_time = get_collision_time(t1, t2)\n        else:\n            if safe_sound_time is None or safe_sound_time < get_safe_sound_time(t1, t2):\n                safe_sound_time = get_safe_sound_time(t1, t2)\n\n    if collision_time is not None:\n        return f\"bumper tap at time {collision_time}\"\n    else:\n        return \"safe and sound\""
    },
    {
        "number": 2866,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = list(map(int, stdin))\n    n = len(digits)\n    max_num = 10 ** n\n    for i in range(1, max_num):\n        if all(digits[j]!= i % 10 for j in range(n)):\n            return str(i)\n    return \"1\""
    },
    {
        "number": 2867,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *v, *c = map(int, stdin.split())\n    happiness = [0] * n\n    for i in range(n):\n        happiness[i] = sum(v[:i+1]) + sum(v[i+1:])\n    max_happiness = max(happiness)\n    return str(max_happiness)"
    },
    {
        "number": 2868,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, word = map(int, stdin.split())\n    blink_count = 0\n    result = \"\"\n\n    for i in range(len(word)):\n        if blink_count % 2 == 0:\n            result += word[i]\n        else:\n            if i == 0:\n                result += word[i]\n            elif i == len(word) - 1:\n                result += word[i]\n            else:\n                result += word[i] + word[i - 1]\n\n    return result"
    },
    {
        "number": 2869,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    roman_to_int = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n    int_to_roman = {1: 'I', 5: 'V', 10: 'X', 50: 'L', 100: 'C', 500: 'D', 1000: 'M'}\n    roman_num = ''\n    for char in stdin:\n        if char in roman_to_int:\n            roman_num += char\n        elif char in int_to_roman:\n            roman_num += int_to_roman[roman_to_int[char]]\n    return roman_num"
    },
    {
        "number": 2870,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    max_diff = 0\n    for i in range(1, p + 1):\n        for j in range(1, q + 1):\n            if i % 2 == 0 and j % 2 == 0:\n                max_diff = max(max_diff, 1)\n            elif i % 2 == 1 and j % 2 == 1:\n                max_diff = max(max_diff, -1)\n    return str(max_diff)"
    },
    {
        "number": 2871,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n    v.sort(reverse=True)\n    return str(sum(v[:k]))"
    },
    {
        "number": 2872,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input into day and month\n    day, month = stdin.split()\n    # Convert the month to its integer representation\n    month_int = {\n        'JAN': 1,\n        'FEB': 2,\n        'MAR': 3,\n        'APR': 4,\n        'MAY': 5,\n        'JUN': 6,\n        'JUL': 7,\n        'AUG': 8,\n        'SEP': 9,\n        'OCT': 10,\n        'NOV': 11,\n        'DEC': 12\n    }\n    month_int = month_int[month]\n    # Calculate the day of the year\n    day_of_year = (int(day) + month_int) % 365\n    # Check if the day of the year is a Friday\n    if day_of_year % 7 == 4:\n        return 'TGIF'\n    # Check if the year has a 29th of February\n    if month_int == 2 and day_of_year % 7 == 1:\n        return 'TGIF'\n    # If none of the above conditions are met, it's not Friday\n    return ':('"
    },
    {
        "number": 2873,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOU\"\n    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    vowel_count = 0\n    consonant_count = 0\n    consecutive_vowels = 0\n    consecutive_consonants = 0\n    has_l = False\n\n    for char in stdin:\n        if char in vowels:\n            vowel_count += 1\n            consecutive_vowels = 0\n        elif char in consonants:\n            consonant_count += 1\n            consecutive_consonants = 0\n        elif char == \"_\":\n            has_l = True\n\n        if consecutive_vowels == 3 and consecutive_consonants == 3 and has_l:\n            vowel_count -= 1\n            consonant_count -= 1\n            consecutive_vowels = 0\n            consecutive_consonants = 0\n            has_l = False\n\n    return str(vowel_count + consonant_count)\n"
    },
    {
        "number": 2874,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    positions = [list(map(int, stdin.split())) for _ in range(n)]\n    trees = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def closest_tree(person):\n        closest = float('inf')\n        for tree in trees:\n            if abs(tree[0] - person[0]) < closest:\n                closest = abs(tree[0] - person[0])\n        return closest\n\n    def can_claim(person):\n        closest_tree_distance = closest_tree(person)\n        for tree in trees:\n            if abs(tree[0] - person[0]) == closest_tree_distance:\n                return False\n        return True\n\n    won_trees = 0\n    for person in positions:\n        if can_claim(person):\n            won_trees += 1\n\n    return str(won_trees)"
    },
    {
        "number": 2875,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *v = map(int, stdin.split())\n    v.sort()\n    for i in range(len(v) - 1):\n        if v[i] == v[i + 1]:\n            return \"impossible\"\n    for i in range(len(v) - 1):\n        if v[i] == v[i + 1]:\n            return f\"{i + 1} {i + 2}\"\n    return \"impossible\""
    },
    {
        "number": 2876,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = []\n    for _ in range(n):\n        x, z = map(int, stdin.split()[1:])\n        points.append((x, z))\n    points.sort(key=lambda x: x[0])\n\n    def f(x):\n        return sum(z * (x - xi) for xi, z in points)\n\n    def g(x):\n        return sum(z * (x - xi) for xi, z in points)\n\n    def h(x):\n        return sum(z * (x - xi) for xi, z in points)\n\n    def lipschitz_constant(f, g, h):\n        return max(abs(f(x) - g(x)), abs(f(x) - h(x)), abs(g(x) - h(x)))\n\n    return str(lipschitz_constant(f, g, h))\n"
    },
    {
        "number": 2877,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip().lower()\n    if len(word) < 3 or len(word) > 50:\n        return \"Invalid input\"\n\n    # Split the word into three parts\n    parts = [word[i:i+3] for i in range(0, len(word), 3)]\n\n    # Reverse the order of the letters in each part\n    parts = [part[::-1] for part in parts]\n\n    # Join the parts back together\n    result = ''.join(parts)\n\n    return result"
    },
    {
        "number": 2878,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n\n    triplets = 0\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '.':\n                continue\n            for k in range(N):\n                if grid[i][k] == '.' or grid[k][j] == '.' or grid[i][j] == grid[k][k]:\n                    continue\n                if grid[i][k] == grid[k][j]:\n                    if grid[i][j] == grid[k][k]:\n                        triplets += 1\n\n    return str(triplets)"
    },
    {
        "number": 2879,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    matrix = [list(row) for row in stdin.split()[1:]]\n\n    def is_valid(matrix, i, j, k):\n        for x in range(i, i + k):\n            for y in range(j, j + k):\n                if matrix[x][y] == 'X':\n                    return False\n        return True\n\n    def dfs(matrix, i, j, k, result):\n        if k == 1:\n            result.append(''.join(matrix[i][j:j+k]))\n            return\n        for x in range(i, h - k + 1):\n            for y in range(j, w - k + 1):\n                if matrix[x][y] == '.' and is_valid(matrix, x, y, k):\n                    matrix[x][y] = 'X'\n                    dfs(matrix, x, y, k, result)\n                    matrix[x][y] = '.'\n\n    result = []\n    dfs(matrix, 0, 0, 1, result)\n    if not result:\n        return \"No solution\"\n    return '\\n'.join([''.join(row) for row in result])"
    },
    {
        "number": 2880,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    matrix = [list(row) for row in stdin.splitlines()]\n\n    # Find the maximum number of rows that can be deleted\n    max_rows = 0\n    for i in range(R):\n        if matrix[i]!= matrix[0]:\n            max_rows += 1\n\n    return str(max_rows)"
    },
    {
        "number": 2881,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(str.split, stdin.split())\n    x = [int(digit) for digit in x]\n    y = [int(digit) for digit in y]\n\n    if len(x)!= len(y):\n        return \"no\"\n\n    for i in range(len(x)):\n        if x[i] == y[i]:\n            continue\n        if x[i] < y[i]:\n            x[i], y[i] = y[i], x[i]\n            break\n        else:\n            x[i], y[i] = y[i], x[i]\n            break\n\n    return \"yes\" if x == y else \"no\""
    },
    {
        "number": 2882,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = []\n    def backtrack(start: int, current: str, left: int, right: int):\n        if left == 0 and right == 0:\n            result.append(current)\n            return\n        if left > 0:\n            backtrack(start + 1, current + \"(\", left - 1, right)\n        if right > left:\n            backtrack(start + 1, current + \")\", left, right - 1)\n    backtrack(0, \"\", n, n)\n    return result"
    },
    {
        "number": 2883,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.split('\\n'):\n        start, end = map(int, line.split())\n        intervals.append((start, end))\n\n    merged_intervals = []\n    for i in range(len(intervals)):\n        if not merged_intervals or merged_intervals[-1][1] < intervals[i][0]:\n            merged_intervals.append(intervals[i])\n        else:\n            merged_intervals[-1] = (merged_intervals[-1][0], max(merged_intervals[-1][1], intervals[i][1]))\n\n    return '\\n'.join(f'{start} {end}' for start, end in merged_intervals)"
    },
    {
        "number": 2884,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    candidates = list(map(int, stdin.split()))\n    target = int(stdin.split()[1])\n\n    def backtrack(start, current_sum, current_combination):\n        if current_sum == target:\n            result.append(current_combination[:])\n            return\n\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i - 1]:\n                continue\n            current_combination.append(candidates[i])\n            backtrack(i + 1, current_sum + candidates[i], current_combination)\n            current_combination.pop()\n\n    result = []\n    backtrack(0, 0, [])\n    return str(result)"
    },
    {
        "number": 2885,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = [list(map(int, x.split())) for x in stdin.split('\\n')[:-1]]\n    new_interval = list(map(int, stdin.split('\\n')[-1].split()))\n\n    merged_intervals = []\n    i = 0\n    j = 0\n\n    while i < len(intervals) and j < len(new_interval):\n        if intervals[i][1] < new_interval[0]:\n            merged_intervals.append(intervals[i])\n            i += 1\n        elif intervals[i][0] > new_interval[1]:\n            merged_intervals.append(new_interval)\n            j += 1\n        else:\n            merged_intervals.append([min(intervals[i][0], new_interval[0]), max(intervals[i][1], new_interval[1])])\n            i += 1\n            j += 1\n\n    while i < len(intervals):\n        merged_intervals.append(intervals[i])\n        i += 1\n\n    while j < len(new_interval):\n        merged_intervals.append(new_interval)\n        j += 1\n\n    return '\\n'.join([' '.join(map(str, x)) for x in merged_intervals])"
    },
    {
        "number": 2886,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 2:\n        return -1, -1\n\n    n = len(s)\n    count = [0] * 26\n    for c in s:\n        count[ord(c) - ord('a')] += 1\n\n    same_count = sum(1 for c in count if count.count(c) == 1)\n    if same_count > n // 2:\n        return -1, -1\n\n    for i in range(n):\n        if count[i] == 1:\n            continue\n        for j in range(i + 1, n):\n            if count[j] == 1:\n                continue\n            if count[i] == count[j]:\n                return i + 1, j + 1\n\n    return -1, -1\n"
    },
    {
        "number": 2887,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *v, *t = map(int, stdin.split())\n    volumes = [0] * n\n    temps = [0] * n\n    for i in range(n):\n        volumes[i] = v[i]\n        temps[i] = t[i]\n\n    for i in range(n):\n        volumes[i] -= volumes[i] * temps[i] / 100\n        if volumes[i] < 0:\n            volumes[i] = 0\n\n    return \" \".join(map(str, volumes))"
    },
    {
        "number": 2888,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sin = map(int, stdin.split())\n    e = list(map(int, stdin.split()))\n\n    def train_or_battle(strength, experience):\n        if experience == 0:\n            return 0\n        else:\n            return strength + (1 if experience > 0 else -1) * (experience ** 3)\n\n    def max_xv(strength, experience):\n        max_xv = 0\n        for i in range(n):\n            if i == 0:\n                if experience > 0:\n                    max_xv = train_or_battle(strength, experience)\n            else:\n                if experience > 0:\n                    max_xv = max(max_xv, train_or_battle(strength, experience))\n                else:\n                    max_xv = max(max_xv, train_or_battle(strength, experience) + e[i - 1] * experience)\n        return max_xv\n\n    return str(max_xv(sin, 0))"
    },
    {
        "number": 2889,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mowers = []\n    for _ in range(m):\n        name, price, cut_rate, cut_time, recharge_time = map(int, stdin.split())\n        mowers.append((name, price, cut_rate, cut_time, recharge_time))\n    mowers.sort(key=lambda x: (x[1], x[2], x[3], x[4]))\n    cheapest_mower = mowers[0][0]\n    return cheapest_mower"
    },
    {
        "number": 2890,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, int, int, List[Tuple[int, int, int, int]]]:\n        N, M, k1, k2 = map(int, stdin.split())\n        edges = []\n        for _ in range(M):\n            u, v, x, c = map(int, stdin.split())\n            edges.append((u, v, x, c))\n        S, T = map(int, stdin.split())\n        return N, M, k1, k2, edges, S, T\n\n    def bellman_ford(N: int, edges: List[Tuple[int, int, int, int]]) -> int:\n        dist = [float('inf')] * (N + 1)\n        dist[1] = 0\n        for _ in range(N - 1):\n            for u, v, x, c in edges:\n                if dist[u]!= float('inf') and dist[u] + x < dist[v]:\n                    dist[v] = dist[u] + x\n        for u, v, x, c in edges:\n            if dist[u]!= float('inf') and dist[u] + x < dist[v]:\n                return -1\n        return dist[T]\n\n    def min_time(N: int, edges: List[Tuple[int, int, int, int]], k1: int, k2: int, S: int, T: int) -> int:\n        dist = bellman_ford(N, edges)\n        if dist == -1:\n            return -1\n        min_time = float('inf')\n        for u, v, x, c in edges:\n            if dist[u]!= float('inf') and dist[u] + x < dist[v]:\n                min_time = min(min_time, dist[u] + x)\n        return min_time\n\n    N, M, k1, k2, edges, S, T = read_input()\n    result = min_time(N, edges, k1, k2, S, T)\n    if result == -1:\n        print(-1)\n    else:\n        print(result)\n"
    },
    {
        "number": 2891,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    p = sum(c)\n    if p > n:\n        return \"0\"\n\n    def choose(n, k):\n        if n == k:\n            return 1\n        if n < k:\n            return 0\n        return choose(n - 1, k - 1) * (n - k + 1) // k\n\n    def binomial(n, k):\n        return choose(n, k) * choose(n, n - k)\n\n    def shared_birthdays(people):\n        return binomial(n, people)\n\n    def probability(people):\n        return shared_birthdays(people) / binomial(n, p)\n\n    return f\"{-1 * probability(p):.6f}\""
    },
    {
        "number": 2892,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sizes = map(int, stdin.split())\n    sizes.sort()\n    openings = 0\n    current_group = []\n    for size in sizes:\n        if size == current_group[-1] + 1:\n            current_group.append(size)\n        else:\n            openings += len(current_group)\n            current_group = [size]\n    openings += len(current_group)\n    return str(openings)"
    },
    {
        "number": 2893,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def quicksort(arr, low, high):\n        if low < high:\n            pivot_index = partition(arr, low, high)\n            quicksort(arr, low, pivot_index)\n            quicksort(arr, pivot_index + 1, high)\n\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    def ultra_quicksort(arr, low, high):\n        if low < high:\n            pivot_index = partition(arr, low, high)\n            ultra_quicksort(arr, low, pivot_index)\n            ultra_quicksort(arr, pivot_index + 1, high)\n\n    def count_swaps(arr, low, high):\n        count = 0\n        for i in range(low, high):\n            if arr[i] > arr[i + 1]:\n                count += 1\n        return count\n\n    quicksort(a, 0, len(a) - 1)\n    ultra_quicksort(a, 0, len(a) - 1)\n    count = count_swaps(a, 0, len(a) - 1)\n    print(count)\n    return \"\"\n"
    },
    {
        "number": 2894,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, K, T1, T2, H = map(float, stdin.split())\n\n    # Calculate the time it takes for the water to reach the leak\n    leak_time = L / K\n\n    # Calculate the time it takes for the water to evaporate\n    evaporation_time = T1\n\n    # Calculate the time it takes for the water to reach the tube\n    tube_time = T2\n\n    # Calculate the time it takes for the water to reach the observation height\n    observation_time = H\n\n    # Calculate the total time it takes for the rain to fall\n    total_time = leak_time + evaporation_time + tube_time + observation_time\n\n    # Calculate the rainfall during the rainfall\n    rainfall = total_time * K\n\n    # Calculate the smallest and largest rainfalls that would result in the given observation\n    smallest_rainfall = rainfall - observation_time * K\n    largest_rainfall = rainfall + observation_time * K\n\n    return f\"{smallest_rainfall:.6f} {largest_rainfall:.6f}\""
    },
    {
        "number": 2895,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, x_f, y_f, n = map(float, stdin.split())\n    layers = []\n    for _ in range(n - 1):\n        y1, y2 = map(float, stdin.split())\n        layers.append(((-10000, 10000), (y1, y2)))\n    speeds = list(map(float, stdin.split()))\n    x_start, y_start = x_s, y_s\n    x_end, y_end = x_f, y_f\n    time = 0\n    for layer, speed in zip(layers, speeds):\n        x_start, y_start = layer[0][0], layer[0][1]\n        x_end, y_end = layer[1][0], layer[1][1]\n        time += (x_end - x_start) / speed\n    return str(time)"
    },
    {
        "number": 2896,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    before, after = stdin.split('\\n')\n    before_seq = before.upper()\n    after_seq = after.upper()\n\n    # Find the length of the smallest single, consecutive piece of DNA that can have been inserted into the first sequence to turn it into the second one\n    min_length = float('inf')\n    for i in range(len(before_seq)):\n        for j in range(i + 1, len(before_seq) + 1):\n            if before_seq[i:j] == after_seq[i:j]:\n                min_length = min(min_length, j - i)\n\n    return str(min_length)"
    },
    {
        "number": 2897,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    map_ = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    n = int(stdin.splitlines()[1])\n    queries = [tuple(map(int, line.split())) for line in stdin.splitlines()[2:]]\n\n    def is_binary_friendly(r: int, c: int) -> bool:\n        return map_[r - 1][c - 1] == 0\n\n    def is_decimal_friendly(r: int, c: int) -> bool:\n        return map_[r - 1][c - 1] == 1\n\n    def is_valid_move(r1: int, c1: int, r2: int, c2: int) -> bool:\n        return (r1, c1)!= (r2, c2) and (r1 - r2) ** 2 + (c1 - c2) ** 2 == 1\n\n    def is_valid_move_binary(r1: int, c1: int, r2: int, c2: int) -> bool:\n        return is_valid_move(r1, c1, r2, c2) and is_binary_friendly(r1, c1)\n\n    def is_valid_move_decimal(r1: int, c1: int, r2: int, c2: int) -> bool:\n        return is_valid_move(r1, c1, r2, c2) and is_decimal_friendly(r1, c1)\n\n    result = []\n    for query in queries:\n        r1, c1, r2, c2 = query\n        if is_valid_move_binary(r1, c1, r2, c2):\n            result.append(\"binary\")\n        elif is_valid_move_decimal(r1, c1, r2, c2):\n            result.append(\"decimal\")\n        else:\n            result.append(\"neither\")\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2898,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    capacities = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    capacities.sort(key=lambda x: x[0])\n    total_extra_capacity = 0\n    for i in range(n):\n        if i == 0:\n            total_extra_capacity += capacities[i][1] - capacities[i][0]\n        else:\n            total_extra_capacity += capacities[i][0] - capacities[i][1]\n    return str(total_extra_capacity)"
    },
    {
        "number": 2899,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    graph = [[] for _ in range(n + 1)]\n    for line in stdin.split()[1:]:\n        i, j = map(int, line.split())\n        graph[i].append(j)\n        graph[j].append(i)\n\n    def dfs(node, used_freqs):\n        nonlocal max_freqs\n        if node == n:\n            return used_freqs\n\n        for neighbor in graph[node]:\n            if neighbor not in used_freqs:\n                used_freqs.add(neighbor)\n                max_freqs = max(max_freqs, neighbor)\n                dfs(neighbor, used_freqs)\n                used_freqs.remove(neighbor)\n\n    max_freqs = 0\n    dfs(1, set())\n\n    return \" \".join(map(str, sorted(max_freqs)))\n"
    },
    {
        "number": 2900,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = list(stdin)\n    n = len(s)\n    count = [0] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == 'B' and s[j] == 'A' and j - i == 1:\n                count[i] += 1\n                count[j] += 1\n\n    for k in range(1, n):\n        for i in range(n - k):\n            j = i + k\n            if s[i] == 'B' and s[j] == 'A' and j - i == k:\n                count[i] += 1\n                count[j] += 1\n\n    return '\\n'.join(map(str, count))"
    },
    {
        "number": 2901,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    edges = [tuple(map(int, stdin.split()[i:i+2])) for i in range(0, n*2, 2)]\n    players = [tuple(map(str, stdin.split()[i+2:i+6])) for i in range(0, n*2, 6)]\n\n    def find_player(name: str) -> int:\n        for i, player in enumerate(players):\n            if player[0] == name:\n                return i\n        return -1\n\n    def find_team(name: str) -> int:\n        for i, player in enumerate(players):\n            if player[3] == name:\n                return i\n        return -1\n\n    def find_league(name: str) -> int:\n        for i, player in enumerate(players):\n            if player[2] == name:\n                return i\n        return -1\n\n    def find_country(name: str) -> int:\n        for i, player in enumerate(players):\n            if player[1] == name:\n                return i\n        return -1\n\n    def is_connected(a: int, b: int) -> bool:\n        for edge in edges:\n            if edge[0] == a and edge[1] == b or edge[0] == b and edge[1] == a:\n                return True\n        return False\n\n    def get_synergy(a: int, b: int) -> int:\n        if find_country(players[a][1]) == find_country(players[b][1]) and find_league(players[a][2]) == find_league(players[b][2]) and find_team(players[a][3]) == find_team(players[b][3]):\n            return 2\n        elif find_country(players[a][1]) == find_country(players[b][1]) and find_team(players[a][3]) == find_team(players[b][3]):\n            return 3\n        elif find_country(players[a][1]) == find_country(players[b][1]):\n            return 1\n        else:\n            return 0\n\n    def dfs(node: int, visited: set) -> int:\n        visited.add(node)\n        max_synergy = 0\n        for neighbor in range(10):\n            if not is_connected(node, neighbor) and neighbor not in visited:\n                synergy = get_synergy(node, neighbor)\n                if synergy > max_synergy:\n                    max_synergy = synergy\n        return max_synergy\n\n    def is_perfect_team(formation: list) -> bool:\n        visited = set()\n        for node in range(10):\n            if node not in visited:\n                max_synergy = dfs(node, visited)\n                if max_synergy < node:\n                    return False\n        return True\n\n    def get_perfect_team(formation: list) -> list:\n        visited = set()\n        for node in range(10):\n            if node not in visited:\n                max_synergy = dfs(node, visited)\n                if max_synergy == node:\n                    return [players[node]]\n        return []\n\n    perfect_teams = []\n    for formation in range(1, 10):\n        for i in range(10):\n            for j in range(i+1, 10):\n                if is_connected(i, j):\n                    formation_copy = formation.copy()\n                    formation_copy.remove(i)\n                    formation_copy.remove(j)\n                    perfect_teams.append(get_perfect_team(formation_copy))\n\n    perfect_teams = [team for team in perfect_teams if team]\n    perfect_teams.sort(key=lambda x: len(x), reverse=True)\n\n    for team in perfect_teams:\n        if is_perfect_team(team):\n            return \"yes\"\n\n    return \"no\""
    },
    {
        "number": 2902,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cows, farms, days = map(int, stdin.split())\n    cows_per_farm = [int(input()) for _ in range(farms)]\n    days_visited = [int(input()) for _ in range(days)]\n\n    def count_farms(cows: int, farms: int, days_visited: int) -> int:\n        if cows == 0:\n            return 0\n        if cows == 1:\n            return 1\n        if cows == 2:\n            return 2\n        if cows == 3:\n            return 3\n        if cows == 4:\n            return 4\n        if cows == 5:\n            return 5\n        if cows == 6:\n            return 6\n        if cows == 7:\n            return 7\n        if cows == 8:\n            return 8\n        if cows == 9:\n            return 9\n        if cows == 10:\n            return 10\n        if cows == 11:\n            return 11\n        if cows == 12:\n            return 12\n        if cows == 13:\n            return 13\n        if cows == 14:\n            return 14\n        if cows == 15:\n            return 15\n        if cows == 16:\n            return 16\n        if cows == 17:\n            return 17\n        if cows == 18:\n            return 18\n        if cows == 19:\n            return 19\n        if cows == 20:\n            return 20\n        if cows == 21:\n            return 21\n        if cows == 22:\n            return 22\n        if cows == 23:\n            return 23\n        if cows == 24:\n            return 24\n        if cows == 25:\n            return 25\n        if cows == 26:\n            return 26\n        if cows == 27:\n            return 27\n        if cows == 28:\n            return 28\n        if cows == 29:\n            return 29\n        if cows == 30:\n            return 30\n        if cows == 31:\n            return 31\n        if cows == 32:\n            return 32\n        if cows == 33:\n            return 33\n        if cows == 34:\n            return 34\n        if cows == 35:\n            return 35\n        if cows == 36:\n            return 36\n        if cows == 37:\n            return 37\n        if cows == 38:\n            return 38\n        if cows == 39:\n            return 39\n        if cows == 40:\n            return 40\n        if cows == 41:\n            return 41\n        if cows == 42:\n            return 42\n        if cows == 43:\n            return 43\n        if cows == 44:\n            return 44\n        if cows == 45:\n            return 45\n        if cows == 46:\n            return 46\n        if cows == 47:\n            return 47\n        if cows == 48:\n            return 48\n        if cows == 49:\n            return 49\n        if cows == 50:\n            return 50\n        if cows == 51:\n            return 51\n        if cows == 52:\n            return 52\n        if cows == 53:\n            return 53\n        if cows == 54:\n            return 54\n        if cows == 55:\n            return 55\n        if cows == 56:\n            return 56\n        if cows == 57:\n            return 57\n        if cows == 58:\n            return 58\n        if cows == 59:\n            return 59\n        if cows == 60:\n            return 60\n        if cows == 61:\n            return 61\n        if cows == 62:\n            return 62\n        if cows == 63:\n            return 63\n        if cows == 64:\n            return 64\n        if cows == 65:\n            return 65\n        if cows == 66:\n            return 66\n        if cows == 67:\n            return 67\n        if cows == 68:\n            return"
    },
    {
        "number": 2903,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    a = [0] * N\n    fenwick_tree = [0] * (N + 1)\n\n    for _ in range(Q):\n        op, i, delta = map(int, stdin.split())\n        if op == 1:\n            a[i] += delta\n            for j in range(i, N + 1):\n                fenwick_tree[j] += delta\n        elif op == 2:\n            print(fenwick_tree[i])\n        else:\n            print(fenwick_tree[0])\n\n    return \"\""
    },
    {
        "number": 2904,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows, cols = map(int, stdin.split())\n    grid = []\n    for _ in range(rows):\n        row = list(stdin.readline().strip())\n        grid.append(row)\n\n    regions = []\n    for _ in range(int(stdin.readline().strip())):\n        region_size = int(stdin.readline().strip())\n        region_cells = []\n        for _ in range(region_size):\n            region_cells.append(tuple(map(int, stdin.readline().strip()[1:-1].split(','))))\n        regions.append(region_cells)\n\n    def is_valid(cell, grid, regions):\n        row, col = cell\n        if grid[row][col]!= '-':\n            return False\n        for region in regions:\n            if (row, col) in region:\n                return False\n        return True\n\n    def dfs(cell, grid, regions, visited):\n        row, col = cell\n        if grid[row][col]!= '-':\n            return\n        visited.add((row, col))\n        for neighbor in [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]:\n            if neighbor in visited:\n                continue\n            if is_valid(neighbor, grid, regions):\n                dfs(neighbor, grid, regions, visited)\n\n    def solve(grid, regions):\n        visited = set()\n        for cell in [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == '-']:\n            dfs(cell, grid, regions, visited)\n        return grid\n\n    solved_grid = solve(grid, regions)\n    return''.join([''.join(row) for row in solved_grid])"
    },
    {
        "number": 2905,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, b = map(int, stdin.split())\n    h_packs = [int(x) for x in stdin.split()]\n    b_packs = [int(x) for x in stdin.split()]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def packs_needed(h_packs, b_packs):\n        h_needed = sum(h_packs)\n        b_needed = sum(b_packs)\n\n        if h_needed % 2 == 0 and b_needed % 2 == 0:\n            return 0\n\n        h_needed_even = h_needed // 2\n        b_needed_even = b_needed // 2\n\n        h_needed_odd = h_needed - h_needed_even\n        b_needed_odd = b_needed - b_needed_even\n\n        h_needed_even_packs = h_needed_even // 10\n        h_needed_odd_packs = h_needed_odd // 10\n\n        b_needed_even_packs = b_needed_even // 8\n        b_needed_odd_packs = b_needed_odd // 12\n\n        h_needed_even_buns = h_needed_even % 10\n        h_needed_odd_buns = h_needed_odd % 10\n\n        b_needed_even_buns = b_needed_even % 8\n        b_needed_odd_buns = b_needed_odd % 12\n\n        h_needed_even_packs = min(h_needed_even_packs, h_needed_odd_packs)\n        h_needed_odd_packs = min(h_needed_even_packs, h_needed_odd_packs)\n\n        b_needed_even_packs = min(b_needed_even_packs, b_needed_odd_packs)\n        b_needed_odd_packs = min(b_needed_even_packs, b_needed_odd_packs)\n\n        h_needed_even_buns = min(h_needed_even_buns, h_needed_odd_buns)\n        h_needed_odd_buns = min(h_needed_even_buns, h_needed_odd_buns)\n\n        b_needed_even_buns = min(b_needed_even_buns, b_needed_odd_buns)\n        b_needed_odd_buns = min(b_needed_even_buns, b_needed_odd_buns)\n\n        return h_needed_even_packs + h_needed_odd_packs + b_needed_even_packs + b_needed_odd_packs\n\n    result = packs_needed(h_packs, b_packs)\n\n    if result == 0:\n        return \"impossible\"\n    else:\n        return str(result)"
    },
    {
        "number": 2906,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    targets = [0] * (n + 1)\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            targets[i] = dfs(graph, i, visited)\n            if targets[i] == 0:\n                return \"Impossible\"\n    return \"\\n\".join(map(str, targets))\n\n\ndef"
    },
    {
        "number": 2907,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    O, message, N = map(int, stdin.split())\n    message = message.lower()\n    vowels = set('aeiouy')\n    encoded_message = ''\n    for _ in range(N):\n        encoded_message += ''.join(chr((ord(c) - ord('a') + O) % 26 + ord('a')) for c in message)\n    encoded_vowels = set(c for c in encoded_message if c in vowels)\n    if len(encoded_vowels) < len(vowels) / 2:\n        return 'Boris'\n    else:\n        return 'Colleague'"
    },
    {
        "number": 2908,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    cards.sort()\n    for i in range(n - 1):\n        if cards[i] + cards[i + 1] == s:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 2909,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    breads = list(map(int, stdin.split()))\n    boss_order = list(map(int, stdin.split()))\n\n    def rotate(breads: list, n: int) -> list:\n        result = []\n        for i in range(n):\n            result.append(breads.pop(0))\n        for i in range(n):\n            result.append(breads.pop(0))\n        return result\n\n    def is_sorted(breads: list) -> bool:\n        return breads == sorted(breads)\n\n    def is_valid_order(breads: list, boss_order: list) -> bool:\n        for i in range(len(breads)):\n            if breads[i]!= boss_order[i]:\n                return False\n        return True\n\n    def is_valid_rotation(breads: list, boss_order: list) -> bool:\n        for i in range(len(breads) - 2):\n            if breads[i]!= boss_order[i]:\n                return False\n        return True\n\n    def is_valid_permutation(breads: list, boss_order: list) -> bool:\n        return is_valid_order(breads, boss_order) or is_valid_rotation(breads, boss_order)\n\n    if is_valid_permutation(breads, boss_order):\n        return \"Possible\"\n    else:\n        return \"Impossible\""
    },
    {
        "number": 2910,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    A = list(map(int, stdin.split()[1].split()))\n    B = list(map(int, stdin.split()[2].split()))\n\n    total_area = [0, 0, 0]\n    for i in range(n):\n        for j in range(n):\n            total_area[(i + j) % 3] += A[i] * B[j]\n\n    return''.join(map(str, total_area))"
    },
    {
        "number": 2911,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    times = list(map(int, stdin.split()))\n    p = 1 / (t + 1)\n    count = 0\n    for i in range(n):\n        if i == 0 or times[i]!= times[i - 1]:\n            count += 1\n    return str((p * t ** count) % 998244353)"
    },
    {
        "number": 2912,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *operations = map(int, stdin.split())\n    strings = [\"\"] * n\n    for i, s in enumerate(stdin.split()[n:], start=n):\n        strings[i] = s\n\n    for a, b in operations:\n        strings[a - 1] += strings[b - 1]\n        strings[b - 1] = \"\"\n\n    return strings[-1]\n\n\ndef"
    },
    {
        "number": 2913,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split())\n    grid = [list(row) for row in stdin.splitlines()]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 1 <= x <= n and 1 <= y <= n and grid[x - 1][y - 1] == '.'\n\n    def is_mirror(x: int, y: int) -> bool:\n        return grid[x - 1][y - 1] in ['/', '\\\\']\n\n    def is_hit(x: int, y: int) -> bool:\n        return grid[x - 1][y - 1] == '/'\n\n    def is_empty(x: int, y: int) -> bool:\n        return grid[x - 1][y - 1] == '.'\n\n    def is_in_way(x: int, y: int) -> bool:\n        return any(is_hit(x + dx, y + dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)])\n\n    def is_valid_mirror(x: int, y: int) -> bool:\n        return is_valid(x, y) and is_mirror(x, y) and not is_in_way(x, y)\n\n    def is_valid_position(x: int, y: int) -> bool:\n        return is_valid(x, y) and not is_mirror(x, y) and not is_hit(x, y)\n\n    def is_valid_position_mirror(x: int, y: int) -> bool:\n        return is_valid_position(x, y) and is_valid_mirror(x, y)\n\n    def is_valid_position_mirror_hit(x: int, y: int) -> bool:\n        return is_valid_position_mirror(x, y) and is_hit(x, y)\n\n    def is_valid_position_mirror_empty(x: int, y: int) -> bool:\n        return is_valid_position_mirror(x, y) and is_empty(x, y)\n\n    def is_valid_position_mirror_empty_hit(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty(x, y) and is_hit(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit(x, y) and is_in_way(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way_mirror(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit_in_way(x, y) and is_mirror(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way_mirror_hit(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit_in_way_mirror(x, y) and is_hit(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit_in_way_mirror_hit(x, y) and is_mirror(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror_hit(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror(x, y) and is_hit(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror_hit_mirror(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror_hit(x, y) and is_mirror(x, y)\n\n    def is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror_hit_mirror_hit(x: int, y: int) -> bool:\n        return is_valid_position_mirror_empty_hit_in_way_mirror_hit_mirror_hit_mirror(x, y) and is_hit(x, y)\n\n    def is_"
    },
    {
        "number": 2914,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    if n > 10000 or k > s or k > 500:\n        return \"Error: Invalid input\"\n\n    def probability(n, k, s):\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1 / s\n        if n == 2:\n            return 1 / (s * (s - 1))\n        if n == 3:\n            return 1 / (s * (s - 1) * (s - 2))\n        if n == 4:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3))\n        if n == 5:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4))\n        if n == 6:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5))\n        if n == 7:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6))\n        if n == 8:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7))\n        if n == 9:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8))\n        if n == 10:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8) * (s - 9))\n        if n == 11:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8) * (s - 9) * (s - 10))\n        if n == 12:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8) * (s - 9) * (s - 10) * (s - 11))\n        if n == 13:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8) * (s - 9) * (s - 10) * (s - 11) * (s - 12))\n        if n == 14:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8) * (s - 9) * (s - 10) * (s - 11) * (s - 12) * (s - 13))\n        if n == 15:\n            return 1 / (s * (s - 1) * (s - 2) * (s - 3) * (s - 4) * (s - 5) * (s - 6) * (s - 7) * (s - 8) * (s - 9) * (s - 10) * (s - 11) * (s - 12) * (s - 13) *"
    },
    {
        "number": 2915,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    delivery_locations = []\n    for _ in range(N):\n        x, t = map(int, stdin.split())\n        delivery_locations.append((x, t))\n\n    def distance(a: tuple, b: tuple) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_distance(locations: list) -> int:\n        min_distance = float('inf')\n        for i in range(len(locations)):\n            for j in range(i + 1, len(locations)):\n                min_distance = min(min_distance, distance(locations[i], locations[j]))\n        return min_distance\n\n    min_distance_to_post_office = min_distance(delivery_locations)\n    min_distance_to_locations = [min_distance(delivery_locations[:i] + delivery_locations[i + 1:]) for i in range(N)]\n\n    min_total_distance = min(min_distance_to_post_office, *min_distance_to_locations)\n    return str(min_total_distance)"
    },
    {
        "number": 2916,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    islands = []\n    for i in range(1, n+1):\n        t, k = map(int, stdin.split()[i].split())\n        islands.append((t, k, [tuple(map(int, stdin.split()[j].split())) for j in range(i+1, n+1)]))\n    islands.append((0, 0, []))\n    islands.sort(key=lambda x: x[0])\n    surviving = 0\n    for t, k, neighbors in islands:\n        if t > 0:\n            surviving += 1\n            for neighbor, units in neighbors:\n                t -= units\n                if t <= 0:\n                    surviving -= 1\n                    break\n    return str(surviving)"
    },
    {
        "number": 2917,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"1\"\n    else:\n        return str(2 * n * (2 * n - 1) // (n + 1))"
    },
    {
        "number": 2918,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    matrix = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    kings = [i for i in range(n) if matrix[0][i] == '1']\n    if len(kings)!= 1:\n        return \"impossible\"\n\n    def find_winner(king: int, opponents: list) -> int:\n        for opponent in opponents:\n            if matrix[king][opponent] == '1':\n                return opponent\n        return -1\n\n    def find_winners(king: int) -> list:\n        opponents = [i for i in range(n) if matrix[i][king] == '1']\n        return [find_winner(king, opponents) for opponents in itertools.combinations(opponents, 2)]\n\n    def is_winnable(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 2\n\n    def is_winnable_with_henk(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 3 and winners[0] == 0\n\n    def is_winnable_with_henk_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 4 and winners[0] == 0 and winners[1] == 2\n\n    def is_winnable_with_henk_and_hill_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 5 and winners[0] == 0 and winners[1] == 2 and winners[2] == 4\n\n    def is_winnable_with_henk_and_hill_and_hill_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 6 and winners[0] == 0 and winners[1] == 2 and winners[2] == 4 and winners[3] == 6\n\n    def is_winnable_with_henk_and_hill_and_hill_and_hill_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 7 and winners[0] == 0 and winners[1] == 2 and winners[2] == 4 and winners[3] == 6 and winners[4] == 8\n\n    def is_winnable_with_henk_and_hill_and_hill_and_hill_and_hill_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 8 and winners[0] == 0 and winners[1] == 2 and winners[2] == 4 and winners[3] == 6 and winners[4] == 8 and winners[5] == 10\n\n    def is_winnable_with_henk_and_hill_and_hill_and_hill_and_hill_and_hill_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 9 and winners[0] == 0 and winners[1] == 2 and winners[2] == 4 and winners[3] == 6 and winners[4] == 8 and winners[5] == 10 and winners[6] == 12\n\n    def is_winnable_with_henk_and_hill_and_hill_and_hill_and_hill_and_hill_and_hill_and_hill(king: int) -> bool:\n        winners = find_winners(king)\n        return len(winners) == 10 and winners[0] == 0 and winners[1] == 2 and winners[2] == 4 and winners[3] == 6 and winners[4] == 8 and winners[5] == 10 and winners[6] == 12 and winners[7] == 14\n\n    def is_winnable_with_henk_and_"
    },
    {
        "number": 2919,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char == 'T':\n            stack.append(9)\n        elif char == 'N':\n            stack.append(10)\n        elif char == 'S':\n            stack.append(32)\n        else:\n            raise ValueError(\"Invalid input\")\n\n    while stack:\n        instruction = stack.pop()\n        if instruction == 9:\n            stack.append(stack.pop() + stack.pop())\n        elif instruction == 10:\n            if not stack:\n                print(\"Invalid copy operation\")\n            else:\n                stack.append(stack[-1])\n        elif instruction == 32:\n            if len(stack) < 2:\n                print(\"Invalid swap operation\")\n            else:\n                stack[-2], stack[-1] = stack[-1], stack[-2]\n        elif instruction == 13:\n            if len(stack) < 2:\n                print(\"Invalid remove operation\")\n            else:\n                stack.pop()\n        elif instruction == 14:\n            if len(stack) < 2:\n                print(\"Invalid addition operation\")\n            else:\n                stack.append(stack.pop() + stack.pop())\n        elif instruction == 15:\n            if len(stack) < 2:\n                print(\"Invalid subtraction operation\")\n            else:\n                stack.append(stack.pop() - stack.pop())\n        elif instruction == 16:\n            if len(stack) < 2:\n                print(\"Invalid multiplication operation\")\n            else:\n                stack.append(stack.pop() * stack.pop())\n        elif instruction == 17:\n            if len(stack) < 2:\n                print(\"Invalid division operation\")\n            else:\n                if stack[-1] == 0:\n                    print(\"Division by zero\")\n                else:\n                    stack.append(stack.pop() // stack.pop())\n        elif instruction == 18:\n            if not stack:\n                print(\"Invalid print operation\")\n            else:\n                print(stack.pop())\n\n    return \"\""
    },
    {
        "number": 2920,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = [list(line.strip()) for line in stdin.split()[1:]]\n    s = (0, 0)\n    t = (n - 1, n - 1)\n\n    def dfs(x, y, path):\n        if x == t[0] and y == t[1]:\n            return 1\n        if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] == '#':\n            return 0\n        path.append((x, y))\n        return dfs(x + 1, y, path) + dfs(x - 1, y, path) + dfs(x, y + 1, path) + dfs(x, y - 1, path)\n\n    paths = dfs(s[0], s[1], [])\n    if paths == 0:\n        paths = dfs(s[0], s[1], []) + dfs(s[0], s[1], []) + dfs(s[0], s[1], []) + dfs(s[0], s[1], [])\n\n    return str(paths % (10**9 + 7))"
    },
    {
        "number": 2921,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, u, d = map(float, stdin.split())\n    drinks = []\n    for _ in range(d):\n        name, strength, size, cost = stdin.split()\n        strength = float(strength) / 100\n        drinks.append((name, strength, size, cost))\n\n    drinks.sort(key=lambda x: (-x[1], x[2], x[3]))\n\n    total_cost = 0\n    for name, strength, size, cost in drinks:\n        if total_cost + cost <= m:\n            total_cost += cost\n            u -= 1\n            if u == 0:\n                return f\"{name} {u}\"\n\n    return \"IMPOSSIBLE\""
    },
    {
        "number": 2922,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def split_boxes(a):\n        total_pieces = sum(a)\n        pieces_per_box = total_pieces // n\n        lcm_pieces = lcm(pieces_per_box, a[0])\n        return lcm_pieces\n\n    def check_split(a):\n        for i in range(n):\n            if a[i] > split_boxes(a):\n                return False\n        return True\n\n    if check_split(a):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 2923,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split()[0].split())\n    grid = [list(row) for row in stdin.split()[1:]]\n\n    def is_valid(x, y):\n        return 0 <= x < w and 0 <= y < h and grid[x][y]!= 'A' and grid[x][y]!= 'B'\n\n    def is_neutral(x, y):\n        return grid[x][y] == '0'\n\n    def count_neighbors(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy))\n\n    def count_neighbors_with_enemy(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B')\n\n    def count_neighbors_with_enemy_and_neutral(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy))\n\n    def count_neighbors_with_enemy_and_neutral_and_enemy(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B')\n\n    def count_neighbors_with_enemy_and_neutral_and_enemy_and_neutral(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy))\n\n    def count_neighbors_with_enemy_and_neutral_and_enemy_and_neutral_and_enemy(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B')\n\n    def count_neighbors_with_enemy_and_neutral_and_enemy_and_neutral_and_enemy_and_neutral(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy))\n\n    def count_neighbors_with_enemy_and_neutral_and_enemy_and_neutral_and_enemy_and_neutral_and_enemy(x, y):\n        return sum(1 for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)] if is_valid(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy) and grid[x + dx][y + dy] == 'B' and is_neutral(x + dx, y + dy)"
    },
    {
        "number": 2924,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def is_valid(c, d):\n        return lcm(c, d) <= 100000\n\n    def is_valid_change(c, d):\n        return lcm(c, d) <= 100000 and (lcm(c, d) - lcm(c, min(c, d))) <= p\n\n    def is_valid_setup(c, d):\n        return is_valid(c, d) and is_valid_change(c, d)\n\n    if is_valid_setup(c, d):\n        return \"Ride on!\"\n    else:\n        return \"Time to change gears!\"\n"
    },
    {
        "number": 2925,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    songs = []\n    for i in range(n):\n        f, s = map(int, stdin.split())\n        songs.append((f, s))\n\n    songs.sort(key=lambda x: (-x[0], x[1]))\n    result = []\n    for i in range(m):\n        result.append(songs[i][1])\n\n    return \" \".join(result)"
    },
    {
        "number": 2926,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    categories = []\n    for _ in range(int(stdin.split()[0])):\n        name, words = stdin.split()[1:]\n        words = words.split()\n        categories.append((name, words))\n\n    statement = stdin.split()[2:]\n    statement = statement.split()\n\n    matches = {}\n    for category, words in categories:\n        matches[category] = sum(1 for word in words if word in statement)\n\n    max_matches = max(matches.values())\n    suggestions = [category for category, match in matches.items() if match == max_matches]\n\n    return \" \".join(suggestions)"
    },
    {
        "number": 2927,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plays = list(map(int, stdin.split()))\n    total_yards = sum(plays)\n    first_down = False\n    safety = False\n\n    for yards in plays:\n        total_yards += yards\n        if total_yards >= 80:\n            first_down = True\n        if total_yards >= 100:\n            safety = True\n        if first_down and safety:\n            break\n\n    if first_down and safety:\n        return \"Touchdown\"\n    elif first_down:\n        return \"First Down\"\n    elif safety:\n        return \"Safety\"\n    else:\n        return \"Nothing\""
    },
    {
        "number": 2928,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_tax_band(income: float) -> int:\n        for i in range(len(tax_bands)):\n            if income <= tax_bands[i][0]:\n                return i\n        return len(tax_bands)\n\n    tax_bands = []\n    for _ in range(int(stdin.split()[0])):\n        size, percentage = map(float, stdin.split()[1:])\n        tax_bands.append((size, percentage))\n\n    percentage_tax = float(stdin.split()[2])\n\n    friends = int(stdin.split()[3])\n    earned_money = [float(x) for x in stdin.split()[4:4 + friends]]\n    desired_money = [float(x) for x in stdin.split()[4 + friends:4 + 2 * friends]]\n\n    total_earned = sum(earned_money)\n    total_tax = 0\n\n    for i in range(friends):\n        income = earned_money[i]\n        desired_income = desired_money[i]\n\n        tax_band = find_tax_band(income)\n        tax_amount = tax_bands[tax_band][1] * (income - tax_bands[tax_band][0]) / 100\n\n        total_tax += tax_amount\n\n        if desired_income > total_earned:\n            desired_income = total_earned\n\n        if desired_income > total_earned - tax_amount:\n            desired_income = total_earned - tax_amount\n\n        earned_money[i] = desired_income\n\n    for i in range(friends):\n        print(earned_money[i])\n\n    return \"\\n\".join(map(str, earned_money))\n"
    },
    {
        "number": 2929,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    h = [[int(x) for x in stdin.split()[1:]] for _ in range(N)]\n\n    def bfs(i, j, visited):\n        queue = [(i, j)]\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) == (N - 1, N - 1):\n                return visited[x][y]\n            if (x, y) not in visited:\n                visited[(x, y)] = visited[(x - 1, y)] + visited[(x, y - 1)] + visited[(x + 1, y)] + visited[(x, y + 1)]\n                queue.append((x - 1, y))\n                queue.append((x, y - 1))\n                queue.append((x + 1, y))\n                queue.append((x, y + 1))\n        return float('inf')\n\n    visited = {(0, 0): 1}\n    return str(bfs(0, 0, visited))"
    },
    {
        "number": 2930,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    arr = list(map(int, stdin.split()[1:]))\n    max_length = 1\n    current_length = 1\n    zigzag = True\n\n    for i in range(1, n):\n        if arr[i] > arr[i - 1]:\n            if zigzag:\n                current_length += 1\n            else:\n                current_length = 1\n        else:\n            if zigzag:\n                current_length = 1\n            else:\n                current_length += 1\n\n        if current_length > max_length:\n            max_length = current_length\n\n        zigzag = not zigzag\n\n    return str(max_length)"
    },
    {
        "number": 2931,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def get_place(points):\n        total_points = sum(points)\n        if total_points == 0:\n            return 1\n        elif total_points == 650:\n            return n + 1\n        else:\n            return sum(points)\n\n    highest_place = max(get_place(points[i]) for i in range(n))\n    lowest_place = min(get_place(points[i]) for i in range(n))\n\n    return f\"{highest_place} {lowest_place}\""
    },
    {
        "number": 2932,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = list(s)\n    n = len(s)\n\n    def is_valid(i, j):\n        return abs(i - j) >= k\n\n    def merge(left, right):\n        result = []\n        i, j = 0, 0\n        while i < len(left) and j < len(right):\n            if is_valid(i, j):\n                result.append(left[i])\n                i += 1\n            elif is_valid(j, i):\n                result.append(right[j])\n                j += 1\n            else:\n                if left[i] < right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    sorted_s = merge_sort(s)\n    if sorted_s == s:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2933,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    plates = [int(x) for x in stdin.split()]\n    plates.sort(reverse=True)\n    total_weight = sum(plates)\n    closest_weight = plates[0]\n    for plate in plates[1:]:\n        if abs(plate - 1000) < abs(closest_weight - 1000):\n            closest_weight = plate\n    return str(closest_weight)"
    },
    {
        "number": 2934,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n * m % 2 == 1:\n        return str((n * m) // 2)\n    else:\n        return str((n * m) // 2 + 1)"
    },
    {
        "number": 2935,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, f, s, t = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    cities.sort()\n    cities.append(n)\n    roads = []\n    for i in range(m):\n        u, v, c = map(int, stdin.split())\n        roads.append((u, v, c))\n        roads.append((v, u, c))\n    flights = []\n    for i in range(f):\n        u, v = map(int, stdin.split())\n        flights.append((u, v))\n    flights.sort()\n    dp = [[float('inf')] * (t + 1) for _ in range(n + 1)]\n    dp[s][t] = 0\n    for i in range(n + 1):\n        for j in range(t + 1):\n            if i == s:\n                dp[i][j] = 0\n            elif i == t:\n                dp[i][j] = cities[t]\n            else:\n                for u, v, c in roads:\n                    if i == u and j == v:\n                        dp[i][j] = min(dp[i][j], dp[i][u] + dp[u][j] + c)\n                for u, v in flights:\n                    if i == u and j == v:\n                        dp[i][j] = min(dp[i][j], dp[i][u] + dp[u][j])\n    return str(dp[s][t])"
    },
    {
        "number": 2936,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def k_max_subarray(A, k):\n        if k == 1:\n            return max(A)\n        mid = len(A) // 2\n        left_max = k_max_subarray(A[:mid], k)\n        right_max = k_max_subarray(A[mid:], k)\n        return max(left_max, right_max)\n\n    return str(k_max_subarray(A, k))"
    },
    {
        "number": 2937,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c = map(int, stdin.split())\n    kids = stdin.split()[1:]\n    enemies = []\n    for i in range(k):\n        enemies.append(stdin.split()[1:][i].split())\n\n    def find_groups(kids, enemies):\n        groups = []\n        for i in range(len(kids)):\n            group = [kids[i]]\n            for j in range(i + 1, len(kids)):\n                if enemies[i][0] in group and enemies[j][0] in group:\n                    continue\n                if enemies[i][0] in group:\n                    group.append(kids[j])\n                elif enemies[j][0] in group:\n                    group.append(kids[i])\n            groups.append(group)\n        return groups\n\n    groups = find_groups(kids, enemies)\n    min_groups = min(len(group) for group in groups)\n    result = []\n    for group in groups:\n        result.append(\" \".join(group))\n    return str(min_groups) + \"\\n\" + \"\\n\".join(result)"
    },
    {
        "number": 2938,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = [list(row) for row in stdin.split('\\n')]\n    yraglac_king = [i for i, row in enumerate(board) if 'K' in row][0]\n    opponent_king = [i for i, row in enumerate(board) if 'k' in row][0]\n    yraglac_rook = [i for i, row in enumerate(board) if 'R' in row][0]\n    opponent_rook = [i for i, row in enumerate(board) if 'r' in row][0]\n\n    def is_threatened(king_row, king_col, rook_row, rook_col):\n        if board[king_row][king_col] == 'K' and board[rook_row][rook_col] == 'R':\n            return True\n        if board[king_row][king_col] == 'k' and board[rook_row][rook_col] == 'r':\n            return True\n        return False\n\n    def is_checkmate(king_row, king_col, rook_row, rook_col):\n        if is_threatened(king_row, king_col, rook_row, rook_col):\n            return True\n        for row in range(8):\n            if board[row][king_col] == 'K' and row!= king_row:\n                return True\n            if board[king_row][row] == 'K' and row!= king_row:\n                return True\n        for col in range(8):\n            if board[king_row][col] == 'K' and col!= king_col:\n                return True\n            if board[king_row][col] == 'k' and col!= king_col:\n                return True\n        return False\n\n    def is_valid_move(king_row, king_col, rook_row, rook_col, new_row, new_col):\n        if new_row < 0 or new_row >= 8 or new_col < 0 or new_col >= 8:\n            return False\n        if board[new_row][new_col]!= '.':\n            return False\n        if is_threatened(king_row, king_col, rook_row, rook_col):\n            return False\n        if is_threatened(new_row, new_col, rook_row, rook_col):\n            return False\n        return True\n\n    def is_valid_move_rook(king_row, king_col, rook_row, rook_col, new_row, new_col):\n        if new_row < 0 or new_row >= 8 or new_col < 0 or new_col >= 8:\n            return False\n        if board[new_row][new_col]!= '.':\n            return False\n        if is_threatened(king_row, king_col, rook_row, rook_col):\n            return False\n        if is_threatened(king_row, king_col, new_row, new_col):\n            return False\n        return True\n\n    def is_valid_move_king(king_row, king_col, rook_row, rook_col, new_row, new_col):\n        if new_row < 0 or new_row >= 8 or new_col < 0 or new_col >= 8:\n            return False\n        if board[new_row][new_col]!= '.':\n            return False\n        if is_threatened(king_row, king_col, rook_row, rook_col):\n            return False\n        return True\n\n    def is_valid_move_king_rook(king_row, king_col, rook_row, rook_col, new_row, new_col):\n        if new_row < 0 or new_row >= 8 or new_col < 0 or new_col >= 8:\n            return False\n        if board[new_row][new_col]!= '.':\n            return False\n        if is_threatened(king_row, king_col, rook_row, rook_col):\n            return False\n        if is_threatened(king_row, king_col, new_row, new_col):\n            return False\n        return True\n\n    def is_valid_move_king_rook_threatened(king_row, king_col, rook_row, rook_col, new_row, new_col):\n        if new_row < 0 or new_row >= 8 or new_col < 0 or new_col >= 8:\n            return False\n        if board["
    },
    {
        "number": 2939,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grid = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n\n    def bfs(x, y):\n        queue = [(x, y)]\n        visited = set()\n        visited.add((x, y))\n        max_distance = 0\n        while queue:\n            x, y = queue.pop(0)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 3:\n                    visited.add((nx, ny))\n                    queue.append((nx, ny))\n                    max_distance = max(max_distance, abs(x - nx) + abs(y - ny))\n        return max_distance\n\n    residential_zones = [i for i in range(n) for j in range(n) if grid[i][j] == 1]\n    max_distance = 0\n    for residential_zone in residential_zones:\n        max_distance = max(max_distance, bfs(residential_zone, 0))\n        max_distance = max(max_distance, bfs(residential_zone, n - 1))\n        max_distance = max(max_distance, bfs(0, residential_zone))\n        max_distance = max(max_distance, bfs(n - 1, residential_zone))\n\n    return str(max_distance)"
    },
    {
        "number": 2940,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    recipes = []\n    for i in range(1, n + 1):\n        ingredients = list(map(int, stdin.split()[i].split()))\n        recipes.append(ingredients)\n\n    def is_valid_recipe(recipe, used_ingredients):\n        for ingredient in recipe:\n            if ingredient not in used_ingredients:\n                return False\n        return True\n\n    def concoct_recipe(recipe, used_ingredients):\n        cauldron = [0] * 500001\n        for ingredient in recipe:\n            cauldron[ingredient] += 1\n        for i in range(1, 500001):\n            cauldron[i] += cauldron[i - 1]\n\n        for ingredient in recipe:\n            cauldron[ingredient] -= 1\n            if cauldron[ingredient] == 0:\n                del cauldron[ingredient]\n\n        for i in range(1, 500001):\n            cauldron[i] -= cauldron[i - 1]\n\n        for ingredient in recipe:\n            if cauldron[ingredient] < 0:\n                return False\n\n        return True\n\n    used_ingredients = set()\n    valid_recipes = []\n    for recipe in recipes:\n        if is_valid_recipe(recipe, used_ingredients):\n            valid_recipes.append(recipe)\n            used_ingredients.update(recipe)\n\n    valid_recipes.sort(key=lambda x: x[0])\n    valid_recipes.sort(key=lambda x: x[1])\n    valid_recipes.sort(key=lambda x: x[2])\n\n    count = 0\n    for recipe in valid_recipes:\n        if concoct_recipe(recipe, used_ingredients):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2941,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    queries = [int(x) for x in stdin.split()]\n    queries.pop(0)\n    queries.sort()\n    for query in queries:\n        if query == 1:\n            T, M, S = map(int, stdin.split())\n            print(M)\n        elif query == 2:\n            T = int(stdin.split()[0])\n            print(\"doctor takes a break\")\n        elif query == 3:\n            T, M = map(int, stdin.split())\n            print(M)\n    return \"\""
    },
    {
        "number": 2942,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D = int(stdin)\n    if D > 200000:\n        return \"impossible\"\n\n    n1 = 0\n    n2 = 0\n    while n2**2 - n1**2 < D:\n        n1 += 1\n        n2 = n1 + 1\n\n    if n2**2 - n1**2 == D:\n        return f\"{n1} {n2}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2943,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    sections = [0] * n\n    for i, c in enumerate(stdin):\n        if c == 'R':\n            sections[i] = 1\n        elif c == 'B':\n            sections[i] = 2\n\n    westernmost_start = westernmost_end = 0\n    for i in range(n):\n        if sections[i] == 1:\n            westernmost_start = i\n        elif sections[i] == 2:\n            westernmost_end = i\n\n    return f\"{westernmost_start} {westernmost_end}\""
    },
    {
        "number": 2944,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    connections = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(str, stdin.split())\n        connections[int(u)].append(int(v))\n        connections[int(v)].append(int(u))\n\n    r = stdin.split()[0]\n    skepticism = [0] * (n + 1)\n    skepticism[int(r)] = 0\n\n    def bfs(start: int) -> int:\n        queue = [start]\n        visited = set()\n        level = 0\n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                current = queue.pop(0)\n                if current not in visited:\n                    visited.add(current)\n                    for neighbor in connections[current]:\n                        if neighbor not in visited:\n                            queue.append(neighbor)\n                            skepticism[neighbor] = max(skepticism[neighbor], skepticism[current] + 1)\n        return level\n\n    return str(bfs(int(r)))"
    },
    {
        "number": 2945,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N, A, B, M, C, D = map(int, stdin.split())\n    A_list = list(map(int, stdin.split()))\n    B_list = list(map(int, stdin.split()))\n    C_list = list(map(int, stdin.split()))\n    D_list = list(map(int, stdin.split()))\n\n    A_sum = sum(A_list)\n    B_sum = sum(B_list)\n    C_sum = sum(C_list)\n    D_sum = sum(D_list)\n\n    if A_sum > T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum > T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum < T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 0:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 2 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 3 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 4 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 5 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 6 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 7 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 8 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 9 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 10 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 11 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 12 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 13 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 14 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 15 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 16 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 17 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 18 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 19 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 20 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 21 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 22 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 23 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 24 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 25 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 26 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_sum + D_sum == 27 * T:\n        return \"0\"\n\n    if A_sum + B_sum + C_"
    },
    {
        "number": 2946,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    prices = list(map(int, stdin.split()))\n\n    def max_profit(prices, k):\n        if len(prices) < 2:\n            return 0\n\n        min_price = prices[0]\n        max_profit = 0\n        for price in prices[1:]:\n            if price < min_price:\n                min_price = price\n            else:\n                profit = price - min_price\n                if profit > max_profit:\n                    max_profit = profit\n\n        return max_profit\n\n    return str(max_profit(prices, k))"
    },
    {
        "number": 2947,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *lines = stdin.split('\\n')\n    n = int(n)\n    m = [int(x) for x in lines[0].split()]\n    nums = [list(map(int, line.split())) for line in lines[1:]]\n\n    def is_connected(a: int, b: int, r: int) -> bool:\n        return any(r in nums[a - 1][:m[a - 1]]) or any(r in nums[b - 1][:m[b - 1]])\n\n    def find_connected(a: int, b: int) -> tuple[int, int, int]:\n        for r in range(1, 1000001):\n            if is_connected(a, b, r):\n                return a, b, r\n        return -1, -1, -1\n\n    connected = [find_connected(i, i + 1) for i in range(1, n)]\n    connected.sort(key=lambda x: x[2])\n\n    if not connected:\n        return \"impossible\"\n\n    for a, b, r in connected:\n        if a!= b:\n            return f\"{a} {b} {r}\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 2948,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pairs = []\n    for i in range(5):\n        pairs.append(list(map(int, stdin.split()[i+1].split())))\n    pairs = [sorted(pair) for pair in pairs]\n    mps = [f\"A{i+1}\" for i in range(n)]\n    mps.extend([f\"B{i+1}\" for i in range(n)])\n    mps = list(set(mps))\n    for pair in pairs:\n        if pair[0] in mps and pair[1] in mps:\n            mps.remove(pair[0])\n            mps.remove(pair[1])\n    return \"\".join(mps)"
    },
    {
        "number": 2949,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    pylons = []\n    for _ in range(n):\n        x, y, a = map(int, stdin.split()[1:])\n        pylons.append((x, y, a))\n    pylons.sort(key=lambda x: (x[1], x[0]))\n\n    def is_valid(pylons, i, j):\n        if pylons[i][2] == 1:\n            return True\n        if pylons[i][2] == 2:\n            return pylons[j][1] - pylons[i][1] == 1\n        return pylons[i][1] - pylons[j][1] == 1\n\n    def dfs(pylons, i, j, count):\n        if i == j:\n            return count\n        if not is_valid(pylons, i, j):\n            return dfs(pylons, i + 1, j, count)\n        return max(dfs(pylons, i + 1, j, count), dfs(pylons, i, j - 1, count))\n\n    return str(dfs(pylons, 0, n - 1, 0))"
    },
    {
        "number": 2950,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *heights = map(int, stdin.split())\n    heights.sort()\n    total_height = sum(heights)\n    min_charges = 0\n    for i in range(n):\n        if heights[i] == heights[i + 1]:\n            min_charges += total_height - heights[i]\n        else:\n            min_charges += heights[i] - heights[i + 1]\n    return str(min_charges)"
    },
    {
        "number": 2951,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = list(map(int, stdin.split()[1:]))\n\n    def dfs(i, j, k, visited):\n        if i == N:\n            return 1\n\n        if (i, j, k) in visited:\n            return visited[(i, j, k)]\n\n        visited[(i, j, k)] = 0\n\n        count = 0\n        for l in range(N):\n            if l!= i and l!= j and l!= k:\n                count += dfs(l, j, k, visited)\n\n        visited[(i, j, k)] = count\n\n        return count\n\n    return str(dfs(0, 0, 0, {}))"
    },
    {
        "number": 2952,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b, c = map(int, stdin.split())\n    if a + b + c > m:\n        return \"impossible\"\n    elif a + b + c == m:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2953,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    points = [tuple(map(int, stdin.split()[1:])) for _ in range(n)]\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(points[i][0] - points[j][0]) == 2018 and abs(points[i][1] - points[j][1]) == 2018:\n                pairs.append((points[i], points[j]))\n    return str(len(pairs))"
    },
    {
        "number": 2954,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, T = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        roads.append((u, v, d))\n\n    s, t = map(int, stdin.split())\n    spiders = list(map(int, stdin.split()))\n\n    def bfs(start: int, end: int, visited: set) -> int:\n        queue = [(start, 0)]\n        visited.add(start)\n        while queue:\n            u, d = queue.pop(0)\n            if u == end:\n                return d\n            for v, w in roads:\n                if v not in visited and w <= d:\n                    queue.append((v, d + w))\n        return float('inf')\n\n    def dfs(start: int, end: int, visited: set, path: list) -> int:\n        visited.add(start)\n        path.append(start)\n        if start == end:\n            return 0\n        min_dist = float('inf')\n        for v, w in roads:\n            if v not in visited and w <= min_dist:\n                min_dist = dfs(v, end, visited, path)\n        path.pop()\n        visited.remove(start)\n        return min_dist\n\n    visited = set()\n    min_dist = dfs(s, t, visited, [])\n    for spider in spiders:\n        min_dist = min(min_dist, bfs(s, spider, visited))\n\n    return str(min_dist)"
    },
    {
        "number": 2955,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, b = map(int, stdin.split())\n    z = list(map(int, stdin.split()))\n\n    def is_valid(pattern: str) -> bool:\n        count = 0\n        for i in range(n):\n            if pattern[i] == '1':\n                count += 1\n            if count > c:\n                return False\n        return True\n\n    def next_pattern(pattern: str) -> str:\n        next_pattern = ''\n        for i in range(n):\n            if pattern[i] == '1':\n                next_pattern += '0'\n            else:\n                next_pattern += '1'\n        return next_pattern\n\n    def count_bit_changes(pattern: str) -> int:\n        count = 0\n        for i in range(n):\n            if pattern[i] == '1' and i > 0 and pattern[i - 1] == '1':\n                count += 1\n        return count\n\n    def find_pattern(z: List[int]) -> str:\n        pattern = '1' * n\n        for i in range(b):\n            pattern = next_pattern(pattern)\n            if i in z:\n                pattern = pattern[:z[i] - 1] + '0' + pattern[z[i] - 1:]\n        return pattern\n\n    pattern = find_pattern(z)\n    while not is_valid(pattern):\n        pattern = next_pattern(pattern)\n\n    return pattern"
    },
    {
        "number": 2956,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_patterns(turn_sequence: str) -> int:\n        def is_valid_pattern(pattern: str) -> bool:\n            visited = set()\n            for i in range(len(pattern)):\n                if pattern[i] == 'L':\n                    if i == 0 or pattern[i - 1] == 'R':\n                        return False\n                elif pattern[i] == 'R':\n                    if i == len(pattern) - 1 or pattern[i + 1] == 'L':\n                        return False\n                elif pattern[i] == 'S':\n                    if i == 0 or i == len(pattern) - 1:\n                        return False\n                elif pattern[i] == 'A':\n                    if i == 0 or i == len(pattern) - 1:\n                        return False\n                elif pattern[i] == '?':\n                    if i == 0 or i == len(pattern) - 1:\n                        return False\n                    if pattern[i - 1] == 'R' and pattern[i + 1] == 'L':\n                        return False\n                    if pattern[i - 1] == 'L' and pattern[i + 1] == 'R':\n                        return False\n            return True\n\n        def count_valid_patterns(visited: set) -> int:\n            count = 0\n            for i in range(1, 10):\n                if i not in visited:\n                    visited.add(i)\n                    for j in range(i + 1, 10):\n                        if j not in visited:\n                            visited.add(j)\n                            for k in range(j + 1, 10):\n                                if k not in visited:\n                                    visited.add(k)\n                                    for l in range(k + 1, 10):\n                                        if l not in visited:\n                                            visited.add(l)\n                                            for m in range(l + 1, 10):\n                                                if m not in visited:\n                                                    visited.add(m)\n                                                    for n in range(m + 1, 10):\n                                                        if n not in visited:\n                                                            visited.add(n)\n                                                            for o in range(n + 1, 10):\n                                                                if o not in visited:\n                                                                    visited.add(o)\n                                                                    for p in range(o + 1, 10):\n                                                                        if p not in visited:\n                                                                            visited.add(p)\n                                                                            for q in range(p + 1, 10):\n                                                                                if q not in visited:\n                                                                                    visited.add(q)\n                                                                                    for r in range(q + 1, 10):\n                                                                                        if r not in visited:\n                                                                                            visited.add(r)\n                                                                                            for s in range(r + 1, 10):\n                                                                                                if s not in visited:\n                                                                                                    visited.add(s)\n                                                                                                    for t in range(s + 1, 10):\n                                                                                                        if t not in visited:\n                                                                                                            visited.add(t)\n                                                                                                            for u in range(t + 1, 10):\n                                                                                                                if u not in visited:\n                                                                                                                    visited.add(u)\n                                                                                                                    for v in range(u + 1, 10):\n                                                                                                                        if v not in visited:\n                                                                                                                            visited.add(v)\n                                                                                                                            for w in range(v + 1, 10):\n                                                                                                                                if w not in visited:\n                                                                                                                                    visited.add(w)\n                                                                                                                                    for x in range(w + 1, 10):\n                                                                                                                                        if x not in visited:\n                                                                                                                                            visited.add(x)\n                                                                                                                                            for y in range(x + 1, 10):\n                                                                                                                                                if y not in visited:\n                                                                                                                                                    visited.add(y)\n                                                                                                                                                    for z in range(y + 1, 10):\n                                                                                                                                                        if z not in visited:\n                                                                                                                                                            visited.add(z)\n                                                                                                                                                            for a in range(z + 1, 10):\n                                                                                                                                                                if a not in visited:\n                                                                                                                                                                    visited.add(a)\n                                                                                                                                                                    for b in range(a + 1, 10):\n                                                                                                                                                                        if b not in visited:\n                                                                                                                                                                            visited.add(b)\n                                                                                                                                                                            for c in range(b + 1, 10):\n                                                                                                                                                                                if c not in visited:\n                                                                                                                                                                                    visited.add(c)\n                                                                                                                                                                                    for d in range(c + 1, 10):\n                                                                                                                                                                                        if d not in visited:\n                                                                                                                                                                                            visited.add(d)\n                                                                                                                                                                                            for e in range(d + 1, 10):\n                                                                                                                                                                                                if e not in visited:\n                                                                                                                                                                                                    visited.add(e)\n                                                                                                                                                                                                    for f"
    },
    {
        "number": 2957,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * n\n    visited[0] = True\n    queue = [(0, 0)]\n    shortest_path = float('inf')\n    while queue:\n        u, distance = queue.pop(0)\n        if u == n - 1:\n            shortest_path = min(shortest_path, distance)\n            continue\n        for v in graph[u]:\n            if not visited[v]:\n                visited[v] = True\n                queue.append((v, distance + 1))\n    return str(shortest_path)"
    },
    {
        "number": 2958,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    a, b = map(int, stdin.split())\n\n    def buy_sell(card_type, coins):\n        if coins >= a[card_type - 1]:\n            return 1\n        elif coins >= b[card_type - 1]:\n            return 2\n        else:\n            return 0\n\n    def max_profit(coins):\n        combos = [0] * t\n        for card in cards:\n            combos[card - 1] += 1\n\n        for card_type in range(1, t + 1):\n            for i in range(combos[card_type - 1]):\n                if combos[card_type - 1] - i >= 2:\n                    combos[card_type] += buy_sell(card_type, coins + a[card_type - 1])\n\n        return sum(combos)\n\n    return str(max_profit(0))"
    },
    {
        "number": 2959,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(row) for row in stdin.split('\\n')[1:]]\n    ring_numbers = []\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'T':\n                ring_numbers.append(find_ring(i, j, grid, ring_numbers))\n\n    return '\\n'.join([''.join(map(str, ring_numbers[i:i+m])) for i in range(0, len(ring_numbers), m)])\n\ndef"
    },
    {
        "number": 2960,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(binomial_coefficient(n, 2))\n\ndef"
    },
    {
        "number": 2961,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    rooms = [list(map(int, stdin.split()[i:i+4])) for i in range(0, 4*n, 4)]\n    visited = [False] * n\n    visited[0] = True\n    queue = [(0, 0)]\n    while queue:\n        room, direction = queue.pop(0)\n        if room == n-1:\n            return \"Yes\"\n        for i in range(4):\n            if not visited[i] and rooms[room][i]!= 0:\n                visited[i] = True\n                queue.append((rooms[room][i], i))\n    return \"Impossible\""
    },
    {
        "number": 2962,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    people = []\n    for i in range(n):\n        cash, time = map(int, stdin.split())\n        people.append((cash, time))\n    people.sort(key=lambda x: x[1])\n    total_cash = 0\n    served = 0\n    for cash, time in people:\n        if time <= t:\n            total_cash += cash\n            served += 1\n            if served == 1:\n                break\n    return str(total_cash)"
    },
    {
        "number": 2963,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    x = 1\n    while x**x < n:\n        x += 1\n    return str(x)"
    },
    {
        "number": 2964,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    shots = int(stdin.split()[0])\n    shots_list = []\n    for _ in range(shots):\n        x, y = map(int, stdin.split()[1].split())\n        shots_list.append((x, y))\n    shots_list = [(x, y) for x, y in shots_list if abs(x) <= 1000 and abs(y) <= 1000]\n    if len(shots_list) < 2:\n        return \"0.0\"\n    distances = []\n    for i in range(len(shots_list)):\n        for j in range(i + 1, len(shots_list)):\n            distances.append(abs(shots_list[i][0] - shots_list[j][0]) + abs(shots_list[i][1] - shots_list[j][1]))\n    return str(max(distances))"
    },
    {
        "number": 2965,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, p = map(int, stdin.split())\n    pumpkins = []\n    for _ in range(p):\n        r, c = map(int, stdin.split())\n        pumpkins.append((r, c))\n\n    def is_valid(r, c):\n        return 0 <= r < n and 0 <= c < n\n\n    def is_alive(r, c):\n        return is_valid(r, c) and (r, c) not in visited\n\n    def grow(r, c):\n        nonlocal visited\n        if is_alive(r, c):\n            visited.add((r, c))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                if is_valid(r + dr, c + dc) and grid[r + dr][c + dc] == 0:\n                    grid[r + dr][c + dc] = 1\n                    grow(r + dr, c + dc)\n\n    def count_alive(r, c):\n        nonlocal visited\n        if is_alive(r, c):\n            visited.add((r, c))\n            count_alive(r, c)\n            count_alive(r + 1, c)\n            count_alive(r - 1, c)\n            count_alive(r, c + 1)\n            count_alive(r, c - 1)\n            count_alive(r + 1, c + 1)\n            count_alive(r - 1, c - 1)\n            count_alive(r + 1, c - 1)\n            count_alive(r - 1, c + 1)\n            return 1\n        return 0\n\n    def count_dead(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 0:\n            return 1\n        return 0\n\n    def count_roots(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 1:\n            return 1\n        return 0\n\n    def count_pumpkins(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_dead(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 0\n        return 0\n\n    def count_pumpkins_roots(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_roots_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_roots_dead(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 0\n        return 0\n\n    def count_pumpkins_roots_dead_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_roots_dead_alive_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_roots_dead_alive_alive_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_roots_dead_alive_alive_alive_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n        return 0\n\n    def count_pumpkins_roots_dead_alive_alive_alive_alive_alive(r, c):\n        nonlocal visited\n        if is_valid(r, c) and grid[r][c] == 2:\n            return 1\n       "
    },
    {
        "number": 2966,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    count = 0\n    for i in range(m):\n        for j in range(n):\n            if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2967,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    arrivals = []\n    for _ in range(n):\n        arrival, stay = map(int, stdin.split())\n        arrivals.append((arrival, stay))\n\n    arrivals.sort(key=lambda x: x[0])\n\n    unlockings = 0\n    current_arrival = 0\n    current_stay = 0\n    current_workstation = 0\n\n    for arrival, stay in arrivals:\n        if current_arrival + current_stay <= arrival:\n            current_arrival += arrival\n            current_stay += stay\n            current_workstation += 1\n        else:\n            unlockings += 1\n            current_arrival = arrival\n            current_stay = stay\n            current_workstation = 1\n\n    return str(unlockings)"
    },
    {
        "number": 2968,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n, e = map(int, stdin.split())\n    s_b, s_n, s_e = map(int, stdin.split())\n    c_1, *c_m = map(int, stdin.split())\n\n    max_speed = 0\n    for i in range(b):\n        max_speed += c_1 * s_b\n    for i in range(n):\n        max_speed += c_1 * s_n\n    for i in range(e):\n        max_speed += c_1 * s_e\n\n    for i in range(b, b + n):\n        max_speed += c_1 * s_b + c_1 * s_n\n    for i in range(b + n, b + n + e):\n        max_speed += c_1 * s_b + c_1 * s_e\n\n    for i in range(b + n, b + n + e):\n        max_speed += c_1 * s_b + c_1 * s_e\n\n    for c in c_m:\n        max_speed += c * s_b + c * s_n + c * s_e\n\n    return str(max_speed)"
    },
    {
        "number": 2969,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    hand = [tuple(map(int, stdin.split()[i:i+2])) for i in range(0, n*2, 2)]\n    hand.sort(key=lambda x: (x[1], x[0]))\n    for i in range(len(hand)):\n        if hand[i][0] == hand[i+1][0]:\n            return \"impossible\"\n    return \"possible\""
    },
    {
        "number": 2970,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    buildings = [[] for _ in range(m + 1)]\n    for _ in range(n):\n        label = int(stdin.split()[0])\n        buildings[label].append(1)\n    noise_levels = [0] * (m + 1)\n    for i in range(1, m + 1):\n        noise_levels[i] = sum(buildings[i])\n    for _ in range(k):\n        for i in range(1, m + 1):\n            if buildings[i]:\n                buildings[i] = []\n                noise_levels[i] = 0\n    return str(sum(noise_levels))"
    },
    {
        "number": 2971,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    words = [stdin.split()[i] for i in range(1, n + 1)]\n    max_rhyme_power = 0\n\n    for i in range(len(words)):\n        for j in range(i + 1, len(words)):\n            rhyme_power = 0\n            for k in range(len(words[i])):\n                if words[i][k] == words[j][k]:\n                    rhyme_power += 1\n                else:\n                    break\n            max_rhyme_power = max(max_rhyme_power, rhyme_power)\n\n    return str(max_rhyme_power)"
    },
    {
        "number": 2972,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    count = 0\n    for i in range(a, b + 1):\n        for j in range(2, k + 1):\n            if i == int(str(i)[::-1]):\n                count += 1\n    return str(count)"
    },
    {
        "number": 2973,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    segments = []\n    for _ in range(n):\n        d, s = map(int, stdin.split())\n        segments.append((d, s))\n    segments.sort(key=lambda x: x[0])\n    total_distance = sum(d for d, _ in segments)\n    total_time = sum(t for _, t in segments)\n    c = total_distance / total_time\n    return f\"{c:.6f}\""
    },
    {
        "number": 2974,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    P = list(map(int, stdin.split()[1].split()))\n    D = list(map(int, stdin.split()[2].split()))\n\n    # Find the minimum k such that there is a consistent recollection of k events\n    k_p = min(len(set(P)), len(set(D)))\n    k_r = min(len(set(P)), len(set(D)))\n\n    # Find the minimum k such that there is a consistent recollection of k events\n    for k in range(1, min(len(set(P)), len(set(D))) + 1):\n        if len(set(P) & set(D)) >= k:\n            k_p = k\n            break\n\n    for k in range(1, min(len(set(P)), len(set(D))) + 1):\n        if len(set(P) & set(D)) >= k:\n            k_r = k\n            break\n\n    return f\"{k_p} {k_r}\""
    },
    {
        "number": 2975,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ingredients = []\n    for _ in range(n):\n        x, y, s_m, p_m, s_v, p_v = map(int, stdin.split())\n        ingredients.append((x, y, s_m, p_m, s_v, p_v))\n\n    def buy_ingredient(ingredient, size, price):\n        if ingredient[1] >= size:\n            ingredient[1] -= size\n            return True\n        return False\n\n    def buy_ingredient_package(ingredient, size, price):\n        if ingredient[1] >= size:\n            ingredient[1] -= size\n            return True\n        return False\n\n    def buy_ingredient_packages(ingredient, size, price):\n        if ingredient[1] >= size:\n            ingredient[1] -= size\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price(ingredient, size, price):\n        if ingredient[1] >= size and ingredient[4] >= price:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size(ingredient, size, price):\n        if ingredient[1] >= size and ingredient[4] >= price and ingredient[5] >= size:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            ingredient[5] -= size\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size_and_quantity(ingredient, size, price, quantity):\n        if ingredient[1] >= size and ingredient[4] >= price and ingredient[5] >= size and ingredient[2] >= quantity:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            ingredient[5] -= size\n            ingredient[2] -= quantity\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size_and_quantity_and_quantity(ingredient, size, price, quantity, quantity2):\n        if ingredient[1] >= size and ingredient[4] >= price and ingredient[5] >= size and ingredient[2] >= quantity and ingredient[3] >= quantity2:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            ingredient[5] -= size\n            ingredient[2] -= quantity\n            ingredient[3] -= quantity2\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size_and_quantity_and_quantity_and_quantity(ingredient, size, price, quantity, quantity2, quantity3):\n        if ingredient[1] >= size and ingredient[4] >= price and ingredient[5] >= size and ingredient[2] >= quantity and ingredient[3] >= quantity2 and ingredient[6] >= quantity3:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            ingredient[5] -= size\n            ingredient[2] -= quantity\n            ingredient[3] -= quantity2\n            ingredient[6] -= quantity3\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size_and_quantity_and_quantity_and_quantity_and_quantity(ingredient, size, price, quantity, quantity2, quantity3, quantity4):\n        if ingredient[1] >= size and ingredient[4] >= price and ingredient[5] >= size and ingredient[2] >= quantity and ingredient[3] >= quantity2 and ingredient[6] >= quantity3 and ingredient[7] >= quantity4:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            ingredient[5] -= size\n            ingredient[2] -= quantity\n            ingredient[3] -= quantity2\n            ingredient[6] -= quantity3\n            ingredient[7] -= quantity4\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size_and_quantity_and_quantity_and_quantity_and_quantity_and_quantity(ingredient, size, price, quantity, quantity2, quantity3, quantity4, quantity5):\n        if ingredient[1] >= size and ingredient[4] >= price and ingredient[5] >= size and ingredient[2] >= quantity and ingredient[3] >= quantity2 and ingredient[6] >= quantity3 and ingredient[7] >= quantity4 and ingredient[8] >= quantity5:\n            ingredient[1] -= size\n            ingredient[4] -= price\n            ingredient[5] -= size\n            ingredient[2] -= quantity\n            ingredient[3] -= quantity2\n            ingredient[6] -= quantity3\n            ingredient[7] -= quantity4\n            ingredient[8] -= quantity5\n            return True\n        return False\n\n    def buy_ingredient_packages_with_price_and_size_and_quantity_and_quantity"
    },
    {
        "number": 2976,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players, n = stdin.split()\n    players = players.split()\n    n = int(n)\n\n    for _ in range(n):\n        sets = []\n        for _ in range(5):\n            set_result = input().split()\n            set_result = [int(x) for x in set_result]\n            sets.append(set_result)\n\n        valid = True\n        for set_result in sets:\n            if set_result[0] + set_result[1] < 6:\n                valid = False\n                break\n\n        if players[0] == \"federer\" and set_result[0] == 6 and set_result[1] == 6:\n            valid = False\n\n        if valid:\n            print(\"da\")\n        else:\n            print(\"ne\")"
    },
    {
        "number": 2977,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    question, n = stdin.split('\\n')[0].split()\n    alternatives = [line.strip().split(',') for line in stdin.split('\\n')[1:]]\n\n    # Calculate incongruity\n    incongruities = []\n    for i in range(n):\n        incongruities.append(sum(1 for j in range(n) if i!= j and alternatives[i]!= alternatives[j]))\n\n    # Find least incongruous alternative\n    least_incongruous = min(alternatives, key=lambda x: incongruities.index(min(incongruities)))\n\n    return least_incongruous"
    },
    {
        "number": 2978,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    streets = []\n    for _ in range(int(stdin.split()[0])):\n        x1, y1, x2, y2 = map(int, stdin.split()[1:])\n        streets.append((x1, y1, x2, y2))\n\n    properties = []\n    for _ in range(int(stdin.split()[2])):\n        x3, y3, x4, y4 = map(int, stdin.split()[3:])\n        properties.append((x3, y3, x4, y4))\n\n    for street in streets:\n        for property in properties:\n            if street[0] == property[0] or street[0] == property[1] or street[1] == property[0] or street[1] == property[1]:\n                if street[0] == property[0] and street[1] == property[1]:\n                    return \"same\"\n                elif street[0] == property[0] and street[1] == property[3]:\n                    return \"different\"\n                elif street[0] == property[1] and street[1] == property[2]:\n                    return \"different\"\n                elif street[0] == property[1] and street[1] == property[3]:\n                    return \"same\"\n\n    return \"same\""
    },
    {
        "number": 2979,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x - 1].append(y - 1)\n        graph[y - 1].append(x - 1)\n\n    infected = [False] * n\n    infected[s] = True\n\n    def dfs(node: int) -> int:\n        nonlocal infected\n        count = 0\n        for neighbor in graph[node]:\n            if not infected[neighbor]:\n                infected[neighbor] = True\n                count += dfs(neighbor)\n        return count + 1\n\n    return str(dfs(s) * t)"
    },
    {
        "number": 2980,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *s = map(int, stdin.split())\n    m, *h = map(int, stdin.split())\n\n    def xor_sum(h: List[int]) -> int:\n        return sum(h) ^ (h[0] << 1)\n\n    def is_winning(h: List[int]) -> bool:\n        return xor_sum(h) == 0\n\n    def is_losing(h: List[int]) -> bool:\n        return xor_sum(h)!= 0\n\n    positions = []\n    for _ in range(m):\n        positions.append(tuple(map(int, stdin.split())))\n\n    for position in positions:\n        if is_winning(position):\n            print(\"W\")\n        elif is_losing(position):\n            print(\"L\")\n        else:\n            print(\"?\")"
    },
    {
        "number": 2981,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    vertices = []\n    for _ in range(n):\n        x, y = map(float, stdin.split()[1:])\n        vertices.append((x, y))\n    min_slot_size = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    polygon = [(vertices[i], vertices[j], vertices[k], vertices[l])]\n                    polygon.sort(key=lambda x: x[0][0])\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y[0]) for x, y in polygon]\n                    polygon = [(x[0], y"
    },
    {
        "number": 2982,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    hype_ratings = list(map(int, stdin.split()[1:]))\n\n    def is_valid_setlist(setlist):\n        if setlist[0]!= 1 or setlist[-1]!= 3:\n            return False\n        for i in range(1, len(setlist) - 1):\n            if setlist[i]!= 2:\n                return False\n        return True\n\n    def count_setlists(hype_ratings):\n        setlists = []\n        for i in range(len(hype_ratings) - 2):\n            for j in range(i + 1, len(hype_ratings) - 1):\n                for k in range(j + 1, len(hype_ratings)):\n                    setlists.append([hype_ratings[i], hype_ratings[j], hype_ratings[k]])\n        return len(setlists)\n\n    setlists = count_setlists(hype_ratings)\n    valid_setlists = [setlist for setlist in setlists if is_valid_setlist(setlist)]\n    return str((setlists - valid_setlists) % (10**9 + 7))"
    },
    {
        "number": 2983,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sheets = map(int, stdin.split())\n    if n > 30:\n        return \"impossible\"\n\n    def paper_size(size: int) -> float:\n        return 2 ** (size - 1) / 4\n\n    def tape_length(size: int) -> float:\n        return sheets[size - 2] * paper_size(size)\n\n    total_length = sum(tape_length(size) for size in range(2, n + 1))\n    if total_length > 1.60965532263:\n        return \"impossible\"\n\n    return f\"{total_length:.5f}\"\n"
    },
    {
        "number": 2984,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, p = map(int, stdin.split())\n    cars = [int(x) for x in stdin.split()]\n    passengers = [int(x) for x in stdin.split()]\n\n    max_distance = 0\n    max_board = 0\n\n    for i in range(p):\n        distance = abs(cars[i] - passengers[i])\n        if distance > max_distance:\n            max_distance = distance\n            max_board = 1\n        elif distance == max_distance:\n            max_board += 1\n\n    return str(max_distance) + \"\\n\" + str(max_board)"
    },
    {
        "number": 2985,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, d, n = map(int, stdin.split())\n    positions = list(map(int, stdin.split()))\n    positions.sort()\n    count = 0\n    for i in range(n):\n        if positions[i] - d >= 6:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2986,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.split()[0])\n    for _ in range(T):\n        s = stdin.split()[1]\n        s = ''.join(c for c in s if c not in '<[]')\n        s = ''.join(c if c!= '<' else s[0] + s[1] + s[2] else c for c in s)\n        s = ''.join(c if c!= '[' else s[0] + s[1] + s[2] else c for c in s)\n        s = ''.join(c if c!= ']' else s[0] + s[1] + s[2] else c for c in s)\n        print(s)"
    },
    {
        "number": 2987,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, W = map(int, stdin.split())\n    estimates = []\n    for i in range(W + 1):\n        estimates.append(list(map(int, stdin.split())))\n    estimates.reverse()\n\n    def max_revenue(prices, seats, weeks):\n        revenue = 0\n        for i in range(len(prices)):\n            revenue += prices[i] * seats[i] * weeks[i]\n        return revenue\n\n    def min_price(prices, seats, weeks):\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            if prices[i] < min_price:\n                min_price = prices[i]\n        return min_price\n\n    def max_price(prices, seats, weeks):\n        max_price = prices[-1]\n        for i in range(len(prices) - 2, -1, -1):\n            if prices[i] > max_price:\n                max_price = prices[i]\n        return max_price\n\n    def min_seats(prices, seats, weeks):\n        min_seats = seats[0]\n        for i in range(1, len(seats)):\n            if seats[i] < min_seats:\n                min_seats = seats[i]\n        return min_seats\n\n    def max_seats(prices, seats, weeks):\n        max_seats = seats[-1]\n        for i in range(len(seats) - 2, -1, -1):\n            if seats[i] > max_seats:\n                max_seats = seats[i]\n        return max_seats\n\n    def min_weeks(prices, seats, weeks):\n        min_weeks = weeks[0]\n        for i in range(1, len(weeks)):\n            if weeks[i] < min_weeks:\n                min_weeks = weeks[i]\n        return min_weeks\n\n    def max_weeks(prices, seats, weeks):\n        max_weeks = weeks[-1]\n        for i in range(len(weeks) - 2, -1, -1):\n            if weeks[i] > max_weeks:\n                max_weeks = weeks[i]\n        return max_weeks\n\n    max_revenue_week = 0\n    max_revenue_price = 0\n    max_revenue_seats = 0\n\n    for i in range(W + 1):\n        max_revenue_week = max(max_revenue_week, max_revenue(estimates[i][1:], estimates[i][2:], estimates[i][3:]))\n        max_revenue_price = max(max_revenue_price, min_price(estimates[i][1:], estimates[i][2:], estimates[i][3:]))\n        max_revenue_seats = max(max_revenue_seats, min_seats(estimates[i][1:], estimates[i][2:], estimates[i][3:]))\n\n    max_revenue_week = max(max_revenue_week, max_revenue(estimates[0][1:], estimates[0][2:], estimates[0][3:]))\n    max_revenue_price = max(max_revenue_price, min_price(estimates[0][1:], estimates[0][2:], estimates[0][3:]))\n    max_revenue_seats = max(max_revenue_seats, min_seats(estimates[0][1:], estimates[0][2:], estimates[0][3:]))\n\n    max_revenue_week = max(max_revenue_week, max_revenue(estimates[-1][1:], estimates[-1][2:], estimates[-1][3:]))\n    max_revenue_price = max(max_revenue_price, min_price(estimates[-1][1:], estimates[-1][2:], estimates[-1][3:]))\n    max_revenue_seats = max(max_revenue_seats, min_seats(estimates[-1][1:], estimates[-1][2:], estimates[-1][3:]))\n\n    max_revenue_week = max(max_revenue_week, max_revenue(estimates[0][1:], estimates[0][2:], estimates[0][3:]))\n    max_revenue_price = max(max_revenue_price, min_price(estimates[0][1:], estimates[0][2:], estimates[0][3:]))\n    max_revenue_seats = max(max_revenue_seats, min_seats(estimates[0][1:], estimates[0"
    },
    {
        "number": 2988,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teleporters = [list(map(int, stdin.split())) for _ in range(m)]\n    balls = list(map(int, stdin.split()))\n\n    def dfs(city, visited, path):\n        if city == n:\n            return 1\n        if (city, visited) in visited:\n            return 0\n        visited.add((city, visited))\n        for i, (a, b, t) in enumerate(teleporters):\n            if a == city and b not in visited:\n                if dfs(b, visited, path + [i]):\n                    return 1\n        return 0\n\n    visited = set()\n    for i, ball in enumerate(balls):\n        if dfs(ball, visited, []):\n            return i + 1\n    return -1"
    },
    {
        "number": 2989,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    pipes = []\n    for _ in range(p):\n        a, b, c = map(int, stdin.split())\n        pipes.append((a, b, c))\n\n    improvements = []\n    for _ in range(k):\n        a, b, c = map(int, stdin.split())\n        improvements.append((a, b, c))\n\n    def find_pipe(a, b):\n        for a1, b1, c in pipes:\n            if a1 == a and b1 == b:\n                return a1, b1, c\n            if a1 == b and b1 == a:\n                return a1, b1, c\n        return None\n\n    def increase_capacity(a, b, c):\n        a1, b1, _ = find_pipe(a, b)\n        if a1 is None:\n            pipes.append((a, b, c))\n        else:\n            pipes.remove((a1, b1, _))\n            pipes.append((a1, b1, c))\n\n    def install_pipe(a, b, c):\n        a1, b1, _ = find_pipe(a, b)\n        if a1 is None:\n            pipes.append((a, b, c))\n        else:\n            pipes.remove((a1, b1, _))\n            pipes.append((a1, b1, c))\n            pipes.append((a, b, c))\n\n    for a, b, c in improvements:\n        if a == b:\n            increase_capacity(a, b, c)\n        else:\n            install_pipe(a, b, c)\n\n    def find_station(a):\n        for a1, b1, c in pipes:\n            if a1 == a:\n                return a1\n            if a1 == b:\n                return a1\n        return None\n\n    def find_max_water(a):\n        max_water = 0\n        for b in range(1, n + 1):\n            if b == a:\n                continue\n            a1 = find_station(a)\n            b1 = find_station(b)\n            if a1 is None or b1 is None:\n                continue\n            c = pipes[(a1 - 1) * (n - 1) // 2 + (b1 - 1)]\n            max_water = max(max_water, pipes[(a1 - 1) * (n - 1) // 2 + (b1 - 1)] + pipes[(b1 - 1) * (n - 1) // 2 + (a1 - 1)])\n        return max_water\n\n    max_water = 0\n    for a in range(1, n + 1):\n        max_water = max(max_water, find_max_water(a))\n\n    return str(max_water) + '\\n' + '\\n'.join(map(str, [find_max_water(a) for a in range(1, n + 1)]))"
    },
    {
        "number": 2990,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    players = list(map(str, stdin.split()))\n    players.sort()\n    preferences = [[] for _ in range(n)]\n\n    for i in range(n):\n        q = int(stdin.split()[i + 1])\n        preferences[i] = players[:q]\n        players = players[q:]\n\n    for i in range(n):\n        preferences[i].sort(key=lambda x: players.index(x))\n\n    result = []\n    for i in range(n):\n        result.append(\" \".join(preferences[i][:k]))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2991,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    gnomes = list(map(int, stdin.split()))\n    gnomes.sort()\n    for i in range(1, n + 1):\n        if i in gnomes:\n            gnomes.remove(i)\n    return \" \".join(map(str, gnomes))"
    },
    {
        "number": 2992,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cities = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        cities[a].append((b, c))\n        cities[b].append((a, c))\n    min_range = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if cities[i] and cities[j]:\n                for city in cities[i]:\n                    for other_city in cities[j]:\n                        if city[0] == other_city[0] or city[0] == other_city[1]:\n                            continue\n                        min_range = min(min_range, city[1] + other_city[1])\n    if min_range == float('inf'):\n        return 'IMPOSSIBLE'\n    return str(min_range)"
    },
    {
        "number": 2993,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, encoded_message = map(int, stdin.split())\n    p_A = D / 8\n    intervals = [0, 1]\n    message = \"\"\n\n    for i in range(N):\n        if encoded_message[i] == \"0\":\n            intervals[0] = intervals[0] + p_A * (intervals[1] - intervals[0])\n        else:\n            intervals[1] = intervals[0] + p_A * (intervals[1] - intervals[0])\n        if intervals[1] >= 1:\n            message += \"A\"\n            intervals[0] = intervals[1] = 0\n        else:\n            message += \"B\"\n\n    return message"
    },
    {
        "number": 2994,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'a':\n                if i + 1 < R and grid[i + 1][j] == '.':\n                    grid[i][j] = 'a'\n                    grid[i + 1][j] = '.'\n                elif i - 1 >= 0 and grid[i - 1][j] == '.':\n                    grid[i][j] = 'a'\n                    grid[i - 1][j] = '.'\n                elif j + 1 < C and grid[i][j + 1] == '.':\n                    grid[i][j] = 'a'\n                    grid[i][j + 1] = '.'\n                elif j - 1 >= 0 and grid[i][j - 1] == '.':\n                    grid[i][j] = 'a'\n                    grid[i][j - 1] = '.'\n\n    return '\\n'.join(''.join(row) for row in grid)"
    },
    {
        "number": 2995,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    items = set(stdin.split())\n    suspicious_pairs = set()\n\n    for _ in range(m):\n        suspicious_pair = stdin.split()\n        suspicious_pairs.add(tuple(sorted(suspicious_pair)))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (i, j) in suspicious_pairs or (j, i) in suspicious_pairs:\n                continue\n            if (i, j) in items and (j, i) in items:\n                items.remove((i, j))\n                items.remove((j, i))\n                break\n\n    if not items:\n        return \"impossible\"\n\n    return \" \".join(sorted(items))\n\n\ndef"
    },
    {
        "number": 2996,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    costs = list(map(int, stdin.split()))\n    requests = [[] for _ in range(n)]\n    for i in range(n):\n        requests[i] = list(map(int, stdin.split()))\n\n    def min_cost(start: int, end: int) -> int:\n        if start == end:\n            return 0\n        if start > end:\n            start, end = end, start\n        min_cost = float('inf')\n        for i in range(start, end):\n            min_cost = min(min_cost, costs[i] + min_cost(start, i) + min_cost(i + 1, end))\n        return min_cost\n\n    return str(min_cost(1, n))\n"
    },
    {
        "number": 2997,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n    colors = [0] * (n + 1)\n    colors[1] = 1\n    max_color_changes = 0\n    for i in range(2, n + 1):\n        for j in graph[i]:\n            if colors[i]!= colors[j]:\n                max_color_changes += 1\n                colors[j] = 3 - colors[j]\n    return str(max_color_changes)"
    },
    {
        "number": 2998,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    umm_coded_message = stdin.strip()\n    decoded_message = \"\"\n    for i in range(0, len(umm_coded_message), 7):\n        word = umm_coded_message[i:i+7]\n        if word.isalpha() and word.lower() == \"u\":\n            decoded_message += \"i\"\n        elif word.isalpha() and word.lower() == \"m\":\n            decoded_message += \"c\"\n        else:\n            decoded_message += word\n    return decoded_message"
    },
    {
        "number": 2999,
        "checkpoint": "3B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    participants = []\n    for _ in range(n):\n        name, bet = stdin.split()\n        participants.append((name, int(bet)))\n\n    participants.sort(key=lambda x: x[1], reverse=True)\n    winners = []\n    for i in range(n):\n        if i == 0 or participants[i][1] >= 2 * participants[i - 1][1]:\n            winners.append(participants[i][0])\n\n    print(len(winners))\n    for winner in winners:\n        print(winner)\n\n    return \"\""
    }
]