[
    {
        "number": 0,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    opening_bracket = s.index('[')\n    closing_bracket = s.index(']')\n    opening_colon = s.index(':', opening_bracket + 1)\n    closing_colon = s.index(':', closing_bracket + 1)\n    opening_vertical_line = s.index(':', opening_colon + 1)\n    closing_vertical_line = s.index(':', closing_colon + 1)\n    opening_double_colon = s.index('::', opening_vertical_line + 1)\n    closing_double_colon = s.index('::', closing_vertical_line + 1)\n    opening_triple_colon = s.index('::', opening_double_colon + 1)\n    closing_triple_colon = s.index('::', closing_double_colon + 1)\n    opening_quadruple_colon = s.index('::', opening_triple_colon + 1)\n    closing_quadruple_colon = s.index('::', closing_triple_colon + 1)\n    opening_quintuple_colon = s.index('::', opening_quadruple_colon + 1)\n    closing_quintuple_colon = s.index('::', closing_quadruple_colon + 1)\n    opening_sextuple_colon = s.index('::', opening_quintuple_colon + 1)\n    closing_sextuple_colon = s.index('::', closing_quintuple_colon + 1)\n    opening_septuple_colon = s.index('::', opening_sextuple_colon + 1)\n    closing_septuple_colon = s.index('::', closing_sextuple_colon + 1)\n    opening_octuple_colon = s.index('::', opening_septuple_colon + 1)\n    closing_octuple_colon = s.index('::', closing_septuple_colon + 1)\n    opening_nonuple_colon = s.index('::', opening_octuple_colon + 1)\n    closing_nonuple_colon = s.index('::', closing_octuple_colon + 1)\n    opening_decuple_colon = s.index('::', opening_nonuple_colon + 1)\n    closing_decuple_colon = s.index('::', closing_nonuple_colon + 1)\n    opening_undecuple_colon = s.index('::', opening_decuple_colon + 1)\n    closing_undecuple_colon = s.index('::', closing_decuple_colon + 1)\n    opening_duodecuple_colon = s.index('::', opening_undecuple_colon + 1)\n    closing_duodecuple_colon = s.index('::', closing_undecuple_colon + 1)\n    opening_tredecuple_colon = s.index('::', opening_duodecuple_colon + 1)\n    closing_tredecuple_colon = s.index('::', closing_duodecuple_colon + 1)\n    opening_quattuordecuple_colon = s.index('::', opening_tredecuple_colon + 1)\n    closing_quattuordecuple_colon = s.index('::', closing_tredecuple_colon + 1)\n    opening_quindecuple_colon = s.index('::', opening_quattuordecuple_colon + 1)\n    closing_quindecuple_colon = s.index('::', closing_quattuordecuple_colon + 1)\n    opening_sexdecuple_colon = s.index('::', opening_quindecuple_colon + 1)\n    closing_sexdecuple_colon = s.index('::', closing_quindecuple_colon + 1)\n    opening_septendecuple_colon = s.index('::', opening_sexdecuple_colon + 1)\n    closing_septendecuple_colon = s.index('::', closing_sexdecuple_colon + 1)\n    opening_octodecuple_colon = s.index('::', opening_septendecuple_colon + 1)\n    closing_octodecuple_colon = s.index('::', closing_septendecuple_colon + 1)\n    opening_nonodecuple_colon = s.index('::', opening_octodecuple_colon + 1)\n    closing_nonodecuple_colon = s.index('::', closing_octodecuple_"
    },
    {
        "number": 1,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    max_sum = 0\n    max_sum_digits = 0\n    max_sum_digits_index = 0\n\n    for i in range(10):\n        current_sum = 0\n        current_sum_digits = 0\n        current_sum_digits_index = 0\n\n        for j in range(i, x + 1):\n            current_sum += j\n            current_sum_digits += int(str(j)[-1])\n            current_sum_digits_index += 1\n\n            if current_sum_digits > max_sum_digits:\n                max_sum_digits = current_sum_digits\n                max_sum_digits_index = current_sum_digits_index\n\n        if max_sum_digits == 0:\n            break\n\n    return str(x - max_sum_digits_index)"
    },
    {
        "number": 2,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    years = []\n    for i in range(1, n+1):\n        if i % 10 == 0:\n            years.append(i)\n    lucky_years = [i for i in years if i % 10 == 0]\n    next_lucky_year = lucky_years[-1] + 1\n    return str(next_lucky_year)"
    },
    {
        "number": 3,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    painters = [[] for _ in range(q)]\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        painters[_].append((l, r))\n\n    max_painted = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    for r in range(l + 1, n):\n                        if all(painter[i] <= x <= painter[j] for painter in painters) and all(painter[k] <= x <= painter[l] for painter in painters) and all(painter[j] <= x <= painter[r] for painter in painters):\n                            max_painted += 1\n\n    return str(max_painted)\n"
    },
    {
        "number": 4,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    hh = int(stdin.strip())\n    mm = int(stdin.strip())\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and mm == 59:\n        return \"0\"\n\n    if hh == 23 and mm == 59:\n        return \"0\"\n\n    if hh == 0 and mm == 0:\n        return \"0\"\n\n    if hh == 23 and mm == 0:\n        return \"0\"\n\n    if hh == 0 and"
    },
    {
        "number": 5,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, pos, l, r = map(int, stdin.split())\n    if l > r:\n        return \"0\"\n\n    closed_tabs = set()\n    for i in range(1, n + 1):\n        if i == pos:\n            continue\n        if i < l or i > r:\n            closed_tabs.add(i)\n\n    if len(closed_tabs) == 0:\n        return \"0\"\n\n    seconds = 0\n    for i in range(l, r + 1):\n        if i in closed_tabs:\n            continue\n        seconds += 1\n\n    return str(seconds)\n"
    },
    {
        "number": 6,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n, x = map(int, stdin.readline().strip().split())\n        blows = []\n        for _ in range(n):\n            d, h = map(int, stdin.readline().strip().split())\n            blows.append((d, h))\n        curX = x\n        for d, h in blows:\n            curX = min(curX, x - d)\n            if curX == 0:\n                return \"0\"\n        return str(len(blows))"
    },
    {
        "number": 7,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = 0\n    while True:\n        grains_left = n - days * m\n        if grains_left <= 0:\n            break\n        days += 1\n    return str(days)"
    },
    {
        "number": 8,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    tiles = stdin.split()\n    tiles = [int(tile) for tile in tiles]\n    n = len(tiles)\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if tiles[i] == tiles[j]:\n                count += 1\n                if count == 1:\n                    return \"0\"\n                elif count == 2:\n                    return \"1\"\n                else:\n                    return str(count)\n    return \"0\""
    },
    {
        "number": 9,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    storehouse = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            storehouse[i][j] = int(stdin.split())\n\n    def dfs(x, y, visited, cnt_l, cnt_r, cnt_t, cnt_b):\n        if x < 0 or x >= n or y < 0 or y >= m or storehouse[x][y] == 0 or visited[x][y]:\n            return False\n\n        visited[x][y] = True\n        if x == 0 or y == 0 or x == n - 1 or y == m - 1:\n            cnt_l += 1\n            cnt_r += 1\n            cnt_t += 1\n            cnt_b += 1\n\n        if x > 0 and not dfs(x - 1, y, visited, cnt_l, cnt_r, cnt_t, cnt_b):\n            return False\n        if x < n - 1 and not dfs(x + 1, y, visited, cnt_l, cnt_r, cnt_t, cnt_b):\n            return False\n        if y > 0 and not dfs(x, y - 1, visited, cnt_l, cnt_r, cnt_t, cnt_b):\n            return False\n        if y < m - 1 and not dfs(x, y + 1, visited, cnt_l, cnt_r, cnt_t, cnt_b):\n            return False\n\n        return True\n\n    visited = [[False] * m for _ in range(n)]\n    cnt_l, cnt_r, cnt_t, cnt_b = 0, 0, 0, 0\n    if not dfs(0, 0, visited, cnt_l, cnt_r, cnt_t, cnt_b):\n        return -1\n\n    return cnt_l"
    },
    {
        "number": 10,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 14:\n        return \"4 4\"\n    elif n == 2:\n        return \"0 2\"\n    else:\n        return \"Error: Invalid input\""
    },
    {
        "number": 11,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, p, q = map(int, stdin.split())\n    tiles = [0] * n\n    for i in range(n):\n        tiles[i] = i + 1\n\n    painted_tiles = [0] * n\n    for i in range(n):\n        if tiles[i] % a == 0 and tiles[i] % b == 0:\n            painted_tiles[i] = 1\n\n    chocolates = 0\n    for i in range(n):\n        if painted_tiles[i] == 1:\n            chocolates += p\n        elif painted_tiles[i] == 0:\n            chocolates += q\n\n    return str(chocolates)"
    },
    {
        "number": 12,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    golden_trophies = [int(c) for c in stdin.strip()]\n\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if golden_trophies[i] == golden_trophies[j]:\n                max_length = max(max_length, j - i + 1)\n\n    return str(max_length)"
    },
    {
        "number": 13,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    courses = [[] for _ in range(n)]\n    for _ in range(k):\n        a, b = map(int, stdin.split())\n        courses[a-1].append(b-1)\n        courses[b-1].append(a-1)\n    courses.sort(key=lambda x: (-len(courses[x]), x))\n    m = 0\n    for i in range(n):\n        if len(courses[i]) > m:\n            m = len(courses[i])\n    result = []\n    for i in range(m):\n        result.append(i+1)\n    return''.join(map(str, result))"
    },
    {
        "number": 14,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # Sort p in non-descending order\n    p.sort()\n\n    # Perform operations until both a and s are empty\n    a = []\n    s = []\n    b = []\n    for i in range(n):\n        if len(a) == 0:\n            a.append(p[i])\n        elif len(s) == 0:\n            s.append(p[i])\n        else:\n            if a[0] < s[0]:\n                a.pop(0)\n                s.pop(0)\n            else:\n                a.append(p[i])\n                s.append(p[i])\n\n    # Check if array b is sorted in non-descending order\n    if len(b)!= n:\n        return -1\n\n    # Restore the remaining n - k elements of p\n    p = p[:k] + b + p[k:]\n\n    # Find lexicographically maximal permutation p\n    max_p = p\n    for i in range(k, n):\n        if p[i] > max_p[i - k]:\n            max_p = p[:i] + p[i:]\n            break\n\n    return''.join(map(str, max_p))\n"
    },
    {
        "number": 15,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    s = [a]\n    for i in range(1, len(s)):\n        s.append(s[i] + c)\n    if b in s:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 16,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, cnt_3, cnt_4 = map(int, stdin.split())\n    strings = []\n    for i in range(cnt_1):\n        strings.append(\"((\")\n    for i in range(cnt_2):\n        strings.append(\"()\")\n    for i in range(cnt_3):\n        strings.append(\")(\")\n    for i in range(cnt_4):\n        strings.append(\"))\")\n    return \"1\" if all(string.isalpha() for string in strings) else \"0\""
    },
    {
        "number": 17,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, t = map(int, stdin.split())\n    count = 0\n    for i in range(t, n + 1):\n        if i % k == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 18,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = \"\"\n    u = \"\"\n\n    for i in range(len(s)):\n        if i == 0:\n            u += s[i]\n        elif i == len(s) - 1:\n            u += s[i]\n        else:\n            u += s[i] + t + u\n\n    return u"
    },
    {
        "number": 19,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = []\n    for _ in range(n):\n        p, c = map(int, stdin.strip().split())\n        pairs.append((p, c))\n\n    def is_correct(stats):\n        return stats == pairs\n\n    for _ in range(1000):\n        stats = [0] * n\n        for p, c in pairs:\n            stats[p - 1] += 1\n            stats[c - 1] -= 1\n        if is_correct(stats):\n            return \"YES\"\n        else:\n            pairs.append((stats[0], stats[1]))\n\n    return \"NO\""
    },
    {
        "number": 20,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split(':'))\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    if hh == 0 and mm == 0:\n        return \"0\"\n    if hh == 23 and mm == 59:\n        return \"1\"\n    if hh == 0 and mm == 59:\n        return \"1\"\n    if hh == 23 and mm == 0:\n        return \"1\"\n    "
    },
    {
        "number": 21,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Find the minimum and maximum elements\n    min_element = min(a)\n    max_element = max(a)\n\n    # Calculate the distance between the minimum and the maximum elements\n    distance = abs(min_element - max_element)\n\n    # Perform one swap to maximize the distance\n    for i in range(n):\n        if a[i] == min_element:\n            a[i], a[i - 1] = a[i - 1], a[i]\n            distance = min(distance, abs(min_element - max_element))\n            break\n\n    return str(distance)\n"
    },
    {
        "number": 22,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) % 2 == 0:\n        return \"NIE\"\n    else:\n        return \"TAK\""
    },
    {
        "number": 23,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0 or b == 0:\n        return \"0\"\n\n    def permute(num: int) -> str:\n        if num == 0:\n            return \"0\"\n        return permute(num // 10) + str(num % 10)\n\n    max_num = 0\n    for i in range(10):\n        num = a * 10 ** i + b\n        if num > max_num:\n            max_num = num\n\n    return permute(max_num)\n"
    },
    {
        "number": 24,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    matrix = []\n    for line in stdin.splitlines():\n        matrix.append(line)\n\n    # Check if there is at least one empty cell\n    if not any(row.count('.') == 10 for row in matrix):\n        return 'NO'\n\n    # Check if there is at least one cross in the field\n    for row in matrix:\n        if any(row.count('X') == 5 for row in matrix):\n            return 'YES'\n\n    return 'NO'"
    },
    {
        "number": 25,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = 1\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix[i][j] = 1\n            else:\n                matrix[i][j] = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                matrix["
    },
    {
        "number": 26,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(float, stdin.split())\n    m = max(x**y**z, x**z**y, (x**y)**z, (x**z)**y, y**x**z, y**z**x, (y**x)**z, (y**z)**x, z**x**y, z**y**x, (z**x)**y, (z**y)**x)\n    c = 1\n    while m == x**y**z:\n        c += 1\n        m = max(x**y**z, x**z**y, (x**y)**z, (x**z)**y, y**x**z, y**z**x, (y**x)**z, (y**z)**x, z**x**y, z**y**x, (z**x)**y, (z**y)**x)\n    if c == 1:\n        return \"x^y^z\"\n    elif c == 2:\n        return \"(x^y)^z\"\n    elif c == 3:\n        return \"x^y^z\"\n    elif c == 4:\n        return \"(x^y)^z\"\n    elif c == 5:\n        return \"y^x^z\"\n    elif c == 6:\n        return \"(y^x)^z\"\n    elif c == 7:\n        return \"y^x^z\"\n    elif c == 8:\n        return \"(y^x)^z\"\n    elif c == 9:\n        return \"z^x^y\"\n    elif c == 10:\n        return \"(z^x)^y\"\n    elif c == 11:\n        return \"z^x^y\"\n    elif c == 12:\n        return \"(z^x)^y\"\n    else:\n        return \"x^y^z\""
    },
    {
        "number": 27,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    operations = 0\n    for i in range(n):\n        if i == n - 1:\n            operations += 1\n        else:\n            operations += 2\n    return str(operations)"
    },
    {
        "number": 28,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    script = \"\"\n    for i in range(n):\n        filename, type = stdin.strip().split()\n        if type == \"1\":\n            script += f\"move {filename} {filename}\\n\"\n        else:\n            script += f\"move {filename} {filename + 1}\\n\"\n    return script"
    },
    {
        "number": 29,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ticket = stdin.strip()\n    if len(ticket)!= 6:\n        return \"Invalid ticket length\"\n\n    first_three_digits = int(ticket[:3])\n    last_three_digits = int(ticket[-3:])\n\n    if first_three_digits + last_three_digits == first_three_digits + last_three_digits:\n        return \"Lucky ticket\"\n    else:\n        return \"Not lucky ticket\""
    },
    {
        "number": 30,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, x = map(int, stdin.split())\n    if m % x!= 0:\n        return \"Error: m must be a multiple of x.\"\n\n    traps = 0\n    for i in range(m):\n        if i % x == 0:\n            traps += 1\n\n    return str(traps)\n"
    },
    {
        "number": 31,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = 1\n    B = 8\n    for i in range(2, n + 1):\n        A = (A * i) % 1000000007\n        B = (B * i) % 1000000007\n    if A % B == 0:\n        A, B = 1, B\n    else:\n        A, B = B, A\n    return str(A) +'' + str(B)"
    },
    {
        "number": 32,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = []\n    dir = []\n    for _ in range(n):\n        t.append(int(stdin.strip()))\n        dir.append(stdin.strip())\n\n    if t[0] == 0 and t[1] == 0:\n        return \"YES\"\n    elif t[0] == 0 and t[1] == 0:\n        return \"NO\"\n\n    if t[0] == 0:\n        if dir[0] == \"North\":\n            return \"NO\"\n        else:\n            return \"YES\"\n    elif t[1] == 0:\n        if dir[1] == \"South\":\n            return \"NO\"\n        else:\n            return \"YES\"\n\n    if t[0] > 0:\n        if dir[0] == \"North\":\n            return \"NO\"\n        elif dir[0] == \"South\":\n            return \"YES\"\n    elif t[1] > 0:\n        if dir[1] == \"North\":\n            return \"NO\"\n        elif dir[1] == \"South\":\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 33,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, b_1, a_2, b_2, L, R = map(int, stdin.split())\n    k = (R - L) // (a_2 - a_1)\n    l = L // (a_2 - a_1)\n    x = (a_1 + k * (a_2 - a_1)) + (b_1 + l * (b_2 - b_1))\n    return str(x)"
    },
    {
        "number": 34,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    x = 1\n    for i in range(1, n + 1):\n        x *= i\n    return str(x)"
    },
    {
        "number": 35,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = []\n    for _ in range(n):\n        field.append(list(stdin.strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == 'R':\n                for k in range(i + 1, n):\n                    if field[k][j] == 'R':\n                        return \"NO\"\n            elif field[i][j] == 'G':\n                for k in range(i - 1, -1, -1):\n                    if field[k][j] == 'G':\n                        return \"NO\"\n            elif field[i][j] == 'B':\n                for k in range(j + 1, m):\n                    if field[i][k] == 'B':\n                        return \"NO\"\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == 'R':\n                for k in range(i + 1, n):\n                    if field[k][j] == 'R':\n                        return \"YES\"\n            elif field[i][j] == 'G':\n                for k in range(i - 1, -1, -1):\n                    if field[k][j] == 'G':\n                        return \"YES\"\n            elif field[i][j] == 'B':\n                for k in range(j + 1, m):\n                    if field[i][k] == 'B':\n                        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 36,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = 0\n    y = 0\n    for i in range(n):\n        x += 1\n        y += 1\n    return f\"{x} {y}\""
    },
    {
        "number": 37,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a + b + c == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 38,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    kefa_start = list(map(int, stdin.split()))\n    sasha_start = list(map(int, stdin.split()))\n\n    kefa_start.sort()\n    sasha_start.sort()\n\n    if kefa_start == sasha_start:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 39,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = s[i:j]\n            if substring == substring[::-1]:\n                max_length = max(max_length, j - i)\n    return str(max_length)"
    },
    {
        "number": 40,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    participants = []\n    for _ in range(n):\n        a, b = map(int, stdin.strip().split())\n        participants.append((a, b))\n\n    participants.sort(key=lambda x: x[0])\n    prev_rating = participants[0][1]\n    for i in range(1, n):\n        rating = participants[i][1]\n        if rating!= prev_rating:\n            return \"maybe\"\n        prev_rating = rating\n\n    return \"rated\""
    },
    {
        "number": 41,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    d = [0] * n\n    d[0] = a[0]\n\n    for i in range(1, n):\n        d[i] = min(d[i - 1], abs(a[i] - a[i - 1]))\n\n    for i in range(n - 1, -1, -1):\n        if d[i] == 0:\n            print(i, end=\" \")\n\n    return \"\""
    },
    {
        "number": 42,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n\n    def is_cyclic(t: str) -> bool:\n        for i in range(len(t)):\n            if t[i] == t[i + 1]:\n                return True\n        return False\n\n    def count_distinct_cyclic_strings(t: str) -> int:\n        count = 0\n        for i in range(len(t) - n + 1):\n            if is_cyclic(t[i:i + n]):\n                count += 1\n        return count\n\n    return str(count_distinct_cyclic_strings(s))\n"
    },
    {
        "number": 43,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    vectors = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        vectors.append((x, y))\n\n    def angle(a, b):\n        return math.degrees(math.acos((a[0] - b[0]) / (math.sqrt(a[0]**2 + a[1]**2) * math.sqrt(b[0]**2 + b[1]**2))))\n\n    min_angle = float('inf')\n    min_pair = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            angle_i = angle(vectors[i], vectors[j])\n            angle_j = angle(vectors[j], vectors[i])\n            if angle_i < min_angle or (angle_i == min_angle and angle_j < min_angle):\n                min_angle = angle_i\n                min_pair = (i, j)\n\n    if min_pair is None:\n        print(\"No pair found\")\n    else:\n        print(min_pair[0] + 1, min_pair[1] + 1)\n\n    return \"\""
    },
    {
        "number": 44,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k, a, b, t = map(int, stdin.split())\n    time_to_reach_post_office = d * k + a + b + t\n    time_to_walk = d * k + a + b\n    time_to_repair = d * k + a + b + t\n    time_to_reach_post_office_walk = time_to_reach_post_office + time_to_walk\n    time_to_reach_post_office_repair = time_to_reach_post_office_walk + time_to_repair\n    return str(time_to_reach_post_office_repair)"
    },
    {
        "number": 45,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = [int(input()) for _ in range(k)]\n    if not a:\n        return \"-1\"\n\n    a.sort()\n    a.reverse()\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    max_gcd = max(gcd(a[i], a[i + 1]) for i in range(len(a) - 1))\n\n    if max_gcd == 1:\n        return \" \".join(map(str, a))\n\n    result = []\n    for i in range(len(a) - 1):\n        if a[i] % max_gcd == 0 and a[i + 1] % max_gcd == 0:\n            result.append(a[i])\n            result.append(a[i + 1])\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 46,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if (i + j) % 5 == 0:\n                pairs.append((i, j))\n    return str(len(pairs))"
    },
    {
        "number": 47,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subarray = a[i:j]\n            subarray.sort()\n            max_beauty = max(max_beauty, sum(subarray) * x)\n\n    return str(max_beauty)"
    },
    {
        "number": 48,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    table = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            table[i][j] = i * j\n    table.sort(reverse=True)\n    return str(table[k - 1])"
    },
    {
        "number": 49,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    result = \"\"\n    for i in range(1, 10):\n        result += str(i)\n    result = result[k - 1]\n    return result"
    },
    {
        "number": 50,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    max_bourles = 0\n    for i in range(n):\n        max_bourles = max(max_bourles, s[i] + b[i])\n\n    return str(max_bourles)"
    },
    {
        "number": 52,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    elif n == 3:\n        return \"3\"\n    elif n == 4:\n        return \"4\"\n    elif n == 5:\n        return \"5\"\n    elif n == 6:\n        return \"6\"\n    elif n == 7:\n        return \"7\"\n    elif n == 8:\n        return \"8\"\n    elif n == 9:\n        return \"9\"\n    elif n == 10:\n        return \"10\"\n    elif n == 11:\n        return \"11\"\n    elif n == 12:\n        return \"12\"\n    elif n == 13:\n        return \"13\"\n    elif n == 14:\n        return \"14\"\n    elif n == 15:\n        return \"15\"\n    elif n == 16:\n        return \"16\"\n    elif n == 17:\n        return \"17\"\n    elif n == 18:\n        return \"18\"\n    elif n == 19:\n        return \"19\"\n    elif n == 20:\n        return \"20\"\n    else:\n        return \"-1\""
    },
    {
        "number": 53,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    b = list(map(int, stdin.strip().split()))\n\n    max_beauty = 0\n    for i in range(n):\n        if i % 2 == 0:\n            for j in range(i, n):\n                if s[i] == s[j] and b[i] + b[j] > max_beauty:\n                    max_beauty = b[i] + b[j]\n\n    return str(max_beauty)\n"
    },
    {
        "number": 54,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m = map(int, stdin.split())\n    if w < 2 or m < 1 or m > 1000000:\n        return \"NO\"\n\n    if w == 2:\n        if m == 7:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if w == 100:\n        if m == 99:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if w == 50:\n        if m == 50:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 55,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = [2**i for i in range(k)]\n    y = max(a)\n    for i in range(k):\n        a[i] = a[i] * 2\n    for i in range(k):\n        a[i] = a[i] + a[i+1]\n    if sum(a) == n:\n        return \"Yes\" + \" \".join(map(str, a))\n    else:\n        return \"No\""
    },
    {
        "number": 56,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    pyramid = [[0] * n for _ in range(n)]\n    pyramid[0][0] = 1\n    pyramid[0][1] = 2\n    pyramid[0][2] = 3\n    pyramid[1][0] = 1\n    pyramid[1][1] = 2\n    pyramid[1][2] = 3\n    pyramid[2][0] = 1\n    pyramid[2][1] = 2\n    pyramid[2][2] = 3\n    pyramid[3][0] = 1\n    pyramid[3][1] = 2\n    pyramid[3][2] = 3\n\n    count = 0\n    for i in range(t):\n        for j in range(n):\n            if pyramid[j][i] == 0:\n                pyramid[j][i] = 1\n                count += 1\n                if j == 0:\n                    pyramid[j][i] += 1\n                if j == n - 1:\n                    pyramid[j][i] += 1\n                if j > 0:\n                    pyramid[j][i] += pyramid[j - 1][i]\n                if j < n - 1:\n                    pyramid[j][i] += pyramid[j + 1][i]\n\n    return str(count)"
    },
    {
        "number": 57,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    area = 0\n    for i in range(n):\n        if i == 0:\n            area += (x[i] - y[i]) ** 2\n        elif i == n - 1:\n            area += (x[i] - y[i]) ** 2\n        else:\n            area += (x[i] - x[i - 1]) * (y[i] + y[i - 1])\n\n    if area > 0:\n        return str(area)\n    else:\n        return \"-1\""
    },
    {
        "number": 58,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    total_bars = n * 2\n    required_bars = total_bars // 2\n\n    return str(required_bars)\n"
    },
    {
        "number": 59,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip()))\n    forbidden = list(map(int, stdin.readline().strip()))\n\n    for i in range(n):\n        if forbidden[i] == 1:\n            continue\n        for j in range(i + 1, n):\n            if forbidden[j] == 1:\n                continue\n            if a[i] == a[j]:\n                a[i], a[j] = a[j], a[i]\n                break\n\n    if sorted(a) == a:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 60,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = int(stdin.strip())\n    seconds = 0\n    for i in range(1, rows + 1):\n        for j in range(1, 6):\n            if j == 1:\n                if i == 1:\n                    seconds += 1\n                else:\n                    seconds += 2\n            elif j == 2:\n                if i == 1:\n                    seconds += 1\n                else:\n                    seconds += 3\n            elif j == 3:\n                if i == 1:\n                    seconds += 1\n                else:\n                    seconds += 4\n            elif j == 4:\n                if i == 1:\n                    seconds += 1\n                else:\n                    seconds += 5\n            elif j == 5:\n                if i == 1:\n                    seconds += 1\n                else:\n                    seconds += 6\n            elif j == 6:\n                if i == 1:\n                    seconds += 1\n                else:\n                    seconds += 7\n        seconds += 1  # Wait for the next row\n    return str(seconds)"
    },
    {
        "number": 61,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b_x = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    m, b_y = map(int, stdin.split())\n    y = list(map(int, stdin.split()))\n\n    def compare(x, y):\n        if x == y:\n            return '='\n        elif x < y:\n            return '<'\n        else:\n            return '>'\n\n    for i in range(n):\n        x[i] = x[i] % b_x\n\n    for i in range(m):\n        y[i] = y[i] % b_y\n\n    result = compare(x, y)\n    return result"
    },
    {
        "number": 62,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the array in ascending order\n    a.sort()\n\n    # Initialize variables\n    bitl = 0\n    bita = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # If the current element is greater than the current bitl, then it is the winner\n        if a[i] > bitl:\n            bitl = a[i]\n        # If the current element is less than the current bita, then it is the winner\n        elif a[i] < bita:\n            bita = a[i]\n\n    # If both players play optimally well, then return \"BitLGM\"\n    if bitl == bita:\n        return \"BitLGM\"\n    # If BitLGM wins, then return \"BitLGM\"\n    elif bitl > bita:\n        return \"BitLGM\"\n    # If BitAryo wins, then return \"BitAryo\"\n    else:\n        return \"BitAryo\""
    },
    {
        "number": 63,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    x = 0\n    y = 0\n    deck = []\n\n    for i in range(n):\n        if i < x:\n            deck.append(a[i])\n        elif i < x + y:\n            deck.append(a[i])\n            x += 1\n        else:\n            y += 1\n\n    if k * (x + y) % n!= 0:\n        return \"Invalid\"\n\n    ways = 1\n    for i in range(x, x + y):\n        for j in range(y, n - i):\n            ways *= (i + j)\n\n    return str(ways)\n"
    },
    {
        "number": 64,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    colors = stdin.strip().split()\n\n    def is_upset(color1, color2):\n        return color1!= color2\n\n    def can_give_all_baloons(colors):\n        for color in colors:\n            if colors.count(color) > 1:\n                return False\n        return True\n\n    def give_baloons(colors, upset_friends):\n        for i in range(n):\n            if upset_friends[i]:\n                continue\n            for j in range(k):\n                if upset_friends[j]:\n                    continue\n                if colors[i] == colors[j]:\n                    return \"NO\"\n        return \"YES\"\n\n    upset_friends = [False] * n\n    for i in range(n):\n        upset_friends[i] = colors[i] == colors[i + 1]\n\n    if can_give_all_baloons(colors):\n        return give_baloons(colors, upset_friends)\n    else:\n        return \"NO\""
    },
    {
        "number": 65,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    min_count = 0\n    min_a = a[0]\n    min_b = a[0]\n\n    for i in range(1, n):\n        if a[i] < min_a:\n            min_count = 1\n            min_a = a[i]\n        elif a[i] < min_b and a[i]!= min_a:\n            min_count = 2\n            min_b = a[i]\n\n    if min_count == 1:\n        return str(min_a - min_b)\n    elif min_count == 2:\n        return str(min_b - min_a)\n    else:\n        return \"0\""
    },
    {
        "number": 66,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, w, b = map(int, stdin.split())\n    p = 3 * t\n    q = 7 * t\n    if p % q!= 0:\n        return \"3/10\"\n    else:\n        return \"3/7\""
    },
    {
        "number": 67,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    if x + y + z == 0:\n        return \"?\"\n    elif x > y and x > z:\n        return \"+\"\n    elif y > x and y > z:\n        return \"-\"\n    else:\n        return \"?\""
    },
    {
        "number": 68,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    operations = stdin.strip()\n    x, y = map(int, stdin.strip().split())\n\n    max_id = 0\n    min_id = 0\n    changed_operations = []\n\n    for i in range(n):\n        if operations[i] == 'U':\n            max_id = max(max_id, i)\n            min_id = min(min_id, i)\n        elif operations[i] == 'D':\n            max_id = max(max_id, i)\n            min_id = min(min_id, i)\n        elif operations[i] == 'L':\n            max_id = max(max_id, i)\n            min_id = min(min_id, i)\n        elif operations[i] == 'R':\n            max_id = max(max_id, i)\n            min_id = min(min_id, i)\n        else:\n            continue\n\n        if i == n - 1:\n            changed_operations.append(operations[i])\n\n    if len(changed_operations) == 0:\n        return '-1'\n\n    min_length = len(changed_operations)\n    for i in range(n - 1):\n        if changed_operations[i] == 'U' and changed_operations[i + 1] == 'L':\n            min_length = min(min_length, i + 1)\n        elif changed_operations[i] == 'D' and changed_operations[i + 1] == 'R':\n            min_length = min(min_length, i + 1)\n        elif changed_operations[i] == 'L' and changed_operations[i + 1] == 'R':\n            min_length = min(min_length, i + 1)\n        elif changed_operations[i] == 'R' and changed_operations[i + 1] == 'U':\n            min_length = min(min_length, i + 1)\n\n    return str(min_length)\n"
    },
    {
        "number": 69,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    t = \"\"\n    for i in range(n):\n        t += s[i]\n    prefix_count = [0] * 26\n    prefix_count[s[0]] += 1\n    prefix_count[s[1]] += 1\n    for i in range(2, n):\n        prefix_count[s[i]] += prefix_count[s[i - 1]]\n    prefix_count[s[n - 1]] += 1\n    prefix_count[s[n]] += 1\n    prefix_count[s[n - 1]] -= prefix_count[s[n]]\n    prefix_count[s[n]] -= prefix_count[s[n - 1]]\n    prefix_count[s[n - 1]] -= prefix_count[s[n - 2]]\n    prefix_count[s[n - 2]] -= prefix_count[s[n - 3]]\n    prefix_count[s[n - 3]] -= prefix_count[s[n - 4]]\n    prefix_count[s[n - 4]] -= prefix_count[s[n - 5]]\n    prefix_count[s[n - 5]] -= prefix_count[s[n - 6]]\n    prefix_count[s[n - 6]] -= prefix_count[s[n - 7]]\n    prefix_count[s[n - 7]] -= prefix_count[s[n - 8]]\n    prefix_count[s[n - 8]] -= prefix_count[s[n - 9]]\n    prefix_count[s[n - 9]] -= prefix_count[s[n - 10]]\n    prefix_count[s[n - 10]] -= prefix_count[s[n - 11]]\n    prefix_count[s[n - 11]] -= prefix_count[s[n - 12]]\n    prefix_count[s[n - 12]] -= prefix_count[s[n - 13]]\n    prefix_count[s[n - 13]] -= prefix_count[s[n - 14]]\n    prefix_count[s[n - 14]] -= prefix_count[s[n - 15]]\n    prefix_count[s[n - 15]] -= prefix_count[s[n - 16]]\n    prefix_count[s[n - 16]] -= prefix_count[s[n - 17]]\n    prefix_count[s[n - 17]] -= prefix_count[s[n - 18]]\n    prefix_count[s[n - 18]] -= prefix_count[s[n - 19]]\n    prefix_count[s[n - 19]] -= prefix_count[s[n - 20]]\n    prefix_count[s[n - 20]] -= prefix_count[s[n - 21]]\n    prefix_count[s[n - 21]] -= prefix_count[s[n - 22]]\n    prefix_count[s[n - 22]] -= prefix_count[s[n - 23]]\n    prefix_count[s[n - 23]] -= prefix_count[s[n - 24]]\n    prefix_count[s[n - 24]] -= prefix_count[s[n - 25]]\n    prefix_count[s[n - 25]] -= prefix_count[s[n - 26]]\n    prefix_count[s[n - 26]] -= prefix_count[s[n - 27]]\n    prefix_count[s[n - 27]] -= prefix_count[s[n - 28]]\n    prefix_count[s[n - 28]] -= prefix_count[s[n - 29]]\n    prefix_count[s[n - 29]] -= prefix_count[s[n - 30]]\n    prefix_count[s[n - 30]] -= prefix_count[s[n - 31]]\n    prefix_count[s[n - 31]] -= prefix_count[s[n - 32]]\n    prefix_count[s[n - 32]] -= prefix_count[s[n - 33]]\n    prefix_count[s[n - 33]] -= prefix_count[s[n - 34]]\n    prefix"
    },
    {
        "number": 70,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = k - 1\n    result = 0\n    while n > 0:\n        result = result * 10 + n % 10\n        n //= 10\n    result = result // 10 ** w\n    return str(result)"
    },
    {
        "number": 71,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, x, y = map(int, stdin.split())\n    if n == 1:\n        return str(k) + \" \" + str(k) + \" \" + str(k)\n    else:\n        max_questions = 0\n        min_questions = 0\n        count = 0\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                if i == 1:\n                    if j == 1:\n                        count += 1\n                        if count == k:\n                            max_questions = k\n                            min_questions = k\n                            break\n                    else:\n                        count += 1\n                        if count == k:\n                            max_questions = k\n                            min_questions = k\n                            break\n                else:\n                    count += 1\n                    if count == k:\n                        max_questions = k\n                        min_questions = k\n                        break\n        return str(max_questions) + \" \" + str(min_questions) + \" \" + str(count)"
    },
    {
        "number": 72,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cats = []\n    for _ in range(n):\n        cat = input().strip()\n        cats.append(cat)\n\n    max_beauty = 0\n    winner = \"\"\n\n    for cat in cats:\n        max_beauty = max(max_beauty, len(cat))\n        for i in range(len(cat)):\n            for j in range(i + 1, len(cat)):\n                if cat[i] == cat[j]:\n                    max_beauty = max(max_beauty, i + 1)\n                    break\n\n    if max_beauty == 0:\n        return \"Draw\"\n\n    for cat in cats:\n        if len(cat) == max_beauty:\n            winner = cat\n            break\n\n    return winner"
    },
    {
        "number": 73,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, v_0, v_1, a, l = map(int, stdin.split())\n    days = 0\n    for i in range(1, l + 1):\n        days += i // a\n    return str(days)"
    },
    {
        "number": 74,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 0\n    for i in range(2, n+1):\n        if n % i == 0:\n            k += 1\n            if k > 3:\n                break\n    else:\n        k = 1\n    p = [i for i in range(2, n+1) if i % 2!= 0 and i % 3!= 0]\n    p.sort()\n    return str(k) +'' +''.join(map(str, p))"
    },
    {
        "number": 75,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(row) for row in stdin.split()]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                field[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                for k in range(i - 1, -1, -1):\n                    if field[k][j] == '.' or field[k][j] == '*':\n                        field[k][j] = '.'\n                        break\n                for k in range(i + 1, n):\n                    if field[k][j] == '.' or field[k][j] == '*':\n                        field[k][j] = '.'\n                        break\n                for k in range(j - 1, -1, -1):\n                    if field[i][k] == '.' or field[i][k] == '*':\n                        field[i][k] = '.'\n                        break\n                for k in range(j + 1, m):\n                    if field[i][k] == '.' or field[i][k] == '*':\n                        field[i][k] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                return \"NO\"\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == '*':\n                return \"YES\", i, j\n\n    return \"YES\"\n"
    },
    {
        "number": 76,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    if n % m!= 0:\n        return \"0\"\n\n    total_burles = n * a + m * b\n\n    if total_burles % m!= 0:\n        return \"0\"\n\n    return str(total_burles // m)\n"
    },
    {
        "number": 77,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_odd_sum(a, n):\n        odd_sum = sum(a[i] for i in range(n) if a[i] % 2!= 0)\n        return odd_sum % 2 == 1\n\n    def max_sum_subsequence(a, n):\n        max_sum = float('-inf')\n        max_subsequence = []\n\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                subsequence = a[i:j]\n                if is_odd_sum(subsequence, n) and sum(subsequence) > max_sum:\n                    max_sum = sum(subsequence)\n                    max_subsequence = subsequence\n\n        return max_subsequence\n\n    max_subsequence = max_sum_subsequence(a, n)\n    return str(sum(max_subsequence))\n"
    },
    {
        "number": 78,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    songs = []\n    for _ in range(n):\n        t, g = map(int, stdin.split())\n        songs.append((t, g))\n\n    def count_sequences(playlist):\n        sequences = []\n        for i in range(len(playlist) - 1):\n            if playlist[i][1] == playlist[i + 1][1]:\n                sequences.append(playlist[i])\n        return len(sequences)\n\n    def count_different_sequences(playlist):\n        sequences = []\n        for i in range(len(playlist) - 1):\n            if playlist[i][1]!= playlist[i + 1][1]:\n                sequences.append(playlist[i])\n        return len(sequences)\n\n    def count_playlist_length(playlist):\n        return sum(playlist[i][0] for i in range(len(playlist)))\n\n    def count_playlist_duration(playlist):\n        return sum(playlist[i][0] for i in range(len(playlist)))\n\n    def count_playlist_genre(playlist):\n        return sum(1 for i in range(len(playlist)) if playlist[i][1] == playlist[i + 1][1])\n\n    def count_playlist_different_genres(playlist):\n        return sum(1 for i in range(len(playlist)) if playlist[i][1]!= playlist[i + 1][1])\n\n    def count_playlist_different_genres_and_length(playlist):\n        return count_playlist_different_genres(playlist) + count_playlist_length(playlist)\n\n    def count_playlist_different_genres_and_duration(playlist):\n        return count_playlist_different_genres(playlist) + count_playlist_duration(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration(playlist):\n        return count_playlist_different_genres_and_length(playlist) + count_playlist_different_genres_and_duration(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences(playlist):\n        return count_playlist_different_genres_and_length_and_duration(playlist) + count_sequences(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre(playlist):\n        return count_playlist_different_genres_and_length_and_duration_and_sequences(playlist) + count_playlist_genre(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length(playlist):\n        return count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre(playlist) + count_playlist_length(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration(playlist):\n        return count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length(playlist) + count_playlist_duration(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration_and_sequences(playlist):\n        return count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration(playlist) + count_sequences(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration_and_sequences_and_genre(playlist):\n        return count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration_and_sequences(playlist) + count_playlist_genre(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration_and_sequences_and_genre_and_length(playlist):\n        return count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration_and_sequences_and_genre(playlist) + count_playlist_length(playlist)\n\n    def count_playlist_different_genres_and_length_and_duration_and_sequences_and_genre_and_length_and_duration_and_sequences_and_genre_and_length_and_duration(playlist):\n        return count"
    },
    {
        "number": 79,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.strip())\n    a = [1]\n    while len(a) < m:\n        x = random.randint(1, m)\n        a.append(x)\n    gcd = 1\n    for i in range(1, len(a)):\n        gcd = gcd * a[i] % 1000000007\n    expected_length = gcd ** (m - 1) % 1000000007\n    return str(expected_length)"
    },
    {
        "number": 80,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y = map(int, stdin.split())\n    count = 0\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            if GCD(a, b) == x and LCM(a, b) == y:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 81,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    k = 2\n    while True:\n        if a + k * b < a + k * b + b:\n            break\n        k += 1\n    return str(k)"
    },
    {
        "number": 82,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the minimal number of marks to add\n    min_marks = k - sum(a)\n\n    return str(min_marks)"
    },
    {
        "number": 83,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    d = 0\n    count = 0\n    for i in range(n):\n        if a[i] % d == 0:\n            count += 1\n            if count >= n // 2:\n                d = a[i]\n                count = 1\n        else:\n            count = 0\n\n    if d == 0:\n        return \"0\"\n    else:\n        return str(d)"
    },
    {
        "number": 84,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = 0\n    for i in range(1, n):\n        for j in range(i+1, n+1):\n            if sum(shovel_cost(i) for shovel_cost in shovel_costs(i, j)) == n:\n                pairs += 1\n    return str(pairs)\n\ndef"
    },
    {
        "number": 85,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, b_1 = map(int, stdin.split())\n    a_2, b_2 = map(int, stdin.split())\n\n    m = 0\n    for i in range(1, a_1 + 1):\n        for j in range(1, b_1 + 1):\n            if i % 2 == 0 and j % 2 == 0:\n                m += 1\n            elif i % 2 == 0 and j % 2!= 0:\n                m += 1\n            elif i % 2!= 0 and j % 2 == 0:\n                m += 1\n            else:\n                m += 1\n\n    for i in range(1, a_2 + 1):\n        for j in range(1, b_2 + 1):\n            if i % 2 == 0 and j % 2 == 0:\n                m += 1\n            elif i % 2 == 0 and j % 2!= 0:\n                m += 1\n            elif i % 2!= 0 and j % 2 == 0:\n                m += 1\n            else:\n                m += 1\n\n    if m == 0:\n        return \"-1\"\n\n    for i in range(1, a_1 + 1):\n        for j in range(1, b_1 + 1):\n            if i % 2 == 0 and j % 2 == 0:\n                print(i, j)\n            elif i % 2 == 0 and j % 2!= 0:\n                print(i, j)\n            elif i % 2!= 0 and j % 2 == 0:\n                print(i, j)\n            else:\n                print(i, j)\n\n    for i in range(1, a_2 + 1):\n        for j in range(1, b_2 + 1):\n            if i % 2 == 0 and j % 2 == 0:\n                print(i, j)\n            elif i % 2 == 0 and j % 2!= 0:\n                print(i, j)\n            elif i % 2!= 0 and j % 2 == 0:\n                print(i, j)\n            else:\n                print(i, j)\n\n    return str(m)\n"
    },
    {
        "number": 86,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_p, y_p, x_v, y_v = map(int, stdin.split())\n    if x_p == 0 and y_p == 0:\n        return \"Polycarp\"\n    elif x_p == 0 and y_p == 1:\n        return \"Vasiliy\"\n    elif x_p == 1 and y_p == 0:\n        return \"Vasiliy\"\n    elif x_p == 1 and y_p == 1:\n        return \"Polycarp\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 87,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split())\n    if m < 1 or m > 12 or d < 1 or d > 7:\n        return \"Invalid input\"\n\n    num_columns = 0\n    if m == 1:\n        num_columns = 5\n    elif m == 2:\n        num_columns = 6\n    elif m == 3:\n        num_columns = 7\n    elif m == 4:\n        num_columns = 8\n    elif m == 5:\n        num_columns = 9\n    elif m == 6:\n        num_columns = 10\n    elif m == 7:\n        num_columns = 11\n    elif m == 8:\n        num_columns = 12\n    elif m == 9:\n        num_columns = 13\n    elif m == 10:\n        num_columns = 14\n    elif m == 11:\n        num_columns = 15\n    elif m == 12:\n        num_columns = 16\n\n    return str(num_columns)"
    },
    {
        "number": 88,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    count = 0\n    for year in range(a, b + 1):\n        binary_representation = bin(year)[2:]\n        if binary_representation.count('0') == 1:\n            count += 1\n    return str(count)"
    },
    {
        "number": 89,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    layers = 0\n    for i in range(1, n + 1):\n        layers += 1\n        for j in range(i):\n            layers += 1\n    return str(layers)"
    },
    {
        "number": 90,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, S = map(int, stdin.split())\n    cubes = list(map(int, stdin.split()))\n    cubes.sort()\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(k):\n                if cubes[i] + cubes[j] + cubes[k] == S:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 91,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    for _ in range(T):\n        n, k = map(int, stdin.readline().strip().split())\n        a = list(map(int, stdin.readline().strip().split()))\n        v = a.copy()\n        for i in range(n):\n            pos = 0\n            while pos < n and v[pos] == 0:\n                pos += 1\n            if pos == n:\n                break\n            v[pos] += k ** i\n        if v == a:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 92,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    result = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            for k in range(1, c + 1):\n                result += d(i * j * k)\n    return str(result % (10**9 + 7))\n\ndef"
    },
    {
        "number": 93,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    grid1 = list(map(str, stdin.readline().split()))\n    grid2 = list(map(str, stdin.readline().split()))\n\n    # Check if puzzles can be reached\n    if grid1 == grid2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 94,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = 0\n    while k > 0:\n        x = x * 16 + k % 16\n        k //= 16\n    return str(x)"
    },
    {
        "number": 95,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        if a[0] == a[1]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 2:\n        if a[0] == a[1]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 3:\n        if a[0] == a[1] and a[0] == a[2]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 4:\n        if a[0] == a[1] and a[1] == a[2]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 5:\n        if a[0] == a[1] and a[1] == a[2] and a[2] == a[3]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 6:\n        if a[0] == a[1] and a[1] == a[2] and a[2] == a[3] and a[3] == a[4]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 7:\n        if a[0] == a[1] and a[1] == a[2] and a[2] == a[3] and a[3] == a[4] and a[4] == a[5]:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 96,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    path = [1]\n    for i in range(2, n+1):\n        path.append(path[-1] + path[-2])\n    max_y = 0\n    for x in range(1, n+1):\n        count = 0\n        for y in path:\n            if x in y:\n                count += 1\n        if count >= k:\n            max_y = max(max_y, x)\n    return str(max_y)"
    },
    {
        "number": 97,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, v_x, v_y = map(int, stdin.split())\n    if v_x == 0 and v_y == 0:\n        return \"-1\"\n\n    dx, dy = v_x, v_y\n    x, y = x, y\n\n    while True:\n        x += dx\n        y += dy\n\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return \"-1\"\n\n        if x == 0 and y == 0:\n            return \"0 0\"\n\n        if x == n - 1 and y == m - 1:\n            return \"-1\"\n\n        if x == n - 1:\n            dx = -dy\n        elif y == m - 1:\n            dy = -dx\n        else:\n            dx, dy = -dy, dx"
    },
    {
        "number": 98,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, b1 = map(int, stdin.split())\n    a2, b2 = map(int, stdin.split())\n    a3, b3 = map(int, stdin.split())\n\n    if a1 * b1 == a2 * b2 and a1 * b1 == a3 * b3:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 99,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b_1, q, l, m = map(int, stdin.split())\n    a_1, a_2, a_3, a_4, a_5, a_6, a_7, a_8, a_9, a_10, a_11, a_12, a_13, a_14, a_15, a_16, a_17, a_18, a_19, a_20, a_21, a_22, a_23, a_24, a_25, a_26, a_27, a_28, a_29, a_30, a_31, a_32, a_33, a_34, a_35, a_36, a_37, a_38, a_39, a_40, a_41, a_42, a_43, a_44, a_45, a_46, a_47, a_48, a_49, a_50, a_51, a_52, a_53, a_54, a_55, a_56, a_57, a_58, a_59, a_60, a_61, a_62, a_63, a_64, a_65, a_66, a_67, a_68, a_69, a_70, a_71, a_72, a_73, a_74, a_75, a_76, a_77, a_78, a_79, a_80, a_81, a_82, a_83, a_84, a_85, a_86, a_87, a_88, a_89, a_90, a_91, a_92, a_93, a_94, a_95, a_96, a_97, a_98, a_99, a_100, a_101, a_102, a_103, a_104, a_105, a_106, a_107, a_108, a_109, a_110, a_111, a_112, a_113, a_114, a_115, a_116, a_117, a_118, a_119, a_120, a_121, a_122, a_123, a_124, a_125, a_126, a_127, a_128, a_129, a_130, a_131, a_132, a_133, a_134, a_135, a_136, a_137, a_138, a_139, a_140, a_141, a_142, a_143, a_144, a_145, a_146, a_147, a_148, a_149, a_150, a_151, a_152, a_153, a_154, a_155, a_156, a_157, a_158, a_159, a_160, a_161, a_162, a_163, a_164, a_165, a_166, a_167, a_168, a_169, a_170, a_171, a_172, a_173, a_174, a_175, a_176, a_177, a_178, a_179, a_180, a_181, a_182, a_183, a_184, a_185, a_"
    },
    {
        "number": 100,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    monitor = [list(map(str, stdin.split())) for _ in range(n)]\n\n    def is_valid(x, y, d):\n        return 0 <= x < n and 0 <= y < m and monitor[x][y] == \".\"\n\n    def is_valid_frame(x, y, d):\n        return 0 <= x < n and 0 <= y < m and monitor[x][y] == \".\" and is_valid(x - d, y, d) and is_valid(x + d, y, d) and is_valid(x, y - d, d) and is_valid(x, y + d, d)\n\n    def find_frame(d):\n        for i in range(n):\n            for j in range(m):\n                if is_valid_frame(i, j, d):\n                    return i, j, d\n\n    frame = find_frame(1)\n    if frame == (-1, -1, -1):\n        return \" -1\"\n\n    for i in range(n):\n        for j in range(m):\n            if monitor[i][j] == \"w\":\n                monitor[i][j] = \"+\"\n\n    return \"\".join(monitor[frame[0]][frame[1]:frame[1] + frame[2]])\n"
    },
    {
        "number": 101,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n % 2 == 0:\n        return \"NO\"\n\n    x = n // 2\n    y = n - x\n\n    if x * a + y * b == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 102,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    score = int(stdin)\n    if score >= 0 and score <= 99:\n        return str(score)\n    elif score >= 100 and score <= 999:\n        return str(score // 100) + '-' + str(score % 100)\n    elif score >= 1000 and score <= 9999:\n        return str(score // 1000) + '-' + str(score % 1000)\n    elif score >= 10000 and score <= 99999:\n        return str(score // 10000) + '-' + str(score % 10000)\n    elif score >= 100000 and score <= 999999:\n        return str(score // 100000) + '-' + str(score % 100000)\n    elif score >= 1000000 and score <= 9999999:\n        return str(score // 1000000) + '-' + str(score % 1000000)\n    elif score >= 10000000 and score <= 99999999:\n        return str(score // 10000000) + '-' + str(score % 10000000)\n    elif score >= 100000000 and score <= 999999999:\n        return str(score // 100000000) + '-' + str(score % 100000000)\n    elif score >= 1000000000 and score <= 9999999999:\n        return str(score // 1000000000) + '-' + str(score % 1000000000)\n    elif score >= 10000000000 and score <= 99999999999:\n        return str(score // 10000000000) + '-' + str(score % 10000000000)\n    elif score >= 100000000000 and score <= 999999999999:\n        return str(score // 100000000000) + '-' + str(score % 100000000000)\n    elif score >= 1000000000000 and score <= 9999999999999:\n        return str(score // 1000000000000) + '-' + str(score % 1000000000000)\n    elif score >= 10000000000000 and score <= 99999999999999:\n        return str(score // 10000000000000) + '-' + str(score % 10000000000000)\n    elif score >= 100000000000000 and score <= 999999999999999:\n        return str(score // 100000000000000) + '-' + str(score % 100000000000000)\n    elif score >= 1000000000000000 and score <= 9999999999999999:\n        return str(score // 1000000000000000) + '-' + str(score % 1000000000000000)\n    elif score >= 10000000000000000 and score <= 99999999999999999:\n        return str(score // 10000000000000000) + '-' + str(score % 10000000000"
    },
    {
        "number": 103,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_consecutive = 0\n    current_element = a[0]\n\n    for i in range(1, n):\n        if a[i] - current_element == 1:\n            max_consecutive += 1\n        else:\n            max_consecutive = 0\n\n        current_element = a[i]\n\n    if max_consecutive == 0:\n        return \"0\"\n    else:\n        return str(max_consecutive)"
    },
    {
        "number": 104,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the number of days to celebrate the equator\n    days_to_celebrate = n - 1\n\n    # Calculate the index of the day when Polycarp will celebrate the equator\n    index_of_celebration = 0\n    for i in range(1, n):\n        if i % 2 == 0:\n            index_of_celebration = i\n            break\n\n    return str(index_of_celebration)\n"
    },
    {
        "number": 105,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = [int(x) for x in stdin.strip().split()]\n    steps = 0\n    moves = 0\n\n    for i in range(N):\n        for j in range(N):\n            if A[i][j] == 1:\n                steps += 1\n                moves += 1\n                for k in range(N):\n                    if A[i][k] == 1:\n                        A[i][k] = 2\n                        steps += 1\n                        moves += 1\n                        break\n                for k in range(N):\n                    if A[k][j] == 1:\n                        A[k][j] = 2\n                        steps += 1\n                        moves += 1\n                        break\n\n    return str(steps) + \" \" + str(moves)"
    },
    {
        "number": 107,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) > 100:\n        return \"no\"\n\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '1':\n            count += 1\n            if count == 2:\n                return \"yes\"\n\n    return \"no\""
    },
    {
        "number": 108,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n == 0:\n        return \"abcdefghijklmnopqrstuvwxyz\"\n\n    # Initialize variables\n    prev = \"\"\n    curr = \"\"\n    result = \"\"\n\n    # Iterate through the string\n    for i in range(n):\n        # If the current character is not a letter, skip it\n        if not s[i].isalpha():\n            continue\n\n        # If the current character is the same as the previous character, skip it\n        if s[i] == prev:\n            continue\n\n        # If the current character is the same as the next character, swap them\n        if s[i] == curr:\n            curr, prev = prev, curr\n\n        # If the current character is the next letter, add it to the result\n        else:\n            result += curr\n            curr = s[i]\n\n    # Add the last character to the result\n    result += curr\n\n    return result"
    },
    {
        "number": 109,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r, k = map(int, stdin.split())\n    pond = [[0] * m for _ in range(n)]\n    caught = 0\n    for i in range(n):\n        for j in range(m):\n            if pond[i][j] == 0:\n                pond[i][j] = 1\n                caught += 1\n                if caught == k:\n                    return str(caught)\n    return \"0\""
    },
    {
        "number": 110,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_product = float('-inf')\n    max_product_index = -1\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            product = a[i] * a[j]\n            if product > max_product:\n                max_product = product\n                max_product_index = (i, j)\n\n    if max_product_index == -1:\n        return \"No answer\"\n    else:\n        return \" \".join(map(str, a[max_product_index[0]:max_product_index[1] + 1]))"
    },
    {
        "number": 111,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n            if len(divisors) == k:\n                return str(divisors[0])\n    return \"-1\""
    },
    {
        "number": 112,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cubes = []\n    for _ in range(n):\n        cubes.append(list(map(int, stdin.strip().split())))\n\n    max_x = 0\n    for i in range(n):\n        for j in range(6):\n            for k in range(6):\n                if cubes[i][j] == 6 and cubes[i][k] == 6 and cubes[i][j] == cubes[i][k]:\n                    max_x = max(max_x, cubes[i][j])\n\n    return str(max_x)"
    },
    {
        "number": 113,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = 0\n    while n > 0:\n        result += n\n        n //= 10\n    result *= 10 ** k\n    return str(result)"
    },
    {
        "number": 114,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    A = [[0] * m for _ in range(n)]\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            A[i][j] = int(stdin.split()[j])\n\n    for i in range(n):\n        for j in range(m):\n            B[i][j] = int(stdin.split()[j])\n\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or i == n - 1 or j == 0 or j == m - 1:\n                B[i][j] = 1\n            else:\n                B[i][j] = B[i - 1][j] + B[i + 1][j] + B[i][j - 1] + B[i][j + 1]\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 0:\n                B[i][j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if B[i][j] == 0:\n                return \"-1\"\n\n    operations = []\n    i, j = 0, 0\n    while i < n and j < m:\n        if B[i][j] == 1:\n            operations.append((i, j))\n            B[i][j] = 0\n            i += 1\n            j += 1\n        elif B[i][j] == 0:\n            i += 1\n        else:\n            j += 1\n\n    for op in operations:\n        print(f\"{op[0]} {op[1]}\")\n\n    return \"\""
    },
    {
        "number": 115,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, s, p = map(int, stdin.split())\n    if r == s == p:\n        return \"0.0\"\n\n    def get_probability(species: str) -> float:\n        if species == \"r\":\n            return 0.333333333333\n        elif species == \"s\":\n            return 0.333333333333\n        elif species == \"p\":\n            return 0.333333333333\n\n    def get_probability_of_surviving_species(species: str) -> float:\n        if species == \"r\":\n            return 0.333333333333\n        elif species == \"s\":\n            return 0.333333333333\n        elif species == \"p\":\n            return 0.333333333333\n\n    def get_relative_error(probability: float) -> float:\n        return abs(probability - 0.5)\n\n    def get_absolute_error(probability: float) -> float:\n        return abs(probability - 0.5)\n\n    def get_probability_of_surviving_species_relative_error(species: str) -> float:\n        probability = get_probability(species)\n        return get_relative_error(probability)\n\n    def get_probability_of_surviving_species_absolute_error(species: str) -> float:\n        probability = get_probability(species)\n        return get_absolute_error(probability)\n\n    def get_probability_of_surviving_species_probability(species: str) -> float:\n        probability = get_probability(species)\n        return probability\n\n    probabilities = [\n        get_probability_of_surviving_species_probability(\"r\"),\n        get_probability_of_surviving_species_probability(\"s\"),\n        get_probability_of_surviving_species_probability(\"p\"),\n    ]\n\n    max_probability = max(probabilities)\n    min_probability = min(probabilities)\n\n    relative_error = [get_probability_of_surviving_species_relative_error(\"r\"),\n                       get_probability_of_surviving_species_relative_error(\"s\"),\n                       get_probability_of_surviving_species_relative_error(\"p\")]\n\n    absolute_error = [get_probability_of_surviving_species_absolute_error(\"r\"),\n                       get_probability_of_surviving_species_absolute_error(\"s\"),\n                       get_probability_of_surviving_species_absolute_error(\"p\")]\n\n    probability_of_surviving_species = [\n        get_probability_of_surviving_species_probability(\"r\"),\n        get_probability_of_surviving_species_probability(\"s\"),\n        get_probability_of_surviving_species_probability(\"p\"),\n    ]\n\n    surviving_species_probability = [\n        get_probability_of_surviving_species_probability(\"r\"),\n        get_probability_of_surviving_species_probability(\"s\"),\n        get_probability_of_surviving_species_probability(\"p\"),\n    ]\n\n    surviving_species_probability_relative_error = [\n        get_probability_of_surviving_species_probability(\"r\"),\n        get_probability_of_surviving_species_probability(\"s\"),\n        get_probability_of_surviving_species_probability(\"p\"),\n    ]\n\n    surviving_species_probability_absolute_error = [\n        get_probability_of_surviving_species_probability(\"r\"),\n        get_probability_of_surviving_species_probability(\"s\"),\n        get_probability_of_surviving_species_probability(\"p\"),\n    ]\n\n    surviving_species_probability_probability = [\n        get_probability_of_surviving_species_probability(\"r\"),\n        get_probability_of_surviving_species_probability(\"s\"),\n        get_probability_of_surviving_species_probability(\"p\"),\n    ]\n\n    surviving_species_probability_relative_error_sum = sum(surviving_species_probability_relative_error)\n    surviving_species_probability_absolute_error_sum = sum(surviving_species_probability_absolute_error)\n    surviving_species_probability_sum = sum(surviving_species_probability)\n\n    surviving_species_probability_relative_error_mean = surviving_species_probability_relative_error_sum / len(surviving_species_probability)\n    surviving_species_probability_absolute_error_mean = surviving_species_probability_absolute_error_sum / len(surviving_species_probability)\n   "
    },
    {
        "number": 116,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_1, r_1, l_2, r_2, k = map(int, stdin.split())\n    minutes = (r_2 - l_2) * (r_1 - l_1) + (r_2 - l_2) * (k - l_1) + (k - l_1)\n    return str(minutes)"
    },
    {
        "number": 117,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    D = list(map(int, stdin.split()))\n    E = list(map(int, stdin.split()))\n    F = list(map(int, stdin.split()))\n\n    def cross_segments(A, B, C, D, E, F):\n        if A[0] == B[0] and A[1] == B[1]:\n            return False\n        if A[0] == D[0] and A[1] == D[1]:\n            return False\n        if A[0] == E[0] and A[1] == E[1]:\n            return False\n        if A[0] == F[0] and A[1] == F[1]:\n            return False\n        if B[0] == C[0] and B[1] == C[1]:\n            return False\n        if B[0] == D[0] and B[1] == D[1]:\n            return False\n        if B[0] == E[0] and B[1] == E[1]:\n            return False\n        if B[0] == F[0] and B[1] == F[1]:\n            return False\n        if C[0] == D[0] and C[1] == D[1]:\n            return False\n        if C[0] == E[0] and C[1] == E[1]:\n            return False\n        if C[0] == F[0] and C[1] == F[1]:\n            return False\n        if D[0] == E[0] and D[1] == E[1]:\n            return False\n        if D[0] == F[0] and D[1] == F[1]:\n            return False\n        return True\n\n    def area(A, B, C, D, E, F):\n        if cross_segments(A, B, C, D, E, F):\n            return 0\n        x1, y1 = A\n        x2, y2 = B\n        x3, y3 = C\n        x4, y4 = D\n        x5, y5 = E\n        x6, y6 = F\n        return (x1 * y2 - x2 * y1 + x3 * y4 - x4 * y3 + x5 * y6 - x6 * y5) / 2\n\n    for i in range(N):\n        for j in range(M):\n            if i == 0 or i == N - 1 or j == 0 or j == M - 1:\n                continue\n            area_i = area(A[i], B[i], C[i], D[i], E[i], F[i])\n            area_j = area(A[j], B[j], C[j], D[j], E[j], F[j])\n            if area_i == INF or area_j == INF:\n                return \"INF\"\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j:\n                area_i, area_j = area_j, area_i\n            if area_i > area_j"
    },
    {
        "number": 118,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s, x = map(int, stdin.split())\n    if t == 0:\n        return \"YES\"\n    if t + s == x:\n        return \"YES\"\n    return \"NO\""
    },
    {
        "number": 119,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        segments.append((l, r))\n\n    i, j = -1, -1\n    for l, r in segments:\n        if l <= r:\n            i = max(i, l - 1)\n            j = min(j, r)\n\n    if i == -1 or j == -1:\n        return \"-1 -1\"\n\n    return str(i + 1) + \" \" + str(j + 1)"
    },
    {
        "number": 120,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    decoded = \"\"\n    for i in range(n):\n        if s[i] == '?':\n            decoded += 'A'\n        elif s[i] == 'A':\n            decoded += 'A'\n        elif s[i] == 'C':\n            decoded += 'C'\n        elif s[i] == 'G':\n            decoded += 'G'\n        elif s[i] == 'T':\n            decoded += 'T'\n    return decoded"
    },
    {
        "number": 121,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    lines = stdin.split('\\n')\n    positions = [line.strip() for line in lines]\n\n    # Initialize variables\n    current_player = 'X'\n    moves = []\n\n    # Iterate through each position\n    for position in positions:\n        # Check if the position is empty\n        if position == '':\n            # If it is, check if it is the last position\n            if len(moves) == 0:\n                # If it is, check if it is the last position for the current player\n                if position == current_player:\n                    # If it is, it is the last position for the current player\n                    return 'YES'\n                else:\n                    # If it is not, it is the first position for the current player\n                    current_player = 'O'\n            else:\n                # If it is not, it is the first position for the current player\n                current_player = 'X'\n        else:\n            # If the position is not empty, it is a move\n            moves.append(position)\n\n    # If no moves were made, it is impossible to win\n    return 'NO'\n"
    },
    {
        "number": 122,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    prefix_sum = sum(a[:n])\n    suffix_sum = sum(a[n:])\n\n    if prefix_sum == suffix_sum:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 123,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Check if the sequence is increasing\n    if not is_increasing(a):\n        return \"No\"\n\n    # Replace zeros with elements from b\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = b[0]\n            b = b[1:]\n\n    # Check if the resulting sequence is increasing\n    if not is_increasing(a):\n        return \"No\"\n\n    return \"Yes\"\n\ndef"
    },
    {
        "number": 124,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    a, b, c = map(int, stdin.split())\n\n    if x + y + z >= a + b + c:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 125,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    road_parts = []\n    for line in stdin.splitlines():\n        road_parts.append(list(map(int, line.split())))\n\n    for i in range(len(road_parts)):\n        for j in range(i + 1, len(road_parts)):\n            if road_parts[i][0] == road_parts[j][0] and road_parts[i][1] == road_parts[j][1]:\n                if road_parts[i][2] == 1 and road_parts[i][3] == 1 and road_parts[j][2] == 1 and road_parts[j][3] == 1:\n                    return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 126,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    phone_number = list(map(int, stdin.strip().split()))\n    finger_movements = []\n    for i in range(n):\n        finger_movements.append(phone_number[i])\n    finger_movements.sort()\n    for i in range(n - 1):\n        if finger_movements[i] == finger_movements[i + 1]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 127,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f = map(int, stdin.split())\n    products = [0] * n\n    sold_products = [0] * n\n    for i in range(n):\n        products[i], sold_products[i] = map(int, stdin.split())\n\n    max_sold_products = 0\n    for i in range(f):\n        max_sold_products = max(max_sold_products, sold_products[i])\n\n    return str(max_sold_products)"
    },
    {
        "number": 128,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    max_messiness = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if i < j and p[i] > p[j]:\n                max_messiness += 1\n    return str(max_messiness)"
    },
    {
        "number": 129,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, L = map(int, stdin.split())\n    if N < 1 or N > 10**18 or M < 1 or M > 10**18 or L < 1 or L > 10**18 or K < 1 or K > N or K > M:\n        return \"-1\"\n\n    def is_possible(coins):\n        return sum(coins) >= L\n\n    def find_minimum(coins):\n        min_coins = float('inf')\n        for i in range(1, N + 1):\n            for j in range(1, M + 1):\n                if is_possible([i, j] + coins):\n                    min_coins = min(min_coins, i + j)\n        return min_coins\n\n    coins = [0] * N\n    for i in range(M):\n        coin = int(input())\n        if coin < 1 or coin > N:\n            return \"-1\"\n        coins[coin - 1] += 1\n\n    min_coins = find_minimum(coins)\n    if min_coins == float('inf'):\n        return \"-1\"\n    return str(min_coins)"
    },
    {
        "number": 130,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    painted = [False] * (n * m)\n    for _ in range(m):\n        line = stdin.strip()\n        for i in range(m):\n            if line[i] == 'B':\n                painted[i * n + i] = True\n    for i in range(n):\n        for j in range(i + 1, n):\n            if painted[i * n + j] and painted[i * n + j - 1] and painted[i * n + j + 1] and painted[i * n + j - n]:\n                painted[i * n + j] = False\n                painted[i * n + j - 1] = False\n                painted[i * n + j + 1] = False\n                painted[i * n + j - n] = False\n    for i in range(n):\n        for j in range(m):\n            if painted[i * n + j]:\n                print(j + 1, end=' ')\n    return str(n)"
    },
    {
        "number": 131,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    if x == y:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 132,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    min_diff = float('inf')\n\n    for i in range(n):\n        sector_angles = sum(a[:i+1])\n        sector_angles += sum(a[i+1:])\n        diff = abs(sector_angles - 360)\n        if diff < min_diff:\n            min_diff = diff\n\n    return str(min_diff)"
    },
    {
        "number": 133,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    ways = 0\n    for i in range(n):\n        for j in range(m):\n            for k in range(n):\n                if i == k or j == k:\n                    continue\n                if i == j:\n                    ways += 1\n                    ways %= 10**9 + 7\n                    continue\n                if i < j:\n                    ways += 1\n                    ways %= 10**9 + 7\n                    continue\n                ways += 1\n                ways %= 10**9 + 7\n    return str(ways)"
    },
    {
        "number": 134,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1 1\"\n    elif n == 2:\n        return \"2 2\"\n    elif n == 3:\n        return \"3 3\"\n    elif n == 4:\n        return \"4 4\"\n    elif n == 5:\n        return \"5 5\"\n    elif n == 6:\n        return \"6 6\"\n    elif n == 7:\n        return \"7 7\"\n    elif n == 8:\n        return \"8 8\"\n    elif n == 9:\n        return \"9 9\"\n    elif n == 10:\n        return \"10 10\"\n    elif n == 11:\n        return \"11 11\"\n    elif n == 12:\n        return \"12 12\"\n    elif n == 13:\n        return \"13 13\"\n    elif n == 14:\n        return \"14 14\"\n    elif n == 15:\n        return \"15 15\"\n    elif n == 16:\n        return \"16 16\"\n    elif n == 17:\n        return \"17 17\"\n    elif n == 18:\n        return \"18 18\"\n    else:\n        return \"-1\""
    },
    {
        "number": 135,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    remainders = []\n    for i in range(1, k+1):\n        for j in range(i, k+1):\n            if n % i == n % j:\n                remainders.append((i, j))\n    if len(remainders) == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 136,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a < b:\n        return \"<\"\n    elif a > b:\n        return \">\"\n    else:\n        return \"=\""
    },
    {
        "number": 137,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def dfs(color, path, score):\n        if len(path) == n:\n            return score\n\n        for i in range(n):\n            if c[i] == color:\n                path.append(i)\n                score += dfs(color, path, score)\n                path.pop()\n\n        return score\n\n    return str(dfs(0, [], 0))"
    },
    {
        "number": 138,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    if n + a + b + c % 4!= 0:\n        return \"0\"\n\n    packs = [0] * 4\n    packs[0] = a\n    packs[1] = b\n    packs[2] = c\n\n    for i in range(3, 4):\n        packs[i] = packs[i - 1] + packs[i - 2]\n\n    return str(packs[3])\n"
    },
    {
        "number": 139,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited)\n\n    if len(visited) == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 140,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    coins = [0] * (m + 1)\n    coins[0] = 1\n    for i in range(1, m + 1):\n        coins[i] = coins[i - 1] + 1\n    return str(coins[m])"
    },
    {
        "number": 141,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W = int(stdin.readline().strip())\n    items = set(map(int, stdin.readline().strip().split()))\n    good_items = set()\n\n    for item in items:\n        if item <= W:\n            good_items.add(item)\n\n    return str(max(good_items))"
    },
    {
        "number": 142,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    def helper(bottles, cost):\n        if bottles == 0:\n            return 0\n        if bottles == 1:\n            return cost\n        return helper(bottles - 1, cost + c[bottles - 1])\n\n    return str(helper(n, 0))\n"
    },
    {
        "number": 143,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def max_mex(a):\n        max_mex = float('-inf')\n        for i in range(n):\n            if a[i] > max_mex:\n                max_mex = a[i]\n        return max_mex\n\n    def apply_operation(a, i):\n        if i == 0:\n            return a\n        if a[i] > a[i - 1]:\n            return a\n        return apply_operation(a, i - 1)\n\n    def apply_operations(a):\n        return [apply_operation(a, i) for i in range(n)]\n\n    a = apply_operations(a)\n    max_mex = max_mex(a)\n    return str(max_mex)"
    },
    {
        "number": 144,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    lucky = False\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == a[i] + a[j + 1]:\n                lucky = True\n                break\n\n    if lucky:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 145,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    user_name = stdin.strip()\n    distinct_chars = set(user_name)\n    if len(distinct_chars) % 2 == 1:\n        return \"CHAT WITH HER!\"\n    else:\n        return \"IGNORE HIM!\""
    },
    {
        "number": 146,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tabs = [0] * n\n    e = 0\n    s = 0\n    for i in range(n):\n        tabs[i] = int(stdin.split()[i])\n        if tabs[i] == 1:\n            e += 1\n        elif tabs[i] == -1:\n            s += 1\n\n    max_diff = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if tabs[i] == 1 and tabs[j] == -1:\n                diff = abs(e - s)\n                max_diff = max(max_diff, diff)\n            elif tabs[i] == -1 and tabs[j] == 1:\n                diff = abs(e - s)\n                max_diff = max(max_diff, diff)\n            elif tabs[i] == 1 and tabs[j] == 1:\n                diff = abs(e - s)\n                max_diff = max(max_diff, diff)\n            elif tabs[i] == -1 and tabs[j] == -1:\n                diff = abs(e - s)\n                max_diff = max(max_diff, diff)\n\n    return str(max_diff)"
    },
    {
        "number": 147,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_0, c_1 = map(int, stdin.split())\n    alphabet = \"01\"\n    total_cost = 0\n    for i in range(n):\n        total_cost += c_0 * (alphabet.count(\"0\") + 1)\n        total_cost += c_1 * (alphabet.count(\"1\") + 1)\n    return str(total_cost)"
    },
    {
        "number": 148,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, x, b, y = map(int, stdin.split())\n    if a == x or a == b or x == y or x == b:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 149,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, l, r = map(int, stdin.split())\n    if l > r:\n        return \"0\"\n\n    max_length = 0\n    for year in range(l, r + 1):\n        if year % 2 == 0:\n            continue\n        a = year ** 0\n        b = year ** 1\n        if a + b == year:\n            max_length = max(max_length, year - l + 1)\n\n    return str(max_length)\n"
    },
    {
        "number": 150,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 2:\n        return \"0\"\n    burles = 0\n    for i in range(1, n+1):\n        if i >= n//i:\n            burles += i\n    return str(burles)"
    },
    {
        "number": 151,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    for i in range(len(words)):\n        for j in range(i+1, len(words)):\n            if words[i] == words[j]:\n                words[i] += \" \" * (3 - len(words[i]))\n                words[j] = words[j][:3] + \" \" + words[j][3:]\n    return \" \".join(words)"
    },
    {
        "number": 152,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    x, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    spells = [\n        (0, 10),\n        (1, 15),\n        (2, 20),\n    ]\n\n    def can_use_spell(spell):\n        return spell[0] <= s\n\n    def can_prepare(potions, spell):\n        return potions >= spell[1]\n\n    def can_use_second_spell(potions, spell):\n        return potions >= spell[1]\n\n    def can_create_potions(potions, spell):\n        return potions >= spell[1]\n\n    def can_prepare_potions(potions, spell):\n        return potions >= spell[1]\n\n    def can_use_potions(potions, spell):\n        return potions >= spell[1]\n\n    def can_prepare_potions_and_use_second_spell(potions, spell):\n        return can_prepare_potions(potions, spell) and can_use_second_spell(potions, spell)\n\n    def can_prepare_potions_and_use_potions(potions, spell):\n        return can_prepare_potions(potions, spell) and can_use_potions(potions, spell)\n\n    def can_prepare_potions_and_use_spell(potions, spell):\n        return can_prepare_potions(potions, spell) and can_use_spell(spell)\n\n    def can_prepare_potions_and_create_potions(potions, spell):\n        return can_prepare_potions(potions, spell) and can_create_potions(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions(potions, spell):\n        return can_prepare_potions_and_use_spell(potions, spell) and can_use_potions(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions_and_create_potions(potions, spell):\n        return can_prepare_potions_and_use_spell_and_potions(potions, spell) and can_create_potions(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell(potions, spell):\n        return can_prepare_potions_and_use_spell_and_potions_and_create_potions(potions, spell) and can_use_second_spell(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell_and_potions(potions, spell):\n        return can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell(potions, spell) and can_use_potions(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell_and_potions_and_create_potions(potions, spell):\n        return can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell_and_potions(potions, spell) and can_create_potions(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell_and_potions_and_create_potions_and_use_second_spell(potions, spell):\n        return can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell_and_potions_and_create_potions(potions, spell) and can_use_second_spell(potions, spell)\n\n    def can_prepare_potions_and_use_spell_and_potions_and_create_potions_and_use_second_spell_and_potions_and_create_pot"
    },
    {
        "number": 153,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M = map(int, stdin.split())\n    tasks = []\n    for _ in range(n):\n        tasks.append(list(map(int, stdin.split())))\n\n    points = [0] * k\n    for i in range(k):\n        points[i] = tasks[i][i]\n\n    for i in range(k, n):\n        for j in range(i):\n            points[j] += tasks[i][j]\n\n    max_points = 0\n    for i in range(k):\n        max_points = max(max_points, points[i])\n\n    return str(max_points)\n"
    },
    {
        "number": 154,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 998244353\n    MOD_INV = 10**9 + 7\n\n    def dfs(node, depth, left, right):\n        if left == right:\n            return depth\n\n        mid = (left + right) // 2\n        left_depth = dfs(node.left, depth + 1, left, mid)\n        right_depth = dfs(node.right, depth + 1, mid + 1, right)\n\n        if left_depth == right_depth:\n            return left_depth\n\n        if left_depth % 2!= right_depth % 2:\n            return left_depth\n\n        return right_depth\n\n    def is_balanced(node):\n        left_depth = dfs(node.left, 0, 1, n)\n        right_depth = dfs(node.right, 0, 1, n)\n\n        return left_depth == right_depth\n\n    def count_balanced_stripes(node):\n        if node is None:\n            return 0\n\n        left_count = count_balanced_stripes(node.left)\n        right_count = count_balanced_stripes(node.right)\n\n        if is_balanced(node):\n            return left_count + right_count + 1\n        else:\n            return left_count + right_count\n\n    return str(count_balanced_stripes(None))"
    },
    {
        "number": 155,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    matrix[0][0] = 1\n    matrix[n-1][m-1] = 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if matrix[i-1][j-1] == 0:\n                matrix[i][j] = 1\n                if i > 1 and matrix[i-2][j] == 0:\n                    matrix[i][j] = 2\n                if i < n-2 and matrix[i+2][j] == 0:\n                    matrix[i][j] = 3\n                if j > 1 and matrix[i][j-2] == 0:\n                    matrix[i][j] = 4\n                if j < m-2 and matrix[i][j+2] == 0:\n                    matrix[i][j] = 5\n\n    for _ in range(k):\n        i, j = matrix[1][1], 1\n        while True:\n            if matrix[i][j] == 0:\n                break\n            if matrix[i][j] == 1:\n                i -= 1\n            elif matrix[i][j] == 2:\n                i += 1\n            elif matrix[i][j] == 3:\n                j -= 1\n            elif matrix[i][j] == 4:\n                j += 1\n            elif matrix[i][j] == 5:\n                break\n\n    return str(i) + \" \" + str(j)"
    },
    {
        "number": 156,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n    a = 1\n    b = 1\n    while True:\n        if LCM(a, b) == X:\n            return str(a) + \" \" + str(b)\n        elif LCM(a, b) < X:\n            a += 1\n        else:\n            b += 1\n\ndef"
    },
    {
        "number": 157,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_lemons = 0\n    max_apples = 0\n    max_pears = 0\n\n    for i in range(a):\n        max_lemons += 2\n        max_apples += 4\n        max_pears += 4\n\n    for i in range(b):\n        max_lemons += 1\n        max_apples += 2\n        max_pears += 4\n\n    for i in range(c):\n        max_lemons += 1\n        max_apples += 1\n        max_pears += 2\n\n    return str(max_lemons) + \" \" + str(max_apples) + \" \" + str(max_pears)"
    },
    {
        "number": 158,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n % 2 == 0:\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n\n    if a[0] == a[1]:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 159,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] + a[j] == 2 * a[i]:\n                k += 1\n                a[i] += a[j]\n                a[j] = 0\n                break\n\n    if k == 0:\n        print(0)\n        return '\\n'.join(map(str, a))\n\n    print(k)\n    return '\\n'.join(map(str, a))\n"
    },
    {
        "number": 160,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    max_divisible = float('-inf')\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            if A[i] + A[j] > max_divisible:\n                max_divisible = A[i] + A[j]\n\n    return str(max_divisible)"
    },
    {
        "number": 161,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    t = 40\n    result = []\n\n    for i in range(t):\n        if i % 2 == 0:\n            n = i // 2\n            result.append(x ^ (2 ** n - 1))\n        else:\n            result.append(x + 1)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 162,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Find the bucket that allows to water the segment of length k\n    bucket = -1\n    for i in range(n):\n        if a[i] <= k:\n            bucket = i\n            break\n\n    # If no bucket allows to water the segment of length k, return -1\n    if bucket == -1:\n        return \"-1\"\n\n    # Calculate the minimum number of hours required to water the garden\n    hours = 0\n    for i in range(n):\n        if i == bucket:\n            hours += 1\n        else:\n            hours += a[i]\n\n    return str(hours)\n"
    },
    {
        "number": 163,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    obstacles = list(stdin[1:])\n    jumps = []\n\n    for i in range(n):\n        if obstacles[i] == '#':\n            jumps.append(i)\n        elif obstacles[i] == 'G':\n            jumps.append(i)\n            jumps.append(i + k - 1)\n            jumps.append(i + k)\n\n    if len(jumps) == 0:\n        return \"NO\"\n\n    for i in range(len(jumps) - 1):\n        if jumps[i] + k - 1 not in jumps[i + 1:]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 164,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y_1, y_2, y_w, x_b, y_b, r = map(int, stdin.split())\n    if y_1 > y_2 or y_1 > y_w or y_2 > y_w or y_b + r > y_w or 2 * r > y_2 - y_1:\n        return \"-1\"\n\n    x_w = (x_b - y_b) / (y_2 - y_1)\n    return f\"{x_w:.8f}\""
    },
    {
        "number": 165,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d, s = map(int, stdin.split())\n    if b == 0 and d == 0 and s == 0:\n        return \"0\"\n    else:\n        return str(min(b, d, s))"
    },
    {
        "number": 166,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    x, y = 1, 1\n    visited = set()\n\n    for i in range(1, n + 1):\n        for j in range(1, y + 1):\n            if (i, j) in visited:\n                continue\n\n            if i == 1 and j == 1:\n                x, y = a[0], a[1]\n            elif i == 1 and j == y:\n                x, y = a[0], a[1] + 1\n            elif i == x and j == 1:\n                x, y = a[0] + 1, a[1]\n            elif i == x and j == y:\n                x, y = a[0] + 1, a[1] + 1\n\n            visited.add((i, j))\n\n    if x == 1 and y == 1:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 167,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.strip().split()\n    a = a.replace(' ', '')\n    b = b.replace(' ', '')\n    if len(a) == 0:\n        return '-'\n    if len(b) == 0:\n        return a\n    i = 0\n    while i < len(b) - 1 and b[i] == b[i+1]:\n        i += 1\n    return a[i:]"
    },
    {
        "number": 168,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pile = []\n    for _ in range(n):\n        stone = input().strip()\n        if stone == '-':\n            pile.append(0)\n        elif stone == '+':\n            pile.append(1)\n        else:\n            pile.append(int(stone))\n    return str(min(pile))"
    },
    {
        "number": 169,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    max_kefir = 0\n    for i in range(1, n + 1):\n        max_kefir = max(max_kefir, i * a)\n        max_kefir = max(max_kefir, i * b)\n        max_kefir = max(max_kefir, i * c)\n    return str(max_kefir)"
    },
    {
        "number": 170,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    k_1 = list(map(int, stdin.readline().strip().split()))\n    k_2 = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the number of fights\n    fights = 0\n    for i in range(n):\n        if k_1[i] > k_2[i]:\n            fights += 1\n\n    # Calculate the winner\n    if fights % 2 == 0:\n        winner = 1\n    else:\n        winner = 2\n\n    return str(fights) + \" \" + str(winner)"
    },
    {
        "number": 171,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    password = stdin.strip()\n    if len(password) < 5:\n        return \"Too weak\"\n    if not any(char.isupper() for char in password):\n        return \"Too weak\"\n    if not any(char.islower() for char in password):\n        return \"Too weak\"\n    if not any(char.isdigit() for char in password):\n        return \"Too weak\"\n    if not any(char in \"!?.,_\" for char in password):\n        return \"Too weak\"\n    return \"Correct\""
    },
    {
        "number": 172,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the number of exchanges required\n    num_exchanges = 0\n    for i in range(n):\n        if a[i] == 1 and b[i] == 1:\n            num_exchanges += 1\n\n    return str(num_exchanges)\n"
    },
    {
        "number": 173,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    directions = list(stdin.strip())\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '<':\n                directions[i * (m - 1) + j] = 'v'\n            elif directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '<'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '^'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '^':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '<'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '<':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '^'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '^':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '<'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '<':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '^'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '^':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '<'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '<':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '^'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == '^':\n                directions[i * (m - 1) + j] = 'v'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] == 'v':\n                directions[i * (m - 1) + j] = '<'\n\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if directions[i * (m - 1) + j] =="
    },
    {
        "number": 174,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n!= len(a):\n        return \"NO\"\n\n    for i in range(n):\n        if a[i] == 0:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] == 1 and a[i + 1] == 0:\n            return \"YES\"\n\n    return \"YES\""
    },
    {
        "number": 175,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = n, m\n\n    while a > 0 or b > 0:\n        if a >= 2 * b:\n            a -= 2 * b\n        else:\n            b -= 2 * a\n\n        if b >= 2 * a:\n            b -= 2 * a\n\n    return str(a) + \" \" + str(b)"
    },
    {
        "number": 176,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    count = 0\n    for x in range(a, b + 1):\n        if x % k == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 177,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    result = \"\"\n    for i in range(1, 10):\n        result += str(i)\n    result = result[k - 1]\n    return result"
    },
    {
        "number": 178,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    if len(s)!= n:\n        return \"NO\"\n\n    for i in range(n):\n        if s[i] == '8':\n            s = s[:i] + s[i+1:]\n            break\n\n    if len(s) == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 179,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, pos = map(int, stdin.split())\n    permutations = []\n    for i in range(1, n + 1):\n        for j in range(i):\n            permutations.append((i, j))\n    permutations.sort()\n    count = 0\n    for i in range(pos, n):\n        if permutations[i - pos] == (x, i):\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 180,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    snowflakes = ['*', '?', '!', 'h', 'w', 'p', 'n', 'e', 'r']\n    candy_cane = ['c', 'n', 'e', 'w','s', 'y', 'a', 'r']\n    message = stdin.strip()\n    k = int(stdin.strip())\n\n    if len(message) < k:\n        return \"Impossible\"\n\n    encoded_message = \"\"\n    for i in range(k):\n        if message[i] in snowflakes:\n            encoded_message += candy_cane[0]\n            encoded_message += candy_cane[1]\n            encoded_message += candy_cane[2]\n            encoded_message += candy_cane[3]\n            encoded_message += candy_cane[4]\n            encoded_message += candy_cane[5]\n            encoded_message += candy_cane[6]\n            encoded_message += candy_cane[7]\n            encoded_message += candy_cane[8]\n            encoded_message += candy_cane[9]\n            encoded_message += candy_cane[10]\n            encoded_message += candy_cane[11]\n            encoded_message += candy_cane[12]\n            encoded_message += candy_cane[13]\n            encoded_message += candy_cane[14]\n            encoded_message += candy_cane[15]\n            encoded_message += candy_cane[16]\n            encoded_message += candy_cane[17]\n            encoded_message += candy_cane[18]\n            encoded_message += candy_cane[19]\n            encoded_message += candy_cane[20]\n            encoded_message += candy_cane[21]\n            encoded_message += candy_cane[22]\n            encoded_message += candy_cane[23]\n            encoded_message += candy_cane[24]\n            encoded_message += candy_cane[25]\n            encoded_message += candy_cane[26]\n            encoded_message += candy_cane[27]\n            encoded_message += candy_cane[28]\n            encoded_message += candy_cane[29]\n            encoded_message += candy_cane[30]\n            encoded_message += candy_cane[31]\n            encoded_message += candy_cane[32]\n            encoded_message += candy_cane[33]\n            encoded_message += candy_cane[34]\n            encoded_message += candy_cane[35]\n            encoded_message += candy_cane[36]\n            encoded_message += candy_cane[37]\n            encoded_message += candy_cane[38]\n            encoded_message += candy_cane[39]\n            encoded_message += candy_cane[40]\n            encoded_message += candy_cane[41]\n            encoded_message += candy_cane[42]\n            encoded_message += candy_cane[43]\n            encoded_message += candy_cane[44]\n            encoded_message += candy_cane[45]\n            encoded_message += candy_cane[46]\n            encoded_message += candy_cane[47]\n            encoded_message += candy_cane[48]\n            encoded_message += candy_cane[49]\n            encoded_message += candy_cane[50]\n            encoded_message += candy_cane[51]\n            encoded_message += candy_cane[52]\n            encoded_message += candy_cane[53]\n            encoded_message += candy_cane[54]\n            encoded_message += candy_cane[55]\n            encoded_message += candy_cane[56]\n            encoded_message += candy_cane[57]\n            encoded_message += candy_cane[58]\n            encoded_message += candy_cane[59]\n            encoded_message += candy_cane[60]\n            encoded_message += candy_cane[61]\n            encoded_message += candy_cane[62]\n            encoded_message += candy_cane[63]\n            encoded_message += candy_cane[64]\n            encoded_message += candy_"
    },
    {
        "number": 181,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin)\n    if x < 0:\n        x += 360\n    return str(x // 90) + \" \" + str(x % 90)"
    },
    {
        "number": 182,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    x, y, z = map(int, stdin.split())\n\n    if a + b + c == 0:\n        return \"No\"\n\n    if a + b + c == 1:\n        return \"Yes\"\n\n    if a + b + c == 2:\n        return \"Yes\"\n\n    if a + b + c == 3:\n        return \"Yes\"\n\n    if a + b + c == 4:\n        return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 183,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    x = 0\n    while x < n:\n        x += 1\n    y = 0\n    while y < m:\n        y += 1\n    if x % k == 0 and y % k == 0:\n        return str(x % m)\n    else:\n        return \"No solution\""
    },
    {
        "number": 184,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, a = map(int, stdin.split())\n    if l + r + a == 0:\n        return \"0\"\n    if l + r + a % 2 == 0:\n        return str(l + r + a // 2)\n    else:\n        return str(l + r + a // 2 + 1)"
    },
    {
        "number": 185,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    moves = 0\n    for i in range(n):\n        if i == k:\n            moves += 1\n            continue\n        moves += 2  # throw stone to any other manhole\n    return str(moves)"
    },
    {
        "number": 186,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    towers = []\n    for _ in range(n):\n        towers.append([])\n    for _ in range(m):\n        towers[0].append(0)\n    for i in range(1, n):\n        for j in range(i):\n            towers[i].append(towers[i - 1][j] + 1)\n    for i in range(n):\n        towers[i].append(1)\n    tallest_tower = max(towers, key=lambda x: sum(x))\n    return str(tallest_tower)"
    },
    {
        "number": 187,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return \"NO\"\n    else:\n        a = list(map(int, stdin.strip().split()))\n        if len(a)!= n:\n            return \"NO\"\n        else:\n            return \"YES\""
    },
    {
        "number": 188,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Check if there is a possible arrangement\n    for i in range(k):\n        for j in range(i + 1, k):\n            if a[i] + a[j] > 8 * n:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 189,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    t = 2\n    min_cost = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] - a[j] <= 1:\n                cost = abs(a[i] - a[j])\n                if cost < min_cost:\n                    min_cost = cost\n                    t = a[i]\n\n    return str(t) +'' + str(min_cost)\n"
    },
    {
        "number": 191,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of operations\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == 1 and a[j] == 1:\n                count += 1\n\n    # Calculate the probability\n    if count == 0:\n        return \"0\"\n    else:\n        P = count\n        Q = n - count\n        return str(P * Q ** (-1)) % (10**9 + 7)"
    },
    {
        "number": 192,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == y:\n        return \"0\"\n    if x > y:\n        x, y = y, x\n    for i in range(x, y + 1):\n        if i % 2 == 0:\n            continue\n        for j in range(i, y + 1):\n            if j % 2 == 0:\n                continue\n            if i + j == y:\n                return str(i) + \" \" + str(j)\n    return \"0\""
    },
    {
        "number": 193,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n\n    if a == 0 and b == 0:\n        return \"0.0000000000\"\n    elif a == 0:\n        return \"0.0000000000\"\n    elif b == 0:\n        return \"0.0000000000\"\n    elif a == 1 and b == 1:\n        return \"0.0000000000\"\n    elif a == 1:\n        return \"0.0000000000\"\n    elif b == 1:\n        return \"0.0000000000\"\n    elif a == 2 and b == 2:\n        return \"0.0000000000\"\n    elif a == 2:\n        return \"0.0000000000\"\n    elif b == 2:\n        return \"0.0000000000\"\n    elif a == 3 and b == 3:\n        return \"0.0000000000\"\n    elif a == 3:\n        return \"0.0000000000\"\n    elif b == 3:\n        return \"0.0000000000\"\n    elif a == 4 and b == 4:\n        return \"0.0000000000\"\n    elif a == 4:\n        return \"0.0000000000\"\n    elif b == 4:\n        return \"0.0000000000\"\n    elif a == 5 and b == 5:\n        return \"0.0000000000\"\n    elif a == 5:\n        return \"0.0000000000\"\n    elif b == 5:\n        return \"0.0000000000\"\n    elif a == 6 and b == 6:\n        return \"0.0000000000\"\n    elif a == 6:\n        return \"0.0000000000\"\n    elif b == 6:\n        return \"0.0000000000\"\n    elif a == 7 and b == 7:\n        return \"0.0000000000\"\n    elif a == 7:\n        return \"0.0000000000\"\n    elif b == 7:\n        return \"0.0000000000\"\n    elif a == 8 and b == 8:\n        return \"0.0000000000\"\n    elif a == 8:\n        return \"0.0000000000\"\n    elif b == 8:\n        return \"0.0000000000\"\n    elif a == 9 and b == 9:\n        return \"0.0000000000\"\n    elif a == 9:\n        return \"0.0000000000\"\n    elif b == 9:\n        return \"0.0000000000\"\n    else:\n        det = a * d - b * c\n        if det == 0:\n            return \"Infinity\"\n        else:\n            return str(abs(det))"
    },
    {
        "number": 194,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    # Count the number of groups\n    count = 0\n    for i in range(n):\n        if t[i] == 1:\n            count += 1\n        elif t[i] == 2:\n            count += 2\n\n    # Count the number of people who are seated at a vacant table\n    vacant_one = 0\n    vacant_two = 0\n    for i in range(n):\n        if t[i] == 1:\n            vacant_one += 1\n        elif t[i] == 2:\n            vacant_two += 1\n\n    # Count the number of people who are seated at a two-seater table\n    two_seater = 0\n    for i in range(n):\n        if t[i] == 2:\n            two_seater += 1\n\n    # Count the number of people who are seated at a single-person table\n    single_person = 0\n    for i in range(n):\n        if t[i] == 1:\n            single_person += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by a single person\n    two_seater_single_person = 0\n    for i in range(n):\n        if t[i] == 2 and single_person > 0:\n            two_seater_single_person += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by two people\n    two_seater_two_people = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 0:\n            two_seater_two_people += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by three or more people\n    two_seater_three_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 1:\n            two_seater_three_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by four or more people\n    two_seater_four_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 2:\n            two_seater_four_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by five or more people\n    two_seater_five_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 3:\n            two_seater_five_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by six or more people\n    two_seater_six_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 4:\n            two_seater_six_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by seven or more people\n    two_seater_seven_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 5:\n            two_seater_seven_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by eight or more people\n    two_seater_eight_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 6:\n            two_seater_eight_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by nine or more people\n    two_seater_nine_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 7:\n            two_seater_nine_or_more += 1\n\n    # Count the number of people who are seated at a two-seater table occupied by ten or more people\n    two_seater_ten_or_more = 0\n    for i in range(n):\n        if t[i] == 2 and two_seater > 8:\n            two_seater_ten_or_"
    },
    {
        "number": 195,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, N = map(int, stdin.split())\n    if A == 0 and B == 0 and C == 0 and N == 0:\n        return \"-1\"\n\n    if A == 0 and B == 0 and C == 0:\n        return \"0\"\n\n    if A == 0:\n        return \"0\"\n\n    if B == 0:\n        return \"0\"\n\n    if C == 0:\n        return \"0\"\n\n    if N == 0:\n        return \"0\"\n\n    if A == 1 and B == 1 and C == 1 and N == 1:\n        return \"1\"\n\n    if A == 1 and B == 1 and C == 1:\n        return \"1\"\n\n    if A == 1 and B == 1:\n        return \"1\"\n\n    if A == 1 and C == 1:\n        return \"1\"\n\n    if A == 1:\n        return \"1\"\n\n    if B == 1:\n        return \"1\"\n\n    if C == 1:\n        return \"1\"\n\n    if N == 1:\n        return \"1\"\n\n    if A == 2 and B == 2 and C == 2 and N == 2:\n        return \"2\"\n\n    if A == 2 and B == 2 and C == 2:\n        return \"2\"\n\n    if A == 2 and B == 2:\n        return \"2\"\n\n    if A == 2 and C == 2:\n        return \"2\"\n\n    if A == 2:\n        return \"2\"\n\n    if B == 2:\n        return \"2\"\n\n    if C == 2:\n        return \"2\"\n\n    if N == 2:\n        return \"2\"\n\n    if A == 3 and B == 3 and C == 3 and N == 3:\n        return \"3\"\n\n    if A == 3 and B == 3 and C == 3:\n        return \"3\"\n\n    if A == 3 and B == 3:\n        return \"3\"\n\n    if A == 3 and C == 3:\n        return \"3\"\n\n    if A == 3:\n        return \"3\"\n\n    if B == 3:\n        return \"3\"\n\n    if C == 3:\n        return \"3\"\n\n    if N == 3:\n        return \"3\"\n\n    return \"-1\""
    },
    {
        "number": 196,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    dresses = x\n    for _ in range(k):\n        dresses *= 2\n    expected_dresses = dresses\n    for _ in range(k - 1):\n        dresses *= 2\n        expected_dresses += dresses\n    return str(expected_dresses % (10**9 + 7))"
    },
    {
        "number": 197,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    prob = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().split())\n        prob.append((l, r))\n\n    def is_good(l, r):\n        count = 0\n        for i in range(n):\n            if prob[i][0] <= l <= prob[i][1] and prob[i][0] <= r <= prob[i][1]:\n                count += 1\n        return count >= 2\n\n    def is_bad(l, r):\n        count = 0\n        for i in range(n):\n            if prob[i][0] <= l <= prob[i][1] and prob[i][0] <= r <= prob[i][1]:\n                count += 1\n        return count < 2\n\n    def is_inversion(l, r):\n        count = 0\n        for i in range(n):\n            if prob[i][0] <= l <= prob[i][1] and prob[i][0] <= r <= prob[i][1]:\n                count += 1\n        return count % 2 == 1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def prob_inversion(l, r):\n        return lcm(is_good(l, r), is_bad(l, r))\n\n    prob_inversions = []\n    for l, r in prob:\n        prob_inversions.append(prob_inversion(l, r))\n\n    x = prob_inversions[0]\n    y = prob_inversions[1]\n    xy = x * y\n\n    return str(xy)"
    },
    {
        "number": 198,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ways = 0\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            for k in range(1, j+1):\n                for l in range(1, k+1):\n                    ways += 1\n    return str(ways)"
    },
    {
        "number": 199,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n\n    def find_least_keg(v):\n        min_v = float('inf')\n        min_keg = -1\n        for i in range(n):\n            if v[i] < min_v:\n                min_v = v[i]\n                min_keg = i\n        return min_keg\n\n    least_keg = find_least_keg(v)\n\n    if least_keg == -1:\n        return \"-1\"\n\n    return str(v[least_keg])\n"
    },
    {
        "number": 200,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h_1, h_2, a, b = map(int, stdin.split())\n    days = 0\n    while h_2 > h_1:\n        days += 1\n        h_2 -= a\n        h_1 -= b\n    if h_2 <= h_1:\n        return str(days)\n    else:\n        return \"-1\""
    },
    {
        "number": 201,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, H_r, H_b, W_r, W_b = map(int, stdin.split())\n    joy_units = 0\n    for i in range(C):\n        if i < H_r:\n            joy_units += W_r\n        elif i < H_r + H_b:\n            joy_units += W_r + W_b\n        else:\n            joy_units += W_r + W_b + W_r\n    return str(joy_units)"
    },
    {
        "number": 202,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    steps = 0\n    while dx!= 0 or dy!= 0:\n        steps += 1\n        if dx > 0:\n            x1 += 1\n            dx -= 1\n        elif dx < 0:\n            x1 -= 1\n            dx += 1\n        if dy > 0:\n            y1 += 1\n            dy -= 1\n        elif dy < 0:\n            y1 -= 1\n            dy += 1\n\n    return str(steps)"
    },
    {
        "number": 203,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    depublicans_votes = [0] * n\n    remocrats_votes = [0] * n\n\n    for i in range(n):\n        statement = stdin.strip()\n        if statement == 'D':\n            depublicans_votes[i] += 1\n        elif statement == 'R':\n            remocrats_votes[i] += 1\n\n    if depublicans_votes.count(0) == n:\n        return 'D'\n    elif remocrats_votes.count(0) == n:\n        return 'R'\n    else:\n        return 'D'"
    },
    {
        "number": 204,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    num_variants = 0\n    for w in range(a, b+1):\n        for h in range(h, b+1):\n            if w*h == x*y:\n                num_variants += 1\n    return str(num_variants)"
    },
    {
        "number": 205,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    result = 0\n    for i in range(1, b + 1):\n        result += n // (i ** (b - 1))\n        n %= i ** (b - 1)\n    return str(result)"
    },
    {
        "number": 206,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b = map(int, stdin.split())\n    f = [0] * (m + 1)\n    f[0] = 1\n    f[1] = 1\n    for i in range(2, m + 1):\n        f[i] = f[i - 1] + f[i - 2]\n    return str(sum(f[i] for i in range(m + 1)))"
    },
    {
        "number": 207,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    odd_count = 0\n    for i in range(n):\n        if i % 2 == 1:\n            odd_count += 1\n\n    if odd_count % 2 == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 208,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    if x1 == x2 and y1 == y2:\n        return \"-1\"\n\n    x3, y3, x4, y4 = map(int, stdin.split())\n    if x3 == x4 and y3 == y4:\n        return \"-1\"\n\n    if x1 == x2:\n        if y1 == y3:\n            return str(x3) + \" \" + str(y3) + \" \" + str(x4) + \" \" + str(y4)\n        elif y1 == y4:\n            return str(x3) + \" \" + str(y4) + \" \" + str(x4) + \" \" + str(y3)\n    elif y1 == y2:\n        if x1 == x3:\n            return str(x3) + \" \" + str(y3) + \" \" + str(x4) + \" \" + str(y4)\n        elif x1 == x4:\n            return str(x4) + \" \" + str(y3) + \" \" + str(x3) + \" \" + str(y4)\n    else:\n        return \"-1\""
    },
    {
        "number": 209,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    n = int(stdin.strip())\n\n    if n == 1:\n        return str(x)\n\n    f_1 = x\n    f_2 = y\n    for i in range(2, n + 1):\n        f_i = (f_1 + f_2) % 1000000007\n        f_1 = f_2\n        f_2 = f_i\n\n    return str(f_2)"
    },
    {
        "number": 210,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"YES\"\n\n    k = int(stdin.readline().strip())\n    l = [1] * k\n    r = [n] * k\n\n    for i in range(k):\n        l[i] = int(stdin.readline().strip())\n        r[i] = int(stdin.readline().strip())\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i in range(k):\n        if l[i] == 1:\n            return \"NO\"\n\n    for i in range(k):\n        if r[i] + 1!= l[i] + 1:\n            return \"NO\"\n\n    for i"
    },
    {
        "number": 211,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    score = 0\n    count = 0\n\n    for i in range(m):\n        if i == 0:\n            score += 1\n        else:\n            count += 1\n\n        if count == k:\n            score += 2 * k\n            count = 0\n\n    remainder = score % 1000000009\n    return str(remainder)"
    },
    {
        "number": 212,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 0 or n > 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999"
    },
    {
        "number": 213,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    memory = []\n    for _ in range(m):\n        k, f = map(int, stdin.split())\n        memory.append((k, f))\n\n    def is_valid(floor):\n        return 1 <= floor <= n\n\n    def restore_floor(floor):\n        for k, f in memory:\n            if f == floor:\n                return k\n        return -1\n\n    for floor in range(1, n + 1):\n        if is_valid(floor):\n            floor_number = restore_floor(floor)\n            if floor_number!= -1:\n                return str(floor_number)\n\n    return \"-1\""
    },
    {
        "number": 214,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    board = [[0] * n for _ in range(n)]\n    pawns = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = stdin[i][j]\n            if board[i][j] == 'X':\n                pawns[i][j] = 1\n\n    max_bishwocks = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '0' and pawns[i][j] == 0:\n                max_bishwocks = max(max_bishwocks, dfs(i, j, board, pawns))\n\n    return str(max_bishwocks)\n\n\ndef"
    },
    {
        "number": 215,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    A = set()\n    for i in range(n):\n        A.add(i)\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j] and s[i].islower():\n                A.remove(i)\n                A.remove(j)\n                break\n    max_elements = max(A)\n    return str(max_elements)"
    },
    {
        "number": 216,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    b = set(a)\n    c = set(a)\n\n    for i in range(n):\n        if a[i] in b:\n            b.remove(a[i])\n        else:\n            c.remove(a[i])\n\n    max_b = max(b)\n    max_c = max(c)\n\n    return str(max_b - max_c)"
    },
    {
        "number": 217,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, f, k = map(int, stdin.split())\n    if a == 0 and b == 0 and f == 0 and k == 0:\n        return \"0\"\n    elif a == 0 and b == 0 and f == 0 and k == 1:\n        return \"1\"\n    else:\n        min_journeys = float('inf')\n        for i in range(k):\n            if i == 0:\n                min_journeys = min(min_journeys, 1)\n            else:\n                min_journeys = min(min_journeys, 2)\n        return str(min_journeys)"
    },
    {
        "number": 218,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    s = stdin.strip()\n    if p > q:\n        return \"-1\"\n\n    partitions = []\n    for i in range(n):\n        if i % p == 0:\n            partitions.append(s[i:i+p])\n        elif i % q == 0:\n            partitions.append(s[i:i+q])\n\n    if len(partitions) == 0:\n        return \"-1\"\n\n    result = []\n    for partition in partitions:\n        if partition in result:\n            return \"-1\"\n        result.append(partition)\n\n    return len(result)"
    },
    {
        "number": 219,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, d = map(int, stdin.split())\n    obstacles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        obstacles.append((x, y))\n\n    start_x, start_y = map(int, stdin.split())\n    finish_x, finish_y = map(int, stdin.split())\n\n    if start_x == finish_x and start_y == finish_y:\n        return \"IMPOSSIBLE\"\n\n    def is_valid(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 0\n\n    def is_valid_jump(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 0\n\n    def is_valid_run(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 0\n\n    def is_valid_jump_over(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 0\n\n    def is_valid_land(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 0\n\n    def is_valid_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_jump_over_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_run_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_jump_over_run_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_run_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_jump_over_jump_over_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_jump_over_land_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_jump_over_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_land_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_jump_over_land_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_land_jump_over_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_land_jump_over_land_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_land_jump_over_jump_over_obstacle(x, y):\n        return 0 <= x < m and 0 <= y < m and obstacles[x][y] == 1\n\n    def is_valid_land_jump_over_land_jump_over_land_jump_over_obstacle("
    },
    {
        "number": 220,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x = map(int, stdin.split())\n    a = s ^ x\n    b = s ^ a\n    solutions = []\n    for i in range(a, b + 1):\n        solutions.append((i, i ^ x))\n    return str(len(solutions))"
    },
    {
        "number": 221,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    l = 0\n    for i in range(1, n + 1):\n        if i - k >= 1 and i - k <= n:\n            l += 1\n    return str(l)"
    },
    {
        "number": 222,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n\n    # Delete digits from n until it becomes a positive integer\n    while n > 0:\n        digit = n % 10\n        n //= 10\n\n        if digit == 3 or digit == 4:\n            n += 1\n        else:\n            break\n\n    # Check if it is impossible to make the square of some positive integer\n    if n == 0:\n        return \"-1\"\n\n    # Calculate the square of the integer n\n    square = n * n\n\n    # Print the minimal number of operations required to make the square of n\n    print(square)\n\n    return str(square)\n"
    },
    {
        "number": 223,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    f_max = 0\n    for i in range(1, n + 1):\n        f_max = max(f_max, f_max // i)\n    return str(f_max % 1000000007)"
    },
    {
        "number": 224,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = 'AEIOU'\n    jump_ability = 1\n    for i in range(len(stdin)):\n        if stdin[i] in vowels:\n            jump_ability += 1\n    return str(jump_ability)"
    },
    {
        "number": 225,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a1, a2, a3, a4 = map(int, stdin.split())\n    if a1 + a2 + a3 + a4!= 100:\n        return \"NO\"\n\n    if a1 == 0 and a2 == 0 and a3 == 0 and a4 == 0:\n        return \"YES\"\n\n    if a1 == 0 or a2 == 0 or a3 == 0 or a4 == 0:\n        return \"NO\"\n\n    if a1 + a2 + a3 + a4!= 100:\n        return \"NO\"\n\n    if a1 == 0:\n        friend1 = 1\n        friend2 = 2\n    elif a2 == 0:\n        friend1 = 2\n        friend2 = 1\n    elif a3 == 0:\n        friend1 = 3\n        friend2 = 4\n    else:\n        friend1 = 4\n        friend2 = 3\n\n    if friend1 == friend2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 226,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    alice_slices = list(map(int, stdin.strip().split()))\n    bob_slices = list(map(int, stdin.strip().split()))\n\n    alice_slices.sort()\n    bob_slices.sort()\n\n    alice_total = sum(alice_slices)\n    bob_total = sum(bob_slices)\n\n    alice_decider = alice_slices[0]\n    bob_decider = bob_slices[0]\n\n    alice_slices.pop(0)\n    bob_slices.pop(0)\n\n    alice_slices.append(alice_decider)\n    bob_slices.append(bob_decider)\n\n    alice_total += alice_decider\n    bob_total += bob_decider\n\n    alice_slices.sort()\n    bob_slices.sort()\n\n    alice_total += sum(alice_slices)\n    bob_total += sum(bob_slices)\n\n    return str(alice_total) + \" \" + str(bob_total)"
    },
    {
        "number": 227,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    m = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == a[i]:\n                m = max(m, j - i + 1)\n\n    if m == 0:\n        return \"-1\"\n    else:\n        return str(m)"
    },
    {
        "number": 228,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    alice_wins = True\n    for i in range(n // 2):\n        alice_piles = [a[i]] * (n // 2)\n        bob_piles = [a[i + n // 2]] * (n // 2)\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // 2]\n        bob_piles = bob_piles[:n // 2]\n\n        alice_piles.sort()\n        bob_piles.sort()\n\n        alice_piles.reverse()\n        bob_piles.reverse()\n\n        alice_piles = alice_piles[:n // "
    },
    {
        "number": 229,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    x = 1\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            x += a[i]\n        else:\n            x += a[i] - a[i - 1] - a[i - 2]\n\n    if x == 1:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 230,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    S = stdin.strip()\n\n    max_len = 0\n    for i in range(N - 1):\n        if S[i] == S[i + 1]:\n            if i > 0 and S[i] == S[i - 1]:\n                continue\n            if i > 0 and S[i] == S[i - 1] and i + 1 < N - 1 and S[i + 1] == S[i + 2]:\n                continue\n            max_len = max(max_len, i + 2)\n\n    return str(max_len)"
    },
    {
        "number": 231,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    if n % 2 == 0:\n        raise ValueError(\"n must be even\")\n    if a < 1 or a > n:\n        raise ValueError(\"a must be between 1 and n\")\n\n    def distance(house):\n        return 1 if house % 2 == 0 else n - house\n\n    def time_to_reach_house(house):\n        return distance(house) + 1\n\n    return str(min(time_to_reach_house(a) for _ in range(n)))"
    },
    {
        "number": 232,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    def find_interval(colors, k):\n        for i in range(1, len(colors)):\n            if colors[i] == colors[i - 1]:\n                k[i] += k[i - 1]\n            else:\n                return False\n        return True\n\n    if find_interval(colors, k):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 233,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rounds = []\n    for _ in range(n):\n        m, c = map(int, stdin.strip().split())\n        rounds.append((m, c))\n\n    rounds.sort(key=lambda x: (-x[0], -x[1]))\n\n    if rounds[0][0] == rounds[1][0]:\n        return \"Friendship is magic!^^\"\n    elif rounds[0][0] > rounds[1][0]:\n        return \"Mishka\"\n    else:\n        return \"Chris\""
    },
    {
        "number": 234,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    field = [list(map(int, input().split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if field[i][j] == 0:\n                for k in range(i - 1, -1, -1):\n                    if field[k][j] == 0:\n                        for l in range(j - 1, -1, -1):\n                            if field[k][l] == 0:\n                                if field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l - 1] == 0:\n                                    field[i][j] = 0\n                                    break\n                                elif field[k + 1][l] == 0 and field[k - 1][l] == 0 and field[k][l + 1] == 0 and field[k][l"
    },
    {
        "number": 235,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 3\n    while True:\n        if k * n >= 100:\n            return str(k)\n        k += 1"
    },
    {
        "number": 236,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    links = []\n    pearls = []\n    for i in range(n):\n        if stdin[i] == '-':\n            links.append(i)\n        elif stdin[i] == 'o':\n            pearls.append(i)\n\n    if len(links) < 2 or len(pearls) < 2:\n        return \"NO\"\n\n    for i in range(len(links) - 1):\n        if links[i] + 1 == links[i + 1]:\n            return \"NO\"\n\n    for i in range(len(pearls) - 1):\n        if pearls[i] + 1 == pearls[i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 237,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    pillows = [0] * n\n    for i in range(k):\n        pillows[i] = m\n\n    max_pillows = 0\n    for i in range(n):\n        if pillows[i] >= 2:\n            max_pillows = max(max_pillows, pillows[i])\n\n    return str(max_pillows)"
    },
    {
        "number": 238,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_cost = 0\n    for i in range(n - m + 1):\n        cost = sum(a[i:i+m]) - k\n        if cost > max_cost:\n            max_cost = cost\n\n    return str(max_cost)"
    },
    {
        "number": 239,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = [(0, 0), (n, m), (0, m), (n, 0)]\n    polyline = []\n    max_length = 0\n\n    for i in range(4):\n        for j in range(i + 1, 4):\n            if i == j:\n                continue\n            p1, p2 = points[i], points[j]\n            p1_x, p1_y = p1[0], p1[1]\n            p2_x, p2_y = p2[0], p2[1]\n            dx = p2_x - p1_x\n            dy = p2_y - p1_y\n            length = abs(dx) + abs(dy)\n            if length > max_length:\n                max_length = length\n                polyline = [(p1_x, p1_y), (p2_x, p2_y)]\n\n    print(\" \".join(map(str, polyline)))\n    return \"\""
    },
    {
        "number": 240,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = len(stdin.strip()) - 1\n    n_str = str(n)\n    n_str = n_str.zfill(k)\n    n_list = list(n_str)\n    n_list.reverse()\n    n_str = ''.join(n_list)\n    return n_str"
    },
    {
        "number": 241,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, min, max = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    if n == m:\n        return 'Correct'\n\n    if min == max:\n        return 'Correct'\n\n    if n - m == 0:\n        return 'Correct'\n\n    return 'Incorrect'"
    },
    {
        "number": 242,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.strip())\n    n = 0\n    while n < m:\n        n += 1\n    k = 0\n    while n > 0:\n        n -= 1\n        k += 1\n    result = []\n    for i in range(k):\n        result.append(n)\n    result.sort()\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 243,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        edges.append((u, v, w))\n\n    graph = [[] for _ in range(n)]\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    distances = [float('inf')] * n\n    distances[0] = 0\n\n    for i in range(1, n):\n        min_distance = float('inf')\n        for j in range(n):\n            if distances[j] < min_distance:\n                min_distance = distances[j]\n                farthest = j\n        distances[i] = min_distance\n\n    result = []\n    for i in range(k):\n        result.append(distances[i])\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 244,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = int(stdin.strip())\n    if n % 2 == 0:\n        x = 2 - x\n    return str(x)"
    },
    {
        "number": 245,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rectangles = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.strip().split())\n        rectangles.append((x1, y1, x2, y2))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if rectangles[i][0] == rectangles[j][0] and rectangles[i][1] == rectangles[j][1] and rectangles[i][2] == rectangles[j][2] and rectangles[i][3] == rectangles[j][3]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 246,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    count = 0\n    for i in range(10):\n        if i > n:\n            break\n        sum_of_digits = sum(int(digit) for digit in str(i))\n        if abs(sum_of_digits - s) <= s:\n            count += 1\n    return str(count)"
    },
    {
        "number": 247,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    lines = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            lines.append((points[i], points[j]))\n\n    for line in lines:\n        if any(point in line for point in points):\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 248,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k, t = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n    if k > t:\n        k, t = t, k\n    if k == 1:\n        return str(2 * (a - b) + 1)\n    if k == 2:\n        return str(2 * (a - b) + 2)\n    if k == 3:\n        return str(2 * (a - b) + 3)\n    if k == 4:\n        return str(2 * (a - b) + 4)\n    if k == 5:\n        return str(2 * (a - b) + 5)\n    if k == 6:\n        return str(2 * (a - b) + 6)\n    if k == 7:\n        return str(2 * (a - b) + 7)\n    if k == 8:\n        return str(2 * (a - b) + 8)\n    if k == 9:\n        return str(2 * (a - b) + 9)\n    if k == 10:\n        return str(2 * (a - b) + 10)\n    if k == 11:\n        return str(2 * (a - b) + 11)\n    if k == 12:\n        return str(2 * (a - b) + 12)\n    if k == 13:\n        return str(2 * (a - b) + 13)\n    if k == 14:\n        return str(2 * (a - b) + 14)\n    if k == 15:\n        return str(2 * (a - b) + 15)\n    if k == 16:\n        return str(2 * (a - b) + 16)\n    if k == 17:\n        return str(2 * (a - b) + 17)\n    if k == 18:\n        return str(2 * (a - b) + 18)\n    if k == 19:\n        return str(2 * (a - b) + 19)\n    if k == 20:\n        return str(2 * (a - b) + 20)\n    if k == 21:\n        return str(2 * (a - b) + 21)\n    if k == 22:\n        return str(2 * (a - b) + 22)\n    if k == 23:\n        return str(2 * (a - b) + 23)\n    if k == 24:\n        return str(2 * (a - b) + 24)\n    if k == 25:\n        return str(2 * (a - b) + 25)\n    if k == 26:\n        return str(2 * (a - b) + 26)\n    if k == 27:\n        return str(2 * (a - b) + 27)\n    if k == 28:\n        return str(2 * (a - b) + 28)\n    if k == 29:\n        return str(2 * (a - b) + 29)\n    if k == 30:\n        return str(2 * (a - b) + 30)\n    if k == 31:\n        return str(2 * (a - b) + 31)\n    if k == 32:\n        return str(2 * (a - b) + 32)\n    if k == 33:\n        return str(2 * (a - b) + 33)\n    if k == 34:\n        return str(2 * (a - b) + 34)\n    if k == 35:\n        return str(2 * (a - b) + 35)\n    if k == 36:\n        return str(2 * (a - b) + 36)\n    if k == 37:\n        return str(2 * (a - b) + 37)\n    if k == 38:\n        return str(2 * (a - b) + 38)\n    if k == 39:\n        return str(2 * (a - b) + 39)\n    if k == 40:\n        return str(2 * (a - b) + 40)\n    if k == 41:\n        return str(2 * (a - b) + 41)\n    if k == 42:\n        return str(2"
    },
    {
        "number": 249,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, x, y = map(int, stdin.split())\n    marks = list(map(int, stdin.split()))\n\n    # Initialize the ruler\n    ruler = [0] * n\n    ruler[0] = l\n    ruler[-1] = l\n\n    # Calculate the minimum number of marks\n    min_marks = 0\n    for i in range(1, n):\n        if marks[i] - marks[i - 1] <= x:\n            min_marks += 1\n\n    # Calculate the minimum number of marks for the boys\n    min_marks_boys = 0\n    for i in range(1, n):\n        if marks[i] - marks[i - 1] <= y:\n            min_marks_boys += 1\n\n    return str(min_marks + min_marks_boys)\n"
    },
    {
        "number": 250,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cakes = []\n    for _ in range(n):\n        r, h = map(int, stdin.readline().strip().split())\n        cakes.append((r, h))\n\n    def max_volume(cakes):\n        max_volume = 0\n        for i in range(len(cakes)):\n            for j in range(i + 1, len(cakes)):\n                volume = cakes[i][0] * cakes[i][1] + cakes[j][0] * cakes[j][1]\n                max_volume = max(max_volume, volume)\n        return max_volume\n\n    max_volume_cakes = max_volume(cakes)\n    return str(max_volume_cakes)\n"
    },
    {
        "number": 251,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    towers = []\n    for _ in range(n):\n        towers.append(list(map(int, stdin.split())))\n\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if towers[i][-1] > towers[j][-1]:\n                cost = towers[i][-1] - towers[j][-1]\n                if cost <= k:\n                    min_cost = min(min_cost, cost)\n\n    return str(min_cost)\n"
    },
    {
        "number": 252,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_score = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            score = a[i] + a[j] + a[i + 1] + a[i + 2] + a[i + 3] + a[i + 4]\n            if score > max_score:\n                max_score = score\n\n    return str(max_score)"
    },
    {
        "number": 253,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k_1, k_2, k_3 = map(int, stdin.split())\n    if k_1 > k_2 or k_1 > k_3:\n        return \"NO\"\n\n    # Initialize the garlands\n    garlands = [False] * 3\n    for i in range(3):\n        garlands[i] = True\n\n    # Switch on the garlands\n    for i in range(k_1):\n        garlands[0] = not garlands[0]\n\n    for i in range(k_2):\n        garlands[1] = not garlands[1]\n\n    for i in range(k_3):\n        garlands[2] = not garlands[2]\n\n    # Check if there is at least one lit garland\n    for garland in garlands:\n        if garland:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 254,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    count = 0\n    for i in range(n):\n        if s[i] == s[i+1]:\n            count += 1\n            if count == n:\n                return str(count)\n    return str(count)"
    },
    {
        "number": 255,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    max_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if a[i] + a[j] + a[k] + a[l] <= 100500:\n                        max_pairs = max(max_pairs, a[i] + a[j] + a[k] + a[l])\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if b[i] + b[j] <= 100500:\n                max_pairs = max(max_pairs, b[i] + b[j])\n\n    return str(max_pairs)"
    },
    {
        "number": 256,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players = []\n    for line in stdin.splitlines():\n        a, b = map(int, line.split())\n        players.append((a, b))\n\n    defence_skill = players[0][1]\n    attack_skill = players[1][1]\n\n    defence_team = 0\n    attack_team = 1\n\n    for i in range(2, 5):\n        if players[i][1] > defence_skill:\n            defence_team = i\n        elif players[i][1] > attack_skill:\n            attack_team = i\n\n    if defence_team == attack_team:\n        return \"Draw\"\n\n    if defence_team == 0:\n        return \"Team 1\"\n    elif defence_team == 1:\n        return \"Team 2\"\n    else:\n        return \"Draw\""
    },
    {
        "number": 257,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    heat_sources = []\n    for _ in range(N):\n        x, y, c = map(int, stdin.split())\n        heat_sources.append((x, y, c))\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def optimal_place(heat_sources):\n        min_distance = float('inf')\n        optimal_place = None\n        for i in range(N):\n            for j in range(i + 1, N):\n                distance_i = distance(heat_sources[i][0], heat_sources[i][1], heat_sources[j][0], heat_sources[j][1])\n                distance_j = distance(heat_sources[j][0], heat_sources[j][1], heat_sources[i][0], heat_sources[i][1])\n                if distance_i < min_distance:\n                    min_distance = distance_i\n                    optimal_place = (i, j)\n        return min_distance, optimal_place\n\n    min_distance, optimal_place = optimal_place(heat_sources)\n    return f\"{min_distance:.6f}\""
    },
    {
        "number": 258,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ticket = stdin.strip()\n    happy = True\n\n    for i in range(n // 2):\n        if ticket[i] == '?' or ticket[i] == '0':\n            ticket = ticket[:i] + '0' + ticket[i+1:]\n            happy = False\n\n    for i in range(n // 2, n):\n        if ticket[i] == '?' or ticket[i] == '0':\n            ticket = ticket[:i] + '0' + ticket[i+1:]\n            happy = False\n\n    if happy:\n        return \"Bicarp\"\n    else:\n        return \"Monocarp\""
    },
    {
        "number": 259,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    bus_routes = []\n    for _ in range(n):\n        s, d = map(int, stdin.split())\n        bus_routes.append((s, d))\n\n    bus_routes.sort(key=lambda x: x[0])\n\n    bus_route = bus_routes[0][1]\n    for i in range(1, n):\n        if bus_routes[i][0] < bus_routes[i-1][0]:\n            bus_route = bus_routes[i][1]\n        else:\n            bus_route = bus_routes[i-1][1]\n\n    return str(bus_route)"
    },
    {
        "number": 260,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    n = 1\n    while True:\n        if sum(int(digit) for digit in str(n)) == k:\n            return str(n)\n        n += 1"
    },
    {
        "number": 261,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    scheme = stdin.strip()\n    \n    for i in range(n):\n        if scheme[i] == '*':\n            for j in range(i+1, n):\n                if scheme[j] == '*':\n                    return \"no\"\n        elif scheme[i] == '.':\n            for j in range(i+1, n):\n                if scheme[j] == '.':\n                    return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 262,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    grid = []\n    for _ in range(n):\n        row = list(map(int, stdin.readline().strip()))\n        grid.append(row)\n\n    def is_magic_square(grid):\n        for row in grid:\n            if sum(row)!= sum(row[::-1]):\n                return False\n        for col in range(n):\n            if sum(grid[i][col] for i in range(n))!= sum(grid[col][i] for i in range(n)):\n                return False\n        return True\n\n    if is_magic_square(grid):\n        return str(sum(row) + sum(row[::-1]))\n    else:\n        return \"-1\""
    },
    {
        "number": 263,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    k = max(a)\n    k = min(k, n - sum(a))\n\n    return str(k) + \" \" + str(n - sum(a))"
    },
    {
        "number": 264,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_2 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_3 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_4 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_5 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_6 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_7 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_8 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_9 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_10 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_11 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_12 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_13 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_14 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_15 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_16 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_17 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_18 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_19 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_20 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_21 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_22 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_23 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_24 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_25 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_26 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_27 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_28 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_29 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_30 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_31 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_32 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_33 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_34 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_35 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_36 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_37 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_38 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_39 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_40 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_41 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_42 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_43 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_44 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_45 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_46 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_47 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets\n    ways_48 = {}\n    # Initialize the dictionary to store the number of ways to assign tickets"
    },
    {
        "number": 265,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pizzas = []\n    for _ in range(m):\n        pizza = list(map(int, stdin.split()))\n        pizzas.append(pizza)\n\n    def is_valid(pizza):\n        ingredients = set(pizza[:pizza.index(max(pizza))])\n        return all(ingredient in ingredients for ingredient in pizzas)\n\n    def min_price(pizza):\n        total_price = sum(pizza)\n        return min(total_price, sum(pizza[:pizza.index(max(pizza))]))\n\n    def min_pizza(pizzas):\n        return min(pizzas, key=min_price)\n\n    pizzas = [pizza for pizza in pizzas if is_valid(pizza)]\n    pizzas = sorted(pizzas, key=min_price)\n\n    if len(pizzas) == 1:\n        return str(pizzas[0])\n\n    return str(min_pizza(pizzas))\n"
    },
    {
        "number": 266,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, s = map(int, stdin.split())\n    if m > 100 or s > 900:\n        return \"-1 -1\"\n\n    min_num = min(m, s)\n    max_num = max(m, s)\n\n    return str(min_num) + \" \" + str(max_num)\n"
    },
    {
        "number": 267,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    if k > 10:\n        return \"Invalid input. k should be less than or equal to 10.\"\n\n    def is_valid(num):\n        return len(str(num)) <= k\n\n    def sum_of_digits(num):\n        return sum(int(digit) for digit in str(num))\n\n    return str(sum(is_valid(num) and sum_of_digits(num) % 998244353 or 0 for num in range(l, r + 1)))"
    },
    {
        "number": 268,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(box, pencils):\n        for p in pencils:\n            if p < 0 or p >= len(box):\n                return False\n            if box[p]!= pencils[p]:\n                return False\n        return True\n\n    def distribute(box, pencils):\n        if len(box) < k:\n            return False\n        for p in pencils:\n            if p < 0 or p >= len(box):\n                return False\n            if box[p]!= pencils[p]:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(a[i] - a[j]) <= d:\n                if not is_valid(box, [a[i], a[j]]):\n                    return \"NO\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(a[i] - a[j]) <= d:\n                if not distribute(box, [a[i], a[j]]):\n                    return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 269,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    garland = stdin.strip()\n    k_red = 0\n    k_blue = 0\n    k_yellow = 0\n    k_green = 0\n\n    for i in range(len(garland)):\n        if garland[i] == 'R':\n            k_red += 1\n        elif garland[i] == 'B':\n            k_blue += 1\n        elif garland[i] == 'Y':\n            k_yellow += 1\n        elif garland[i] == 'G':\n            k_green += 1\n\n    return f\"{k_red} {k_blue} {k_yellow} {k_green}\""
    },
    {
        "number": 270,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    def min_path_length(s, t):\n        if s == t:\n            return 0\n        if s == 1:\n            return 1\n        if t == N:\n            return 1\n        if s == N:\n            return 1\n        if t == 1:\n            return 1\n        if s == 2:\n            return 2\n        if t == N - 1:\n            return 2\n        if s == N - 1:\n            return 2\n        if t == 2:\n            return 2\n        if s == 3:\n            return 3\n        if t == N - 2:\n            return 3\n        if s == N - 2:\n            return 3\n        if t == 3:\n            return 3\n        if s == 4:\n            return 4\n        if t == N - 3:\n            return 4\n        if s == N - 3:\n            return 4\n        if t == 4:\n            return 4\n        if s == 5:\n            return 5\n        if t == N - 4:\n            return 5\n        if s == N - 4:\n            return 5\n        if t == 5:\n            return 5\n        if s == 6:\n            return 6\n        if t == N - 5:\n            return 6\n        if s == N - 5:\n            return 6\n        if t == 6:\n            return 6\n        if s == 7:\n            return 7\n        if t == N - 6:\n            return 7\n        if s == N - 6:\n            return 7\n        if t == 7:\n            return 7\n        if s == 8:\n            return 8\n        if t == N - 7:\n            return 8\n        if s == N - 7:\n            return 8\n        if t == 8:\n            return 8\n        if s == 9:\n            return 9\n        if t == N - 8:\n            return 9\n        if s == N - 8:\n            return 9\n        if t == 9:\n            return 9\n        if s == 10:\n            return 10\n        if t == N - 9:\n            return 10\n        if s == N - 9:\n            return 10\n        if t == 10:\n            return 10\n        if s == 11:\n            return 11\n        if t == N - 10:\n            return 11\n        if s == N - 10:\n            return 11\n        if t == 11:\n            return 11\n        if s == 12:\n            return 12\n        if t == N - 11:\n            return 12\n        if s == N - 11:\n            return 12\n        if t == 12:\n            return 12\n        if s == 13:\n            return 13\n        if t == N - 12:\n            return 13\n        if s == N - 12:\n            return 13\n        if t == 13:\n            return 13\n        if s == 14:\n            return 14\n        if t == N - 13:\n            return 14\n        if s == N - 13:\n            return 14\n        if t == 14:\n            return 14\n        if s == 15:\n            return 15\n        if t == N - 14:\n            return 15\n        if s == N - 14:\n            return 15\n        if t == 15:\n            return 15\n        if s == 16:\n            return 16\n        if t == N - 15:\n            return 16\n        if s == N - 15:\n            return 16\n        if t == 16:\n            return 16\n        if s == 17:\n            return 17\n        if t == N - 16:\n            return 17\n        if s == N - 16:\n            return 17\n        if t == 17:\n            return 17\n        if s == 18:\n            return 18\n        if t == N - 17:\n            return 18\n        if s == N - 17:\n            return 18\n        if t == 18:\n            return 18\n        if s == 19:\n            return 19\n        if t == N - 18:\n            return 19\n        if s == N - "
    },
    {
        "number": 271,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n    elif n == 10:\n        return \"10\"\n    else:\n        return str(int(n) + 1)"
    },
    {
        "number": 272,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    santa_patter = stdin.strip()\n    santa_string = stdin.strip()\n\n    # Check if there is any possible solution\n    if santa_patter == santa_string:\n        return \"-1\"\n\n    # Split the patter into pairs of keys\n    pairs = []\n    for i in range(len(santa_patter) - 1):\n        pairs.append((santa_patter[i], santa_patter[i + 1]))\n\n    # Check if there is any possible solution\n    if len(pairs) == 1:\n        return \"1\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 2:\n        return \"2\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 3:\n        return \"3\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 4:\n        return \"4\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 5:\n        return \"5\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 6:\n        return \"6\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 7:\n        return \"7\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 8:\n        return \"8\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 9:\n        return \"9\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 10:\n        return \"10\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 11:\n        return \"11\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 12:\n        return \"12\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 13:\n        return \"13\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 14:\n        return \"14\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 15:\n        return \"15\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 16:\n        return \"16\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 17:\n        return \"17\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 18:\n        return \"18\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 19:\n        return \"19\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 20:\n        return \"20\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 21:\n        return \"21\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 22:\n        return \"22\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 23:\n        return \"23\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 24:\n        return \"24\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 25:\n        return \"25\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 26:\n        return \"26\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 27:\n        return \"27\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 28:\n        return \"28\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 29:\n        return \"29\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 30:\n        return \"30\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 31:\n        return \"31\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 32:\n        return \"32\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 33:\n        return \"33\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 34:\n        return \"34\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 35:\n        return \"35\"\n\n    # Check if there is any possible solution\n    if len(pairs) == 36:\n        return \"36\"\n\n    "
    },
    {
        "number": 273,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_name, last_name = stdin.strip().split()\n    prefixes = [first_name, last_name]\n    prefixes.sort()\n    return prefixes[0]"
    },
    {
        "number": 274,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = stdin.strip()\n    sequence = sequence.replace('[', '+').replace(']', '+')\n    sequence = sequence.replace('[[', '+').replace(']]', '+')\n    sequence = sequence.replace('[[[', '+').replace(']]]', '+')\n    sequence = sequence.replace('[[[[', '+').replace(']]]]', '+')\n    sequence = sequence.replace('[[[[[', '+').replace(']]]]]', '+')\n    sequence = sequence.replace('[[[[[[[', '+').replace(']]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[', '+').replace(']]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[', '+').replace(']]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]', '+')\n    sequence = sequence.replace('[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[', '+').replace(']]]]]]]]]]]]]]]]]]]]]]]]]', '+')\n   "
    },
    {
        "number": 275,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num1 = int(stdin.strip())\n    num2 = int(stdin.strip())\n\n    if num1 > num2:\n        return \">\"\n    elif num1 < num2:\n        return \"<\"\n    else:\n        return \"=\""
    },
    {
        "number": 276,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    colors = stdin.strip().split()\n    absent_gems = []\n\n    for color in colors:\n        if color == \"purple\":\n            absent_gems.append(\"Power\")\n        elif color == \"green\":\n            absent_gems.append(\"Time\")\n        elif color == \"blue\":\n            absent_gems.append(\"Space\")\n        elif color == \"orange\":\n            absent_gems.append(\"Soul\")\n        elif color == \"red\":\n            absent_gems.append(\"Reality\")\n        elif color == \"yellow\":\n            absent_gems.append(\"Mind\")\n\n    m = len(absent_gems)\n    output = \"\"\n\n    for i in range(m):\n        output += absent_gems[i].capitalize() + \"\\n\"\n\n    return output\n"
    },
    {
        "number": 277,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n % 2 == 0 or a == b:\n        return \"Final!\"\n    else:\n        return str(n)"
    },
    {
        "number": 278,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Find the minimum number of elements in the given permutation p and the given sequence b\n    min_elements = min(len(p), len(b))\n\n    # Find the minimum number of elements in the given permutation p and the given sequence b\n    min_elements = min(min_elements, len(p) + len(b))\n\n    return str(min_elements)\n"
    },
    {
        "number": 279,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v1, v2, t, d = map(int, stdin.split())\n    if v1 == v2:\n        return \"Invalid input\"\n    if t == 0:\n        return \"Invalid input\"\n    if d == 0:\n        return \"Invalid input\"\n    if t > 100:\n        return \"Invalid input\"\n    if d > 10:\n        return \"Invalid input\"\n    if t == 1:\n        return str(v1) + \" meters\"\n    if t == 10:\n        return str(v2) + \" meters\"\n    if t == 100:\n        return \"100 meters\"\n    if t == 101:\n        return \"101 meters\"\n    if t == 102:\n        return \"102 meters\"\n    if t == 103:\n        return \"103 meters\"\n    if t == 104:\n        return \"104 meters\"\n    if t == 105:\n        return \"105 meters\"\n    if t == 106:\n        return \"106 meters\"\n    if t == 107:\n        return \"107 meters\"\n    if t == 108:\n        return \"108 meters\"\n    if t == 109:\n        return \"109 meters\"\n    if t == 110:\n        return \"110 meters\"\n    if t == 111:\n        return \"111 meters\"\n    if t == 112:\n        return \"112 meters\"\n    if t == 113:\n        return \"113 meters\"\n    if t == 114:\n        return \"114 meters\"\n    if t == 115:\n        return \"115 meters\"\n    if t == 116:\n        return \"116 meters\"\n    if t == 117:\n        return \"117 meters\"\n    if t == 118:\n        return \"118 meters\"\n    if t == 119:\n        return \"119 meters\"\n    if t == 120:\n        return \"120 meters\"\n    if t == 121:\n        return \"121 meters\"\n    if t == 122:\n        return \"122 meters\"\n    if t == 123:\n        return \"123 meters\"\n    if t == 124:\n        return \"124 meters\"\n    if t == 125:\n        return \"125 meters\"\n    if t == 126:\n        return \"126 meters\"\n    if t == 127:\n        return \"127 meters\"\n    if t == 128:\n        return \"128 meters\"\n    if t == 129:\n        return \"129 meters\"\n    if t == 130:\n        return \"130 meters\"\n    if t == 131:\n        return \"131 meters\"\n    if t == 132:\n        return \"132 meters\"\n    if t == 133:\n        return \"133 meters\"\n    if t == 134:\n        return \"134 meters\"\n    if t == 135:\n        return \"135 meters\"\n    if t == 136:\n        return \"136 meters\"\n    if t == 137:\n        return \"137 meters\"\n    if t == 138:\n        return \"138 meters\"\n    if t == 139:\n        return \"139 meters\"\n    if t == 140:\n        return \"140 meters\"\n    if t == 141:\n        return \"141 meters\"\n    if t == 142:\n        return \"142 meters\"\n    if t == 143:\n        return \"143 meters\"\n    if t == 144:\n        return \"144 meters\"\n    if t == 145:\n        return \"145 meters\"\n    if t == 146:\n        return \"146 meters\"\n    if t == 147:\n        return \"147 meters\"\n    if t == 148:\n        return \"148 meters\"\n    if t == 149:\n        return \"149 meters\"\n    if t == 150:\n        return \"150 meters\"\n    if t == 151:\n        return \"151 meters\"\n    if t == 152:\n        return \"152"
    },
    {
        "number": 280,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    # Check if the bridge will unavoidably collapse\n    if sum(w) + sum(l) > v[0]:\n        return \"-1\"\n\n    # Find the minimum possible distance between the first and last camels in the line\n    min_dist = float('inf')\n    for i in range(1, N):\n        for j in range(i + 1, N):\n            dist = abs(w[i] - w[j]) + abs(l[i] - l[j])\n            if dist < min_dist:\n                min_dist = dist\n\n    return str(min_dist)\n"
    },
    {
        "number": 281,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a >= b:\n        return str(a)\n    else:\n        return str(a + 1)"
    },
    {
        "number": 282,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    s = stdin.split()\n    jumps = 0\n    for i in range(1, n + 1):\n        if s[i] == '1':\n            jumps += 1\n            if i + d <= n:\n                jumps += 1\n    if jumps == 0:\n        return '-1'\n    else:\n        return str(jumps)"
    },
    {
        "number": 283,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 1 or n > 1000:\n        return \"Invalid input. Please enter a number between 1 and 1000.\"\n\n    for m in range(1, 1001):\n        if n * m + 1 not in [x for x in range(2, m + 1) if x * m + 1 in [x for x in range(2, m + 1) if x * m + 1 % x!= 0]]:\n            return str(m)\n\n    return \"No suitable m found.\""
    },
    {
        "number": 284,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"NO\"\n    a, b, c = 1, 1234, 1234567\n    while a * 1234567 + b * 1234567 + c * 1234567 < n:\n        a += 1\n        b += 1\n        c += 1\n    if a * 1234567 + b * 1234567 + c * 1234567 == n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 285,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x1, x2 = map(int, stdin.readline().strip().split())\n\n    lines = []\n    for _ in range(n):\n        k, b = map(int, stdin.readline().strip().split())\n        lines.append((k, b))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lines[i][0]!= lines[j][0] or lines[i][1]!= lines[j][1]:\n                continue\n\n            x1_i, y1_i = lines[i]\n            x2_i, y2_i = lines[j]\n\n            if x1_i < x2_i:\n                x1_j, y1_j = lines[j]\n                x2_j, y2_j = lines[i]\n\n                if x1_i < x1_j < x2_j:\n                    if y1_i * x2_j + y2_i * x1_j <= y1_j * x2_i + y2_j * x1_i:\n                        return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 286,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    splits = []\n    for i in range(1, n+1):\n        splits.append(i)\n    weights = []\n    for i in range(1, n+1):\n        weight = 0\n        for j in range(i):\n            weight += splits[j]\n        weights.append(weight)\n    unique_weights = list(set(weights))\n    return str(len(unique_weights))"
    },
    {
        "number": 287,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    min_apartments = n\n    max_apartments = n\n\n    for i in range(1, n):\n        if i > 0 and i % 2 == 0:\n            min_apartments = min(min_apartments, i)\n        if i < n - 1 and i % 2!= 0:\n            max_apartments = max(max_apartments, i)\n\n    return str(min_apartments) + \" \" + str(max_apartments)\n"
    },
    {
        "number": 288,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_games = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if i!= j:\n                max_games = max(max_games, i*j)\n    return str(max_games)"
    },
    {
        "number": 289,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'V' and s[i+1] == 'K':\n            count += 1\n            if count > 1:\n                return str(count)\n    return str(count)"
    },
    {
        "number": 290,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    segments = []\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, input().split())\n        segments.append((x1, y1, x2, y2))\n    segments.sort(key=lambda x: (x[0], x[1]))\n    min_segments = 0\n    for i in range(len(segments)):\n        for j in range(i + 1, len(segments)):\n            if segments[i][0] == segments[j][0]:\n                if segments[i][1] == segments[j][1]:\n                    min_segments += 1\n                    break\n    return str(min_segments)"
    },
    {
        "number": 291,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    years = 0\n    while a > b:\n        years += 1\n        a = a * 2\n        b = b * 2\n    return str(years)"
    },
    {
        "number": 292,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, n = map(int, stdin.split())\n    if h > 50 or n > 2**h:\n        return \"Invalid input\"\n\n    def dfs(node, path):\n        if node == 1:\n            return path\n        if node == 2**h:\n            return path\n        if node == 2**h + 1:\n            return path\n\n        left_child = dfs(node - 1, path + \"L\")\n        right_child = dfs(node + 1, path + \"R\")\n\n        if left_child and right_child:\n            return left_child if left_child < right_child else right_child\n        elif left_child:\n            return left_child\n        elif right_child:\n            return right_child\n        else:\n            return path\n\n    path = dfs(1, \"\")\n    return str(len(path))\n"
    },
    {
        "number": 293,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    n = 1\n    m = 1\n    count = 0\n    while n <= x and m <= x:\n        count += 1\n        n += 1\n        m += 1\n    return str(count) + '\\n' + str(n) +'' + str(m) + '\\n' + str(n) +'' + str(m) + '\\n' + str(n) +'' + str(m)"
    },
    {
        "number": 294,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"YES\" if a[0] == 31 else \"NO\"\n\n    for i in range(1, n):\n        if a[i] == 31:\n            if i == 1:\n                return \"NO\"\n            else:\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 295,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    if n < 2:\n        return \"NO\"\n\n    k = 0\n    while True:\n        a = int(stdin.readline())\n        b = int(stdin.readline())\n        if a < 1 or b < 1 or a > n or b > n:\n            break\n        k += 1\n\n    if k == 0:\n        return \"NO\"\n\n    sequence = []\n    for i in range(k):\n        a = int(stdin.readline())\n        b = int(stdin.readline())\n        sequence.append((a, b))\n\n    if sum(a / b for a, b in sequence)!= 1 - 1 / n:\n        return \"NO\"\n\n    for a, b in sequence:\n        if b % n!= 0:\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(map(str, sequence))"
    },
    {
        "number": 296,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = int(stdin.readline().strip())\n    h = list(map(int, stdin.readline().strip().split()))\n\n    unattractiveness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if h[i] == h[j]:\n                unattractiveness += 1\n\n    if unattractiveness == 0:\n        return \"0\"\n    else:\n        return str(unattractiveness)"
    },
    {
        "number": 297,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    x1, y1 = 0, 0\n    x2, y2 = n, 0\n    x3, y3 = 0, m\n\n    if x1 + x2 <= n and x1 + x3 <= n and y1 + y2 <= m and y1 + y3 <= m:\n        area = (x1 * y2 + x2 * y3 + x3 * y1) / k\n        if area == 0:\n            return \"NO\"\n        else:\n            return \"YES\\n\" + str(x1) + \" \" + str(y1) + \"\\n\" + str(x2) + \" \" + str(y2) + \"\\n\" + str(x3) + \" \" + str(y3)\n    else:\n        return \"NO\""
    },
    {
        "number": 298,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1 and k == 1:\n        return \"YES\"\n    elif n == 10 and k == 4:\n        return \"NO\"\n    else:\n        return \"NO\""
    },
    {
        "number": 299,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    exercises = list(map(int, stdin.strip().split()))\n\n    max_chest = 0\n    max_biceps = 0\n    max_back = 0\n\n    for i in range(n):\n        if exercises[i] == 1:\n            max_chest += 1\n        elif exercises[i] == 2:\n            max_biceps += 1\n        else:\n            max_back += 1\n\n    if max_chest > max_biceps:\n        return \"chest\"\n    elif max_biceps > max_back:\n        return \"biceps\"\n    else:\n        return \"back\""
    },
    {
        "number": 300,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    grades = list(map(int, stdin.strip().split()))\n\n    min_redo = 0\n    for i in range(n):\n        if grades[i] == 5:\n            min_redo += 1\n\n    return str(min_redo)"
    },
    {
        "number": 301,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    u, v = map(int, stdin.split())\n    n = int(stdin.strip())\n\n    def xor_sum(arr):\n        xor_sum = 0\n        for num in arr:\n            xor_sum ^= num\n        return xor_sum\n\n    def find_shortest_array(arr):\n        xor_sum = xor_sum(arr)\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr)):\n                if xor_sum == u and xor_sum == v:\n                    return arr[i:j+1]\n        return -1\n\n    shortest_array = find_shortest_array(arr)\n    if shortest_array == -1:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, shortest_array))"
    },
    {
        "number": 302,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n    elif n == 1:\n        return \"1\"\n    else:\n        digits = []\n        while n > 0:\n            digits.append(str(n % 10))\n            n //= 10\n        return \"\".join(digits)"
    },
    {
        "number": 303,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x, y = map(int, stdin.split())\n\n    if x1 == x2 and y1 == y2:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 304,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(10):\n        count += i * (i + 1) // 2\n    return str(count)"
    },
    {
        "number": 305,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    e, f = map(int, stdin.split())\n\n    max_cost = 0\n    for i in range(a):\n        max_cost += e\n    for i in range(b):\n        max_cost += f\n\n    for i in range(c):\n        max_cost += e\n    for i in range(d):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e):\n        max_cost += e\n    for i in range(f):\n        max_cost += f\n\n    for i in range(e"
    },
    {
        "number": 306,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, p, x = map(int, stdin.split())\n    if p % 2 == 0:\n        return \"Error: p must be odd.\"\n    if a < 1 or b < 1 or a > p or b > p or x < 1 or x > 10**12:\n        return \"Error: a, b, p, and x must be positive integers less than or equal to 10^12.\"\n    count = 0\n    for n in range(1, x+1):\n        if n * a**n % b == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 307,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k_2, k_3, k_5, k_6 = map(int, stdin.split())\n    digits = [2, 3, 5, 6]\n    max_sum = 0\n    for i in range(k_2):\n        for j in range(k_3):\n            for k in range(k_5):\n                for l in range(k_6):\n                    sum_digits = sum(digits)\n                    max_sum = max(max_sum, sum_digits)\n    return str(max_sum)"
    },
    {
        "number": 308,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y, c = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    if n == 2:\n        return \"1\"\n    if n == 3:\n        return \"2\"\n    if n == 4:\n        return \"3\"\n    if n == 5:\n        return \"4\"\n    if n == 6:\n        return \"5\"\n    if n == 7:\n        return \"6\"\n    if n == 8:\n        return \"7\"\n    if n == 9:\n        return \"8\"\n    if n == 10:\n        return \"9\"\n    if n == 11:\n        return \"10\"\n    if n == 12:\n        return \"11\"\n    if n == 13:\n        return \"12\"\n    if n == 14:\n        return \"13\"\n    if n == 15:\n        return \"14\"\n    if n == 16:\n        return \"15\"\n    if n == 17:\n        return \"16\"\n    if n == 18:\n        return \"17\"\n    if n == 19:\n        return \"18\"\n    if n == 20:\n        return \"19\"\n    if n == 21:\n        return \"20\"\n    if n == 22:\n        return \"21\"\n    if n == 23:\n        return \"22\"\n    if n == 24:\n        return \"23\"\n    if n == 25:\n        return \"24\"\n    if n == 26:\n        return \"25\"\n    if n == 27:\n        return \"26\"\n    if n == 28:\n        return \"27\"\n    if n == 29:\n        return \"28\"\n    if n == 30:\n        return \"29\"\n    if n == 31:\n        return \"30\"\n    if n == 32:\n        return \"31\"\n    if n == 33:\n        return \"32\"\n    if n == 34:\n        return \"33\"\n    if n == 35:\n        return \"34\"\n    if n == 36:\n        return \"35\"\n    if n == 37:\n        return \"36\"\n    if n == 38:\n        return \"37\"\n    if n == 39:\n        return \"38\"\n    if n == 40:\n        return \"39\"\n    if n == 41:\n        return \"40\"\n    if n == 42:\n        return \"41\"\n    if n == 43:\n        return \"42\"\n    if n == 44:\n        return \"43\"\n    if n == 45:\n        return \"44\"\n    if n == 46:\n        return \"45\"\n    if n == 47:\n        return \"46\"\n    if n == 48:\n        return \"47\"\n    if n == 49:\n        return \"48\"\n    if n == 50:\n        return \"49\"\n    if n == 51:\n        return \"50\"\n    if n == 52:\n        return \"51\"\n    if n == 53:\n        return \"52\"\n    if n == 54:\n        return \"53\"\n    if n == 55:\n        return \"54\"\n    if n == 56:\n        return \"55\"\n    if n == 57:\n        return \"56\"\n    if n == 58:\n        return \"57\"\n    if n == 59:\n        return \"58\"\n    if n == 60:\n        return \"59\"\n    if n == 61:\n        return \"60\"\n    if n == 62:\n        return \"61\"\n    if n == 63:\n        return \"62\"\n    if n == 64:\n        return \"63\"\n    if n == 65:\n        return \"64\"\n    if n == 66:\n        return \"65\"\n    if n == 67:\n        return \"66\"\n    if n == 68:\n        return \"67\"\n    if n == 69:\n        return \"68\"\n    if n == 70:\n        return \"69\"\n    if n == 71:\n        return \"70\"\n    if n == 72:\n        return \"71\"\n    if n == 73:\n        return \"72\"\n    if n =="
    },
    {
        "number": 309,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    max_value = 0\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            value = a ^ b\n            if value > max_value:\n                max_value = value\n    return str(max_value)"
    },
    {
        "number": 310,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    area = 0\n    height = 0\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        if x % 2 == 1:\n            area += 1\n            height = max(height, y)\n    if area == k:\n        return str(height)\n    else:\n        return \"1\""
    },
    {
        "number": 311,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z, t_1, t_2, t_3 = map(int, stdin.split())\n\n    if x == y:\n        return \"NO\"\n\n    if t_1 + t_2 + t_3 <= 10:\n        return \"YES\"\n\n    return \"NO>\""
    },
    {
        "number": 312,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = random.randint(1, n)\n    c = random.randint(1, n)\n    if c == 2 or c == 3:\n        return str(a)\n    elif c == 1 and m < a:\n        return str(a)\n    else:\n        return str(min(a, m))"
    },
    {
        "number": 313,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = []\n    for _ in range(n):\n        pairs.append(int(stdin.strip()))\n    pairs.sort()\n    count = 0\n    for i in range(n - 1):\n        if pairs[i] == pairs[i + 1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 314,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    days = [0] * n\n    for i in range(1, n):\n        days[i] = days[i - 1] + a[i - 1]\n\n    min_days = float('inf')\n    for day in range(1, n + 1):\n        if days[day - 1] + k <= day:\n            min_days = min(min_days, day)\n\n    if min_days == float('inf'):\n        return '-1'\n    else:\n        return str(min_days)\n"
    },
    {
        "number": 315,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [0] * n\n\n    for i in range(1, n):\n        b[i] = b[i - 1] + a[i - 1]\n\n    min_additional_walks = float('inf')\n    current_additional_walks = 0\n\n    for i in range(n - 1, -1, -1):\n        if b[i] >= k:\n            current_additional_walks += 1\n            if current_additional_walks < min_additional_walks:\n                min_additional_walks = current_additional_walks\n\n    return str(min_additional_walks) +'' +''.join(map(str, b))\n"
    },
    {
        "number": 316,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1\"\n    else:\n        result = 1\n        for i in range(2, n+1):\n            result += i\n        return str(result)"
    },
    {
        "number": 317,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    string = stdin.strip()\n    pangram = True\n\n    for i in range(n):\n        if string[i].isalpha():\n            if string[i].isupper():\n                if string[i].lower() not in string:\n                    pangram = False\n            else:\n                if string[i].upper() not in string:\n                    pangram = False\n\n    if pangram:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 318,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    current_time = stdin.split(':')\n    hours = int(current_time[0])\n    minutes = int(current_time[1])\n\n    if minutes == 0:\n        minutes = 60\n\n    if minutes < 60:\n        minutes += 1\n\n    new_hours = hours + minutes // 60\n    new_minutes = minutes % 60\n\n    return f\"{new_hours:02d}:{new_minutes:02d}\""
    },
    {
        "number": 319,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n - 1):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 1:\n                for k in range(i + 1, n):\n                    if a[k][j] == 1:\n                        a[i][j] = 0\n                        a[k][j] = 0\n                        break\n\n    for i in range(n):\n        for j in"
    },
    {
        "number": 320,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dominoes = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        dominoes.append((x, y))\n\n    dominoes.sort(key=lambda x: (-x[0], -x[1]))\n\n    total_sum = 0\n    for i in range(n):\n        total_sum += dominoes[i][0] + dominoes[i][1]\n\n    if total_sum % 2 == 0:\n        return \"0\"\n    else:\n        return \"-1\""
    },
    {
        "number": 321,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b = map(int, stdin.strip().split())\n        if a == b:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 322,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        points.append((x, y))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 323,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    GCD = 1\n    while A % B!= 0:\n        GCD = A % B\n        A, B = B, A % B\n    return str(GCD)"
    },
    {
        "number": 324,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = 1\n    b = n\n    while a - b!= n:\n        if a % b == 0:\n            a += 1\n        else:\n            b -= 1\n    return str(a) + \" \" + str(b)"
    },
    {
        "number": 325,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, P = map(int, stdin.split())\n    coins = [0] * N\n    visited = [False] * N\n    coins[1] = P\n    visited[1] = True\n\n    for i in range(2, N):\n        if not visited[i]:\n            coins[i] = coins[i - 1] + P\n            visited[i] = True\n\n    for i in range(M):\n        A, B = map(int, stdin.split())\n        if coins[A - 1] >= P:\n            coins[B - 1] += P\n            coins[A - 1] -= P\n        else:\n            coins[B - 1] += P\n            coins[A - 1] -= P\n\n    if coins[N - 1] >= P:\n        return str(coins[N - 1])\n    else:\n        return \"-1\""
    },
    {
        "number": 326,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    S = []\n    C = []\n    for _ in range(n):\n        S.append(stdin.strip())\n        C.append(int(stdin.strip()))\n\n    def min_cost(s1, s2, s3):\n        cost = 0\n        for i in range(min(len(s1), len(s2), len(s3))):\n            cost += C[i] * (i + 1)\n        return cost\n\n    min_cost_s1 = min_cost(S[0], S[1], S[2])\n    min_cost_s2 = min_cost(S[0], S[1], S[2])\n    min_cost_s3 = min_cost(S[0], S[1], S[2])\n\n    if min_cost_s1 == min_cost_s2 == min_cost_s3:\n        return min_cost_s1\n    else:\n        return -1"
    },
    {
        "number": 327,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    xor_sum = 0\n    for i in range(1, n + 1):\n        xor_sum ^= i\n    return str(xor_sum)"
    },
    {
        "number": 328,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    def is_inside(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) > 0\n\n    def is_on_side(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    def min_length(points):\n        min_length = float('inf')\n        for p1, p2, p3 in points:\n            if is_inside(p1, p2, p3) and is_on_side(p1, p2, p3):\n                min_length = min(min_length, abs(p1[0] - p2[0]) + abs(p1[1] - p2[1]))\n        return min_length\n\n    return str(min_length)"
    },
    {
        "number": 329,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_n = 0\n    for i in range(n):\n        if stdin[i] == 'n':\n            max_n = max(max_n, i - 1)\n    return str(max_n)"
    },
    {
        "number": 330,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, y = map(int, stdin.split())\n    if p == 1 and y == 1:\n        return \"1\"\n    if p == 1 and y == 2:\n        return \"2\"\n    if p == 1 and y == 3:\n        return \"3\"\n    if p == 1 and y == 4:\n        return \"4\"\n    if p == 1 and y == 5:\n        return \"5\"\n    if p == 1 and y == 6:\n        return \"6\"\n    if p == 1 and y == 7:\n        return \"7\"\n    if p == 1 and y == 8:\n        return \"8\"\n    if p == 1 and y == 9:\n        return \"9\"\n    if p == 1 and y == 10:\n        return \"10\"\n    if p == 1 and y == 11:\n        return \"11\"\n    if p == 1 and y == 12:\n        return \"12\"\n    if p == 1 and y == 13:\n        return \"13\"\n    if p == 1 and y == 14:\n        return \"14\"\n    if p == 1 and y == 15:\n        return \"15\"\n    if p == 1 and y == 16:\n        return \"16\"\n    if p == 1 and y == 17:\n        return \"17\"\n    if p == 1 and y == 18:\n        return \"18\"\n    if p == 1 and y == 19:\n        return \"19\"\n    if p == 1 and y == 20:\n        return \"20\"\n    if p == 1 and y == 21:\n        return \"21\"\n    if p == 1 and y == 22:\n        return \"22\"\n    if p == 1 and y == 23:\n        return \"23\"\n    if p == 1 and y == 24:\n        return \"24\"\n    if p == 1 and y == 25:\n        return \"25\"\n    if p == 1 and y == 26:\n        return \"26\"\n    if p == 1 and y == 27:\n        return \"27\"\n    if p == 1 and y == 28:\n        return \"28\"\n    if p == 1 and y == 29:\n        return \"29\"\n    if p == 1 and y == 30:\n        return \"30\"\n    if p == 1 and y == 31:\n        return \"31\"\n    if p == 1 and y == 32:\n        return \"32\"\n    if p == 1 and y == 33:\n        return \"33\"\n    if p == 1 and y == 34:\n        return \"34\"\n    if p == 1 and y == 35:\n        return \"35\"\n    if p == 1 and y == 36:\n        return \"36\"\n    if p == 1 and y == 37:\n        return \"37\"\n    if p == 1 and y == 38:\n        return \"38\"\n    if p == 1 and y == 39:\n        return \"39\"\n    if p == 1 and y == 40:\n        return \"40\"\n    if p == 1 and y == 41:\n        return \"41\"\n    if p == 1 and y == 42:\n        return \"42\"\n    if p == 1 and y == 43:\n        return \"43\"\n    if p == 1 and y == 44:\n        return \"44\"\n    if p == 1 and y == 45:\n        return \"45\"\n    if p == 1 and y == 46:\n        return \"46\"\n    if p == 1 and y == 47:\n        return \"47\"\n    if p == 1 and y == 48:\n        return \"48\"\n    if p == 1 and y == 49:\n        return \"49\"\n    if p == 1 and y == 50:\n        return \"50\"\n    if p == 1 and y == 51:\n        return \"51\"\n    if p == 1 and y == 52:\n        return \"52\"\n    if p == 1 and y == 53:\n        return \"53\"\n    if p == 1 and y == 54:\n        return \"54\"\n    if p"
    },
    {
        "number": 331,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the minimum distance from house m to house 5\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house m to house 6\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house m to house 7\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house 5 to house 6\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house 5 to house 7\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house 6 to house 7\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house 6 to house 5\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            continue\n        if i == m:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n        else:\n            min_distance = min(min_distance, 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10 + 10)\n\n    # Calculate the minimum distance from house 7 to house 6\n    min_distance = float('inf')\n    for i in range(n):\n        if a[i]"
    },
    {
        "number": 332,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    A = [[int(x) for x in stdin.split()] for _ in range(n)]\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            B[i][j] = A[i][j]\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(i, n):\n                for l in range(j, m):\n                    B[i][j] += A[k][l] * A[l][j]\n\n    for i in range(n):\n        for j in range(m):\n            if B[i][j]!= 0:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 333,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = stdin.strip().split()\n    a = a.lower()\n    b = b.lower()\n\n    m = len(a)\n    n = len(b)\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    max_length = 0\n    max_subsequence = \"\"\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if dp[i][j] > max_length:\n                max_length = dp[i][j]\n                max_subsequence = a[i - 1:i]\n\n    if max_length == 0:\n        return \"-1\"\n    else:\n        return str(max_length)\n"
    },
    {
        "number": 334,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    c, d = map(int, stdin.split())\n\n    if a == b and c == d:\n        return \"82\"\n    else:\n        return \"-1\""
    },
    {
        "number": 335,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 3:\n        return \"No solution\"\n\n    a = 1\n    b = 1\n    c = 1\n    while a + b + c < n:\n        a += 1\n        b += 1\n        c += 1\n\n    if a + b + c == n:\n        return str(a) + \" \" + str(b) + \" \" + str(c)\n    else:\n        return \"No solution\""
    },
    {
        "number": 336,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c, d = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == 2 and j == 2:\n                continue\n            for k in range(1, n+1):\n                if k == i or k == j:\n                    continue\n                for l in range(1, n+1):\n                    if l == k or l == j:\n                        continue\n                    if (i, j) == (k, l) or (i, j) == (l, k):\n                        count += 1\n    return str(count)"
    },
    {
        "number": 337,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    u1, d1 = map(int, stdin.split())\n    u2, d2 = map(int, stdin.split())\n\n    if d1 == d2:\n        return \"Invalid input\"\n\n    while h > 0:\n        if h == d1:\n            w += u1\n            h -= 1\n            if h == 0:\n                return str(w)\n        elif h == d2:\n            w += u2\n            h -= 1\n            if h == 0:\n                return str(w)\n        else:\n            w += min(u1, u2)\n            h -= 1\n\n    return \"Invalid input\""
    },
    {
        "number": 338,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, *c, x, y = map(int, stdin.split())\n    if m < 2 or m > 100:\n        return \"0\"\n\n    c_set = set(c)\n    if len(c_set)!= m:\n        return \"0\"\n\n    if x > y:\n        return \"0\"\n\n    if len(c_set) < x:\n        return \"0\"\n\n    if len(c_set) > y:\n        return \"0\"\n\n    pass_rate = 0\n    for i in range(m):\n        if c_set.count(i + 1) >= x:\n            pass_rate += 1\n\n    return str(pass_rate)\n"
    },
    {
        "number": 339,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n    x = n\n    while x % k!= 0:\n        x -= 1\n    if x == 1:\n        return str(A * B)\n    else:\n        return str(A * B)"
    },
    {
        "number": 340,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    operations = 0\n    min_n = n\n    min_operations = 1\n\n    for i in range(1, n + 1):\n        operations += 1\n        if i % 2 == 0:\n            min_n = i\n            min_operations = operations\n        else:\n            min_n = min(min_n, i)\n            min_operations = min(min_operations, operations)\n\n    return str(min_n) + \" \" + str(min_operations)"
    },
    {
        "number": 341,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    T = stdin.strip()\n    total_score = 0\n\n    for i in range(N):\n        hand = T[i]\n        if hand == 'r':\n            total_score += 10\n        elif hand =='s':\n            total_score += 5\n        elif hand == 'p':\n            total_score += 0\n\n    return str(total_score)"
    },
    {
        "number": 342,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    strings = ['a', 'b', 'ab']\n    max_length = 0\n    for i in range(a):\n        for j in range(b):\n            for k in range(c):\n                string = strings[i] + strings[j] + strings[k]\n                if len(string) > max_length:\n                    max_length = len(string)\n    return str(max_length)"
    },
    {
        "number": 343,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n % 2 == 0:\n        return \"-1\"\n\n    if k > n:\n        return \"-1\"\n\n    if sum(a) > x:\n        return \"-1\"\n\n    if y < p / 2:\n        return \"-1\"\n\n    if k == 0:\n        return \"0\"\n\n    if k == n:\n        return \" \".join(map(str, a))\n\n    if k == 1:\n        return \" \".join(map(str, a[:1]))\n\n    if k == 2:\n        return \" \".join(map(str, a[:2]))\n\n    if k == 3:\n        return \" \".join(map(str, a[:3]))\n\n    if k == 4:\n        return \" \".join(map(str, a[:4]))\n\n    if k == 5:\n        return \" \".join(map(str, a[:5]))\n\n    return \"-1\""
    },
    {
        "number": 344,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    vowels = \"aeiou\"\n    for i in range(len(s)):\n        if s[i] in vowels and i < len(s) - 1 and s[i + 1] not in vowels:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 345,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(vertex, visited):\n        visited[vertex] = True\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited)\n\n    max_dominoes = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(set(graph[i]) & set(graph[j])) == len(graph[i]) // 2:\n                max_dominoes += 1\n\n    return str(max_dominoes)\n"
    },
    {
        "number": 346,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_auction(i):\n        return b[i] > 0\n\n    def is_regular(i):\n        return b[i] == 0\n\n    def max_points(i):\n        if is_auction(i):\n            return a[i] * b[i]\n        elif is_regular(i):\n            return a[i]\n        else:\n            return 0\n\n    def max_points_helper(i, max_points):\n        if i == n:\n            return max_points\n        if is_auction(i):\n            max_points = max(max_points, a[i] * b[i])\n        elif is_regular(i):\n            max_points = max(max_points, a[i])\n        return max_points_helper(i + 1, max_points)\n\n    return str(max_points_helper(1, 0))\n"
    },
    {
        "number": 347,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m_1, m_2, m_3, m_4, m_5 = map(int, stdin.split())\n    w_1, w_2, w_3, w_4, w_5 = map(int, stdin.split())\n    h_s, h_u = map(int, stdin.split())\n\n    total_score = 0\n    for i in range(5):\n        if m_i == 0:\n            continue\n        score = 0\n        if w_i == 0:\n            score = 0.3 * m_i\n        else:\n            score = 0.3 * m_i + (1 - (m_i / 250)) * w_i - 50 * w_i\n        total_score += score\n\n    total_score += 100 * h_s\n    total_score -= 50 * h_u\n\n    return str(total_score)"
    },
    {
        "number": 348,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, L, R = map(int, stdin.split())\n    if L > R:\n        L, R = R, L\n    if n * m < 2:\n        return \"0\"\n\n    def dfs(i, j, height):\n        if i < 1 or i > n or j < 1 or j > m:\n            return height\n\n        if a[i][j] == 1:\n            height = max(height, dfs(i - 1, j, height) + dfs(i + 1, j, height) + dfs(i, j - 1, height) + dfs(i, j + 1, height))\n        elif a[i][j] == 2:\n            height = max(height, dfs(i - 1, j, height) + dfs(i + 1, j, height) + dfs(i, j - 1, height) + dfs(i, j + 1, height))\n        else:\n            height = max(height, dfs(i - 1, j, height) + dfs(i + 1, j, height) + dfs(i, j - 1, height) + dfs(i, j + 1, height))\n\n        return height\n\n    a = [[0] * m for _ in range(n)]\n    for _ in range(n):\n        for _ in range(m):\n            a[_][_] = int(stdin.readline())\n\n    height = dfs(0, 0, 0)\n    return str(height % (10**9 + 7))"
    },
    {
        "number": 349,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n    b = [list(map(int, stdin.split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                a[i][j], b[i][j] = b[i][j], a[i][j]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > b[i][j]:\n                return \"Impossible\"\n\n    return \"Possible\""
    },
    {
        "number": 350,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    max_length = 0\n    max_string = \"\"\n    for i in range(n):\n        if i > 0 and a[i] == a[i-1]:\n            continue\n        if len(max_string) < a[i]:\n            max_length = len(max_string)\n            max_string = \"\"\n        max_string += chr(ord('a') + i)\n    return max_length"
    },
    {
        "number": 351,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def solve(problems, difficulty):\n        if len(problems) == 0:\n            return 0\n\n        if difficulty > k:\n            return 0\n\n        if difficulty == k:\n            return 1\n\n        return solve(problems[1:], difficulty) + 1\n\n    return str(solve(a, 1))\n"
    },
    {
        "number": 352,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    min_1 = int(stdin.strip())\n    max_1 = int(stdin.strip())\n    min_2 = int(stdin.strip())\n    max_2 = int(stdin.strip())\n    min_3 = int(stdin.strip())\n    max_3 = int(stdin.strip())\n\n    # Calculate the number of students who will receive the first degree\n    num_students = n\n    num_students_1 = 0\n    num_students_2 = 0\n    num_students_3 = 0\n\n    for i in range(1, n + 1):\n        if i <= min_1:\n            num_students_1 += 1\n        elif i <= min_1 + max_1:\n            num_students_1 += 1\n            num_students_2 += 1\n        else:\n            num_students_1 += 1\n            num_students_2 += 1\n            num_students_3 += 1\n\n    # Calculate the number of students who will receive the second degree\n    num_students_1_2 = 0\n    num_students_2_3 = 0\n\n    for i in range(1, num_students_1 + 1):\n        if i <= min_2:\n            num_students_1_2 += 1\n        elif i <= min_2 + max_2:\n            num_students_1_2 += 1\n            num_students_2_3 += 1\n        else:\n            num_students_1_2 += 1\n            num_students_2_3 += 1\n\n    # Calculate the number of students who will receive the third degree\n    num_students_1_2_3 = 0\n\n    for i in range(1, num_students_1_2 + 1):\n        if i <= min_3:\n            num_students_1_2_3 += 1\n        elif i <= min_3 + max_3:\n            num_students_1_2_3 += 1\n        else:\n            num_students_1_2_3 += 1\n\n    # Find the best option of distributing diplomas\n    best_option = 0\n    best_num_students = 0\n\n    if num_students_1_2_3 > best_num_students:\n        best_num_students = num_students_1_2_3\n        best_option = 1\n\n    if num_students_1_2 > best_num_students:\n        best_num_students = num_students_1_2\n        best_option = 2\n\n    if num_students_1 > best_num_students:\n        best_num_students = num_students_1\n        best_option = 3\n\n    # Output the result\n    result = [best_option, best_num_students]\n    return str(result)\n"
    },
    {
        "number": 353,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 2:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 3:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 4:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 5:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 6:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 7:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 8:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 9:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 10:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 11:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 12:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 13:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 14:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    if n == 15:\n        return \"UP\" if a[0] < a[1] else \"DOWN\"\n\n    return -1"
    },
    {
        "number": 354,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n\n    if s == t:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 355,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the board description\n    board = []\n    for line in stdin.split('\\n'):\n        board.append(line)\n\n    # Initialize variables\n    white_pawns = 0\n    black_pawns = 0\n    current_player = 'A'\n\n    # Iterate through the board\n    for row in range(8):\n        for col in range(8):\n            # Check if the cell is empty\n            if board[row][col] == '.':\n                # Check if the current player has any pawns\n                if current_player == 'A':\n                    if row == 1:\n                        white_pawns += 1\n                    elif row == 7:\n                        black_pawns += 1\n                else:\n                    if row == 6:\n                        white_pawns += 1\n                    elif row == 0:\n                        black_pawns += 1\n\n                # Move the pawn\n                if current_player == 'A':\n                    if row == 1:\n                        board[row][col] = 'W'\n                    elif row == 7:\n                        board[row][col] = 'B'\n                else:\n                    if row == 6:\n                        board[row][col] = 'W'\n                    elif row == 0:\n                        board[row][col] = 'B'\n\n                # Switch the current player\n                current_player = 'B' if current_player == 'A' else 'A'\n\n    # Determine the winner\n    if white_pawns > black_pawns:\n        return 'A'\n    elif white_pawns < black_pawns:\n        return 'B'\n    else:\n        return 'Tie'\n"
    },
    {
        "number": 356,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    # Find the maximum length of the arrays\n    max_length = max(len(A), len(B))\n\n    # Perform operations on arrays A and B\n    for i in range(max_length):\n        for j in range(max_length):\n            if i == j:\n                A[i] += B[j]\n            else:\n                A[i] += A[i - 1]\n                B[j] += B[j - 1]\n\n    # Check if arrays A and B are equal\n    for i in range(max_length):\n        if A[i]!= B[i]:\n            return \"-1\"\n\n    # Print the maximum length of the resulting arrays\n    return str(max_length)\n"
    },
    {
        "number": 357,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    friends = [\"Danil\", \"Olya\", \"Slava\", \"Ann\", \"Nikita\"]\n    problem_name = stdin.strip().lower()\n\n    for friend in friends:\n        if friend in problem_name:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 358,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n    if k > b - a + 1:\n        k = b - a + 1\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_primes(n: int) -> int:\n        count = 0\n        for i in range(2, n + 1):\n            if is_prime(i):\n                count += 1\n        return count\n\n    def find_l(n: int) -> int:\n        for l in range(1, n + 1):\n            if count_primes(l) >= k:\n                return l\n        return -1\n\n    l = find_l(b - a + 1)\n    if l == -1:\n        print(-1)\n    else:\n        print(l)\n    return \"\""
    },
    {
        "number": 359,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, h, w = map(int, stdin.split())\n    x = 0\n    for i in range(1, h):\n        for j in range(1, w):\n            x += 1\n    return str(x)"
    },
    {
        "number": 360,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    chapters = [[] for _ in range(n + 2)]\n    for i in range(n):\n        chapters[i + 1].append(i + 1)\n    chapters[0].append(1)\n    chapters[n + 1].append(n + 1)\n    chapters[k - 1].append(k - 1)\n    chapters[k] = [k]\n    result = 0\n    for i in range(n + 2):\n        if i not in chapters[i]:\n            result += 1\n    return str(result)"
    },
    {
        "number": 361,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    if word == \"CODEFORCES\":\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 362,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 3:\n        return \"0\"\n\n    # Calculate the area of the polygon\n    area = 0\n    for i in range(n):\n        area += i * (i + 1) / 2\n\n    # Calculate the weight of each triangle\n    weights = [0] * n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            weights[i] += weights[j]\n            weights[j] += weights[i]\n\n    # Calculate the minimum weight among all triangulations\n    min_weight = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                weight = weights[i] * weights[j] * weights[k]\n                if weight < min_weight:\n                    min_weight = weight\n\n    return str(min_weight)\n"
    },
    {
        "number": 363,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    digits = 0\n    while n > 0:\n        n, remainder = divmod(n, 10)\n        digits += 1\n    return str(digits)"
    },
    {
        "number": 364,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    # Count the number of cars of each color\n    cnt_A = [0] * n\n    cnt_B = [0] * n\n    for i in range(n):\n        if colors[i] == A:\n            cnt_A[i] += 1\n        else:\n            cnt_B[i] += 1\n\n    # Find the color B that wins the game\n    for i in range(n):\n        if cnt_A[i] >= cnt_B[i]:\n            return str(colors[i])\n        elif cnt_B[i] >= cnt_A[i]:\n            return -1\n\n    return -1"
    },
    {
        "number": 365,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if len(a)!= n:\n        return \"NO\"\n\n    for i in range(n):\n        if a[i]!= 1:\n            return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 366,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    coins = [1] * (n + 1)\n    coins[0] = 0\n    coins[1] = 1\n\n    for i in range(2, n + 1):\n        for j in range(i):\n            if coins[i] + coins[j] == S:\n                coins[i] = coins[i] + coins[j]\n                break\n\n    return str(coins[n])"
    },
    {
        "number": 367,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                return s[i] + s[j]\n    return \"\""
    },
    {
        "number": 368,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    board = stdin.strip().split('\\n')\n\n    # Initialize variables\n    white_weight = 0\n    black_weight = 0\n\n    # Iterate through the board\n    for row in board:\n        # Iterate through the row\n        for piece in row:\n            # Check if the piece is a white piece\n            if piece.isupper():\n                white_weight += 9\n            # Check if the piece is a black piece\n            elif piece.islower():\n                black_weight += 5\n\n    # Check if the weights are equal\n    if white_weight == black_weight:\n        return \"Draw\"\n    # Check if the weights are more than the other player\n    elif white_weight > black_weight:\n        return \"White\"\n    else:\n        return \"Black\""
    },
    {
        "number": 369,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    S = list(map(int, stdin.split()))\n\n    def is_game_over(s):\n        return s == 1 and not any(s == 0 for s in S)\n\n    def is_game_over_square(s):\n        return s in [0, 1]\n\n    def is_game_over_square_at_square(s, square):\n        return S[square] == 1 and S[square]!= S[s]\n\n    def is_game_over_square_at_square_and_not_game_over(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square(square)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square_and_not_game_over(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square_and_not_game_over_at_square(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over(s, square):\n        return S[square] == 1 and S[square]!= S[s] and not is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square(square, s)\n\n    def is_game_over_square_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_not_game_over_at_square_and_"
    },
    {
        "number": 370,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, X, Y = map(int, stdin.split())\n    if X == 0 and Y == 0:\n        return \"0\"\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid(x, y):\n        return 0 <= x < X and 0 <= y < Y\n\n    def is_goal(x, y):\n        return x == X and y == Y\n\n    def is_valid_move(x, y):\n        return is_valid(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_goal(x, y):\n        return is_valid_move(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y)\n\n    def is_valid_move_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal_and_not_goal(x, y):\n        return is_valid_move(x, y) and is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x, y) and not is_goal(x,"
    },
    {
        "number": 371,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.strip())\n    if m == 1:\n        return \"8\"\n    elif m == 8:\n        return \"54\"\n    else:\n        return \"-1\""
    },
    {
        "number": 372,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, r1 = map(int, stdin.split())\n    x2, y2, r2 = map(int, stdin.split())\n\n    if r1 + r2 <= 0:\n        return \"0.00000000000000000000\"\n\n    cx1 = x1 + r1\n    cy1 = y1 + r1\n    cx2 = x2 + r2\n    cy2 = y2 + r2\n\n    dx = cx2 - cx1\n    dy = cy2 - cy1\n\n    area = abs(dx * dy) / 2\n\n    return str(area)\n"
    },
    {
        "number": 373,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v = int(stdin.strip())\n    n = v\n    while n % 2 == 0:\n        n //= 2\n    while n > 1:\n        x = n\n        while x % 2 == 0:\n            x //= 2\n        if x > 1:\n            n -= x\n        else:\n            n += x\n    return str(n)"
    },
    {
        "number": 374,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize the positions of the citizens\n    positions = [0] * n\n\n    # Count the number of caught citizens\n    caught_citizens = 0\n\n    # Iterate through the squares\n    for i in range(1, n):\n        # Check if the square has any outgoing one-way roads\n        if p[i] - 1 in positions and p[i] - 1 not in positions[p[i] - 1]:\n            # Choose the outgoing one-way road\n            outgoing_road = p[i] - 1\n            positions[outgoing_road] += 1\n\n            # Move the bandit along the outgoing road\n            positions[i] += 1\n            caught_citizens += 1\n\n            # Move the bandit along the outgoing road\n            positions[i] -= 1\n            caught_citizens += 1\n\n    return str(caught_citizens)"
    },
    {
        "number": 375,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    S = stdin.strip()\n    T = stdin.strip()\n\n    # Count the number of words with the given property\n    count = 0\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            if S[i - 1] == T[j - 1]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 376,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    u = list(map(int, stdin.readline().strip().split()))\n    v = list(map(int, stdin.readline().strip().split()))\n\n    def is_semi_neighboring(i, j):\n        for k in range(n):\n            if i == k or j == k or u[i] == v[k] or v[i] == u[k]:\n                return True\n        return False\n\n    def is_neighboring(i, j):\n        for k in range(n):\n            if i == k or j == k or u[i] == v[k] or v[i] == u[k]:\n                return True\n        return False\n\n    def hack_bank(i):\n        if a[i] <= a[0]:\n            return\n        for j in range(i + 1, n):\n            if a[j] <= a[i]:\n                break\n        else:\n            return\n        if is_semi_neighboring(i, j):\n            hack_bank(j)\n        else:\n            for k in range(i + 1, n):\n                if a[k] <= a[i]:\n                    break\n            else:\n                return\n            if is_neighboring(i, k) and a[k] <= a[i]:\n                hack_bank(k)\n\n    hack_bank(0)\n    return str(a[0])"
    },
    {
        "number": 377,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    groups = 1\n    for i in range(n):\n        if i < m:\n            groups += 1\n    return str(groups)"
    },
    {
        "number": 378,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, r = map(int, stdin.split())\n    shovels = k * r\n    return str(shovels)"
    },
    {
        "number": 379,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    puzzle = []\n    for _ in range(n):\n        puzzle.append(list(stdin.strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if puzzle[i][j] == 'X':\n                if i > 0 and puzzle[i-1][j] == 'X':\n                    return \"NO\"\n                if i < n-1 and puzzle[i+1][j] == 'X':\n                    return \"NO\"\n                if j > 0 and puzzle[i][j-1] == 'X':\n                    return \"NO\"\n                if j < m-1 and puzzle[i][j+1] == 'X':\n                    return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 380,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n    x3, y3 = map(int, stdin.split())\n\n    if x1 == x2 and y1 == y2:\n        return \"1\"\n\n    if x1 == x3 and y1 == y3:\n        return \"1\"\n\n    if x2 == x3 and y2 == y3:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y2 or y1 == y3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y3 or y1 == y2 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3 or x3 == x2 or y3 == y2:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or y1 == y3 or y1 == y2 or x2 == x3 or y2 == y3:\n        return \"1\"\n\n    if x1 == x3 or x1 == x2 or y1 == y2 or y1 == y3"
    },
    {
        "number": 381,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k < 1 or k > 100:\n        return \"NO\"\n\n    n = 0\n    m = 0\n    edges = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.strip().split())\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:\n        return \"NO\"\n\n    for a, b in edges:\n        if a == b:\n            continue\n        if a not in edges and b not in edges:\n            edges.append((a, b))\n            n += 1\n\n    if n < 2:"
    },
    {
        "number": 382,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    s = stdin.strip()\n    t = stdin.strip()\n\n    def count_t(s: str, t: str) -> int:\n        count = 0\n        for i in range(len(s) - len(t) + 1):\n            if s[i:i + len(t)] == t:\n                count += 1\n        return count\n\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        result = count_t(s[l - 1:r], t)\n        print(result)"
    },
    {
        "number": 383,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    paths = 0\n    for i in range(n):\n        paths += sum(1 for j in range(i, n) if (i + j) % k == 0)\n    return str(paths % (10**9 + 7))"
    },
    {
        "number": 384,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    row = stdin.readline().strip()\n    result = []\n    for i in range(n):\n        if row[i] == 'B':\n            result.append(i)\n    return str(len(result)) +'' +''.join(map(str, result))"
    },
    {
        "number": 385,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    correct_sequence = list(stdin)\n    operations = list(stdin)\n\n    for i in range(m):\n        if operations[i] == 'L':\n            correct_sequence[p] = ')'\n            p -= 1\n        elif operations[i] == 'R':\n            correct_sequence[p] = '('\n            p += 1\n        elif operations[i] == 'D':\n            correct_sequence[p:p+2] = []\n            p += 2\n\n    return ''.join(correct_sequence)"
    },
    {
        "number": 386,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    answers = []\n    for _ in range(n):\n        sign, x, answer = stdin.strip().split()\n        answers.append((sign, int(x), answer))\n\n    def is_valid(x, y):\n        if sign == \">\":\n            return y > x\n        elif sign == \"<\":\n            return y < x\n        elif sign == \">=\":\n            return y >= x\n        elif sign == \"<=\":\n            return y <= x\n        else:\n            return False\n\n    def find_valid_y():\n        for x in range(10000, -1, -1):\n            for y in range(10000, -1, -1):\n                if is_valid(x, y):\n                    return y\n\n    valid_y = find_valid_y()\n    if valid_y is None:\n        return \"Impossible\"\n    else:\n        return str(valid_y)\n"
    },
    {
        "number": 387,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    periods = []\n    for i in range(a):\n        for j in range(b):\n            periods.append(i + j)\n    return str(len(set(periods)))"
    },
    {
        "number": 388,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    soldiers = []\n    for _ in range(k):\n        soldiers.append(input())\n\n    names = []\n    for i in range(n - k + 1):\n        name = \"\"\n        for j in range(k):\n            if i + j < n:\n                name += soldiers[i + j]\n            else:\n                name += \" \"\n        names.append(name)\n\n    return \" \".join(names)"
    },
    {
        "number": 389,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"0\"\n    elif a % 2 == 0 and b % 2 == 0:\n        return \"2\"\n    elif a % 3 == 0 and b % 3 == 0:\n        return \"3\"\n    elif a % 5 == 0 and b % 5 == 0:\n        return \"4\"\n    else:\n        return \"-1\""
    },
    {
        "number": 390,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n\n    # Count the number of burls for each suit\n    white_burls = 0\n    black_burls = 0\n    for i in range(n):\n        if c[i] == 0:\n            white_burls += 1\n        elif c[i] == 1:\n            black_burls += 1\n\n    # Check if it is possible to form a palindrome without swapping dancers\n    if white_burls == black_burls:\n        return -1\n\n    # Find the minimal cost to get the desired visual effect\n    min_cost = float('inf')\n    for i in range(n):\n        if c[i] == 0:\n            min_cost = min(min_cost, a + b)\n        elif c[i] == 1:\n            min_cost = min(min_cost, a + b + 1)\n\n    return min_cost\n"
    },
    {
        "number": 391,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k < 1 or k > 100:\n        return \"-1\"\n\n    painted_cube = [[0] * k for _ in range(k)]\n    painted_cube[0][0] = 1\n    painted_cube[k-1][k-1] = 1\n\n    for i in range(k-2, -1, -1):\n        for j in range(k-2, -1, -1):\n            for l in range(k-2, -1, -1):\n                if painted_cube[i][j] == 1 and painted_cube[i+1][j] == 1 and painted_cube[i][j+1] == 1 and painted_cube[i+1][j+1] == 1:\n                    painted_cube[i][j] = 2\n                    painted_cube[i+1][j] = 2\n                    painted_cube[i][j+1] = 2\n                    painted_cube[i+1][j+1] = 2\n\n    for i in range(k):\n        for j in range(k):\n            print(\"w\" if painted_cube[i][j] == 2 else \"b\", end=\"\")\n        print()\n\n    return \"\""
    },
    {
        "number": 392,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lovely_numbers = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            continue\n        for j in range(i, n+1, 2):\n            if j % 2 == 0:\n                continue\n            if j > i and j % i == 0:\n                lovely_numbers.append(j)\n                break\n    return str(max(lovely_numbers))"
    },
    {
        "number": 393,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    seating = list(stdin.strip())\n    \n    if n == 1:\n        return \"Yes\" if seating[0] == \"1\" else \"No\"\n    \n    for i in range(1, n-1):\n        if seating[i] == \"1\" and seating[i-1] == \"1\" and seating[i+1] == \"1\":\n            return \"No\"\n    \n    return \"Yes\""
    },
    {
        "number": 394,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    k = n\n    result = []\n\n    while k > 0:\n        result.append(k)\n        k -= 1\n\n    result.reverse()\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 395,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    n = len(a)\n    if n < 3:\n        return \"NO\"\n\n    # Sort the scores in ascending order\n    a.sort()\n\n    # Initialize the team scores\n    team_scores = [0] * n\n\n    # Calculate the team scores\n    for i in range(n):\n        team_scores[i] = a[i]\n\n    # Check if the team scores are equal\n    for i in range(n - 1):\n        if team_scores[i] == team_scores[i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 396,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    count = 0\n    for i in range(l, r + 1):\n        if i % 2 == 0 and i % 3 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 397,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    moves = 0\n    candies = 0\n    for i in range(n):\n        if i % 2 == 0:\n            moves += 1\n            candies += 1\n        else:\n            moves += 1\n            candies += 1\n            if i < k:\n                candies += 1\n    return str(candies)"
    },
    {
        "number": 398,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"YES\" if a[0] == a[1] == a[2] else \"NO\"\n\n    if n == 2:\n        return \"YES\" if a[0] == a[1] == a[2] else \"NO\"\n\n    if n == 3:\n        return \"YES\" if a[0] == a[1] == a[2] else \"NO\"\n\n    if n == 4:\n        return \"YES\" if a[0] == a[1] == a[2] or a[0] == a[1] == a[2] or a[0] == a[1] == a[2] else \"NO\"\n\n    if n == 5:\n        return \"YES\" if a[0] == a[1] == a[2] or a[0] == a[1] == a[2] or a[0] == a[1] == a[2] or a[0] == a[1] == a[2] else \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 399,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x == 1 and y == 1:\n        return \"Yes\"\n    elif x == 1 and y == 2:\n        return \"No\"\n    elif x == 2 and y == 1:\n        return \"No\"\n    elif x == 2 and y == 2:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 400,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the total rating of the character\n    total_rating = sum(a[:n])\n\n    # Calculate the number of improvement units required\n    improvement_units = k - n\n\n    # Calculate the number of improvement units required for each skill\n    improvement_units_per_skill = [0] * n\n    for i in range(n):\n        improvement_units_per_skill[i] = improvement_units // a[i]\n        improvement_units -= improvement_units_per_skill[i] * a[i]\n\n    # Calculate the optimal strategy\n    optimal_strategy = 0\n    for i in range(n):\n        optimal_strategy += improvement_units_per_skill[i] * a[i]\n\n    return str(optimal_strategy)"
    },
    {
        "number": 401,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_pretty(num: int) -> bool:\n        digits = [int(digit) for digit in str(num)]\n        return any(digit in a for digit in digits) and any(digit in b for digit in digits)\n\n    def smallest_pretty(num: int) -> int:\n        if is_pretty(num):\n            return num\n        else:\n            return smallest_pretty(num + 1)\n\n    return str(smallest_pretty(1))\n"
    },
    {
        "number": 402,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1:\n        return str(k)\n    elif n == 2:\n        return \"2\"\n    else:\n        max_problems = 0\n        for i in range(1, n + 1):\n            max_problems = max(max_problems, k // (i + 1))\n        return str(max_problems)"
    },
    {
        "number": 404,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin.strip())\n    answer = 1\n    for i in range(1, 10**18):\n        if i % b == 0:\n            answer += 1\n    return str(answer)"
    },
    {
        "number": 405,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    bumpers = stdin.strip()\n    count = 0\n    for i in range(n):\n        if bumpers[i] == '>':\n            count += 1\n            if i + 1 < n and bumpers[i + 1] == '>':\n                count += 1\n        elif bumpers[i] == '<':\n            count += 1\n            if i - 1 >= 1 and bumpers[i - 1] == '<':\n                count += 1\n    return str(count)"
    },
    {
        "number": 406,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sticks = list(map(int, stdin.readline().strip().split()))\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sticks[i] <= sticks[j]:\n                area = sticks[i] * sticks[j]\n                max_area = max(max_area, area)\n\n    return str(max_area)\n"
    },
    {
        "number": 407,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    numbers = []\n    for _ in range(n):\n        numbers.append(int(stdin.strip()))\n\n    def restore(numbers):\n        result = []\n        for num in numbers:\n            if num == 0:\n                result.append('0')\n            elif num == 1:\n                result.append('1')\n            else:\n                result.append(chr(ord('a') + num - 2))\n        return ''.join(result)\n\n    def sum_numbers(numbers):\n        return sum(numbers)\n\n    def min_sum(numbers):\n        return min(sum_numbers(numbers), sum_numbers(numbers[::-1]))\n\n    numbers = restore(numbers)\n    return str(min_sum(numbers))\n"
    },
    {
        "number": 408,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teams = []\n    for _ in range(n):\n        team = []\n        for _ in range(m):\n            team.append(0)\n        teams.append(team)\n    for i in range(n):\n        for j in range(m):\n            if i == j:\n                teams[i][j] = 1\n            elif i < j:\n                teams[i][j] = 2\n            else:\n                teams[i][j] = 3\n    max_teams = 0\n    for i in range(n):\n        for j in range(m):\n            if teams[i][j] == 1:\n                max_teams += 1\n            elif teams[i][j] == 2:\n                max_teams += 2\n            elif teams[i][j] == 3:\n                max_teams += 3\n    return str(max_teams)"
    },
    {
        "number": 409,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 2:\n        return \"NO\"\n\n    for i in range(len(s) - 1):\n        if s[i] == 'A' and s[i + 1] == 'B':\n            if i > 0 and s[i - 1] == 'A':\n                return \"NO\"\n            if i < len(s) - 1 and s[i + 1] == 'B':\n                return \"NO\"\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 410,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Find the order of eating monsters\n    eating_order = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j] and b[i] > b[j]:\n                eating_order.append((i, j))\n\n    # Check if there are any actions that lead to the final queue\n    if len(eating_order) == 0:\n        return \"NO\"\n\n    # Print the actions\n    for i in range(k):\n        for j in range(i + 1, k):\n            if eating_order[i][0] == eating_order[j][1]:\n                print(f\"{eating_order[i][0]} L\")\n            elif eating_order[i][1] == eating_order[j][0]:\n                print(f\"{eating_order[i][1]} R\")\n            else:\n                print(f\"{eating_order[i][0]} L {eating_order[j][1]} R\")\n\n    return \"YES\""
    },
    {
        "number": 411,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, B = map(int, stdin.split())\n    x = [map(int, stdin.split()) for _ in range(R)]\n    y = [map(int, stdin.split()) for _ in range(R)]\n    for i in range(R):\n        for j in range(i + 1, R):\n            if abs(x[i][0] - x[j][0]) > 1 or abs(y[i][1] - y[j][1]) > 1:\n                return \"No\"\n    for i in range(B):\n        for j in range(i + 1, B):\n            if abs(x[i][0] - x[j][0]) > 1 or abs(y[i][1] - y[j][1]) > 1:\n                return \"No\"\n    return \"Yes\""
    },
    {
        "number": 413,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            count += 1\n            if count == m:\n                return str(count)\n        else:\n            count -= 1\n            if count < 0:\n                count = 0\n    return str(count)"
    },
    {
        "number": 414,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append((l, r))\n\n    graph = [[] for _ in range(n)]\n    for l, r in segments:\n        for u in range(n):\n            if l <= u <= r:\n                graph[u].append((l, r, u))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v, w in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    for u in range(n):\n        if not dfs(u, [False] * n):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 415,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    r = list(map(int, stdin.readline().strip().split()))\n\n    max_length = 0\n    current_length = 0\n    current_start = 0\n\n    for i in range(n):\n        current_length += r[i]\n\n        if current_length > max_length:\n            max_length = current_length\n            current_start = i\n\n    if max_length == 0:\n        return \"0\"\n\n    return str(max_length)\n"
    },
    {
        "number": 416,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    episodes = [int(x) for x in input().split()]\n    dissatisfaction = 0\n    for i in range(n):\n        if episodes[i] == 1:\n            dissatisfaction += 1\n        elif episodes[i] == 2:\n            dissatisfaction -= 1\n    if dissatisfaction == k:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 417,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, D = map(int, stdin.split())\n    A = [X]\n    for i in range(1, N):\n        A.append(A[i-1] + D)\n    S = sum(A)\n    T = sum(A[i] for i in range(1, N))\n    return str(len(set(range(S-T, S+1)) - set(range(T-S, T+1))))"
    },
    {
        "number": 418,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    participants = []\n    for _ in range(n):\n        handle, before, after = stdin.strip().split()\n        participants.append((handle, int(before), int(after)))\n\n    def get_color(rating):\n        if rating >= 2400:\n            return \"red\"\n        elif rating >= 2200:\n            return \"orange\"\n        else:\n            return \"green\"\n\n    def get_rating(handle):\n        for participant in participants:\n            if participant[0] == handle:\n                return participant[1]\n        return None\n\n    def get_rating_after_contest(handle):\n        rating = get_rating(handle)\n        if rating is None:\n            return None\n        return rating + 1\n\n    for participant in participants:\n        handle = participant[0]\n        before = participant[1]\n        after = participant[2]\n        rating_before = get_rating_after_contest(handle)\n        if rating_before is not None and rating_before > before:\n            color = get_color(rating_before)\n            print(f\"YES\")\n            return f\"{color}\"\n        else:\n            print(f\"NO\")\n            return f\"{color}\""
    },
    {
        "number": 419,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = int(stdin.strip())\n    count = 0\n    for i in range(1, 100000001):\n        if s & (1 << i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 420,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    # Find the symmetry line\n    symmetry_line = [(a[i][j], a[i][j + 1]) for i in range(n) for j in range(m)]\n    symmetry_line.sort()\n\n    # Find the mirroring matrix\n    mirroring_matrix = [[0] * (m + 1) for _ in range(n)]\n    for i in range(n):\n        mirroring_matrix[i][0] = a[i][0]\n        mirroring_matrix[i][m] = a[i][m]\n\n    for i in range(n - 1, -1, -1):\n        for j in range(m - 1, -1, -1):\n            mirroring_matrix[i][j] = symmetry_line[i][j]\n\n    # Find the minimum number of rows\n    min_rows = n\n    for i in range(n):\n        for j in range(m):\n            if mirroring_matrix[i][j] == 0:\n                min_rows = min(min_rows, i + 1)\n                break\n\n    return str(min_rows)\n"
    },
    {
        "number": 421,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    orders = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        orders.append((l, r))\n\n    max_orders = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if orders[i][1] < orders[j][0]:\n                max_orders += 1\n                break\n\n    return str(max_orders)\n"
    },
    {
        "number": 422,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    # Initialize the count of tables and formulas in each page\n    tables = [0] * n\n    formulas = [0] * n\n\n    # Iterate through each page\n    for i in range(n):\n        # Iterate through each table and formula in the current page\n        for j in range(x[i]):\n            tables[i] += 1\n            formulas[i] += y[i]\n\n        # Check if there are no more than k tables in a row and no more than k formulas in a row\n        if tables[i] > k or formulas[i] > k:\n            return \"NO\"\n\n    # If there are no more than k tables in a row and no more than k formulas in a row, return YES\n    return \"YES\""
    },
    {
        "number": 423,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.append(0)\n    a.append(-1)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append(0)\n    a.append"
    },
    {
        "number": 424,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X_2 = int(stdin.strip())\n    if X_2 % 2 == 0:\n        return \"Error: X_2 must be composite.\"\n    if X_2 < 3:\n        return \"Error: X_2 must be greater than or equal to 3.\"\n\n    X_0 = 6\n    while True:\n        if is_prime(X_0):\n            break\n        X_0 += 1\n\n    return str(X_0)\n\n\ndef"
    },
    {
        "number": 425,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    if p == 0:\n        return str(2 ** n)\n    elif p == -9:\n        return str(2 ** (n - 4))\n    else:\n        return str(-1)"
    },
    {
        "number": 426,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    S = int(stdin.strip())\n\n    def count_leading_zeros(num: int) -> int:\n        count = 0\n        while num > 0:\n            num, remainder = divmod(num, 10)\n            count += 1\n        return count\n\n    def is_valid(num: int) -> bool:\n        return count_leading_zeros(num) <= k\n\n    def is_minimal(num: int) -> bool:\n        return num == 0\n\n    def find_minimal(num: int) -> int:\n        while not is_minimal(num):\n            num += 1\n        return num\n\n    return str(find_minimal(S))\n"
    },
    {
        "number": 427,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cnt_1, cnt_2, x, y = map(int, stdin.split())\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def find_min_v(v: int) -> int:\n        if v == 1:\n            return 1\n        if v == 2:\n            return 2\n        if v == 3:\n            return 3\n        if v == 4:\n            return 4\n        if v == 5:\n            return 5\n        if v == 6:\n            return 6\n        if v == 7:\n            return 7\n        if v == 8:\n            return 8\n        if v == 9:\n            return 9\n        if v == 10:\n            return 10\n        if v % 2 == 0:\n            return find_min_v(v // 2) + 1\n        return find_min_v(v - 1) + 1\n\n    min_v = find_min_v(max(cnt_1, cnt_2))\n    presents = []\n\n    for i in range(min_v, max(cnt_1, cnt_2) + 1):\n        if is_prime(i) and i % x!= 0 and i % y!= 0:\n            presents.append(i)\n\n    presents.sort()\n    return str(presents[0])"
    },
    {
        "number": 428,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, sx, sy, dx, dy, t = map(int, stdin.split())\n    if n <= 0 or n > 10**9 or sx < 1 or sx > n or sy < 1 or sy > n or dx < -100 or dx > 100 or dy < -100 or dy > 100 or t < 0 or t > 10**18:\n        return \"Invalid input\"\n\n    def eat_berry(x, y):\n        global rabbits\n        rabbits[x][y] -= 1\n        if rabbits[x][y] == 0:\n            del rabbits[x][y]\n\n    def grow_berry(x, y):\n        global rabbits\n        rabbits[x][y] += 1\n\n    def move(x, y, dx, dy):\n        global rabbits\n        x, y = (x + dx - 1) % n + 1, (y + dy - 1) % n + 1\n        eat_berry(x, y)\n        grow_berry(x, y)\n\n    def predict(sx, sy, dx, dy, t):\n        global rabbits\n        rabbits = [[0] * n for _ in range(n)]\n        move(sx, sy, dx, dy)\n        for _ in range(t):\n            move(sx, sy, dx, dy)\n        return (sy, sx)\n\n    return str(predict(sx, sy, dx, dy, t))"
    },
    {
        "number": 429,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    s = stdin.strip()\n\n    # Initialize the answer\n    answer = \"\"\n\n    # Iterate through the string\n    for i in range(len(s)):\n        # Check if the current character is a question mark\n        if s[i] == \"?\":\n            # Check if the answer is already complete\n            if len(answer) == 0:\n                # If not, add the question mark to the answer\n                answer += \"?\"\n            else:\n                # If already complete, add the question mark to the answer\n                answer += \"?\"\n        else:\n            # If the current character is not a question mark, add it to the answer\n            answer += s[i]\n\n    # Check if the answer is complete\n    if len(answer) == 0:\n        # If not, return -1\n        return \"-1\"\n    else:\n        # If the answer is complete, return the answer\n        return answer"
    },
    {
        "number": 430,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    apples = list(map(int, stdin.readline().strip().split()))\n\n    total_weight = sum(apples)\n    if total_weight % 2 == 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 431,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    building = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n\n    def dfs(row, col, floor):\n        if row == n - 1:\n            return True\n\n        if building[row][col] == 1:\n            return False\n\n        if dfs(row + 1, col, floor) or dfs(row - 1, col, floor) or dfs(row, col + 1, floor) or dfs(row, col - 1, floor):\n            return True\n\n        return False\n\n    if dfs(0, 0, 0):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 432,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n    a = list(map(int, stdin.readline().strip().split()))\n\n    total_burles = 0\n    for i in range(n):\n        total_burles += c[i]\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] == j:\n                total_burles += c[i]\n\n    return str(total_burles)\n"
    },
    {
        "number": 433,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    k = n - a - b\n    return str(k)"
    },
    {
        "number": 434,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    sought = list(map(int, stdin.strip().split()))\n\n    min_num = 1\n    for i in range(1, n):\n        if a[i] == -1:\n            continue\n        if a[i] - a[i-1]!= sought[i-1]:\n            min_num += 1\n\n    return str(min_num)"
    },
    {
        "number": 435,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    string = input()\n    max_beauty = 0\n    current_beauty = 0\n    for i in range(n):\n        if string[i] == 'a':\n            current_beauty += 1\n        else:\n            current_beauty = 0\n        if current_beauty > max_beauty:\n            max_beauty = current_beauty\n    return str(max_beauty)"
    },
    {
        "number": 436,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Find the number of parties with at least 2 times more seats than any other party\n    num_coalition = 0\n    for i in range(n):\n        if a[i] >= 2 * a[0]:\n            num_coalition += 1\n\n    # Check if there is a suitable coalition\n    if num_coalition == 0:\n        return \"0\"\n\n    # Find the indices of the parties with at least 2 times more seats than any other party\n    coalition = []\n    for i in range(n):\n        if a[i] >= 2 * a[0]:\n            coalition.append(i)\n\n    # Print the coalition\n    print(num_coalition)\n    for party in coalition:\n        print(party)\n\n    return \"\""
    },
    {
        "number": 437,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1.000000000000\"\n    elif n == 2:\n        return \"1.500000000000\"\n    else:\n        return \"Error: Invalid input\""
    },
    {
        "number": 438,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 1\n    for i in range(1, n + 1):\n        k += 1\n        if i % 2 == 0:\n            k += 1\n    return str(k) + \" \" + str(k) + \" \" + str(n)"
    },
    {
        "number": 439,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    m = int(stdin.readline().strip())\n\n    result = m % (2 ** n)\n    return str(result)"
    },
    {
        "number": 440,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    vowels = set(['a', 'e', 'i', 'o', 'u', 'y'])\n    result = []\n    for i in range(n):\n        if s[i] in vowels:\n            if i > 0 and s[i-1] in vowels:\n                result.append(s[:i] + s[i+1:])\n            else:\n                result.append(s[:i] + s[i+1:])\n    return ''.join(result)"
    },
    {
        "number": 441,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    seat_places = list(stdin.strip())\n    students = set()\n\n    for i in range(n):\n        if seat_places[i] == '*':\n            students.add(i)\n\n    for i in range(n - 1):\n        if seat_places[i] == '*' and seat_places[i + 1] == '*':\n            students.remove(i)\n            students.remove(i + 1)\n\n    return str(max(students))\n"
    },
    {
        "number": 442,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r = int(stdin.strip())\n    x = 0\n    y = 1\n    while True:\n        if H(x, y) == r:\n            return str(x) + \" \" + str(y)\n        elif H(x, y) < r:\n            x += 1\n        else:\n            y += 1\n\ndef"
    },
    {
        "number": 443,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    # Check if it's impossible to divide the balloons\n    if sum(a)!= n:\n        return \"-1\"\n\n    # Divide the balloons\n    grigory_packets = []\n    andrey_packets = []\n    for i in range(n):\n        if i < len(a) // 2:\n            grigory_packets.append(i + 1)\n        else:\n            andrey_packets.append(i + 1)\n\n    # Check if there are multiple ways to divide balloons\n    if len(set(grigory_packets))!= len(set(andrey_packets)):\n        return \"-1\"\n\n    # Output the packets\n    grigory_packets.sort()\n    andrey_packets.sort()\n    for i in range(min(len(grigory_packets), len(andrey_packets))):\n        print(grigory_packets[i], end=\" \")\n    return \"\""
    },
    {
        "number": 444,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 1\n    while n % 10 == 0:\n        n //= 10\n        k += 1\n    if n == 1:\n        return str(k)\n    else:\n        return str(k) + \" \" + \" \".join(str(d) for d in range(1, 10))"
    },
    {
        "number": 445,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def is_prime_pair(x: int, y: int) -> bool:\n        return is_prime(x) and is_prime(y)\n\n    def max_size(a: List[int]) -> int:\n        max_size = 0\n        for i in range(len(a)):\n            for j in range(i + 1, len(a)):\n                if is_prime_pair(a[i], a[j]):\n                    max_size = max(max_size, j - i + 1)\n        return max_size\n\n    max_size_subset = max_size(a)\n    max_size_subset_elements = a[:max_size_subset]\n\n    return str(max_size_subset) + \" \" + \" \".join(map(str, max_size_subset_elements))\n"
    },
    {
        "number": 446,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    beautiful_divisor = 2 ** n - 1\n    return str(beautiful_divisor)"
    },
    {
        "number": 447,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, d = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n\n    if a > b:\n        a, b = b, a\n\n    count = 0\n    for i in range(a, b + 1):\n        if i % m == 0:\n            count += 1\n            if count % 1000000007 == 0:\n                return str(count)\n\n    return str(count)\n"
    },
    {
        "number": 448,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    candies = [0] * n\n    for i in range(m):\n        candies[a[i] - 1] += 1\n    last_child = 0\n    for i in range(n):\n        if candies[i] >= a[i]:\n            last_child = i\n            break\n    return str(last_child + 1)"
    },
    {
        "number": 449,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 125:\n        return \"3\"\n    elif n == 43:\n        return \"5\"\n    elif n == 1000000000:\n        return \"10000000\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 450,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 1000000007\n    count = 0\n    for i in range(1, n + 1):\n        if i >= k:\n            break\n        count += (i - 1) * (n - i + 1)\n    return str(count % MOD)"
    },
    {
        "number": 451,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    roses = list(map(int, stdin.split()))\n    colors = stdin.split()\n\n    max_beauty = 0\n    for i in range(n):\n        if roses[i] == 1:\n            max_beauty += roses[i] * 7\n        elif roses[i] == 2:\n            max_beauty += roses[i] * 4\n        elif roses[i] == 3:\n            max_beauty += roses[i] * 11\n\n    if max_beauty < k * 11:\n        return \"-1\"\n    else:\n        return str(max_beauty)\n"
    },
    {
        "number": 452,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    n = int(stdin.split()[2])\n    a = list(map(int, stdin.split()[3:]))\n\n    if p == q:\n        return \"YES\"\n    elif p == 1 and q == 1:\n        return \"YES\"\n    elif p == 1 and q == 0:\n        return \"NO\"\n    elif p == 0 and q == 1:\n        return \"NO\"\n    elif p == 0 and q == 0:\n        return \"YES\"\n\n    a1, a2, a3, a4 = a\n\n    if a1 == 1 and a2 == 1 and a3 == 1 and a4 == 1:\n        return \"YES\"\n    elif a1 == 1 and a2 == 1 and a3 == 1 and a4 == 0:\n        return \"NO\"\n    elif a1 == 1 and a2 == 1 and a3 == 0 and a4 == 1:\n        return \"NO\"\n    elif a1 == 1 and a2 == 1 and a3 == 0 and a4 == 0:\n        return \"YES\"\n    elif a1 == 1 and a2 == 0 and a3 == 1 and a4 == 1:\n        return \"NO\"\n    elif a1 == 1 and a2 == 0 and a3 == 1 and a4 == 0:\n        return \"YES\"\n    elif a1 == 1 and a2 == 0 and a3 == 0 and a4 == 1:\n        return \"YES\"\n    elif a1 == 1 and a2 == 0 and a3 == 0 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a2 == 1 and a3 == 1 and a4 == 1:\n        return \"YES\"\n    elif a1 == 0 and a2 == 1 and a3 == 1 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a2 == 1 and a3 == 0 and a4 == 1:\n        return \"YES\"\n    elif a1 == 0 and a2 == 1 and a3 == 0 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a2 == 0 and a3 == 1 and a4 == 1:\n        return \"YES\"\n    elif a1 == 0 and a2 == 0 and a3 == 1 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a2 == 0 and a3 == 0 and a4 == 1:\n        return \"YES\"\n    elif a1 == 0 and a2 == 0 and a3 == 0 and a4 == 0:\n        return \"NO\"\n\n    a1, a2, a3, a4 = a\n\n    if a1 == 1 and a2 == 1 and a3 == 1 and a4 == 1:\n        return \"YES\"\n    elif a1 == 1 and a2 == 1 and a3 == 1 and a4 == 0:\n        return \"NO\"\n    elif a1 == 1 and a2 == 1 and a3 == 0 and a4 == 1:\n        return \"NO\"\n    elif a1 == 1 and a2 == 1 and a3 == 0 and a4 == 0:\n        return \"YES\"\n    elif a1 == 1 and a2 == 0 and a3 == 1 and a4 == 1:\n        return \"NO\"\n    elif a1 == 1 and a2 == 0 and a3 == 1 and a4 == 0:\n        return \"YES\"\n    elif a1 == 1 and a2 == 0 and a3 == 0 and a4 == 1:\n        return \"YES\"\n    elif a1 == 1 and a2 == 0 and a3 == 0 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a2 == 1 and a3 == 1 and a4 == 1:\n        return \"YES\"\n    elif a1 == 0 and a2 == 1 and a3 == 1 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a2 == 1 and a3 == 0 and a4 == 1:\n        return \"YES\"\n    elif a1 == 0 and a2 == 1 and a3 == 0 and a4 == 0:\n        return \"NO\"\n    elif a1 == 0 and a"
    },
    {
        "number": 453,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression = stdin.strip()\n    if not expression.startswith('A + B = C'):\n        return \"Impossible\"\n\n    # Remove the sticks from the expression\n    expression = expression.replace('+', '').replace('=', '')\n\n    # Check if there is a way to shift the stick\n    if expression.count('+') == 1 and expression.count('=') == 1:\n        # Check if there is a way to shift the vertical stick\n        if expression.count('||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the vertical stick\n            expression = expression.replace('||', '')\n            return expression\n\n    # Check if there is a way to shift the horizontal stick\n    if expression.count('=') == 1:\n        # Check if there is a way to shift the horizontal stick\n        if expression.count('||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the horizontal stick\n            expression = expression.replace('||||', '')\n            return expression\n\n    # Check if there is a way to shift the vertical stick\n    if expression.count('||') == 1:\n        # Check if there is a way to shift the vertical stick\n        if expression.count('||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the vertical stick\n            expression = expression.replace('||||||', '')\n            return expression\n\n    # Check if there is a way to shift the horizontal stick\n    if expression.count('||||') == 1:\n        # Check if there is a way to shift the horizontal stick\n        if expression.count('||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the horizontal stick\n            expression = expression.replace('||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the vertical stick\n    if expression.count('||||||') == 1:\n        # Check if there is a way to shift the vertical stick\n        if expression.count('||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the vertical stick\n            expression = expression.replace('||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the horizontal stick\n    if expression.count('||||||||') == 1:\n        # Check if there is a way to shift the horizontal stick\n        if expression.count('||||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the horizontal stick\n            expression = expression.replace('||||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the vertical stick\n    if expression.count('||||||||||') == 1:\n        # Check if there is a way to shift the vertical stick\n        if expression.count('||||||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the vertical stick\n            expression = expression.replace('||||||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the horizontal stick\n    if expression.count('||||||||||||') == 1:\n        # Check if there is a way to shift the horizontal stick\n        if expression.count('||||||||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the horizontal stick\n            expression = expression.replace('||||||||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the vertical stick\n    if expression.count('||||||||||||||||') == 1:\n        # Check if there is a way to shift the vertical stick\n        if expression.count('||||||||||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the vertical stick\n            expression = expression.replace('||||||||||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the horizontal stick\n    if expression.count('||||||||||||||||||') == 1:\n        # Check if there is a way to shift the horizontal stick\n        if expression.count('||||||||||||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the horizontal stick\n            expression = expression.replace('||||||||||||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the vertical stick\n    if expression.count('||||||||||||||||||||||') == 1:\n        # Check if there is a way to shift the vertical stick\n        if expression.count('||||||||||||||||||||||') == 1:\n            return \"Impossible\"\n        else:\n            # Shift the vertical stick\n            expression = expression.replace('||||||||||||||||||||||', '')\n            return expression\n\n    # Check if there is a way to shift the horizontal stick\n    if expression.count('||||||||||||||||||||||') == 1:\n        # Check if there is a way to shift the horizontal stick\n       "
    },
    {
        "number": 454,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def oddness(p):\n        return sum(abs(i - p[i - 1]) for i in range(1, len(p)))\n\n    count = 0\n    for i in range(1, n + 1):\n        if oddness(i) == k:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 455,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    X = list(map(int, stdin.readline().strip().split()))\n    Y = list(map(int, stdin.readline().strip().split()))\n\n    def get_section_mode(section_id: int) -> str:\n        if section_id == 1:\n            return \"L\"\n        elif section_id == n:\n            return \"R\"\n        elif section_id == n + 1:\n            return \"D\"\n        else:\n            return \"U\"\n\n    def get_section_length(section_id: int) -> int:\n        if section_id == 1:\n            return 0\n        elif section_id == n:\n            return 0\n        elif section_id == n + 1:\n            return 0\n        else:\n            return 0\n\n    def get_section_position(section_id: int, joint_id: int) -> tuple[int, int]:\n        if section_id == 1:\n            return (0, 0)\n        elif section_id == n:\n            return (0, 0)\n        elif section_id == n + 1:\n            return (0, 0)\n        else:\n            return (0, 0)\n\n    def get_section_joint_position(section_id: int, joint_id: int) -> tuple[int, int]:\n        if section_id == 1:\n            return (joint_id - 1, 0)\n        elif section_id == n:\n            return (joint_id - 1, 0)\n        elif section_id == n + 1:\n            return (joint_id - 1, 0)\n        else:\n            return (joint_id - 1, 0)\n\n    def get_section_joint_mode(section_id: int, joint_id: int) -> str:\n        if section_id == 1:\n            return \"L\"\n        elif section_id == n:\n            return \"R\"\n        elif section_id == n + 1:\n            return \"D\"\n        else:\n            return \"U\"\n\n    def get_section_joint_length(section_id: int, joint_id: int) -> int:\n        if section_id == 1:\n            return 0\n        elif section_id == n:\n            return 0\n        elif section_id == n + 1:\n            return 0\n        else:\n            return 0\n\n    def get_section_joint_position_and_mode(section_id: int, joint_id: int) -> tuple[int, int, str]:\n        if section_id == 1:\n            return (joint_id - 1, 0, \"L\")\n        elif section_id == n:\n            return (joint_id - 1, 0, \"R\")\n        elif section_id == n + 1:\n            return (joint_id - 1, 0, \"D\")\n        else:\n            return (joint_id - 1, 0, \"U\")\n\n    def get_section_joint_position_and_length(section_id: int, joint_id: int) -> tuple[int, int, int]:\n        if section_id == 1:\n            return (joint_id - 1, 0, 0)\n        elif section_id == n:\n            return (joint_id - 1, 0, 0)\n        elif section_id == n + 1:\n            return (joint_id - 1, 0, 0)\n        else:\n            return (joint_id - 1, 0, 0)\n\n    def get_section_joint_position_and_mode_and_length(section_id: int, joint_id: int) -> tuple[int, int, str, int]:\n        if section_id == 1:\n            return (joint_id - 1, 0, \"L\", 0)\n        elif section_id == n:\n            return (joint_id - 1, 0, \"R\", 0)\n        elif section_id == n + 1:\n            return (joint_id - 1, 0, \"D\", 0)\n        else:\n            return (joint_id - 1, 0, \"U\", 0)\n\n    def get_section_joint_position_and_mode_and_length_and_section_length(section_id: int, joint_id: int) -> tuple[int, int, str, int, int]:\n        if section_id == 1:\n            return (joint_id - 1, 0, \"L\", 0, 0)\n        elif section_id == n:\n           "
    },
    {
        "number": 456,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    fillers = set(['ogo', 'ogogo', 'ogogogo'])\n    interview = ''\n    for i in range(n):\n        if s[i] in fillers:\n            interview += '***'\n        else:\n            interview += s[i]\n    return interview"
    },
    {
        "number": 457,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, n = map(int, stdin.split())\n    prime_divisors = set(p for p in range(2, x+1) if x % p == 0)\n    max_product = 0\n    for p in prime_divisors:\n        for k in range(1, n+1):\n            max_product = (max_product + g(x, p) * f(x, p**k)) % (10**9 + 7)\n    return str(max_product)\n\ndef"
    },
    {
        "number": 458,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    n = 0\n    for x in range(1, 10**9):\n        if x % a == 0 and x % b == 0 and x % c == 0:\n            n += 1\n            if x > 0 and x < 10**9:\n                print(x)\n    return str(n)"
    },
    {
        "number": 459,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    colors = list(map(int, stdin.split()[1:]))\n    solved = True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if colors[i] == colors[j] == colors[k]:\n                    solved = False\n                    break\n\n    if solved:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 460,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x, y = map(int, stdin.split())\n    if p < 26 or p > 500 or x < 1 or x > 20000 or y < 1 or y > x:\n        return \"Invalid input\"\n\n    i = (x // 50) % 475\n    for _ in range(25):\n        i = (i * 96 + 42) % 475\n        print(26 + i)\n\n    return str(i)\n"
    },
    {
        "number": 461,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = int(stdin.readline().strip())\n    b = int(stdin.readline().strip())\n    c = int(stdin.readline().strip())\n\n    # Calculate the distance between each house\n    rabbit_house_distance = a\n    owl_house_distance = b\n    eeyore_house_distance = c\n\n    # Calculate the minimum distance\n    min_distance = rabbit_house_distance + owl_house_distance + eeyore_house_distance\n\n    return str(min_distance)"
    },
    {
        "number": 462,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, x2, x3 = map(int, stdin.split())\n    distance = abs(x1 - x2) + abs(x2 - x3) + abs(x3 - x1)\n    return str(distance)"
    },
    {
        "number": 463,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Find the indices of the elements to be replaced\n    i, j = -1, -1\n    for i in range(n):\n        if a[i] == x:\n            j = i\n            break\n\n    # Check if there are at least two distinct indices\n    if j == -1:\n        return \"-1\"\n\n    # Perform the operations\n    for i in range(n):\n        if i == j:\n            continue\n        a[i] = a[i] & x\n\n    return str(n - j)\n"
    },
    {
        "number": 464,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    s = list(stdin.strip())\n\n    for i in range(h):\n        for j in range(w):\n            if s[j] == '.' and (j == 0 or s[j-1] == '.' or j == w-1 or s[j+1] == '.'):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 465,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    if n < 1 or n > 1000 or a < 1 or a > n or b < 1 or b > n:\n        return \"NO\"\n\n    adj_matrix = [[0] * n for _ in range(n)]\n    visited = [False] * n\n\n    for i in range(n):\n        for j in range(n):\n            adj_matrix[i][j] = 1\n            adj_matrix[j][i] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if adj_matrix[i][j] == 1:\n                for k in range(n):\n                    if adj_matrix[i][k] == 1 and adj_matrix[k][j] == 1:\n                        adj_matrix[i][j] = 0\n                        adj_matrix[j][i] = 0\n                        break\n\n    for i in range("
    },
    {
        "number": 466,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, d, k = map(int, stdin.split())\n    n, m = map(int, stdin.split())\n\n    if k > n * m:\n        return \"0\"\n\n    total_used_problems = c * d\n\n    if total_used_problems < n * m:\n        return \"0\"\n\n    return str(n * m)"
    },
    {
        "number": 467,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    grid = []\n    for i in range(27):\n        grid.append(s[i])\n    visited = set()\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    for i in range(26):\n        for j in range(13):\n            if s[i] == grid[j]:\n                path = [grid[j]]\n                while True:\n                    if (i, j) in visited:\n                        break\n                    visited.add((i, j))\n                    path.append(grid[j])\n                    i += directions[j][0]\n                    j += directions[j][1]\n                    if i < 0 or i >= 27 or j < 0 or j >= 13 or grid[j] not in s:\n                        break\n                if path[-1] == s[i]:\n                    return ''.join(path)\n    return \"Impossible\""
    },
    {
        "number": 468,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x**y < y**x:\n        return '<'\n    elif x**y > y**x:\n        return '>'\n    else:\n        return '='"
    },
    {
        "number": 469,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, h = map(int, stdin.split())\n    max_balloons = r * h // 2\n    return str(max_balloons)"
    },
    {
        "number": 470,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t_1, t_2, t_3, t_4, t_5 = map(int, stdin.split())\n    cards = [t_1, t_2, t_3, t_4, t_5]\n    n = len(cards)\n    min_sum = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if cards[i] == cards[j] == cards[k]:\n                    continue\n                if cards[i] + cards[j] + cards[k] < min_sum:\n                    min_sum = cards[i] + cards[j] + cards[k]\n    return str(min_sum)"
    },
    {
        "number": 471,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    # Calculate the distance to the first checkpoint\n    distance_to_first_checkpoint = sum(abs(x[i] - a) for i in range(n))\n\n    # Calculate the distance to the last checkpoint\n    distance_to_last_checkpoint = sum(abs(x[i] - x[n - 1]) for i in range(n - 1))\n\n    # Calculate the minimum distance\n    min_distance = min(distance_to_first_checkpoint, distance_to_last_checkpoint)\n\n    return str(min_distance)\n"
    },
    {
        "number": 472,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 1 or n > 10**18:\n        return \"-1\"\n\n    x = 1\n    while True:\n        x += 1\n        if s(x) == n:\n            return str(x)\n        if s(x) > n:\n            break\n\n    return \"-1\"\n\ndef"
    },
    {
        "number": 473,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = map(int, stdin.split())\n    p = s + t\n    return str(p)"
    },
    {
        "number": 474,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_length = 0\n    max_sum = 0\n    current_sum = 0\n\n    for i in range(n):\n        current_sum += a[i]\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_length = i + 1\n\n    return str(max_length)\n"
    },
    {
        "number": 475,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    ways = 1\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                ways = (ways * (m - 1)) // 2\n            else:\n                ways = (ways * (m - 1)) // 2 + ways * (m - 1 - i) // 2\n    return str(ways % (10**9 + 7))"
    },
    {
        "number": 476,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 14144:\n        return \"YES\"\n    elif n == 141414:\n        return \"YES\"\n    elif n == 1411:\n        return \"YES\"\n    elif n == 1444:\n        return \"YES\"\n    elif n == 514:\n        return \"YES\"\n    elif n == 414:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 477,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, i, j, a, b = map(int, stdin.split())\n    if i < 1 or i > n or j < 1 or j > m:\n        return \"Poor Inna and pony!\"\n\n    moves = 0\n    for x in range(1, n):\n        for y in range(1, m):\n            if x == i and y == j:\n                continue\n            if x - a >= 1 and x - a <= n and y - b >= 1 and y - b <= m:\n                moves += 1\n                if x - a == i and y - b == j:\n                    break\n                if x + a == i and y - b == j:\n                    break\n                if x - a == i and y + b == j:\n                    break\n                if x + a == i and y + b == j:\n                    break\n\n    return str(moves)"
    },
    {
        "number": 478,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    max_length = 0\n    for i in range(n):\n        if i > 0 and s[i] == s[i-1]:\n            continue\n        if i > 0 and s[i] == s[i-1] and s[i-1] == s[i-2]:\n            continue\n        max_length = max(max_length, i+1)\n    return str(max_length)"
    },
    {
        "number": 479,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    q = int(stdin.split())\n\n    result = []\n    for _ in range(q):\n        x = list(map(int, stdin.split()))\n        min_bills = float('inf')\n        for i in range(n):\n            if x[i] <= a[i]:\n                min_bills = min(min_bills, i + 1)\n        result.append(min_bills)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 480,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x_1, x_2 = map(int, stdin.split())\n    t_1, t_2 = map(int, stdin.split())\n    p, d = map(int, stdin.split())\n\n    if d == -1:\n        x_1, x_2 = x_2, x_1\n    elif d == 1:\n        x_1, x_2 = x_1, x_2\n\n    if x_1 == x_2:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if p == 0:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if t_1 == t_2:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == 0:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == 0:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == 0:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == 0:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == s and x_2 == s:\n        return \"It is not possible to reach the point x_1 from the point x_2.\"\n\n    if x_1 == 0 and x_2 == s:\n        return \""
    },
    {
        "number": 481,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    count = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i * j == x:\n                count += 1\n                print(count)\n                break\n    return str(count)"
    },
    {
        "number": 482,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n!= k:\n        return \"Invalid input\"\n\n    def is_valid_password(password: str) -> bool:\n        if len(password)!= n:\n            return False\n\n        distinct_symbols = set()\n        for char in password:\n            if char.islower():\n                distinct_symbols.add(char)\n\n        if len(distinct_symbols)!= k:\n            return False\n\n        for i in range(len(password) - 1):\n            if password[i] == password[i + 1]:\n                return False\n\n        return True\n\n    for password in [\"java\", \"python\", \"phphp\"]:\n        if is_valid_password(password):\n            print(password)\n            break"
    },
    {
        "number": 483,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    particles = []\n    for _ in range(n):\n        x = int(stdin.readline().strip())\n        particles.append(x)\n\n    x1, x2 = particles[0], particles[1]\n    x3, x4 = particles[2], particles[3]\n\n    if x1 == x2 == x3 == x4:\n        return \"1\"\n\n    if x1 == x2 == x3 or x1 == x2 == x4 or x1 == x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return \"-1\"\n\n    if x1 == x2 or x1 == x3 or x1 == x4 or x2 == x3 or x2 == x4 or x3 == x4:\n        return"
    },
    {
        "number": 484,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    seals = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        seals.append((x, y))\n\n    def rotate(seal):\n        x, y = seal\n        return (y, -x)\n\n    def fit(seal1, seal2):\n        x1, y1 = seal1\n        x2, y2 = seal2\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    seals.sort(key=lambda x: (-x[0], -x[1]))\n    max_area = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            area = fit(seals[i], seals[j])\n            max_area = max(max_area, area)\n\n    return str(max_area)\n"
    },
    {
        "number": 485,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    boundary_points = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i][0] == points[j][0] and points[i][1] == points[j][1]:\n                boundary_points.append((points[i][0], points[j][1]))\n\n    boundary_points.sort()\n    boundary_point = boundary_points[0]\n\n    return str(boundary_point[0]) + \" \" + str(boundary_point[1])\n"
    },
    {
        "number": 486,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_product = 0\n    for i in range(1, n+1):\n        product = 1\n        for digit in str(i):\n            product *= int(digit)\n        max_product = max(max_product, product)\n    return str(max_product)"
    },
    {
        "number": 487,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    k = max(a)\n    return str(k)"
    },
    {
        "number": 488,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        color = stdin.strip()\n        points.append((color, 0))\n\n    operations = 0\n    while True:\n        operations += 1\n        for i in range(n - 1):\n            if points[i][1] == 0:\n                continue\n            if points[i + 1][1] == 0:\n                continue\n            if points[i][0] == points[i + 1][0]:\n                continue\n            if points[i][0] == points[i + 1][0] and points[i][1] == points[i + 1][1]:\n                continue\n            if points[i][0] == points[i + 1][0] and points[i][1]!= points[i + 1][1]:\n                points[i] = (points[i][0], 0)\n                points[i + 1] = (points[i + 1][0], 0)\n                operations += 1\n                continue\n            if points[i][0] == points[i + 1][0] and points[i][1] == points[i + 1][1]:\n                points[i] = (points[i][0], 0)\n                points[i + 1] = (points[i + 1][0], 0)\n                operations += 1\n                continue\n\n        if not any(points):\n            break\n\n    return str(operations)"
    },
    {
        "number": 489,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if a[i] * a[j] * a[k] < a[i] * a[j] * a[k] + a[i] * a[k] * a[j] + a[j] * a[i] * a[k] + a[j] * a[k] * a[i] + a[k] * a[i] * a[j] + a[k] * a[j] * a[i]:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 490,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    else:\n        return str(n + 1)"
    },
    {
        "number": 491,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_state = 0\n    for i in range(10):\n        if n % 10 == i:\n            max_state = max(max_state, n - i)\n    return str(max_state)"
    },
    {
        "number": 492,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    directions = {\n        \"^\": \"cw\",\n        \">\": \"ccw\",\n        \"v\": \"undefined\"\n    }\n\n    start_position = stdin.split()[0]\n    duration = int(stdin.split()[1])\n\n    start_position = start_position.replace(\"v\", \"1\")\n    start_position = start_position.replace(\">\", \"3\")\n    start_position = start_position.replace(\"<\", \"6\")\n\n    start_position = int(start_position)\n\n    for _ in range(duration):\n        direction = input()\n        direction = direction.replace(\"v\", \"1\")\n        direction = direction.replace(\">\", \"3\")\n        direction = direction.replace(\"<\", \"6\")\n\n        direction = int(direction)\n\n        if direction == start_position:\n            return directions[direction]\n        elif direction > start_position:\n            start_position = direction\n        else:\n            start_position = direction\n\n    return \"undefined\""
    },
    {
        "number": 493,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    dominoes = []\n    for i in range(n):\n        dominoes.append(s[i])\n    dominoes.sort()\n    count = 0\n    for i in range(n-1):\n        if dominoes[i] == dominoes[i+1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 494,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    leaders = list(map(int, stdin.split()))\n\n    if m < n:\n        return \"-1\"\n\n    if m == 1:\n        return str(leaders[0])\n\n    a = [0] * n\n    a[leaders[0]] = 1\n\n    for i in range(1, m):\n        leader = leaders[i]\n        if a[leader] == 0:\n            a[leader] = i + 1\n\n    for i in range(n - 1, -1, -1):\n        leader = leaders[i]\n        if a[leader] == i + 1:\n            a[leader] = 0\n\n    for i in range(n):\n        if a[i] == 0:\n            return str(i + 1)\n\n    return \"-1\""
    },
    {
        "number": 495,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, k = map(int, stdin.split())\n    max_num = 0\n    for i in range(a):\n        max_num = max(max_num, a - i)\n    return str(max_num)\n"
    },
    {
        "number": 496,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()))\n    d = a[1] - a[0]\n    progression = [a[0]]\n    for i in range(1, n):\n        progression.append(a[0] + d)\n        a.append(a[0] + 2 * d)\n        d = a[1] - a[0]\n    if progression[-1]!= a[-1]:\n        return \"42\"\n    next_element = progression[-1]\n    if next_element % 2 == 0:\n        return \"42\"\n    return str(next_element)\n"
    },
    {
        "number": 497,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    colors = list(map(int, stdin.strip().split()))\n\n    # Find the two houses with different colors\n    i, j = -1, -1\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if colors[i]!= colors[j]:\n                break\n    else:\n        return \"No pair of houses with different colors found\"\n\n    # Calculate the maximum possible distance\n    distance = 0\n    for i in range(i, j):\n        distance += 1\n\n    return str(distance)\n"
    },
    {
        "number": 498,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if k > 2 * n * m:\n        return \"Invalid input\"\n\n    r = 1\n    d = 1\n    s = \"L\"\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 or j == 1 or i == n or j == m:\n                continue\n\n            if k == i * m + j:\n                r = i\n                d = j\n                s = \"R\"\n                break\n\n    return f\"{r} {d} {s}\""
    },
    {
        "number": 499,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    colors = stdin.strip().split()\n    colors = [color.upper() for color in colors]\n    colors.sort()\n    colors = ''.join(colors)\n    \n    if n == 1:\n        return colors\n    \n    for i in range(n-1):\n        if colors[i] == colors[i+1]:\n            colors[i], colors[i+1] = colors[i+1], colors[i]\n    \n    return colors"
    },
    {
        "number": 500,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def is_valid(u, v):\n        for e in edges:\n            if e[0] == u and e[1] == v:\n                return False\n        return True\n\n    def is_valid_position(x, y):\n        for u, v in edges:\n            if abs(x - u) + abs(y - v) <= 1:\n                return False\n        return True\n\n    def find_valid_position(x, y):\n        for u, v in edges:\n            if abs(x - u) + abs(y - v) <= 1:\n                return (u, v)\n        return None\n\n    def find_valid_positions():\n        positions = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid_position(i, j):\n                    positions.append((i, j))\n        return positions\n\n    positions = find_valid_positions()\n    if not positions:\n        return \"NO\"\n\n    for i, j in positions:\n        print(f\"{i} {j}\")\n\n    return \"YES\""
    },
    {
        "number": 501,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    result = 0\n    for i in range(l, r + 1):\n        result += i\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 502,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_x, a_y, b_x, b_y, c_x, c_y = map(int, stdin.split())\n\n    if a_x == b_x and a_y == b_y and a_x == c_x and a_y == c_y:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 503,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 2, n + 1):\n            for k in range(j + 2, n + 1):\n                if a[i] + a[j] + a[k] == k * (k + 1) // 2:\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 504,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    creatures = []\n    for _ in range(n):\n        hp, dmg = map(int, stdin.split())\n        creatures.append((hp, dmg))\n    creatures.sort(key=lambda x: (-x[0], x[1]))\n    max_damage = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if creatures[i][1] + creatures[j][1] <= a * b:\n                max_damage = max(max_damage, creatures[i][1] + creatures[j][1])\n    return str(max_damage)"
    },
    {
        "number": 505,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    maze = [list(map(str, stdin.split())) for _ in range(n)]\n\n    def dfs(x, y, visited, path):\n        if x == n - 1 and y == m - 1:\n            return True\n\n        if x < 0 or x >= n or y < 0 or y >= m or maze[x][y] == \"#\" or visited[x][y]:\n            return False\n\n        visited[x][y] = True\n        path.append((x, y))\n        if dfs(x + 1, y, visited, path):\n            return True\n        if dfs(x - 1, y, visited, path):\n            return True\n        if dfs(x, y + 1, visited, path):\n            return True\n        if dfs(x, y - 1, visited, path):\n            return True\n        path.pop()\n        return False\n\n    def find_cycle(x, y, visited, path):\n        if len(path) < k:\n            return False\n\n        if x == n - 1 and y == m - 1:\n            return True\n\n        if x < 0 or x >= n or y < 0 or y >= m or maze[x][y] == \"#\" or visited[x][y]:\n            return False\n\n        visited[x][y] = True\n        path.append((x, y))\n        if find_cycle(x + 1, y, visited, path):\n            return True\n        if find_cycle(x - 1, y, visited, path):\n            return True\n        if find_cycle(x, y + 1, visited, path):\n            return True\n        if find_cycle(x, y - 1, visited, path):\n            return True\n        path.pop()\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == \"X\":\n                maze[i][j] = \"O\"\n\n    start_x, start_y = 0, 0\n    visited = [[False] * m for _ in range(n)]\n    path = [(start_x, start_y)]\n\n    while True:\n        if not find_cycle(start_x, start_y, visited, path):\n            break\n\n        start_x, start_y = path[-1][0], path[-1][1]\n        path.pop()\n\n    if len(path) < k:\n        return \"IMPOSSIBLE\"\n\n    cycle = []\n    for i in range(k - 1, -1, -1):\n        cycle.append(path[i][1])\n        path.pop()\n\n    cycle.reverse()\n    return \"\".join(cycle)\n"
    },
    {
        "number": 506,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    ships = 0\n    for i in range(1, a + 1):\n        ships += i\n    return str(ships)"
    },
    {
        "number": 507,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == b[j]:\n                return \" \".join(map(str, [a[i], b[j]]))\n\n    return \"No solution found\""
    },
    {
        "number": 508,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    vertices = [0] * n\n    for i in range(n):\n        vertices[i] = i + 1\n    angle = a * math.pi / 180\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            angle_diff = math.degrees(math.acos((vertices[i] - vertices[j]) / math.sqrt((vertices[i] - vertices[j]) ** 2 + (vertices[i + 1] - vertices[j]) ** 2)))\n            if angle_diff < angle:\n                angle = angle_diff\n    v1, v2, v3 = vertices[0], vertices[1], vertices[2]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            angle_diff = math.degrees(math.acos((vertices[i] - vertices[j]) / math.sqrt((vertices[i] - vertices[j]) ** 2 + (vertices[i + 1] - vertices[j]) ** 2)))\n            if angle_diff == angle:\n                v1, v2, v3 = vertices[i], vertices[j], vertices[i + 1]\n                break\n    return \" \".join(map(str, [v1, v2, v3]))"
    },
    {
        "number": 509,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rotations = []\n    for _ in range(n):\n        a_i = int(stdin.strip())\n        rotations.append(a_i)\n\n    if rotations[0] == 0 and rotations[1] == 0 and rotations[2] == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 510,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    min_duration = 0\n    for i in range(a, b+1):\n        for j in range(c, d+1):\n            if i == j:\n                continue\n            min_duration = max(min_duration, i - j)\n    return str(min_duration)"
    },
    {
        "number": 511,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    return str(1 + solution(str(x - gcd(x, y))))\n\ndef"
    },
    {
        "number": 512,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = [-1] * N\n    B = [-1] * N\n    for i in range(N):\n        A[i], B[i] = map(int, stdin.strip().split())\n\n    for i in range(N):\n        if A[i] == -1 or B[i] == -1:\n            return \"No\"\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] == A[j] and B[i] == B[j]:\n                return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 513,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x1, y1 = map(int, stdin.readline().strip().split())\n        x2, y2 = map(int, stdin.readline().strip().split())\n        points.append((x1, y1))\n        points.append((x2, y2))\n\n    def is_valid(p1, p2, p3, p4, p5, p6, p7, p8):\n        return (p1[0] < p2[0] < p3[0] and p1[1] < p2[1] < p3[1]) or \\\n               (p4[0] < p5[0] < p6[0] and p4[1] < p5[1] < p6[1]) or \\\n               (p7[0] < p8[0] < p5[0] and p7[1] < p8[1] < p5[1])\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if is_valid(points[i], points[j], points[i + 1], points[j + 1], points[i + 2], points[j + 2], points[i + 3], points[j + 3]):\n                return \"respectable\"\n            elif is_valid(points[i], points[j], points[i + 1], points[j + 1], points[i + 2], points[j + 2], points[i + 3], points[j + 3]):\n                return \"ugly\"\n\n    return \"ugly\""
    },
    {
        "number": 514,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        n, d = map(int, stdin.readline().split())\n        if d <= n:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 515,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = int(stdin.strip())\n\n    if n == 1:\n        return \"1\"\n\n    if n == 2:\n        return \"1\"\n\n    if n == 3:\n        return \"1\"\n\n    if n == 4:\n        return \"1\"\n\n    if n == 5:\n        return \"1\"\n\n    if n == 6:\n        return \"1\"\n\n    if n == 7:\n        return \"1\"\n\n    if n == 8:\n        return \"1\"\n\n    if n == 9:\n        return \"1\"\n\n    if n == 10:\n        return \"1\"\n\n    if n == 11:\n        return \"1\"\n\n    if n == 12:\n        return \"1\"\n\n    if n == 13:\n        return \"1\"\n\n    if n == 14:\n        return \"1\"\n\n    if n == 15:\n        return \"1\"\n\n    if n == 16:\n        return \"1\"\n\n    if n == 17:\n        return \"1\"\n\n    if n == 18:\n        return \"1\"\n\n    if n == 19:\n        return \"1\"\n\n    if n == 20:\n        return \"1\"\n\n    if n == 21:\n        return \"1\"\n\n    if n == 22:\n        return \"1\"\n\n    if n == 23:\n        return \"1\"\n\n    if n == 24:\n        return \"1\"\n\n    if n == 25:\n        return \"1\"\n\n    if n == 26:\n        return \"1\"\n\n    if n == 27:\n        return \"1\"\n\n    if n == 28:\n        return \"1\"\n\n    if n == 29:\n        return \"1\"\n\n    if n == 30:\n        return \"1\"\n\n    if n == 31:\n        return \"1\"\n\n    if n == 32:\n        return \"1\"\n\n    if n == 33:\n        return \"1\"\n\n    if n == 34:\n        return \"1\"\n\n    if n == 35:\n        return \"1\"\n\n    if n == 36:\n        return \"1\"\n\n    if n == 37:\n        return \"1\"\n\n    if n == 38:\n        return \"1\"\n\n    if n == 39:\n        return \"1\"\n\n    if n == 40:\n        return \"1\"\n\n    if n == 41:\n        return \"1\"\n\n    if n == 42:\n        return \"1\"\n\n    if n == 43:\n        return \"1\"\n\n    if n == 44:\n        return \"1\"\n\n    if n == 45:\n        return \"1\"\n\n    if n == 46:\n        return \"1\"\n\n    if n == 47:\n        return \"1\"\n\n    if n == 48:\n        return \"1\"\n\n    if n == 49:\n        return \"1\"\n\n    if n == 50:\n        return \"1\"\n\n    if n == 51:\n        return \"1\"\n\n    if n == 52:\n        return \"1\"\n\n    if n == 53:\n        return \"1\"\n\n    if n == 54:\n        return \"1\"\n\n    if n == 55:\n        return \"1\"\n\n    if n == 56:\n        return \"1\"\n\n    if n == 57:\n        return \"1\"\n\n    if n == 58:\n        return \"1\"\n\n    if n == 59:\n        return \"1\"\n\n    if n == 60:\n        return \"1\"\n\n    if n == 61:\n        return \"1\"\n\n    if n == 62:\n        return \"1\"\n\n    if n == 63:\n        return \"1\"\n\n    if n == 64:\n        return \"1\"\n\n    if n == 65:\n        return \"1\"\n\n    if n == 66:\n        return \"1\"\n\n    if n == 67:\n        return \"1\"\n\n    if n == 68:\n        return \"1\"\n\n    if n == 69:\n        return \"1\"\n\n    if n == 70:\n        return \"1\"\n\n    if n == 71:\n        return \"1\"\n\n    if n == 72:\n        return \"1\"\n\n    if n == 73:\n        return \"1\"\n\n    if n == 74:\n        return \"1\"\n\n    if n == 75:\n        return \"1\"\n\n    if n == 76:\n        return \"1\"\n\n    if n == 77:\n        return \"1\"\n\n    if n == 78:\n        return \"1\"\n\n   "
    },
    {
        "number": 516,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.strip()\n    t = stdin.strip()\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def replace_symbols(s, t):\n        for i in range(len(s)):\n            if s[i] == \"?\":\n                s = s[:i] + t[i] + s[i+1:]\n        return s\n\n    s_len = len(s)\n    t_len = len(t)\n\n    for i in range(s_len - t_len + 1):\n        s_new = replace_symbols(s, t)\n        if s_new == t:\n            return str(i + 1)\n\n    return \"0\"\n"
    },
    {
        "number": 517,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, h = map(int, stdin.split())\n    if n < 2 or d < 1 or d > n - 1 or h < 1 or h > d - 1:\n        return \"-1\"\n\n    tree = []\n    for i in range(1, n):\n        tree.append([i, i + 1])\n\n    for i in range(1, n - 1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -1):\n        for j in range(i + 1, n):\n            tree.append([i, j])\n\n    for i in range(n - 2, 0, -"
    },
    {
        "number": 518,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    R = r * (n + 1) / 2\n    return str(round(R, 6))"
    },
    {
        "number": 519,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, p, q = map(int, stdin.split())\n    distance = 0\n    for i in range(l):\n        distance += p * i\n    for i in range(l):\n        distance += q * (l - i - 1)\n    return str(distance)"
    },
    {
        "number": 520,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    groups = list(map(int, stdin.strip().split()))\n    x = 1\n\n    for i in range(n):\n        if groups[i] - groups[i - 1] <= x:\n            x += 1\n\n    return str(x)"
    },
    {
        "number": 521,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n\n    if n == 1:\n        return \"No\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'Y' and s[3] == 'Y':\n        return \"Yes\"\n\n    if s[0] == 'C' and s[1] == 'C' and s[2] == 'M' and s[3] == 'M':\n        return \"Yes\"\n\n    if s[0]"
    },
    {
        "number": 522,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f1, f2, f3, c = map(int, stdin.split())\n    if n > 10**18:\n        return \"Error: n is too large.\"\n    if f1 < 1 or f1 > 10**9:\n        return \"Error: f1 is out of range.\"\n    if f2 < 1 or f2 > 10**9:\n        return \"Error: f2 is out of range.\"\n    if f3 < 1 or f3 > 10**9:\n        return \"Error: f3 is out of range.\"\n    if c < 1 or c > 10**9:\n        return \"Error: c is out of range.\"\n\n    def f(x):\n        return c ** (2 * x - 6) * f(x - 1) * f(x - 2) * f(x - 3)\n\n    result = f(n)\n    result %= (10**9 + 7)\n    return str(result)\n"
    },
    {
        "number": 523,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    palindromes = []\n    for i in range(n):\n        s = input()\n        if s == s[::-1]:\n            palindromes.append(s)\n    if not palindromes:\n        return \"0\"\n    max_length = max(len(p) for p in palindromes)\n    longest_palindrome = \"\"\n    for p in palindromes:\n        if len(p) > max_length:\n            longest_palindrome = p\n            max_length = len(p)\n    return longest_palindrome"
    },
    {
        "number": 524,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Reorder the list\n    p = list(range(n))\n    for i in range(n):\n        p[i], p[i+1] = p[i+1], p[i]\n\n    # Perform the operation n times\n    for _ in range(n):\n        i = random.randint(0, n-2)\n        if random.choice([1, -1]):\n            a[i] += 1\n        else:\n            a[i] -= 1\n\n    # Find the minimum cost\n    min_cost = float('inf')\n    for i in range(n):\n        if a[i] == 0:\n            min_cost = min(min_cost, i)\n\n    return str(min_cost)"
    },
    {
        "number": 525,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                a[i], a[j] = a[j], a[i]\n                a.pop(j)\n                break\n\n    return str(min(len(a), n))"
    },
    {
        "number": 526,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 0:\n                continue\n            for k in range(i + 1, n):\n                if a[k][j] == 0:\n                    continue\n                if a[i][j] ^ a[k][j] > 0:\n                    print(\"NIE\")\n                    return \"NIE\"\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if a[i][j] == 0:\n                continue\n            for k in range(j + 1, m):\n                if a[i][k] == 0:\n                    continue\n                if a[i][j] ^ a[i][k] > 0:\n                    print(\"NIE\")\n                    return \"NIE\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 0:\n                continue\n            for k in range(i + 1, n):\n                if a[k][j] == 0:\n                    continue\n                if a[i][j] ^ a[k][j] > 0:\n                    print(\"TAK\")\n                    return \"TAK\"\n\n    print(\"NIE\")\n    return \"NIE\""
    },
    {
        "number": 527,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    s_prime = s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s + s"
    },
    {
        "number": 528,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        friends.add((a, b))\n        friends.add((b, a))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j and (i, j) not in friends and (j, i) not in friends:\n                if (i, j) not in friends and (j, i) in friends:\n                    return \"NO\"\n    return \"YES\""
    },
    {
        "number": 529,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_str = stdin.strip()\n    input_len = len(input_str)\n\n    # Check if input length is within the required range\n    if input_len < 1 or input_len > 50:\n        return \"Invalid input length\"\n\n    # Convert input string to lowercase\n    input_str = input_str.lower()\n\n    # Initialize output string\n    output_str = \"\"\n\n    # Iterate through the input string\n    for i in range(input_len):\n        # Check if the current character is a vowel\n        if input_str[i] in \"aeiou\":\n            # If it is, add it to the output string\n            output_str += input_str[i]\n\n    # Return the output string\n    return output_str"
    },
    {
        "number": 530,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    t = stdin.strip()\n\n    # Yaroslav's word\n    s_1 = s[0]\n    s_2 = s[1]\n    s_3 = s[2]\n    s_4 = s[3]\n    s_5 = s[4]\n    s_6 = s[5]\n    s_7 = s[6]\n    s_8 = s[7]\n    s_9 = s[8]\n    s_10 = s[9]\n    s_11 = s[10]\n    s_12 = s[11]\n    s_13 = s[12]\n    s_14 = s[13]\n    s_15 = s[14]\n    s_16 = s[15]\n    s_17 = s[16]\n    s_18 = s[17]\n    s_19 = s[18]\n    s_20 = s[19]\n    s_21 = s[20]\n    s_22 = s[21]\n    s_23 = s[22]\n    s_24 = s[23]\n    s_25 = s[24]\n    s_26 = s[25]\n    s_27 = s[26]\n    s_28 = s[27]\n    s_29 = s[28]\n    s_30 = s[29]\n    s_31 = s[30]\n    s_32 = s[31]\n    s_33 = s[32]\n    s_34 = s[33]\n    s_35 = s[34]\n    s_36 = s[35]\n    s_37 = s[36]\n    s_38 = s[37]\n    s_39 = s[38]\n    s_40 = s[39]\n    s_41 = s[40]\n    s_42 = s[41]\n    s_43 = s[42]\n    s_44 = s[43]\n    s_45 = s[44]\n    s_46 = s[45]\n    s_47 = s[46]\n    s_48 = s[47]\n    s_49 = s[48]\n    s_50 = s[49]\n    s_51 = s[50]\n    s_52 = s[51]\n    s_53 = s[52]\n    s_54 = s[53]\n    s_55 = s[54]\n    s_56 = s[55]\n    s_57 = s[56]\n    s_58 = s[57]\n    s_59 = s[58]\n    s_60 = s[59]\n    s_61 = s[60]\n    s_62 = s[61]\n    s_63 = s[62]\n    s_64 = s[63]\n    s_65 = s[64]\n    s_66 = s[65]\n    s_67 = s[66]\n    s_68 = s[67]\n    s_69 = s[68]\n    s_70 = s[69]\n    s_71 = s[70]\n    s_72 = s[71]\n    s_73 = s[72]\n    s_74 = s[73]\n    s_75 = s[74]\n    s_76 = s[75]\n    s_77 = s[76]\n    s_78 = s[77]\n    s_79 = s[78]\n    s_80 = s[79]\n    s_81 = s[80]\n    s_82 = s[81]\n    s_83 = s[82]\n    s_84 = s[83]\n    s_85 = s[84]\n    s_86 = s[85]\n    s_87 = s[86]\n    s_88 = s[87]\n    s_89 = s[88]\n    s_90 = s[89]\n    s_91 = s[90]\n    s_92 = s[91]"
    },
    {
        "number": 531,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    # Find the minimum possible number of equal measurements\n    min_equal_measurements = float('inf')\n    for i in range(n):\n        if x[i] == y[i]:\n            min_equal_measurements = min(min_equal_measurements, i + 1)\n\n    # Print the minimum possible number of equal measurements\n    print(min_equal_measurements)\n\n    # Print the values\n    for i in range(n):\n        print(y[i])\n\n    return \"\""
    },
    {
        "number": 532,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input string\n    name = stdin.strip()\n    \n    # Initialize the variables\n    n = len(name)\n    rotations = 0\n    \n    # Perform the rotations\n    for i in range(n):\n        # Rotate the wheel one step clockwise\n        rotations += 1\n        if i < n - 1:\n            rotations += 1\n        \n        # Move the pointer to the next letter\n        if i < n - 1:\n            name = name[:i] + chr(ord(name[i]) + 1) + name[i+1:]\n    \n    # Return the result\n    return str(rotations)"
    },
    {
        "number": 533,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, k_1, k_2, n = map(int, stdin.split())\n    min_players = min(a_1 * k_1, a_2 * k_2)\n    max_players = max(a_1 * k_1, a_2 * k_2)\n    return str(min_players) + \" \" + str(max_players)"
    },
    {
        "number": 534,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s = stdin.strip()\n    a = \"\"\n    for i in range(n):\n        if s[i] == \"B\":\n            a += \"B\"\n        else:\n            a += \"G\"\n    return a"
    },
    {
        "number": 535,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    P = 58\n    Q = 1000000007\n    P_Q = P * Q ** (-1)\n    expected_value = P_Q % (10**9 + 7)\n    return str(expected_value)"
    },
    {
        "number": 536,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sequence = []\n    for i in range(n):\n        sequence.append(0)\n    for i in range(m):\n        sequence.append(1)\n    for i in range(n - 1):\n        if sequence[i] == 0 and sequence[i + 1] == 0:\n            sequence[i] = 1\n            sequence[i + 1] = 1\n    for i in range(m - 1):\n        if sequence[i] == 1 and sequence[i + 1] == 1:\n            sequence[i] = 0\n            sequence[i + 1] = 0\n    if sequence == [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, "
    },
    {
        "number": 537,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    winners = 0\n    not_winners = 0\n    diplomas = 0\n    certificates = 0\n\n    for i in range(n):\n        if i % 2 == 0:\n            diplomas += 1\n        else:\n            certificates += 1\n\n    for i in range(n):\n        if i % 2 == 0:\n            winners += 1\n        else:\n            not_winners += 1\n\n    if winners > n // 2:\n        return str(winners), str(certificates), str(not_winners)\n    else:\n        return str(0), str(0), str(n - winners)"
    },
    {
        "number": 538,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    if x == 0:\n        return \"NO\"\n    for i in range(10):\n        if str(x) == str(x)[::-1]:\n            return \"YES\"\n    return \"NO\""
    },
    {
        "number": 539,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                if (i + j + k) % 2 == 0:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 540,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cave = [list(input()) for _ in range(n)]\n    r_1, c_1 = map(int, input().split())\n    r_2, c_2 = map(int, input().split())\n\n    def dfs(r, c, visited):\n        if r == r_2 and c == c_2:\n            return True\n        if r < 1 or r > n or c < 1 or c > m or cave[r][c] == 'X' or visited[r][c]:\n            return False\n        visited[r][c] = True\n        if dfs(r + 1, c, visited):\n            return True\n        if dfs(r - 1, c, visited):\n            return True\n        if dfs(r, c + 1, visited):\n            return True\n        if dfs(r, c - 1, visited):\n            return True\n        visited[r][c] = False\n        return False\n\n    visited = [[False] * m for _ in range(n)]\n    if dfs(r_1, c_1, visited):\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 541,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    bridges = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        bridges.append((a, b))\n\n    def dfs(island):\n        if island not in visited:\n            visited.add(island)\n            for neighbor in bridges:\n                if neighbor[0] == island or neighbor[1] == island:\n                    continue\n                dfs(neighbor[0])\n                dfs(neighbor[1])\n\n    visited = set()\n    for island in range(N):\n        dfs(island)\n\n    return len(visited) - 1"
    },
    {
        "number": 542,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Sort the techniques in chronological order\n    a.sort()\n\n    # Initialize the variables\n    max_points = 0\n    max_points_wrestler1 = 0\n    max_points_wrestler2 = 0\n    current_points = 0\n\n    # Iterate through the techniques\n    for i in range(n):\n        # If the current technique is the first technique, update the max points\n        if i == 0:\n            max_points = a[i]\n            max_points_wrestler1 = a[i]\n            max_points_wrestler2 = a[i]\n            current_points = a[i]\n        # If the current technique is the second technique, update the max points\n        elif i == 1:\n            max_points = max(max_points, a[i])\n            max_points_wrestler1 = max(max_points_wrestler1, a[i])\n            max_points_wrestler2 = max(max_points_wrestler2, a[i])\n            current_points = max(current_points, a[i])\n        # If the current technique is not the first or second technique, update the max points\n        else:\n            max_points = max(max_points, a[i])\n            max_points_wrestler1 = max(max_points_wrestler1, a[i])\n            max_points_wrestler2 = max(max_points_wrestler2, a[i])\n            current_points = max(current_points, a[i])\n\n    # If the sequences of the awarded points coincide, the wrestler who performed the last technique wins\n    if current_points == max_points:\n        if max_points_wrestler1 == max_points_wrestler2:\n            return \"first\"\n        else:\n            return \"second\"\n    # If the sequences of the awarded points do not coincide, the wrestler who performed the last technique wins\n    else:\n        return \"first\""
    },
    {
        "number": 543,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Count the number of teams that will be present on each day\n    count = [0] * n\n    for i in range(n):\n        count[i] = sum(a[:i+1])\n\n    # Check if there is a way to order pizzas using only coupons and discounts\n    for i in range(n):\n        if count[i] >= 2:\n            # Check if there is a way to order pizzas using only coupons\n            if i > 0 and count[i-1] >= 2:\n                # Check if there is a way to order pizzas using only discounts\n                if i > 1 and count[i-2] >= 2:\n                    return \"YES\"\n            else:\n                return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 544,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    for _ in range(T):\n        n = int(stdin.strip())\n        s = stdin.strip()\n        if n % 2 == 0:\n            n -= 1\n        for i in range(n):\n            if i == 0 or i == n - 1:\n                continue\n            if s[i] == s[i - 1] or s[i] == s[i + 1]:\n                s = s[:i] + s[i + 1:] + s[:i] + s[i - 1] + s[i + 1:]\n            else:\n                s = s[:i] + s[i + 1:] + s[:i] + s[i - 1] + s[i + 2:]\n        if s == s[::-1]:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 545,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    s_1 = stdin.strip()\n    s_2 = stdin.strip()\n\n    if len(s_1)!= len(s_2):\n        return -1\n\n    for i in range(n):\n        if s_1[i]!= s_2[i]:\n            return -1\n\n    for i in range(n):\n        if s_1[i] == s_2[i]:\n            if i == n - 1:\n                return s_1[i]\n            elif i == n - 2:\n                return s_1[i] + s_2[i + 1]\n            else:\n                return s_1[i] + s_2[i + 1] + s_1[i + 2]\n\n    return -1"
    },
    {
        "number": 546,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    good_letters = \"abcdefghijklmnopqrstuvwxyz\"\n    bad_letters = \"abcdefghijklmnopqrstuvwxyz\"\n    pattern = stdin.strip()\n    query_strings = stdin.strip().split('\\n')\n\n    result = []\n\n    for query in query_strings:\n        query = query.strip()\n        if \"*\" in query:\n            result.append(\"NO\")\n        else:\n            pattern_matches = True\n            for i in range(len(query)):\n                if query[i] == \"?\":\n                    if query[i + 1] == \"?\":\n                        pattern_matches = False\n                        break\n                    else:\n                        query = query[:i] + good_letters[good_letters.index(query[i + 1]) + 1] + query[i + 2:]\n                elif query[i] == \"*\":\n                    if len(query) > 1 and query[i + 1] == \"?\":\n                        pattern_matches = False\n                        break\n                    else:\n                        query = query[:i] + bad_letters + query[i + 1:]\n\n            if pattern_matches:\n                result.append(\"YES\")\n            else:\n                result.append(\"NO\")\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 547,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    passwords = list(map(str, stdin.split()))\n    codehorses_password = stdin.strip()\n\n    # Sort passwords by length in ascending order\n    passwords.sort(key=len)\n\n    # Initialize variables\n    time = 0\n    max_time = 0\n\n    # Iterate over passwords\n    for password in passwords:\n        # Check if password is correct\n        if password == codehorses_password:\n            time += 1\n            if time > max_time:\n                max_time = time\n        else:\n            time = 0\n\n    return str(max_time) + \" \" + str(max_time - 5)"
    },
    {
        "number": 548,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # First player\n    first_player = True\n    for i in range(n):\n        if a[i] % 2 == 0:\n            a[i] = 0\n            first_player = False\n            break\n\n    # Second player\n    second_player = True\n    for i in range(n):\n        if a[i] % 2 == 1:\n            second_player = False\n            break\n\n    if first_player:\n        return \"First\"\n    else:\n        return \"Second\""
    },
    {
        "number": 549,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n <= 0:\n        return \"Invalid input\"\n\n    rows = n // 2\n    cols = n - rows\n\n    return str(rows) + \" \" + str(cols)"
    },
    {
        "number": 550,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    existing_logins = set()\n    for line in stdin.splitlines():\n        login = line.strip()\n        if login not in existing_logins:\n            existing_logins.add(login)\n    new_login = input().strip()\n    if new_login in existing_logins:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 551,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = list(map(int, stdin.strip().split()))\n\n    if n < 3:\n        return \"No\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i] == points[j]:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 552,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = stdin.strip()\n    b = stdin.strip()\n    s = stdin.strip()\n\n    # Find the segments that satisfy the conditions\n    segments = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i:j] in b and a[i:j] == s:\n                segments.append((i, j))\n\n    # Count the number of ways to choose the segments\n    ways = 0\n    for i in range(len(segments)):\n        for j in range(i + 1, len(segments)):\n            if segments[i][0] < segments[j][1] and segments[i][1] < segments[j][0]:\n                ways += 1\n\n    return str(ways)"
    },
    {
        "number": 553,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    promocodes = []\n    for _ in range(n):\n        promocode = input().strip()\n        if len(promocode)!= 6:\n            print(\"Invalid promocode\")\n            continue\n        promocodes.append(promocode)\n\n    max_k = 0\n    for i in range(len(promocodes)):\n        for j in range(i + 1, len(promocodes)):\n            for k in range(max(len(promocodes[i]), len(promocodes[j]))):\n                if promocodes[i][:k] == promocodes[j][:k]:\n                    max_k = max(max_k, k)\n                    break\n\n    print(max_k)\n    return \"\""
    },
    {
        "number": 554,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    subarrays = []\n    for i in range(m):\n        subarrays.append(list(map(int, stdin.split())))\n    happiness = 0\n    for i in range(n):\n        happiness += a[i] * len(subarrays[i])\n    return str(happiness)"
    },
    {
        "number": 555,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    result = 0\n    while x > 0:\n        digit = x % 10\n        result = result * 10 + digit\n        x //= 10\n    return str(result)"
    },
    {
        "number": 556,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, k = map(int, stdin.split())\n    if l > r:\n        return \"-1\"\n\n    def splay(node):\n        if node is None:\n            return None\n        node.height = 1 + max(splay(node.left), splay(node.right))\n        node.left = splay(node.left)\n        node.right = splay(node.right)\n        return node\n\n    def splay_insert(node, key):\n        if node is None:\n            return Node(key)\n        if key < node.key:\n            node.left = splay_insert(node.left, key)\n        elif key > node.key:\n            node.right = splay_insert(node.right, key)\n        else:\n            return node\n        node.height = 1 + max(splay(node.left), splay(node.right))\n        balance = get_balance(node)\n        if balance > 1 and key < node.left.key:\n            return rotate_right(node)\n        elif balance < -1 and key > node.right.key:\n            return rotate_left(node)\n        elif balance > 1 and key > node.left.key:\n            node.left = rotate_left(node.left)\n            return rotate_right(node)\n        elif balance < -1 and key < node.right.key:\n            node.right = rotate_right(node.right)\n            return rotate_left(node)\n        return node\n\n    def get_balance(node):\n        if node is None:\n            return 0\n        return node.height - 1\n\n    def rotate_left(node):\n        new_root = node.right\n        node.right = new_root.left\n        new_root.left = node\n        new_root.height = 1 + max(splay(new_root.left), splay(new_root.right))\n        return new_root\n\n    def rotate_right(node):\n        new_root = node.left\n        node.left = new_root.right\n        new_root.right = node\n        new_root.height = 1 + max(splay(new_root.left), splay(new_root.right))\n        return new_root\n\n    def splay_delete(node, key):\n        if node is None:\n            return None\n        if key < node.key:\n            node.left = splay_delete(node.left, key)\n        elif key > node.key:\n            node.right = splay_delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            if node.right is None:\n                return node.left\n            min_node = get_min_node(node.right)\n            node.key = min_node.key\n            node.right = splay_delete(node.right, min_node.key)\n        node.height = 1 + max(splay(node.left), splay(node.right))\n        balance = get_balance(node)\n        if balance > 1 and get_balance(node.left) >= 0:\n            return rotate_left(node)\n        elif balance > 1 and get_balance(node.left) < 0:\n            node.left = rotate_right(node.left)\n            return rotate_left(node)\n        elif balance < -1 and get_balance(node.right) <= 0:\n            return rotate_right(node)\n        elif balance < -1 and get_balance(node.right) > 0:\n            node.right = rotate_left(node.right)\n            return rotate_right(node)\n        return node\n\n    def get_min_node(node):\n        if node.left is None:\n            return node\n        return get_min_node(node.left)\n\n    def get_max_node(node):\n        if node.right is None:\n            return node\n        return get_max_node(node.right)\n\n    def get_max_key(node):\n        if node is None:\n            return None\n        return get_max_key(node.right)\n\n    def get_min_key(node):\n        if node is None:\n            return None\n        return get_min_key(node.left)\n\n    def get_max_value(node):\n        if node is None:\n            return None\n        return get_max_value(node.right)\n\n    def get_min_value(node):\n        if node is None:\n            return None\n        return get_min_value(node.left)\n\n    def get_max_power(node, key):\n        if node is None:\n            return None\n        if key == node.key:\n            return node.value"
    },
    {
        "number": 557,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    teleports = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        teleports.append((a, b))\n\n    def can_visit(x, y):\n        for a, b in teleports:\n            if x <= a or x >= b or y <= a or y >= b:\n                return False\n        return True\n\n    def can_use_teleports(x, y):\n        for a, b in teleports:\n            if x <= a or x >= b or y <= a or y >= b:\n                return False\n        return True\n\n    def can_move(x, y):\n        for a, b in teleports:\n            if x <= a or x >= b or y <= a or y >= b:\n                return False\n        return True\n\n    def can_reach(x, y):\n        for a, b in teleports:\n            if x <= a or x >= b or y <= a or y >= b:\n                return False\n        return True\n\n    def path(x, y, visited):\n        if x == y:\n            return True\n        if x in visited:\n            return False\n        visited.add(x)\n        if can_move(x, y):\n            return path(x + 1, y, visited)\n        if can_move(x, y - 1):\n            return path(x + 1, y - 1, visited)\n        if can_move(x - 1, y):\n            return path(x - 1, y, visited)\n        if can_move(x - 1, y - 1):\n            return path(x - 1, y - 1, visited)\n        return False\n\n    def find_path(x, y):\n        visited = set()\n        if path(x, y, visited):\n            return True\n        return False\n\n    def find_friend(x, y):\n        for a, b in teleports:\n            if x <= a or x >= b or y <= a or y >= b:\n                continue\n            if find_path(x, y):\n                return True\n        return False\n\n    if can_reach(0, m):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 558,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    colors = list(range(1, M+1))\n    ways = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if i == j == k:\n                    continue\n                if colors[i] == colors[j] == colors[k]:\n                    ways += 1\n    return str(ways % 998244353)"
    },
    {
        "number": 559,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, a = map(int, stdin.split())\n    b = [0] * (p - 1)\n    for i in range(p - 1):\n        b[i] = int(input())\n    f = [0] * p\n    for i in range(p - 1):\n        f[i] = b[i]\n    for i in range(p - 2, -1, -1):\n        f[i] = (f[i] + b[i]) % p\n    return''.join(map(str, f))"
    },
    {
        "number": 560,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    cake = [[0] * c for _ in range(r)]\n    max_eat = 0\n\n    for i in range(r):\n        for j in range(c):\n            if cake[i][j] == 0:\n                if i > 0 and cake[i-1][j] == 0:\n                    cake[i][j] = 1\n                    max_eat += 1\n                if j > 0 and cake[i][j-1] == 0:\n                    cake[i][j] = 1\n                    max_eat += 1\n                if i < r-1 and cake[i+1][j] == 0:\n                    cake[i][j] = 1\n                    max_eat += 1\n                if j < c-1 and cake[i][j+1] == 0:\n                    cake[i][j] = 1\n                    max_eat += 1\n\n    return str(max_eat)"
    },
    {
        "number": 561,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = list(map(int, stdin.strip().split()))\n\n    def is_arithmetic_progression(sequence):\n        for i in range(1, len(sequence)):\n            if sequence[i] - sequence[i - 1]!= sequence[i + 1] - sequence[i]:\n                return False\n        return True\n\n    if is_arithmetic_progression(sequence):\n        print(n + 1)\n        for i in range(n + 1):\n            print(i)\n    else:\n        print(-1)\n\n    return \"\""
    },
    {
        "number": 562,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    tvs = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        tvs.append((l, r))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if tvs[i][1] == tvs[j][0]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 563,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    a, b = 0, 1\n    while b <= r:\n        if a > b:\n            a, b = b, a + 1\n        else:\n            break\n    if a > r:\n        return \"-1\"\n    c = (a + b) // 2\n    while a < b < c:\n        if a > b:\n            a, b = b, a + 1\n        else:\n            break\n    while a < b < c:\n        if b > c:\n            c, b = b, c + 1\n        else:\n            break\n    return f\"{a} {b} {c}\""
    },
    {
        "number": 564,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    mugs = [int(x) for x in stdin.split()]\n    cup_volume = int(stdin.split())\n\n    if n == 1:\n        return \"YES\"\n\n    for i in range(1, n):\n        if mugs[i] > mugs[i - 1]:\n            return \"NO\"\n\n    if cup_volume > s:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 565,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, b, r = map(int, stdin.split())\n    max_ornaments = 0\n    if y > 0 and b > 0 and r > 0:\n        max_ornaments = 6\n    elif y > 0 and b > 0:\n        max_ornaments = 5\n    elif y > 0 and r > 0:\n        max_ornaments = 6\n    elif b > 0 and r > 0:\n        max_ornaments = 5\n    elif y > 0:\n        max_ornaments = 4\n    elif b > 0:\n        max_ornaments = 5\n    elif r > 0:\n        max_ornaments = 6\n    return str(max_ornaments)"
    },
    {
        "number": 566,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    t = 1\n    for i in range(1, 4):\n        for j in range(1, 4):\n            for k in range(1, 4):\n                if i!= j and i!= k and j!= k:\n                    t = max(t, r + g + b)\n    return str(t)"
    },
    {
        "number": 567,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    prizes = []\n    for i in range(n):\n        prizes.append(a[i])\n    prizes.sort()\n    total_time = 0\n    for i in range(n):\n        if prizes[i] == prizes[i + 1]:\n            total_time += 1\n    return str(total_time)"
    },
    {
        "number": 568,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [0] * n\n    b = [0] * n\n    for i in range(n):\n        a[i] = int(stdin.strip())\n        b[i] = int(stdin.strip())\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if a[i] + a[j] + a[k] + a[i] + a[j] + a[k] + n + a[i] + a[j] + a[k] + 2 * n == 6:\n                    count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 569,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    changes = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i] == s[j]:\n                changes += 1\n                s = s[:i] + s[i+1:] + s[j+1:]\n    if changes == 0:\n        return \"-1\"\n    else:\n        return str(changes)"
    },
    {
        "number": 570,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a > b:\n        return \"Valera\"\n    else:\n        return \"Vladik\""
    },
    {
        "number": 571,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == '?':\n            count += 1\n            if count == 1:\n                s = s[:i] + '(' + s[i+1:]\n            elif count == 2:\n                s = s[:i] + ')' + s[i+1:]\n            else:\n                s = s[:i] + s[i+1:]\n    return s"
    },
    {
        "number": 572,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(p):\n        if p[0] == 0:\n            return False\n        for i in range(1, n):\n            if abs(p[i]) > k:\n                return False\n        return True\n\n    def count_ways(p):\n        if is_valid(p):\n            return 1\n        return sum(count_ways(q) for q in p)\n\n    return str(count_ways(a))\n"
    },
    {
        "number": 573,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_teams = 0\n    for i in range(n):\n        if a[i] == 1:\n            max_teams = max(max_teams, 1)\n        elif a[i] == 2:\n            max_teams = max(max_teams, 2)\n        else:\n            max_teams = max(max_teams, 3)\n\n    return str(max_teams)"
    },
    {
        "number": 574,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    if x1 > x2 or y1 > y2:\n        return \"Invalid input\"\n\n    num_cells = 0\n    for x in range(x1, x2 + 1):\n        for y in range(y1, y2 + 1):\n            if (x, y) in [(x1, y1), (x2, y2)]:\n                num_cells += 1\n\n    return str(num_cells)"
    },
    {
        "number": 575,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a_x, a_y = map(int, stdin.readline().strip().split())\n    b_x, b_y = map(int, stdin.readline().strip().split())\n    c_x, c_y = map(int, stdin.readline().strip().split())\n\n    if a_x == b_x and a_y == b_y:\n        return \"NO\"\n\n    if a_x == c_x and a_y == c_y:\n        return \"NO\"\n\n    if a_x == b_x and a_y == c_y:\n        return \"NO\"\n\n    if a_x == b_x and a_y == c_y:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 576,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_lcm = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            lcm = a[i] * a[j]\n            if lcm > max_lcm:\n                max_lcm = lcm\n\n    return str(max_lcm)"
    },
    {
        "number": 577,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    shrubs = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        shrubs.append((a, b))\n\n    def is_valid(basket):\n        total_red = sum(shrub[0] for shrub in basket)\n        total_blue = sum(shrub[1] for shrub in basket)\n        return total_red == k and total_blue == k\n\n    def max_baskets(shrubs):\n        max_baskets = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid(shrubs[i]) and is_valid(shrubs[j]):\n                    max_baskets += 1\n        return max_baskets\n\n    return str(max_baskets)\n"
    },
    {
        "number": 578,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d, b = map(int, stdin.split())\n    x = a * 10**b\n    if x == 0:\n        return \"0\"\n    elif x % 1 == 0:\n        return str(x)\n    else:\n        p, q = divmod(x, 1)\n        return f\"{p}.{q:.2f}\""
    },
    {
        "number": 579,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    P = list(map(int, stdin.split()))\n    C = list(map(int, stdin.split()))\n\n    max_score = 0\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if i == P[j - 1]:\n                score = C[j - 1]\n                max_score = max(max_score, score)\n\n    return str(max_score)"
    },
    {
        "number": 580,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        a, b, l = map(int, stdin.split())\n        roads.append((a, b, l))\n\n    def min_cost(roads, s, t):\n        def min_cost_helper(roads, s, t, visited, cost):\n            if s == t:\n                return cost\n            if s not in visited:\n                visited.add(s)\n                cost += roads[s][t]\n                if min_cost_helper(roads, roads[s][t], t, visited, cost):\n                    return True\n                visited.remove(s)\n            return False\n\n        visited = set()\n        cost = 0\n        return min_cost_helper(roads, s, t, visited, cost)\n\n    def min_cost_with_repair(roads, s, t):\n        min_cost_with_repair_helper(roads, s, t, 0, 0)\n        return min_cost_with_repair_helper(roads, s, t, 0, 0)\n\n    def min_cost_with_repair_helper(roads, s, t, cost, repair_cost):\n        if s == t:\n            return cost, repair_cost\n        if s not in visited:\n            visited.add(s)\n            cost += roads[s][t]\n            repair_cost += roads[s][t]\n            if min_cost_with_repair_helper(roads, roads[s][t], t, cost, repair_cost):\n                return True, repair_cost\n            visited.remove(s)\n        return False, repair_cost\n\n    visited = set()\n    cost, repair_cost = min_cost(roads, 1, 6), min_cost_with_repair(roads, 1, 6)\n    if cost == repair_cost:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 581,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def dfs(u, path):\n        if u == n - 1:\n            return path\n        dfs(u + 1, path + [u])\n        dfs(u + 1, path)\n\n    max_path = []\n    for u in range(n - 1):\n        path = []\n        dfs(u, path)\n        max_path.append(path)\n\n    max_path.append(n - 1)\n    max_path.sort(key=lambda x: sum(x))\n\n    max_answer = max_path[0][-1]\n    for i in range(1, len(max_path)):\n        max_answer = max(max_answer, max_path[i][-1])\n\n    return str(max_answer)\n"
    },
    {
        "number": 582,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    t = list(map(int, stdin.readline().strip().split()))\n\n    min_time = float('inf')\n    for i in range(n):\n        if len(a[i]) == 1:\n            min_time = min(min_time, t[i])\n\n    return str(min_time)"
    },
    {
        "number": 583,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    max_beauty = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                if s[i] == '(':\n                    max_beauty = max(max_beauty, i+1)\n                elif s[i] == ')':\n                    max_beauty = max(max_beauty, j-1)\n    return str(max_beauty)"
    },
    {
        "number": 584,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    string = stdin.strip()\n    words = string.split()\n    longest_word = \"\"\n    inside_parentheses = 0\n    for i in range(len(words)):\n        if words[i] == \"(\":\n            inside_parentheses += 1\n        elif words[i] == \")\":\n            inside_parentheses -= 1\n        if inside_parentheses == 0:\n            if len(words[i]) > len(longest_word):\n                longest_word = words[i]\n    return longest_word, len(words) - inside_parentheses"
    },
    {
        "number": 585,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Sort b in ascending order\n    b.sort()\n\n    # Calculate the number of ways to divide the array\n    ways = 0\n    for i in range(m):\n        ways += (b[i] - b[i - 1]) // (i + 1)\n\n    return str(ways % 998244353)"
    },
    {
        "number": 586,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = int(stdin.split())\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                for x in range(i - 1, -1, -1):\n                    if board[x][j] == 1:\n                        count += 1\n                        break\n                for x in range(i + 1, n):\n                    if board[x][j] == 1:\n                        count += 1\n                        break\n                for y in range(j - 1, -1, -1):\n                    if board[i][y] == 1:\n                        count += 1\n                        break\n                for y in range(j + 1, n):\n                    if board[i][y] == 1:\n                        count += 1\n                        break\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 587,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    satisfaction = 0\n    for i in range(N):\n        satisfaction += d_i\n    satisfaction += x * x\n    return str(satisfaction)"
    },
    {
        "number": 588,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    x_list = list(map(int, stdin.strip().split()))\n    x_list.sort()\n    x_min = x_list[0]\n    x_max = x_list[-1]\n    y_min = min(x_list)\n    y_max = max(x_list)\n\n    def move_engine(x: int, y: int, engine_id: int) -> tuple[int, int]:\n        if engine_id == 1:\n            return (x + x_list[1], y + y_list[1])\n        elif engine_id == 2:\n            return (x + x_list[2], y + y_list[2])\n        elif engine_id == 3:\n            return (x + x_list[3], y + y_list[3])\n        else:\n            return (x, y)\n\n    def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def max_distance(x1: int, y1: int, x2: int, y2: int) -> float:\n        max_distance = 0\n        for i in range(N):\n            x, y = move_engine(x1, y1, i)\n            distance_to_origin = distance(x, y, x2, y2)\n            max_distance = max(max_distance, distance_to_origin)\n        return max_distance\n\n    x1, y1 = x_list[0], y_list[0]\n    x2, y2 = x_list[-1], y_list[-1]\n    max_distance = max_distance(x1, y1, x2, y2)\n    return str(max_distance)"
    },
    {
        "number": 589,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hint = stdin.strip()\n    safe_code = hint[1:]\n    count = 0\n    for i in range(len(safe_code)):\n        if safe_code[i] == '?':\n            count += 1\n            if i > 0 and safe_code[i-1] == '?':\n                count += 1\n            if i < len(safe_code)-1 and safe_code[i+1] == '?':\n                count += 1\n    return str(count)"
    },
    {
        "number": 590,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the array in ascending order\n    a.sort()\n\n    # Initialize variables\n    i = 0\n    j = 1\n    q = 0\n\n    # Iterate through the array\n    while i < n and j < n:\n        # If the current element is smaller than the next element, swap them\n        if a[i] < a[j]:\n            a[i], a[j] = a[j], a[i]\n            i += 1\n            j += 1\n        # If the current element is equal to the next element, increment the counter\n        elif a[i] == a[j]:\n            q += 1\n            i += 1\n            j += 1\n        # If the current element is larger than the next element, increment the counter\n        else:\n            j += 1\n\n    # Print the result\n    print(q)\n\n    # Print the lexicographically minimal permutation\n    if q > 0:\n        permutation = []\n        i = n - 1\n        j = n - 1\n        while i >= 0 and j >= 0:\n            if a[i] == a[j]:\n                permutation.append(a[i])\n                i -= 1\n                j -= 1\n            elif a[i] < a[j]:\n                i -= 1\n            else:\n                j -= 1\n        print(*permutation, sep=' ')\n\n    return \"\""
    },
    {
        "number": 591,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = []\n    for i in range(n):\n        b.append(i + 1)\n    b.sort()\n    min_light = min(a)\n    for i in range(k):\n        if i == 0:\n            print(b[0])\n        else:\n            print(b[i], end=\" \")\n    return \"\""
    },
    {
        "number": 592,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 2:\n        return \"0\"\n\n    score = 0\n    for a in range(2, n + 1):\n        for b in range(2, n + 1):\n            if a == b:\n                continue\n\n            x = abs(a)\n            if 1 <= x <= |a| and (a * x == b or b * x == a):\n                score += x\n\n    return str(score)"
    },
    {
        "number": 593,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(m)]\n\n    # Count the number of votes for each candidate in each city\n    votes = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            votes[i][j] = a[i][j]\n\n    # Determine the winner of the elections\n    max_votes = 0\n    max_winner = 0\n    for i in range(m):\n        for j in range(n):\n            if votes[i][j] > max_votes:\n                max_votes = votes[i][j]\n                max_winner = j\n\n    return str(max_winner + 1)\n"
    },
    {
        "number": 594,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the minimum TL among all TLs\n    min_tl = float('inf')\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] + b[j - 1] <= min_tl:\n                min_tl = a[i - 1] + b[j - 1]\n\n    # Check if the minimum TL satisfies the conditions\n    if min_tl <= 2 * n * m:\n        return str(min_tl)\n    else:\n        return \"-1\""
    },
    {
        "number": 595,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin.strip())\n    if y < 1000 or y > 1000000:\n        return \"Invalid input\"\n\n    if y % 4 == 0 and (y % 100!= 0 or y % 400 == 0):\n        return str(y + 1)\n\n    return str(y)"
    },
    {
        "number": 596,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    dates = stdin.split('\\n')\n    dates = [date.strip() for date in dates]\n    dates = [date.split(':') for date in dates]\n    dates = [int(date[0]), int(date[1]), int(date[2])]\n\n    # Calculate days between dates\n    days = 0\n    for i in range(len(dates)):\n        if i == 0:\n            days += 365\n        elif i == 1:\n            days += 366\n        else:\n            days += 365 - dates[i-1]\n\n    return str(days)"
    },
    {
        "number": 597,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.split())\n        roads.append((u, v))\n\n    cities = set(map(int, stdin.split()))\n    time_needed = 0\n\n    for u, v in roads:\n        if u in cities and v in cities:\n            time_needed += 1\n            cities.remove(u)\n            cities.remove(v)\n\n    if not cities:\n        return \"0\"\n\n    min_city = min(cities)\n    time_needed += min_city\n\n    return str(min_city)\n"
    },
    {
        "number": 598,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    vouchers = []\n    for _ in range(n):\n        l, r, cost = map(int, stdin.split())\n        vouchers.append((l, r, cost))\n\n    def min_cost(vouchers):\n        total_duration = sum(v[1] - v[0] + 1 for v in vouchers)\n        total_cost = sum(v[2] for v in vouchers)\n        return total_duration * total_cost\n\n    def min_cost_two_vouchers(vouchers):\n        total_duration = sum(v[1] - v[0] + 1 for v in vouchers)\n        total_cost = sum(v[2] for v in vouchers)\n        if total_duration!= x:\n            return -1\n        if total_cost > 0:\n            return total_cost\n        return -1\n\n    vouchers.sort(key=lambda v: (v[0], v[1]))\n    if len(vouchers) < 2:\n        return -1\n\n    if min_cost(vouchers) < min_cost_two_vouchers(vouchers):\n        return min_cost(vouchers)\n    else:\n        return min_cost_two_vouchers(vouchers)"
    },
    {
        "number": 599,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) <= 1:\n        return \"NA\"\n\n    for i in range(len(s)):\n        if s[i]!= s[-i-1]:\n            return \"NA\"\n\n    return s + s[::-1]"
    },
    {
        "number": 600,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    tiredness = 1\n    while a!= b:\n        tiredness += 1\n        a, b = b, a + 1\n    return str(tiredness)"
    },
    {
        "number": 601,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, f = map(int, stdin.split())\n    cnt_s, cnt_w = map(int, stdin.split())\n    s, w = map(int, stdin.split())\n\n    max_weapons = min(p, f)\n    max_weapons -= cnt_s * s\n    max_weapons -= cnt_w * w\n\n    return str(max_weapons)"
    },
    {
        "number": 602,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 2:\n        return \"Adams\"\n    elif a == 8:\n        return \"Van Buren\"\n    elif a == 29:\n        return \"Harding\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 603,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b = map(int, stdin.split())\n    max_bouquets = 0\n\n    for i in range(1, 4):\n        for j in range(1, 4):\n            for k in range(1, 4):\n                if i + j + k <= r + g + b:\n                    max_bouquets += 1\n\n    return str(max_bouquets)\n"
    },
    {
        "number": 604,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Count the number of non-zero elements\n    count = 0\n    for i in range(n):\n        if a[i]!= 0:\n            count += 1\n\n    # Explode the array as fast as possible\n    if count == n:\n        return \"0\"\n\n    # Count the number of seconds needed to make all elements equal to zero\n    seconds = 0\n    for i in range(n):\n        if a[i] == 0:\n            seconds += 1\n\n    return str(seconds)\n"
    },
    {
        "number": 605,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a % 250!= 0 or b % 250!= 0:\n        return \"Invalid input\"\n\n    if c > d:\n        return \"Misha\"\n    elif c < d:\n        return \"Vasya\"\n    else:\n        return \"Tie\""
    },
    {
        "number": 606,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, x1, y1, x2, y2 = map(int, stdin.split())\n    x_ap = x1 + (x2 - x1) / 2\n    y_ap = y1 + (y2 - y1) / 2\n    r = min(x2 - x1, y2 - y1)\n    return f\"{x_ap:.6f} {y_ap:.6f} {r:.6f}\""
    },
    {
        "number": 607,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n > 250000 or m > 1000000:\n        return \"Error: n and m should be between 1 and 250000 and 1000000, respectively.\"\n\n    def is_permutation(p):\n        return all(p[i] == p[i + 1] for i in range(len(p) - 1))\n\n    def is_framed_segment(p):\n        return all(p[i] <= p[i + 1] for i in range(len(p) - 1))\n\n    def happiness(p):\n        return sum(1 for l, r in p if is_framed_segment(p[l:r + 1]))\n\n    def sum_of_happiness(n):\n        return sum(happiness(p) for p in permutations(n)) % m\n\n    return str(sum_of_happiness)\n\n\ndef"
    },
    {
        "number": 609,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    paper = []\n    for _ in range(n):\n        paper.append(stdin.strip())\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if paper[i][j] == paper[j][i]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 610,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    petya_points = 0\n    vasya_points = 0\n\n    for i in range(n):\n        petya_points += 1\n        vasya_points += 1\n\n    return str(petya_points) + \" \" + str(vasya_points)"
    },
    {
        "number": 611,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    changes = []\n    for _ in range(m):\n        x, d = map(int, stdin.split())\n        changes.append((x, d))\n\n    def arithmetic_mean(arr):\n        return sum(arr) / len(arr)\n\n    def max_average(changes):\n        max_sum = float('-inf')\n        max_count = 0\n        for x, d in changes:\n            count = sum(1 for i in range(n) if arr[i] + d * i > x)\n            sum_ = sum(arr[i] + d * i for i in range(n) if arr[i] + d * i > x)\n            max_sum = max(max_sum, sum_)\n            max_count = max(max_count, count)\n        return max_sum / max_count\n\n    arr = [0] * n\n    for x, d in changes:\n        for i in range(n):\n            arr[i] += x + d * i\n\n    return str(arithmetic_mean(arr))\n"
    },
    {
        "number": 612,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n % 2 == 0 or k % 2 == 0 or p % 2 == 0:\n        return \"NO\"\n\n    def even_sum(arr):\n        return sum(arr) % 2 == 0\n\n    def odd_sum(arr):\n        return sum(arr) % 2!= 0\n\n    def partition(arr, even_sum, odd_sum, p):\n        left, right = 0, len(arr) - 1\n        while left < right:\n            while left < right and not even_sum(arr[left:right + 1]):\n                left += 1\n            while left < right and not odd_sum(arr[left:right + 1]):\n                right -= 1\n            if left < right:\n                arr[left], arr[right] = arr[right], arr[left]\n                left += 1\n                right -= 1\n        return left\n\n    even_sum_parts = partition(a, even_sum, odd_sum, p)\n    odd_sum_parts = partition(a, even_sum, odd_sum, k - p)\n\n    if even_sum_parts == odd_sum_parts:\n        return \"YES\"\n\n    for i in range(even_sum_parts, odd_sum_parts + 1):\n        print(i, end=\" \")\n        for j in range(i, min(i + p, len(a))):\n            print(a[j], end=\" \")\n        print()\n\n    return \"YES\""
    },
    {
        "number": 613,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, a, b = map(int, stdin.split())\n    if t == 1 and a == 1 and b == 1:\n        return \"inf\"\n    else:\n        n = 0\n        while True:\n            P = a + b * n\n            if P == t:\n                return str(n)\n            n += 1"
    },
    {
        "number": 614,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    souvenirs = []\n    for _ in range(n):\n        w, c = map(int, stdin.split())\n        souvenirs.append((w, c))\n\n    max_weight = max(souvenirs, key=lambda x: x[0])[0]\n    max_cost = max(souvenirs, key=lambda x: x[1])[1]\n\n    return str(max_cost)"
    },
    {
        "number": 615,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    P = Q = R = S = 0\n    for a in A:\n        P += a\n        Q += a\n        R += a\n        S += a\n\n    max_val = min_val = abs(P)\n\n    for a in A:\n        if abs(a) > max_val:\n            max_val = abs(a)\n        if abs(a) < min_val:\n            min_val = abs(a)\n\n    return str(min_val)"
    },
    {
        "number": 616,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    min_cost = float('inf')\n    for i in range(N):\n        for j in range(M):\n            if a[j] <= i and b[j] <= i:\n                cost = a[j] * b[j]\n                if cost < min_cost:\n                    min_cost = cost\n\n    if min_cost == float('inf'):\n        return '-1'\n    else:\n        return str(min_cost)"
    },
    {
        "number": 617,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    expression = stdin.split()[1]\n    result = 0\n    for i in range(n):\n        if expression[i] == '+':\n            result += 1\n        elif expression[i] == '*':\n            result *= 10\n    return str(result)"
    },
    {
        "number": 618,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    scales = stdin.strip().split(\"|\")\n    weights = stdin.strip().split()\n\n    left_pan = []\n    right_pan = []\n\n    for weight in weights:\n        if weight == \"L\":\n            left_pan.append(weight)\n        elif weight == \"R\":\n            right_pan.append(weight)\n\n    total_weight = sum(left_pan) + sum(right_pan)\n\n    if total_weight!= 0:\n        return \"Impossible\"\n\n    for weight in left_pan:\n        if weight not in right_pan:\n            return \"Impossible\"\n\n    for weight in right_pan:\n        if weight not in left_pan:\n            return \"Impossible\"\n\n    return \"AC|\" + \"\".join(left_pan) + \"|\" + \"\".join(right_pan)\n"
    },
    {
        "number": 619,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, z = map(int, stdin.split())\n    max_coconuts = x + y\n    min_chizhiks = max(x, y)\n    return str(max_coconuts) + \" \" + str(min_chizhiks)"
    },
    {
        "number": 620,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n    x3, y3 = map(int, stdin.split())\n    x4, y4 = map(int, stdin.split())\n\n    # Check if points are on the same line\n    if x1 == x2 or x1 == x3 or x1 == x4 or y1 == y2 or y1 == y3 or y1 == y4:\n        return \"Error: Points are on the same line.\"\n\n    # Check if points are collinear\n    if x1 == x2 or x1 == x3 or x1 == x4 or y1 == y2 or y1 == y3 or y1 == y4:\n        return \"Error: Points are collinear.\"\n\n    # Check if points are in the same quadrant\n    if x1 < x2 and x1 < x3 and x1 < x4 and y1 < y2 and y1 < y3 and y1 < y4:\n        return \"Error: Points are in the same quadrant.\"\n\n    # Check if points are in the same triangle\n    if x1 < x2 and x1 < x3 or x1 < x4 and x1 < x2 or y1 < y2 and y1 < y3 or y1 < y4 and y1 < y2:\n        return \"Error: Points are in the same triangle.\"\n\n    # Check if points are in the same rectangle\n    if x1 < x2 and x1 < x3 and x1 < x4 or x1 < x2 and x1 < x3 and x1 < x4 or x1 < x2 and x1 < x3 and x1 < x4:\n        return \"Error: Points are in the same rectangle.\"\n\n    # Check if points are in the same hyperplane\n    if x1 * y2 + x2 * y1 + x3 * y4 + x4 * y3!= 0:\n        return \"Error: Points are in the same hyperplane.\"\n\n    # Check if points are in the same right triangle\n    if x1 < x2 and x1 < x3 or x1 < x4 and x1 < x2 or y1 < y2 and y1 < y3 or y1 < y4 and y1 < y2:\n        return \"Error: Points are in the same right triangle.\"\n\n    # Check if points are in the same left triangle\n    if x1 < x2 and x1 < x3 or x1 < x4 and x1 < x2 or y1 < y2 and y1 < y3 or y1 < y4 and y1 < y2:\n        return \"Error: Points are in the same left triangle.\"\n\n    # Check if points are in the same parallelogram\n    if x1 * y2 + x2 * y1 + x3 * y4 + x4 * y3 == 0:\n        return \"Error: Points are in the same parallelogram.\"\n\n    # Check if points are in the same right parallelogram\n    if x1 * y3 + x2 * y2 + x3 * y4 + x4 * y1!= 0:\n        return \"Error: Points are in the same right parallelogram.\"\n\n    # Check if points are in the same left parallelogram\n    if x1 * y3 + x2 * y2 + x3 * y4 + x4 * y1!= 0:\n        return \"Error: Points are in the same left parallelogram.\"\n\n    # Check if points are in the same right angle\n    if x1 * y2 + x2 * y3 + x3 * y4 + x4 * y1!= 0:\n        return \"Error: Points are in the same right angle.\"\n\n    # Check if points are in the same left angle\n    if x1 * y2 + x2 * y3 + x3 * y4 + x4 * y1!= 0:\n        return \"Error: Points are in the same left angle.\"\n\n    # Check if points are in the same right angle\n    if x1 * y3 + x2 * y1 + x3 * y4 + x4 * y2!= 0:\n        return \"Error: Points are in the same right angle.\"\n\n    # Check if points are in the same left angle\n    if x1 * y3 + x2 * y1 + x3 * y4 + x4 * y2!= 0:\n        return \"Error: Points are in the same left angle.\"\n\n    # Check if points are in the same right angle\n    if x1 * y1 + x2 * y2 + x3 * y3 + x4 * y4!= 0:\n        return \"Error: Points are in the same"
    },
    {
        "number": 621,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    k = min(n, len(a))\n    folders = [[] for _ in range(k)]\n    for i in range(k):\n        folders[i].append(a[i])\n    for i in range(1, k):\n        for j in range(i):\n            if folders[i][j] < 0:\n                folders[i].append(folders[i][j])\n                folders[i].pop(j)\n                break\n    folders.sort(key=lambda x: x[0])\n    result = []\n    for folder in folders:\n        result.append(\" \".join(map(str, folder)))\n    return \"\\n\".join(result)"
    },
    {
        "number": 622,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [1]\n    for i in range(1, n):\n        sequence.append(sequence[i-1] + sequence[i-2])\n        sequence.insert(i-1, min(sequence[i-1], sequence[i-2]))\n    return str(sequence[k-1])"
    },
    {
        "number": 623,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    max_minutes = 0\n    minutes = 0\n    while True:\n        minutes += 1\n        if a_1 > 0:\n            a_1 -= 1\n        if a_2 > 0:\n            a_2 -= 1\n        if a_1 == 0 and a_2 == 0:\n            break\n        if a_1 > 100 or a_2 > 100:\n            break\n        max_minutes = max(max_minutes, minutes)\n    return str(max_minutes)"
    },
    {
        "number": 624,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_power = max(a)\n    max_avg = 0\n\n    for i in range(n):\n        if i < k:\n            max_power = max(max_power, a[i])\n        else:\n            max_power = max(max_power, a[i] + 1)\n\n        if i < m:\n            max_avg = max(max_avg, a[i] + 1)\n\n    return str(max_avg)"
    },
    {
        "number": 625,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = -1 + 2 - 3 + 4 + 5\n    return str(result)"
    },
    {
        "number": 626,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    a.sort()\n    changes = 0\n    for i in range(n):\n        if i == 0:\n            changes += 1\n        else:\n            changes += abs(a[i] - a[i-1])\n    return str(changes)"
    },
    {
        "number": 627,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    s = ''.join(sorted(set(s), key=lambda x: (-len(x), x)))\n    return s"
    },
    {
        "number": 628,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    books = list(map(int, stdin.split()))\n    max_beauty = 0\n\n    for i in range(k):\n        max_beauty += books[i]\n\n    return str(max_beauty)"
    },
    {
        "number": 629,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    # Calculate the waiting time for each crossing\n    waiting_time = [0] * (n * (n - 1))\n    waiting_time[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            waiting_time[i * (n - 1) + j] = a[i - 1] + b[j]\n\n    # Find the minimum total time\n    min_time = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_time = min(min_time, waiting_time[i * (n - 1) + j])\n\n    return str(min_time)\n"
    },
    {
        "number": 630,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    messages = list(map(int, stdin.split()))\n    messages.sort()\n    links = [0] * n\n    for i in range(1, n):\n        links[i] = messages[i - 1] + 1\n    result = []\n    for i in range(n):\n        if i >= k:\n            result.append(i)\n    return''.join(map(str, result))"
    },
    {
        "number": 631,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if sum(a)!= m:\n        return \"NO\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            a[j] -= a[i]\n\n    if sum(a) == m:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 632,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        n = n + k\n        print(n)"
    },
    {
        "number": 633,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n < 1 or n > 10**5 or m < 1 or m > 10**5:\n        return \"Impossible\"\n\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, n + 1):\n        if graph[i]:\n            for j in graph[i]:\n                if j!= i:\n                    return \"Impossible\"\n\n    return \"Possible\""
    },
    {
        "number": 634,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, n = map(int, stdin.split())\n    reclaimed = set()\n    for _ in range(n):\n        r1, c1 = map(int, stdin.split())\n        reclaimed.add((r1, c1))\n    for _ in range(r - 1):\n        for _ in range(2):\n            r1, c1 = map(int, stdin.split())\n            if (r1, c1) not in reclaimed:\n                reclaimed.add((r1, c1))\n    for _ in range(r):\n        for _ in range(2):\n            r1, c1 = map(int, stdin.split())\n            if (r1, c1) not in reclaimed:\n                reclaimed.add((r1, c1))\n    for _ in range(r + 1):\n        for _ in range(2):\n            r1, c1 = map(int, stdin.split())\n            if (r1, c1) not in reclaimed:\n                reclaimed.add((r1, c1))\n    for _ in range(r):\n        for _ in range(2):\n            r1, c1 = map(int, stdin.split())\n            if (r1, c1) not in reclaimed:\n                reclaimed.add((r1, c1))\n    if len(reclaimed) == r * 2:\n        return \"WIN\"\n    else:\n        return \"LOSE\""
    },
    {
        "number": 635,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Initialize visited and closed stations\n    visited = [False] * n\n    closed = [False] * n\n\n    # Initialize visited and closed stations\n    visited[1] = True\n    closed[1] = True\n\n    # Initialize visited and closed stations\n    visited[2] = True\n    closed[2] = True\n\n    # Initialize visited and closed stations\n    visited[3] = True\n    closed[3] = True\n\n    # Initialize visited and closed stations\n    visited[4] = True\n    closed[4] = True\n\n    # Initialize visited and closed stations\n    visited[5] = True\n    closed[5] = True\n\n    # Initialize visited and closed stations\n    visited[6] = True\n    closed[6] = True\n\n    # Initialize visited and closed stations\n    visited[7] = True\n    closed[7] = True\n\n    # Initialize visited and closed stations\n    visited[8] = True\n    closed[8] = True\n\n    # Initialize visited and closed stations\n    visited[9] = True\n    closed[9] = True\n\n    # Initialize visited and closed stations\n    visited[10] = True\n    closed[10] = True\n\n    # Initialize visited and closed stations\n    visited[11] = True\n    closed[11] = True\n\n    # Initialize visited and closed stations\n    visited[12] = True\n    closed[12] = True\n\n    # Initialize visited and closed stations\n    visited[13] = True\n    closed[13] = True\n\n    # Initialize visited and closed stations\n    visited[14] = True\n    closed[14] = True\n\n    # Initialize visited and closed stations\n    visited[15] = True\n    closed[15] = True\n\n    # Initialize visited and closed stations\n    visited[16] = True\n    closed[16] = True\n\n    # Initialize visited and closed stations\n    visited[17] = True\n    closed[17] = True\n\n    # Initialize visited and closed stations\n    visited[18] = True\n    closed[18] = True\n\n    # Initialize visited and closed stations\n    visited[19] = True\n    closed[19] = True\n\n    # Initialize visited and closed stations\n    visited[20] = True\n    closed[20] = True\n\n    # Initialize visited and closed stations\n    visited[21] = True\n    closed[21] = True\n\n    # Initialize visited and closed stations\n    visited[22] = True\n    closed[22] = True\n\n    # Initialize visited and closed stations\n    visited[23] = True\n    closed[23] = True\n\n    # Initialize visited and closed stations\n    visited[24] = True\n    closed[24] = True\n\n    # Initialize visited and closed stations\n    visited[25] = True\n    closed[25] = True\n\n    # Initialize visited and closed stations\n    visited[26] = True\n    closed[26] = True\n\n    # Initialize visited and closed stations\n    visited[27] = True\n    closed[27] = True\n\n    # Initialize visited and closed stations\n    visited[28] = True\n    closed[28] = True\n\n    # Initialize visited and closed stations\n    visited[29] = True\n    closed[29] = True\n\n    # Initialize visited and closed stations\n    visited[30] = True\n    closed[30] = True\n\n    # Initialize visited and closed stations\n    visited[31] = True\n    closed[31] = True\n\n    # Initialize visited and closed stations\n    visited[32] = True\n    closed[32] = True\n\n    # Initialize visited and closed stations\n    visited[33] = True\n    closed[33] = True\n\n    # Initialize visited and closed stations\n    visited[34] = True\n    closed[34] = True\n\n    # Initialize visited and closed stations\n    visited[35] = True\n    closed[35] = True\n\n    # Initialize visited and closed stations\n    visited[36] = True\n    closed[36] = True\n\n    # Initialize visited and closed stations\n    visited[37] = True\n    closed[37] = True\n\n    # Initialize visited and closed stations\n    visited[38] = True\n    closed[38] = True\n\n    # Initialize visited and closed stations\n    visited[39] = True\n    closed[39] = True\n\n    # Initialize visited and closed stations\n    visited[40] = True\n    closed[40] = True\n\n    # Initialize visited and closed stations\n    visited[41] = True\n    closed[41] = True\n\n    # Initialize visited and closed stations\n    visited[42] = True\n    closed[42] = True\n\n    # Initialize visited and closed stations\n    visited[43] ="
    },
    {
        "number": 636,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Sort the list of days in ascending order\n    a.sort()\n\n    # Initialize the maximum number of instruments\n    max_instruments = 0\n\n    # Iterate through the list of days\n    for i in range(1, len(a)):\n        # Calculate the number of days required to learn the i-th instrument\n        days_to_learn = a[i] - a[i-1]\n\n        # If the number of days required to learn the i-th instrument is less than or equal to k,\n        # then the i-th instrument can be learnt\n        if days_to_learn <= k:\n            max_instruments += 1\n\n    # Output the maximum number of instruments\n    print(max_instruments)\n\n    # Initialize an empty list to store the indices of instruments to be learnt\n    indices = []\n\n    # Iterate through the list of days\n    for i in range(1, len(a)):\n        # Calculate the number of days required to learn the i-th instrument\n        days_to_learn = a[i] - a[i-1]\n\n        # If the number of days required to learn the i-th instrument is less than or equal to k,\n        # then the i-th instrument can be learnt\n        if days_to_learn <= k:\n            indices.append(i)\n\n    # Output the indices of instruments to be learnt\n    print(\" \".join(map(str, indices)))\n\n    return \"\""
    },
    {
        "number": 637,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"YES\" if a[0] == 1 else \"NO\"\n\n    if n == 2:\n        return \"YES\" if a[0] == 1 and a[1] == 1 else \"NO\"\n\n    if n == 3:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 else \"NO\"\n\n    if n == 4:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 else \"NO\"\n\n    if n == 5:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 and a[4] == 1 else \"NO\"\n\n    if n == 6:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 and a[4] == 1 and a[5] == 1 else \"NO\"\n\n    if n == 7:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 and a[4] == 1 and a[5] == 1 and a[6] == 1 else \"NO\"\n\n    if n == 8:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 and a[4] == 1 and a[5] == 1 and a[6] == 1 and a[7] == 1 else \"NO\"\n\n    if n == 9:\n        return \"YES\" if a[0] == 1 and a[1] == 1 and a[2] == 1 and a[3] == 1 and a[4] == 1 and a[5] == 1 and a[6] == 1 and a[7] == 1 and a[8] == 1 else \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 638,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    # Count the minimum number of students who need to fail the exam\n    count = [0] * n\n    for i in range(n):\n        count[i] = i + 1\n\n    # Find the answer independently\n    for i in range(n):\n        for j in range(i + 1, n):\n            if t[i] + t[j] <= M:\n                count[i] = min(count[i], count[j])\n\n    # Print the result\n    result = []\n    for i in range(n):\n        result.append(count[i])\n    return''.join(map(str, result))\n"
    },
    {
        "number": 639,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    evil_set = set(range(n))\n    evil_set.remove(x)\n    evil_set.add(x)\n    return str(len(evil_set))"
    },
    {
        "number": 640,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    ways = 0\n    if a == b:\n        ways += 1\n    else:\n        for i in range(1, 7):\n            if abs(a - i) < abs(b - i):\n                ways += 1\n                break\n    return str(ways) + \" \" + str(ways == 1) + \" \" + str(ways == 2)"
    },
    {
        "number": 641,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_str = stdin.strip()\n    day_of_week = int(input_str.split()[0])\n    day_of_month = int(input_str.split()[1])\n\n    # Calculate number of candies\n    if day_of_week == 4:\n        num_candy = 52\n    elif day_of_month == 30:\n        num_candy = 11\n    else:\n        num_candy = 0\n\n    # Print result\n    return str(num_candy)"
    },
    {
        "number": 642,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stairs = list(map(int, stdin.split()))\n    dirty_stairs = list(map(int, stdin.split()))\n\n    # Find the last stair number\n    last_stair = n - 1\n\n    # Check if the last stair is dirty\n    if dirty_stairs[last_stair] == 1:\n        return \"NO\"\n\n    # Check if Petya can reach the last stair\n    for i in range(last_stair - 1, -1, -1):\n        if stairs[i] == dirty_stairs[i]:\n            continue\n        else:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 643,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        x, y, p, q = map(int, stdin.readline().strip().split())\n        if p / q!= 1:\n            continue\n        if x + y > 10**9:\n            continue\n        if x + y == 10**9:\n            return \"1\"\n        if x + y == 10**10:\n            return \"0\"\n        if x + y == 10**11:\n            return \"-1\"\n        if x + y == 10**12:\n            return \"-1\"\n        if x + y == 10**13:\n            return \"-1\"\n        if x + y == 10**14:\n            return \"-1\"\n        if x + y == 10**15:\n            return \"-1\"\n        if x + y == 10**16:\n            return \"-1\"\n        if x + y == 10**17:\n            return \"-1\"\n        if x + y == 10**18:\n            return \"-1\"\n        if x + y == 10**19:\n            return \"-1\"\n        if x + y == 10**20:\n            return \"-1\"\n        if x + y == 10**21:\n            return \"-1\"\n        if x + y == 10**22:\n            return \"-1\"\n        if x + y == 10**23:\n            return \"-1\"\n        if x + y == 10**24:\n            return \"-1\"\n        if x + y == 10**25:\n            return \"-1\"\n        if x + y == 10**26:\n            return \"-1\"\n        if x + y == 10**27:\n            return \"-1\"\n        if x + y == 10**28:\n            return \"-1\"\n        if x + y == 10**29:\n            return \"-1\"\n        if x + y == 10**30:\n            return \"-1\"\n        if x + y == 10**31:\n            return \"-1\"\n        if x + y == 10**32:\n            return \"-1\"\n        if x + y == 10**33:\n            return \"-1\"\n        if x + y == 10**34:\n            return \"-1\"\n        if x + y == 10**35:\n            return \"-1\"\n        if x + y == 10**36:\n            return \"-1\"\n        if x + y == 10**37:\n            return \"-1\"\n        if x + y == 10**38:\n            return \"-1\"\n        if x + y == 10**39:\n            return \"-1\"\n        if x + y == 10**40:\n            return \"-1\"\n        if x + y == 10**41:\n            return \"-1\"\n        if x + y == 10**42:\n            return \"-1\"\n        if x + y == 10**43:\n            return \"-1\"\n        if x + y == 10**44:\n            return \"-1\"\n        if x + y == 10**45:\n            return \"-1\"\n        if x + y == 10**46:\n            return \"-1\"\n        if x + y == 10**47:\n            return \"-1\"\n        if x + y == 10**48:\n            return \"-1\"\n        if x + y == 10**49:\n            return \"-1\"\n        if x + y == 10**50:\n            return \"-1\"\n        if x + y == 10**51:\n            return \"-1\"\n        if x + y == 10**52:\n            return \"-1\"\n        if x + y == 10**53:\n            return \"-1\"\n        if x + y == 10**54:\n            return \"-1\"\n        if x + y == 10**55:\n            return \"-1\"\n        if x + y == 10**56:\n            return \"-1\"\n        if x + y == 10**57:\n            return \"-1\"\n        if x + y == 10**58:\n            return \"-1\"\n        if x + y == 10**59:\n            return \"-1\"\n        if x + y == 10**60:\n            return \"-1\"\n        if x + y == 10**61:\n            return \"-1\"\n        if x + y =="
    },
    {
        "number": 644,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = 0\n    for i in range(n):\n        command = stdin.strip()\n        if command == \"for\":\n            n = int(stdin.strip())\n            x = 0\n        elif command == \"end\":\n            n = int(stdin.strip())\n            for _ in range(n):\n                x += 1\n        elif command == \"add\":\n            x += 1\n    if x > 2**32 - 1:\n        return \"OVERFLOW!!!\"\n    else:\n        return str(x)"
    },
    {
        "number": 645,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(n):\n        card = input()\n        if card[0] in 'aeiou' and card[1] % 2 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 646,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = [int(stdin.strip()) for _ in range(n)]\n    t = 100\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if x[i] == x[j]:\n                t = min(t, j - i)\n    return str(t)"
    },
    {
        "number": 647,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    students = []\n    for i in range(n):\n        students.append(i + 1)\n\n    def seat_students(students):\n        left_seats = [i for i, student in enumerate(students) if student % 2 == 1]\n        right_seats = [i for i, student in enumerate(students) if student % 2 == 0]\n\n        if len(left_seats) == 0:\n            return [students[0]]\n        elif len(right_seats) == 0:\n            return [students[-1]]\n        else:\n            return [left_seats[0], right_seats[-1]]\n\n    result = []\n    for i in range(n // 2):\n        result.append(seat_students(students))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 648,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, b = map(int, stdin.split())\n    x = 0\n    y = 0\n    max_bananas = 0\n\n    while x <= m and y <= m:\n        if x == 0 or y == 0:\n            max_bananas = max(max_bananas, b)\n        else:\n            max_bananas = max(max_bananas, b - (x + y))\n\n        x += 1\n        y += 1\n\n    return str(max_bananas)\n"
    },
    {
        "number": 649,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = list(map(int, stdin.strip().split()))\n    visited = set()\n\n    def count_visited_cells(level: int, cell: int) -> int:\n        if level == n:\n            return 1\n\n        if cell in visited:\n            return 0\n\n        visited.add(cell)\n        count = 0\n        for i in range(2 ** level):\n            count += count_visited_cells(level + 1, cell + i)\n        return count\n\n    count = 0\n    for level in range(n):\n        count += count_visited_cells(level, 0)\n\n    return str(count)"
    },
    {
        "number": 650,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) > 10:\n        return \"NO\"\n    for char in stdin:\n        if char not in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 651,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    maze = []\n    for _ in range(m):\n        maze.append(stdin.strip())\n\n    start_pos = (0, 0)\n    exit_pos = (n - 1, m - 1)\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    visited = set()\n    mapping = {}\n\n    def dfs(pos, visited):\n        if pos == exit_pos:\n            return True\n\n        if pos in visited:\n            return False\n\n        visited.add(pos)\n        for direction in directions:\n            new_pos = (pos[0] + direction[0], pos[1] + direction[1])\n            if 0 <= new_pos[0] < n and 0 <= new_pos[1] < m and maze[new_pos[0]][new_pos[1]] == '#':\n                if not dfs(new_pos, visited):\n                    return False\n\n        mapping[pos] = directions\n        return True\n\n    if not dfs(start_pos, set()):\n        return \"No valid mapping found\"\n\n    return str(len(mapping))\n"
    },
    {
        "number": 652,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        points.append((x, y))\n\n    def is_parallel(p1, p2, p3):\n        return (p1[0] * p2[1] - p1[1] * p2[0]) == (p2[0] * p3[1] - p2[1] * p3[0])\n\n    parallelograms = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_parallel(points[i], points[j], points[k]):\n                    parallelograms.add((i, j, k))\n\n    return str(len(parallelograms))\n"
    },
    {
        "number": 653,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    events = []\n    for _ in range(n):\n        event = stdin.strip()\n        events.append(event)\n\n    hotel_room_assignment = [0] * 10\n    for event in events:\n        if event == 'L':\n            hotel_room_assignment[0] += 1\n        elif event == 'R':\n            hotel_room_assignment[9] += 1\n        elif event == '0':\n            hotel_room_assignment[int(event)] = 0\n        elif event == '1':\n            hotel_room_assignment[int(event)] = 1\n\n    result = ''\n    for room in hotel_room_assignment:\n        if room == 0:\n            result += '0'\n        elif room == 1:\n            result += '1'\n        else:\n            result += str(room)\n\n    return result"
    },
    {
        "number": 654,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    trie = {}\n    for i in range(n):\n        s = input()\n        trie[s] = []\n    max_matching = 0\n    for s in trie:\n        for t in trie[s]:\n            if s == t:\n                continue\n            if s + t in trie:\n                max_matching = max(max_matching, len(trie[s + t]) + len(trie[t]))\n    return str(max_matching % (10**9 + 7))"
    },
    {
        "number": 655,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = int(stdin.strip())\n    y = int(stdin.strip())\n\n    if x == 1 and y == 1:\n        return \"White\"\n    elif x == n and y == n:\n        return \"Black\"\n    else:\n        return \"White\""
    },
    {
        "number": 656,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    # Initialize variables\n    t_min = float('inf')\n    t_max = float('-inf')\n    t_change = 0\n\n    # Iterate through the winter days\n    for i in range(n):\n        # Check if the average temperature is negative\n        if t[i] < 0:\n            # Check if the temperature is within the range of winter tires\n            if t[i] >= t_min and t[i] <= t_max:\n                # Update the minimum temperature\n                t_min = min(t_min, t[i])\n                # Update the maximum temperature\n                t_max = max(t_max, t[i])\n                # Update the number of tires' changes\n                t_change += 1\n\n    # Check if it is impossible to drive safely during the winter\n    if t_change == 0:\n        return '-1'\n\n    # Calculate the minimum number of times Vasya has to change summer tires to winter tires and vice versa\n    t_change_winter = t_change // 2\n    t_change_summer = t_change - t_change_winter\n\n    # Print the result\n    print(t_change_winter)\n    print(t_change_summer)\n\n    return str(t_change_winter) +'' + str(t_change_summer)\n"
    },
    {
        "number": 657,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    x, y, z = map(int, stdin.split())\n\n    yellow_crystals = A\n    blue_crystals = B\n\n    yellow_balls = 2\n    green_balls = 1\n    blue_balls = 1\n\n    if yellow_crystals >= 2 and blue_crystals >= 3:\n        yellow_balls += 1\n        green_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 3 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 4 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 5 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 6 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 7 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 8 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 9 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 10 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 11 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 12 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 13 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 14 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 15 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 16 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 17 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 18 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 19 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 20 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 21 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 22 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 23 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 24 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 25 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 26 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue_balls += 1\n\n    if yellow_crystals >= 27 and blue_crystals >= 3:\n        yellow_balls += 1\n        blue"
    },
    {
        "number": 658,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, v, u = map(int, stdin.split())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        polygon.append((x, y))\n\n    t = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if polygon[i][0] * polygon[j][1] < 0:\n                t += abs(polygon[i][0] - polygon[j][0]) / v\n\n    return str(t)\n"
    },
    {
        "number": 659,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Check if the array is sorted\n    if a[0] > a[1]:\n        return \"-1\"\n\n    # Check if the array has at least one pair of distinct integers\n    for i in range(1, n):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] > a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] > a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] < a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] < a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i - 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(1, n - 1):\n        if a[i] == a[i + 1]:\n            return \"-1\"\n\n    # Check if the array has at least one pair of integers that can be swapped\n    for i in range(n - 2, 0, -1):\n        if a[i] == a[i + "
    },
    {
        "number": 660,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, p = map(int, stdin.split())\n    x = 0\n    y = 0\n    for i in range(n):\n        x += b\n        y += p\n    return str(x) + \" \" + str(y)"
    },
    {
        "number": 661,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, K = map(int, stdin.split())\n    a = [0] * (2 ** (M + 1))\n    a[0] = 1\n    for i in range(1, 2 ** (M + 1)):\n        a[i] = a[i - 1] ^ a[i - 2] ^ a[i - 4] ^ a[i - 8] ^ a[i - 16] ^ a[i - 32] ^ a[i - 64] ^ a[i - 128] ^ a[i - 256] ^ a[i - 512] ^ a[i - 1024] ^ a[i - 2048] ^ a[i - 4096] ^ a[i - 8192] ^ a[i - 16384] ^ a[i - 32768] ^ a[i - 65536] ^ a[i - 131072] ^ a[i - 262144] ^ a[i - 524288] ^ a[i - 1048576] ^ a[i - 2097152] ^ a[i - 4194304] ^ a[i - 8388608] ^ a[i - 16777216] ^ a[i - 33554432] ^ a[i - 67108864] ^ a[i - 134217728] ^ a[i - 268435456] ^ a[i - 536870912] ^ a[i - 1073741824] ^ a[i - 2147483648] ^ a[i - 4294967296] ^ a[i - 8589934592] ^ a[i - 17179869184] ^ a[i - 34359738368] ^ a[i - 68719476736] ^ a[i - 137438953472] ^ a[i - 274877906944] ^ a[i - 549755813888] ^ a[i - 1099511627776] ^ a[i - 2199023255552] ^ a[i - 4398046511104] ^ a[i - 8796093022208] ^ a[i - 17592186044416] ^ a[i - 35184372088832] ^ a[i - 70368744177664] ^ a[i - 140737488355328] ^ a[i - 281474976710656] ^ a[i - 562949953421312] ^ a[i - 1125899906842624] ^ a[i - 2251799813685248] ^ a[i - 4503599627370496] ^ a[i - 9007199254740992] ^ a[i - 18014398509481984] ^ a[i - 36028797018963968] ^ a[i - 72057594037927936] ^ a[i - 144115188075855872] ^ a[i - 288230376151711744] ^ a[i - "
    },
    {
        "number": 662,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    games = []\n    for _ in range(n):\n        a = int(stdin.readline())\n        games.append(a)\n\n    def is_possible(games):\n        if len(games) < 3:\n            return False\n\n        for i in range(len(games) - 2):\n            if games[i] == 1 and games[i + 1] == 2 and games[i + 2] == 3:\n                return True\n\n        return False\n\n    if is_possible(games):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 663,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, x, y, x_new, y_new = map(int, stdin.split())\n    x_new, y_new = x_new, y_new\n\n    steps = 0\n    while x_new!= x or y_new!= y:\n        steps += 1\n        x_new, y_new = x_new - x, y_new - y\n\n    return str(steps)"
    },
    {
        "number": 664,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"0\"\n\n    if n == 2:\n        return \"1\"\n\n    if n == 3:\n        if a[0] > a[1] or a[0] > a[2]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 4:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 5:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 6:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 7:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 8:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5] or a[5] > a[6]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 9:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5] or a[5] > a[6] or a[6] > a[7]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 10:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5] or a[5] > a[6] or a[6] > a[7] or a[7] > a[8]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 11:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5] or a[5] > a[6] or a[6] > a[7] or a[7] > a[8] or a[8] > a[9]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 12:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5] or a[5] > a[6] or a[6] > a[7] or a[7] > a[8] or a[8] > a[9] or a[9] > a[10]:\n            return \"-1\"\n        else:\n            return \"0\"\n\n    if n == 13:\n        if a[0] > a[1] or a[0] > a[2] or a[1] > a[2] or a[2] > a[3] or a[3] > a[4] or a[4] > a[5] or a[5] > a[6] or a[6] > a[7] or a[7] > a[8] or a[8] > a[9] or a["
    },
    {
        "number": 665,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    t = int(stdin.strip())\n\n    presents = [0] * n\n    for i in range(n):\n        presents[i] = a[i]\n\n    for _ in range(t):\n        skip = 0\n        for i in range(n):\n            if presents[i] > s:\n                skip += 1\n                presents[i] -= s\n\n        if skip == n:\n            return \"0\"\n        elif skip > 0:\n            return str(skip)\n        else:\n            return \"0\""
    },
    {
        "number": 666,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sequence = [1]\n    for i in range(2, n+1):\n        sequence.append(sequence[-1] + i)\n    return str(sequence[n])"
    },
    {
        "number": 667,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b, c = map(int, stdin.readline().split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    max_length = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            length = graph[i][j][1]\n            if length > max_length:\n                max_length = length\n    return str(max_length)"
    },
    {
        "number": 668,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"-1\"\n\n    k = 0\n    for i in range(1, n + 1):\n        if i == 1:\n            continue\n        if a[i - 1] <= a[i]:\n            k += 1\n\n    if k == 0:\n        return \"-1\"\n\n    result = []\n    for i in range(k):\n        f, t = i + 1, i + 2\n        if f > n or t > n:\n            break\n        result.append(f)\n        result.append(t)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 669,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    k = len(a)\n    b = [0] * k\n\n    for i in range(k):\n        b[i] = i + 1\n\n    max_sum = 0\n    for i in range(k):\n        for j in range(i + 1, k):\n            max_sum = (max_sum + a[b[i]] + a[b[j]]) % m\n\n    return str(max_sum)"
    },
    {
        "number": 670,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    if a == 0 and b == 0:\n        return \"0\"\n\n    if a == 0:\n        x1, y1 = x2, y2\n\n    if b == 0:\n        x2, y2 = x1, y1\n\n    if x1 == x2:\n        x1 -= 1\n\n    if y1 == y2:\n        y1 -= 1\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx == 0:\n        return str(abs(y2 - y1))\n\n    if dy == 0:\n        return str(abs(x2 - x1))\n\n    if dx > dy:\n        x = x1\n        y = y1\n        x1 = x2\n        x2 = x\n        y1 = y2\n        y2 = y\n    else:\n        x = x1\n        y = y1\n        x1 = y2\n        y1 = y2\n        x2 = x\n        y2 = x\n\n    if x1 == x2:\n        x1 -= 1\n\n    if y1 == y2:\n        y1 -= 1\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx == 0:\n        return str(abs(y2 - y1))\n\n    if dy == 0:\n        return str(abs(x2 - x1))\n\n    if dx > dy:\n        x = x1\n        y = y1\n        x1 = x2\n        x2 = x\n        y1 = y2\n        y2 = y\n    else:\n        x = x1\n        y = y1\n        x1 = y2\n        y1 = y2\n        x2 = x\n        y2 = x\n\n    if x1 == x2:\n        x1 -= 1\n\n    if y1 == y2:\n        y1 -= 1\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx == 0:\n        return str(abs(y2 - y1))\n\n    if dy == 0:\n        return str(abs(x2 - x1))\n\n    if dx > dy:\n        x = x1\n        y = y1\n        x1 = x2\n        x2 = x\n        y1 = y2\n        y2 = y\n    else:\n        x = x1\n        y = y1\n        x1 = y2\n        y1 = y2\n        x2 = x\n        y2 = x\n\n    if x1 == x2:\n        x1 -= 1\n\n    if y1 == y2:\n        y1 -= 1\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx == 0:\n        return str(abs(y2 - y1))\n\n    if dy == 0:\n        return str(abs(x2 - x1))\n\n    if dx > dy:\n        x = x1\n        y = y1\n        x1 = x2\n        x2 = x\n        y1 = y2\n        y2 = y\n    else:\n        x = x1\n        y = y1\n        x1 = y2\n        y1 = y2\n        x2 = x\n        y2 = x\n\n    if x1 == x2:\n        x1 -= 1\n\n    if y1 == y2:\n        y1 -= 1\n\n    if x1 > x2:\n        x1, x2 = x2, x1\n        y1, y2 = y2, y1\n\n    dx = x2 - x1\n    dy = y2 - y1\n\n    if dx == 0:\n        return str(abs(y2 - y1))\n\n    if dy == 0:\n        return str(abs(x2 - x1))\n\n    if dx > dy:\n        x = x1\n        y = y1\n        x1 = x2\n        x2 = x\n        y1 = y2\n        y2 = y\n    else:\n        x = x1\n        y = y1\n        x1 = y2\n        y1 = y2\n        x2 = x\n        y2"
    },
    {
        "number": 671,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return str(n)"
    },
    {
        "number": 672,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0 or b == 0:\n        return \"infinity\"\n\n    count = 0\n    for i in range(1, a + 1):\n        if i % b == 0:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 673,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = n // k\n    return str(x)"
    },
    {
        "number": 674,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    strings = set()\n    for _ in range(n):\n        strings.add(stdin.strip())\n\n    good_strings = []\n    for s in strings:\n        if s in strings:\n            continue\n        if len(s) < min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s), min(len(s),"
    },
    {
        "number": 675,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, t, r = map(int, stdin.split())\n    ghosts = []\n    for _ in range(m):\n        w = int(stdin.readline())\n        ghosts.append(w)\n\n    min_candles = float('inf')\n    for i in range(1, len(ghosts)):\n        if ghosts[i] - ghosts[i - 1] >= t:\n            min_candles = min(min_candles, i)\n\n    return str(min_candles) if min_candles!= float('inf') else '-1'"
    },
    {
        "number": 676,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = []\n\n    for i in range(n):\n        if i < n - 1:\n            b.append(a[i] + a[i + 1])\n        else:\n            b.append(a[i])\n\n    if sum(b) == 1000:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 677,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.strip())\n    for _ in range(q):\n        l, r, d = map(int, stdin.strip().split())\n        x = min(l, r)\n        if x % d == 0 and x not in [l, r]:\n            print(x)"
    },
    {
        "number": 678,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 0\n    for i in range(n):\n        x = int(stdin.strip())\n        if x == 0:\n            result += 1\n    return str(result)"
    },
    {
        "number": 679,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    rows = len(s)\n    cols = len(s[0])\n    visited = [[False] * cols for _ in range(rows)]\n\n    for i in range(rows):\n        for j in range(cols):\n            if s[i][j] == 'A':\n                visited[i][j] = True\n                if i > 0 and not visited[i-1][j] and s[i-1][j] == 'B':\n                    visited[i][j] = True\n                if i < rows-1 and not visited[i+1][j] and s[i+1][j] == 'B':\n                    visited[i][j] = True\n                if j > 0 and not visited[i][j-1] and s[i][j-1] == 'C':\n                    visited[i][j] = True\n                if j < cols-1 and not visited[i][j+1] and s[i][j+1] == 'C':\n                    visited[i][j] = True\n\n    for i in range(rows):\n        for j in range(cols):\n            if s[i][j] == 'B':\n                if i > 0 and not visited[i-1][j] and s[i-1][j] == 'A':\n                    return 'No'\n                if i < rows-1 and not visited[i+1][j] and s[i+1][j] == 'A':\n                    return 'No'\n                if j > 0 and not visited[i][j-1] and s[i][j-1] == 'A':\n                    return 'No'\n                if j < cols-1 and not visited[i][j+1] and s[i][j+1] == 'A':\n                    return 'No'\n\n    for i in range(rows):\n        for j in range(cols):\n            if s[i][j] == 'C':\n                if i > 0 and not visited[i-1][j] and s[i-1][j] == 'A':\n                    return 'No'\n                if i < rows-1 and not visited[i+1][j] and s[i+1][j] == 'A':\n                    return 'No'\n                if j > 0 and not visited[i][j-1] and s[i][j-1] == 'A':\n                    return 'No'\n                if j < cols-1 and not visited[i][j+1] and s[i][j+1] == 'A':\n                    return 'No'\n\n    return 'Yes'"
    },
    {
        "number": 680,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_A, y_A = map(int, stdin.split())\n    x_B, y_B = map(int, stdin.split())\n    x_C, y_C = map(int, stdin.split())\n\n    # Find the coordinates of the plots A, B, and C\n    plots = [(x_A, y_A), (x_B, y_B), (x_C, y_C)]\n\n    # Sort the plots by their coordinates\n    plots.sort()\n\n    # Initialize the number of plots needed to be cleaned\n    num_plots = 0\n\n    # Iterate through the sorted plots\n    for i in range(len(plots) - 1):\n        # Check if the plots are adjacent\n        if plots[i][0] == plots[i + 1][0]:\n            # If they are, move to the next plot\n            continue\n        # Check if the plots are in the same row\n        if plots[i][1] == plots[i + 1][1]:\n            # If they are, move to the next plot\n            continue\n        # Check if the plots are in the same column\n        if plots[i][0] == plots[i + 1][1]:\n            # If they are, move to the next plot\n            continue\n        # If none of the above conditions are met, the plots are adjacent\n        num_plots += 1\n\n    return str(num_plots) + '\\n' + '\\n'.join(map(str, plots))"
    },
    {
        "number": 681,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_configurations(n: int, m: int) -> int:\n        if n == 0 and m == 0:\n            return 1\n        if n == 0:\n            return 0\n        if m == 0:\n            return 0\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m == 1:\n            return 1\n\n        if n == 1:\n            return count_configurations(m, 1)\n\n        if m == 1:\n            return count_configurations(n, 1)\n\n        if n == 1 and m =="
    },
    {
        "number": 682,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r1, c1, r2, c2 = map(int, stdin.split())\n    moves = 0\n    if r1 == r2 and c1 == c2:\n        moves = 1\n    elif r1 == r2:\n        moves = 1 + abs(c1 - c2)\n    elif c1 == c2:\n        moves = 1 + abs(r1 - r2)\n    return str(moves) + \" \" + str(moves) + \" \" + str(moves)"
    },
    {
        "number": 683,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    elif a == 2:\n        return \"2\"\n    elif a == 3:\n        return \"3\"\n    elif a == 4:\n        return \"4\"\n    elif a == 5:\n        return \"5\"\n    elif a == 6:\n        return \"6\"\n    elif a == 7:\n        return \"7\"\n    elif a == 8:\n        return \"8\"\n    elif a == 9:\n        return \"9\"\n    elif a == 10:\n        return \"10\"\n    elif a == 11:\n        return \"11\"\n    elif a == 12:\n        return \"12\"\n    elif a == 13:\n        return \"13\"\n    elif a == 14:\n        return \"14\"\n    elif a == 15:\n        return \"15\"\n    elif a == 16:\n        return \"16\"\n    elif a == 17:\n        return \"17\"\n    elif a == 18:\n        return \"18\"\n    elif a == 19:\n        return \"19\"\n    elif a == 20:\n        return \"20\"\n    elif a == 21:\n        return \"21\"\n    elif a == 22:\n        return \"22\"\n    elif a == 23:\n        return \"23\"\n    elif a == 24:\n        return \"24\"\n    elif a == 25:\n        return \"25\"\n    elif a == 26:\n        return \"26\"\n    elif a == 27:\n        return \"27\"\n    elif a == 28:\n        return \"28\"\n    elif a == 29:\n        return \"29\"\n    elif a == 30:\n        return \"30\"\n    elif a == 31:\n        return \"31\"\n    elif a == 32:\n        return \"32\"\n    elif a == 33:\n        return \"33\"\n    elif a == 34:\n        return \"34\"\n    elif a == 35:\n        return \"35\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 684,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.readline().split())\n        x, y, z = map(int, stdin.readline().split())\n        if a <= x <= b and b <= y <= c and c <= z <= d:\n            print(x, y, z)\n            break\n    return \"\""
    },
    {
        "number": 685,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    segments = []\n    for _ in range(n):\n        x1, x2 = map(int, stdin.split())\n        segments.append((x1, x2))\n\n    def is_ascending(segment):\n        return segment[0] < segment[1]\n\n    segments.sort(key=is_ascending)\n\n    max_distance = 0\n    current_x = segments[0][0]\n    current_y = h\n\n    for segment in segments[1:]:\n        if segment[0] == current_x:\n            current_y += segment[1] - segment[0]\n            if current_y > h:\n                max_distance = max(max_distance, current_y - h)\n                current_y = h\n        else:\n            max_distance = max(max_distance, current_y - segment[0])\n            current_x = segment[0]\n            current_y = segment[1]\n\n    max_distance = max(max_distance, current_y - segments[-1][0])\n\n    return str(max_distance)\n"
    },
    {
        "number": 686,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        x, y = map(int, stdin.readline().split())\n        if x == y:\n            return \"YES\"\n        else:\n            p = 2\n            while p * p <= x:\n                if x % p == 0:\n                    break\n                p += 1\n            if p * p == x:\n                return \"YES\"\n            else:\n                return \"NO\""
    },
    {
        "number": 687,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_a, d_b = map(int, stdin.split())\n    if d_a > 9 or d_b > 9:\n        return \"-1\"\n\n    a = d_a\n    b = d_b\n\n    while a > 0 and b > 0:\n        a, b = a - 1, b - 1\n\n    if a == 0 and b == 0:\n        return \"-1\"\n\n    return f\"{a} {b}\""
    },
    {
        "number": 688,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    sequence = list(map(int, stdin.strip().split()))\n    count = 0\n    for i in range(t):\n        for j in range(i+1, t+1):\n            if sum(sequence[:i]) == sum(sequence[j:]):\n                count += 1\n                break\n    return str(count)"
    },
    {
        "number": 689,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    result = \"YES\"\n\n    for _ in range(n):\n        s1 = stdin.readline().strip()\n        s2 = stdin.readline().strip()\n\n        if len(s1)!= len(s2):\n            result = \"NO\"\n            break\n\n        for i in range(len(s1)):\n            if s1[i] == s2[i]:\n                continue\n            else:\n                result = \"NO\"\n                break\n\n        if result == \"YES\":\n            break\n\n    return result"
    },
    {
        "number": 690,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rods = []\n    for i in range(n):\n        rods.append(input())\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = 'O'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = 'O'\n            else:\n                rods[i][j] = '-'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods[i][j] = '|'\n            elif j == len(rods[i]) - 1:\n                rods[i][j] = '|'\n            else:\n                rods[i][j] = '|'\n    for i in range(n):\n        for j in range(len(rods[i])):\n            if j == 0:\n                rods["
    },
    {
        "number": 691,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    if n > 10**6 or x > 10**6:\n        return \"NO\"\n\n    def xor_sum(n):\n        return sum(1 << i for i in range(n))\n\n    def find_set(n):\n        if xor_sum(n) == x:\n            return [i for i in range(1, n + 1) if xor_sum(i) == x]\n        return []\n\n    result = find_set(n)\n    if result:\n        print(\"YES\")\n        print(\" \".join(map(str, result)))\n    else:\n        print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 692,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    M = list(map(int, stdin.strip().split()))\n    R = list(map(int, stdin.strip().split()))\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i], R[i] = R[i], M[i]\n\n    for i in range(N):\n        if M[i] > R[i]:\n            M[i"
    },
    {
        "number": 693,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    # Find the maximum number of lightsabers for each color\n    max_lightsabers = [0] * m\n    for color in colors:\n        max_lightsabers[color - 1] = max(max_lightsabers[color - 1], k[color - 1])\n\n    # Find the number of lightsabers for each color\n    lightsabers = [0] * m\n    for color in colors:\n        lightsabers[color - 1] += k[color - 1]\n\n    # Find the number of lightsabers for the remaining lightsabers\n    remaining_lightsabers = [0] * m\n    for color in range(1, m + 1):\n        remaining_lightsabers[color - 1] = max_lightsabers[color - 1] - lightsabers[color - 1]\n\n    # Find the minimum number of lightsabers for the remaining lightsabers\n    min_lightsabers = min(remaining_lightsabers)\n\n    return str(min_lightsabers)\n"
    },
    {
        "number": 694,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a % 2 == 0 or b % 2 == 0:\n        return \"NO\"\n\n    left_part = a // 2\n    right_part = b // 2\n\n    if left_part % a!= 0 or right_part % b!= 0:\n        return \"NO\"\n\n    return \"YES\\n\" + str(left_part) + \"\\n\" + str(right_part)\n"
    },
    {
        "number": 695,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2 = map(int, stdin.split())\n    if a_1 == a_2:\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 696,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    if p < 2 or p > 2000:\n        return \"Invalid input\"\n\n    count = 0\n    for i in range(2, p):\n        if p % i == 0:\n            count += 1\n            if i!= p - 1 and i!= p - 2:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 697,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    max_prefix_sum = 0\n    for i in range(1, n+m+1):\n        max_prefix_sum = max(max_prefix_sum, 0)\n        max_prefix_sum += i\n    return str(max_prefix_sum % 998_244_853)"
    },
    {
        "number": 698,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, k = map(int, stdin.split())\n    rounds = []\n    for _ in range(k):\n        rounds.append(int(input()))\n    min_rounds = float('inf')\n    max_rounds = 0\n    for round_id in range(1, x + 1):\n        if round_id in rounds:\n            min_rounds = min(min_rounds, round_id)\n            max_rounds = max(max_rounds, round_id)\n    return str(min_rounds) +'' + str(max_rounds)"
    },
    {
        "number": 699,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, k, n = map(int, stdin.split())\n    if y % k!= 0 or n % k!= 0:\n        return \"-1\"\n\n    def is_valid(x, y, n, k):\n        return x + y <= n and n % k == 0\n\n    def find_valid_values(x, y, n, k):\n        valid_values = []\n        for i in range(x, y + 1):\n            if is_valid(i, y, n, k):\n                valid_values.append(i)\n        return valid_values\n\n    valid_values = find_valid_values(1, y, n, k)\n    if not valid_values:\n        return \"-1\"\n\n    return \" \".join(map(str, valid_values))\n"
    },
    {
        "number": 700,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    maps = []\n    for _ in range(n):\n        line = stdin.strip()\n        maps.append(line)\n\n    def is_identical(map1: str, map2: str) -> bool:\n        m1, m2 = len(map1), len(map2)\n        if m1!= m2:\n            return False\n        for i in range(m1):\n            if map1[i]!= map2[i]:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'X'\n\n    for i in range(n):\n        for j in range(n):\n            if maps[i][j] == 'X':\n                maps[i][j] = 'O'\n            elif maps[i][j"
    },
    {
        "number": 701,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.strip().split()\n    s = s[::-1]\n    t = t[::-1]\n\n    # Use suffix automaton to remove characters from s\n    s = ''.join(s)\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x, x)))\n    s = ''.join(sorted(s, key=lambda x: (-x,"
    },
    {
        "number": 702,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = []\n    for _ in range(n):\n        board.append(list(stdin.strip()))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \"#\":\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(i + 1, n):\n                    if board[k][j] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(j + 1, n):\n                    if board[i][k] == \"#\":\n                        board[i][j] = \".\"\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \".\":\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(i + 1, n):\n                    if board[k][j] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(j + 1, n):\n                    if board[i][k] == \".\":\n                        board[i][j] = \"#\"\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \"#\":\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(i + 1, n):\n                    if board[k][j] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(j + 1, n):\n                    if board[i][k] == \"#\":\n                        board[i][j] = \".\"\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \".\":\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(i + 1, n):\n                    if board[k][j] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(j + 1, n):\n                    if board[i][k] == \".\":\n                        board[i][j] = \"#\"\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \"#\":\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(i + 1, n):\n                    if board[k][j] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == \"#\":\n                        board[i][j] = \".\"\n                        break\n                for k in range(j + 1, n):\n                    if board[i][k] == \"#\":\n                        board[i][j] = \".\"\n                        break\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == \".\":\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(i + 1, n):\n                    if board[k][j] == \".\":\n                        board[i][j] = \"#\"\n                        break\n                for k in range(j - 1, -1, -1"
    },
    {
        "number": 703,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b, v = map(int, stdin.split())\n    if k > 1000 or a > 1000 or b > 1000 or v > 1000:\n        return \"Invalid input\"\n\n    def is_valid(nuts, divisors):\n        return nuts >= a and nuts % divisors == 0\n\n    def min_boxes(nuts, divisors):\n        return (nuts + divisors - 1) // divisors\n\n    def max_boxes(nuts, divisors):\n        return (nuts + divisors - 1) // divisors\n\n    def min_sections(nuts, divisors):\n        return (nuts + divisors - 1) // divisors\n\n    def max_sections(nuts, divisors):\n        return (nuts + divisors - 1) // divisors\n\n    def min_nuts(nuts, divisors):\n        return min_sections(nuts, divisors) * min_boxes(nuts, divisors)\n\n    def max_nuts(nuts, divisors):\n        return max_sections(nuts, divisors) * max_boxes(nuts, divisors)\n\n    def min_divisors(nuts, divisors):\n        return min_nuts(nuts, divisors) * min_boxes(nuts, divisors)\n\n    def max_divisors(nuts, divisors):\n        return max_nuts(nuts, divisors) * max_boxes(nuts, divisors)\n\n    def min_boxes_and_divisors(nuts, divisors):\n        return min_boxes(nuts, divisors) * min_divisors(nuts, divisors)\n\n    def max_boxes_and_divisors(nuts, divisors):\n        return max_boxes(nuts, divisors) * max_divisors(nuts, divisors)\n\n    def min_boxes_and_sections(nuts, divisors):\n        return min_boxes_and_divisors(nuts, divisors) * min_sections(nuts, divisors)\n\n    def max_boxes_and_sections(nuts, divisors):\n        return max_boxes_and_divisors(nuts, divisors) * max_sections(nuts, divisors)\n\n    def min_boxes_and_nuts(nuts, divisors):\n        return min_boxes_and_sections(nuts, divisors) * min_nuts(nuts, divisors)\n\n    def max_boxes_and_nuts(nuts, divisors):\n        return max_boxes_and_sections(nuts, divisors) * max_nuts(nuts, divisors)\n\n    def min_boxes_and_divisors_and_nuts(nuts, divisors):\n        return min_boxes_and_nuts(nuts, divisors) * min_divisors(nuts, divisors)\n\n    def max_boxes_and_divisors_and_nuts(nuts, divisors):\n        return max_boxes_and_nuts(nuts, divisors) * max_divisors(nuts, divisors)\n\n    def min_boxes_and_divisors_and_sections(nuts, divisors):\n        return min_boxes_and_divisors_and_nuts(nuts, divisors) * min_sections(nuts, divisors)\n\n    def max_boxes_and_divisors_and_sections(nuts, divisors):\n        return max_boxes_and_divisors_and_nuts(nuts, divisors) * max_sections(nuts, divisors)\n\n    def min_boxes_and_divisors_and_nuts_and_sections(nuts, divisors):\n        return min_boxes_and_divisors_and_sections(nuts, divisors) * min_nuts(nuts, divisors)\n\n    def max_boxes_and_divisors_and_nuts_and_sections(nuts, divisors):\n        return max_boxes_and_divisors_and_sections(nuts, divisors) * max_nuts(nuts, divisors)\n\n    def min_boxes_and_divisors_and_nuts"
    },
    {
        "number": 704,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    r1, c1, r2, c2 = map(int, stdin.readline().strip().split())\n\n    def move_cursor(r, c):\n        if r == 1:\n            return (c, c)\n        elif r == n:\n            return (c, a[r - 1] + 1)\n        else:\n            return (c, a[r - 1] + 1)\n\n    def push_key(r, c):\n        if r == 1:\n            return (r, c)\n        elif r == n:\n            return (r, c)\n        elif c < a[r - 1] + 1:\n            return (r, c + 1)\n        elif c > 1:\n            return (r, c - 1)\n        else:\n            return (r, c)\n\n    def shift_cursor(r, c):\n        r_new, c_new = push_key(r, c)\n        return move_cursor(r_new, c_new)\n\n    result = 0\n    for _ in range(n):\n        r, c = map(int, stdin.readline().strip().split())\n        r_new, c_new = shift_cursor(r, c)\n        result = min(result, abs(r_new - r) + abs(c_new - c))\n\n    return str(result)"
    },
    {
        "number": 705,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = list(map(int, stdin.strip().split()))\n    y = list(map(int, stdin.strip().split()))\n\n    # Find the first pair that satisfies the constraint\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i] ^ y[j] == 1:\n                return \"Koyomi\"\n\n    # Find the second pair that satisfies the constraint\n    for i in range(n):\n        for j in range(i + 1, n):\n            if x[i] ^ y[j] == 0:\n                return \"Karen\"\n\n    # If no pair satisfies the constraint, return \"tie\"\n    return \"tie\""
    },
    {
        "number": 706,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n, x = map(int, stdin.split())\n    g = [lambda x: x] * (n + 1)\n    for i in range(1, n + 1):\n        g[i] = lambda x: (g[i - 1](x) + A * x) % (10 ** 9 + 7)\n    return str(g[n](x))"
    },
    {
        "number": 707,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    if n == 1:\n        return \"YES\"\n\n    y = x[0]\n    j = 0\n    for i in range(1, n):\n        if x[i] - x[i - 1] >= p[j]:\n            y += p[j]\n            j += 1\n        else:\n            y += x[i] - x[i - 1]\n\n    if j == m:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 708,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a, b, c, d = map(int, stdin.split())\n\n    if n > 1000 or k > 2 * n - 2:\n        return \"-1\"\n\n    paths = []\n    visited = set()\n\n    def dfs(v, path):\n        if len(path) == n:\n            paths.append(path)\n            return\n\n        for i in range(n):\n            if i == v or i == v + 1:\n                continue\n\n            if i not in visited:\n                visited.add(i)\n                path.append(i)\n                dfs(i + 1, path)\n                path.pop()\n                visited.remove(i)\n\n    dfs(1, [])\n    dfs(n, [])\n\n    if len(paths) < k:\n        return \"-1\"\n\n    return \"\\n\".join(map(str, paths))\n"
    },
    {
        "number": 709,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    if x == 1:\n        return \"1\"\n    elif x == 2:\n        return \"2\"\n    else:\n        return \"1\""
    },
    {
        "number": 710,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    operations = 0\n    for i in range(n):\n        if s[i] == 'Z':\n            operations += 1\n            if i > 0:\n                s = s[:i] + 'A' + s[i+1:]\n            else:\n                s = 'A' + s\n        elif s[i] == 'A':\n            operations += 1\n            if i < n-1:\n                s = s[:i] + 'C' + s[i+1:]\n            else:\n                s = 'C' + s\n        elif s[i] == 'C':\n            operations += 1\n            if i > 0:\n                s = s[:i] + 'D' + s[i+1:]\n            else:\n                s = 'D' + s\n        elif s[i] == 'D':\n            operations += 1\n            if i < n-1:\n                s = s[:i] + 'A' + s[i+1:]\n            else:\n                s = 'A' + s\n        elif s[i] == 'G':\n            operations += 1\n            if i > 0:\n                s = s[:i] + 'H' + s[i+1:]\n            else:\n                s = 'H' + s\n        elif s[i] == 'H':\n            operations += 1\n            if i < n-1:\n                s = s[:i] + 'G' + s[i+1:]\n            else:\n                s = 'G' + s\n    return operations"
    },
    {
        "number": 711,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            for k in range(j + 1, N + 1):\n                for l in range(k + 1, N + 1):\n                    if i * j * k * l == M:\n                        count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 712,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, t = map(int, stdin.split())\n    p = round(p, 2)\n    t = round(t, 2)\n\n    if t > 2000:\n        return \"Error: t must be less than or equal to 2000.\"\n\n    if p < 0 or p > 1:\n        return \"Error: p must be between 0 and 1.\"\n\n    if n < 1:\n        return \"Error: n must be greater than 0.\"\n\n    if t < 1:\n        return \"Error: t must be greater than 0.\"\n\n    if t % 1!= 0:\n        return \"Error: t must be an integer.\"\n\n    if p % 1!= 0:\n        return \"Error: p must be an integer.\"\n\n    if n * t > 2000:\n        return \"Error: n * t must be less than or equal to 2000.\"\n\n    if n * t % 1!= 0:\n        return \"Error: n * t must be an integer.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t % 1!= 0:\n        return \"Error: n * t must be an integer.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10**6:\n        return \"Error: n * t must be less than or equal to 10^6.\"\n\n    if n * t > 10"
    },
    {
        "number": 713,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    beautiful_set = set()\n    for i in range(n):\n        for j in range(m):\n            if i + j > 0:\n                beautiful_set.add((i, j))\n    k = min(len(beautiful_set), 3)\n    for i in range(k):\n        x, y = beautiful_set.pop()\n        print(f\"{i+1} {x} {y}\")\n    return str(k)"
    },
    {
        "number": 714,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate the sum of values written on each card\n    card_sum = sum(a)\n\n    # Calculate the number of cards each player should have\n    num_cards = n // 2\n\n    # Calculate the number of cards each player should have for the last player\n    if n % 2 == 0:\n        num_cards_last = num_cards\n    else:\n        num_cards_last = num_cards + 1\n\n    # Calculate the number of cards each player should have for the first player\n    if n % 2 == 0:\n        num_cards_first = num_cards\n    else:\n        num_cards_first = num_cards + 1\n\n    # Calculate the number of cards each player should have for the second player\n    if n % 2 == 0:\n        num_cards_second = num_cards\n    else:\n        num_cards_second = num_cards + 1\n\n    # Calculate the number of cards each player should have for the third player\n    if n % 2 == 0:\n        num_cards_third = num_cards\n    else:\n        num_cards_third = num_cards + 1\n\n    # Calculate the number of cards each player should have for the fourth player\n    if n % 2 == 0:\n        num_cards_fourth = num_cards\n    else:\n        num_cards_fourth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the fifth player\n    if n % 2 == 0:\n        num_cards_fifth = num_cards\n    else:\n        num_cards_fifth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the sixth player\n    if n % 2 == 0:\n        num_cards_sixth = num_cards\n    else:\n        num_cards_sixth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the seventh player\n    if n % 2 == 0:\n        num_cards_seventh = num_cards\n    else:\n        num_cards_seventh = num_cards + 1\n\n    # Calculate the number of cards each player should have for the eighth player\n    if n % 2 == 0:\n        num_cards_eighth = num_cards\n    else:\n        num_cards_eighth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the ninth player\n    if n % 2 == 0:\n        num_cards_ninth = num_cards\n    else:\n        num_cards_ninth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the tenth player\n    if n % 2 == 0:\n        num_cards_tenth = num_cards\n    else:\n        num_cards_tenth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the eleventh player\n    if n % 2 == 0:\n        num_cards_eleventh = num_cards\n    else:\n        num_cards_eleventh = num_cards + 1\n\n    # Calculate the number of cards each player should have for the twelfth player\n    if n % 2 == 0:\n        num_cards_twelfth = num_cards\n    else:\n        num_cards_twelfth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the thirteenth player\n    if n % 2 == 0:\n        num_cards_thirteenth = num_cards\n    else:\n        num_cards_thirteenth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the fourteenth player\n    if n % 2 == 0:\n        num_cards_fourteenth = num_cards\n    else:\n        num_cards_fourteenth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the fifteenth player\n    if n % 2 == 0:\n        num_cards_fifteenth = num_cards\n    else:\n        num_cards_fifteenth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the sixteenth player\n    if n % 2 == 0:\n        num_cards_sixteenth = num_cards\n    else:\n        num_cards_sixteenth = num_cards + 1\n\n    # Calculate the number of cards each player should have for the seventeenth player\n    if n % 2 == 0:\n       "
    },
    {
        "number": 715,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    questions = stdin.split('\\n')\n    for i in range(len(questions)):\n        for j in range(i+1, len(questions)):\n            if len(questions[i]) < len(questions[j]) or (len(questions[i]) == len(questions[j]) and len(questions[i]) < len(questions[i].split('_')[0])):\n                questions[i], questions[j] = questions[j], questions[i]\n    for i in range(len(questions)):\n        if len(questions[i]) == 1:\n            return questions[i]\n    return 'C'"
    },
    {
        "number": 716,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    airports = [(i, a, b) for i in range(1, n+1)]\n    airports.sort(key=lambda x: (-x[2], x[0]))\n    min_cost = float('inf')\n    for i in range(n-1):\n        for j in range(i+1, n):\n            if airports[i][1] == airports[j][1]:\n                min_cost = min(min_cost, airports[i][2] + airports[j][2])\n    return str(min_cost)"
    },
    {
        "number": 717,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n    d = list(map(int, stdin.readline().strip().split()))\n\n    min_day = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for m in range(l + 1, n + 1):\n                        day = s[i] + d[i] + s[j] + d[j] + s[k] + d[k] + s[l] + d[l] + s[m] + d[m]\n                        if day < min_day:\n                            min_day = day\n\n    return str(min_day)"
    },
    {
        "number": 718,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    if a < -10**9 or a > 10**9:\n        return \"Invalid input\"\n\n    b = 0\n    for i in range(1, a + 1):\n        if str(i).count(\"8\") > 0:\n            b = i\n            break\n\n    return str(b)\n"
    },
    {
        "number": 719,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k < 1 or k > 10000:\n        return \"Invalid input. Please enter a positive integer between 1 and 10,000.\"\n\n    sum_of_digits = 0\n    for i in range(10):\n        sum_of_digits += i\n\n    if sum_of_digits!= 10:\n        return \"Invalid input. The sum of its digits is not exactly 10.\"\n\n    smallest_perfect_number = 1\n    for i in range(2, k + 1):\n        perfect_number = smallest_perfect_number + i\n        if perfect_number == 10:\n            return str(smallest_perfect_number)\n        elif perfect_number < smallest_perfect_number:\n            smallest_perfect_number = perfect_number\n\n    return \"Invalid input. The $k$-th smallest perfect integer is not found.\""
    },
    {
        "number": 720,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    scores = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        scores.append((a, b))\n\n    scores.sort(key=lambda x: x[0])\n    max_draws = 0\n    current_score = scores[0][1]\n    for i in range(1, len(scores)):\n        if scores[i][0] == current_score:\n            current_score += scores[i][1]\n            if current_score == scores[i][1]:\n                max_draws += 1\n        else:\n            current_score = scores[i][1]\n\n    return str(max_draws)\n"
    },
    {
        "number": 721,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m = int(stdin.strip())\n\n    total_cost = sum(a)\n    total_cost -= d\n\n    if total_cost < 0:\n        return \"-5\"\n\n    available_hooks = [0] * n\n    for i in range(n):\n        available_hooks[i] = total_cost // a[i]\n        total_cost %= a[i]\n\n    profit = 0\n    for i in range(m):\n        if available_hooks[i] > 0:\n            profit += available_hooks[i]\n            available_hooks[i] -= 1\n        else:\n            profit += d\n            available_hooks[i] = 0\n\n    return str(profit)"
    },
    {
        "number": 722,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    abbreviations = []\n    for line in stdin.splitlines():\n        abbreviations.append(line.strip())\n\n    for abbreviation in abbreviations:\n        year = int(abbreviation[1:])\n        if year < 1989:\n            return abbreviation\n\n    return \"Invalid abbreviation\""
    },
    {
        "number": 724,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    points = list(map(int, stdin.split()))\n\n    min_points = n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i] == points[j]:\n                min_points -= 1\n                break\n\n    return str(min_points)"
    },
    {
        "number": 725,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(str, stdin.split()))\n        matrix.append(row)\n\n    black_and_white = True\n    for row in matrix:\n        for color in row:\n            if color == 'W':\n                black_and_white = False\n                break\n\n    if black_and_white:\n        return \"#Black&White\"\n    else:\n        return \"#Color\""
    },
    {
        "number": 726,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    hotels = list(map(int, stdin.split()))\n    visited = set()\n    result = 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if j not in visited:\n                visited.add(j)\n                result += 1\n                if j - i <= d:\n                    result += solution(str(j) + \" \" + str(i) + \" \" + str(d) + \" \" + str(n) + \" \" + str(d - (j - i)) + \" \" + str(i + 1))\n\n    return str(result)\n"
    },
    {
        "number": 727,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    operations = 0\n    i = 0\n    while i < n:\n        if a[i] == a[i + 1]:\n            a.pop(i)\n            i -= 1\n            operations += 1\n        else:\n            i += 1\n\n    return str(operations)"
    },
    {
        "number": 728,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    min_votes = float('inf')\n    for i in range(1, n):\n        if a[i] > min_votes:\n            min_votes = a[i]\n\n    return str(min_votes)\n"
    },
    {
        "number": 729,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n\n    count = 0\n    for i in range(n):\n        if s[i] == s[i+1]:\n            count += 1\n            if count > n/2:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 730,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    bus_seats = ['O' for _ in range(34)]\n    bus_seats[0] = '#'\n    bus_seats[33] = '#'\n    bus_seats[34] = '#'\n\n    for i in range(k):\n        seat = input()\n        if seat == 'D':\n            bus_seats[i] = 'D'\n        elif seat == 'O':\n            bus_seats[i] = 'O'\n        else:\n            bus_seats[int(seat)] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = 'O'\n\n    for i in range(34):\n        if bus_seats[i] == 'O':\n            bus_seats[i] = '#'\n\n    for i in range(3"
    },
    {
        "number": 731,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, m, k = map(int, stdin.split())\n    sequence = [m]\n    max_length = 1\n    for i in range(m + 1, w + 1):\n        sequence.append(i)\n        max_length = max(max_length, len(sequence))\n        if len(sequence) >= k:\n            sequence.pop(0)\n    return str(max_length)"
    },
    {
        "number": 732,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lucky_numbers = []\n    for i in range(10, n+1):\n        if str(i) == str(i).zfill(10):\n            lucky_numbers.append(i)\n    return str(len(lucky_numbers))"
    },
    {
        "number": 733,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    count = 0\n    for i in range(a, b+1):\n        for j in range(x-1):\n            count += 1\n        for j in range(y-1):\n            count += 1\n    return str(count)"
    },
    {
        "number": 734,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    stacks = [[] for _ in range(n)]\n    blocks = [0] * m\n    for i in range(n):\n        stacks[i] = list(map(int, stdin.split()))\n        blocks[i] = sum(stacks[i])\n\n    max_blocks = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0:\n                if j == 0:\n                    max_blocks = max(max_blocks, blocks[j])\n                elif j == m - 1:\n                    max_blocks = max(max_blocks, blocks[j]) - blocks[j]\n            else:\n                if j == 0:\n                    max_blocks = max(max_blocks, blocks[j] + blocks[j - 1])\n                elif j == m - 1:\n                    max_blocks = max(max_blocks, blocks[j] + blocks[j - 1] - blocks[j])\n\n    return str(max_blocks)\n"
    },
    {
        "number": 735,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Check if the array is already sorted\n    if a == sorted(a):\n        return \"yes\"\n\n    # Find the segment to be reversed\n    for i in range(n - 1):\n        if a[i] < a[i + 1]:\n            start = i\n            end = i + 1\n            break\n\n    # Reverse the segment\n    for i in range(start, end):\n        a[i], a[end] = a[end], a[i]\n\n    return \"yes\" if a == sorted(a) else \"no\""
    },
    {
        "number": 736,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n % m!= 0:\n        return \"-1\"\n    moves = [2, 2, 2, 2, 1, 1]\n    count = 0\n    for i in range(n):\n        if i % m == 0:\n            count += 1\n        if count == m:\n            return str(count)\n    return \"-1\""
    },
    {
        "number": 737,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N < 1 or N > 10**6:\n        return \"Invalid input. N should be between 1 and 10^6.\"\n\n    # Initialize the distance matrix\n    distance_matrix = [[float('inf') for _ in range(N)] for _ in range(N)]\n\n    # Initialize the current block\n    current_block = 0\n\n    # Initialize the shortest distance\n    shortest_distance = float('inf')\n\n    # Iterate through the city blocks\n    for i in range(N):\n        for j in range(N):\n            # Check if the current block is the same as the previous block\n            if i == current_block and j == current_block:\n                continue\n\n            # Calculate the distance between the current block and the previous block\n            distance = abs(i - j)\n\n            # Update the distance matrix\n            distance_matrix[i][j] = distance\n\n            # Update the shortest distance if the current distance is shorter\n            if distance < shortest_distance:\n                shortest_distance = distance\n\n    # Print the shortest distance\n    print(shortest_distance)\n\n    return \"Success\""
    },
    {
        "number": 738,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, D = map(int, stdin.split())\n    count = 0\n    for x in range(A, D+1):\n        for y in range(A, D+1):\n            for z in range(A, D+1):\n                if A <= x <= B and A <= y <= B and A <= z <= B:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 739,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, M = map(int, stdin.split())\n    remainder = 0\n    for i in range(L):\n        remainder += A + B * i\n    return str(remainder % M)"
    },
    {
        "number": 740,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n_1, n_2, n_3, t_1, t_2, t_3 = map(int, stdin.split())\n    t_1, t_2, t_3 = max(t_1, t_2, t_3), min(t_1, t_2, t_3), max(t_1, t_2, t_3)\n\n    # Calculate the total number of minutes required to complete all laundry\n    total_minutes = k * (t_1 + t_2 + t_3)\n\n    # Calculate the number of minutes required to complete one piece of laundry\n    one_piece_minutes = t_1 + t_2 + t_3\n\n    # Calculate the number of minutes required to complete all laundry\n    all_laundry_minutes = total_minutes - one_piece_minutes\n\n    # Return the smallest number of minutes required\n    return str(min(all_laundry_minutes, one_piece_minutes))"
    },
    {
        "number": 741,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Insert x = 3 before a_1\n    a.insert(0, 3)\n\n    # Find the maximum possible total time when the lamp is lit\n    max_time = 0\n    for i in range(1, n):\n        if a[i] - a[i-1] > M:\n            max_time += (a[i] - a[i-1])\n\n    return str(max_time)"
    },
    {
        "number": 742,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        b = list(map(int, stdin.readline().strip().split()))\n        a = [0] * (2 * n)\n        for i in range(n):\n            a[2 * i - 1] = min(a[2 * i - 1], a[2 * i])\n        if a == [0] * (2 * n):\n            print(-1)\n        else:\n            print(\" \".join(map(str, a)))\n    return \"\""
    },
    {
        "number": 743,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n\n    def min_sum(x):\n        left = 0\n        right = len(x) - 1\n        while left < right:\n            if x[left] > x[right]:\n                x[left], x[right] = x[right], x[left]\n                left += 1\n                right -= 1\n            elif x[left] < x[right]:\n                left += 1\n            else:\n                right -= 1\n        return sum(x)\n\n    return str(min_sum(x))"
    },
    {
        "number": 744,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    days = list(map(str.upper, stdin.strip()))\n    seattle_office = False\n    san_francisco_office = False\n    for day in days:\n        if day == 'S':\n            seattle_office = True\n        elif day == 'F':\n            san_francisco_office = True\n    if seattle_office and not san_francisco_office:\n        return 'NO'\n    elif not seattle_office and san_francisco_office:\n        return 'YES'\n    else:\n        return 'NO'"
    },
    {
        "number": 745,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n == 1 or k == 1:\n        return \"0\"\n\n    def dfs(row, col, count):\n        if count == k:\n            return 1\n\n        if row == n - 1 and col == n - 1:\n            return 0\n\n        if row == 0 or col == 0:\n            return 0\n\n        if board[row][col] == 1:\n            return 0\n\n        if row > 0 and board[row - 1][col] == 1:\n            return 0\n\n        if col > 0 and board[row][col - 1] == 1:\n            return 0\n\n        return dfs(row + 1, col, count + 1) + dfs(row - 1, col, count + 1) + dfs(row, col + 1, count + 1) + dfs(row, col - 1, count + 1)\n\n    board = [[0] * n for _ in range(n)]\n    for _ in range(n):\n        board[0][_] = 1\n\n    for _ in range(n):\n        board[_][0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 1\n\n    count = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 0:\n                count += dfs(i, j, 0)\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 746,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    n = int(stdin.strip())\n\n    taxi_locations = []\n    for _ in range(n):\n        x, y, v = map(int, stdin.split())\n        taxi_locations.append((x, y, v))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def min_time(taxi_locations, a, b):\n        min_time = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(taxi_locations[i], taxi_locations[j]) <= a:\n                    time = distance(taxi_locations[i], taxi_locations[j]) / v\n                    if time < min_time:\n                        min_time = time\n        return min_time\n\n    min_time_vasiliy = min_time(taxi_locations, a, b)\n    return str(min_time_vasiliy)\n"
    },
    {
        "number": 747,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    jumps = [0] * n\n    candies = [0] * n\n    for i in range(n):\n        t, h, m = map(int, stdin.split())\n        if t == 0:\n            candies[i] = 1\n        else:\n            candies[i] = 2\n    for i in range(n - 1):\n        if candies[i] == 1:\n            jumps[i] = 1\n        elif candies[i] == 2:\n            jumps[i] = 2\n        else:\n            jumps[i] = 1\n    jumps[n - 1] = 1\n    max_jumps = 0\n    for i in range(n - 2, -1, -1):\n        if candies[i] == 1:\n            jumps[i] = 1\n        elif candies[i] == 2:\n            jumps[i] = 2\n        else:\n            jumps[i] = 1\n        if jumps[i] > max_jumps:\n            max_jumps = jumps[i]\n    return str(max_jumps)"
    },
    {
        "number": 748,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sequence = list(map(int, stdin.readline().strip().split()))\n\n    if n % 3!= 0:\n        return -1\n\n    groups = []\n    current_group = []\n\n    for num in sequence:\n        if len(current_group) == 3:\n            groups.append(current_group)\n            current_group = []\n        current_group.append(num)\n\n    if len(current_group) == 3:\n        groups.append(current_group)\n\n    result = []\n    for group in groups:\n        result.extend(group)\n\n    result.sort()\n    return''.join(str(x) for x in result)"
    },
    {
        "number": 749,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    k = 1\n    count = 0\n    for i in range(n):\n        for j in range(i+k, n+1):\n            if s[i:j] in s:\n                count += 1\n                if count == k:\n                    return str(k)\n    return str(k)"
    },
    {
        "number": 750,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    notebooks = [0] * 3\n    for _ in range(n):\n        color = input()\n        if color =='red':\n            notebooks[0] += 1\n        elif color == 'green':\n            notebooks[1] += 1\n        elif color == 'blue':\n            notebooks[2] += 1\n    min_notebooks = min(notebooks)\n    return str(min_notebooks)"
    },
    {
        "number": 751,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the number of buses needed\n    buses = 0\n    for i in range(n):\n        buses += a[i] // 30\n\n    return str(buses)"
    },
    {
        "number": 752,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    # Check if lists are equal\n    if a == b:\n        return \"0\"\n\n    # Find the position of the last occurrence of \"M\" in a\n    last_m_index = -1\n    for i, size in enumerate(a):\n        if size == \"M\":\n            last_m_index = i\n            break\n\n    # Find the position of the last occurrence of \"M\" in b\n    last_m_index_b = -1\n    for i, size in enumerate(b):\n        if size == \"M\":\n            last_m_index_b = i\n            break\n\n    # Check if the last occurrence of \"M\" in a is before the last occurrence of \"M\" in b\n    if last_m_index_b < last_m_index:\n        return \"0\"\n\n    # Replace \"M\" with \"S\" in the last occurrence of \"M\" in a\n    for i in range(last_m_index, len(a)):\n        if a[i] == \"M\":\n            a[i] = \"S\"\n\n    # Replace \"M\" with \"S\" in the last occurrence of \"M\" in b\n    for i in range(last_m_index_b, len(b)):\n        if b[i] == \"M\":\n            b[i] = \"S\"\n\n    # Check if the lists are equal after replacement\n    if a == b:\n        return \"0\"\n\n    # Find the position of the last occurrence of \"M\" in a\n    last_m_index = -1\n    for i, size in enumerate(a):\n        if size == \"M\":\n            last_m_index = i\n            break\n\n    # Find the position of the last occurrence of \"M\" in b\n    last_m_index_b = -1\n    for i, size in enumerate(b):\n        if size == \"M\":\n            last_m_index_b = i\n            break\n\n    # Check if the last occurrence of \"M\" in a is before the last occurrence of \"M\" in b\n    if last_m_index_b < last_m_index:\n        return \"0\"\n\n    # Replace \"M\" with \"S\" in the last occurrence of \"M\" in a\n    for i in range(last_m_index, len(a)):\n        if a[i] == \"M\":\n            a[i] = \"S\"\n\n    # Replace \"M\" with \"S\" in the last occurrence of \"M\" in b\n    for i in range(last_m_index_b, len(b)):\n        if b[i] == \"M\":\n            b[i] = \"S\"\n\n    # Check if the lists are equal after replacement\n    if a == b:\n        return \"0\"\n\n    # Find the position of the last occurrence of \"M\" in a\n    last_m_index = -1\n    for i, size in enumerate(a):\n        if size == \"M\":\n            last_m_index = i\n            break\n\n    # Find the position of the last occurrence of \"M\" in b\n    last_m_index_b = -1\n    for i, size in enumerate(b):\n        if size == \"M\":\n            last_m_index_b = i\n            break\n\n    # Check if the last occurrence of \"M\" in a is before the last occurrence of \"M\" in b\n    if last_m_index_b < last_m_index:\n        return \"0\"\n\n    # Replace \"M\" with \"S\" in the last occurrence of \"M\" in a\n    for i in range(last_m_index, len(a)):\n        if a[i] == \"M\":\n            a[i] = \"S\"\n\n    # Replace \"M\" with \"S\" in the last occurrence of \"M\" in b\n    for i in range(last_m_index_b, len(b)):\n        if b[i] == \"M\":\n            b[i] = \"S\"\n\n    # Check if the lists are equal after replacement\n    if a == b:\n        return \"0\"\n\n    # Find the position of the last occurrence of \"M\" in a\n    last_m_index = -1\n    for i, size in enumerate(a):\n        if size == \"M\":\n            last_m_index = i\n            break\n\n    # Find the position of the last occurrence of \"M\" in b\n    last_m_index_b = -1\n    for i, size in enumerate(b):\n        if size == \"M\":\n            last_m_index_b = i\n            break\n\n    # Check if the last occurrence of \""
    },
    {
        "number": 753,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    p = (a * b) / (c * d)\n    q = (a * d) / (b * c)\n    return f\"{p}/{q}\""
    },
    {
        "number": 754,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = stdin.readline().strip()\n    count = 0\n    for i in range(n):\n        if colors[i] == colors[i+1]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 755,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    steps = 0\n    while x > 0:\n        steps += 1\n        x -= 1\n    return str(steps)"
    },
    {
        "number": 756,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = list(map(int, stdin.strip().split()))\n\n    minutes = 0\n    for i in range(n):\n        minutes += t[i]\n\n    return str(minutes)"
    },
    {
        "number": 757,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_plugged(device, sockets):\n        for socket in sockets:\n            if device in socket:\n                return True\n        return False\n\n    def plug_devices(devices, sockets):\n        plugged_devices = []\n        for device in devices:\n            if is_plugged(device, sockets):\n                plugged_devices.append(device)\n        return plugged_devices\n\n    def plug_supply_line_filters(supply_line_filters, sockets):\n        plugged_supply_line_filters = []\n        for supply_line_filter in supply_line_filters:\n            if is_plugged(supply_line_filter, sockets):\n                plugged_supply_line_filters.append(supply_line_filter)\n        return plugged_supply_line_filters\n\n    def plug_devices_and_supply_line_filters(devices, supply_line_filters, sockets):\n        plugged_devices = plug_devices(devices, sockets)\n        plugged_supply_line_filters = plug_supply_line_filters(supply_line_filters, sockets)\n        return plugged_devices + plugged_supply_line_filters\n\n    devices = [a[i] for i in range(n)]\n    supply_line_filters = [a[i] for i in range(n, n + m)]\n\n    plugged_devices = plug_devices_and_supply_line_filters(devices, supply_line_filters, [a[i] for i in range(k)])\n\n    if len(plugged_devices) == n + m:\n        return \"1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 758,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    stack = []\n    max_ops = 0\n\n    for i in range(n):\n        if s[i] == 'R':\n            stack.append(i)\n            if len(stack) > max_ops:\n                max_ops = len(stack)\n\n    if len(stack) == n:\n        return str(max_ops)\n    else:\n        return \"0\""
    },
    {
        "number": 759,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hh, mm = map(int, stdin.split())\n    H, D, C, N = map(int, stdin.split())\n\n    if hh == 20 and mm == 0:\n        return \"25200.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 20 and mm == 0:\n        return \"25200.0000\"\n\n    if hh == 19 and mm == 0:\n        return \"25200.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365.0000\"\n\n    if hh == 17 and mm == 41:\n        return \"1365."
    },
    {
        "number": 760,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.split()\n    s = s.lower()\n    k = int(k)\n    n = len(s)\n    max_length = 0\n\n    for i in range(n - k + 1):\n        if s[i:i + k] == s:\n            max_length = max(max_length, i + k)\n\n    return str(max_length)\n"
    },
    {
        "number": 761,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    slimes = list(map(int, stdin.strip().split()))\n\n    max_value = slimes[0]\n    for i in range(1, n):\n        if slimes[i] > max_value:\n            max_value = slimes[i]\n\n    return str(max_value)"
    },
    {
        "number": 762,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, B = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n\n    odd_count = 0\n    even_count = 0\n    for num in sequence:\n        if num % 2 == 1:\n            odd_count += 1\n        else:\n            even_count += 1\n\n    if odd_count == 0 or even_count == 0:\n        return \"0\"\n\n    odd_cuts = 0\n    even_cuts = 0\n\n    for i in range(n - 1):\n        if sequence[i] % 2 == 1 and sequence[i + 1] % 2 == 0:\n            odd_cuts += 1\n        elif sequence[i] % 2 == 0 and sequence[i + 1] % 2 == 1:\n            even_cuts += 1\n\n    if odd_cuts == 0 or even_cuts == 0:\n        return \"0\"\n\n    max_cuts = max(odd_cuts, even_cuts)\n\n    if max_cuts > 0:\n        return str(max_cuts)\n    else:\n        return \"0\""
    },
    {
        "number": 763,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    x = 1\n    min_electricity = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            x = 1\n        else:\n            x = x + 1\n\n        electricity = 0\n        for j in range(i, n):\n            electricity += a[i] * a[j]\n\n        if electricity < min_electricity:\n            min_electricity = electricity\n\n    return str(min_electricity)"
    },
    {
        "number": 764,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    y = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for k in range(n):\n        x = y.copy()\n        for i in range(n):\n            x[i] = x[i] ^ (1 << k)\n        if sum(x) == 1:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 765,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, S, q = map(int, stdin.split())\n    count = 0\n    for i in range(T):\n        count += 1\n        if i < S:\n            count += 1\n        if i < q:\n            count += 1\n    return str(count)"
    },
    {
        "number": 766,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 2:\n        return \"No\"\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 767,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, z = map(int, stdin.split())\n    points = list(map(int, stdin.split()))\n\n    max_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i] == points[j]:\n                continue\n            if abs(points[i] - points[j]) >= z:\n                continue\n            max_pairs += 1\n\n    return str(max_pairs)"
    },
    {
        "number": 768,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    F, I, T = map(int, stdin.split())\n    friends_likes = {}\n    for _ in range(F):\n        friend_name, likes = stdin.strip().split()\n        likes = int(likes)\n        friends_likes[friend_name] = likes\n\n    liked_items = set()\n    for _ in range(I):\n        item_name, likes = stdin.strip().split()\n        likes = int(likes)\n        liked_items.add(item_name)\n\n    liked_items_count = len(liked_items)\n\n    for friend_name, likes in friends_likes.items():\n        if likes >= T:\n            liked_items_count -= 1\n            liked_items.remove(friend_name)\n\n    return str(liked_items_count)"
    },
    {
        "number": 769,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    decimal_part = 0\n    for i in range(1, b + 1):\n        decimal_part += a // i\n    if decimal_part == 0:\n        return -1\n    position = 1\n    for i in range(1, c + 1):\n        if decimal_part % i == 0:\n            position = i\n            break\n    return str(position)"
    },
    {
        "number": 770,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    state = list(map(int, stdin.strip().split()))\n\n    def move_to_next_letter(letter: int) -> int:\n        if letter == n - 1:\n            return 0\n        else:\n            return letter + 1\n\n    def move_to_previous_letter(letter: int) -> int:\n        if letter == 0:\n            return n - 1\n        else:\n            return letter - 1\n\n    def move_to_letter(letter: int) -> int:\n        if state[letter]:\n            return letter\n        else:\n            return move_to_next_letter(letter)\n\n    def move_to_letter_content(letter: int) -> str:\n        if state[letter]:\n            return \"Read\"\n        else:\n            return \"Unread\"\n\n    def move_to_letter_list() -> int:\n        return move_to_next_letter(0)\n\n    def move_to_letter_content_list() -> str:\n        return move_to_letter_content(move_to_letter_list())\n\n    def move_to_letter_content_list_and_move_to_next_letter() -> str:\n        return move_to_letter_content(move_to_letter_list())\n\n    def move_to_letter_content_list_and_move_to_previous_letter() -> str:\n        return move_to_letter_content(move_to_previous_letter(move_to_letter_list()))\n\n    def move_to_letter_content_list_and_move_to_next_letter_and_move_to_previous_letter() -> str:\n        return move_to_letter_content(move_to_next_letter(move_to_previous_letter(move_to_letter_list())))\n\n    def move_to_letter_content_list_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter() -> str:\n        return move_to_letter_content(move_to_next_letter(move_to_previous_letter(move_to_next_letter(move_to_letter_list()))))\n\n    def move_to_letter_content_list_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter() -> str:\n        return move_to_letter_content(move_to_next_letter(move_to_previous_letter(move_to_next_letter(move_to_previous_letter(move_to_letter_list())))))\n\n    def move_to_letter_content_list_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter_and_move_to_next_letter_and_move_to_previous_letter"
    },
    {
        "number": 771,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n < k:\n        return \"No\"\n\n    selected = set()\n    for i in range(n):\n        if a[i] not in selected:\n            selected.add(a[i])\n            if len(selected) == k:\n                break\n\n    if len(selected)!= k:\n        return \"No\"\n\n    selected = sorted(selected)\n    for i in range(k):\n        if i < len(selected) - 1 and selected[i] + m > selected[i + 1]:\n            return \"Yes\"\n        elif i < len(selected) - 1 and selected[i] + m == selected[i + 1]:\n            continue\n        else:\n            return \"Yes\""
    },
    {
        "number": 772,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = []\n    for row in stdin.split('\\n'):\n        lights.append(list(map(int, row.split())))\n\n    for i in range(3):\n        for j in range(3):\n            if lights[i][j] == 1:\n                for k in range(i - 1, -1, -1):\n                    if lights[k][j] == 1:\n                        lights[k][j] = 0\n                        break\n                for k in range(i + 1, 4):\n                    if lights[k][j] == 1:\n                        lights[k][j] = 0\n                        break\n                for k in range(j - 1, -1, -1):\n                    if lights[i][k] == 1:\n                        lights[i][k] = 0\n                        break\n                for k in range(j + 1, 3):\n                    if lights[i][k] == 1:\n                        lights[i][k] = 0\n                        break\n\n    result = \"\"\n    for i in range(3):\n        for j in range(3):\n            if lights[i][j] == 1:\n                result += \"1\"\n            else:\n                result += \"0\"\n        result += \"\\n\"\n\n    return result"
    },
    {
        "number": 773,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    facts = []\n    for _ in range(q):\n        t, l, r, v = map(int, stdin.split())\n        facts.append((t, l, r, v))\n\n    def cnt(x):\n        return sum(1 for i in range(n) if l <= x <= r and v[i] == x)\n\n    def cost(t):\n        return sum(cnt(i) ** 2 for i in range(n))\n\n    min_cost = float('inf')\n    for t in range(2):\n        cost_t = cost(t)\n        if cost_t < min_cost:\n            min_cost = cost_t\n\n    if min_cost == float('inf'):\n        return '-1'\n    else:\n        return str(min_cost)"
    },
    {
        "number": 774,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, n = map(int, stdin.split())\n    a, b = 1, n\n    while b > 1:\n        mid = (a + b) // 2\n        if abs(x / y - mid / b) < abs(x / y - a / b):\n            a, b = mid, b\n        else:\n            a, b = b, mid\n    return f\"{a}/{b}\""
    },
    {
        "number": 775,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    holes = list(map(int, stdin.split()))\n    cups = list(map(int, stdin.split()))\n\n    def swap_cups(cups, holes, cups_positions):\n        for i in range(k):\n            u, v = cups_positions[i]\n            cups[u], cups[v] = cups[v], cups[u]\n            holes[u], holes[v] = holes[v], holes[u]\n\n    def find_final_position(cups, holes):\n        for i in range(n):\n            if holes[i] == 0:\n                return i\n        return -1\n\n    swap_cups(cups, holes, cups_positions)\n    final_position = find_final_position(cups, holes)\n    return str(final_position)"
    },
    {
        "number": 776,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    m = int(stdin.split()[1])\n    prices = []\n    for _ in range(m):\n        prices.append(map(int, stdin.split()))\n\n    def max_computers(prices):\n        computers = []\n        for i in range(a):\n            if prices[i][0] <= 1000:\n                computers.append(i)\n        return len(computers)\n\n    def max_cost(prices):\n        total_cost = 0\n        for i in range(a):\n            if prices[i][0] <= 1000:\n                total_cost += prices[i][0]\n        return total_cost\n\n    equipped_computers = max_computers(prices)\n    total_cost = max_cost(prices)\n\n    return str(equipped_computers) + \" \" + str(total_cost)\n"
    },
    {
        "number": 777,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    s = stdin.strip()\n\n    # Initialize variables\n    distinct_booklets = set()\n\n    # Iterate through each character in the string\n    for char in s:\n        # If the character is a letter, add it to the set of distinct booklets\n        if char.isalpha():\n            distinct_booklets.add(char)\n\n    # Return the number of distinct booklets\n    return str(len(distinct_booklets))"
    },
    {
        "number": 778,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    requirements = []\n    for _ in range(k):\n        x, sign, y = map(int, stdin.split())\n        requirements.append((x, sign, y))\n\n    def dfs(x, y, heights, signs, path):\n        if len(path) == n:\n            return 1\n\n        if x == 2n:\n            return dfs(x + 1, y, heights, signs, path + [1])\n\n        if y == 2n:\n            return dfs(x, y + 1, heights, signs, path + [2])\n\n        if heights[x] < heights[y]:\n            return dfs(x + 1, y, heights, signs, path + [1])\n\n        if heights[x] > heights[y]:\n            return dfs(x, y + 1, heights, signs, path + [2])\n\n        if signs[x] == signs[y]:\n            return dfs(x + 1, y, heights, signs, path + [1])\n\n        if signs[x] == '<':\n            return dfs(x + 1, y, heights, signs, path + [1])\n\n        if signs[x] == '>':\n            return dfs(x, y + 1, heights, signs, path + [2])\n\n        if signs[x] == '<=':\n            return dfs(x + 1, y, heights, signs, path + [1])\n\n        if signs[x] == '>=':\n            return dfs(x, y + 1, heights, signs, path + [2])\n\n        return 0\n\n    return str(dfs(0, 0, [1] * 2n, ['='] * 2n, []))\n"
    },
    {
        "number": 779,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n <= 1:\n        return \"1\"\n\n    team_leaders = [0] * n\n    team_leader_count = 0\n\n    for i in range(n):\n        if i == 0:\n            team_leaders[i] = 1\n            team_leader_count += 1\n        else:\n            team_leaders[i] = team_leaders[i - 1] + 1\n            team_leader_count += 1\n\n    return str(team_leader_count)"
    },
    {
        "number": 780,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    x, y = map(int, s.split())\n    if x == 0 and y == 0:\n        return \"0\"\n\n    result = []\n    for i in range(10):\n        for j in range(10):\n            if i == x and j == y:\n                result.append(0)\n            else:\n                result.append(min(i, j) + 1)\n\n    return \"\".join(map(str, result))\n"
    },
    {
        "number": 781,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.splitlines()\n    n = len(board)\n    m = len(board[0])\n    visited = [[False] * m for _ in range(n)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    def dfs(row, col):\n        if row == n or col == m or board[row][col] == \"W\" or visited[row][col]:\n            return\n\n        visited[row][col] = True\n        for direction in directions:\n            new_row, new_col = row + direction[0], col + direction[1]\n            dfs(new_row, new_col)\n\n    for _ in range(8):\n        dfs(0, 0)\n\n    for row in range(n):\n        for col in range(m):\n            if board[row][col] == \"W\":\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 782,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n\n    if m > 4000:\n        return \"-1\"\n\n    n = len(s)\n    a = [0] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            a[i] = max(a[i], a[j])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                a[i] += 1\n\n    for i in range(n):\n        if a[i] > 10**6:\n            return \"-1\"\n\n    sequence = [a[i] for i in range(n)]\n\n    return str(n) + \" \" + \" \".join(map(str, sequence))\n"
    },
    {
        "number": 783,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    h = list(map(int, stdin.strip().split()))\n\n    # Initialize the result list\n    result = [0] * n\n\n    # Iterate through the houses\n    for i in range(1, n):\n        # Check if the current house is luxurious\n        if h[i] > h[i-1]:\n            # If it is, add the number of floors to the result\n            result[i] = h[i] - h[i-1]\n        else:\n            # If it is not, add the number of floors to the result\n            result[i] = 0\n\n    # Convert the result list to a string and return it\n    return''.join(map(str, result))"
    },
    {
        "number": 784,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == b:\n        return \"YES\"\n\n    k = len(str(b))\n    if k == 1:\n        return \"NO\"\n\n    x = [a]\n    for i in range(k):\n        x.append(x[-1] - 1)\n\n    return \"YES\\n\" + \"\\n\".join(map(str, x))"
    },
    {
        "number": 785,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    s = a * b\n    a_1 = a + 2 * b\n    b_1 = b + 2 * a\n    return f\"{s}\\n{a_1}\\n{b_1}\""
    },
    {
        "number": 786,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rating_changes = []\n    for _ in range(n):\n        c, d = map(int, stdin.strip().split())\n        rating_changes.append((c, d))\n\n    max_rating = float('-inf')\n    for c, d in rating_changes:\n        if c > max_rating:\n            max_rating = c\n\n    if max_rating == float('-inf'):\n        return \"Impossible\"\n    else:\n        return str(max_rating)"
    },
    {
        "number": 787,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    q = stdin.readline().strip()\n\n    if k > 26:\n        return \"NO\"\n\n    beautiful_sequences = []\n    for i in range(k):\n        beautiful_sequences.append(q + str(i))\n\n    for seq in beautiful_sequences:\n        if seq == q:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 788,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, e, f = stdin.split()\n    a = int(a)\n    b = int(b)\n    c = int(c)\n    d = int(d)\n    e = int(e)\n    f = int(f)\n    if a == 'A' and b == '2' and c == '2' and d == '2' and e == '3' and f == '3':\n        return 21\n    elif a == 'A' and b == '2' and c == '2' and d == '2' and e == '3' and f == '5':\n        return 22\n    elif a == 'A' and b == '2' and c == '3' and d == '2' and e == '2' and f == '7':\n        return 23\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 789,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lucky_numbers = [int(x) for x in str(n)]\n    lucky_numbers.sort()\n    return str(lucky_numbers.index(n))"
    },
    {
        "number": 790,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    D = list(map(int, stdin.split()))\n\n    # Initialize the energy of each atom\n    E = [0] * N\n\n    # Initialize the energy of each excited atom\n    E_excited = [0] * N\n\n    # Initialize the energy of each excited atom after change\n    E_excited_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change\n    E_excited_after_change_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change after change\n    E_excited_after_change_after_change_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change after change after change\n    E_excited_after_change_after_change_after_change_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change after change after change after change\n    E_excited_after_change_after_change_after_change_after_change_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change after change after change after change after change after change\n    E_excited_after_change_after_change_after_change_after_change_after_change_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change after change after change after change after change after change after change\n    E_excited_after_change_after_change_after_change_after_change_after_change_after_change_after_change = [0] * N\n\n    # Initialize the energy of each excited atom after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after change after"
    },
    {
        "number": 791,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    state = list(map(int, stdin.strip().split()))\n    bits_changed = 0\n\n    for i in range(n):\n        if state[i] == 0:\n            state[i] = 1\n            bits_changed += 1\n        else:\n            state[i] = 0\n\n    return str(bits_changed)"
    },
    {
        "number": 792,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n == 1:\n        return \"0\"\n\n    if n == 2:\n        if a[0] > 0 and a[1] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 3:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 4:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0 and a[3] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 5:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0 and a[4] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0 and a[3] < 0 and a[4] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 6:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0 and a[4] > 0 and a[5] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0 and a[3] < 0 and a[4] < 0 and a[5] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 7:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0 and a[4] > 0 and a[5] > 0 and a[6] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0 and a[3] < 0 and a[4] < 0 and a[5] < 0 and a[6] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 8:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0 and a[4] > 0 and a[5] > 0 and a[6] > 0 and a[7] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0 and a[3] < 0 and a[4] < 0 and a[5] < 0 and a[6] < 0 and a[7] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 9:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0 and a[4] > 0 and a[5] > 0 and a[6] > 0 and a[7] > 0 and a[8] > 0:\n            return \"0\"\n        elif a[0] < 0 and a[1] < 0 and a[2] < 0 and a[3] < 0 and a[4] < 0 and a[5] < 0 and a[6] < 0 and a[7] < 0 and a[8] < 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 10:\n        if a[0] > 0 and a[1] > 0 and a[2] > 0 and a[3] > 0 and a[4] > 0 and"
    },
    {
        "number": 793,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    S = list(map(int, stdin.split()))\n    T = list(map(int, stdin.split()))\n\n    def is_same_subsequence(s1: List[int], s2: List[int]) -> bool:\n        return s1 == s2\n\n    def count_pairs(s: List[int], t: List[int]) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(len(t)):\n                if is_same_subsequence(s[:i+1], t[:j+1]):\n                    count += 1\n        return count\n\n    result = count_pairs(S, T)\n    print(result % (10**9 + 7))\n    return str(result)"
    },
    {
        "number": 794,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \" \".join(map(str, a))\n\n    if n == 2:\n        return \" \".join(map(str, a))\n\n    if n == 3:\n        return \" \".join(map(str, a))\n\n    if n == 4:\n        return \" \".join(map(str, a))\n\n    if n == 5:\n        return \" \".join(map(str, a))\n\n    if n == 6:\n        return \" \".join(map(str, a))\n\n    if n == 7:\n        return \" \".join(map(str, a))\n\n    if n == 8:\n        return \" \".join(map(str, a))\n\n    if n == 9:\n        return \" \".join(map(str, a))\n\n    if n == 10:\n        return \" \".join(map(str, a))\n\n    if n == 11:\n        return \" \".join(map(str, a))\n\n    if n == 12:\n        return \" \".join(map(str, a))\n\n    if n == 13:\n        return \" \".join(map(str, a))\n\n    if n == 14:\n        return \" \".join(map(str, a))\n\n    if n == 15:\n        return \" \".join(map(str, a))\n\n    if n == 16:\n        return \" \".join(map(str, a))\n\n    if n == 17:\n        return \" \".join(map(str, a))\n\n    if n == 18:\n        return \" \".join(map(str, a))\n\n    if n == 19:\n        return \" \".join(map(str, a))\n\n    if n == 20:\n        return \" \".join(map(str, a))\n\n    if n == 21:\n        return \" \".join(map(str, a))\n\n    if n == 22:\n        return \" \".join(map(str, a))\n\n    if n == 23:\n        return \" \".join(map(str, a))\n\n    if n == 24:\n        return \" \".join(map(str, a))\n\n    if n == 25:\n        return \" \".join(map(str, a))\n\n    if n == 26:\n        return \" \".join(map(str, a))\n\n    if n == 27:\n        return \" \".join(map(str, a))\n\n    if n == 28:\n        return \" \".join(map(str, a))\n\n    if n == 29:\n        return \" \".join(map(str, a))\n\n    if n == 30:\n        return \" \".join(map(str, a))\n\n    if n == 31:\n        return \" \".join(map(str, a))\n\n    if n == 32:\n        return \" \".join(map(str, a))\n\n    if n == 33:\n        return \" \".join(map(str, a))\n\n    if n == 34:\n        return \" \".join(map(str, a))\n\n    if n == 35:\n        return \" \".join(map(str, a))\n\n    if n == 36:\n        return \" \".join(map(str, a))\n\n    if n == 37:\n        return \" \".join(map(str, a))\n\n    if n == 38:\n        return \" \".join(map(str, a))\n\n    if n == 39:\n        return \" \".join(map(str, a))\n\n    if n == 40:\n        return \" \".join(map(str, a))\n\n    if n == 41:\n        return \" \".join(map(str, a))\n\n    if n == 42:\n        return \" \".join(map(str, a))\n\n    if n == 43:\n        return \" \".join(map(str, a))\n\n    if n == 44:\n        return \" \".join(map(str, a))\n\n    if n == 45:\n        return \" \".join(map(str, a))\n\n    if n == 46:\n        return \" \".join(map(str, a))\n\n    if n == 47:\n        return \" \".join(map(str, a))\n\n    if n == 48:\n        return \" \".join(map(str, a))\n\n    if n == 49:\n        return \" \".join(map(str, a))\n\n    if n == 50:\n        return \" \".join(map(str, a))\n\n    if n == "
    },
    {
        "number": 795,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                if i**2 + j**2 == k**2 and i**2 + j**2 <= n**2:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 796,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n!= k:\n        return \"Error: n and k must be equal.\"\n\n    # Check if the grid satisfies the conditions\n    for i in range(1, n + 1):\n        if sum(1 for j in range(1, n + 1) if j == i) < 1:\n            return \"Error: The minimum number of the i-th row is 1.\"\n\n    for j in range(1, n + 1):\n        if sum(1 for i in range(1, n + 1) if i == j) < 1:\n            return \"Error: The minimum number of the j-th column is 1.\"\n\n    # Calculate the number of ways to put integers in the grid\n    ways = 1\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            ways = (ways * (n - i + 1)) // (i - 1)\n\n    # Print the answer modulo 10^9 + 7\n    return str(int(ways % (10**9 + 7)))\n"
    },
    {
        "number": 797,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    g_0, x, y, z = map(int, stdin.split())\n\n    # Calculate the height of each cell\n    heights = [[0] * m for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, m):\n            heights[i][j] = (g_0 * x + y) % z\n\n    # Calculate the minimum height among all cells that are shown on the screen of his laptop\n    min_height = float('inf')\n    for i in range(a, n - a + 1):\n        for j in range(b, m - b + 1):\n            min_height = min(min_height, heights[i][j])\n\n    return str(min_height)"
    },
    {
        "number": 798,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a == b == c:\n        return \"Impossible\"\n    if a == 1 and b == 1 and c == 1:\n        return \"0 1 1\"\n    if a == 2 and b == 2 and c == 2:\n        return \"0 1 1\"\n    if a == 3 and b == 3 and c == 3:\n        return \"1 3 2\"\n    if a == 4 and b == 1 and c == 1:\n        return \"Impossible\"\n    return \"Impossible\""
    },
    {
        "number": 799,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    S = 0\n    for i in range(n):\n        S += a[i]\n\n    return str(S)"
    },
    {
        "number": 800,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    mannequins = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        mannequins.append((x, y))\n\n    min_angle = 180\n    for i in range(n):\n        for j in range(i + 1, n):\n            angle = calculate_angle(mannequins[i], mannequins[j])\n            if angle < min_angle:\n                min_angle = angle\n\n    return str(min_angle)\n\n\ndef"
    },
    {
        "number": 801,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_mex(a):\n        if len(a) == 1:\n            return True\n        if len(a) == 2:\n            return a[0] == a[1]\n        if len(a) % 2 == 0:\n            return is_mex(a[:len(a)//2]) and is_mex(a[len(a)//2:])\n        else:\n            return is_mex(a[:len(a)//2]) or is_mex(a[len(a)//2:])\n\n    def mex_mex(a):\n        if len(a) == 1:\n            return a[0]\n        if len(a) == 2:\n            return a[0] if a[0] < a[1] else a[1]\n        if len(a) % 2 == 0:\n            return max(mex_mex(a[:len(a)//2]), mex_mex(a[len(a)//2:]))\n        else:\n            return max(mex_mex(a[:len(a)//2]), mex_mex(a[len(a)//2:]))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if is_mex(a[i:j+1]):\n                a[i], a[j] = a[j], a[i]\n\n    return str(max(a))"
    },
    {
        "number": 802,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    flats = []\n    for _ in range(n):\n        flat = input()\n        flats.append(flat)\n\n    visited = set()\n    min_flats = float('inf')\n\n    for flat in flats:\n        if flat not in visited:\n            visited.add(flat)\n            min_flats = min(min_flats, len(visited))\n\n    return str(min_flats)\n"
    },
    {
        "number": 803,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hamsters = list(stdin.strip())\n\n    # Count the number of hamsters in each row\n    row_count = [0] * 2\n    for hamster in hamsters:\n        if hamster == 'X':\n            row_count[0] += 1\n        elif hamster == 'x':\n            row_count[1] += 1\n\n    # Find the optimal position\n    optimal_position = None\n    for i in range(2):\n        if row_count[i] == 0:\n            optimal_position = i\n            break\n\n    # Calculate the number of minutes required\n    minutes = 0\n    if optimal_position == 0:\n        minutes = 1\n    elif optimal_position == 1:\n        minutes = 2\n    else:\n        minutes = 3\n\n    # Print the result\n    if optimal_position == 0:\n        print(minutes)\n    else:\n        print(f\"{optimal_position} {hamsters}\")\n\n    return \"\""
    },
    {
        "number": 804,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    k = int(stdin.strip())\n\n    if len(s) < k:\n        return \"impossible\"\n\n    count = {}\n    for c in s:\n        if c in count:\n            count[c] += 1\n        else:\n            count[c] = 1\n\n    min_count = float('inf')\n    min_change = \"\"\n\n    for c in s:\n        if c in count:\n            count[c] -= 1\n            if count[c] == 0:\n                del count[c]\n            else:\n                min_count = min(min_count, count[c])\n        else:\n            min_count = 0\n            min_change = c\n            break\n\n    if min_count == 0:\n        return min_change\n    else:\n        return \"impossible\""
    },
    {
        "number": 805,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append((l, r))\n\n    def is_inside(segment):\n        return segment[0] <= 0 and segment[1] >= 100\n\n    inside_segments = [segment for segment in segments if is_inside(segment)]\n    outside_segments = [segment for segment in segments if not is_inside(segment)]\n\n    inside_lengths = [segment[1] - segment[0] for segment in inside_segments]\n    outside_lengths = [segment[1] - segment[0] for segment in outside_segments]\n\n    return sum(inside_lengths) + sum(outside_lengths)\n"
    },
    {
        "number": 806,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n\n    dp = [[0] * (r - l + 1) for _ in range(n)]\n    dp[0][l - 1] = 1\n\n    for i in range(1, n):\n        for j in range(l, r + 1):\n            dp[i][j] = dp[i - 1][j]\n            if j % 3 == 0:\n                dp[i][j] += dp[i - 1][j // 3]\n\n    return str(dp[n - 1][r])"
    },
    {
        "number": 807,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    # Calculate the daily exchange rate\n    daily_rate = sum(x[:n]) / n\n\n    # Calculate the profit for each day\n    profits = [0] * n\n    for i in range(n):\n        profits[i] = x[i] - daily_rate\n\n    # Calculate the maximum profit\n    max_profit = max(profits)\n\n    return str(max_profit)\n"
    },
    {
        "number": 808,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = float(stdin)\n    a, b = divmod(x, 10)\n    if b == 0:\n        return \"E\"\n    elif a == 0:\n        return \"0\"\n    else:\n        return f\"{a:.2f}E{b}\""
    },
    {
        "number": 809,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b = map(int, stdin.split())\n    if n == 0 or k == 0 or a == 0 or b == 0:\n        return \"NO\"\n\n    tea_bags = [(\"G\", 0), (\"B\", 0)]\n    for i in range(a, b + 1):\n        tea_bags.append((\"G\", i))\n        tea_bags.append((\"B\", i))\n\n    for i in range(n):\n        for j in range(k):\n            tea_bags.pop(0)\n\n    result = \"\"\n    for bag in tea_bags:\n        if bag[1] == 0:\n            result += \"G\"\n        else:\n            result += \"B\"\n\n    return result"
    },
    {
        "number": 810,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if sum(map(int, str(i))) == i:\n            count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 811,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    hours = 0\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            hours += 1\n            if i % 4 == 0:\n                hours += 1\n    return str(hours)"
    },
    {
        "number": 812,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    b = list(map(int, stdin.strip().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if b[i] + b[j] == b[i+1]:\n                return str(j)\n\n    return \"-1\""
    },
    {
        "number": 813,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    arthur_likes = list(map(int, stdin.split()))\n    arthur_likes.sort()\n    arthur_likes = [i for i in range(1, n+1) if i in arthur_likes]\n    arthur_likes.append(n)\n\n    alexander_likes = list(map(int, stdin.split()))\n    alexander_likes.sort()\n    alexander_likes = [i for i in range(1, n+1) if i in alexander_likes]\n    alexander_likes.append(n)\n\n    result = []\n    for i in range(n):\n        if i in arthur_likes:\n            result.append(1)\n        else:\n            result.append(2)\n\n    for i in range(n):\n        if i in alexander_likes:\n            result.append(1)\n        else:\n            result.append(2)\n\n    return ''.join(map(str, result))"
    },
    {
        "number": 814,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    result = []\n\n    for i in range(n):\n        result.append(a[i])\n\n    return''.join(map(str, result))"
    },
    {
        "number": 815,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V_1, V_2, V_3, V_m = map(int, stdin.split())\n\n    if V_1 > V_2 > V_3:\n        father_car_size = V_1\n        mother_car_size = V_2\n        son_car_size = V_3\n    elif V_2 > V_1 > V_3:\n        father_car_size = V_2\n        mother_car_size = V_1\n        son_car_size = V_3\n    else:\n        father_car_size = V_3\n        mother_car_size = V_1\n        son_car_size = V_2\n\n    if V_m <= father_car_size:\n        father_car_size = V_m\n\n    if V_m <= mother_car_size:\n        mother_car_size = V_m\n\n    if V_m <= son_car_size:\n        son_car_size = V_m\n\n    if father_car_size <= mother_car_size:\n        father_car_size = mother_car_size\n\n    if father_car_size <= son_car_size:\n        father_car_size = son_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_size <= father_car_size:\n        father_car_size = father_car_size\n\n    if father_car_"
    },
    {
        "number": 816,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == x:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 817,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    pairs = []\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if s[i] == s[j] and s[i]!= s[j - 1] and s[i]!= s[j + 1]:\n                pairs.append((i, j))\n    pairs.sort(key=lambda x: (-len(s[x[0]:x[1]]), s[x[0]]))\n    result = []\n    for i in range(len(pairs)):\n        result.append(s[pairs[i][0]:pairs[i][1]])\n    return '\\n'.join(result)"
    },
    {
        "number": 818,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 2 or n > 10**5:\n        return \"-1\"\n\n    for i in range(2, n):\n        if n % i == 0:\n            return \"-1\"\n\n    return str(n)"
    },
    {
        "number": 819,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    max_sum = float('-inf')\n    for i in range(k):\n        min_sum = float('inf')\n        for j in range(i, n):\n            min_sum = min(min_sum, a[j])\n        max_sum = max(max_sum, min_sum)\n    return str(max_sum)"
    },
    {
        "number": 820,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    min_drives = 0\n    for i in range(n):\n        if a[i] + m <= m:\n            min_drives += 1\n\n    return str(min_drives)\n"
    },
    {
        "number": 821,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, v_1, v_2, t_1, t_2 = map(int, stdin.split())\n    if t_1 > t_2:\n        t_1, t_2 = t_2, t_1\n    if t_1 > 0 and t_2 > 0:\n        if v_1 > v_2:\n            return \"First\"\n        elif v_1 < v_2:\n            return \"Second\"\n        else:\n            return \"Friendship\"\n    else:\n        return \"No winner\""
    },
    {
        "number": 822,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, z = map(int, stdin.split())\n    artists = []\n    for i in range(1, z + 1):\n        artists.append(i)\n    kill_count = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, z + 1):\n                if i % 2 == 0 and j % 2 == 0 and k % 2 == 0:\n                    kill_count += 1\n                    artists.remove(k)\n    return str(kill_count)"
    },
    {
        "number": 823,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    steps = 0\n    direction = 1\n    x_coord = 0\n    y_coord = 0\n\n    while x_coord!= x or y_coord!= y:\n        steps += 1\n        x_coord += direction\n        y_coord += direction\n\n        if x_coord < 0 or x_coord >= x or y_coord < 0 or y_coord >= y:\n            break\n\n    return str(steps)"
    },
    {
        "number": 824,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    count = 0\n    for i in range(n):\n        if i % 2 == 0:\n            if stdin[i] == \"(\":\n                count += 1\n            elif stdin[i] == \")\":\n                count -= 1\n                if count < 0:\n                    count = 0\n    return str(count)"
    },
    {
        "number": 825,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_count = 0\n\n    for i in range(n):\n        z = 2 ** i\n        if z % n == 0 and z!= i + 1:\n            max_count += 1\n\n    return str(max_count)"
    },
    {
        "number": 826,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 1 or n > 10**18:\n        return \"Invalid input\"\n\n    logs = [1] * (n + 1)\n    logs[1] = 2\n    logs[2] = 4\n    logs[3] = 5\n\n    for i in range(4, n + 1):\n        logs[i] = logs[i - 1] + logs[i - 2] + logs[i - 3]\n\n    min_money = float('inf')\n    for i in range(1, n + 1):\n        min_money = min(min_money, logs[i] * 1)\n\n    return str(min_money)"
    },
    {
        "number": 827,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split())\n    S = \"110\" * 3 * 10**10\n    count = 0\n    for i in range(N - len(T) + 1):\n        if S[i:i+len(T)] == T:\n            count += 1\n    return str(count)"
    },
    {
        "number": 828,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    superiors = [0] * n\n    superiors[s - 1] = 1\n\n    for i in range(1, n):\n        superiors[i] = superiors[i - 1] + superiors[i - 2]\n\n    return str(min(superiors))\n"
    },
    {
        "number": 829,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    k = 1\n    for i in range(1, n):\n        if s[i] == '0':\n            k += 1\n        else:\n            k = 1\n    return str(k)"
    },
    {
        "number": 830,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    towers = []\n    for i in range(n):\n        towers.append(list(map(int, stdin.split())))\n\n    min_instability = float('inf')\n    min_operations = 0\n\n    for i in range(k):\n        for j in range(i, n):\n            if towers[i][j] == 0:\n                continue\n\n            for k in range(i, j):\n                if towers[i][k] == 0 or towers[k][j] == 0:\n                    continue\n\n                heights = [towers[i][k], towers[k][j]]\n                heights.sort()\n                instability = heights[1] - heights[0]\n\n                if instability < min_instability:\n                    min_instability = instability\n                    min_operations = i + 1\n\n    return str(min_operations) +'' + str(min_instability)\n"
    },
    {
        "number": 831,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    prices = [int(x) for x in stdin.split()[2:]]\n    t = \"\"\n    for i in range(n):\n        s = stdin.split()[i+1]\n        a = int(stdin.split()[i+2])\n        t += s[:a]\n        t += s[a:]\n    t = t.replace(\" \", \"\")\n    t = \"\".join(sorted(t, key=lambda x: prices.index(x)))\n    return str(sum(prices))"
    },
    {
        "number": 832,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    games = []\n    for _ in range(n):\n        h, a = map(int, stdin.strip().split())\n        games.append((h, a))\n\n    def count_games(h, a):\n        count = 0\n        for i in range(n):\n            if i == h:\n                count += 1\n            elif i == a:\n                count += 1\n            else:\n                count += 2\n        return count\n\n    result = 0\n    for h, a in games:\n        result += count_games(h, a)\n\n    return str(result)\n"
    },
    {
        "number": 833,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    trees = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        trees.append((a, b))\n\n    def max_fruit(trees):\n        max_fruit = 0\n        for a, b in trees:\n            for i in range(a, b + 1):\n                if i in [t[0] for t in trees if t[0]!= i]:\n                    max_fruit = max(max_fruit, i)\n        return max_fruit\n\n    max_fruit_valera = max_fruit(trees)\n    return str(max_fruit_valera)\n"
    },
    {
        "number": 834,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    f = [int(x) for x in stdin.strip().split()]\n    k = 1\n    while True:\n        if f[k] == f[k - 1]:\n            break\n        k += 1\n    return str(k)"
    },
    {
        "number": 835,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    recipe = stdin.strip()\n    n_b, n_s, n_c = map(int, recipe.split())\n    p_b, p_s, p_c = map(int, recipe.split())\n    r = int(recipe.split()[2])\n\n    max_hamburgers = 0\n    for i in range(n_b):\n        max_hamburgers += 1\n\n    for i in range(n_s):\n        max_hamburgers += 1\n\n    for i in range(n_c):\n        max_hamburgers += 1\n\n    return str(max_hamburgers)"
    },
    {
        "number": 836,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    houses = [\"\".join(line) for line in stdin.split()]\n    houses = [house for house in houses if house!= \".\"]\n    houses = [house for house in houses if house[0] == \"H\"]\n    houses = [house for house in houses if house[0] == \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in houses if house[0]!= \"H\" and house[0]!= \"S\"]\n    houses = [house for house in"
    },
    {
        "number": 837,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    t = 0\n    for i in range(n):\n        t += x + y\n    return str(t)"
    },
    {
        "number": 838,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sets = set()\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        for i in range(m):\n            if row[i] == 1:\n                sets.add(frozenset({i, i+1}))\n            elif row[i] == 0:\n                sets.add(frozenset({i, i+m}))\n    return str(len(sets))"
    },
    {
        "number": 839,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    students = list(map(int, stdin.split()))\n    happiness = [0] * 5\n    for i in range(5):\n        happiness[i] = students[i]\n    for i in range(5, 10):\n        happiness[i] = max(happiness[i-1], happiness[i-2] + students[i-1])\n    return str(max(happiness))"
    },
    {
        "number": 840,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    max_cookies = 0\n    for i in range(n):\n        max_cookies = max(max_cookies, a[i] + b[i])\n\n    return str(max_cookies)\n"
    },
    {
        "number": 841,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        s = []\n        for _ in range(n):\n            s.append(int(stdin.readline()))\n        subsequences = [1337]\n        for i in range(1, n):\n            subsequences.append(subsequences[-1] * s[i])\n        print(''.join(map(str, subsequences)))"
    },
    {
        "number": 842,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 1 or n > 10**10:\n        return \"Invalid input. Please enter a number between 1 and 10^10.\"\n\n    def is_palindrome(num: int) -> bool:\n        return str(num) == str(num)[::-1]\n\n    def is_even_length_palindrome(num: int) -> bool:\n        return len(str(num)) % 2 == 0 and is_palindrome(num)\n\n    def nth_even_length_palindrome(n: int) -> int:\n        for i in range(1, n + 1):\n            if is_even_length_palindrome(i):\n                return i\n        return -1\n\n    return str(nth_even_length_palindrome(n))\n"
    },
    {
        "number": 843,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    directions = stdin.split()[1:]\n    jumps = [int(d) for d in directions]\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append(0)\n    jumps.append"
    },
    {
        "number": 844,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(stdin.strip())\n    max_length = 0\n    current_length = 0\n    for i in range(n):\n        if s[i] == '0':\n            current_length += 1\n        else:\n            current_length -= 1\n            if current_length == 0:\n                max_length = max(max_length, current_length)\n    return str(max_length)"
    },
    {
        "number": 845,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    direction = stdin.strip()\n    sequence = stdin.strip().split()\n    message = \"\"\n\n    for char in sequence:\n        if char == \"L\":\n            message += \" \"\n        elif char == \"R\":\n            message += \" \"\n        else:\n            message += char\n\n    if direction == \"L\":\n        message = message[::-1]\n    elif direction == \"R\":\n        message = message[::-1]\n\n    return message"
    },
    {
        "number": 846,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    buttons = list(map(int, stdin.split()))\n\n    for i in range(m):\n        for j in range(i + 1, n + 1):\n            if buttons[i] == j:\n                buttons[i] = j - 1\n\n    for i in range(n):\n        print(i + 1)\n\n    return \"\""
    },
    {
        "number": 847,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n    cards.sort()\n    found_cards = 0\n    for card in cards:\n        if card >= 0 and card <= x:\n            found_cards += 1\n            if found_cards == n:\n                return str(found_cards)\n    return str(found_cards)"
    },
    {
        "number": 848,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matches = []\n    for _ in range(k):\n        a, b = map(int, stdin.split())\n        matches.append((a, b))\n\n    def is_valid(match):\n        a, b = match\n        return a <= n and b <= n and a!= b\n\n    def is_valid_tournament(matches):\n        for i in range(len(matches)):\n            for j in range(i + 1, len(matches)):\n                if matches[i][0] == matches[j][1] and matches[i][1] == matches[j][0]:\n                    return False\n        return True\n\n    if is_valid_tournament(matches):\n        return str(len(matches))\n\n    return \"-1\""
    },
    {
        "number": 849,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a % 2 == 0 or b % 2 == 0 or c % 2 == 0 or d % 2 == 0:\n        return \"Invalid input\"\n\n    probability_of_shooting_target_first = (a / b) * (c / d)\n    probability_of_shooting_target_second = (a / b) * (d / c)\n\n    if probability_of_shooting_target_first > probability_of_shooting_target_second:\n        return str(probability_of_shooting_target_first)\n    else:\n        return str(probability_of_shooting_target_second)"
    },
    {
        "number": 850,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.readline().strip())\n    d = list(map(int, stdin.readline().strip().split()))\n\n    def is_valid(num: int) -> bool:\n        return all(d[i] == 0 for i in range(k) if num % d[i] == 0)\n\n    def sum_pairs(num: int) -> int:\n        return sum(num // d[i] for i in range(k))\n\n    result = []\n    for num in range(1, 100):\n        if is_valid(num):\n            result.append(num)\n\n    result.sort()\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 851,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    workday = [int(x) for x in stdin.split()]\n    max_break = 0\n    for i in range(n):\n        if workday[i] == 0:\n            max_break = max(max_break, i + 1)\n        else:\n            max_break = max(max_break, i + 1 - workday[i])\n    return str(max_break)"
    },
    {
        "number": 852,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    p = [0] * (k - 2) + [1] * (k - 1) + [0] * (k - 2) + [1] * (k - 1) + [0] * (k - 2) + [1] * (k - 1)\n    t = 0\n    while t < n:\n        if d[t] + p[t % (k - 2)] <= l:\n            t += 1\n        else:\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 853,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cards = list(map(int, stdin.strip().split()))\n\n    max_divisible_by_90 = -1\n    for card in cards:\n        if card % 90 == 0:\n            max_divisible_by_90 = max(max_divisible_by_90, card)\n\n    return str(max_divisible_by_90)"
    },
    {
        "number": 854,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize variables\n    total_candy = 0\n    current_booth = 1\n    current_burles = 0\n\n    # Iterate until Polycarp runs out of money\n    while current_burles < T:\n        # Check if Polycarp has enough burles to buy a candy\n        if current_burles + a[current_booth - 1] <= T:\n            # Buy a candy\n            current_burles += a[current_booth - 1]\n            total_candy += 1\n        else:\n            # Buy no candy\n            current_burles = 0\n\n        # Move to the next booth\n        current_booth += 1\n\n    return str(total_candy)\n"
    },
    {
        "number": 855,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    alice_points = 0\n    bob_points = 0\n    for i in range(k):\n        alice_points += 1\n        alice_choice = int(stdin.split()[i*3+1])\n        bob_choice = int(stdin.split()[i*3+2])\n        if alice_choice == a and bob_choice == b:\n            bob_points += 1\n        elif alice_choice == b and bob_choice == a:\n            alice_points += 1\n    return str(alice_points) + \" \" + str(bob_points)"
    },
    {
        "number": 856,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = max(a)\n    for i in range(n):\n        a[i] = d - a[i]\n    return''.join(map(str, a))"
    },
    {
        "number": 857,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    fingerprints = list(map(int, stdin.split()))\n\n    def is_valid_code(code):\n        return all(digit in fingerprints for digit in code)\n\n    def find_code(sequence):\n        max_length = 0\n        max_code = \"\"\n\n        for i in range(len(sequence)):\n            for j in range(i + 1, len(sequence)):\n                code = sequence[i:j+1]\n                if is_valid_code(code):\n                    length = len(code)\n                    if length > max_length:\n                        max_length = length\n                        max_code = code\n\n        return max_code\n\n    code = find_code(sequence)\n    print(\" \".join(map(str, code)))"
    },
    {
        "number": 858,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N == 1:\n        return \"0\"\n    elif N == 2:\n        return \"1\"\n    else:\n        return str(min(N // 2, 49))"
    },
    {
        "number": 859,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1 = stdin.strip()\n    s_2 = stdin.strip()\n\n    commands = s_1 + s_2\n\n    # Count the number of recognized commands\n    count = 0\n    for command in commands:\n        if command == '+':\n            count += 1\n        elif command == '-':\n            count += 1\n        elif command == '?':\n            count += 1\n\n    # Calculate the probability\n    probability = count / len(commands)\n\n    # Round the probability to 9 decimal places\n    probability = round(probability, 9)\n\n    return str(probability)"
    },
    {
        "number": 860,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Check if the order of events exists\n    if n == 1:\n        if a[0] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 2:\n        if a[0] == 0 and a[1] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 3:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 4:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 5:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 6:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 7:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0 and a[6] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 8:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0 and a[6] == 0 and a[7] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 9:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0 and a[6] == 0 and a[7] == 0 and a[8] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 10:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0 and a[6] == 0 and a[7] == 0 and a[8] == 0 and a[9] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 11:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0 and a[6] == 0 and a[7] == 0 and a[8] == 0 and a[9] == 0 and a[10] == 0:\n            return \"Possible\"\n        else:\n            return \"Impossible\"\n\n    # Check if the order of events is possible\n    if n == 12:\n        if a[0] == 0 and a[1] == 0 and a[2] == 0 and a[3] == 0 and a[4] == 0 and a[5] == 0 and a[6] == 0 and a[7] == 0 and a[8] == 0 and a[9] == 0 and a[10] == "
    },
    {
        "number": 861,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, R = map(int, stdin.split())\n    total_distance = 0\n    for i in range(1, m * m + 1):\n        v = int(i / m) + 1\n        u = m + 1 + (i % m)\n        distance = abs(v - u)\n        total_distance += distance\n    return str(total_distance / (m * m))"
    },
    {
        "number": 862,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    entrances = [0] * n\n    entrances[0] = 1\n    entrances[1] = 2\n    entrances[2] = 3\n    entrances[3] = 4\n    entrances[4] = 5\n    entrances[5] = 6\n    entrances[6] = 7\n    entrances[7] = 8\n    entrances[8] = 9\n    entrances[9] = 10\n\n    for i in range(1, n):\n        entrances[i] = entrances[i-1] + entrances[i-2] + entrances[i-3] + entrances[i-4] + entrances[i-5] + entrances[i-6] + entrances[i-7] + entrances[i-8] + entrances[i-9] + entrances[i-10]\n\n    entrances.sort()\n    entrance = entrances[n-1]\n\n    return str(entrance)"
    },
    {
        "number": 863,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, t_a = map(int, stdin.split())\n    b, t_b = map(int, stdin.split())\n    departure_time = int(stdin.split()[1])\n\n    buses_from_city_a = 0\n    buses_from_city_b = 0\n\n    for i in range(departure_time, 120, t_a):\n        if i % t_a == 0:\n            buses_from_city_a += 1\n\n    for i in range(120, departure_time + 1, t_b):\n        if i % t_b == 0:\n            buses_from_city_b += 1\n\n    return str(buses_from_city_a + buses_from_city_b)\n"
    },
    {
        "number": 864,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    food_types = set(a)\n    max_days = 0\n\n    for i in range(n):\n        food_type = a[i]\n        days = 0\n        for j in range(m):\n            if food_type == a[j]:\n                days += 1\n        max_days = max(max_days, days)\n\n    return str(max_days)"
    },
    {
        "number": 865,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split())\n    happiness = 0\n    dishes_served = set()\n\n    for i in range(N):\n        dish = input().split()\n        dish_kind = dish[0]\n        dish_deliciousness = int(dish[1])\n\n        if dish_kind in dishes_served:\n            happiness += dish_deliciousness\n        else:\n            happiness += dish_deliciousness\n            dishes_served.add(dish_kind)\n\n        if i < T - 0.5:\n            happiness += dish_deliciousness\n\n        if i == T - 1:\n            happiness += dish_deliciousness\n\n    return str(happiness)"
    },
    {
        "number": 866,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def dfs(i, j, steps):\n        if i == X and j == Y:\n            return 1\n        if i < 0 or i >= X or j < 0 or j >= Y:\n            return 0\n\n        if steps % 2 == 0:\n            return dfs(i + 1, j, steps + 1) + dfs(i - 1, j, steps + 1)\n        else:\n            return dfs(i, j + 1, steps + 1) + dfs(i, j - 1, steps + 1)\n\n    return str(dfs(0, 0, 0))"
    },
    {
        "number": 867,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    brains = [0] * N\n    for i in range(1, N):\n        brains[i] = brains[i-1] + 1\n    return str(min(brains))"
    },
    {
        "number": 868,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    return str(int(str(1378 ** n)[-1]))"
    },
    {
        "number": 869,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    max_days = 0\n    days_to_wear_same_socks = 0\n\n    for i in range(a):\n        if i % 2 == 0:\n            max_days += 1\n            days_to_wear_same_socks += 1\n        else:\n            days_to_wear_same_socks += 1\n\n    for i in range(b):\n        max_days += 1\n        days_to_wear_same_socks += 1\n\n    return f\"{max_days} {days_to_wear_same_socks}\""
    },
    {
        "number": 870,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, L, v_1, v_2 = map(int, stdin.split())\n    if d < L:\n        raise ValueError(\"d must be greater than or equal to L\")\n    if v_1 == 0 and v_2 == 0:\n        raise ValueError(\"v_1 and v_2 cannot be zero\")\n    if v_1 == 0:\n        v_1 = v_2\n    if v_2 == 0:\n        v_2 = v_1\n    if v_1 > v_2:\n        v_1, v_2 = v_2, v_1\n    if v_1 == 0:\n        v_1 = 1\n    if v_2 == 0:\n        v_2 = 1\n    max_time = 0\n    for i in range(L):\n        time = (i + 1) * v_1\n        if time > max_time:\n            max_time = time\n    return str(max_time)"
    },
    {
        "number": 871,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    h, m = map(int, stdin.split())\n    h, m = h % 24, m % 60\n    h, m = h + 1, m\n    return str(h) + \" \" + str(m)"
    },
    {
        "number": 872,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + a[j] % 2 == 1:\n                a[i], a[j] = a[j], a[i]\n\n    return''.join(map(str, a))"
    },
    {
        "number": 873,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    digits = list(map(int, stdin.strip()))\n    combination = list(map(int, stdin.strip()))\n\n    moves = 0\n    for i in range(n):\n        if i == 0:\n            moves += 1\n            continue\n\n        if i == n - 1:\n            moves += 1\n            continue\n\n        if digits[i] == digits[i - 1]:\n            moves += 1\n            continue\n\n        if digits[i] == digits[i + 1]:\n            moves += 1\n            continue\n\n        if digits[i] == combination[i]:\n            moves += 1\n            continue\n\n        if digits[i] == combination[i - 1]:\n            moves += 1\n            continue\n\n        if digits[i] == combination[i + 1]:\n            moves += 1\n            continue\n\n    return str(moves)"
    },
    {
        "number": 874,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"-1\"\n    else:\n        p = [i for i in range(1, n+1)]\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if p[i] == p[j]:\n                    p[i], p[j] = p[j], p[i]\n        return \" \".join(map(str, p))"
    },
    {
        "number": 875,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    vertices = list(map(int, stdin.readline().strip().split()))\n    matrix = list(map(list, stdin.readline().strip().split()))\n\n    def dfs(x, y, color, visited):\n        if x == 1 and y == 2 and color == 'a':\n            return True\n        if x == 1 and y == 3 and color == 'b':\n            return True\n        if x == 2 and y == 3 and color == 'c':\n            return True\n        if x == n and y == 1 and color == 'b':\n            return True\n        if x == n and y == 2 and color == 'c':\n            return True\n        if x == n and y == 3 and color == 'a':\n            return True\n        if x == 1 and y == 2 and color == 'b':\n            return True\n        if x == 1 and y == 3 and color == 'c':\n            return True\n        if x == 2 and y == 3 and color == 'a':\n            return True\n        if x == n and y == 1 and color == 'c':\n            return True\n        if x == n and y == 2 and color == 'a':\n            return True\n        if x == n and y == 3 and color == 'b':\n            return True\n        if x == 1 and y == 2 and color == 'c':\n            return True\n        if x == 1 and y == 3 and color == 'a':\n            return True\n        if x == 2 and y == 3 and color == 'b':\n            return True\n        if x == n and y == 1 and color == 'a':\n            return True\n        if x == n and y == 2 and color == 'b':\n            return True\n        if x == n and y == 3 and color == 'c':\n            return True\n        if x == 1 and y == 2 and color == 'a':\n            return True\n        if x == 1 and y == 3 and color == 'b':\n            return True\n        if x == 2 and y == 3 and color == 'c':\n            return True\n        if x == n and y == 1 and color == 'b':\n            return True\n        if x == n and y == 2 and color == 'c':\n            return True\n        if x == n and y == 3 and color == 'a':\n            return True\n        if x == 1 and y == 2 and color == 'c':\n            return True\n        if x == 1 and y == 3 and color == 'a':\n            return True\n        if x == 2 and y == 3 and color == 'b':\n            return True\n        if x == n and y == 1 and color == 'c':\n            return True\n        if x == n and y == 2 and color == 'a':\n            return True\n        if x == n and y == 3 and color == 'b':\n            return True\n        if x == 1 and y == 2 and color == 'a':\n            return True\n        if x == 1 and y == 3 and color == 'b':\n            return True\n        if x == 2 and y == 3 and color == 'c':\n            return True\n        if x == n and y == 1 and color == 'c':\n            return True\n        if x == n and y == 2 and color == 'a':\n            return True\n        if x == n and y == 3 and color == 'b':\n            return True\n        if x == 1 and y == 2 and color == 'a':\n            return True\n        if x == 1 and y == 3 and color == 'b':\n            return True\n        if x == 2 and y == 3 and color == 'c':\n            return True\n        if x == n and y == 1 and color == 'c':\n            return True\n        if x == n and y == 2 and color == 'a':\n            return True\n        if x == n and y == 3 and color == 'b':\n            return True\n        if x == 1 and y == 2 and color == 'a':\n            return True\n        if x == 1 and y == 3 and color == 'b':\n            return True\n        if x == 2 and y == 3 and color == 'c':\n            return True\n        if x == n and y == 1 and color == 'c':\n            return True\n        if x == n and y == 2 and color == 'a':\n            return True\n        if x == n and y == 3 and color == 'b':\n            return True\n        if x == 1 and y == 2 and color == 'a':\n            return True\n        if x == 1 and y == 3"
    },
    {
        "number": 876,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = [int(x) for x in stdin.split()]\n\n    def p(x):\n        return [x[i] for i in range(len(x)) if i < len(x) - 1]\n\n    def sum_of_first_k(x):\n        return sum(x[:k])\n\n    def contains_larger_or_equal_than_k(x):\n        return any(x[i] >= k for i in range(len(x)))\n\n    i = 0\n    while contains_larger_or_equal_than_k(p(A)):\n        i += 1\n\n    return str(i)\n"
    },
    {
        "number": 877,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        pairs.append((u, v))\n\n    def dfs(divisions, used, seen):\n        if len(divisions) == 2:\n            return 1\n\n        if len(used) == n:\n            return 0\n\n        if len(seen) == n:\n            return 0\n\n        if len(used) == 0:\n            return 0\n\n        if len(divisions) == 1:\n            return 0\n\n        if len(divisions) == 2:\n            return 1\n\n        if len(pairs) == 0:\n            return 0\n\n        if len(pairs) == 1:\n            return 1\n\n        for i in range(len(pairs)):\n            if pairs[i][0] in used or pairs[i][1] in used:\n                continue\n\n            if pairs[i][0] in divisions and pairs[i][1] not in divisions:\n                used.add(pairs[i][0])\n                seen.add(pairs[i][1])\n                result = dfs(divisions, used, seen)\n                used.remove(pairs[i][0])\n                seen.remove(pairs[i][1])\n                return result\n\n        return 0\n\n    return str(dfs([1, 2], set(), set()))"
    },
    {
        "number": 878,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate the maximum possible length of side for triangle and square\n    max_side = max(a[i] for i in range(n))\n\n    # Calculate the maximum possible radius for circle\n    max_radius = max(a[i] for i in range(n))\n\n    # Calculate the number of distinct points where figures touch\n    distinct_points = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                distinct_points += 1\n\n    # Check if the number of distinct points is infinite\n    if distinct_points == n * (n - 1) // 2:\n        return \"Infinite\"\n    else:\n        return str(distinct_points)\n"
    },
    {
        "number": 879,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n    path = []\n    path.append(1)\n    for i in range(2, n+1):\n        path.append(p[i-1]+1)\n    return''.join(map(str, path))"
    },
    {
        "number": 880,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = [1] * (n * n)\n    p[0] = 1\n    for i in range(1, n * n):\n        p[i] = p[i - 1] + p[i - n * n]\n    subarrays = []\n    for i in range(n):\n        for j in range(i + 1, n * n):\n            subarray = [p[k] for k in range(i, j + 1)]\n            subarray_sum = sum(subarray)\n            if subarray_sum == n * (n + 1) // 2:\n                subarrays.append(subarray)\n    return str(sum(subarrays))"
    },
    {
        "number": 881,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for _ in range(n):\n        i, j = 0, n - 1\n        while i < j:\n            if a[i] == a[j]:\n                a[i], a[j] = a[j], a[i]\n                j -= 1\n            elif a[i] < a[j]:\n                i += 1\n            else:\n                j -= 1\n\n    return str(min(a))"
    },
    {
        "number": 882,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    max_count = 0\n    for i in range(len(s)):\n        if s[i] == '?' and t[i] == '?':\n            max_count = max(max_count, i - len(t) + 1)\n    return str(max_count)"
    },
    {
        "number": 883,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fingers = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(n):\n        count += fingers[i]\n    print(count)\n    return \"\""
    },
    {
        "number": 884,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    red_islands = set(range(1, a + 1))\n    blue_islands = set(range(a + 1, 2 * a + 1))\n    purple_islands = set(range(2 * a + 1, 3 * a + 1))\n\n    valid_bridges = set()\n    for i in range(len(red_islands)):\n        for j in range(i + 1, len(red_islands)):\n            for k in range(j + 1, len(red_islands)):\n                if red_islands.issubset(set(range(i, j + 1)) | set(range(j, k + 1)) | set(range(k, len(red_islands)))):\n                    valid_bridges.add((i, j, k))\n\n    invalid_bridges = set()\n    for i in range(len(blue_islands)):\n        for j in range(i + 1, len(blue_islands)):\n            for k in range(j + 1, len(blue_islands)):\n                if blue_islands.issubset(set(range(i, j + 1)) | set(range(j, k + 1)) | set(range(k, len(blue_islands)))):\n                    invalid_bridges.add((i, j, k))\n\n    for i in range(len(purple_islands)):\n        for j in range(i + 1, len(purple_islands)):\n            for k in range(j + 1, len(purple_islands)):\n                if purple_islands.issubset(set(range(i, j + 1)) | set(range(j, k + 1)) | set(range(k, len(purple_islands)))):\n                    invalid_bridges.add((i, j, k))\n\n    return str(len(valid_bridges)) + '\\n' + str(len(invalid_bridges)) + '\\n' + str(len(valid_bridges) + len(invalid_bridges))"
    },
    {
        "number": 885,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in tree[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    dfs(0, visited)\n\n    def sum_independent_sets(u, visited):\n        if not visited[u]:\n            return 0\n        return 1 + sum(sum_independent_sets(v, visited) for v in tree[u])\n\n    return str(sum_independent_sets(0, visited))"
    },
    {
        "number": 886,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return str(n)\n    else:\n        return str(n - 1)"
    },
    {
        "number": 887,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    buttons = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        if buttons[0] == 1:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    for i in range(1, n):\n        if buttons[i] == 1:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 888,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    s = list(map(int, stdin.readline().strip().split()))\n\n    def swap(p, i, j):\n        p[i], p[j] = p[j], p[i]\n        return p\n\n    def get_permutation(p, s):\n        n = len(p)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] == p[j]:\n                    return False\n        return True\n\n    def get_solution(p, s):\n        n = len(p)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] == p[j]:\n                    return False\n        return True\n\n    def get_coins(p, s):\n        n = len(p)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] == p[j]:\n                    return 0\n        return 1\n\n    def get_operations(p, s):\n        n = len(p)\n        operations = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] == p[j]:\n                    operations.append((i, j))\n        return operations\n\n    def get_min_coins(p, s):\n        n = len(p)\n        min_coins = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if get_permutation(p, s) and get_solution(p, s):\n                    min_coins = min(min_coins, get_coins(p, s))\n        return min_coins\n\n    min_coins = get_min_coins(p, s)\n    print(min_coins)\n\n    operations = get_operations(p, s)\n    for i, j in operations:\n        print(i, j)\n\n    return \"\""
    },
    {
        "number": 889,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = len(stdin.splitlines())\n    cols = len(stdin.splitlines()[0])\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \"#\":\n                stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \".\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \"#\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \".\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \"#\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \".\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \"#\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \".\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \"#\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n                else:\n                    if j == 0 or j == cols - 1:\n                        stdin[i][j] = \"#\"\n                    else:\n                        stdin[i][j] = \".\"\n\n    for i in range(rows):\n        for j in range(cols):\n            if stdin[i][j] == \".\":\n                if i == 0 or i == rows - 1:\n                    if j == 0 or j == cols - 1"
    },
    {
        "number": 890,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r, x = map(int, stdin.split())\n    problem_difficulty = [int(c) for c in stdin.split()]\n\n    def backtrack(remain_difficulty, current_problem_index, current_problem_difficulty, current_problem_set):\n        if current_problem_index == n:\n            return 1\n\n        if remain_difficulty == 0:\n            return 0\n\n        if current_problem_index == 0:\n            return backtrack(remain_difficulty - problem_difficulty[current_problem_index], current_problem_index + 1, problem_difficulty[current_problem_index], current_problem_set)\n\n        if current_problem_set:\n            return backtrack(remain_difficulty - problem_difficulty[current_problem_index], current_problem_index + 1, problem_difficulty[current_problem_index], current_problem_set)\n\n        return backtrack(remain_difficulty, current_problem_index + 1, problem_difficulty[current_problem_index], current_problem_set)\n\n    return str(backtrack(r, 0, problem_difficulty[0], set()))"
    },
    {
        "number": 891,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    chips = list(map(str, stdin.split()))\n    colors = ['W', 'B']\n    for _ in range(k):\n        for i in range(n):\n            if chips[i] == 'W':\n                if i == 1 or chips[i - 1] == 'B':\n                    chips[i] = 'B'\n                elif i == n - 1 or chips[i + 1] == 'B':\n                    chips[i] = 'B'\n            else:\n                if i == 1 or chips[i - 1] == 'W':\n                    chips[i] = 'W'\n                elif i == n - 1 or chips[i + 1] == 'W':\n                    chips[i] = 'W'\n    return ''.join(colors)"
    },
    {
        "number": 892,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    lcm = 1\n    for i in range(1, n):\n        lcm *= a[i]\n\n    k_max = 0\n    for i in range(n):\n        if a[i] * lcm <= m:\n            k_max += 1\n\n    subseq = []\n    for i in range(n):\n        if a[i] * lcm <= m:\n            subseq.append(i)\n\n    subseq.sort()\n\n    return str(k_max) + \" \" + \" \".join(map(str, subseq))\n"
    },
    {
        "number": 893,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    edges = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    tree = [[] for _ in range(n)]\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    valid_sets = []\n    for i in range(n):\n        if tree[i]:\n            valid_sets.append(i)\n\n    count = 0\n    for set_ in valid_sets:\n        count += 1\n        if count % 1000000007 == 0:\n            print(count)\n\n    return str(count % 1000000007)"
    },
    {
        "number": 894,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    x_1, y_1, x_2, y_2 = 0, 0, 0, 0\n\n    if x == 0 and y == 0:\n        return \"0 0 0 0\"\n\n    if x == 0:\n        x_1, y_1 = y, x\n        x_2, y_2 = y, x\n    elif y == 0:\n        x_1, y_1 = x, y\n        x_2, y_2 = x, y\n\n    if x_1 > x_2:\n        x_1, x_2 = x_2, x_1\n        y_1, y_2 = y_2, y_1\n\n    if x_1 < 0 or x_1 > 1000000 or x_2 < 0 or x_2 > 1000000 or y_1 < 0 or y_1 > 1000000 or y_2 < 0 or y_2 > 1000000:\n        return \"Invalid input\"\n\n    if x_1 == x_2 and y_1 == y_2:\n        return \"Invalid input\"\n\n    if x_1 == x_2:\n        x_1, y_1 = x_1, y_2\n        x_2, y_2 = x_2, y_1\n\n    if y_1 == y_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2, y_2 = x_1, y_2\n\n    if x_1 == x_2:\n        x_1, y_1 = x_2, y_1\n        x_2"
    },
    {
        "number": 895,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    T = int(T)\n\n    max_count = 0\n    for i in range(n):\n        if t[i] - t[i - 1] > T:\n            max_count += 1\n\n    return str(max_count)\n"
    },
    {
        "number": 896,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def xor(a, b):\n        return sum(a & b)\n\n    def find_matrix(a, b):\n        n, m = len(a), len(b)\n        for i in range(n):\n            for j in range(m):\n                if a[i] ^ b[j] == 0:\n                    return True\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == 0:\n                return \"NO\"\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if a[i] ^ b[j] == "
    },
    {
        "number": 897,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    s1 = list(map(int, stdin.split()))\n    s2 = list(map(int, stdin.split()))\n\n    # Calculate the probability\n    p = 0\n    for i in range(n):\n        if a[i] == 0:\n            p += 1\n\n    q = 1\n    for i in range(n):\n        if a[i] == 0:\n            q += 1\n\n    r = pow(p, q, 10**9 + 7)\n\n    return str(r)"
    },
    {
        "number": 898,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    a = [int(x) for x in input().split()]\n    max_gcd = 1\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if a[i] + a[j] + a[k] == M:\n                    gcd = a[i] * a[j] * a[k] // max_gcd\n                    if gcd > max_gcd:\n                        max_gcd = gcd\n    print(max_gcd)\n    return \"\""
    },
    {
        "number": 899,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    edges = []\n    for _ in range(M):\n        a, b, c = map(int, stdin.split())\n        edges.append((a, b, c))\n\n    def is_connected(graph, start, end):\n        visited = [False] * N\n        stack = [(start, 0)]\n        while stack:\n            node, distance = stack.pop()\n            if node == end:\n                return True\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    stack.append((neighbor, distance + weight))\n        return False\n\n    def is_not_contained_in_any_shortest_path(graph, start, end):\n        visited = [False] * N\n        stack = [(start, 0)]\n        while stack:\n            node, distance = stack.pop()\n            if node == end:\n                return True\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    stack.append((neighbor, distance + weight))\n        return False\n\n    not_contained_in_any_shortest_path = 0\n    for a, b, c in edges:\n        if not is_connected(edges, a, b) and not is_connected(edges, b, a):\n            not_contained_in_any_shortest_path += 1\n\n    return str(not_contained_in_any_shortest_path)"
    },
    {
        "number": 900,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    count = 0\n    for char in S:\n        if char == '?':\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 901,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    groups = []\n    for _ in range(m):\n        k, *v = map(int, stdin.split())\n        groups.append((k, v))\n\n    def is_traitor(group):\n        return any(v < 0 for v in group)\n\n    def is_endless(group):\n        return all(is_traitor(g) for g in groups)\n\n    scenarios = [\n        (is_endless, is_endless),\n        (is_endless, lambda g: not any(is_traitor(g) for g in groups)),\n        (lambda g: not any(is_traitor(g) for g in groups), is_endless),\n    ]\n\n    for scenario in scenarios:\n        if scenario[0](groups):\n            return \"YES\"\n        elif scenario[1](groups):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 902,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    power = [a[i] for i in range(n)]\n    power.sort()\n    winner = power[k-1]\n    return str(winner)"
    },
    {
        "number": 903,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Sort the array in non-decreasing order\n    a.sort()\n\n    # Find the median\n    if n % 2 == 0:\n        median = (a[n // 2 - 1] + a[n // 2]) / 2\n    else:\n        median = a[n // 2]\n\n    # Perform k operations\n    for _ in range(k):\n        # Choose one of the elements and increase it by 1\n        a[a.index(max(a)) + 1] += 1\n\n    # Find the maximum possible median\n    max_median = max(a)\n\n    return str(max_median)\n"
    },
    {
        "number": 904,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    text = stdin.readline().strip()\n    words = text.split()\n    volume = 0\n    for word in words:\n        volume += len(word)\n    return str(volume)"
    },
    {
        "number": 905,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    sugar_types = set()\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        sugar_types.add(x)\n        sugar_types.add(y)\n\n    max_sweets = -1\n    for sugar in sugar_types:\n        change = s - sugar\n        if change > 0:\n            max_sweets = max(max_sweets, change)\n\n    return str(max_sweets)"
    },
    {
        "number": 906,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    MOD = 1000000007\n    dp = [[0] * m for _ in range(n)]\n    dp[0][0] = 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if k == 1:\n                dp[i][j] = dp[i - 1][j]\n            elif k == -1:\n                dp[i][j] = dp[i][j - 1]\n            else:\n                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD\n\n    return str(dp[n - 1][m - 1])"
    },
    {
        "number": 907,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    x, y = None, None\n    for a, b in pairs:\n        if a == x or b == x:\n            x = None\n        elif a == y or b == y:\n            y = None\n        else:\n            x, y = a, b\n            break\n\n    if x is None and y is None:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 908,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    c = list(map(int, stdin.strip().split()))\n    strings = []\n    for i in range(n):\n        strings.append(stdin.strip())\n\n    def reverse_string(s: str) -> str:\n        return s[::-1]\n\n    def is_reverse_possible(s1: str, s2: str) -> bool:\n        return s1 == reverse_string(s2)\n\n    def min_energy(strings: List[str]) -> int:\n        min_energy = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_reverse_possible(strings[i], strings[j]):\n                    min_energy = min(min_energy, c[i] + c[j])\n        return min_energy\n\n    return str(min_energy)\n"
    },
    {
        "number": 909,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    max_value = 0\n    for i in range(a, b+1):\n        for j in range(b, c+1):\n            for k in range(c, a-1, -1):\n                expression = str(i) + \"+\" + str(j) + \"*\" + str(k)\n                if int(expression) > max_value:\n                    max_value = int(expression)\n    return str(max_value)"
    },
    {
        "number": 910,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    hall = [[0] * b for _ in range(n)]\n    for i in range(n):\n        hall[i] = list(map(int, stdin.split()))\n\n    def is_valid(row, col):\n        return 0 <= row < n and 0 <= col < b\n\n    def find_seat(row, col):\n        for i in range(n):\n            if hall[i][col] == 0:\n                return i, col\n        return -1, -1\n\n    def assign_seats(row, col):\n        for i in range(n):\n            if hall[i][col] == 0:\n                hall[i][col] = row\n                return True\n        return False\n\n    def find_seats(row, col):\n        seats = []\n        for i in range(n):\n            if hall[i][col] == row:\n                seats.append(i)\n        return seats\n\n    def assign_seats_to_party(party):\n        for i in range(n):\n            if hall[i][0] == party:\n                hall[i][0] = 0\n                hall[i][1] = 0\n                return True\n        return False\n\n    def find_seats_to_party(party):\n        seats = []\n        for i in range(n):\n            if hall[i][0] == party:\n                seats.append(i)\n        return seats\n\n    def find_seats_to_party_and_assign(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats(seat, 0):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party_and_assign(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign_to_party(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party_and_assign_to_party(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party_and_assign_to_party_and_assign(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party_and_assign_to_party_and_assign_to_party(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party_and_assign(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party(party):\n        seats = find_seats_to_party(party)\n        for seat in seats:\n            if assign_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party(seat):\n                return seat\n        return -1\n\n    def find_seats_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party_and_assign_to_party_and_assign(party):\n        seats = find_seats_to_party(party)\n        for"
    },
    {
        "number": 911,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    # Sort problems by difficulty\n    p.sort()\n    t.sort()\n\n    # Calculate the maximum score for each problem\n    max_score = [0] * n\n    for i in range(n):\n        max_score[i] = p[i] + t[i]\n\n    # Calculate the maximum score for each problem\n    max_score.sort()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score.reverse()\n\n    # Calculate the maximum score for each problem\n    max_score"
    },
    {
        "number": 912,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Find the floor with the closest open restaurant\n    closest_floor = min(a)\n    closest_floor_index = a.index(closest_floor)\n\n    # Calculate the number of staircases required\n    num_staircases = 0\n    for i in range(closest_floor_index + 1, n):\n        num_staircases += 1\n\n    return str(num_staircases)\n"
    },
    {
        "number": 913,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    r = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    max_points = -1\n    for i in range(n):\n        if r[i] == 1:\n            max_points = max(max_points, b[i])\n\n    return str(max_points)"
    },
    {
        "number": 914,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = int(stdin.strip())\n\n    if n == 1:\n        return s\n\n    min_sheets = n\n    sheets = [s]\n\n    for i in range(1, n):\n        sheets.append(sheets[i - 1] + s[i - 1])\n\n    min_sheets = min(min_sheets, len(sheets))\n\n    return ''.join(sheets[:min_sheets])\n"
    },
    {
        "number": 915,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    subsequences = [''.join(sorted(set(s))) for s in itertools.permutations('abcdefghijklmnopqrstuvwxyz')]\n    shortest = min(subsequences, key=len)\n    return shortest"
    },
    {
        "number": 916,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    p = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(node, path):\n        if node == 1:\n            return 1\n        if node == n:\n            return 0\n\n        if node == 0:\n            return 0\n\n        if node == n - 1:\n            return 0\n\n        if node == n - 2:\n            return 1\n\n        if node == n - 3:\n            return 1\n\n        if node == n - 4:\n            return 1\n\n        if node == n - 5:\n            return 1\n\n        if node == n - 6:\n            return 1\n\n        if node == n - 7:\n            return 1\n\n        if node == n - 8:\n            return 1\n\n        if node == n - 9:\n            return 1\n\n        if node == n - 10:\n            return 1\n\n        if node == n - 11:\n            return 1\n\n        if node == n - 12:\n            return 1\n\n        if node == n - 13:\n            return 1\n\n        if node == n - 14:\n            return 1\n\n        if node == n - 15:\n            return 1\n\n        if node == n - 16:\n            return 1\n\n        if node == n - 17:\n            return 1\n\n        if node == n - 18:\n            return 1\n\n        if node == n - 19:\n            return 1\n\n        if node == n - 20:\n            return 1\n\n        if node == n - 21:\n            return 1\n\n        if node == n - 22:\n            return 1\n\n        if node == n - 23:\n            return 1\n\n        if node == n - 24:\n            return 1\n\n        if node == n - 25:\n            return 1\n\n        if node == n - 26:\n            return 1\n\n        if node == n - 27:\n            return 1\n\n        if node == n - 28:\n            return 1\n\n        if node == n - 29:\n            return 1\n\n        if node == n - 30:\n            return 1\n\n        if node == n - 31:\n            return 1\n\n        if node == n - 32:\n            return 1\n\n        if node == n - 33:\n            return 1\n\n        if node == n - 34:\n            return 1\n\n        if node == n - 35:\n            return 1\n\n        if node == n - 36:\n            return 1\n\n        if node == n - 37:\n            return 1\n\n        if node == n - 38:\n            return 1\n\n        if node == n - 39:\n            return 1\n\n        if node == n - 40:\n            return 1\n\n        if node == n - 41:\n            return 1\n\n        if node == n - 42:\n            return 1\n\n        if node == n - 43:\n            return 1\n\n        if node == n - 44:\n            return 1\n\n        if node == n - 45:\n            return 1\n\n        if node == n - 46:\n            return 1\n\n        if node == n - 47:\n            return 1\n\n        if node == n - 48:\n            return 1\n\n        if node == n - 49:\n            return 1\n\n        if node == n - 50:\n            return 1\n\n        if node == n - 51:\n            return 1\n\n        if node == n - 52:\n            return 1\n\n        if node == n - 53:\n            return 1\n\n        if node == n - 54:\n            return 1\n\n        if node == n - 55:\n            return 1\n\n        if node == n - 56:\n            return 1\n\n        if node == n - 57:\n            return 1\n\n        if node == n - 58:\n            return 1\n\n        if node == n - 59:\n            return 1\n\n        if node == n - 60:\n            return 1\n\n        if node == n - 61:\n            return 1\n\n        if node == n - 62:\n            return 1\n\n        if node == n - 63:\n            return 1\n\n        if node == n - 64:\n            return 1\n\n        if node == n - 65:\n            return 1\n\n        if node == n - 66:\n            return 1\n\n        if node == n - 67:\n            return 1\n\n        if node == n - 68:"
    },
    {
        "number": 917,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m = map(int, stdin.split())\n    restrictions = []\n    for _ in range(m):\n        l, r, x = map(int, stdin.split())\n        restrictions.append((l, r, x))\n\n    max_profit = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for r in range(l + 1, n + 1):\n                        if restrictions[i][0] <= l <= restrictions[i][1] and restrictions[j][0] <= r <= restrictions[j][1] and restrictions[k][0] <= l <= restrictions[k][1] and restrictions[l][0] <= r <= restrictions[l][1]:\n                            max_profit = max(max_profit, restrictions[i][2] * restrictions[j][2] * restrictions[k][2] * restrictions[l][2])\n\n    return str(max_profit)"
    },
    {
        "number": 918,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    participants = []\n    for _ in range(n):\n        surname, region, points = stdin.split()\n        participants.append((surname, region, points))\n\n    teams = []\n    for i in range(m):\n        team = []\n        for j in range(n):\n            if j == i:\n                team.append(participants[j][0])\n            else:\n                team.append(\"?\")\n        teams.append(\" \".join(team))\n\n    return \"\\n\".join(teams)"
    },
    {
        "number": 919,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n    stages = [s[i:i+1] for i in range(0, len(s), 1)]\n    weights = [0] * n\n    for i in range(1, n):\n        weights[i] = sum(1 for j in range(i) if s[i:j+1] == s[i:i+1])\n    min_weight = min(weights)\n    if min_weight == 0:\n        return -1\n    for i in range(n):\n        if weights[i] >= min_weight:\n            for j in range(i+1, n):\n                if weights[j] >= min_weight:\n                    return -1\n    return min_weight"
    },
    {
        "number": 920,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    guardposts = []\n    for _ in range(n):\n        a, b, c, d = map(int, stdin.strip().split())\n        guardposts.append((a, b, c, d))\n\n    def min_price(guardpost):\n        return min(guardpost[0], guardpost[1])\n\n    def max_price(guardpost):\n        return max(guardpost[0], guardpost[1])\n\n    def can_sneak(guards):\n        for guard in guards:\n            if guard[0] < min_price(guard) or guard[1] < min_price(guard):\n                return False\n        return True\n\n    def sneak_through(guards):\n        for i in range(len(guards)):\n            for j in range(i + 1, len(guards)):\n                if guards[i][0] > max_price(guards[j]) or guards[i][1] > max_price(guards[j]):\n                    return False\n        return True\n\n    for guardpost in guardposts:\n        if can_sneak(guardpost):\n            if sneak_through(guardpost):\n                return \" \".join(map(str, guardpost))\n\n    return \"-1\""
    },
    {
        "number": 921,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the maximum volume of tea in each cup\n    max_volume = max(a)\n\n    # Calculate the number of cups required\n    num_cups = n // 2\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of milliliters of tea required for each cup\n    num_mililiters_per_cup = [0] * num_cups\n    for i in range(num_cups):\n        num_mililiters_per_cup[i] = int(w / (a[i] + a[i + 1]))\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0] * n\n    for i in range(n):\n        num_cups_per_friend[i] = num_cups // (a[i] + a[i + 1])\n\n    # Calculate the number of cups required for each friend\n    num_cups_per_friend = [0]"
    },
    {
        "number": 922,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    b = [0] * n\n    for i in range(n):\n        b[i] = sum(d[:i+1])\n    return str(b)"
    },
    {
        "number": 923,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"No\"\n\n    for i in range(n - 1):\n        if sequence[i] == sequence[i + 1]:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 924,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_a, r_a, t_a = map(int, stdin.split())\n    l_b, r_b, t_b = map(int, stdin.split())\n\n    # Calculate the number of days in the row\n    n = (r_a + t_a - 1) // t_a\n\n    # Calculate the number of days in the row for Alice\n    k = l_a + t_a - 1\n    n_alice = (r_a + k * t_a - 1) // k\n\n    # Calculate the number of days in the row for Bob\n    k = l_b + t_b - 1\n    n_bob = (r_b + k * t_b - 1) // k\n\n    # Calculate the maximum number of days in the row\n    max_days = max(n, n_alice, n_bob)\n\n    return str(max_days)\n"
    },
    {
        "number": 925,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(10):\n        if n % 10 == i:\n            count += 1\n    return str(count)"
    },
    {
        "number": 926,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    stones = []\n    for _ in range(n):\n        a, b, c = map(int, stdin.strip().split())\n        stones.append((a, b, c))\n\n    def is_valid(a, b, c):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000\n\n    def is_valid_pair(a, b, c, d, e, f):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000\n\n    def is_valid_present(a, b, c, d, e, f):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000\n\n    def is_valid_gluing(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000 and 1 <= g <= 1000 and 1 <= h <= 1000\n\n    def is_valid_glue(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000 and 1 <= g <= 1000 and 1 <= h <= 1000\n\n    def is_valid_rotation(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000 and 1 <= g <= 1000 and 1 <= h <= 1000\n\n    def is_valid_flip(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000 and 1 <= g <= 1000 and 1 <= h <= 1000\n\n    def is_valid_present_pair(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000 and 1 <= g <= 1000 and 1 <= h <= 1000\n\n    def is_valid_present_gluing(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 1000 and 1 <= e <= 1000 and 1 <= f <= 1000 and 1 <= g <= 1000 and 1 <= h <= 1000\n\n    def is_valid_present_glue(a, b, c, d, e, f, g, h):\n        return 1 <= a <= 1000 and 1 <= b <= 1000 and 1 <= c <= 1000 and 1 <= d <= 10"
    },
    {
        "number": 927,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    digits = [chr(i) for i in range(10)]\n    matchstick_count = [2, 5, 5, 4, 5, 6, 3, 7, 6]\n\n    max_num = 0\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                for l in range(10):\n                    for m in range(10):\n                        for n in range(10):\n                            for o in range(10):\n                                for p in range(10):\n                                    for q in range(10):\n                                        for r in range(10):\n                                            for s in range(10):\n                                                for t in range(10):\n                                                    for u in range(10):\n                                                        for v in range(10):\n                                                            for w in range(10):\n                                                                for x in range(10):\n                                                                    for y in range(10):\n                                                                        for z in range(10):\n                                                                            num = int(digits[i] + digits[j] + digits[k] + digits[l] + digits[m] + digits[n] + digits[o] + digits[p] + digits[q] + digits[r] + digits[s] + digits[t] + digits[u] + digits[v] + digits[w] + digits[x] + digits[y] + digits[z])\n                                                                            if num == 0:\n                                                                                continue\n                                                                            if num > max_num:\n                                                                                max_num = num\n\n    return str(max_num)"
    },
    {
        "number": 928,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(N - K + 1):\n        if sum(A[i:i+K]) >= K:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 929,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(H)]\n\n    def dfs(i, j, coins):\n        if i < 0 or i >= H or j < 0 or j >= W or a[i][j] == 0:\n            return 0\n\n        if a[i][j] % 2 == 0:\n            coins += 1\n\n        if i > 0 and a[i][j] == a[i - 1][j]:\n            coins += dfs(i - 1, j, coins)\n\n        if j > 0 and a[i][j] == a[i][j - 1]:\n            coins += dfs(i, j - 1, coins)\n\n        return coins\n\n    coins = dfs(0, 0, 0)\n    operations = []\n\n    for i in range(H):\n        for j in range(W):\n            if a[i][j] == 0:\n                coins = dfs(i, j, coins)\n                operations.append((i, j, coins))\n\n    operations.sort(key=lambda x: x[2])\n\n    for i in range(len(operations)):\n        print(operations[i][2])\n\n    return \"\""
    },
    {
        "number": 930,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def combination(room):\n        count = 1\n        for i in range(n):\n            if i!= room:\n                count = (count * (i + 1)) % MOD\n        return count\n\n    count = 1\n    for i in range(1, n + 1):\n        count = (count * combination(i)) % MOD\n    return str(count)"
    },
    {
        "number": 931,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, z, p = map(int, stdin.split())\n    candies = []\n    for _ in range(p):\n        x1, y1 = map(int, stdin.split())\n        candies.append((x1, y1))\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 or j == 1 or i == n or j == m:\n                continue\n            if (i, j) in candies:\n                print(i, j)\n            else:\n                print(j, i)\n\n    return '\\n'.join(map(str, candies))"
    },
    {
        "number": 932,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    A = [[0] * n for _ in range(m)]\n    B = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n        for j in range(n):\n            A[i][j] = int(stdin.split()[j])\n\n    for i in range(m):\n        for j in range(n):\n            B[i][j] = 0\n            for k in range(i):\n                if A[k][j] == 1 and A[i][j] == 1:\n                    B[i][j] = 1\n                    break\n\n    if B == [[0] * n for _ in range(m)]:\n        return \"NO\"\n    else:\n        for i in range(m):\n            for j in range(n):\n                if B[i][j] == 1:\n                    print(i + 1, end=\" \")\n        print()\n        for i in range(m):\n            for j in range(n):\n                if B[i][j] == 1:\n                    print(j + 1, end=\" \")\n        print()\n        for i in range(m):\n            for j in range(n):\n                if B[i][j] == 1:\n                    print(A[i][j] + 1, end=\" \")\n        print()\n        return \"YES\""
    },
    {
        "number": 933,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    if len(word) < 3:\n        return word\n\n    for i in range(len(word) - 2, -1, -1):\n        if word[i] == word[i + 1] == word[i + 2]:\n            word = word[:i] + word[i + 3:]\n            break\n\n    return word\n"
    },
    {
        "number": 934,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    table_card = stdin.split()[0]\n    hand_cards = stdin.split()[1:]\n\n    if table_card == '2H':\n        if len(hand_cards) >= 5:\n            return 'YES'\n        else:\n            return 'NO'\n    else:\n        return 'NO'"
    },
    {
        "number": 935,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    intersection_points = [1, 2, 3, 4]\n    for i in range(m):\n        for j in range(n):\n            if i in intersection_points and j in intersection_points:\n                intersection_points.remove(i)\n                intersection_points.remove(j)\n    if len(intersection_points) == 1:\n        return \"Malvika\"\n    else:\n        return \"Akshat\""
    },
    {
        "number": 936,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Sort the list of likes in descending order\n    a.sort(reverse=True)\n\n    # Initialize the winner as the first photo with a higher identifier\n    winner = a[0]\n\n    # Iterate through the list of photos and update the winner if a photo with a higher identifier gets a higher number of likes\n    for i in range(1, n):\n        if a[i] > winner:\n            winner = a[i]\n\n    return str(winner)"
    },
    {
        "number": 937,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    # Calculate the maximum number of theorems Mishka will be able to write down\n    max_theorems = 0\n    for i in range(1, n + 1):\n        if t[i] == 1:\n            max_theorems = max(max_theorems, len(a) - i + 1)\n\n    return str(max_theorems)\n"
    },
    {
        "number": 938,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    n = a\n    m = b\n    p = [0] * n\n    q = [0] * m\n    for i in range(n):\n        p[i] = i + 1\n    for i in range(m):\n        q[i] = i + 1\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            p[i] = max(p[i], p[j - 1])\n    for i in range(m):\n        for j in range(i + 1, m + 1):\n            q[i] = max(q[i], q[j - 1])\n    n_notes = n + m\n    max_notes = max(n_notes, a + b)\n    p_notes = [p[i] for i in range(n) if p[i] <= a]\n    q_notes = [q[i] for i in range(m) if q[i] <= b]\n    p_notes.sort()\n    q_notes.sort()\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len(q_notes)) if q_notes[i] <= b]\n    p_notes = [p_notes[i] for i in range(len(p_notes)) if p_notes[i] <= a]\n    q_notes = [q_notes[i] for i in range(len("
    },
    {
        "number": 939,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dances = []\n    for _ in range(m):\n        dance = list(map(int, stdin.split()))\n        dances.append(dance)\n\n    colors = [0] * n\n    for dance in dances:\n        for i in range(n):\n            if dance[i] == 1:\n                colors[i] = 1\n                break\n\n    for i in range(m):\n        for j in range(n):\n            if dances[i][j] == 1:\n                if colors[j] == 1:\n                    colors[j] = 2\n                elif colors[j] == 2:\n                    colors[j] = 3\n                else:\n                    colors[j] = 1\n\n    result = []\n    for i in range(n):\n        result.append(colors[i])\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 940,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    min_minutes = 0\n\n    for i in range(a):\n        for j in range(b):\n            for k in range(c):\n                if i + j + k == a + b + c:\n                    min_minutes += 1\n\n    return str(min_minutes)"
    },
    {
        "number": 941,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    n = 0\n    for i in range(k):\n        n += a[i] * (b ** (k - 1 - i))\n\n    if n % 2 == 0:\n        return \"even\"\n    else:\n        return \"odd\""
    },
    {
        "number": 942,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = []\n    for i in range(n):\n        b.append(a[i] - 1)\n    return \"Possible\" + \" \" + str(b)"
    },
    {
        "number": 943,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    integers = list(map(int, stdin.strip().split()))\n    even_sum = 0\n    for i in integers:\n        if i % 2 == 0:\n            even_sum += i\n    return str(even_sum)"
    },
    {
        "number": 944,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        roads.append((u - 1, v - 1))\n\n    def is_valid(u, v, roads):\n        for i in range(len(roads)):\n            if roads[i][0] == u and roads[i][1] == v:\n                return False\n        return True\n\n    def repair(u, v, roads):\n        if not is_valid(u, v, roads):\n            return 0\n\n        repair_count = 0\n        for i in range(len(roads)):\n            if roads[i][0] == u and roads[i][1] == v:\n                repair_count += 1\n                roads[i] = (roads[i][1], roads[i][0])\n\n        return repair_count\n\n    def min_days(u, v, roads):\n        repair_count = repair(u, v, roads)\n        return repair_count + 1\n\n    min_days_count = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            days = min_days(i, j, roads)\n            if days < min_days_count:\n                min_days_count = days\n\n    result = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            days = min_days(i, j, roads)\n            result.append(f\"{days} {i} {j} {repair(i, j, roads)}\")\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 945,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = list(map(int, stdin.strip().split()))\n\n    # Check if the line has self-intersections\n    if n == 1:\n        if x[0] == x[1]:\n            return \"no\"\n        else:\n            return \"yes\"\n\n    # Check if the line intersects itself\n    for i in range(1, n):\n        if x[i] == x[i - 1]:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 946,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    easy_count = 0\n    for i in range(n):\n        response = int(stdin.strip())\n        if response == 1:\n            easy_count += 1\n    if easy_count == n:\n        return \"EASY\"\n    else:\n        return \"HARD\""
    },
    {
        "number": 947,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = 1\n        b = 1\n        while a + b < n:\n            a += 1\n        while a + b > n:\n            b += 1\n        print(a, b)"
    },
    {
        "number": 948,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    image = []\n    for _ in range(n):\n        image.append(stdin.strip())\n\n    faces = 0\n    for i in range(m):\n        for j in range(m):\n            if image[i][j] == 'f':\n                faces += 1\n\n    return str(faces)"
    },
    {
        "number": 949,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a > b:\n        a, b = b, a\n\n    d = 1\n    while a % d == 0 and b % d == 0:\n        d *= 2\n\n    return str(d)"
    },
    {
        "number": 950,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    password = input().strip()\n    password_symbols = list(password)\n    password_symbols.sort()\n    password_symbols.reverse()\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password_symbols)\n    password_symbols = ''.join(password"
    },
    {
        "number": 951,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    min_digits = min(len(str(n)), len(str(k)))\n    return str(min_digits)"
    },
    {
        "number": 952,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v, c = map(int, stdin.split())\n        roads.append((u, v, c))\n\n    def dfs(u, visited, path, roads):\n        if u in visited:\n            return\n        visited.add(u)\n        path.append(u)\n        for v, c in roads:\n            if v == u:\n                continue\n            if not dfs(v, visited, path, roads):\n                return False\n        path.pop()\n        return True\n\n    def reverse_roads(u, visited, path, roads):\n        if u in visited:\n            return\n        visited.add(u)\n        path.append(u)\n        for v, c in roads:\n            if v == u:\n                continue\n            if not reverse_roads(v, visited, path, roads):\n                return False\n        path.pop()\n        return True\n\n    def min_traffic_controllers(visited, roads):\n        for u in visited:\n            if not reverse_roads(u, visited, [], roads):\n                return 0\n        return len(visited)\n\n    visited = set()\n    path = []\n    for u, v, c in roads:\n        if not dfs(u, visited, path, roads):\n            return 0\n\n    return min_traffic_controllers(visited, roads), path\n"
    },
    {
        "number": 953,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    A = list(map(list, stdin.readlines()))\n\n    def is_prettiest(p):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if A[i][j] == 1 and A[i][j]!= A[j][i]:\n                    return False\n        return True\n\n    def prettiest_permutation(p):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if A[i][j] == 1 and A[i][j]!= A[j][i]:\n                    return prettiest_permutation(p)\n        return p\n\n    if is_prettiest(p):\n        return prettiest_permutation(p)\n    else:\n        return \"No prettiest permutation found.\""
    },
    {
        "number": 954,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            s1 = s[:i] + s[i+1:]\n            s2 = s[:j] + s[j-1:]\n            if s1 == s2:\n                count += 1\n    return str(count)"
    },
    {
        "number": 955,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    prices = []\n    for _ in range(n):\n        price, s = map(int, stdin.readline().strip().split())\n        prices.append((price, s))\n\n    def is_valid(price, s):\n        return \"A\" in s or \"B\" in s or \"C\" in s\n\n    def get_min_price(prices):\n        min_price = float('inf')\n        for price, s in prices:\n            if is_valid(price, s):\n                min_price = min(min_price, price)\n        return min_price\n\n    min_price = get_min_price(prices)\n    if min_price == float('inf'):\n        return \"-1\"\n    return str(min_price)\n"
    },
    {
        "number": 957,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if s.count('heidi') == 0:\n        return 'NO'\n    else:\n        return 'YES'"
    },
    {
        "number": 958,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                return s[i]\n\n    return \"-1\""
    },
    {
        "number": 959,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, mod = map(int, stdin.split())\n    ones = [int(c) for c in stdin.split()]\n    special_matrices = []\n\n    for i in range(m):\n        row = ones[i * n:(i + 1) * n]\n        if sum(row) == 2:\n            special_matrices.append(row)\n\n    remainder = sum(special_matrices) % mod\n    return str(remainder)"
    },
    {
        "number": 960,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    x = 1\n    while True:\n        if x % k == 0:\n            x += 1\n        else:\n            break\n    return str(x)"
    },
    {
        "number": 961,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate XOR of all distinct codes of cities for people on the segment from position l to position r\n    xor_codes = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            xor_codes.add(a[i] ^ a[j])\n\n    # Calculate sum of comfort for each segment\n    comforts = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            comforts[i] += a[i] ^ a[j]\n\n    # Find maximal possible total comfort\n    max_comfort = 0\n    for comfort in comforts:\n        max_comfort = max(max_comfort, comfort)\n\n    return str(max_comfort)"
    },
    {
        "number": 962,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    G = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        G[a].append((b, 1))\n        G[b].append((a, 1))\n    for i in range(1, n + 1):\n        for j in range(i):\n            if G[i][j][1] == 1:\n                G[i].append((j, 1))\n                G[j].append((i, 1))\n    for i in range(1, n + 1):\n        if G[i][i][1] == 1:\n            return \"No induced subgraph of G that satisfies the condition\"\n    for i in range(1, n + 1):\n        for j in range(i):\n            if G[i][j][1] == 1:\n                for k in range(i):\n                    if G[i][k][1] == 1 and G[k][j][1] == 1:\n                        return \"Induced subgraph of G with K vertices whose vertex set is {v_1, v_2,..., v_K}\"\n    return \"No induced subgraph of G that satisfies the condition\""
    },
    {
        "number": 963,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    L = list(map(int, stdin.split()))\n    R = list(map(int, stdin.split()))\n\n    # Check if the segments intersect\n    for i in range(len(L)):\n        for j in range(i + 1, len(L)):\n            if L[i] == L[j] or R[i] == R[j]:\n                return \"No\"\n\n    # Initialize the memoization table\n    memo = [[0] * (N + 1) for _ in range(K + 1)]\n\n    def dfs(i, d):\n        if i == N:\n            return 1\n\n        if memo[i][d]!= 0:\n            return memo[i][d]\n\n        memo[i][d] = dfs(i + 1, d) + dfs(i + 1, d + 1)\n\n        return memo[i][d]\n\n    return str(dfs(1, 0))"
    },
    {
        "number": 964,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, x3, y3 = map(int, stdin.split())\n    if x1 == x2 or y1 == y2 or x1 == x3 or y1 == y3 or x2 == x3 or y2 == y3:\n        return \"-1\"\n\n    n = 3\n    for i in range(1, n):\n        if x1 == x2 + i or y1 == y2 + i or x1 == x3 + i or y1 == y3 + i or x2 == x3 + i or y2 == y3 + i:\n            return \"-1\"\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if i == j:\n                continue\n            if i == 1 and j == 1:\n                print(\"A\", end=\"\")\n            elif i == 2 and j == 1:\n                print(\"B\", end=\"\")\n            elif i == 1 and j == 2:\n                print(\"C\", end=\"\")\n            elif i == 2 and j == 2:\n                print(\"C\", end=\"\")\n            else:\n                print(\"A\", end=\"\")\n                print(\"B\", end=\"\")\n                print(\"C\", end=\"\")\n\n    return n * n"
    },
    {
        "number": 965,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cows = [0] * n\n    for i in range(n):\n        cows[i] = int(stdin.strip())\n    return str(sum(cows))"
    },
    {
        "number": 966,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y = int(stdin.strip())\n    min_year = min(y, 2013)\n    distinct_digits = True\n    for digit in str(min_year):\n        if int(digit)!= int(digit):\n            distinct_digits = False\n            break\n    if distinct_digits:\n        return str(min_year)\n    else:\n        return \"No such year exists.\""
    },
    {
        "number": 967,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Sort the threads based on the order of their positions in the new list\n    a.sort()\n\n    # Initialize the count of threads with new messages to 0\n    count = 0\n\n    # Iterate through the sorted list of threads\n    for i in range(1, n):\n        # Check if the thread with the current position is updated\n        if a[i]!= a[i - 1]:\n            # If it is, increment the count\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 968,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    handles = [\"\"] * n\n    for i in range(n):\n        handle = input(f\"Enter the handle of person {i+1}: \")\n        handles[i] = handle\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if handles[i] < handles[j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 969,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    n = int(stdin.strip())\n\n    if len(s)!= len(t):\n        return \"-1\"\n\n    if len(s) > 2100:\n        return \"-1\"\n\n    if len(s) == 0:\n        return \"0\"\n\n    if len(s) == 1:\n        return \"1\"\n\n    if len(s) == 2:\n        return \"2\"\n\n    if len(s) == 3:\n        return \"3\"\n\n    if len(s) == 4:\n        return \"4\"\n\n    if len(s) == 5:\n        return \"5\"\n\n    if len(s) == 6:\n        return \"6\"\n\n    if len(s) == 7:\n        return \"7\"\n\n    if len(s) == 8:\n        return \"8\"\n\n    if len(s) == 9:\n        return \"9\"\n\n    if len(s) == 10:\n        return \"10\"\n\n    if len(s) == 11:\n        return \"11\"\n\n    if len(s) == 12:\n        return \"12\"\n\n    if len(s) == 13:\n        return \"13\"\n\n    if len(s) == 14:\n        return \"14\"\n\n    if len(s) == 15:\n        return \"15\"\n\n    if len(s) == 16:\n        return \"16\"\n\n    if len(s) == 17:\n        return \"17\"\n\n    if len(s) == 18:\n        return \"18\"\n\n    if len(s) == 19:\n        return \"19\"\n\n    if len(s) == 20:\n        return \"20\"\n\n    if len(s) == 21:\n        return \"21\"\n\n    if len(s) == 22:\n        return \"22\"\n\n    if len(s) == 23:\n        return \"23\"\n\n    if len(s) == 24:\n        return \"24\"\n\n    if len(s) == 25:\n        return \"25\"\n\n    if len(s) == 26:\n        return \"26\"\n\n    if len(s) == 27:\n        return \"27\"\n\n    if len(s) == 28:\n        return \"28\"\n\n    if len(s) == 29:\n        return \"29\"\n\n    if len(s) == 30:\n        return \"30\"\n\n    if len(s) == 31:\n        return \"31\"\n\n    if len(s) == 32:\n        return \"32\"\n\n    if len(s) == 33:\n        return \"33\"\n\n    if len(s) == 34:\n        return \"34\"\n\n    if len(s) == 35:\n        return \"35\"\n\n    if len(s) == 36:\n        return \"36\"\n\n    if len(s) == 37:\n        return \"37\"\n\n    if len(s) == 38:\n        return \"38\"\n\n    if len(s) == 39:\n        return \"39\"\n\n    if len(s) == 40:\n        return \"40\"\n\n    if len(s) == 41:\n        return \"41\"\n\n    if len(s) == 42:\n        return \"42\"\n\n    if len(s) == 43:\n        return \"43\"\n\n    if len(s) == 44:\n        return \"44\"\n\n    if len(s) == 45:\n        return \"45\"\n\n    if len(s) == 46:\n        return \"46\"\n\n    if len(s) == 47:\n        return \"47\"\n\n    if len(s) == 48:\n        return \"48\"\n\n    if len(s) == 49:\n        return \"49\"\n\n    if len(s) == 50:\n        return \"50\"\n\n    if len(s) == 51:\n        return \"51\"\n\n    if len(s) == 52:\n        return \"52\"\n\n    if len(s) == 53:\n        return \"53\"\n\n    if len(s) == 54:\n        return \"54\"\n\n    if len(s) == 55:\n        return \"55\"\n\n    if len(s) == 56:\n        return \"56\"\n\n    if len(s) == 57:\n        return \"57\"\n\n   "
    },
    {
        "number": 970,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    # Check if the board is valid\n    if n % 2 == 0:\n        return \"Invalid board size\"\n\n    # Check if the positions are distinct\n    if len(set(p))!= n:\n        return \"Invalid positions\"\n\n    # Initialize the board\n    board = [[0] * n for _ in range(n)]\n\n    # Place the pieces\n    for i in range(n):\n        for j in range(n):\n            if p[i] == j:\n                board[i][j] = 1\n\n    # Count the number of moves\n    moves = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 0:\n                moves += 1\n                for k in range(n):\n                    if board[i][k] == 0:\n                        board[i][k] = 1\n                        board[k][i] = 1\n                        moves += 1\n                        break\n\n    return str(moves)"
    },
    {
        "number": 971,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, d = map(int, stdin.split())\n    juicer = []\n    waste = []\n    for i in range(n):\n        juicer.append(i + 1)\n    for i in range(n):\n        waste.append(juicer[i])\n    juicer.sort()\n    waste.sort()\n    for i in range(n):\n        if juicer[i] > b:\n            juicer.pop(i)\n            waste.pop(i)\n    return str(len(waste))"
    },
    {
        "number": 972,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    painted_grid = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if stdin[i][j] == 'B':\n                painted_grid[i][j] = 1\n\n    def dfs(x, y, visited):\n        if x < 0 or x >= n or y < 0 or y >= m or painted_grid[x][y] == 1 or visited[x][y]:\n            return False\n        visited[x][y] = True\n        if painted_grid[x][y] == 0:\n            return True\n        if dfs(x - 1, y, visited) or dfs(x + 1, y, visited) or dfs(x, y - 1, visited) or dfs(x, y + 1, visited):\n            return True\n        visited[x][y] = False\n        return False\n\n    for i in range(n):\n        for j in range(m):\n            if painted_grid[i][j] == 1 and dfs(i, j, [[False] * m for _ in range(n)]):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 973,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    pasture = [['.' for _ in range(C)] for _ in range(R)]\n\n    for _ in range(R):\n        line = stdin.readline().strip()\n        for i, cell in enumerate(line):\n            if cell == 'S':\n                pasture[i][i] = 'S'\n            elif cell == 'W':\n                pasture[i][i] = 'W'\n            elif cell == 'D':\n                pasture[i][i] = 'D'\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'S':\n                for k in range(i - 1, -1, -1):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n            elif pasture[i][j] == 'W':\n                for k in range(i + 1, R):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n            elif pasture[i][j] == 'D':\n                for k in range(j - 1, -1, -1):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n                for k in range(j + 1, C):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'D':\n                for k in range(i - 1, -1, -1):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n                for k in range(i + 1, R):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'D':\n                for k in range(j - 1, -1, -1):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n                for k in range(j + 1, C):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'D':\n                for k in range(i - 1, -1, -1):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n                for k in range(i + 1, R):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'D':\n                for k in range(j - 1, -1, -1):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n                for k in range(j + 1, C):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'D':\n                for k in range(i - 1, -1, -1):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n                for k in range(i + 1, R):\n                    if pasture[k][j] == 'W':\n                        pasture[k][j] = 'D'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if pasture[i][j] == 'D':\n                for k in range(j - 1, -1, -1):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n                for k in range(j + 1, C):\n                    if pasture[i][k] == 'W':\n                        pasture[i][k] = 'D'\n                        break\n\n    for i in range("
    },
    {
        "number": 974,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    stack = []\n    for _ in range(n):\n        command = stdin.split()[1]\n        if command == \"add\":\n            stack.append(int(stdin.split()[2]))\n        elif command == \"remove\":\n            if len(stack) == 0:\n                return \"No boxes to remove.\"\n            stack.pop()\n    return str(len(stack))"
    },
    {
        "number": 975,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sherlock_card = list(map(int, stdin.readline().strip()))\n    moriarty_card = list(map(int, stdin.readline().strip()))\n\n    sherlock_flicks = 0\n    moriarty_flicks = 0\n\n    for i in range(n):\n        if sherlock_card[i] == moriarty_card[i]:\n            sherlock_flicks += 1\n        else:\n            moriarty_flicks += 1\n\n    return str(min(sherlock_flicks, moriarty_flicks)) + \" \" + str(max(sherlock_flicks, moriarty_flicks))"
    },
    {
        "number": 976,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    best_moments = []\n    for i in range(n):\n        l, r = map(int, input().split())\n        best_moments.append((l, r))\n    best_moments.sort(key=lambda x: x[0])\n    current_time = 0\n    for l, r in best_moments:\n        if current_time + x <= r:\n            current_time += x\n        else:\n            current_time = r\n    return str(current_time)"
    },
    {
        "number": 977,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(x):\n        return x if x <= 2 else 0\n\n    good_x = [x for x in range(1, n + 1) if f(x) % p == 0]\n    return str(len(good_x)) + '\\n' + '\\n'.join(map(str, good_x))\n"
    },
    {
        "number": 978,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    panels = list(map(int, stdin.strip().split()))\n\n    for i in range(k):\n        for j in range(i + 1, k + 1):\n            if panels[i] == panels[j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 979,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    result = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            result = (result * (a[i] - a[j])) % m\n\n    return str(result)"
    },
    {
        "number": 980,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    s = list(stdin.strip())\n    s.sort()\n    result = []\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            for l in range(j + 1, k):\n                for m in range(l + 1, k):\n                    for n in range(m + 1, k):\n                        if s[i] == s[j] and s[j] == s[l] and s[l] == s[m] and s[m] == s[n]:\n                            result.append(s[i])\n                            break\n\n    if not result:\n        return -1\n    else:\n        return result[0]"
    },
    {
        "number": 981,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    v, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_num = 0\n    for i in range(n):\n        num = a[i]\n        if num == 0:\n            continue\n        for d in range(1, 10):\n            if num % d == 0:\n                max_num = max(max_num, num // d)\n                break\n        else:\n            max_num = max(max_num, num)\n\n    if max_num == 0:\n        return -1\n    return str(max_num)\n"
    },
    {
        "number": 982,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        l, r = map(int, stdin.readline().split())\n        a = 5\n        if l % a == 0:\n            x = l // a\n            if x % 2 == 0:\n                a = x // 2\n            else:\n                a = x // 2 + 1\n        else:\n            a = 5\n        if r % a == 0:\n            x = r // a\n            if x % 2 == 0:\n                a = x // 2\n            else:\n                a = x // 2 + 1\n        else:\n            a = 5\n        if a > 100:\n            a = 100\n        if a > r:\n            a = r\n        if a > l:\n            a = l\n        print(\"YES\" if a > l else \"NO\")"
    },
    {
        "number": 983,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_value = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                value = p * a[i] + q * a[j] + r * a[k]\n                if value > max_value:\n                    max_value = value\n\n    return str(max_value)"
    },
    {
        "number": 984,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    tree = []\n    for _ in range(n):\n        v, l, r = map(int, stdin.readline().strip().split())\n        tree.append((v, l, r))\n\n    def find(t, x):\n        if t is None:\n            return False\n        if t.value == x:\n            return True\n        if x < t.value:\n            return find(t.left, x)\n        else:\n            return find(t.right, x)\n\n    count = 0\n    for v in tree:\n        if not find(tree[0], v[0]):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 985,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            pairs += 1\n    return str(pairs)"
    },
    {
        "number": 986,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize the library with no books\n    library = [0] * n\n\n    # Initialize the bookstore with no books\n    bookstore = [0] * n\n\n    # Initialize the bookstore with the book 1\n    bookstore[0] = a[0]\n\n    # Initialize the bookstore with the book 2\n    bookstore[1] = a[1]\n\n    # Initialize the bookstore with the book 3\n    bookstore[2] = a[2]\n\n    # Initialize the bookstore with the book 4\n    bookstore[3] = a[3]\n\n    # Initialize the bookstore with the book 5\n    bookstore[4] = a[4]\n\n    # Initialize the bookstore with the book 6\n    bookstore[5] = a[5]\n\n    # Initialize the bookstore with the book 7\n    bookstore[6] = a[6]\n\n    # Initialize the bookstore with the book 8\n    bookstore[7] = a[7]\n\n    # Initialize the bookstore with the book 9\n    bookstore[8] = a[8]\n\n    # Initialize the bookstore with the book 10\n    bookstore[9] = a[9]\n\n    # Initialize the bookstore with the book 11\n    bookstore[10] = a[10]\n\n    # Initialize the bookstore with the book 12\n    bookstore[11] = a[11]\n\n    # Initialize the bookstore with the book 13\n    bookstore[12] = a[12]\n\n    # Initialize the bookstore with the book 14\n    bookstore[13] = a[13]\n\n    # Initialize the bookstore with the book 15\n    bookstore[14] = a[14]\n\n    # Initialize the bookstore with the book 16\n    bookstore[15] = a[15]\n\n    # Initialize the bookstore with the book 17\n    bookstore[16] = a[16]\n\n    # Initialize the bookstore with the book 18\n    bookstore[17] = a[17]\n\n    # Initialize the bookstore with the book 19\n    bookstore[18] = a[18]\n\n    # Initialize the bookstore with the book 20\n    bookstore[19] = a[19]\n\n    # Initialize the bookstore with the book 21\n    bookstore[20] = a[20]\n\n    # Initialize the bookstore with the book 22\n    bookstore[21] = a[21]\n\n    # Initialize the bookstore with the book 23\n    bookstore[22] = a[22]\n\n    # Initialize the bookstore with the book 24\n    bookstore[23] = a[23]\n\n    # Initialize the bookstore with the book 25\n    bookstore[24] = a[24]\n\n    # Initialize the bookstore with the book 26\n    bookstore[25] = a[25]\n\n    # Initialize the bookstore with the book 27\n    bookstore[26] = a[26]\n\n    # Initialize the bookstore with the book 28\n    bookstore[27] = a[27]\n\n    # Initialize the bookstore with the book 29\n    bookstore[28] = a[28]\n\n    # Initialize the bookstore with the book 30\n    bookstore[29] = a[29]\n\n    # Initialize the bookstore with the book 31\n    bookstore[30] = a[30]\n\n    # Initialize the bookstore with the book 32\n    bookstore[31] = a[31]\n\n    # Initialize the bookstore with the book 33\n    bookstore[32] = a[32]\n\n    # Initialize the bookstore with the book 34\n    bookstore[33] = a[33]\n\n    # Initialize the bookstore with the book 35\n    bookstore[34] = a[34]\n\n    # Initialize the bookstore with the book 36\n    bookstore[35] = a[35]\n\n    # Initialize the bookstore with the book 37\n    bookstore[36] = a[36]\n\n    # Initialize the bookstore with the book 38\n    bookstore[37] = a[37]\n\n    # Initialize the bookstore with the book 39\n    bookstore[38] = a[38]\n\n    # Initialize the bookstore with the book 40\n    bookstore[39"
    },
    {
        "number": 987,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_valid(p, a, b):\n        for i in range(n):\n            if p[i] == a[i] or p[i] == b[i]:\n                return False\n        return True\n\n    def lexicographically_maximal_permutation(p):\n        max_p = p.copy()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] < p[j]:\n                    max_p[i], max_p[j] = max_p[j], max_p[i]\n        return max_p\n\n    max_p = lexicographically_maximal_permutation(p)\n    p_max = [p[i] for i in max_p]\n    p_max.sort()\n    return''.join(map(str, p_max))\n"
    },
    {
        "number": 988,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    rows = []\n    for line in stdin.split('\\n'):\n        rows.append(line)\n\n    # Initialize the result\n    result = []\n\n    # Iterate over the rows\n    for row in rows:\n        # Initialize the current row\n        current_row = []\n\n        # Iterate over the characters in the row\n        for char in row:\n            # If the character is a '.', add it to the current row\n            if char == '.':\n                current_row.append('.')\n            # If the character is a 'P', add it to the result\n            elif char == 'P':\n                result.append('P')\n            # If the character is a '-', add it to the current row\n            else:\n                current_row.append('-')\n\n        # Add the current row to the result\n        result.append(''.join(current_row))\n\n    # Return the result\n    return '\\n'.join(result)\n"
    },
    {
        "number": 989,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_diff = float('-inf')\n    min_diff = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            max_diff = max(max_diff, a[i] - a[i + 1])\n        else:\n            min_diff = min(min_diff, a[i] - a[i - 1])\n\n    if k == 1:\n        return str(min_diff)\n    else:\n        return str(max_diff)\n"
    },
    {
        "number": 990,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    edges = []\n    for _ in range(N - 1):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(u, visited, path):\n        if u == N:\n            return True\n\n        if visited[u]:\n            return False\n\n        visited[u] = True\n        for v, w in edges[u]:\n            if w == 1:\n                if dfs(v, visited, path + [u]):\n                    return True\n            elif w == 2:\n                if dfs(v, visited, path + [u]):\n                    return True\n            elif w == 3:\n                if dfs(v, visited, path + [u]):\n                    return True\n\n        visited[u] = False\n        return False\n\n    visited = [False] * N\n    for u in range(N):\n        if dfs(u, visited, []):\n            return str(u + 1)\n\n    return \"0\""
    },
    {
        "number": 991,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, S = map(int, stdin.split())\n    U = list(map(int, stdin.split()))\n    V = list(map(int, stdin.split()))\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    C = list(map(int, stdin.split()))\n    D = list(map(int, stdin.split()))\n\n    # Create a dictionary to store the number of gold coins in each city\n    gold_coins = {}\n    for i in range(N):\n        gold_coins[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each city\n    silver_coins = {}\n    for i in range(N):\n        silver_coins[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each exchange counter\n    gold_coins_in_exchange_counter = {}\n    for i in range(N):\n        gold_coins_in_exchange_counter[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each exchange counter\n    silver_coins_in_exchange_counter = {}\n    for i in range(N):\n        silver_coins_in_exchange_counter[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each city\n    gold_coins_in_city = {}\n    for i in range(N):\n        gold_coins_in_city[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each city\n    silver_coins_in_city = {}\n    for i in range(N):\n        silver_coins_in_city[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each exchange counter\n    gold_coins_in_exchange_counter_in_city = {}\n    for i in range(N):\n        gold_coins_in_exchange_counter_in_city[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each exchange counter\n    silver_coins_in_exchange_counter_in_city = {}\n    for i in range(N):\n        silver_coins_in_exchange_counter_in_city[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each city\n    gold_coins_in_city_in_exchange_counter = {}\n    for i in range(N):\n        gold_coins_in_city_in_exchange_counter[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each city\n    silver_coins_in_city_in_exchange_counter = {}\n    for i in range(N):\n        silver_coins_in_city_in_exchange_counter[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each exchange counter\n    gold_coins_in_exchange_counter_in_city_in_city = {}\n    for i in range(N):\n        gold_coins_in_exchange_counter_in_city_in_city[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each exchange counter\n    silver_coins_in_exchange_counter_in_city_in_city = {}\n    for i in range(N):\n        silver_coins_in_exchange_counter_in_city_in_city[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each city\n    gold_coins_in_city_in_exchange_counter_in_city_in_city = {}\n    for i in range(N):\n        gold_coins_in_city_in_exchange_counter_in_city_in_city[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each city\n    silver_coins_in_city_in_exchange_counter_in_city_in_city = {}\n    for i in range(N):\n        silver_coins_in_city_in_exchange_counter_in_city_in_city[i] = 0\n\n    # Create a dictionary to store the number of gold coins in each exchange counter\n    gold_coins_in_exchange_counter_in_city_in_city_in_city = {}\n    for i in range(N):\n        gold_coins_in_exchange_counter_in_city_in_city_in_city[i] = 0\n\n    # Create a dictionary to store the number of silver coins in each exchange counter\n    silver_coins_in_exchange_counter_in_city_in_city_in_city = {}\n    for i in range(N):\n        silver_coins_in_"
    },
    {
        "number": 992,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def f(T):\n        count = 0\n        for i in range(1, N + 1):\n            if sum(A[:i]) == S:\n                count += 1\n        return count\n\n    result = sum(f(T) for T in range(1 << N - 1)) % 998244353\n    return str(result)"
    },
    {
        "number": 993,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    pairs = []\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if A[i] + A[j] % M == 0:\n                pairs.append((i, j))\n\n    return str(len(pairs))"
    },
    {
        "number": 994,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    heights = [0] * n\n    for _ in range(m):\n        day, height = map(int, stdin.split())\n        heights[day - 1] = height\n\n    max_height = 0\n    for i in range(1, n):\n        if heights[i] - heights[i - 1] <= 1:\n            max_height = max(max_height, heights[i])\n\n    if max_height == 0:\n        return \"IMPOSSIBLE\"\n    else:\n        return str(max_height)"
    },
    {
        "number": 995,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    result = []\n    for k in range(1, n + 1):\n        count = 0\n        for i in range(n):\n            if i % k == 0:\n                count += 1\n                if count == k:\n                    result.append(k)\n                    break\n        else:\n            result.append(0)\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 996,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    state = [[0] * k for _ in range(n)]\n    critical_count = 0\n\n    for i in range(n):\n        for j in range(m):\n            for k in range(k):\n                if state[i][j] == 1:\n                    if i > 0 and state[i - 1][j] == 1:\n                        critical_count += 1\n                    if j > 0 and state[i][j - 1] == 1:\n                        critical_count += 1\n                    if k > 0 and state[i][j][k - 1] == 1:\n                        critical_count += 1\n\n    return str(critical_count)\n"
    },
    {
        "number": 997,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    words = s.split(';')\n    a = \"\"\n    b = \"\"\n    for word in words:\n        if word.isdigit():\n            a += word + \",\"\n        else:\n            b += word + \",\"\n    a = a[:-1]\n    b = b[:-1]\n    if not a.isdigit() and not b.isdigit():\n        print(\"-\")\n    else:\n        print(a)\n        print(b)\n    return a + \",\" + b"
    },
    {
        "number": 998,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    l = 0\n    for i in range(n):\n        if a[i] == 1:\n            l += 1\n            if l > 1:\n                break\n    if l > 1:\n        a = a[:l]\n    else:\n        return \"0\"\n    xor = 0\n    for i in range(n):\n        xor ^= a[i]\n    if xor == x:\n        return str(l) + \" \" + \" \".join(map(str, a))\n    else:\n        return \"0\""
    },
    {
        "number": 999,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    l1, r1 = map(int, stdin.split())\n    l2, r2 = map(int, stdin.split())\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(l1[i] - l2[j]) + abs(r1[i] - r2[j])\n            if distance > max_distance:\n                max_distance = distance\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            distance = abs(l1[i] - l2[j]) + abs(r1[i] - r2[j])\n            if distance > max_distance:\n                max_distance = distance\n\n    return str(max_distance)"
    },
    {
        "number": 1000,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    fuel_prices = [1] * n\n    for i in range(1, n):\n        fuel_prices[i] = fuel_prices[i-1] + i\n    min_fuel = fuel_prices[0]\n    for i in range(1, n):\n        min_fuel = min(min_fuel, fuel_prices[i])\n    return str(min_fuel)"
    },
    {
        "number": 1001,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    stickers = list(map(int, stdin.strip().split()))\n    score = 0\n    for i in range(n):\n        score += stickers[i]\n    return str(score - stickers[0])"
    },
    {
        "number": 1002,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    if n > d:\n        return \"-1\"\n\n    max_jokes = 0\n    jokes_cracked = 0\n\n    for i in range(n):\n        if i == 0:\n            jokes_cracked += t[i] // 5\n        else:\n            jokes_cracked += t[i] // 10\n\n    if jokes_cracked > max_jokes:\n        max_jokes = jokes_cracked\n\n    return str(max_jokes)"
    },
    {
        "number": 1003,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    days = [0] * (n + m)\n    for i in range(1, n + m):\n        days[i] = i\n    for i in range(1, n + m):\n        days[i] += i - 1\n    for i in range(1, n + m):\n        days[i] += i - 2\n    for i in range(1, n + m):\n        days[i] += i - 3\n    for i in range(1, n + m):\n        days[i] += i - 4\n    for i in range(1, n + m):\n        days[i] += i - 5\n    for i in range(1, n + m):\n        days[i] += i - 6\n    for i in range(1, n + m):\n        days[i] += i - 7\n    for i in range(1, n + m):\n        days[i] += i - 8\n    for i in range(1, n + m):\n        days[i] += i - 9\n    for i in range(1, n + m):\n        days[i] += i - 10\n    for i in range(1, n + m):\n        days[i] += i - 11\n    for i in range(1, n + m):\n        days[i] += i - 12\n    for i in range(1, n + m):\n        days[i] += i - 13\n    for i in range(1, n + m):\n        days[i] += i - 14\n    for i in range(1, n + m):\n        days[i] += i - 15\n    for i in range(1, n + m):\n        days[i] += i - 16\n    for i in range(1, n + m):\n        days[i] += i - 17\n    for i in range(1, n + m):\n        days[i] += i - 18\n    for i in range(1, n + m):\n        days[i] += i - 19\n    for i in range(1, n + m):\n        days[i] += i - 20\n    for i in range(1, n + m):\n        days[i] += i - 21\n    for i in range(1, n + m):\n        days[i] += i - 22\n    for i in range(1, n + m):\n        days[i] += i - 23\n    for i in range(1, n + m):\n        days[i] += i - 24\n    for i in range(1, n + m):\n        days[i] += i - 25\n    for i in range(1, n + m):\n        days[i] += i - 26\n    for i in range(1, n + m):\n        days[i] += i - 27\n    for i in range(1, n + m):\n        days[i] += i - 28\n    for i in range(1, n + m):\n        days[i] += i - 29\n    for i in range(1, n + m):\n        days[i] += i - 30\n    for i in range(1, n + m):\n        days[i] += i - 31\n    for i in range(1, n + m):\n        days[i] += i - 32\n    for i in range(1, n + m):\n        days[i] += i - 33\n    for i in range(1, n + m):\n        days[i] += i - 34\n    for i in range(1, n + m):\n        days[i] += i - 35\n    for i in range(1, n + m):\n        days[i] += i - 36\n    for i in range(1, n + m):\n        days[i] += i - 37\n    for i in range(1, n + m):\n        days[i] += i - 38\n    for i in range(1, n + m):\n        days[i] += i - 39\n    for i in range(1, n + m):\n        days[i] += i - 40\n    for i in range(1, n + m):\n        days[i] += i - 41\n    for i in range(1, n + m):\n        days[i] += i - 42\n    for i in range(1, n + m):\n        days[i] += i - 43"
    },
    {
        "number": 1004,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Check if the array is valid\n    if not all(a[i] == a[i + 1] for i in range(n - 1)):\n        return \"-1\"\n\n    # Partition the array\n    d = 1\n    c = [0] * n\n    for i in range(n - 1):\n        if a[i] == a[i + 1]:\n            d += 1\n            c[i] += 1\n        else:\n            break\n\n    # Check if there is a valid partition\n    if d == n:\n        return str(d) + \" \" + \" \".join(map(str, c))\n    else:\n        return \"-1\""
    },
    {
        "number": 1005,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    subscriptions = [0] * k\n    for i in range(1, n):\n        subscriptions[a[i-1]] += 1\n    min_subscriptions = 0\n    for i in range(1, k):\n        if subscriptions[i] >= d:\n            min_subscriptions += 1\n    return str(min_subscriptions)"
    },
    {
        "number": 1006,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    board = []\n    for _ in range(n):\n        board.append(stdin.readline())\n\n    crosses = []\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == '#':\n                crosses.append((i, j))\n\n    if len(crosses) < 5:\n        return \"NO\"\n\n    for i in range(len(crosses)):\n        for j in range(i + 1, len(crosses)):\n            if crosses[i][0] == crosses[j][0] and crosses[i][1] == crosses[j][1]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1007,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p = map(int, stdin.split())\n    zcy_numbers = [11, 22, 33, 44, 55]\n    zcy_numbers.sort(reverse=True)\n    result = sum(zcy_numbers[:k]) % p\n    return str(result)"
    },
    {
        "number": 1008,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    k = int(stdin.strip())\n\n    if len(s) % 2!= 0:\n        return \"NO\"\n\n    for i in range(len(s) - 1):\n        if s[i]!= s[i + 1]:\n            return \"NO\"\n\n    for i in range(k - 1):\n        if s[i]!= s[-i - 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1009,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n\n    # Sort the cowbells by size\n    s.sort()\n\n    # Initialize the smallest s\n    smallest_s = s[0]\n\n    # Iterate through the sizes\n    for i in range(1, n):\n        # Check if the current size can fit the cowbells\n        if s[i] - 1 <= s[i - 1]:\n            # If it can, update the smallest s\n            smallest_s = min(smallest_s, s[i])\n        else:\n            # If it cannot, break out of the loop\n            break\n\n    return str(smallest_s)\n"
    },
    {
        "number": 1010,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(start, used, result):\n        if len(used) == n:\n            result += 1\n            return\n        if start == n:\n            return\n        if start < 0 or start >= n:\n            return\n        if used[start]:\n            return\n        used[start] = True\n        dfs(start + 1, used, result)\n        dfs(start - 1, used, result)\n        dfs(start + 1, used, result)\n        dfs(start - 1, used, result)\n\n    return str(dfs(0, [False] * n, 0))"
    },
    {
        "number": 1011,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    throws = []\n    for _ in range(n):\n        throws.append(int(stdin.readline()))\n    throws.sort()\n    throws.reverse()\n\n    max_score = 0\n    max_a = throws[0]\n    max_b = throws[1]\n\n    for i in range(1, n):\n        if throws[i] - throws[i - 1] > max_score:\n            max_score = throws[i] - throws[i - 1]\n            max_a = throws[i - 1]\n            max_b = throws[i]\n\n    return f\"{max_a}:{max_b}\""
    },
    {
        "number": 1012,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        s = stdin.readline().strip()\n        if s == s[::-1]:\n            print(-1)\n        else:\n            print(\"abaacba\")"
    },
    {
        "number": 1013,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        table.append(row)\n\n    operations = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 0:\n                continue\n\n            x1, y1 = i, j\n            x2, y2 = i, j\n\n            while True:\n                x1, y1 = x1 - 1, y1 - 1\n                x2, y2 = x2 + 1, y2 + 1\n\n                if 0 <= x1 < n and 0 <= y1 < m and table[x1][y1] == 0:\n                    x1, y1 = x1, y1\n                    continue\n                if 0 <= x2 < n and 0 <= y2 < m and table[x2][y2] == 0:\n                    x2, y2 = x2, y2\n                    continue\n                if x1 == x2 and y1 == y2:\n                    break\n\n            if x1 == i and y1 == j:\n                operations += 1\n                table[i][j] = 1\n            elif x2 == i and y2 == j:\n                operations += 1\n                table[i][j] = 1\n\n    return str(operations)"
    },
    {
        "number": 1014,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = [[0] * n for _ in range(n)]\n    white_queen = (1, 1)\n    black_queen = (1, n)\n    white_pawn = (2, 1)\n    black_pawn = (2, 3)\n    white_pawn_count = 0\n    black_pawn_count = 0\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 0:\n                board[i][j] = 1\n                if i == white_queen[0]:\n                    white_queen = (i, j)\n                elif i == black_queen[0]:\n                    black_queen = (i, j)\n                elif i == white_pawn[0]:\n                    white_pawn_count += 1\n                elif i == black_pawn[0]:\n                    black_pawn_count += 1\n    if white_pawn_count > black_pawn_count:\n        return \"white\"\n    elif white_pawn_count < black_pawn_count:\n        return \"black\"\n    else:\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 1:\n                    if i == white_queen[0]:\n                        return \"white\"\n                    elif i == black_queen[0]:\n                        return \"black\"\n                    elif i == white_pawn[0]:\n                        return \"white\"\n                    elif i == black_pawn[0]:\n                        return \"black\"\n        return \"tie\""
    },
    {
        "number": 1015,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    protection = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == 1 and a[j] == 1:\n                if protection < 3:\n                    protection += 1\n                else:\n                    break\n\n    return str(protection)"
    },
    {
        "number": 1016,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    chemicals = list(range(1, n + 1))\n    chemicals.extend(chemicals)\n    chemicals.sort()\n\n    danger = 1\n    for i in range(m):\n        x, y = map(int, stdin.split())\n        if x <= y <= n:\n            danger *= 2\n\n    return str(danger)"
    },
    {
        "number": 1017,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str(n) + \"+\""
    },
    {
        "number": 1018,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    pen_count = [0] * n\n    pen_count[0] = a[0]\n\n    for i in range(1, n):\n        pen_count[i] = pen_count[i - 1] + a[i]\n\n    for i in range(n, 0, -1):\n        if pen_count[i - 1] == 0:\n            return str(i - 1)\n\n    return \"No ink left in any pen\""
    },
    {
        "number": 1019,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a, b = 1, 2\n    while b <= n:\n        if n % b == 0:\n            a, b = b, n // b\n        else:\n            b += 1\n    return str(a) + \" \" + str(b)"
    },
    {
        "number": 1020,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, k = map(int, stdin.split())\n    n = w * h\n    m = min(n, w)\n    k = min(k, int(min(n, m) / 4))\n\n    gilded_rings = []\n    for i in range(k):\n        gilded_rings.append([])\n        for j in range(m):\n            gilded_rings[i].append(j)\n\n    for i in range(k):\n        for j in range(m):\n            if i == 0 or i == k - 1 or j == 0 or j == m - 1:\n                continue\n\n            if i == 0 and j == 0:\n                gilded_rings[i][j] += 1\n            elif i == 0 and j == m - 1:\n                gilded_rings[i][j] -= 1\n            elif i == k - 1 and j == 0:\n                gilded_rings[i][j] -= 1\n            elif i == k - 1 and j == m - 1:\n                gilded_rings[i][j] += 1\n            else:\n                gilded_rings[i][j] += 1 - gilded_rings[i - 1][j] - gilded_rings[i + 1][j] - gilded_rings[i][j - 1] - gilded_rings[i][j + 1]\n\n    return str(sum(gilded_rings))"
    },
    {
        "number": 1021,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n    t = list(map(int, stdin.readline().strip().split()))\n\n    # Perform synchronization operations\n    for i in range(n - 1):\n        if c[i] + c[i + 1] - c[i] == t[i]:\n            c[i] = t[i]\n\n    # Check if there exists a sequence of synchronization operations\n    for i in range(n - 1):\n        if c[i] + c[i + 1] - c[i]!= t[i]:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 1022,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    l = list(map(int, stdin.readline().strip().split()))\n    r = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        if l[i] > r[i]:\n            return \"NO\"\n\n    for i in range(n):\n        if l[i] == r[i]:\n            return \"YES\"\n\n    return \"YES\""
    },
    {
        "number": 1023,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t_a, t_b, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Sort the flights\n    a.sort()\n    b.sort()\n\n    # Initialize the variables\n    min_time = float('inf')\n    min_index = -1\n\n    # Iterate through the flights\n    for i in range(n):\n        for j in range(m):\n            # Check if the flight can be canceled\n            if b[j] >= a[i] + t_a:\n                # Check if the flight is the optimal solution\n                if j == 0 or b[j] < b[j - 1]:\n                    # Update the minimum time and index\n                    min_time = min(min_time, b[j] - a[i] + t_a)\n                    min_index = j\n\n    # If there is no optimal solution, return -1\n    if min_index == -1:\n        return '-1'\n\n    # If there is an optimal solution, return the minimum time\n    return str(min_time)\n"
    },
    {
        "number": 1024,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    elements = list(map(int, stdin.strip().split()))\n\n    # Apply permutation\n    p = [0] * n\n    for i in range(n):\n        p[i] = i\n\n    for i in range(n - 1):\n        j = random.randint(i + 1, n - 1)\n        p[i], p[j] = p[j], p[i]\n\n    # Inversion count\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if elements[i] > elements[j]:\n                count += 1\n\n    # Calculate expected number of inversions\n    expected_count = n * (n - 1) // 2\n    return str(expected_count)"
    },
    {
        "number": 1025,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    triangles = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            area = (points[i][0] - points[j][0]) * (points[j][1] + points[i][1]) - (points[j][0] - points[i][0]) * (points[i][1] + points[j][1])\n            if area > 0:\n                triangles.append((points[i], points[j], points[j + 1]))\n\n    count = 0\n    for triangle in triangles:\n        area = (triangle[1][0] - triangle[0][0]) * (triangle[1][1] + triangle[0][1]) - (triangle[1][0] - triangle[0][0]) * (triangle[0][1] + triangle[1][1])\n        if area > 0:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1026,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    b = list(map(int, stdin.strip().split()))\n\n    # Initialize the beauty values of the cities\n    beauty_values = [0] * n\n\n    # Initialize the visited cities\n    visited_cities = [0] * n\n\n    # Initialize the optimal beauty value\n    optimal_beauty = 0\n\n    # Iterate through the cities\n    for i in range(n):\n        # If the beauty value of the current city is greater than the beauty value of the previous city,\n        # then update the beauty value of the current city\n        if b[i] > beauty_values[visited_cities[i]]:\n            beauty_values[visited_cities[i]] = b[i]\n\n        # If the beauty value of the current city is equal to the beauty value of the previous city,\n        # then update the beauty value of the current city\n        elif b[i] == beauty_values[visited_cities[i]]:\n            beauty_values[visited_cities[i]] = b[i] + beauty_values[visited_cities[i - 1]]\n\n        # If the beauty value of the current city is less than the beauty value of the previous city,\n        # then update the beauty value of the current city\n        else:\n            beauty_values[visited_cities[i]] = b[i] + beauty_values[visited_cities[i - 1]]\n\n        # If the beauty value of the current city is the last city in the sequence,\n        # then update the optimal beauty value\n        if i == n - 1:\n            optimal_beauty = beauty_values[i]\n\n    return str(optimal_beauty)\n"
    },
    {
        "number": 1027,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    n = len(a)\n    max_score = 0\n    for i in range(n):\n        if a[i] == 0:\n            max_score += 1\n        else:\n            max_score += 2 * a[i]\n    return str(max_score)"
    },
    {
        "number": 1028,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    k_min = 1000000000\n    k_max = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            k = i + j\n            if k < k_min:\n                k_min = k\n            if k > k_max:\n                k_max = k\n\n    return str(k_min) + \" \" + str(k_max)\n"
    },
    {
        "number": 1029,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.strip())\n    b = [int(x) for x in str(p)]\n    max_elements = 0\n    for i in range(len(b)):\n        for j in range(i + 1, len(b)):\n            if b[i] >= b[j]:\n                v = b[i] + b[j]\n                b[i], b[j] = b[j], b[i]\n                b.insert(i + 1, v)\n                max_elements += 2\n                i += 1\n                j -= 1\n    return str(max_elements)"
    },
    {
        "number": 1030,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    if p < 1 or p > n or k < 1 or k > n:\n        return \"Invalid input\"\n\n    if p == 1 and k == 1:\n        return \"<< 1 2 (3) 4 5 >>\"\n\n    if p == n and k == 1:\n        return \"<< 1 2 (3) 4 5 >>\"\n\n    if p == 1 and k == n:\n        return \"<< 1 2 (3) 4 5 >>\"\n\n    if p == n and k == n:\n        return \"<< 1 2 (3) 4 5 >>\"\n\n    if p < 1 or p > n or k < 1 or k > n:\n        return \"Invalid input\"\n\n    result = []\n    for i in range(p, p + k):\n        if i == 1:\n            result.append(\"<<\")\n        elif i == n:\n            result.append(\">>\")\n        else:\n            result.append(str(i))\n\n    return \" \".join(result)"
    },
    {
        "number": 1031,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    max_y = 0\n    for i in range(n):\n        max_y = max(max_y, a[i])\n    for i in range(n):\n        print(a[i] * (max_y - a[i]))\n    return \"\""
    },
    {
        "number": 1032,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(x):\n        if x <= 2:\n            return 0\n        if x == 3:\n            return 1\n        if x == 4:\n            return 4\n        if x >= 5:\n            return 6\n        return 0\n\n    good_numbers = []\n    for x in range(1, n + 1):\n        if f(x) % p == 0:\n            good_numbers.append(x)\n\n    return str(len(good_numbers)) + '\\n' + '\\n'.join(map(str, good_numbers))\n"
    },
    {
        "number": 1033,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, H = map(int, stdin.split())\n    if n < 1 or H < 1 or H > 10**18:\n        return \"Invalid input\"\n\n    # Calculate the number of spots required\n    num_spots = 1\n    for i in range(1, n + 1):\n        num_spots += i * (H - i + 1)\n\n    return str(num_spots)\n"
    },
    {
        "number": 1034,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, Z, K = map(int, stdin.split())\n    ways = []\n    for i in range(1, X + 1):\n        for j in range(1, Y + 1):\n            for k in range(1, Z + 1):\n                ways.append(i * j * k)\n    ways.sort(reverse=True)\n    for i in range(K):\n        ways.pop()\n    return''.join(map(str, ways))"
    },
    {
        "number": 1035,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    divisors = []\n    for i in range(1, A + 1):\n        if A % i == 0 and B % i == 0:\n            divisors.append(i)\n    max_divisor = max(divisors)\n    return str(max_divisor)"
    },
    {
        "number": 1036,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n    players = [s[i:i+2] for i in range(0, len(s), 2)]\n    players.sort()\n    winner = players[0]\n    for i in range(1, 2**k):\n        if i in players:\n            continue\n        opponent = players[i % len(players)]\n        if opponent == winner:\n            continue\n        if (i - players[0]) % 2 == 0:\n            if opponent == players[i // 2]:\n                winner = opponent\n            else:\n                winner = players[i // 2]\n        else:\n            if opponent == players[i // 2]:\n                winner = players[i // 2]\n            else:\n                winner = opponent\n    return winner"
    },
    {
        "number": 1037,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    happiness_points = 0\n    for i in range(N):\n        happiness_points += A[i] * (i + 1)\n    return str(happiness_points)"
    },
    {
        "number": 1038,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    f = A ^ (A + 1) ^ (A + 2) ^ (A + 3) ^ (A + 4) ^ (A + 5) ^ (A + 6) ^ (A + 7) ^ (A + 8) ^ (A + 9) ^ (A + 10) ^ (A + 11) ^ (A + 12) ^ (A + 13) ^ (A + 14) ^ (A + 15) ^ (A + 16) ^ (A + 17) ^ (A + 18) ^ (A + 19) ^ (A + 20) ^ (A + 21) ^ (A + 22) ^ (A + 23) ^ (A + 24) ^ (A + 25) ^ (A + 26) ^ (A + 27) ^ (A + 28) ^ (A + 29) ^ (A + 30) ^ (A + 31) ^ (A + 32) ^ (A + 33) ^ (A + 34) ^ (A + 35) ^ (A + 36) ^ (A + 37) ^ (A + 38) ^ (A + 39) ^ (A + 40) ^ (A + 41) ^ (A + 42) ^ (A + 43) ^ (A + 44) ^ (A + 45) ^ (A + 46) ^ (A + 47) ^ (A + 48) ^ (A + 49) ^ (A + 50) ^ (A + 51) ^ (A + 52) ^ (A + 53) ^ (A + 54) ^ (A + 55) ^ (A + 56) ^ (A + 57) ^ (A + 58) ^ (A + 59) ^ (A + 60) ^ (A + 61) ^ (A + 62) ^ (A + 63) ^ (A + 64) ^ (A + 65) ^ (A + 66) ^ (A + 67) ^ (A + 68) ^ (A + 69) ^ (A + 70) ^ (A + 71) ^ (A + 72) ^ (A + 73) ^ (A + 74) ^ (A + 75) ^ (A + 76) ^ (A + 77) ^ (A + 78) ^ (A + 79) ^ (A + 80) ^ (A + 81) ^ (A + 82) ^ (A + 83) ^ (A + 84) ^ (A + 85) ^ (A + 86) ^ (A + 87) ^ (A + 88) ^ (A + 89) ^ (A + 90) ^ (A + 91) ^ (A + 92) ^ (A + 93) ^ (A + 94) ^ (A + 95) ^ (A + 96) ^ (A + 97) ^ (A + 98) ^ (A + 99) ^ (A + 100) ^ (A + 101) ^ (A + 102) ^ (A + 103) ^ (A + 104) ^ (A + 105) ^ (A + 106) ^ (A + 107) ^ (A + 108) ^ (A + 109) ^ (A + 110) ^ (A + 111) ^ (A + 112) ^ (A + 113) ^ (A + 114) ^ (A + 115) ^ (A + 116) ^ (A + 117) ^ (A + 118) ^ (A + 119) ^ (A + 120) ^ (A + 121) ^ (A + 122) ^ (A + 123) ^ (A + 124"
    },
    {
        "number": 1039,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q, K = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b, c = map(int, stdin.split())\n        graph[a - 1].append((b - 1, c))\n        graph[b - 1].append((a - 1, c))\n\n    def dijkstra(start: int) -> int:\n        dist = [float('inf')] * N\n        dist[start] = 0\n        queue = [(0, start)]\n        while queue:\n            dist, curr = queue.pop(0)\n            if dist == float('inf'):\n                continue\n            for neighbor, weight in graph[curr]:\n                if dist[neighbor] > dist[curr] + weight:\n                    dist[neighbor] = dist[curr] + weight\n                    queue.append((dist[neighbor], neighbor))\n        return dist[K - 1]\n\n    for _ in range(Q):\n        x, y = map(int, stdin.split())\n        length = dijkstra(x - 1) + dijkstra(y - 1)\n        print(length)\n\n    return ''"
    },
    {
        "number": 1040,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s = map(int, stdin.split())\n    s = s.lower()\n    result = \"\"\n    for i in range(N):\n        if s[i:i+len(\"fox\")] == \"fox\":\n            result += s[i+len(\"fox\"):]\n            s = s[:i] + s[i+len(\"fox\")+1:]\n    result += s\n    return result"
    },
    {
        "number": 1041,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    k = int(s[0])\n    points = [int(s[i:i+2]) for i in range(0, len(s), 2)]\n    result = \"NO\"\n\n    for i in range(n):\n        if i == 0:\n            continue\n        for j in range(i+1, n):\n            if i == j:\n                continue\n            if points[i] % 2 == 0 and points[j] % 2 == 0:\n                if points[i] + k >= points[j]:\n                    result = \"YES\"\n                    break\n                elif points[i] - k <= points[j]:\n                    result = \"YES\"\n                    break\n            elif points[i] % 2 == 0 and points[j] % 2!= 0:\n                if points[i] + k >= points[j]:\n                    result = \"YES\"\n                    break\n            elif points[i] % 2!= 0 and points[j] % 2 == 0:\n                if points[i] - k <= points[j]:\n                    result = \"YES\"\n                    break\n\n    return result"
    },
    {
        "number": 1042,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    count = 0\n    for i in range(1, x + 1):\n        for j in range(1, y + 1):\n            if gcd(i, j, x, y) == x:\n                count += 1\n    return str(count % (10**9 + 7))\n\ndef"
    },
    {
        "number": 1043,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate the minimum number of dollars to bribe the friend\n    min_bribe = 0\n    for i in range(n):\n        if a[i] == -1:\n            min_bribe += 1\n\n    return str(min_bribe)"
    },
    {
        "number": 1044,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    result = []\n\n    for i in range(n):\n        cycles = set()\n        for j in range(i + 1, n + 1):\n            cycles.add(set(a[:j]))\n        result.append(len(cycles))\n\n    return str(max(result))\n"
    },
    {
        "number": 1045,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_height = 1\n    for i in range(1, n + 1):\n        max_height += 1\n    return str(max_height)"
    },
    {
        "number": 1046,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    secretaries = list(map(int, stdin.strip().split()))\n\n    pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if secretaries[i] == 0 and secretaries[j] == 0:\n                pairs += 1\n\n    return str(pairs)"
    },
    {
        "number": 1047,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    quasibinary_count = 0\n    quasibinary_sum = 0\n    for i in range(1, n+1):\n        if str(i).count('0') == 0 and str(i).count('1') == 0:\n            quasibinary_count += 1\n            quasibinary_sum += i\n    return str(quasibinary_count) +'' +''.join(map(str, range(1, quasibinary_count+1)))"
    },
    {
        "number": 1048,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = stdin.strip()\n    max_commands = 0\n    current_x = 0\n    current_y = 0\n    for i in range(n):\n        command = sequence[i]\n        if command == 'U':\n            current_y += 1\n        elif command == 'D':\n            current_y -= 1\n        elif command == 'L':\n            current_x -= 1\n        elif command == 'R':\n            current_x += 1\n        else:\n            continue\n        if current_x == 0 and current_y == 0:\n            max_commands += 1\n    return str(max_commands)"
    },
    {
        "number": 1049,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    opponents = [[] for _ in range(n)]\n    for _ in range(d):\n        opponents_present = list(map(int, input().split()))\n        for i in range(n):\n            if opponents_present[i]:\n                opponents[i].append(i)\n\n    max_consecutive_days = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(set(opponents[i]) & set(opponents[j])) == 0:\n                max_consecutive_days = max(max_consecutive_days, j - i)\n\n    return str(max_consecutive_days)\n"
    },
    {
        "number": 1050,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n == 0 or m == 0 or k == 0:\n        return \"No\"\n\n    if n == 1 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 1 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 2 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 2 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 3 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 3 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 4 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 4 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 5 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 5 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 6 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 6 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 7 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 7 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 8 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 8 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 9 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 9 and m == 1 and k == 2:\n        return \"Yes\"\n\n    if n == 10 and m == 1 and k == 1:\n        return \"Yes\"\n\n    if n == 10 and m == 1 and k == 2:\n        return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 1051,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.readline().strip())\n    r = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the finalists by their qualifying ranks\n    finalists = sorted(enumerate(r), key=lambda x: x[1])\n\n    # Initialize the minimum number of contestants that declined the invitation\n    min_declined = K\n\n    # Iterate through the finalists and count the number of contestants that declined the invitation\n    for i, (rank, _) in finalists:\n        if rank == K:\n            min_declined -= 1\n\n    return str(min_declined)\n"
    },
    {
        "number": 1052,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if sum(p[i] == i for p in permutations(range(1, n + 1))) >= k:\n            count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 1053,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    graph = [[0] * n for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        graph[u][v] = graph[v][u] = 1\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in range(n):\n            if not visited[v] and graph[u][v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    dfs(0, visited)\n    weight = sum(graph[u][v] for u in range(n) for v in range(n) if graph[u][v])\n    return str(weight)"
    },
    {
        "number": 1054,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    mines = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        mines.append((x, y))\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def is_inside(x, y):\n        return 0 <= x < n and 0 <= y < n\n\n    def is_border(x, y):\n        return x == 0 or x == n - 1 or y == 0 or y == n - 1\n\n    def area(x1, y1, x2, y2):\n        return abs(x2 - x1) * abs(y2 - y1)\n\n    def min_area(mines):\n        min_area = float('inf')\n        for x1, y1 in mines:\n            for x2, y2 in mines:\n                if is_valid(x1, y1) and is_valid(x2, y2) and not is_border(x1, y1) and not is_border(x2, y2):\n                    min_area = min(min_area, area(x1, y1, x2, y2))\n        return min_area\n\n    min_area_city = min_area(mines)\n    return str(min_area_city)\n"
    },
    {
        "number": 1055,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Sort the array using Thanos sort\n    for i in range(n // 2):\n        for j in range(i, n - 1):\n            if a[j] > a[j + 1]:\n                a[j], a[j + 1] = a[j + 1], a[j]\n\n    # Find the maximum length of a sorted array\n    max_length = 1\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            max_length += 1\n\n    return str(max_length)\n"
    },
    {
        "number": 1056,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    h = list(map(int, stdin.split()))\n\n    # Initialize variables\n    n = len(h)\n    m = len(h[0])\n    goal_row = 0\n    goal_col = 0\n    start_row = 0\n    start_col = 0\n    ladders = []\n    visited = set()\n\n    # Initialize the board\n    board = [[0] * m for _ in range(n)]\n\n    # Initialize the path\n    path = [[0] * m for _ in range(n)]\n\n    # Initialize the current position\n    row = 0\n    col = 0\n\n    # Initialize the minimum expected number of turns\n    min_turns = float('inf')\n\n    # Perform the game\n    while True:\n        # Roll the dice\n        r = random.randint(1, 6)\n\n        # Check if the player can climb the ladder\n        if r == 1:\n            # Check if the player can climb the ladder at the current position\n            if board[row][col] == 0:\n                # If the player can climb the ladder, move to the next position\n                row += 1\n                col = 0\n            else:\n                # If the player cannot climb the ladder, move to the square containing the bottom of the ladder\n                row += 1\n                col = 0\n                while board[row][col] == 0:\n                    row += 1\n                    col = 0\n\n        # Check if the player can climb the ladder at the current position\n        elif r == 2:\n            # Check if the player can climb the ladder at the current position\n            if board[row][col] == 0:\n                # If the player can climb the ladder, move to the next position\n                row += 1\n                col = 0\n            else:\n                # If the player cannot climb the ladder, move to the square containing the bottom of the ladder\n                row += 1\n                col = 0\n                while board[row][col] == 0:\n                    row += 1\n                    col = 0\n\n        # Check if the player can climb the ladder at the current position\n        elif r == 3:\n            # Check if the player can climb the ladder at the current position\n            if board[row][col] == 0:\n                # If the player can climb the ladder, move to the next position\n                row += 1\n                col = 0\n            else:\n                # If the player cannot climb the ladder, move to the square containing the bottom of the ladder\n                row += 1\n                col = 0\n                while board[row][col] == 0:\n                    row += 1\n                    col = 0\n\n        # Check if the player can climb the ladder at the current position\n        elif r == 4:\n            # Check if the player can climb the ladder at the current position\n            if board[row][col] == 0:\n                # If the player can climb the ladder, move to the next position\n                row += 1\n                col = 0\n            else:\n                # If the player cannot climb the ladder, move to the square containing the bottom of the ladder\n                row += 1\n                col = 0\n                while board[row][col] == 0:\n                    row += 1\n                    col = 0\n\n        # Check if the player can climb the ladder at the current position\n        elif r == 5:\n            # Check if the player can climb the ladder at the current position\n            if board[row][col] == 0:\n                # If the player can climb the ladder, move to the next position\n                row += 1\n                col = 0\n            else:\n                # If the player cannot climb the ladder, move to the square containing the bottom of the ladder\n                row += 1\n                col = 0\n                while board[row][col] == 0:\n                    row += 1\n                    col = 0\n\n        # Check if the player can climb the ladder at the current position\n        elif r == 6:\n            # Check if the player can climb the ladder at the current position\n            if board[row][col] == 0:\n                # If the player can climb the ladder, move to the next position\n                row += 1\n                col = 0\n            else:\n                # If the player cannot climb the ladder, move to the square containing the bottom of the ladder\n                row += 1\n                col = 0\n                while board[row][col] == 0:\n                    row += 1\n                    col = 0\n\n        # Check if the player can climb the ladder at the current position\n        elif r == 7:\n            # Check if the player can climb the ladder"
    },
    {
        "number": 1057,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i:j] == s[i:j][::-1]:\n                count += 1\n                if count == 2:\n                    break\n    return str(count % 998244353)"
    },
    {
        "number": 1058,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    blocks = []\n    for _ in range(n):\n        color1, value, color2 = map(int, stdin.strip().split())\n        blocks.append((color1, value, color2))\n\n    def is_valid(block1, block2):\n        return block1[0] == block2[0] or block1[1] == block2[1] or block1[2] == block2[2]\n\n    def max_value(blocks):\n        max_value = float('-inf')\n        for block in blocks:\n            max_value = max(max_value, block[1] + block[2])\n        return max_value\n\n    def valid_sequence(blocks):\n        valid_blocks = []\n        for i in range(len(blocks)):\n            for j in range(i + 1, len(blocks)):\n                if is_valid(blocks[i], blocks[j]):\n                    valid_blocks.append(blocks[i])\n                    break\n        return valid_blocks\n\n    max_value_sequence = max_value(blocks)\n    valid_sequence_blocks = valid_sequence(blocks)\n\n    max_value_sequence_str = str(max_value_sequence)\n    valid_sequence_blocks_str =''.join(map(str, valid_sequence_blocks))\n\n    return max_value_sequence_str + '\\n' + valid_sequence_blocks_str\n"
    },
    {
        "number": 1059,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    if k < 1 or k > 10**4:\n        return \"-1\"\n\n    vowels = \"aeiou\"\n    grid = [[0] * k for _ in range(k)]\n\n    for i in range(k):\n        grid[i][i] = 1\n\n    for i in range(k - 1):\n        for j in range(i + 1, k):\n            if grid[i][j] == 0:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j] = 1\n                        grid[k][j] = 1\n                        break\n\n    for i in range(k):\n        for j in range(k):\n            if grid[i][j] == 1:\n                for k in range(k):\n                    if grid[i][k] == 0 and grid[k][j] == 0:\n                        grid[i][j]"
    },
    {
        "number": 1060,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = set(map(int, stdin.readline().strip().split()))\n\n    def is_divisible(a, b):\n        return a % b == 0\n\n    def max_clique(A):\n        max_size = 0\n        max_clique = set()\n\n        for a in A:\n            for b in A:\n                if a!= b and is_divisible(a, b):\n                    max_clique.add(a)\n                    max_clique.add(b)\n                    max_size = max(max_size, len(max_clique))\n                    max_clique.clear()\n\n        return max_size\n\n    return str(max_clique(A))\n"
    },
    {
        "number": 1061,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    matrix = []\n    for line in stdin.splitlines():\n        row = []\n        for num in line.split():\n            row.append(int(num))\n        matrix.append(row)\n\n    beautiful = True\n    for i in range(5):\n        for j in range(5):\n            if matrix[i][j] == 1:\n                if i > 0 and j > 0:\n                    if matrix[i - 1][j - 1] == 0:\n                        beautiful = False\n                        break\n                if i > 0:\n                    if matrix[i - 1][j] == 0:\n                        beautiful = False\n                        break\n                if j > 0:\n                    if matrix[i][j - 1] == 0:\n                        beautiful = False\n                        break\n\n    if beautiful:\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 1062,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    S = stdin.readline().strip()\n    T = stdin.readline().strip()\n\n    def hamming_distance(s: str, t: str) -> int:\n        return sum(1 for c1, c2 in zip(s, t) if c1!= c2)\n\n    def swap_characters(s: str, i: int, j: int) -> str:\n        return s[:i] + s[i+1:j] + s[j+1:]\n\n    def min_hamming_distance(s: str, t: str) -> int:\n        min_distance = float('inf')\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                new_s = swap_characters(s, i, j)\n                new_t = swap_characters(t, i, j)\n                distance = hamming_distance(new_s, new_t)\n                if distance < min_distance:\n                    min_distance = distance\n        return min_distance\n\n    if min_hamming_distance(S, T) == float('inf'):\n        return \"-1 -1\"\n    else:\n        i, j = min_hamming_distance(S, T).index(min_hamming_distance(S, T)), min_hamming_distance(S, T).index(min_hamming_distance(S, T))\n        return str(i) + \" \" + str(j)"
    },
    {
        "number": 1063,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = list(map(int, stdin.strip().split()))\n\n    for i in range(n):\n        if sequence[i] == 0:\n            sequence[i] = '?'\n\n    sequence = sorted(sequence)\n    result = []\n\n    for digit in sequence:\n        if digit == '?':\n            result.append('?')\n        else:\n            result.append(str(digit))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1064,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    blocked_positions = list(map(int, stdin.split()))\n    post_lamp_costs = list(map(int, stdin.split()))\n\n    # Check if the segment is possible to illuminate\n    if n == 0:\n        return \"-1\"\n\n    # Check if there are any blocked positions\n    if len(blocked_positions) == 0:\n        return \"0\"\n\n    # Check if there are any post lamps of the same type\n    post_lamps = set()\n    for i in range(n):\n        for l in range(1, k + 1):\n            post_lamps.add((i, l))\n\n    # Check if there are any post lamps of the same type in the blocked positions\n    for i in blocked_positions:\n        for l in range(1, k + 1):\n            if (i, l) in post_lamps:\n                post_lamps.remove((i, l))\n\n    # Calculate the total cost of the post lamps\n    total_cost = 0\n    for i in range(n):\n        for l in range(1, k + 1):\n            if (i, l) in post_lamps:\n                total_cost += post_lamp_costs[l - 1]\n\n    return str(total_cost)\n"
    },
    {
        "number": 1065,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, M, D = map(int, stdin.split())\n    if n > 10**18 or k > n or M > n or D > min((n, 1000)) or M * D * k > n:\n        return \"Invalid input\"\n\n    def split_candies(x):\n        candies = 0\n        for i in range(1, x + 1):\n            candies += i\n        return candies\n\n    max_candies = 0\n    for x in range(1, k + 1):\n        candies = split_candies(x)\n        if candies <= M:\n            max_candies = max(max_candies, candies)\n\n    return str(max_candies)\n"
    },
    {
        "number": 1066,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = [i for i in range(1, n+1) if i % 2 == 0] + [i for i in range(1, n+1) if i % 2!= 0]\n    sequence.sort()\n    return str(sequence[k-1])"
    },
    {
        "number": 1067,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the minimum cost\n    min_cost = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            min_cost += 1 if a[i] * a[j] == 1 else 0\n\n    return str(min_cost)\n"
    },
    {
        "number": 1068,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    if a == 0 and b == 0 and c == 0:\n        return \"0\"\n    elif a == 0 and b == 0 and c!= 0:\n        return str(c) + \"+\" + str(c)\n    elif a == 0 and b!= 0 and c == 0:\n        return str(b) + \"+\" + str(b)\n    elif a == 0 and b!= 0 and c!= 0:\n        return str(b) + \"+\" + str(c)\n    elif a!= 0 and b == 0 and c == 0:\n        return str(a) + \"+\" + str(a)\n    elif a!= 0 and b == 0 and c!= 0:\n        return str(a) + \"+\" + str(c)\n    elif a!= 0 and b!= 0 and c == 0:\n        return str(a) + \"+\" + str(b)\n    elif a!= 0 and b!= 0 and c!= 0:\n        return str(a) + \"+\" + str(c)\n    else:\n        return \"Error: Invalid input\""
    },
    {
        "number": 1069,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = 1\n    for i in range(n):\n        result = (result ** i + 2 ** i + 3 ** i + 4 ** i) % 5\n    return str(result)"
    },
    {
        "number": 1070,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n\n    max_length = 0\n    current_length = 0\n    current_color = colors[0]\n\n    for i in range(1, n):\n        if colors[i] == current_color:\n            current_length += 1\n        else:\n            if current_length > max_length:\n                max_length = current_length\n            current_length = 1\n            current_color = colors[i]\n\n    if current_length > max_length:\n        max_length = current_length\n\n    return str(max_length)"
    },
    {
        "number": 1071,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3 = map(int, stdin.split())\n    b_1, b_2, b_3 = map(int, stdin.split())\n    n = int(stdin.strip())\n\n    if a_1 + a_2 + a_3 == 0 or b_1 + b_2 + b_3 == 0:\n        return \"NO\"\n\n    for i in range(n):\n        if a_1 > 0 and a_1 <= 5 and b_1 > 0 and b_1 <= 5:\n            a_1 -= 1\n            b_1 -= 1\n        elif a_1 > 5 or b_1 > 5:\n            return \"NO\"\n\n        if a_2 > 0 and a_2 <= 5 and b_2 > 0 and b_2 <= 5:\n            a_2 -= 1\n            b_2 -= 1\n        elif a_2 > 5 or b_2 > 5:\n            return \"NO\"\n\n        if a_3 > 0 and a_3 <= 5 and b_3 > 0 and b_3 <= 5:\n            a_3 -= 1\n            b_3 -= 1\n        elif a_3 > 5 or b_3 > 5:\n            return \"NO\"\n\n        if a_1 + a_2 + a_3 > 5 or b_1 + b_2 + b_3 > 5:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1072,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = list(stdin.strip())\n    good = True\n    for i in range(m):\n        for j in range(i+1, m):\n            if table[i] > table[j]:\n                good = False\n                break\n    if good:\n        return \"0\"\n    else:\n        return str(m - 1)"
    },
    {
        "number": 1073,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    commands = stdin.strip().split()\n    directions = ['U', 'R', 'D', 'L']\n    directions_count = {'U': 0, 'R': 0, 'D': 0, 'L': 0}\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions_count['U'] += 1\n    directions_count['R'] += 1\n    directions_count['D'] += 1\n    directions_count['L'] += 1\n    directions_count['U'] -= 1\n    directions_count['R'] -= 1\n    directions_count['D'] -= 1\n    directions_count['L'] -= 1\n    directions"
    },
    {
        "number": 1074,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a % 2 == 0:\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 1075,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 2:\n        return \"-1\"\n\n    order = []\n    for i in range(n):\n        if i == 0:\n            order.append(i)\n        else:\n            order.append(i % n)\n            order.append(i // n * 2 + 1 % n)\n\n    if len(set(order))!= n:\n        return \"-1\"\n\n    return \" \".join(map(str, order))"
    },
    {
        "number": 1076,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    P, Q = 998244353, 998244353\n    P, Q = P - 1, Q - 1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    P = lcm(P, Q)\n    P = P - 1\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if is_prime(P) and is_prime(Q):\n        P = P - 1\n\n    def is_valid_card(card):\n        return 1 <= card <= n\n\n    def is_valid_joker(card):\n        return card == m\n\n    def is_valid_set(set_):\n        return all(is_valid_card(card) for card in set_)\n\n    def is_valid_game(deck):\n        return is_valid_set(deck)\n\n    def is_valid_deck(deck):\n        return all(is_valid_card(card) for card in deck)\n\n    def is_valid_game_state(deck, set_):\n        return is_valid_deck(deck) and is_valid_set(set_)\n\n    def is_valid_game_end(deck, set_):\n        return is_valid_game_state(deck, set_)\n\n    def is_valid_game_state_and_end(deck, set_):\n        return is_valid_game_state(deck, set_) and is_valid_game_end(deck, set_)\n\n    def is_valid_game_state_and_end_and_prime(deck, set_):\n        return is_valid_game_state_and_end(deck, set_) and is_valid_prime(P, Q)\n\n    def is_valid_prime(p, q):\n        if p == 1 or q == 1:\n            return True\n        if p == 2 or q == 2:\n            return True\n        if p == 3 or q == 3:\n            return True\n        if p == 5 or q == 5:\n            return True\n        if p == 7 or q == 7:\n            return True\n        if p == 11 or q == 11:\n            return True\n        if p == 13 or q == 13:\n            return True\n        if p == 17 or q == 17:\n            return True\n        if p == 19 or q == 19:\n            return True\n        if p == 23 or q == 23:\n            return True\n        if p == 29 or q == 29:\n            return True\n        if p == 31 or q == 31:\n            return True\n        if p == 37 or q == 37:\n            return True\n        if p == 41 or q == 41:\n            return True\n        if p == 43 or q == 43:\n            return True\n        if p == 47 or q == 47:\n            return True\n        if p == 53 or q == 53:\n            return True\n        if p == 59 or q == 59:\n            return True\n        if p == 61 or q == 61:\n            return True\n        if p == 67 or q == 67:\n            return True\n        if p == 71 or q == 71:\n            return True\n        if p == 73 or q == 73:\n            return True\n        if p == 79 or q == 79:\n            return True\n        if p == 83 or q == 83:\n            return True\n        if p == 89 or q == 89:\n            return True\n        if p == 97 or q == 97:\n            return True\n        if p == 101 or q == 101:\n            return True\n        if p == 103 or q == 103:\n            return True\n        if p == 107 or q == 107:\n            return True\n        if p == 109 or q == 109:\n            return True\n        if p == 113 or q == 113:\n            return True\n        if p == 127 or q == 127:\n            return True\n        "
    },
    {
        "number": 1077,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize the minimum value and the minimum number of changes\n    min_value = float('inf')\n    min_changes = 0\n\n    # Iterate over the bands\n    for i in range(1, m + 1):\n        # Initialize the number of songs for the current band\n        num_songs = 0\n\n        # Iterate over the songs in the current band\n        for j in range(n):\n            # If the current song is the i-th song, replace it with any other group\n            if a[j] == i:\n                num_songs += 1\n                a[j] = -1\n\n        # If the current band has performed at least one song, update the minimum value\n        if num_songs > 0:\n            min_value = min(min_value, i)\n\n        # If the current band has performed at least two songs, update the minimum number of changes\n        if num_songs >= 2:\n            min_changes += 1\n\n    # Print the result\n    print(min_value, min_changes)\n\n    # Print the changed playlist\n    playlist = []\n    for i in range(n):\n        if a[i] == -1:\n            playlist.append(i + 1)\n        else:\n            playlist.append(a[i])\n\n    print(' '.join(map(str, playlist)))\n\n    return ''"
    },
    {
        "number": 1078,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    total_sum = sum(a)\n    if total_sum!= 0:\n        return str(n) + '\\n' + '\\n'.join(map(str, a))\n    else:\n        return '0\\n'"
    },
    {
        "number": 1079,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    beautiful_numbers = 0\n    for i in range(1, n+1):\n        if i == 2**k or -2**k == i:\n            beautiful_numbers += 1\n    return str(beautiful_numbers)"
    },
    {
        "number": 1080,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                a[i], a[j] = 0, 0\n\n    if all(a[i] == 0 for i in range(n)):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1081,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a % 2 == 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 1082,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    MOD = 10**9 + 7\n\n    def count_ways(a, n):\n        if n == 0:\n            return 1\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n\n        ways = 0\n        for i in range(n):\n            ways += count_ways(a[:i] + a[i+1:], n-1)\n\n        return ways\n\n    ways = count_ways(a, n)\n    return str(ways % MOD)"
    },
    {
        "number": 1083,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        first_group = []\n        second_group = []\n        for i in range(n):\n            if i % 2 == 0:\n                first_group.append(i)\n            else:\n                second_group.append(i)\n        first_sum = sum(first_group)\n        second_sum = sum(second_group)\n        first_diff = abs(first_sum - second_sum)\n        second_diff = abs(second_sum - first_sum)\n        if first_diff < second_diff:\n            return str(first_diff) + \" \" + \" \".join(map(str, first_group))\n        else:\n            return str(second_diff) + \" \" + \" \".join(map(str, second_group))"
    },
    {
        "number": 1084,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(row) for row in stdin.split('\\n')]\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i][k] = '#'\n\n    # Check if the desired setup can be achieved by any valid sequence of operations\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '#':\n                for k in range(i, n):\n                    if grid[k][j] == '.' and k!= i:\n                        grid[k][j] = '#'\n                for k in range(j, m):\n                    if grid[i][k] == '.' and k!= j:\n                        grid[i"
    },
    {
        "number": 1085,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    K = 2\n    count = 0\n\n    while N >= K:\n        N = N // K\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 1086,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    def paint(i, j):\n        A[i][j] = 0\n        B[i][j] = 0\n\n    def move(i, j):\n        if i == 1 and j == 1:\n            return\n        if i == H - 1 and j == W - 1:\n            return\n        if i == 1:\n            paint(i, j + 1)\n        elif i == H - 1:\n            paint(i - 1, j)\n        elif j == 1:\n            paint(i, j + 1)\n        elif j == W - 1:\n            paint(i, j - 1)\n        else:\n            paint(i + 1, j)\n\n    def unbalancedness(i, j):\n        red_sum = sum(A[i][j] for j in range(W))\n        blue_sum = sum(B[i][j] for j in range(W))\n        return abs(red_sum - blue_sum)\n\n    def min_unbalancedness(i, j):\n        min_unbalancedness = float('inf')\n        for k in range(1, H):\n            for l in range(1, W):\n                if i == k and j == l:\n                    continue\n                if unbalancedness(k, l) < min_unbalancedness:\n                    min_unbalancedness = unbalancedness(k, l)\n        return min_unbalancedness\n\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == 0 and B[i][j] == 0:\n                paint(i, j)\n                move(i, j)\n                min_unbalancedness = min(min_unbalancedness, unbalancedness(i, j))\n                move(i, j)\n                paint(i, j)\n\n    return str(min_unbalancedness)\n"
    },
    {
        "number": 1087,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def f(x):\n        return (x ^ A[0]) + (x ^ A[1]) +... + (x ^ A[N-1])\n\n    max_f = max(f(x) for x in range(K, N+1))\n    return str(max_f)"
    },
    {
        "number": 1088,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = [[int(x) for x in stdin.split()] for _ in range(N)]\n\n    def swap_columns(a, x, y):\n        for i in range(N):\n            a[i][x], a[i][y] = a[i][y], a[i][x]\n\n    def swap_rows(a, x, y):\n        for i in range(N):\n            a[x][i], a[y][i] = a[y][i], a[x][i]\n\n    for i in range(N):\n        for j in range(N):\n            if a[i][j] == 1:\n                swap_columns(a, i, j)\n                swap_rows(a, i, j)\n\n    count = 0\n    for i in range(N):\n        for j in range(N):\n            if a[i][j] == 1:\n                count += 1\n\n    return str(count % 998244353)"
    },
    {
        "number": 1089,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    costs = [0] * (N * M)\n    for i in range(N):\n        for j in range(M):\n            if i == 0 or j == 0 or i == N - 1 or j == M - 1:\n                costs[i * M + j] = 0\n            else:\n                x1, y1 = i, j\n                x2, y2 = i + 1, j + 1\n                x3, y3 = i + 1, j\n                x4, y4 = i, j + 1\n                x5, y5 = i + 1, j + 1\n                x6, y6 = i, j\n                x7, y7 = i + 1, j + 1\n                x8, y8 = i + 1, j\n                x9, y9 = i, j + 1\n                x10, y10 = i + 1, j + 1\n                x11, y11 = i, j + 1\n                x12, y12 = i + 1, j\n                x13, y13 = i, j + 1\n                x14, y14 = i + 1, j + 1\n                x15, y15 = i, j + 1\n                x16, y16 = i + 1, j + 1\n                x17, y17 = i, j + 1\n                x18, y18 = i + 1, j + 1\n                x19, y19 = i, j + 1\n                x20, y20 = i + 1, j + 1\n                x21, y21 = i, j + 1\n                x22, y22 = i + 1, j + 1\n                x23, y23 = i, j + 1\n                x24, y24 = i + 1, j + 1\n                x25, y25 = i, j + 1\n                x26, y26 = i + 1, j + 1\n                x27, y27 = i, j + 1\n                x28, y28 = i + 1, j + 1\n                x29, y29 = i, j + 1\n                x30, y30 = i + 1, j + 1\n                x31, y31 = i, j + 1\n                x32, y32 = i + 1, j + 1\n                x33, y33 = i, j + 1\n                x34, y34 = i + 1, j + 1\n                x35, y35 = i, j + 1\n                x36, y36 = i + 1, j + 1\n                x37, y37 = i, j + 1\n                x38, y38 = i + 1, j + 1\n                x39, y39 = i, j + 1\n                x40, y40 = i + 1, j + 1\n                x41, y41 = i, j + 1\n                x42, y42 = i + 1, j + 1\n                x43, y43 = i, j + 1\n                x44, y44 = i + 1, j + 1\n                x45, y45 = i, j + 1\n                x46, y46 = i + 1, j + 1\n                x47, y47 = i, j + 1\n                x48, y48 = i + 1, j + 1\n                x49, y49 = i, j + 1\n                x50, y50 = i + 1, j + 1\n                x51, y51 = i, j + 1\n                x52, y52 = i + 1, j + 1\n                x53, y53 = i, j + 1\n                x54, y54 = i + 1, j + 1\n                x55, y55 = i, j + 1\n                x56, y56 = i + 1, j + 1\n                x57, y57 = i, j + 1\n                x58, y58 = i + 1, j + 1\n                x59, y59 = i, j +"
    },
    {
        "number": 1090,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    directions = list(stdin.strip())\n    queue = [0] * N\n    happy_people = 0\n\n    for i in range(N):\n        if directions[i] == 'L':\n            queue[i] = (queue[i] + 1) % N\n        elif directions[i] == 'R':\n            queue[i] = (queue[i] - 1) % N\n\n    for _ in range(K):\n        l, r = queue[0], queue[-1]\n        queue[0], queue[-1] = queue[-1], queue[0]\n\n        for i in range(N):\n            if directions[i] == 'L':\n                queue[i] = (queue[i] + 1) % N\n            elif directions[i] == 'R':\n                queue[i] = (queue[i] - 1) % N\n\n        if l == r:\n            happy_people += 1\n\n    return str(happy_people)\n"
    },
    {
        "number": 1091,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    prices = list(map(int, stdin.readline().strip().split()))\n\n    # Sort prices in ascending order\n    prices.sort()\n\n    # Initialize variables\n    max_price = prices[0]\n    max_price_index = 0\n    current_price = prices[0]\n    current_price_index = 0\n\n    # Iterate through the prices\n    for i in range(1, n):\n        # Check if the current price is greater than the max price\n        if prices[i] > max_price:\n            # Update max_price and max_price_index\n            max_price = prices[i]\n            max_price_index = i\n\n            # Update current_price and current_price_index\n            current_price = prices[i]\n            current_price_index = i\n\n    # Find the winner and the price he will pay\n    winner_index = max_price_index + 1\n    winner_price = prices[winner_index]\n\n    return f\"{winner_index} {winner_price}\""
    },
    {
        "number": 1092,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    lights = [False] * n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        lights[a - 1] = True\n        lights[b - 1] = True\n\n    def dfs(i, seen):\n        if i == n:\n            return 1\n        if seen[i]:\n            return 0\n        seen[i] = True\n        ways = 0\n        for j in range(i + 1, n + 1):\n            if lights[j - 1] and not seen[j - 1]:\n                ways += dfs(j, seen)\n        seen[i] = False\n        return ways\n\n    return str(dfs(1, [False] * n))"
    },
    {
        "number": 1094,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    chats = []\n    for _ in range(n):\n        recipient = stdin.strip()\n        chats.append(recipient)\n    chats.sort()\n    return '\\n'.join(chats)"
    },
    {
        "number": 1095,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, y1 = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m, y2 = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n\n    max_sensors = 0\n    for i in range(n):\n        for j in range(m):\n            if a[i] == b[j]:\n                max_sensors += 1\n                break\n\n    return str(max_sensors)"
    },
    {
        "number": 1096,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    king_position = stdin.strip()\n    king_position = king_position.split()\n    king_column = king_position[0]\n    king_row = king_position[1]\n    moves = []\n    for i in range(1, 9):\n        moves.append(king_column + str(i))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append(king_column + str(8))\n    moves.append(king_column + str(1))\n    moves.append("
    },
    {
        "number": 1097,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k = map(int, stdin.split())\n    roads = []\n    for _ in range(t):\n        a = map(int, stdin.split())\n        roads.append(a)\n\n    def dfs(start, visited, path):\n        if start == n:\n            return True\n\n        if start in visited:\n            return False\n\n        visited.add(start)\n        path.append(start)\n\n        for i in range(n):\n            if i == start:\n                continue\n\n            if roads[i][start] > 0 and not dfs(i, visited, path):\n                return False\n\n        path.pop()\n        visited.remove(start)\n        return True\n\n    if not dfs(1, set(), []):\n        return -1\n\n    result = []\n    for i in range(n - 1):\n        result.append(roads[i])\n        result.append(roads[i + 1])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1098,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    alarms = []\n    for _ in range(n):\n        alarm = input().split(':')\n        alarms.append((int(alarm[0]), int(alarm[1])))\n\n    max_time = 0\n    current_time = 0\n    for alarm in alarms:\n        current_time += 60\n        if current_time >= alarm[0]:\n            current_time -= alarm[0]\n            max_time = max(max_time, current_time)\n\n    return str(max_time) + ':' + str(max_time % 60)"
    },
    {
        "number": 1099,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in edges[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    dfs(0, visited)\n\n    def dfs_helper(u, visited):\n        if u == n - 1:\n            return True\n        for v in edges[u]:\n            if not visited[v]:\n                visited[v] = True\n                if dfs_helper(v, visited):\n                    return True\n                visited[v] = False\n        return False\n\n    if dfs_helper(0, visited):\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 1100,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    jumps = 0\n    for i in range(1, n):\n        jumps += 1\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            if i < j:\n                jumps += 1\n            else:\n                jumps -= 1\n    return str(jumps)"
    },
    {
        "number": 1101,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    rooms = list(map(int, stdin.split()))\n    rooms.append(0)  # Add an extra room for the farthest cow\n    rooms.append(0)  # Add an extra room for the farthest cow\n\n    # Calculate the minimum possible distance\n    min_distance = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            distance = abs(j - i)\n            if distance < min_distance:\n                min_distance = distance\n\n    return str(min_distance)\n"
    },
    {
        "number": 1102,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    # Count the number of criminals in each city\n    criminals = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            criminals[i] += t[j]\n            criminals[j] += t[i]\n\n    # Count the number of criminals in each city after using the BCD\n    criminals_bcd = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            criminals_bcd[i] += t[j]\n            criminals_bcd[j] += t[i]\n\n    # Find the city with the maximum number of criminals\n    max_city = 0\n    max_count = 0\n    for i in range(n):\n        if criminals[i] > max_count:\n            max_count = criminals[i]\n            max_city = i\n\n    # Print the number of criminals Limak will catch\n    print(max_count)\n\n    return \"\""
    },
    {
        "number": 1103,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = list(map(int, stdin.strip().split()))\n\n    def is_valid(card):\n        return card in [1, 2, 3, 4, 5, 6, 7, 8]\n\n    def is_valid_segment(card):\n        return card in [1, 2, 3, 4, 5, 6, 7, 8]\n\n    def is_valid_subsequence(card):\n        return card in [1, 2, 3, 4, 5, 6, 7, 8]\n\n    def is_valid_pair(card1, card2):\n        return card1 in [1, 2, 3, 4, 5, 6, 7, 8] and card2 in [1, 2, 3, 4, 5, 6, 7, 8]\n\n    def count_occurrences(card):\n        return sequence.count(card)\n\n    def longest_subsequence(start, end):\n        if start == end:\n            return 1\n\n        if start == end - 1:\n            return 1 if is_valid_subsequence(sequence[start]) else 0\n\n        if start == end - 2:\n            return 1 if is_valid_pair(sequence[start], sequence[end]) else 0\n\n        if start == end - 3:\n            return 1 if is_valid_segment(sequence[start]) else 0\n\n        if start == end - 4:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_pair(sequence[start], sequence[end]) else 0\n\n        if start == end - 5:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_segment(sequence[start]) else 0\n\n        if start == end - 6:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_subsequence(sequence[end]) else 0\n\n        if start == end - 7:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_subsequence(sequence[end]) and is_valid_pair(sequence[start], sequence[end]) else 0\n\n        if start == end - 8:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_subsequence(sequence[end]) and is_valid_segment(sequence[start]) else 0\n\n        return 0\n\n    def longest_subsequence_length(start, end):\n        if start == end:\n            return 1\n\n        if start == end - 1:\n            return 1 if is_valid_subsequence(sequence[start]) else 0\n\n        if start == end - 2:\n            return 1 if is_valid_pair(sequence[start], sequence[end]) else 0\n\n        if start == end - 3:\n            return 1 if is_valid_segment(sequence[start]) else 0\n\n        if start == end - 4:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_pair(sequence[start], sequence[end]) else 0\n\n        if start == end - 5:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_segment(sequence[start]) else 0\n\n        if start == end - 6:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_subsequence(sequence[end]) else 0\n\n        if start == end - 7:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_subsequence(sequence[end]) and is_valid_pair(sequence[start], sequence[end]) else 0\n\n        if start == end - 8:\n            return 1 if is_valid_subsequence(sequence[start]) and is_valid_subsequence(sequence[end]) and is_valid_segment(sequence[start]) else 0\n\n        return 0\n\n    longest_subsequence_length_list = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            length = longest_subsequence(i, j)\n            longest_subsequence_length_list.append(length)\n\n    return max(longest_subsequence_length_list)\n"
    },
    {
        "number": 1104,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    for i in range(n - 1):\n        if a[i] == b[i] | a[i + 1] == b[i]:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1105,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    data = []\n    for _ in range(n):\n        x, k = map(int, stdin.strip().split())\n        data.append((x, k))\n\n    data.sort(key=lambda x: x[0])\n\n    for x, k in data:\n        if x == 0:\n            continue\n        for i in range(x):\n            if data[i][1] == k:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1106,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate the number of lights required for each road\n    lights = [0] * (2 ** n + 1)\n    for i in range(2 ** n + 1):\n        lights[i] = a[i]\n\n    # Calculate the minimum number of lights required\n    min_lights = 0\n    for i in range(2 ** n + 1):\n        for j in range(i + 1, 2 ** n + 1):\n            if lights[i] + lights[j] == 2 ** n + 1:\n                min_lights += 1\n\n    return str(min_lights)\n"
    },
    {
        "number": 1107,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    actions = list(stdin.strip())\n    max_juice = 0\n    for i in range(1, n):\n        if actions[i] == 'a':\n            max_juice = max(max_juice, i + 1)\n        else:\n            max_juice = max(max_juice, i - 1)\n    return str(max_juice)"
    },
    {
        "number": 1108,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rooms = []\n    for _ in range(n):\n        p, q = map(int, stdin.readline().strip().split())\n        rooms.append((p, q))\n\n    free_rooms = [room for room in rooms if room[0] > 0 and room[1] > 0]\n    free_rooms.sort(key=lambda x: (-x[0], -x[1]))\n\n    count = 0\n    for room in free_rooms:\n        if room[0] + room[1] <= 10:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1109,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n            if count == k:\n                return \"1\"\n        elif a[i] == 2:\n            count += 1\n            if count == k:\n                return \"0\"\n\n    return \"0\""
    },
    {
        "number": 1110,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    opening_sequence = [2, 3, 1]\n    count = 0\n    for i in range(n):\n        if i in opening_sequence:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1111,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n\n    def partition(w):\n        n = len(w)\n        if n == 1:\n            return [[]]\n        elif n == 2:\n            return [[w[0], w[1]]]\n        else:\n            mid = n // 2\n            left = partition(w[:mid])\n            right = partition(w[mid:])\n            return left + right\n\n    partitions = partition(w)\n    weights = [sum(p) for p in partitions]\n\n    def subset_sum(weights, subset):\n        return sum(weights[i] * subset[i] for i in range(len(subset)))\n\n    def partition_sum(weights, partitions):\n        return sum(subset_sum(weights, p) for p in partitions)\n\n    def partition_count(weights, partitions):\n        return len(set(p for p in partitions))\n\n    def partition_weight(weights, partitions):\n        return sum(weights[p] for p in partitions)\n\n    def partition_subset_count(weights, partitions):\n        return sum(partition_count(weights, p) for p in partitions)\n\n    def partition_subset_weight(weights, partitions):\n        return partition_weight(weights, partitions)\n\n    def partition_subset_sum(weights, partitions):\n        return partition_subset_count(weights, partitions) * partition_subset_weight(weights, partitions)\n\n    def partition_subset_weight_sum(weights, partitions):\n        return partition_subset_weight(weights, partitions) * partition_subset_sum(weights, partitions)\n\n    def partition_subset_count_sum(weights, partitions):\n        return partition_subset_count(weights, partitions) * partition_subset_sum(weights, partitions)\n\n    def partition_subset_count_weight_sum(weights, partitions):\n        return partition_subset_count_weight(weights, partitions) * partition_subset_count_sum(weights, partitions)\n\n    def partition_subset_count_weight_sum_mod(weights, partitions):\n        return (partition_subset_count_weight_sum(weights, partitions) + 7) % 1000000007\n\n    return str(partition_subset_count_weight_sum_mod(weights, partitions))\n"
    },
    {
        "number": 1112,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n = int(stdin.readline())\n    magic_square = list(map(int, stdin.readline().split()))\n\n    # Check if the magic square meets the conditions\n    if sum(magic_square)!= 15:\n        return \"No magic square found\"\n\n    # Restore the original magic square\n    magic_square = [magic_square[i] for i in range(n)]\n    magic_square.append(magic_square[0])\n    magic_square.append(magic_square[-1])\n    magic_square.append(magic_square[n-1])\n    magic_square.append(magic_square[n-2])\n\n    # Print the magic square\n    print(\" \".join(map(str, magic_square)))\n\n    return \"\""
    },
    {
        "number": 1113,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize the array with the first element\n    a.insert(0, a[0])\n\n    # Initialize the variables\n    min_step = 1\n    max_step = n\n\n    # Iterate through the steps\n    for i in range(1, n):\n        # Find the minimum step such that a mistake was made on at least one step\n        for j in range(min_step, max_step + 1):\n            # Check if the current subset is the correct subset\n            if a[j - 1] == a[j]:\n                # If it is, update the minimum step\n                min_step = j\n                break\n\n        # If a mistake was made on at least one step, return -1\n        if min_step == max_step:\n            return \"-1\"\n\n        # Update the maximum step\n        max_step = min_step\n\n    # If the array is obtained without mistakes, return the minimum step\n    return str(min_step)\n"
    },
    {
        "number": 1114,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    if n!= m:\n        return \"Impossible\"\n\n    for i in range(m):\n        if b[i]!= f[i]:\n            return \"Ambiguity\"\n\n    for i in range(n):\n        if b[i]!= f[i]:\n            return \"Impossible\"\n\n    return \"Possible\""
    },
    {
        "number": 1115,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n    r = list(map(int, stdin.split()))\n\n    # Sort the periods\n    l.sort()\n    r.sort()\n\n    # Initialize the result\n    result = -1\n\n    # Iterate over the periods\n    for i in range(m):\n        # Check if the website is working\n        if l[i] <= a[i] <= r[i]:\n            # Check if the solution is possible\n            if i == 0:\n                # If the solution is possible, update the result\n                result = r[i] - a[i]\n            else:\n                # If the solution is not possible, update the result\n                result = -1\n                break\n\n    return str(result)\n"
    },
    {
        "number": 1116,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    for _ in range(T):\n        r, b, k = map(int, stdin.strip().split())\n        painted_planks = []\n        for i in range(1, 10**10):\n            if i % r == 0 and i % b == 0:\n                painted_planks.append(i)\n        if len(painted_planks) < k:\n            print(\"OBEY\")\n        else:\n            print(\"REBEL\")"
    },
    {
        "number": 1117,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rectangles = []\n    for _ in range(n):\n        w, h = map(int, stdin.strip().split())\n        rectangles.append((w, h))\n\n    def rotate(rectangles):\n        for i in range(len(rectangles)):\n            for j in range(i + 1, len(rectangles)):\n                rectangles[i], rectangles[j] = rectangles[j], rectangles[i]\n\n    def check_height(rectangles):\n        for i in range(len(rectangles)):\n            for j in range(i + 1, len(rectangles)):\n                if rectangles[i][1] > rectangles[j][1]:\n                    return False\n        return True\n\n    rotate(rectangles)\n    if check_height(rectangles):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1118,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(i, color):\n        if i == n:\n            return 1\n\n        if colors[i] == color:\n            return dfs(i + 1, color)\n\n        return dfs(i + 1, colors[i])\n\n    return str(dfs(1, colors[0]))\n"
    },
    {
        "number": 1119,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, p_a, p_b = map(int, stdin.split())\n    sequence = []\n    count = 0\n\n    while len(sequence) < k:\n        if random.random() < p_a / (p_a + p_b):\n            sequence.append('a')\n        else:\n            sequence.append('b')\n        count += 1\n\n    expected_count = 2\n\n    return str(expected_count * (k - count + 1))"
    },
    {
        "number": 1120,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    operations = 0\n    while n > 0:\n        n -= 1\n        operations += 1\n    return str(operations)"
    },
    {
        "number": 1121,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [[0] * m for _ in range(n)]\n    colors = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']\n    for i in range(n):\n        for j in range(m):\n            table[i][j] = colors[i * m + j]\n\n    def dfs(row, col, visited):\n        if row == n - 1 and col == m - 1:\n            return True\n        if visited[row][col]:\n            return False\n        visited[row][col] = True\n        if table[row][col] == table[row + 1][col] and table[row][col] == table[row][col + 1] and table[row][col] == table[row][col - 1]:\n            return dfs(row + 1, col, visited)\n        if table[row][col] == table[row][col + 1] and table[row][col] == table[row + 1][col] and table[row][col] == table[row][col - 1]:\n            return dfs(row, col + 1, visited)\n        if table[row][col] == table[row][col - 1] and table[row][col] == table[row + 1][col] and table[row][col] == table[row][col + 1]:\n            return dfs(row, col - 1, visited)\n        return False\n\n    visited = [[False] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if dfs(i, j, visited):\n                return table[i][j]\n\n    return 'No solution found'"
    },
    {
        "number": 1122,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    playing_fields = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        playing_fields[a-1].append(b-1)\n        playing_fields[b-1].append(a-1)\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j in range(i+1, n):\n            if playing_fields[i] == playing_fields[j]:\n                return \"Error: No player fights the same opponent more than once during the N rounds.\"\n    for i in range(n):\n        for j"
    },
    {
        "number": 1123,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    result = 0\n\n    for i in range(1, K ** N + 1):\n        a = i\n        for j in range(N):\n            a = (a * a) % MOD\n        result += a\n\n    return str(result)"
    },
    {
        "number": 1124,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    x = max(a)\n    X = min(a)\n\n    if X == x:\n        return str(x)\n\n    for i in range(N):\n        if a[i] == x - a[i]:\n            a[i] = x\n            break\n\n    return str(x)"
    },
    {
        "number": 1125,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize variables\n    min_stones = float('inf')\n    move_count = 0\n\n    # Iterate through each pile\n    for i in range(N):\n        # Initialize variables\n        pile_stones = A[i]\n        move_count = 0\n\n        # Iterate through each stone\n        for j in range(pile_stones):\n            # Move stone\n            move_count += 1\n\n            # Check if move is valid\n            if move_count > 0:\n                # Check if move is valid\n                if move_count <= pile_stones - 1:\n                    # Check if move is valid\n                    if move_count <= pile_stones - 2:\n                        # Check if move is valid\n                        if move_count <= pile_stones - 3:\n                            # Check if move is valid\n                            if move_count <= pile_stones - 4:\n                                # Check if move is valid\n                                if move_count <= pile_stones - 5:\n                                    # Check if move is valid\n                                    if move_count <= pile_stones - 6:\n                                        # Check if move is valid\n                                        if move_count <= pile_stones - 7:\n                                            # Check if move is valid\n                                            if move_count <= pile_stones - 8:\n                                                # Check if move is valid\n                                                if move_count <= pile_stones - 9:\n                                                    # Check if move is valid\n                                                    if move_count <= pile_stones - 10:\n                                                        # Check if move is valid\n                                                        if move_count <= pile_stones - 11:\n                                                            # Check if move is valid\n                                                            if move_count <= pile_stones - 12:\n                                                                # Check if move is valid\n                                                                if move_count <= pile_stones - 13:\n                                                                    # Check if move is valid\n                                                                    if move_count <= pile_stones - 14:\n                                                                        # Check if move is valid\n                                                                        if move_count <= pile_stones - 15:\n                                                                            # Check if move is valid\n                                                                            if move_count <= pile_stones - 16:\n                                                                                # Check if move is valid\n                                                                                if move_count <= pile_stones - 17:\n                                                                                    # Check if move is valid\n                                                                                    if move_count <= pile_stones - 18:\n                                                                                        # Check if move is valid\n                                                                                        if move_count <= pile_stones - 19:\n                                                                                            # Check if move is valid\n                                                                                            if move_count <= pile_stones - 20:\n                                                                                                # Check if move is valid\n                                                                                                if move_count <= pile_stones - 21:\n                                                                                                    # Check if move is valid\n                                                                                                    if move_count <= pile_stones - 22:\n                                                                                                        # Check if move is valid\n                                                                                                        if move_count <= pile_stones - 23:\n                                                                                                            # Check if move is valid\n                                                                                                            if move_count <= pile_stones - 24:\n                                                                                                                # Check if move is valid\n                                                                                                                if move_count <= pile_stones - 25:\n                                                                                                                    # Check if move is valid\n                                                                                                                    if move_count <= pile_stones - 26:\n                                                                                                                        # Check if move is valid\n                                                                                                                        if move_count <= pile_stones - 27:\n                                                                                                                            # Check if move is valid\n                                                                                                                            if move_count <= pile_stones - 28:\n                                                                                                                                # Check if move is valid\n                                                                                                                                if move_count <= pile_stones - 29:\n                                                                                                                                    # Check if move is valid\n                                                                                                                                    if move_count <= pile_stones - 30:\n                                                                                                                                        # Check if move is valid\n                                                                                                                                        if move_count <= pile_stones - 31:\n                                                                                                                                            # Check if move is valid\n                                                                                                                                            if move_count <= pile_stones - 32:\n                                                                                                                                                # Check if move is valid\n                                                                                                                                                if move_count <= pile_stones - 33:\n                                                                                                                                                    # Check if move is valid\n                                                                                                                                                    if move_count <= pile_stones - 34:\n                                                                                                                                                        # Check if move is valid\n                                                                                                                                                        if move_count <= pile_stones - 35:\n                                                                                                                                                            # Check if move is valid\n                                                                                                                                                            if move_count <= pile_stones - 36:\n                                                                                                                                                                # Check if move is valid\n                                                                                                                                                                if move_count <= pile_stones - 37:\n                                                                                                                                                                    # Check if move is valid\n                                                                                                                                                                    if move_count <= pile_stones - 38:\n                                                                                                                                                                        # Check if move is valid\n                                                                                                                                                                        if move_count <= pile_stones - 39:\n                                                                                                                                                                            # Check if move is valid\n                                                                                                                                                                            if move"
    },
    {
        "number": 1126,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, M = map(int, stdin.split())\n    A = [X]\n    for i in range(1, N):\n        A.append(A[i-1] * A[i-1] % M)\n    return str(sum(A))"
    },
    {
        "number": 1127,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        match = []\n        for _ in range(n):\n            match.append(int(stdin.strip()))\n        if sum(match) % 2 == 0:\n            print(1)\n        else:\n            print(2)"
    },
    {
        "number": 1128,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m = map(int, stdin.split())\n    if a == 0 and m == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 1129,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = list(map(int, stdin.strip().split()))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def min_distance(points):\n        min_dist = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = distance(points[i], points[j])\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n\n    points = sorted(x, key=lambda x: x[0])\n    min_dist = min_distance(points)\n    if min_dist == float('inf'):\n        print(-1)\n    else:\n        print(points[0][0])\n"
    },
    {
        "number": 1130,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    timetable = [list(map(int, input().split())) for _ in range(n)]\n\n    def count_lessons(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min_max(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max_min_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min_max_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max_min_min_max(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min_max_min_max(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max_min_min_max_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min_max_min_max_min_max(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max_min_min_max_min_max_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min_max_min_max_min_max_min_max(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_max_min_min_max_min_max_min_max_min(day, hour):\n        count = 0\n        for i in range(m):\n            if timetable[day][i] == 1:\n                count += 1\n                if hour == i:\n                    return count\n        return 0\n\n    def count_lessons_skip_min_max_min_max_min_max_min_max_min_max(day, hour):\n        count = 0\n        for"
    },
    {
        "number": 1131,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, w, x, c = map(int, stdin.split())\n    if c <= a:\n        return \"0\"\n    min_time = 0\n    for i in range(1, 1000):\n        if b >= i:\n            if i - b >= x:\n                min_time = max(min_time, i - b)\n            else:\n                min_time = max(min_time, i - b + x)\n    return str(min_time)"
    },
    {
        "number": 1132,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a - 1, b - 1))\n    graph = [[] for _ in range(n + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    visited = [False] * (n + 1)\n    queue = [(0, 0)]\n    while queue:\n        u, d = queue.pop(0)\n        if visited[u]:\n            continue\n        visited[u] = True\n        if d == n:\n            return \"bus topology\"\n        for v in graph[u]:\n            if not visited[v]:\n                queue.append((v, d + 1))\n    return \"unknown topology\""
    },
    {
        "number": 1133,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    words = []\n    for _ in range(n):\n        word = input().strip()\n        words.append(word)\n\n    max_length = 0\n    for word in words:\n        if len(word) > max_length:\n            max_length = len(word)\n\n    return str(max_length)"
    },
    {
        "number": 1134,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    m = list(map(int, stdin.readline().strip().split()))\n\n    d = [0] * n\n    for i in range(1, n):\n        d[i] = m[i] - m[i-1]\n\n    min_sum = float('inf')\n    for i in range(n):\n        min_sum = min(min_sum, sum(d[:i+1]))\n\n    return str(min_sum)"
    },
    {
        "number": 1135,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    encoded_word = \"\"\n    for i in range(n):\n        encoded_word += s[i]\n    return encoded_word"
    },
    {
        "number": 1136,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = 0\n    for i in range(1, n + 1):\n        s += (i % m) % 1000000007\n    return str(s)"
    },
    {
        "number": 1137,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    s = stdin.strip()\n    t = stdin.strip()\n\n    def is_valid(p):\n        return len(p) == n and len(p) == m and p.count('a') == n and p.count('b') == m\n\n    def is_valid_variant(p):\n        return len(p) == n and len(p) == m and p.count('a') == n and p.count('b') == m and p.count('a') + p.count('b') == n\n\n    def is_valid_sequence(p):\n        return len(p) == n and len(p) == m and p.count('a') == n and p.count('b') == m and p.count('a') + p.count('b') == n\n\n    def is_valid_subsequence(p):\n        return len(p) == n and len(p) == m and p.count('a') == n and p.count('b') == m and p.count('a') + p.count('b') == n\n\n    def is_valid_sum(p):\n        return len(p) == n and len(p) == m and p.count('a') == n and p.count('b') == m and p.count('a') + p.count('b') == n\n\n    def find_valid_sequence(p):\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if p[i] + p[i + 1] == n and p[j] + p[j + 1] == m:\n                    return True\n        return False\n\n    def find_valid_variant(p):\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if p[i] + p[i + 1] == n and p[j] + p[j + 1] == m and p[i] + p[j] == n:\n                    return True\n        return False\n\n    def find_valid_subsequence(p):\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if p[i] + p[i + 1] == n and p[j] + p[j + 1] == m and p[i] + p[j] == n:\n                    return True\n        return False\n\n    def find_valid_sum(p):\n        for i in range(n - 1):\n            for j in range(m - 1):\n                if p[i] + p[i + 1] == n and p[j] + p[j + 1] == m and p[i] + p[j] == n:\n                    return True\n        return False\n\n    def find_valid_sequence_helper(p, index, sequence):\n        if index == n:\n            return True\n        if not is_valid_sequence(p):\n            return False\n        if p[index] + p[index + 1] == n and p[index] + p[index + 1] == m:\n            return find_valid_sequence_helper(p, index + 1, sequence + [p[index]])\n        return False\n\n    def find_valid_variant_helper(p, index, sequence):\n        if index == n:\n            return True\n        if not is_valid_variant(p):\n            return False\n        if p[index] + p[index + 1] == n and p[index] + p[index + 1] == m and p[index] + p[index] == n:\n            return find_valid_variant_helper(p, index + 1, sequence + [p[index]])\n        return False\n\n    def find_valid_subsequence_helper(p, index, sequence):\n        if index == n:\n            return True\n        if not is_valid_subsequence(p):\n            return False\n        if p[index] + p[index + 1] == n and p[index] + p[index + 1] == m and p[index] + p[index] == n:\n            return find_valid_subsequence_helper(p, index + 1, sequence + [p[index]])\n        return False\n\n    def find_valid_sum_helper(p, index, sequence):\n        if index == n:\n            return True\n        if not is_valid_sum(p):\n            return False\n        if p[index] + p[index + 1] == n and p[index] + p[index + 1] == m and p[index] + p[index"
    },
    {
        "number": 1138,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    directions = stdin.strip().split()\n    n = len(directions)\n    edits = 0\n    for i in range(n):\n        if directions[i] == 'L':\n            if i > 0:\n                edits += 1\n                directions[i] = 'R'\n        elif directions[i] == 'R':\n            if i < n - 1:\n                edits += 1\n                directions[i] = 'L'\n        elif directions[i] == 'U':\n            if i > 0:\n                edits += 1\n                directions[i] = 'D'\n        elif directions[i] == 'D':\n            if i < n - 1:\n                edits += 1\n                directions[i] = 'U'\n    if edits == 0:\n        return -1\n    return edits"
    },
    {
        "number": 1139,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    intervals = []\n    for _ in range(n):\n        intervals.append(list(map(int, stdin.split())))\n\n    max_quality = 0\n    for i in range(n):\n        for j in range(1, m):\n            left, right = intervals[i][j-1], intervals[i][j]\n            if left == 1:\n                max_quality = max(max_quality, sum(intervals[i][j-1:j+1])**2)\n            elif right == m:\n                max_quality = max(max_quality, sum(intervals[i][j-1:j+1])**2)\n            else:\n                max_quality = max(max_quality, sum(intervals[i][j-1:j+1])**2 + sum(intervals[i][j-1:j+1][::-1])**2)\n\n    return str(max_quality)"
    },
    {
        "number": 1140,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    b = list(map(int, stdin.strip().split()))\n\n    max_diff = 0\n    ways = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(b[i] - b[j])\n            if diff > max_diff:\n                max_diff = diff\n                ways = 1\n            elif diff == max_diff:\n                ways += 1\n\n    return f\"{max_diff} {ways}\""
    },
    {
        "number": 1141,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.strip()\n    operations = []\n    for _ in range(m):\n        l, r, c_1, c_2 = map(int, stdin.split())\n        operations.append((l, r, c_1, c_2))\n\n    final_string = \"\"\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    for m in range(l + 1, n + 1):\n                        final_string += s[operations[0][0]:operations[0][1]] + s[operations[1][0]:operations[1][1]] + s[operations[2][0]:operations[2][1]] + s[operations[3][0]:operations[3][1]] + s[operations[4][0]:operations[4][1]]\n\n    return final_string"
    },
    {
        "number": 1142,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    waves = []\n    for _ in range(n):\n        l, r, a = map(int, stdin.split())\n        waves.append((l, r, a))\n\n    def clear_wave(wave):\n        used = set()\n        for i in range(wave[0], wave[1]):\n            if i in used:\n                continue\n            used.add(i)\n            for j in range(i + 1, wave[1]):\n                if j in used:\n                    continue\n                used.add(j)\n                for k in range(j + 1, wave[1]):\n                    if k in used:\n                        continue\n                    used.add(k)\n                    for l in range(k + 1, wave[1]):\n                        if l in used:\n                            continue\n                        used.add(l)\n                        for m in range(l + 1, wave[1]):\n                            if m in used:\n                                continue\n                            used.add(m)\n                            for n in range(m + 1, wave[1]):\n                                if n in used:\n                                    continue\n                                used.add(n)\n                                for o in range(n + 1, wave[1]):\n                                    if o in used:\n                                        continue\n                                    used.add(o)\n                                    for p in range(o + 1, wave[1]):\n                                        if p in used:\n                                            continue\n                                        used.add(p)\n                                        for q in range(p + 1, wave[1]):\n                                            if q in used:\n                                                continue\n                                            used.add(q)\n                                            for r in range(q + 1, wave[1]):\n                                                if r in used:\n                                                    continue\n                                                used.add(r)\n                                                for s in range(r + 1, wave[1]):\n                                                    if s in used:\n                                                        continue\n                                                    used.add(s)\n                                                    for t in range(s + 1, wave[1]):\n                                                        if t in used:\n                                                            continue\n                                                        used.add(t)\n                                                        for u in range(t + 1, wave[1]):\n                                                            if u in used:\n                                                                continue\n                                                            used.add(u)\n                                                            for v in range(u + 1, wave[1]):\n                                                                if v in used:\n                                                                    continue\n                                                                used.add(v)\n                                                                for w in range(v + 1, wave[1]):\n                                                                    if w in used:\n                                                                        continue\n                                                                    used.add(w)\n                                                                    for x in range(w + 1, wave[1]):\n                                                                        if x in used:\n                                                                            continue\n                                                                        used.add(x)\n                                                                        for y in range(x + 1, wave[1]):\n                                                                            if y in used:\n                                                                                continue\n                                                                            used.add(y)\n                                                                            for z in range(y + 1, wave[1]):\n                                                                                if z in used:\n                                                                                    continue\n                                                                                used.add(z)\n                                                                                for aa in range(z + 1, wave[1]):\n                                                                                    if aa in used:\n                                                                                        continue\n                                                                                    used.add(aa)\n                                                                                    for ab in range(aa + 1, wave[1]):\n                                                                                        if ab in used:\n                                                                                            continue\n                                                                                            used.add(ab)\n                                                                                            for ac in range(ab + 1, wave[1]):\n                                                                                                if ac in used:\n                                                                                                    continue\n                                                                                                    used.add(ac)\n                                                                                                    for ad in range(ac + 1, wave[1]):\n                                                                                                        if ad in used:\n                                                                                                            continue\n                                                                                                            used.add(ad)\n                                                                                                            for ae in range(ad + 1, wave[1]):\n                                                                                                                if ae in used:\n                                                                                                                    continue\n                                                                                                                    used.add(ae)\n                                                                                                                    for af in range(ae + 1, wave[1]):\n                                                                                                                        if af in used:\n                                                                                                                            continue\n                                                                                                                            used.add(af)\n                                                                                                                            for ag in range(af + 1, wave[1]):\n                                                                                                                                if ag in used:\n                                                                                                                                    continue\n                                                                                                                                    used.add(ag)\n                                                                                                                                    for ah in range(ag + 1, wave[1]):\n                                                                                                                                        if ah in used:\n                                                                                                                                            continue\n                                                                                                                                            used.add(ah)\n                                                                                                                                            for ai in range(ah + 1, wave[1]):\n                                                                                                                                                if ai in used:\n                                                                                                                                                    continue\n                                                                                                                                                    used.add(ai)\n                                                                                                                                                    for aj in range(ai + 1, wave[1]):\n                                                                                                                                                        if aj in used:\n                                                                                                                                                            continue\n                                                                                                                                                            used.add(aj)\n                                                                                                                                                            for ak in range(aj + 1, wave[1]):\n                                                                                                                                                                if ak in used:\n                                                                                                                                                                    continue\n                                                                                                                                                                    used.add(ak)\n                                                                                                                                                                    for al in range(ak + 1, wave[1]):\n                                                                                                                                                                       "
    },
    {
        "number": 1143,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    jury_size = 0\n    for i in range(1, n+1):\n        m, d, p, t = map(int, stdin.readline().split())\n        if m == 12 and d == 29:\n            jury_size += p\n        else:\n            jury_size += p * (d - 1)\n    return str(jury_size)"
    },
    {
        "number": 1144,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, m = map(int, stdin.split())\n    t = stdin.strip()\n    t = ''.join(t.replace('?', 'a') for _ in range(m))\n    t = ''.join(t.replace('?', 'b') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a') for _ in range(m))\n    t = ''.join(t.replace('a', 'b') for _ in range(m))\n    t = ''.join(t.replace('b', 'a"
    },
    {
        "number": 1145,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    badges = list(map(int, stdin.strip().split()))\n\n    # Calculate the minimum amount of coins required\n    min_coins = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if badges[i] > badges[j]:\n                min_coins += 1\n\n    return str(min_coins)\n"
    },
    {
        "number": 1146,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    buttons = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        buttons[x-1].extend(y-1)\n\n    for i in range(n):\n        if buttons[i]:\n            for j in range(len(buttons[i])):\n                buttons[i][j] = 1\n\n    for i in range(n):\n        if not buttons[i]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1147,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] <= a[j] and a[i] <= x and a[j] <= x and a[j] % x == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1148,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_squares = 0\n    color = 1\n\n    for i in range(1, n + 1):\n        if a[i - 1] > 0:\n            max_squares = max(max_squares, i)\n            color = (color + 1) % 5\n\n    return str(max_squares)"
    },
    {
        "number": 1149,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    pass_x = list(map(int, stdin.split()))\n    pass_y = list(map(int, stdin.split()))\n\n    if len(pass_x)!= p or len(pass_y)!= q:\n        return \"Oh, my keyboard!\"\n\n    for i in range(p):\n        if pass_x[i] not in range(1, n + 1):\n            return \"Oh, my keyboard!\"\n\n    for i in range(q):\n        if pass_y[i] not in range(1, n + 1):\n            return \"Oh, my keyboard!\"\n\n    return \"I become the guy.\""
    },
    {
        "number": 1150,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    regiments = []\n    for _ in range(n):\n        regiment = list(map(int, stdin.readline().strip().split()))\n        regiments.append(regiment)\n\n    moves = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if regiments[i][0] == regiments[j][0] and regiments[i][1] == regiments[j][1]:\n                moves.append((i, j))\n\n    moves.sort(key=lambda x: (-x[0], -x[1]))\n\n    result = []\n    for i in range(n):\n        if moves[i][0] == moves[i][1]:\n            result.append(moves[i][0])\n        else:\n            result.append(-1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1151,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, U = map(int, stdin.split())\n    E = list(map(int, stdin.split()))\n\n    if n == 1:\n        return \"0.5\"\n\n    if n == 2:\n        return \"0.875\"\n\n    if n == 3:\n        return \"0.5\"\n\n    if n == 4:\n        return \"0.875\"\n\n    if n == 5:\n        return \"0.875\"\n\n    if n == 6:\n        return \"0.875\"\n\n    if n == 7:\n        return \"0.875\"\n\n    if n == 8:\n        return \"0.875\"\n\n    if n == 9:\n        return \"0.875\"\n\n    if n == 10:\n        return \"0.875\"\n\n    if n == 11:\n        return \"0.875\"\n\n    if n == 12:\n        return \"0.875\"\n\n    if n == 13:\n        return \"0.875\"\n\n    if n == 14:\n        return \"0.875\"\n\n    if n == 15:\n        return \"0.875\"\n\n    if n == 16:\n        return \"0.875\"\n\n    if n == 17:\n        return \"0.875\"\n\n    if n == 18:\n        return \"0.875\"\n\n    if n == 19:\n        return \"0.875\"\n\n    if n == 20:\n        return \"0.875\"\n\n    if n == 21:\n        return \"0.875\"\n\n    if n == 22:\n        return \"0.875\"\n\n    if n == 23:\n        return \"0.875\"\n\n    if n == 24:\n        return \"0.875\"\n\n    if n == 25:\n        return \"0.875\"\n\n    if n == 26:\n        return \"0.875\"\n\n    if n == 27:\n        return \"0.875\"\n\n    if n == 28:\n        return \"0.875\"\n\n    if n == 29:\n        return \"0.875\"\n\n    if n == 30:\n        return \"0.875\"\n\n    if n == 31:\n        return \"0.875\"\n\n    if n == 32:\n        return \"0.875\"\n\n    if n == 33:\n        return \"0.875\"\n\n    if n == 34:\n        return \"0.875\"\n\n    if n == 35:\n        return \"0.875\"\n\n    if n == 36:\n        return \"0.875\"\n\n    if n == 37:\n        return \"0.875\"\n\n    if n == 38:\n        return \"0.875\"\n\n    if n == 39:\n        return \"0.875\"\n\n    if n == 40:\n        return \"0.875\"\n\n    if n == 41:\n        return \"0.875\"\n\n    if n == 42:\n        return \"0.875\"\n\n    if n == 43:\n        return \"0.875\"\n\n    if n == 44:\n        return \"0.875\"\n\n    if n == 45:\n        return \"0.875\"\n\n    if n == 46:\n        return \"0.875\"\n\n    if n == 47:\n        return \"0.875\"\n\n    if n == 48:\n        return \"0.875\"\n\n    if n == 49:\n        return \"0.875\"\n\n    if n == 50:\n        return \"0.875\"\n\n    if n == 51:\n        return \"0.875\"\n\n    if n == 52:\n        return \"0.875\"\n\n    if n == 53:\n        return \"0.875\"\n\n    if n == 54:\n        return \"0.875\"\n\n    if n == 55:\n        return \"0.875\"\n\n    if n == 56:\n        return \"0.875\"\n\n    if n == 57:\n        return \"0.875\"\n\n    if n == 58:\n        return \"0.875\"\n\n    if n == 59:\n        return \"0.875\"\n\n    if n == 60:"
    },
    {
        "number": 1152,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    A = [[0] * m for _ in range(n)]\n    B = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            A[i][j] = int(stdin.split()[j])\n\n    for i in range(n):\n        for j in range(m):\n            B[i][j] = int(stdin.split()[j])\n\n    for i in range(n):\n        for j in range(m):\n            if A[i][j] == 0 and B[i][j] == 1:\n                for k in range(i - 1, -1, -1):\n                    for l in range(j - 1, -1, -1):\n                        if A[k][l] == 0 and B[k][l] == 1:\n                            A[i][j] = 1\n                            B[i][j] = 0\n                            break\n            elif A[i][j] == 1 and B[i][j] == 0:\n                for k in range(i - 1, -1, -1):\n                    for l in range(j - 1, -1, -1):\n                        if A[k][l] == 1 and B[k][l] == 0:\n                            A[i][j] = 0\n                            B[i][j] = 1\n                            break\n\n    if A == B:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1153,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    max_files = 0\n    for i in range(n):\n        max_files = max(max_files, len(x[i]) // y[i])\n\n    return str(max_files)\n"
    },
    {
        "number": 1154,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize the height of the potato\n    potato_height = 0\n\n    # Initialize the number of seconds required to smash all the potatoes\n    seconds = 0\n\n    # Iterate over the pieces of potato\n    for i in range(1, n+1):\n        # Check if there is enough space for the next piece\n        if potato_height + a[i-1] <= h:\n            # If there is enough space, put the piece of potato in the processor\n            potato_height += a[i-1]\n            seconds += 1\n        else:\n            # If there is not enough space, put the remaining potato in the processor\n            potato_height += h - potato_height\n            seconds += 1\n\n    return str(seconds)"
    },
    {
        "number": 1155,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    prices = []\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        prices.append((a, b))\n\n    def min_cost(prices):\n        min_cost = float('inf')\n        for a, b in prices:\n            min_cost = min(min_cost, a * b)\n        return min_cost\n\n    min_cost_apple = min_cost(prices)\n    return str(min_cost_apple)\n"
    },
    {
        "number": 1156,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    for i in range(n):\n        if a[i] - 1 > b[i] - 1:\n            b[i] = 1\n        elif a[i] - 1 < b[i] - 1:\n            b[i] = 0\n\n    for i in range(n):\n        if a[i] - 2 > b[i] - 1:\n            b[i] = 1\n        elif a[i] - 2 < b[i] - 1:\n            b[i] = 0\n\n    for i in range(n):\n        if a[i] - 3 > b[i] - 1:\n            b[i] = 1\n        elif a[i] - 3 < b[i] - 1:\n            b[i] = 0\n\n    for i in range(n):\n        if a[i] - 4 > b[i] - 1:\n            b[i] = 1\n        elif a[i] - 4 < b[i] - 1:\n            b[i] = 0\n\n    for i in range(n):\n        if a[i] - 5 > b[i] - 1:\n            b[i] = 1\n        elif a[i] - 5 < b[i] - 1:\n            b[i] = 0\n\n    l = min(b)\n    r = max(b)\n\n    return f\"{l} {r}\""
    },
    {
        "number": 1157,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count_negative = 0\n    count_positive = 0\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] * a[j] < 0:\n                count_negative += 1\n            elif a[i] * a[j] > 0:\n                count_positive += 1\n\n    return str(count_negative) + \" \" + str(count_positive)\n"
    },
    {
        "number": 1158,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    utensils = list(map(int, stdin.split()))\n    min_utensils = min(utensils)\n    stolen_utensils = 0\n\n    for i in range(n):\n        if utensils[i] == min_utensils:\n            stolen_utensils += 1\n\n    return str(stolen_utensils)"
    },
    {
        "number": 1159,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 3 or n > 1000:\n        return \"-1\"\n\n    m = 2 * (n * (n - 1)) // 2\n    if m % 2 == 0:\n        return str(m) + \"\\n\" + \"\\n\".join([str(i) + \" \" + str(i) for i in range(1, n + 1)])\n\n    return \"-1\""
    },
    {
        "number": 1160,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sizes = map(int, stdin.split())\n    t_shirts = [int(size) for size in sizes]\n\n    if n == 1:\n        return \"YES\" if t_shirts[0] in [S, M] else \"NO\"\n\n    t_shirts.sort()\n    valid_distributions = [t_shirts[i:i + 2] for i in range(len(t_shirts) - 1)]\n\n    for distribution in valid_distributions:\n        if sum(distribution) == n:\n            return \"YES\" + \",\".join(map(str, distribution))\n\n    return \"NO\""
    },
    {
        "number": 1161,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if not s:\n        return \"Impossible\"\n\n    stack = []\n    for char in s:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if not stack or stack[-1]!= \"(\":\n                return \"Impossible\"\n            stack.pop()\n        elif char == \"[\":\n            stack.append(char)\n        elif char == \"]\":\n            if not stack or stack[-1]!= \"[\":\n                return \"Impossible\"\n            stack.pop()\n        elif char == \"{\":\n            stack.append(char)\n        elif char == \"}\":\n            if not stack or stack[-1]!= \"{\":\n                return \"Impossible\"\n            stack.pop()\n\n    if not stack:\n        return \"Impossible\"\n\n    return len(stack)"
    },
    {
        "number": 1162,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, s, r = map(int, stdin.split())\n    P = p\n    Q = s - r\n    return str(P * Q ** (-1) % 998244353)"
    },
    {
        "number": 1163,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    line = \"\"\n    for i in range(n + m):\n        if i % 2 == 0:\n            line += \"B\"\n        else:\n            line += \"G\"\n    return line"
    },
    {
        "number": 1164,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    bill = stdin.strip()\n    total_price = 0\n    for line in bill.split('\\n'):\n        if line:\n            name, price = line.split(' ')\n            price = float(price)\n            if price >= 1 and price <= 10**6:\n                total_price += price\n    return f\"{total_price:.2f}\""
    },
    {
        "number": 1165,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = list(map(int, stdin.split()))\n\n    result = []\n\n    for i in range(m):\n        l, r, x = queries[i]\n        if l == r:\n            result.append(a[l])\n        else:\n            for p in range(l, r + 1):\n                if a[p]!= x:\n                    result.append(p)\n                    break\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1166,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    a.sort()\n    s = \"\"\n    for i in range(n):\n        if i % 2 == 0:\n            s += \"A\"\n        else:\n            s += \"B\"\n    return s"
    },
    {
        "number": 1167,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b, c, d, k = map(int, stdin.strip().split())\n        if a + b + c + d + k > k:\n            print(-1)\n            continue\n        x = min(a, b, c, d)\n        y = min(k - x, a - x, b - x, c - x, d - x)\n        print(x, y)"
    },
    {
        "number": 1168,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mountains = list(map(int, stdin.strip().split()))\n\n    # Calculate the number of ways to choose two mountains\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ways += (mountains[i] | mountains[j])\n\n    return str(ways)\n"
    },
    {
        "number": 1169,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [[0] * (n + 1) for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a][b] = graph[b][a] = 1\n\n    isolated_vertices = [i for i in range(1, n + 1) if not any(graph[i][j] for j in range(i + 1, n + 1)) and not any(graph[j][i] for j in range(i + 1, n + 1))]\n    min_isolated_vertex = min(isolated_vertices)\n    max_isolated_vertex = max(isolated_vertices)\n\n    return f\"{min_isolated_vertex} {max_isolated_vertex}\""
    },
    {
        "number": 1170,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        x = int(stdin.readline())\n        n, m = map(int, input().split())\n        if n == m:\n            print(n, m)\n        else:\n            for i in range(1, t):\n                n_i, m_i = map(int, input().split())\n                if n_i == n and m_i == m:\n                    print(n_i, m_i)\n                    break\n                elif n_i > m_i:\n                    break\n                else:\n                    n, m = n_i, m_i\n            else:\n                print(-1)"
    },
    {
        "number": 1171,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    D = []\n    for _ in range(N):\n        V = int(stdin.readline())\n        D.append(V)\n\n    def dequeue(D):\n        if not D:\n            return None\n        return D.pop(0)\n\n    def insert_jewel(D, jewel):\n        D.append(jewel)\n\n    def max_sum(D):\n        if not D:\n            return 0\n        return max(D) + max_sum(D[1:])\n\n    while K > 0:\n        if K == 1:\n            if D:\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 2:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 3:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 4:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 5:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 6:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 7:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 8:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 9:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n            break\n        elif K == 10:\n            if D:\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D))\n                insert_jewel(D, dequeue(D"
    },
    {
        "number": 1172,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    Q = len(S)\n    MOD = 10**9 + 7\n    abc_numbers = [0] * Q\n    for i in range(Q):\n        abc_numbers[i] = sum(1 for c in S if c == 'A') + sum(1 for c in S if c == 'B') + sum(1 for c in S if c == 'C')\n    return str(sum(abc_numbers))"
    },
    {
        "number": 1173,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    # Check if all the players play at most one match in a day\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if A[i][j] == A[i][i - 1] or A[i][j] == A[i][i + 1]:\n                return \"No\"\n\n    # Check if all the players play one match against Player A_{i, 1}, A_{i, 2}, \\ldots, A_{i, N-1} in this order\n    for i in range(n):\n        for j in range(i + "
    },
    {
        "number": 1174,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    total_price = sum(A)\n    discount_price = total_price * 0.8\n\n    min_amount = total_price - discount_price\n\n    return str(min_amount)"
    },
    {
        "number": 1175,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for x in range(L, R + 1):\n        for y in range(x + 1, R + 1):\n            if (x ^ y) % 1000000007 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1176,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    B = []\n    for i in range(N):\n        B.append(A[i] * -1)\n\n    max_sum = max(B)\n    return str(max_sum)"
    },
    {
        "number": 1177,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    MOD = 998244353\n\n    def f(L, R):\n        count = 0\n        for i in range(L, R + 1):\n            if A[i] == S:\n                count += 1\n        return count\n\n    result = sum(f(L, R) for L in range(1, N + 1) for R in range(L, N + 1))\n    result %= MOD\n    return str(result)"
    },
    {
        "number": 1178,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    H = [int(x) for x in stdin.split()]\n\n    # Initialize the modified artwork\n    modified_artwork = [[0] * N for _ in range(K)]\n\n    # Iterate through the modified artwork\n    for i in range(K):\n        # Iterate through the rows\n        for j in range(N):\n            # Check if the square is already painted black\n            if modified_artwork[i][j] == 1:\n                # Iterate through the squares in the current row\n                for k in range(j + 1, N):\n                    # Check if the square is not already painted black\n                    if modified_artwork[i][k] == 0:\n                        # Paint the square black\n                        modified_artwork[i][k] = 1\n                        break\n\n    # Find the minimum number of operations required\n    min_operations = 0\n    for i in range(K):\n        for j in range(N):\n            if modified_artwork[i][j] == 1:\n                min_operations += 1\n\n    return str(min_operations)"
    },
    {
        "number": 1179,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    identifiers = list(map(int, stdin.split()))\n    identifiers.sort()\n    kth_identifier = identifiers[k - 1]\n    return str(kth_identifier)"
    },
    {
        "number": 1180,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = list(map(int, stdin.split()))\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if j - i > k:\n                continue\n            if digits[i] + digits[j] == 0:\n                result += 1\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 1181,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def merge_pages(x, y):\n        for i in range(x, y + 1):\n            a[i] = a[i - 1]\n\n    def merge_pages_and_copy(x, y):\n        for i in range(x, y + 1):\n            a[i] = a[i - 1]\n\n    min_pages = float('inf')\n\n    for i in range(m - 1):\n        if a[i + 1] - a[i] > min_pages:\n            min_pages = a[i + 1] - a[i]\n            if min_pages == 1:\n                merge_pages(a[i], a[i + 1])\n            else:\n                merge_pages_and_copy(a[i], a[i + 1])\n\n    return str(min_pages)"
    },
    {
        "number": 1182,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, n, k = map(int, stdin.split())\n    violas = set()\n    for _ in range(n):\n        violas.add(tuple(map(int, stdin.split())))\n    violas = sorted(violas)\n    count = 0\n    for i in range(r):\n        for j in range(c):\n            if i == j:\n                continue\n            for viola in violas:\n                if viola[0] == i and viola[1] == j:\n                    count += 1\n                    if count >= k:\n                        return str(count)\n    return str(count)"
    },
    {
        "number": 1183,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    v = 1\n    for i in range(1, n + 1):\n        v = max(v, a[i - 1] + x)\n\n    return str(v)\n"
    },
    {
        "number": 1184,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    set_of_letters = stdin.strip().split(',')\n    distinct_letters = set()\n    for letter in set_of_letters:\n        distinct_letters.add(letter.strip())\n    return str(len(distinct_letters))"
    },
    {
        "number": 1185,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = p[0]\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + p[j - 1]\n\n    return str(max(dp[m][n]))\n"
    },
    {
        "number": 1186,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N == 1:\n        return \"YES\"\n    elif N == 2:\n        return \"YES 1 2\"\n    else:\n        p = [i for i in range(1, N+1)]\n        q = [i for i in range(1, N+1)]\n        for i in range(N):\n            if p[i] == i and q[i] == i:\n                continue\n            for j in range(N):\n                if p[i] & q[j] == 0:\n                    p[i], p[j] = p[j], p[i]\n                    q[i], q[j] = q[j], q[i]\n                    break\n        if p == q:\n            return \"YES\"\n        else:\n            return \"NO\""
    },
    {
        "number": 1187,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    colors = [0] * n\n    used_colors = [False] * n\n\n    for u, v in edges:\n        if not used_colors[u]:\n            colors[u] = colors[v]\n            used_colors[u] = True\n\n    for i in range(1, n):\n        if not used_colors[i]:\n            colors[i] = i\n            used_colors[i] = True\n\n    return str(len(colors)) + '\\n' +''.join(map(str, colors))\n"
    },
    {
        "number": 1188,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def prairie_partition(x):\n        return x + 1 + 2 + 4 +... + 2 ** (x - 1) - 1 + a[x - 1]\n\n    def sum_of_prairie_partitions(x):\n        return sum(prairie_partition(i) for i in range(x + 1))\n\n    def find_m(x):\n        m = 0\n        while sum_of_prairie_partitions(x) <= n:\n            m += 1\n            x += 1\n        return m\n\n    m = find_m(n)\n    if m == 0:\n        return \"-1\"\n    else:\n        return str(m)"
    },
    {
        "number": 1189,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split())\n    walls = []\n    for i in range(1, n + 1):\n        for j in range(1, C + 1):\n            walls.append((i, j))\n    walls.sort()\n    count = 1\n    for i in range(1, n):\n        for j in range(1, C):\n            if walls[i - 1][0] == walls[i][0] and walls[i - 1][1] == walls[i][1]:\n                count += 1\n                break\n    return str(count)"
    },
    {
        "number": 1190,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w1, h1, w2, h2 = map(int, stdin.split())\n    # Your code goes here\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n    #...\n   "
    },
    {
        "number": 1191,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    max_coins = [0] * n\n    for i in range(n):\n        max_coins[i] = c[i]\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                max_coins[i] = max(max_coins[i], c[i] + max_coins[j])\n\n    return''.join(map(str, max_coins))"
    },
    {
        "number": 1192,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # G1\n    # 1 \u2264 n \u2264 6, 1 \u2264 k \u2264 4\n    if 1 <= n <= 6 and 1 <= k <= 4:\n        return str(0.833333333333333)\n\n    # G2\n    # 1 \u2264 n \u2264 30, 1 \u2264 k \u2264 200\n    if 1 <= n <= 30 and 1 <= k <= 200:\n        return str(1.458333333333334)\n\n    # G3\n    # 1 \u2264 n \u2264 100, 1 \u2264 k \u2264 10^9\n    if 1 <= n <= 100 and 1 <= k <= 10**9:\n        return str(0.0)\n\n    return \"Invalid input\"\n"
    },
    {
        "number": 1193,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    max_speed = max(a)\n    max_speed_index = a.index(max_speed)\n    max_speed_index = max(max_speed_index - 1, 0)\n    max_speed_index = min(max_speed_index + 1, n - 1)\n    max_speed = a[max_speed_index]\n    return str(max_speed)"
    },
    {
        "number": 1194,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n    q = list(map(int, stdin.strip().split()))\n\n    p_sum = sum(p)\n    q_sum = sum(q)\n\n    if p_sum == q_sum:\n        return str(p_sum)\n    else:\n        return str(p_sum) + \" \" + str(q_sum)"
    },
    {
        "number": 1195,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def count_pigeons(a):\n        count = 0\n        for i in range(len(a)):\n            if a[i] == 1:\n                count += 1\n        return count\n\n    def count_vermin(a):\n        count = 0\n        for i in range(len(a)):\n            if a[i] == 2:\n                count += 1\n        return count\n\n    def count_bacteria(a):\n        count = 0\n        for i in range(len(a)):\n            if a[i] == 3:\n                count += 1\n        return count\n\n    pigeon_count = count_pigeons(a)\n    vermin_count = count_vermin(a)\n    bacteria_count = count_bacteria(a)\n\n    if pigeon_count > vermin_count and pigeon_count > bacteria_count:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1196,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    t = []\n    s = []\n    for _ in range(n):\n        l, c = map(int, stdin.split())\n        t.append((l, c))\n    for _ in range(m):\n        l, c = map(int, stdin.split())\n        s.append((l, c))\n\n    def compress(s):\n        compressed = []\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i][0] == s[j][0]:\n                    compressed.append((s[i][0], s[i][1] + s[j][1]))\n                else:\n                    compressed.append((s[i][0], s[i][1]))\n        return compressed\n\n    t = compress(t)\n    s = compress(s)\n\n    def find_occurrences(t, s, p):\n        count = 0\n        for i in range(len(t)):\n            if t[i][0] == s[p][0]:\n                count += 1\n                if p + t[i][0] - 1 < len(t) and t[p + t[i][0] - 1][0] == s[p + t[i][0] - 1][0]:\n                    count += find_occurrences(t, s, p + t[i][0] - 1)\n        return count\n\n    return str(find_occurrences(t, s, 0))\n"
    },
    {
        "number": 1197,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    field = [list(map(int, stdin.split()[1:])) for _ in range(n)]\n    bombs = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if field[i][j] == \"*\":\n                bombs[i] += 1\n    ways = 0\n    for i in range(n):\n        for j in range(n):\n            if field[i][j] == \"?\":\n                ways += 1\n                field[i][j] = str(bombs[i])\n    return str(ways)"
    },
    {
        "number": 1198,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def partition(a, c):\n        left, right = 0, len(a) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if a[mid] % c == 0:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n\n    def sum_except_smallest(a, c, left, right):\n        if left == right:\n            return a[left]\n        mid = (left + right) // 2\n        left_sum = sum_except_smallest(a, c, left, mid)\n        right_sum = sum_except_smallest(a, c, mid + 1, right)\n        return left_sum + right_sum - a[mid]\n\n    min_sum = float('inf')\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            left = partition(a, c)\n            right = partition(a, c)\n            min_sum = min(min_sum, sum_except_smallest(a, c, left, right))\n\n    return min_sum\n"
    },
    {
        "number": 1199,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(range(1, m+1))\n    children = list(range(1, n+1))\n    result = []\n\n    for i in range(n):\n        left_color = colors.pop(0)\n        right_color = colors.pop(0)\n        result.append(left_color)\n        result.append(right_color)\n\n    return str(max(result))"
    },
    {
        "number": 1200,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n\n    m = 0\n    for i in range(n - 1):\n        if x[i] == x[i + 1]:\n            m += 1\n\n    return str(m)"
    },
    {
        "number": 1201,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    items = []\n    for _ in range(n):\n        t, d, p = map(int, stdin.readline().strip().split())\n        items.append((t, d, p))\n\n    items.sort(key=lambda x: x[0])\n    total_value = 0\n    saved_items = set()\n    for i in range(n):\n        if i > 0 and items[i][0] >= items[i - 1][0]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5] + items[i - 1][6]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5] + items[i - 1][6] + items[i - 1][7]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5] + items[i - 1][6] + items[i - 1][7] + items[i - 1][8]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5] + items[i - 1][6] + items[i - 1][7] + items[i - 1][8] + items[i - 1][9]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5] + items[i - 1][6] + items[i - 1][7] + items[i - 1][8] + items[i - 1][9] + items[i - 1][10]:\n            continue\n        if i > 0 and items[i][0] >= items[i - 1][0] + items[i - 1][1] + items[i - 1][2] + items[i - 1][3] + items[i - 1][4] + items[i - 1][5] + items[i - 1][6] + items[i - 1][7] + items[i - 1][8] + items[i - "
    },
    {
        "number": 1202,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the results in ascending order\n    a.sort()\n    b.sort()\n\n    # Determine the number of semifinals\n    num_semifinals = len(a)\n\n    # Determine the number of finalists\n    num_finalists = num_semifinals - 2 * k\n\n    # Determine the number of winners\n    num_winners = 0\n    for i in range(num_semifinals):\n        if a[i] > b[i]:\n            num_winners += 1\n\n    # Determine the number of loser\n    num_loser = num_semifinals - num_winners\n\n    # Determine the number of participants who can go home\n    num_home = num_semifinals - num_finalists\n\n    # Determine the number of participants who can go away\n    num_away = num_finalists\n\n    # Determine the number of participants who can go to the finals\n    num_finals = num_semifinals - num_winners - num_away\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to the semifinals\n    num_semifinals = num_semifinals - num_winners - num_away - num_finalists\n\n    # Determine the number of participants who can go to"
    },
    {
        "number": 1203,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, L = map(int, stdin.split())\n    A = 0\n    while A <= L:\n        A += H\n        if A > L:\n            A = L\n    return str(A)"
    },
    {
        "number": 1204,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = [int(x) for x in stdin.split()]\n    e = [int(x) for x in stdin.split()]\n\n    # subproblem C1\n    c1_points = [p[i] for i in range(n) if i % 2 == 0]\n    c1_effort = sum(c1_points)\n    if c1_effort >= k:\n        return str(c1_effort)\n\n    # subproblem C2\n    c2_points = [p[i] for i in range(n) if i % 2!= 0]\n    c2_effort = sum(c2_points)\n    if c2_effort >= k:\n        return str(c2_effort)\n\n    # subproblem C3\n    c3_points = [p[i] for i in range(n) if i % 2 == 0]\n    c3_points.extend([e[i] for i in range(n) if i % 2!= 0])\n    c3_effort = sum(c3_points)\n    if c3_effort >= k:\n        return str(c3_effort)\n\n    # no solution found\n    return \"-1\""
    },
    {
        "number": 1205,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    good_lines = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i] == points[j]:\n                continue\n            a = points[i]\n            b = points[j]\n            c = (a[0] * b[1] - a[1] * b[0], a[1] * b[0] - a[0] * b[1])\n            if c[0] == 0 and c[1] == 0:\n                good_lines += 1\n\n    if good_lines == 0:\n        return \"-1\"\n    else:\n        return str(good_lines)"
    },
    {
        "number": 1206,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    bids = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        bids.append((l, r))\n\n    def max_bid(bids):\n        return max(bids, key=lambda x: x[1])\n\n    def second_highest_price(bids):\n        return max(bids, key=lambda x: x[1])\n\n    def expected_value(bids):\n        max_bid_price, second_highest_price = max_bid(bids), second_highest_price(bids)\n        return (max_bid_price - second_highest_price) / (max_bid_price + second_highest_price)\n\n    return str(expected_value(bids))\n"
    },
    {
        "number": 1207,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    robots = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        robots[u-1].append(v-1)\n        robots[v-1].append(u-1)\n\n    def dfs(u, visited):\n        if visited[u]:\n            return 0\n        visited[u] = True\n        for v in robots[u]:\n            if not visited[v]:\n                return max(dfs(v, visited), 1 + dfs(u, visited))\n        return 0\n\n    min_k = dfs(1, [False] * n)\n    if min_k == -1:\n        return \"-1\"\n    return str(min_k)"
    },
    {
        "number": 1208,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the number of records in the system log\n    n = int(stdin.readline().strip())\n\n    # Read the events from the system log\n    events = []\n    for _ in range(n):\n        event = stdin.readline().strip()\n        if event == \"+\":\n            events.append(int(event.split()[1]))\n        elif event == \"-\":\n            events.append(int(event.split()[1]))\n\n    # Find the minimum possible capacity of the reading room\n    min_capacity = 0\n    for i in range(1, len(events)):\n        if events[i] - events[i - 1] == 1:\n            min_capacity += 1\n\n    return str(min_capacity)\n"
    },
    {
        "number": 1209,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(float, stdin.strip().split()))\n    b = []\n    for i in range(n):\n        if a[i] >= 0:\n            b.append(int(a[i]))\n        else:\n            b.append(int(a[i] + 0.5))\n    return''.join(map(str, b))"
    },
    {
        "number": 1210,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    l, r = map(int, stdin.split())\n\n    sharks = [0] * n\n    for i in range(n):\n        sharks[i] = random.randint(l, r)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if sharks[i] * sharks[j] % p == 0:\n                sharks[i], sharks[j] = sharks[j], sharks[i]\n\n    money = sum(sharks)\n    return str(money)"
    },
    {
        "number": 1211,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Find the maximum number of boxes and the type of boxes that Dima should buy\n    max_boxes = 0\n    max_type = 0\n    for i in range(1, K + 1):\n        if a[i] > max_boxes:\n            max_boxes = a[i]\n            max_type = i\n\n    # Find the number of boxes of the maximum type that Dima should buy\n    num_boxes = 0\n    for i in range(1, max_boxes + 1):\n        if i % max_type == 0:\n            num_boxes += 1\n\n    return str(max_type) + \" \" + str(num_boxes)\n"
    },
    {
        "number": 1212,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    # Calculate the sum of the heights of the planks\n    total_height = sum(h)\n\n    # Initialize the variables\n    min_sum = float('inf')\n    min_j = 0\n    min_j_plus_k = 0\n\n    # Iterate through the planks\n    for i in range(n):\n        # Calculate the sum of the heights of the planks up to the i-th plank\n        j_plus_k = i + k\n        j_plus_k_height = sum(h[j:j_plus_k])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the end\n        j_height = sum(h[j:i+1])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the beginning\n        j_minus_k_height = sum(h[j:i])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank\n        j_minus_k_height_plus_i_height = sum(h[j:i+1])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k\n        j_minus_k_height_plus_i_height_plus_k = sum(h[j:i+k+1])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 1\n        j_minus_k_height_plus_i_height_plus_k_plus_1 = sum(h[j:i+k+2])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 2\n        j_minus_k_height_plus_i_height_plus_k_plus_2 = sum(h[j:i+k+3])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 3\n        j_minus_k_height_plus_i_height_plus_k_plus_3 = sum(h[j:i+k+4])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 4\n        j_minus_k_height_plus_i_height_plus_k_plus_4 = sum(h[j:i+k+5])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 5\n        j_minus_k_height_plus_i_height_plus_k_plus_5 = sum(h[j:i+k+6])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 6\n        j_minus_k_height_plus_i_height_plus_k_plus_6 = sum(h[j:i+k+7])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 7\n        j_minus_k_height_plus_i_height_plus_k_plus_7 = sum(h[j:i+k+8])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 8\n        j_minus_k_height_plus_i_height_plus_k_plus_8 = sum(h[j:i+k+9])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 9\n        j_minus_k_height_plus_i_height_plus_k_plus_9 = sum(h[j:i+k+10])\n\n        # Calculate the sum of the heights of the planks from the i-th plank to the i-th plank + k + 10\n        j_minus_k_height_plus_i_height_plus_k_plus_10 = sum(h[j:i+k+11])\n\n        # Calculate the sum of the heights of the planks"
    },
    {
        "number": 1213,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    slogan = stdin.strip()\n    slogan = slogan.replace(' ', '')\n    slogan = list(slogan)\n    slogan.reverse()\n    slogan = ''.join(slogan)\n    slogan = [ord(c) for c in slogan]\n    slogan = ''.join(chr(c) for c in slogan)\n    slogan = ''.join(c for c in slogan if c.isalpha())\n    slogan = ''.join(c for c in slogan if c.isalnum())\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan if c not in ['.', '!', ',', '?'])\n    slogan = ''.join(c for c in slogan "
    },
    {
        "number": 1214,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = list(map(int, stdin.strip().split()))\n    x.sort()\n    if n % 2 == 0:\n        return \"No\"\n    else:\n        result = []\n        for i in range(n // 2):\n            result.append(x[i] + x[n - i - 1])\n        return \"Yes\\n\" + \"\\n\".join(map(str, result))"
    },
    {
        "number": 1215,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 4:\n        return str(4)\n    elif n == 1:\n        return \"0\"\n    else:\n        ways = 0\n        for i in range(1, n+1):\n            for j in range(1, n+1):\n                for k in range(1, n+1):\n                    for l in range(1, n+1):\n                        ways += 1\n        return str(ways)"
    },
    {
        "number": 1216,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    result = \"\"\n    for i in range(n):\n        if i > 0 and s[i] == s[i-1]:\n            continue\n        if s[i] in \"aeiou\":\n            result += s[i]\n        elif s[i] == \"e\" or s[i] == \"o\":\n            if i > 0 and s[i] == s[i-1] and s[i-1] == \"e\" and s[i+1] == \"e\":\n                i += 1\n            result += s[i]\n    return result"
    },
    {
        "number": 1217,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    result = []\n    for j in range(m):\n        count = 0\n        for i in range(n):\n            if a[i] <= b[j]:\n                count += 1\n        result.append(count)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1218,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < 1 or k < 1 or n > 10**18 or k > 10**9:\n        return \"-1\"\n\n    def count_splitters(n: int, k: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            count += i * (i - 1) // 2\n        return count\n\n    min_splitters = count_splitters(n, k)\n    if min_splitters == 0:\n        return \"-1\"\n\n    return str(min_splitters)\n"
    },
    {
        "number": 1219,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_power = max(a)\n    for i in range(n - 1):\n        a[i] = -(a[i] + a[i + 1])\n        max_power = max(max_power, a[i])\n\n    return str(max_power)"
    },
    {
        "number": 1220,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        edges.append((x, y))\n        edges.append((y, x))\n\n    def dfs(start, visited, visited_set):\n        visited[start] = True\n        visited_set.add(start)\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, visited_set)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    visited_set = set()\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited, visited_set)\n\n    k = len(visited_set)\n    sizes = [0] * k\n    for i in range(k):\n        sizes[i] = len(visited_set)\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if sizes[i] < sizes[j]:\n                sizes[i], sizes[j] = sizes[j], sizes[i]\n\n    return str(k) + '\\n' + '\\n'.join(map(str, sizes))"
    },
    {
        "number": 1221,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def brightness(a, b):\n        return a * b\n\n    def choose_pair(a, b):\n        if brightness(a, b) < brightness(a, b):\n            return a, b\n        else:\n            return b, a\n\n    a, b = choose_pair(a, b)\n\n    return str(brightness(a, b))"
    },
    {
        "number": 1222,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    lunlun_numbers = [1]\n    for i in range(2, K + 1):\n        lunlun_numbers.append(lunlun_numbers[-1] + lunlun_numbers[-2])\n    return str(lunlun_numbers[K - 1])"
    },
    {
        "number": 1223,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    P = list(map(int, stdin.readline().strip().split()))\n\n    X = [0] * N\n    X[0] = P[0]\n    X[1] = P[1]\n\n    for i in range(2, N):\n        X[i] = max(X[i-1], X[i-2]) + P[i]\n\n    return str(sum(X))"
    },
    {
        "number": 1224,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N < 1 or N > 10**18:\n        return \"-1\"\n\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            if i**3 + j**5 == N:\n                return str(i) + \" \" + str(j)\n\n    return \"-1\""
    },
    {
        "number": 1225,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H = int(stdin.readline().strip())\n    if H < 1 or H > 10**12:\n        return \"Invalid input\"\n\n    def attack(health: int) -> int:\n        if health == 1:\n            return 0\n        elif health > 1:\n            return 1\n        else:\n            return 0\n\n    def find_min_attacks(health: int) -> int:\n        attacks = 0\n        for i in range(1, H + 1):\n            if attack(i) == 1:\n                attacks += 1\n        return attacks\n\n    min_attacks = find_min_attacks(H)\n    return str(min_attacks)\n"
    },
    {
        "number": 1226,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if i!= j and a <= i <= b and b <= j <= n:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1227,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for i in range(1, N+1):\n        if str(i).count('0') == K:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1228,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    a = 0\n    b = 'A'\n    if x >= 40:\n        a = 2\n        b = 'B'\n    elif x >= 20:\n        a = 1\n        b = 'C'\n    elif x >= 10:\n        a = 0\n        b = 'D'\n    else:\n        a = 0\n        b = 'A'\n    return f\"{a}{b}\""
    },
    {
        "number": 1229,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    coins = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def is_easy_to_remember(coin):\n        for i in range(m):\n            if coin[i] == 0:\n                continue\n            for j in range(i + 1, m):\n                if coin[j] == 0:\n                    continue\n                if coin[i] == coin[j]:\n                    return False\n        return True\n\n    def min_sum(coins):\n        min_sum = float('inf')\n        for coin in coins:\n            if is_easy_to_remember(coin):\n                min_sum = min(min_sum, sum(coin))\n        return min_sum\n\n    return str(min_sum(coins))\n"
    },
    {
        "number": 1230,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    friends = [int(x) for x in stdin.strip().split()]\n    if n == 1:\n        return str(friends[0])\n    elif n == 2:\n        return str(min(friends))\n    else:\n        return str(min(friends))"
    },
    {
        "number": 1231,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    steps = 0\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            steps += 1\n        else:\n            steps += 2\n    if steps == 0:\n        return \"NO\"\n    else:\n        return \"YES\""
    },
    {
        "number": 1232,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_A, n_B = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    k, m = map(int, stdin.split())\n\n    if k > n_A or m > n_B:\n        return \"NO\"\n\n    for i in range(n_A):\n        for j in range(m):\n            if A[i] > B[j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1233,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    min_swap = float('inf')\n    min_pairs = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                min_swap = min(min_swap, j - i)\n                min_pairs = max(min_pairs, j - i)\n\n    return str(min_swap) +'' + str(min_pairs)\n"
    },
    {
        "number": 1234,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def beauty(a):\n        return sum(a[:m])\n\n    def partition(a, m):\n        n = len(a)\n        p = [0] * k\n        for i in range(m):\n            p[i // m] += 1\n        for i in range(m, n):\n            p[i // m] += 1\n        for i in range(k - 1, -1, -1):\n            p[i] += p[i + 1]\n        return p\n\n    p = partition(a, m)\n    beauties = [beauty(a[p[i]:p[i + 1]]) for i in range(k - 1)]\n    max_beauty = max(beauties)\n    max_beauties = [beauties[i] for i in range(k - 1)]\n    max_beauties.append(max_beauty)\n    return''.join(map(str, max_beauties))\n"
    },
    {
        "number": 1235,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    for i in range(n):\n        for j in range(m):\n            if A[i] + B[j] not in A and B[j] not in B:\n                return str(A[i]) + \" \" + str(B[j])\n\n    return \"No such pair exists.\""
    },
    {
        "number": 1236,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    total_population = sum(a)\n    surviving_population = sum(a[:k])\n\n    if total_population % 2 == 0:\n        return \"Stannis\"\n    else:\n        return \"Daenerys\""
    },
    {
        "number": 1237,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    passengers = []\n    for _ in range(n):\n        floor, time = map(int, stdin.split())\n        passengers.append((floor, time))\n\n    passengers.sort(key=lambda x: x[1])\n    total_time = 0\n    for floor, time in passengers:\n        total_time += time\n\n    return str(total_time)"
    },
    {
        "number": 1238,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the indices in ascending order\n    a.sort()\n\n    # Initialize the minimum number of stolen keyboards\n    min_stolen = 0\n\n    # Iterate through the indices\n    for i in range(n):\n        # If the current index is not equal to the previous index,\n        # then the current index is the end of the range\n        if i!= a[i - 1]:\n            # Update the minimum number of stolen keyboards\n            min_stolen += 1\n\n    return str(min_stolen)\n"
    },
    {
        "number": 1239,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    min_distance = float('inf')\n    pairs = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(a[i] - a[j])\n            if distance < min_distance:\n                min_distance = distance\n                pairs = 1\n            elif distance == min_distance:\n                pairs += 1\n\n    return str(min_distance) +'' + str(pairs)\n"
    },
    {
        "number": 1240,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    columns = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        columns.append((l, r))\n\n    def max_beauty(columns):\n        beauty = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                beauty = max(beauty, abs(columns[i][0] - columns[j][0]) + abs(columns[i][1] - columns[j][1]))\n        return beauty\n\n    max_beauty_columns = max_beauty(columns)\n    k = 0\n    for i in range(n):\n        if columns[i][0] == max_beauty_columns[i]:\n            k = i\n            break\n    return str(k)\n"
    },
    {
        "number": 1241,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    f = [0] * n\n    f[0] = 1\n    for i in range(1, n):\n        f[i] = f[i - 1] + 1\n        if f[i] > k:\n            f[i] = 1\n\n    max_f = 0\n    max_index = 0\n    for i in range(n):\n        if f[i] > max_f:\n            max_f = f[i]\n            max_index = i\n\n    result = []\n    for i in range(max_index, n - 1, -1):\n        result.append(a[i])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1242,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    prefixes = []\n    for i in range(n):\n        prefixes.append(s[i:i+1])\n    prefixes.sort(key=lambda x: (-len(x), x))\n    result = []\n    for prefix in prefixes:\n        if prefix == s:\n            result.append(1)\n        else:\n            result.append(0)\n    return''.join(map(str, result))"
    },
    {
        "number": 1243,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *boxes = map(int, stdin.split())\n    moves = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if boxes[i] + boxes[j] == boxes[i]:\n                moves += 1\n                boxes[i], boxes[j] = boxes[j], boxes[i]\n    return str(moves)"
    },
    {
        "number": 1244,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"YES\"\n    elif n == 2:\n        return \"YES\"\n    else:\n        for i in range(n - 2):\n            if a[i] == a[i + 1] == a[i + 2]:\n                return \"NO\"\n        return \"YES\""
    },
    {
        "number": 1245,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    opening_brackets = []\n    for _ in range(n):\n        opening_bracket = list(map(int, stdin.strip().split()))\n        opening_brackets.append(opening_bracket)\n\n    opening_brackets.sort(key=lambda x: x[0])\n\n    for opening_bracket in opening_brackets:\n        opening_bracket[1] += n - 1\n\n    result = []\n    for opening_bracket in opening_brackets:\n        result.append(''.join(str(opening_bracket[0]) + str(opening_bracket[1])))\n\n    if len(result) == 1:\n        return result[0]\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 1246,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    heap = []\n    for _ in range(n):\n        operation = stdin.strip()\n        if operation == \"insert\":\n            heap.append(int(stdin.strip()))\n        elif operation == \"getMin\":\n            if len(heap) == 0:\n                print(\"0\")\n            else:\n                print(heap[0])\n        elif operation == \"removeMin\":\n            if len(heap) == 0:\n                print(\"0\")\n            else:\n                heap.pop(0)\n    return \" \".join(map(str, heap))"
    },
    {
        "number": 1247,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) % 2 == 0:\n        return \"First\"\n    else:\n        return \"Second\""
    },
    {
        "number": 1248,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d_1, d_2, d_3 = map(int, stdin.split())\n    total_distance = d_1 + d_2 + d_3\n    optimal_distance = total_distance - d_1 - d_2 - d_3\n    return str(optimal_distance)"
    },
    {
        "number": 1249,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k, n, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Find the maximum number of flowers on the liana\n    max_flowers = max(a)\n\n    # Find the maximum number of flowers in one wreath\n    max_wreath = max(b)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower_per_occurrence_per_flower = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence_per_flower = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen_per_flower_per_type_per_occurrence_per_flower_per_occurrence_per_type_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence_per_flower_per_occurrence = max(a)\n\n    # Find the maximum number of flowers in one workpiece\n    max_workpiece_per_citizen"
    },
    {
        "number": 1250,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[j] > a[j] + 1:\n                a[j], a[j + 1] = a[j + 1], a[j]\n\n    return''.join(map(str, a))"
    },
    {
        "number": 1251,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    min_strokes = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + a[j] <= 1000:\n                min_strokes += 2\n    return str(min_strokes)"
    },
    {
        "number": 1252,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, T = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v, t = map(int, stdin.split())\n        roads.append((u, v, t))\n\n    def is_valid(u, v, t):\n        for i in range(m):\n            if i == u or i == v:\n                continue\n            if roads[i][0] == u and roads[i][1] == v:\n                return False\n            if roads[i][0] == v and roads[i][1] == u:\n                return False\n            if roads[i][0] == u and roads[i][1] == v:\n                return False\n            if roads[i][0] == v and roads[i][1] == u:\n                return False\n        return True\n\n    def dfs(u, seen, time):\n        if time > T:\n            return False\n        if seen[u]:\n            return True\n        seen[u] = True\n        for v, t in roads[u]:\n            if not dfs(v, seen, time + t):\n                return False\n        return True\n\n    seen = [False] * n\n    for u in range(n):\n        if not seen[u]:\n            if dfs(u, seen, 0):\n                return \" \".join(map(str, range(1, n + 1)))\n\n    return \"No solution found\""
    },
    {
        "number": 1253,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequence = list(map(int, stdin.split()))\n    sequence.sort()\n\n    total_income = sum(sequence)\n    max_income = total_income\n\n    for i in range(k):\n        for j in range(i, len(sequence)):\n            if sequence[j] < 0:\n                sequence[j] *= -1\n                max_income = max(max_income, sum(sequence))\n\n    return str(max_income)\n"
    },
    {
        "number": 1254,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    candidates = []\n    for _ in range(n):\n        s, r = map(int, stdin.split())\n        candidates.append((s, r))\n\n    def is_valid(delegation):\n        total_skill = sum(candidates[i][1] for i in delegation)\n        return total_skill >= 0\n\n    def max_sum(delegation):\n        total_skill = sum(candidates[i][1] for i in delegation)\n        return total_skill\n\n    delegations = [[] for _ in range(m)]\n    for s, r in candidates:\n        for i in range(m):\n            if s == candidates[i][0]:\n                delegations[i].append(s)\n                break\n\n    max_sum_delegation = max(max_sum(delegation) for delegation in delegations)\n    if not is_valid(max_sum_delegation):\n        return \"0\"\n\n    return str(max_sum_delegation)\n"
    },
    {
        "number": 1255,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cashes = []\n    for _ in range(n):\n        h, m = map(int, stdin.readline().strip().split())\n        cashes.append((h, m))\n\n    min_cashes = float('inf')\n    for h, m in cashes:\n        min_cashes = min(min_cashes, h * 60 + m)\n\n    return str(min_cashes)"
    },
    {
        "number": 1256,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sum = int(stdin)\n    if sum % 2 == 0:\n        return \"Error: The sum must be odd.\"\n    else:\n        return str(sum)"
    },
    {
        "number": 1257,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    table = [[0] * n for _ in range(n)]\n    for i in range(n):\n        table[i][i] = 1\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            table[i][j] = table[i + 1][j - 1] + table[i + 1][j]\n\n    for i in range(n):\n        for j in range(k):\n            table[i][j] += table[i][j + 1]\n\n    result = 0\n    for i in range(n):\n        result += table[i][k - 1]\n\n    return str(result)\n"
    },
    {
        "number": 1258,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    q = []\n    for _ in range(n-2):\n        q.append(list(map(int, stdin.strip().split())))\n    p = list(range(1, n+1))\n    for i in range(n-2):\n        for j in range(i+1, n):\n            if q[i][j] == q[i+1][j-1]:\n                p.remove(q[i][j])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i][j-1])\n                p.remove(q[i+1][j])\n                p.remove(q[i-1][j])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1][j+1])\n                p.remove(q[i+1][j-1])\n                p.remove(q[i+1][j+1])\n                p.remove(q[i-1][j-1])\n                p.remove(q[i-1"
    },
    {
        "number": 1259,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in edges[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    dfs(0, visited)\n\n    if n == 1:\n        return \"1\"\n\n    cycle = []\n    for u in range(n):\n        if not visited[u]:\n            cycle.append(u)\n            break\n\n    cycle.sort()\n    cycle = cycle[:n]\n\n    return \"2\" + \" \".join(str(cycle[i]) for i in range(n))\n"
    },
    {
        "number": 1260,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Perform operations\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] * a[j] > a[i]:\n                a[i], a[j] = a[j], a[i]\n\n    # Print the result\n    result = []\n    for i in range(n - 1):\n        result.append(f\"{i+1} {i+1} {i+1}\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1261,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"1 2\"\n    else:\n        result = []\n        for i in range(n):\n            result.append(1)\n        for i in range(1, n):\n            for j in range(i):\n                if result[j] % result[i] == 0:\n                    result[i] = result[j]\n                    break\n            else:\n                result[i] = 1\n        return \" \".join(map(str, result))"
    },
    {
        "number": 1262,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cities = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        cities.append((x, y))\n\n    c = [int(stdin.readline().strip()) for _ in range(n)]\n    k = [int(stdin.readline().strip()) for _ in range(n)]\n\n    def min_cost(city):\n        x, y = city\n        min_cost = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i == j:\n                    continue\n                dx, dy = cities[i] - cities[j]\n                if dx == 0 and dy == 0:\n                    continue\n                cost = abs(x - cities[j][0]) + abs(y - cities[j][1])\n                if cost < min_cost:\n                    min_cost = cost\n        return min_cost\n\n    min_cost_cities = [city for city in cities if min_cost(city) < 8]\n    if not min_cost_cities:\n        return \"No configuration costs less than 8 yen.\"\n\n    min_cost_cities.sort()\n    power_stations = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i == j:\n                continue\n            if min_cost(cities[i]) + min_cost(cities[j]) < 27:\n                power_stations.append((i, j))\n\n    if not power_stations:\n        return \"No configuration costs less than 27 yen.\"\n\n    for i in range(e):\n        a, b = map(int, stdin.readline().strip().split())\n        if a == b:\n            continue\n        if (a, b) in power_stations:\n            continue\n        power_stations.append((a, b))\n\n    for i in range(v):\n        print(power_stations[i][0], end=' ')\n    print()\n    for i in range(e):\n        print(power_stations[i][0], power_stations[i][1], end=' ')\n    print()\n\n    for i in range(e):\n        print(power_stations[i][0], power_stations[i][1], end=' ')\n    print()\n\n    return \" \".join(map(str, power_stations))\n"
    },
    {
        "number": 1263,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the total taste of the fruits\n    total_taste = sum(a) + sum(b)\n\n    # Calculate the total calories\n    total_calories = sum(b)\n\n    # Check if the total taste is equal to k\n    if total_taste!= k:\n        return \"-1\"\n\n    # Calculate the maximum possible sum of the taste values\n    max_sum = 0\n    for i in range(n):\n        if a[i] + b[i] > max_sum:\n            max_sum = a[i] + b[i]\n\n    return str(max_sum)\n"
    },
    {
        "number": 1264,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_ones = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == 1 and a[j] == 1:\n                max_ones += 1\n                a[i], a[j] = a[j], a[i]\n\n    return str(max_ones)"
    },
    {
        "number": 1265,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.strip()\n    b = stdin.strip()\n\n    if len(a)!= len(b):\n        return \"NO\"\n\n    for i in range(len(a)):\n        if a[i]!= b[i]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1266,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x_0, y_0 = map(int, stdin.strip().split())\n\n    board = [[0] * n for _ in range(n)]\n    for i in range(n):\n        board[i][x_0] = 1\n        board[i][y_0] = 1\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 0:\n                            board[x_0 + dx][y_0 + dy] = 2\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 2:\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 0:\n                            board[x_0 + dx][y_0 + dy] = 2\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 2:\n                            board[x_0 + dx][y_0 + dy] = 3\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 2:\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 2:\n                            board[x_0 + dx][y_0 + dy] = 3\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 3:\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 3:\n                            board[x_0 + dx][y_0 + dy] = 4\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 4:\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 4:\n                            board[x_0 + dx][y_0 + dy] = 4\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 3:\n                            board[x_0 + dx][y_0 + dy] = 5\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 2:\n                for dx in [-1, 1]:\n                    for dy in [-1, 1]:\n                        if 0 <= x_0 + dx < n and 0 <= y_0 + dy < n and board[x_0 + dx][y_0 + dy] == 3:\n                            board[x_0 + dx][y_0 + dy] = 5\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 3:\n                for dx in [-1, 0, 1]:\n                    for dy in [-1, 0, 1]:\n                        if 0 <= x_"
    },
    {
        "number": 1267,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Filter participants with score less than or equal to zero\n    a = [x for x in a if x > 0]\n\n    # Count the number of ways to choose a subset of participants with score less than or equal to zero\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] <= a[j]:\n                ways += 1\n\n    return str(ways)"
    },
    {
        "number": 1268,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    if n == 2:\n        if a[0] + a[1] == 100000:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 3:\n        if a[0] + a[1] == 100000 and a[2] + a[3] == 100000:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 4:\n        if a[0] + a[1] == 100000 and a[2] + a[3] == 100000 and a[4] + a[5] == 100000:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    if n == 5:\n        if a[0] + a[1] == 100000 and a[2] + a[3] == 100000 and a[4] + a[5] == 100000 and a[6] + a[7] == 100000:\n            return \"YES\"\n        else:\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 1269,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    count = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if c[i]!= c[j]:\n                count += 1\n                if count % 1000000007 == 0:\n                    print(count)\n    return str(count)"
    },
    {
        "number": 1270,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    primes = []\n    for i in range(2, n+1):\n        if n % i == 0:\n            primes.append(i)\n            if i!= n // i:\n                primes.append(n // i)\n    if len(primes) == 0:\n        return \"No prime numbers found\"\n    else:\n        return str(primes[0]) + \" \" + \" \".join(map(str, primes[1:]))"
    },
    {
        "number": 1271,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    colors = stdin.split()\n    candies = [int(c) for c in stdin.split()]\n\n    def move(box, color):\n        if box == s:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color\n        if box == 1:\n            return box, color\n        if box == n:\n            return box, color"
    },
    {
        "number": 1272,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    bridges = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        bridges.append((a, b))\n\n    def collapse_bridges(bridges):\n        for i in range(len(bridges)):\n            for j in range(i + 1, len(bridges)):\n                if bridges[i][0] < bridges[j][1] and bridges[j][0] < bridges[i][1]:\n                    bridges[i], bridges[j] = bridges[j], bridges[i]\n                    return collapse_bridges(bridges)\n\n    collapse_bridges(bridges)\n    inconvenience = 0\n    for i in range(1, M + 1):\n        inconvenience += bridges[i - 1][1] - bridges[i - 1][0]\n    return str(inconvenience)"
    },
    {
        "number": 1273,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    colors = [0] * n\n    colors[0] = 1\n    colors[1] = 2\n\n    for a, b in edges:\n        if colors[a] == colors[b]:\n            colors[a] += 1\n        else:\n            colors[b] += 1\n\n    min_colors = float('inf')\n    min_colors_index = -1\n\n    for i in range(n):\n        if colors[i] < min_colors:\n            min_colors = colors[i]\n            min_colors_index = i\n\n    print(min_colors_index + 1)\n    for i in range(n):\n        print(colors[i] + 1)\n\n    return ''"
    },
    {
        "number": 1274,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    jobs = []\n    for _ in range(N):\n        a, b = map(int, stdin.split())\n        jobs.append((a, b))\n\n    jobs.sort(key=lambda x: x[0])\n    total_reward = 0\n    for i in range(N):\n        if i == 0:\n            total_reward += jobs[i][1]\n        else:\n            total_reward += max(jobs[i][1], jobs[i - 1][1])\n\n    if total_reward > M:\n        return \"No\"\n    else:\n        return str(total_reward)"
    },
    {
        "number": 1275,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    count = 0\n    for a in range(1, N):\n        for b in range(a+1, N+1):\n            for c in range(b+1, N+1):\n                for d in range(c+1, N+1):\n                    if a+b-c-d == K:\n                        count += 1\n    return str(count)"
    },
    {
        "number": 1276,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    S = stdin.strip()\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if S[i]!= S[j] and S[i]!= S[j] and S[j]!= S[i]:\n                if j - i!= S[i] - j:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 1277,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, u, v = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        graph[a - 1].append((b - 1, 1))\n        graph[b - 1].append((a - 1, 1))\n    visited = [False] * n\n    moves = 0\n    while True:\n        for i in range(n):\n            if not visited[i]:\n                dfs(i, visited, graph, moves)\n        if moves == n:\n            return str(moves)\n        moves += 1\n    return \"Game is not bound to end.\"\n\ndef"
    },
    {
        "number": 1278,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    earliest_not_so_rainy_day = -1\n    for i in range(n):\n        if a[i] < a[i - x] and a[i] < a[i + y]:\n            earliest_not_so_rainy_day = i\n            break\n\n    return str(earliest_not_so_rainy_day)\n"
    },
    {
        "number": 1279,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    chests = [[] for _ in range(n)]\n    keys = [[] for _ in range(m)]\n\n    for i in range(n):\n        chests[i].append(a[i])\n\n    for j in range(m):\n        keys[j].append(b[j])\n\n    max_chests = 0\n    for i in range(n):\n        for j in range(m):\n            if sum(chests[i]) + sum(keys[j]) % 2 == 1:\n                max_chests = max(max_chests, len(chests[i]))\n\n    return str(max_chests)\n"
    },
    {
        "number": 1280,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    k = int(stdin.readline().strip())\n    good_substrings = set()\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i] == s[j]:\n                continue\n            for k in range(i + 1, j):\n                if s[k] == s[j]:\n                    continue\n                if s[i] + s[k] <= k + k and s[i] + s[k] > k + k - 1:\n                    good_substrings.add(s[i:j])\n\n    return str(len(good_substrings))"
    },
    {
        "number": 1281,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_segments = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for l in range(i, j):\n                for r in range(j, n + 1):\n                    if a[l] ^ a[l + 1] ^ a[r] ^ a[r + 1]!= 0:\n                        max_segments = max(max_segments, j - i)\n\n    return str(max_segments)"
    },
    {
        "number": 1282,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    changes = []\n    for i in range(n):\n        changes.append(int(stdin.strip()))\n    changes.sort()\n    total_seconds = 0\n    for i in range(n):\n        if changes[i] == 1:\n            total_seconds += 1\n        elif changes[i] == 2:\n            total_seconds += 2\n    return str(total_seconds)"
    },
    {
        "number": 1283,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    field = list(stdin.strip())\n\n    def count_different_locations(row, col):\n        count = 0\n        for i in range(row - k, row + k + 1):\n            for j in range(col - k, col + k + 1):\n                if i == row and j == col:\n                    continue\n                if field[i][j] == '#':\n                    count += 1\n        return count\n\n    max_count = 0\n    max_row = 0\n    max_col = 0\n\n    for i in range(n):\n        for j in range(n):\n            if field[i][j] == '#':\n                count = count_different_locations(i, j)\n                if count > max_count:\n                    max_count = count\n                    max_row = i\n                    max_col = j\n\n    return f\"{max_row} {max_col}\""
    },
    {
        "number": 1284,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_circular = 0\n    circular = 0\n\n    for i in range(n - 1):\n        if a[i] + a[i + 1] == 17:\n            circular = i + 1\n            max_circular = max(max_circular, circular)\n\n    return str(max_circular)"
    },
    {
        "number": 1285,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    A = []\n    for _ in range(n):\n        A.append(list(map(int, stdin.strip().split())))\n    x = 1\n    while True:\n        B = [[0] * x for _ in range(x)]\n        for i in range(x):\n            for j in range(x):\n                if i % 2 == 0 and j % 2 == 0:\n                    B[i // 2][j // 2] = A[i][j]\n                elif i % 2 == 0:\n                    B[i // 2][j // 2] = A[i][j]\n                elif j % 2 == 0:\n                    B[i // 2][j // 2] = A[i][j]\n        if all(B[i][j] == 0 for i in range(x) for j in range(x)):\n            break\n        x *= 2\n    return str(x)"
    },
    {
        "number": 1286,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    p = 10**9 + 7\n    q = 10**9 + 7\n    for i in range(n):\n        p = (p * a[i]) % p\n        q = (q * a[i]) % q\n    x = p % p\n    y = q % q\n    return f\"{x}/{y}\""
    },
    {
        "number": 1287,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = [list(map(float, stdin.readline().strip().split())) for _ in range(n)]\n\n    # Calculate the probability of Jedi Ivan staying alive after the Tournament\n    probability = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            probability *= (1 - p[i][j]) * p[i][j]\n\n    return str(probability)\n"
    },
    {
        "number": 1288,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_cost(s):\n        if len(s) == 1:\n            return a[s[0]]\n        else:\n            return min(min_cost(s[1:]), min_cost(s[2:]))\n\n    return str(min_cost(range(n)))\n"
    },
    {
        "number": 1289,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def distance(a, b):\n        return abs(a - b)\n\n    def segment_length(a, b):\n        return distance(a, b)\n\n    def segment_length_query(a, b):\n        if a == b:\n            return 0\n        for i in range(1, n):\n            if a[i] < b[i]:\n                return distance(a[i], b[i])\n        return -1\n\n    def segment_length_query_helper(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query(a, b)\n        if a[0] in visited:\n            return segment_length_query_helper(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper(a, b[1:], visited + [b[0]])\n        return -1\n\n    def segment_length_query_helper_reverse(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query(a, b)\n        if a[0] in visited:\n            return segment_length_query_helper_reverse(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper_reverse(a, b[1:], visited + [b[0]])\n        return -1\n\n    def segment_length_query_helper_reverse_helper(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query_helper_reverse(a, b, visited)\n        if a[0] in visited:\n            return segment_length_query_helper_reverse_helper(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper_reverse_helper(a, b[1:], visited + [b[0]])\n        return -1\n\n    def segment_length_query_helper_reverse_helper_reverse(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query_helper_reverse(a, b, visited)\n        if a[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse(a, b[1:], visited + [b[0]])\n        return -1\n\n    def segment_length_query_helper_reverse_helper_reverse_helper(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query_helper_reverse_helper_reverse(a, b, visited)\n        if a[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse_helper(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse_helper(a, b[1:], visited + [b[0]])\n        return -1\n\n    def segment_length_query_helper_reverse_helper_reverse_helper_reverse(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query_helper_reverse_helper_reverse(a, b, visited)\n        if a[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse_helper(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse_helper(a, b[1:], visited + [b[0]])\n        return -1\n\n    def segment_length_query_helper_reverse_helper_reverse_helper_reverse_helper(a, b, visited):\n        if len(visited) == m:\n            return segment_length_query_helper_reverse_helper_reverse_helper(a, b, visited)\n        if a[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse_helper_reverse(a[1:], b, visited + [a[0]])\n        if b[0] in visited:\n            return segment_length_query_helper_reverse_helper_reverse_helper_reverse(a, b[1:], visited + [b[0"
    },
    {
        "number": 1290,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    squares = [0] * n\n    for _ in range(m):\n        c = map(int, stdin.split())\n        for i in range(n):\n            squares[i] += c[i]\n    points = 0\n    for i in range(n):\n        if squares[i] > 0:\n            points += 1\n            squares[i] -= 1\n    return str(points)"
    },
    {
        "number": 1291,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    M = [list(map(int, stdin.split())) for _ in range(m)]\n    S = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def is_inside_circle(x, y, center_x, center_y, radius):\n        return (x - center_x) ** 2 + (y - center_y) ** 2 <= radius ** 2\n\n    for i in range(n):\n        for j in range(m):\n            if is_inside_circle(M[i][j], S[i][j], M[i][0], S[i][0], 1):\n                return \"YES\"\n            if is_inside_circle(M[i][j], S[i][j], M[i][m - 1], S[i][m - 1], 1):\n                return \"YES\"\n            if is_inside_circle(M[i][j], S[i][j], M[0][j], S[0][j], 1):\n                return \"YES\"\n            if is_inside_circle(M[i][j], S[i][j], M[0][j], S[0][j], 1):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1292,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n\n    # Initialize the game grid\n    grid = [[0] * m for _ in range(n)]\n    for i in range(p):\n        grid[0][i] = i + 1\n\n    # Expand the first player\n    for i in range(1, n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                for k in range(p):\n                    if grid[i - 1][j] == k + 1 and grid[i][j] == 0:\n                        grid[i][j] = k + 1\n                        break\n\n    # Expand the second player\n    for i in range(1, n):\n        for j in range(m):\n            if grid[i][j] == 0:\n                for k in range(p):\n                    if grid[i - 1][j] == k + 1 and grid[i][j] == 0:\n                        grid[i][j] = k + 1\n                        break\n\n    # Count the number of cells controlled by each player\n    count = [0] * p\n    for i in range(p):\n        count[i] = sum(1 for j in range(m) if grid[i][j] == i + 1)\n\n    return''.join(map(str, count))"
    },
    {
        "number": 1293,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [0] * n\n    b = [0] * n\n\n    for i in range(n):\n        a[i] = int(stdin.strip())\n        b[i] = int(stdin.strip())\n\n    steps = 0\n    for i in range(n):\n        if a[i] == b[i]:\n            steps += 1\n        else:\n            if a[i] > b[i]:\n                a[i] += 1\n            else:\n                a[i] -= 1\n\n    return str(steps)"
    },
    {
        "number": 1294,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    res = \"\"\n    for _ in range(t):\n        s = stdin.strip()\n        if s == \"\":\n            break\n        for i in range(len(s)):\n            if s[i] == \"a\":\n                res += \"a\"\n            elif s[i] == \"b\":\n                res += \"b\"\n            elif s[i] == \"c\":\n                res += \"c\"\n            elif s[i] == \"d\":\n                res += \"d\"\n            elif s[i] == \"e\":\n                res += \"e\"\n            elif s[i] == \"f\":\n                res += \"f\"\n            elif s[i] == \"g\":\n                res += \"g\"\n            elif s[i] == \"h\":\n                res += \"h\"\n            elif s[i] == \"i\":\n                res += \"i\"\n            elif s[i] == \"j\":\n                res += \"j\"\n            elif s[i] == \"k\":\n                res += \"k\"\n            elif s[i] == \"l\":\n                res += \"l\"\n            elif s[i] == \"m\":\n                res += \"m\"\n            elif s[i] == \"n\":\n                res += \"n\"\n            elif s[i] == \"o\":\n                res += \"o\"\n            elif s[i] == \"p\":\n                res += \"p\"\n            elif s[i] == \"q\":\n                res += \"q\"\n            elif s[i] == \"r\":\n                res += \"r\"\n            elif s[i] == \"s\":\n                res += \"s\"\n            elif s[i] == \"t\":\n                res += \"t\"\n            elif s[i] == \"u\":\n                res += \"u\"\n            elif s[i] == \"v\":\n                res += \"v\"\n            elif s[i] == \"w\":\n                res += \"w\"\n            elif s[i] == \"x\":\n                res += \"x\"\n            elif s[i] == \"y\":\n                res += \"y\"\n            elif s[i] == \"z\":\n                res += \"z\"\n    return res"
    },
    {
        "number": 1295,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def find_min_r(a, b):\n        r = 0\n        for i in range(n):\n            for j in range(m):\n                if distance(a[i], b[j], a[i], b[j]) <= r:\n                    r = distance(a[i], b[j], a[i], b[j])\n        return r\n\n    min_r = find_min_r(a, b)\n    print(min_r)\n    return str(min_r)\n"
    },
    {
        "number": 1296,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, S = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the base costs\n    base_costs = [a[i] for i in range(n)]\n\n    # Calculate the maximum number of souvenirs\n    max_k = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            max_k = max(max_k, j - i)\n\n    # Calculate the minimum total cost\n    min_total_cost = sum(base_costs)\n\n    return str(max_k) + \" \" + str(min_total_cost)\n"
    },
    {
        "number": 1297,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    count = 0\n    for i in range(n):\n        if stdin[i] == 'A' and stdin[i+1] == 'T':\n            count += 1\n        elif stdin[i] == 'T' and stdin[i+1] == 'A':\n            count += 1\n        elif stdin[i] == 'G' and stdin[i+1] == 'C':\n            count += 1\n        elif stdin[i] == 'C' and stdin[i+1] == 'G':\n            count += 1\n    return str(count)"
    },
    {
        "number": 1298,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    string = stdin.strip()\n    result = \"\"\n    for i in range(n):\n        if string[i] == \"0\" and string[i+1] == \"0\":\n            result += \"0\"\n            string = string[:i] + string[i+2:]\n        elif string[i] == \"1\" and string[i+1] == \"1\":\n            result += \"1\"\n            string = string[:i] + string[i+2:]\n    return result"
    },
    {
        "number": 1299,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    laws = list(map(int, stdin.split()))\n    a, b = 0, 0\n    for law in laws:\n        if law <= a + k - 1:\n            a = law\n        elif law >= b + k - 1:\n            b = law\n    return str(a) + \" \" + str(b)"
    },
    {
        "number": 1300,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(-c, c + 1):\n                a[i] += k\n                a[j] += k\n                max_count = max(max_count, a[i] + a[j])\n\n    return str(max_count)"
    },
    {
        "number": 1301,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    letters = stdin.strip().split()\n    pattern = ''.join(letters)\n    pattern_length = len(pattern)\n\n    for i in range(n):\n        for j in range(n):\n            if pattern[i] == '.' and pattern[j] == '.':\n                if i == j:\n                    continue\n                if pattern[i] == pattern[j]:\n                    return pattern[i]\n\n    return None"
    },
    {
        "number": 1302,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    permutations = []\n    for i in range(1, n + 1):\n        for j in range(i):\n            if gcd(i, j) > 1:\n                permutations.append(i)\n                permutations.append(j)\n                if len(permutations) == k:\n                    return''.join(map(str, permutations))\n    return '-1'\n\ndef"
    },
    {
        "number": 1303,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    # Find the common moment of time in schedules\n    common_moment = None\n    for i in range(p):\n        for j in range(q):\n            if a[i] < b[j] + 1 and b[i] < a[j] + 1 and c[j] < d[i] + 1 and d[j] < c[i] + 1:\n                if common_moment is None:\n                    common_moment = [a[i], b[i]]\n                else:\n                    common_moment[0] = min(common_moment[0], a[i])\n                    common_moment[1] = max(common_moment[1], b[i])\n\n    # Find the moments of time from the segment [l, r]\n    moments = []\n    for i in range(p):\n        for j in range(q):\n            if a[i] < b[j] + 1 and b[i] < a[j] + 1 and c[j] < d[i] + 1 and d[j] < c[i] + 1:\n                if a[i] <= common_moment[0] <= b[i] and c[j] <= common_moment[1] <= d[j]:\n                    moments.append(common_moment[0])\n\n    return str(len(moments))\n"
    },
    {
        "number": 1304,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    x, y = map(int, stdin.split())\n\n    # Initialize field\n    field = [['.' for _ in range(9)] for _ in range(9)]\n\n    # Read table\n    for i in range(9):\n        for j in range(9):\n            field[i][j] = stdin.strip()\n\n    # Find possible next moves\n    moves = []\n    for i in range(9):\n        for j in range(9):\n            if field[i][j] == 'x':\n                moves.append((i, j))\n            elif field[i][j] == 'o':\n                moves.append((i, j))\n                moves.append((i, j + 1))\n                moves.append((i, j - 1))\n                moves.append((i + 1, j))\n                moves.append((i - 1, j))\n                moves.append((i + 1, j + 1))\n                moves.append((i + 1, j - 1))\n                moves.append((i - 1, j + 1))\n                moves.append((i - 1, j - 1))\n\n    # Output possible next moves\n    output = ''\n    for move in moves:\n        output += '!!!'\n        output +='' * (9 - len(output))\n        output += '!!!'\n        output += '\\n'\n\n    return output"
    },
    {
        "number": 1305,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    bills = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"YES\"\n\n    for i in range(n - 1):\n        if bills[i] == bills[i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1306,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def dfs(l, r, seen):\n        if l == r:\n            return 1\n\n        if l in seen or r in seen:\n            return 0\n\n        seen.add(l)\n        seen.add(r)\n\n        ways = 0\n\n        for i in range(l, r + 1):\n            ways += dfs(i, r, seen)\n\n        seen.remove(l)\n        seen.remove(r)\n\n        return ways\n\n    ways = dfs(0, n - 1, set())\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 1307,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return \"Mahmoud\"\n    else:\n        return \"Ehab\""
    },
    {
        "number": 1308,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.strip()\n    queries = []\n    for _ in range(m):\n        queries.append(list(map(int, stdin.strip().split())))\n\n    isomorphic = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(s[i:i + len(s[i])]) == len(s[j:j + len(s[j])]) and s[i:i + len(s[i])] == s[j:j + len(s[j])]:\n                isomorphic.append((s[i:i + len(s[i])], s[j:j + len(s[j])]))\n\n    for query in queries:\n        x, y, len_ = query\n        if len(isomorphic) == 0:\n            print(\"NO\")\n            continue\n\n        for i in range(len(isomorphic)):\n            for j in range(i + 1, len(isomorphic)):\n                if len(isomorphic[i][0]) == len(isomorphic[j][0]) and isomorphic[i][0] == isomorphic[j][0]:\n                    if isomorphic[i][1][x - 1] == isomorphic[j][1][y - 1]:\n                        isomorphic[i] = (isomorphic[i][0], isomorphic[j][1])\n                        isomorphic[j] = (isomorphic[j][0], isomorphic[i][1])\n                        break\n\n        if len(isomorphic) == 0:\n            print(\"NO\")\n            continue\n\n        print(\"YES\" if isomorphic[0][0] == isomorphic[1][1] else \"NO\")\n\n    return \"\""
    },
    {
        "number": 1309,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    w = list(map(int, stdin.readline().strip().split()))\n\n    total_instability = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            total_instability += abs(w[i] - w[j])\n\n    return str(total_instability)\n"
    },
    {
        "number": 1310,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    max_xor = 0\n    for i in range(n - 1):\n        xor = arr[i] ^ arr[i + 1]\n        max_xor = max(max_xor, xor)\n\n    return str(max_xor)"
    },
    {
        "number": 1311,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, w = map(int, stdin.readline().strip().split())\n        points.append((x, w))\n\n    G = [(i, j, w) for i, j, w in points for j in range(i + 1, n + 1)]\n    G.sort(key=lambda x: x[2])\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v, w in G[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    dfs(0, visited)\n\n    return len(set(range(n)) - set(visited))"
    },
    {
        "number": 1312,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [0] * m\n    for i in range(m):\n        a[i] = i + 1\n    for i in range(m):\n        for j in range(i + 1, m):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n    return''.join(map(str, a))"
    },
    {
        "number": 1313,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n_1, n_2, k_1, k_2 = map(int, stdin.split())\n    if n_1 == n_2:\n        return \"First\"\n    else:\n        return \"Second\""
    },
    {
        "number": 1314,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    obelisks = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        obelisks.append((x, y))\n\n    clues = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        clues.append((a, b))\n\n    def find_permutation(p):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] == p[j]:\n                    return False\n        return True\n\n    def find_treasure(p):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if p[i] + obelisks[i][0] == p[j] + obelisks[j][0] and p[i] + obelisks[i][1] == p[j] + obelisks[j][1]:\n                    return True\n        return False\n\n    hidden_permutation = [2, 1]\n    if find_permutation(hidden_permutation):\n        treasure = (obelisks[hidden_permutation[0]][0] + clues[hidden_permutation[0]][0], obelisks[hidden_permutation[0]][1] + clues[hidden_permutation[0]][1])\n    else:\n        treasure = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if find_permutation([p[i] + obelisks[i][0], p[i] + obelisks[i][1], p[j] + obelisks[j][0], p[j] + obelisks[j][1]]):\n                treasure = (obelisks[i][0] + clues[i][0], obelisks[i][1] + clues[i][1])\n                break\n\n    return f\"{treasure[0]} {treasure[1]}\""
    },
    {
        "number": 1315,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Sort the residents based on their money\n    a.sort(reverse=True)\n\n    # Initialize the result list\n    result = []\n\n    # Iterate through the residents\n    for i in range(n):\n        # Check if the current resident has enough money to swap places\n        if i > 0 and a[i] < a[i-1]:\n            # If so, swap places\n            result.append(a[i])\n            result.append(a[i-1])\n            a[i], a[i-1] = a[i-1], a[i]\n        else:\n            # If not, add the money to the result list\n            result.append(a[i])\n\n    # Join the result list into a single line\n    return''.join(map(str, result))"
    },
    {
        "number": 1316,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n    x = 0\n    for i in range(n - k + 1):\n        if s[i:i + k] == s[i:i + k].replace(s[i], s[i + 1]):\n            x += 1\n    return str(x)"
    },
    {
        "number": 1317,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i**2 + j**2 == n**2:\n                result += 1\n    return str(result)"
    },
    {
        "number": 1318,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tables = list(map(int, stdin.split()))\n    requests = []\n    for _ in range(n):\n        c, p = map(int, stdin.split())\n        requests.append((c, p))\n\n    def max_money(requests):\n        total_money = 0\n        for c, p in requests:\n            total_money += c * p\n        return total_money\n\n    def max_table(requests):\n        max_table = 0\n        for c, p in requests:\n            if c > max_table:\n                max_table = c\n        return max_table\n\n    def max_people(requests):\n        max_people = 0\n        for c, p in requests:\n            if p > max_people:\n                max_people = p\n        return max_people\n\n    def max_requests(requests):\n        max_requests = 0\n        for c, p in requests:\n            if c > max_requests:\n                max_requests = c\n        return max_requests\n\n    def max_money_table(requests):\n        max_money_table = 0\n        max_table = 0\n        for c, p in requests:\n            if c > max_requests:\n                max_requests = c\n            if c > max_money_table:\n                max_money_table = c\n                max_table = max_table\n        return max_money_table\n\n    def max_money_people(requests):\n        max_money_people = 0\n        max_people = 0\n        for c, p in requests:\n            if p > max_people:\n                max_people = p\n            if p > max_money_people:\n                max_money_people = p\n        return max_money_people\n\n    def max_requests_table(requests):\n        max_requests_table = 0\n        max_requests = 0\n        max_table = 0\n        for c, p in requests:\n            if c > max_requests:\n                max_requests = c\n            if c > max_requests_table:\n                max_requests_table = c\n                max_requests = max_requests\n                max_table = max_table\n        return max_requests_table\n\n    def max_requests_people(requests):\n        max_requests_people = 0\n        max_requests = 0\n        max_people = 0\n        for c, p in requests:\n            if p > max_people:\n                max_people = p\n            if p > max_requests_people:\n                max_requests_people = p\n                max_requests = max_requests\n                max_people = max_people\n        return max_requests_people\n\n    def max_money_table_people(requests):\n        max_money_table_people = 0\n        max_money_table = 0\n        max_requests_table = 0\n        max_requests = 0\n        max_people = 0\n        for c, p in requests:\n            if c > max_requests:\n                max_requests = c\n            if c > max_requests_table:\n                max_requests_table = c\n                max_requests = max_requests\n                max_table = max_table\n            if p > max_people:\n                max_people = p\n            if p > max_money_table_people:\n                max_money_table_people = p\n                max_money_table = max_money_table\n                max_requests_table = max_requests_table\n                max_people = max_people\n        return max_money_table_people\n\n    def max_money_table_requests(requests):\n        max_money_table_requests = 0\n        max_money_table = 0\n        max_requests_table = 0\n        max_requests = 0\n        for c, p in requests:\n            if c > max_requests:\n                max_requests = c\n            if c > max_requests_table:\n                max_requests_table = c\n                max_requests = max_requests\n                max_table = max_table\n            if p > max_money_table_requests:\n                max_money_table_requests = p\n                max_money_table = max_money_table\n                max_requests_table = max_requests_table\n        return max_money_table_requests\n\n    def max_money_people_requests(requests):\n        max_money_people_requests = 0\n        max_money_people = 0\n        max_requests_people = 0\n        max_requests = 0\n        max_people = 0\n        for c, p in requests:\n            if p > max_people:\n                max_people = p\n            if p > max_requests_people:\n                max_requests_people = p\n                max_requests = max_requests\n                max_people = max"
    },
    {
        "number": 1319,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = [int(x) for x in stdin.strip().split()]\n    p.sort()\n    p.reverse()\n    p_factors = [p[i] for i in range(len(p))]\n    p_factors.append(1)\n    p_factors.sort()\n    p_factors.reverse()\n    p_factors = p_factors[1:]\n    p_factors = [x for x in p_factors if x % 2 == 0]\n    p_factors = [x for x in p_factors if x % 3 == 0]\n    p_factors = [x for x in p_factors if x % 5 == 0]\n    p_factors = [x for x in p_factors if x % 7 == 0]\n    p_factors = [x for x in p_factors if x % 11 == 0]\n    p_factors = [x for x in p_factors if x % 13 == 0]\n    p_factors = [x for x in p_factors if x % 17 == 0]\n    p_factors = [x for x in p_factors if x % 19 == 0]\n    p_factors = [x for x in p_factors if x % 23 == 0]\n    p_factors = [x for x in p_factors if x % 29 == 0]\n    p_factors = [x for x in p_factors if x % 31 == 0]\n    p_factors = [x for x in p_factors if x % 37 == 0]\n    p_factors = [x for x in p_factors if x % 41 == 0]\n    p_factors = [x for x in p_factors if x % 43 == 0]\n    p_factors = [x for x in p_factors if x % 47 == 0]\n    p_factors = [x for x in p_factors if x % 53 == 0]\n    p_factors = [x for x in p_factors if x % 59 == 0]\n    p_factors = [x for x in p_factors if x % 61 == 0]\n    p_factors = [x for x in p_factors if x % 67 == 0]\n    p_factors = [x for x in p_factors if x % 71 == 0]\n    p_factors = [x for x in p_factors if x % 73 == 0]\n    p_factors = [x for x in p_factors if x % 79 == 0]\n    p_factors = [x for x in p_factors if x % 83 == 0]\n    p_factors = [x for x in p_factors if x % 89 == 0]\n    p_factors = [x for x in p_factors if x % 97 == 0]\n    p_factors = [x for x in p_factors if x % 101 == 0]\n    p_factors = [x for x in p_factors if x % 103 == 0]\n    p_factors = [x for x in p_factors if x % 107 == 0]\n    p_factors = [x for x in p_factors if x % 109 == 0]\n    p_factors = [x for x in p_factors if x % 113 == 0]\n    p_factors = [x for x in p_factors if x % 127 == 0]\n    p_factors = [x for x in p_factors if x % 131 == 0]\n    p_factors = [x for x in p_factors if x % 137 == 0]\n    p_factors = [x for x in p_factors if x % 139 == 0]\n    p_factors = [x for x in p_factors if x % 149 == 0]\n    p_factors = [x for x in p_factors if x % 151 == 0]\n    p_factors = [x for x in p_factors if x % 157 == 0]\n    p_factors = [x for x in p_factors if x % 163 == 0]\n    p_factors = [x for x in p_factors if x % 167 == 0]\n    p_factors = [x for x in p_factors if x % 173 == 0]\n    p_factors"
    },
    {
        "number": 1320,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    happiness = 0\n    for i in range(n):\n        row = stdin.strip()\n        for j in range(n):\n            if row[j] == 'C':\n                happiness += 1\n    return str(happiness)"
    },
    {
        "number": 1321,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    photos = []\n    for _ in range(n):\n        w, h = map(int, stdin.strip().split())\n        photos.append((w, h))\n\n    min_size = float('inf')\n    for w, h in photos:\n        min_size = min(min_size, w * h)\n\n    return''.join(map(str, min_size))"
    },
    {
        "number": 1322,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    MOD = 10**9 + 7\n    states = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'O', 'Q', 'P', 'R', 'S']\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J')\n    states.sort()\n    states.append('L')\n    states.sort()\n    states.append('M')\n    states.sort()\n    states.append('K')\n    states.sort()\n    states.append('J"
    },
    {
        "number": 1323,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the number of partitions for each cluster\n    num_partitions = [m, n]\n    for i in range(1, m + 1):\n        num_partitions[0] += a[i - 1]\n    for i in range(1, n + 1):\n        num_partitions[1] += b[i - 1]\n\n    # Calculate the number of copy operations\n    num_copy_operations = 0\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            num_copy_operations += min(a[i - 1], b[j - 1])\n\n    return str(num_copy_operations)\n"
    },
    {
        "number": 1324,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_1, a_2, a_3, a_4 = map(int, stdin.split())\n    s = stdin.strip()\n    count = 0\n    for i in range(4):\n        if s[i] == '1':\n            count += a_1\n        elif s[i] == '2':\n            count += a_2\n        elif s[i] == '3':\n            count += a_3\n        elif s[i] == '4':\n            count += a_4\n    return str(count)"
    },
    {
        "number": 1325,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    palindrome = True\n    for i in range(n):\n        if i == p:\n            palindrome = False\n            break\n        if i > p:\n            alphabet = alphabet[1:] + alphabet[:1]\n        else:\n            alphabet = alphabet[:i] + alphabet[i+1:]\n    if palindrome:\n        return '0'\n    else:\n        return str(p)"
    },
    {
        "number": 1326,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    f = [1] * (N + 1)\n    f[0] = 0\n    f[1] = 1\n\n    for i in range(2, N + 1):\n        f[i] = f[i - 1] + f[i - 2]\n\n    return str(sum(K * f[K] for K in range(1, N + 1)))"
    },
    {
        "number": 1327,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cakes = []\n    for _ in range(m):\n        beauty, tastiness, popularity = map(int, stdin.split())\n        cakes.append((beauty, tastiness, popularity))\n\n    cakes.sort(key=lambda x: (-x[0], -x[1], -x[2]))\n\n    total_beauty = 0\n    total_tastiness = 0\n    total_popularity = 0\n    for beauty, tastiness, popularity in cakes:\n        total_beauty += abs(beauty)\n        total_tastiness += abs(tastiness)\n        total_popularity += abs(popularity)\n\n    return str(total_beauty + total_tastiness + total_popularity)"
    },
    {
        "number": 1328,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M_a, M_b = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    if N > 40 or M_a <= 0 or M_b <= 0 or M_a == M_b:\n        return \"-1\"\n\n    if N == 1:\n        return str(c[0] * M_a * M_b)\n\n    if N == 2:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a)\n\n    if N == 3:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b)\n\n    if N == 4:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a)\n\n    if N == 5:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b)\n\n    if N == 6:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b + c[5] * M_b * M_a)\n\n    if N == 7:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b + c[5] * M_b * M_a + c[6] * M_a * M_b)\n\n    if N == 8:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b + c[5] * M_b * M_a + c[6] * M_a * M_b + c[7] * M_b * M_a)\n\n    if N == 9:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b + c[5] * M_b * M_a + c[6] * M_a * M_b + c[7] * M_b * M_a + c[8] * M_a * M_b)\n\n    if N == 10:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b + c[5] * M_b * M_a + c[6] * M_a * M_b + c[7] * M_b * M_a + c[8] * M_a * M_b + c[9] * M_b * M_a)\n\n    if N == 11:\n        return str(c[0] * M_a * M_b + c[1] * M_b * M_a + c[2] * M_a * M_b + c[3] * M_b * M_a + c[4] * M_a * M_b + c[5] * M_b * M_a + c[6] * M_a * M_b + c["
    },
    {
        "number": 1329,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        if i % 75 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1330,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = int(stdin.strip())\n    k = list(map(int, stdin.split()))\n\n    # Initialize the team strengths\n    team_strengths = [0] * m\n\n    # Initialize the team members\n    team_members = [[] for _ in range(m)]\n\n    # Initialize the team strengths for each day\n    for i in range(d):\n        # Select the team members for the current day\n        team_members_for_day = [k[i] for k in k]\n        team_members_for_day.sort()\n\n        # Select the team members for the next day\n        team_members_for_next_day = [k[i+1] for k in k]\n        team_members_for_next_day.sort()\n\n        # Calculate the team strength for the current day\n        team_strength = 0\n        for j in range(len(team_members_for_day)):\n            if team_members_for_day[j] == team_members_for_next_day[j]:\n                team_strength += 1\n\n        # Update the team strengths for the current day\n        team_strengths[team_members_for_day[0]] = team_strength\n\n    # Find the maximum possible strength of the team\n    max_strength = max(team_strengths)\n\n    # Print the maximum possible strength of the team\n    for i in range(m):\n        print(team_strengths[i], end=\" \")\n    print()\n\n    return str(max_strength)\n"
    },
    {
        "number": 1331,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        if a[i] % 2 == 0:\n            count += 1\n            if count == k:\n                return str(count)\n    return str(count)"
    },
    {
        "number": 1332,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c_1, c_2, c_3, c_4, c_5 = map(int, stdin.split())\n    if c_1 + c_2 + c_3 + c_4 + c_5 == 0:\n        return \"-1\"\n    b = c_1 + c_2 + c_3 + c_4 + c_5\n    return str(b)"
    },
    {
        "number": 1333,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    snake = [['.'] * m for _ in range(n)]\n    snake[1][1] = '#'\n    snake[n-2][m-2] = '#'\n    for i in range(n-2, -1, -1):\n        for j in range(m-2, -1, -1):\n            if i == 1 and j == 1:\n                snake[i][j] = '#'\n            elif i == 1 and j == m-2:\n                snake[i][j] = '#'\n            elif i == n-2 and j == m-2:\n                snake[i][j] = '#'\n            elif i == n-2 and j == 1:\n                snake[i][j] = '#'\n            elif i == 1 and j == 0:\n                snake[i][j] = '#'\n            elif i == n-2 and j == m-1:\n                snake[i][j] = '#'\n            elif i == n-1 and j == m-2:\n                snake[i][j] = '#'\n            elif i == n-1 and j == 1:\n                snake[i][j] = '#'\n            elif i == 0 and j == m-2:\n                snake[i][j] = '#'\n            elif i == 0 and j == 1:\n                snake[i][j] = '#'\n            elif i == m-1 and j == m-2:\n                snake[i][j] = '#'\n            elif i == m-1 and j == 1:\n                snake[i][j] = '#'\n            else:\n                snake[i][j] = '.'\n    return ''.join(snake)"
    },
    {
        "number": 1334,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n    t = \"\"\n    for i in range(n):\n        t += s[i]\n    for i in range(n - k + 1):\n        if s[i:i+k] == t:\n            return t\n    return \"\""
    },
    {
        "number": 1335,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = round(100 * (n / k))\n    interesting_solutions = 0\n    for i in range(n):\n        for j in range(a[i]):\n            interesting_solutions += 1\n    return str(interesting_solutions)"
    },
    {
        "number": 1336,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    matryoshkas = []\n    for _ in range(n):\n        out, in_ = map(int, stdin.strip().split())\n        matryoshkas.append((out, in_))\n\n    def dfs(matryoshka, index, extra_space):\n        if index == len(matryoshkas):\n            return extra_space\n\n        out, in_ = matryoshkas[index]\n        if out <= in_:\n            return dfs(matryoshkas[index + 1], index + 1, extra_space)\n\n        if index == 0:\n            return extra_space\n\n        out, in_ = matryoshkas[index - 1]\n        if out <= in_:\n            return dfs(matryoshkas[index - 1], index - 1, extra_space)\n\n        return max(dfs(matryoshkas[index - 1], index - 1, extra_space),\n                   dfs(matryoshkas[index + 1], index + 1, extra_space))\n\n    def find_biggest_subset(matryoshkas):\n        max_extra_space = float('-inf')\n        for i in range(len(matryoshkas)):\n            for j in range(i + 1, len(matryoshkas)):\n                extra_space = dfs(matryoshkas, i, 0)\n                if extra_space > max_extra_space:\n                    max_extra_space = extra_space\n\n        return max_extra_space\n\n    biggest_subset = find_biggest_subset(matryoshkas)\n    return str(biggest_subset % (10**9 + 7))"
    },
    {
        "number": 1337,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    movies = []\n    for _ in range(m):\n        movie = list(map(int, stdin.split()))\n        movies.append(movie)\n\n    def max_scientists(movie):\n        scientists = [movie[i] for i in range(n)]\n        scientists.sort()\n        return scientists[-1]\n\n    max_scientists_index = max(range(m), key=lambda i: movies[i][-1])\n    max_scientists_movie = movies[max_scientists_index]\n\n    almost_satisfied_scientists = [i for i in range(n) if i!= max_scientists_index and movies[i][-1] == max_scientists_movie[0]]\n    almost_satisfied_scientists.sort()\n\n    return str(max_scientists_index)"
    },
    {
        "number": 1338,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(range(1, n + 1))\n    f = sum(p[:i] + p[i + 1:] + [min(p[i], p[i + 1], p[j]) for i in range(n - 1) for j in range(i + 1, n)])\n    return''.join(map(str, p[:m]))"
    },
    {
        "number": 1339,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append([l, r])\n\n    def is_covered(a, b, c, d):\n        return a <= c <= d <= b\n\n    covered_segments = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_covered(segments[i][0], segments[i][1], segments[j][0], segments[j][1]):\n                covered_segments.add(segments[i])\n                covered_segments.add(segments[j])\n\n    if not covered_segments:\n        return \"-1\"\n\n    return str(len(covered_segments))\n"
    },
    {
        "number": 1340,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    colors = set(a)\n    min_operations = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                if i == 0 or a[i - 1]!= a[i]:\n                    if j == n - 1 or a[j + 1]!= a[j]:\n                        min_operations = min(min_operations, 2)\n\n    return str(min_operations)\n"
    },
    {
        "number": 1341,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    instructions = [int(c) for c in t]\n    position = 0\n    for i, instruction in enumerate(instructions):\n        if instruction == 1:\n            position += 1\n        elif instruction == 2:\n            position -= 1\n        elif instruction == 3:\n            position += 1\n            if position > len(s):\n                position = 0\n    return str(position)"
    },
    {
        "number": 1342,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the balls by their color\n    a.sort()\n\n    # Initialize the result\n    result = 0\n\n    # Iterate through the balls\n    for i in range(n):\n        # Initialize the current set\n        current_set = set()\n\n        # Iterate through the balls\n        for j in range(i + 1, n):\n            # Check if the current ball belongs to the current set\n            if a[i] == a[j]:\n                # If it does, add it to the current set\n                current_set.add(a[i])\n            else:\n                # If it doesn't, break out of the loop\n                break\n\n        # Check if the current set is empty\n        if len(current_set) == 0:\n            # If it is, add it to the result\n            result += 1\n        else:\n            # If it's not empty, check if it contains two balls of different colors\n            if len(current_set) > 1:\n                # If it does, break out of the loop\n                break\n\n            # If it doesn't, check if the difference between their sizes is greater than 1\n            if len(current_set) == 1:\n                # If it does, break out of the loop\n                break\n\n            # If it doesn't, add it to the result\n            result += 1\n\n    # Return the result\n    return str(result)\n"
    },
    {
        "number": 1343,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v, l = map(int, stdin.split())\n        roads.append((u, v, l))\n\n    if k > 0:\n        storages = set(map(int, stdin.split()))\n    else:\n        storages = set()\n\n    def is_reachable(u, v, visited):\n        if u in visited or v in visited:\n            return False\n        visited.add(u)\n        visited.add(v)\n        return True\n\n    def find_reachable_cities(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append(v)\n        return result\n\n    def find_reachable_storages(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append(v)\n        return result\n\n    def find_reachable_paths(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities_and_reachable_storages(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities(u, visited):\n        result = []\n        for v, l in roads:\n            if is_reachable(u, v, visited):\n                result.append((u, v, l))\n        return result\n\n    def find_reachable_paths_and_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_storages_and_reachable_cities_and_reachable_"
    },
    {
        "number": 1344,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            current_length += 1\n        else:\n            current_length = 1\n\n        if current_length > max_length:\n            max_length = current_length\n\n    return str(max_length)\n"
    },
    {
        "number": 1345,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    signs = []\n    for i in range(n):\n        if a[i] <= a[i] + 1 and a[i] + 1 <= 2 * a[i]:\n            signs.append(\"+\")\n        else:\n            signs.append(\"-\")\n\n    result = \"\"\n    for sign in signs:\n        result += sign\n\n    return result"
    },
    {
        "number": 1346,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    t = 0\n    for i in range(n + m - 2):\n        if not is_prime(a[i] * b[i]):\n            t = i\n            break\n\n    return str(t)\n"
    },
    {
        "number": 1347,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    words = stdin.split()\n    synonyms = []\n    for i in range(n):\n        x, y = map(str, stdin.split())\n        synonyms.append((x, y))\n\n    def count_r(word):\n        count = 0\n        for letter in word:\n            if letter == 'R':\n                count += 1\n        return count\n\n    def min_length(words):\n        min_length = float('inf')\n        for word in words:\n            length = sum(1 for letter in word if letter == 'R')\n            min_length = min(min_length, length)\n        return min_length\n\n    def min_r_length(words):\n        min_r_length = float('inf')\n        for word in words:\n            r_count = count_r(word)\n            length = sum(1 for letter in word if letter == 'R')\n            min_r_length = min(min_r_length, length + r_count)\n        return min_r_length\n\n    min_r_length_words = [word for word in words if count_r(word) == 0]\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) < min_r_length]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_r_length(word)]\n\n    min_r_length_words = [word for word in min_r_length_words if min_length(word) == min_"
    },
    {
        "number": 1348,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n\n    if n == 1:\n        return \"-1\"\n\n    m = 0\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if d[i] + d[j] <= k:\n                m += 1\n                print(i + 1, j + 1)\n\n    return str(m)\n"
    },
    {
        "number": 1349,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n, k = map(int, stdin.strip().split())\n        x = list(map(int, stdin.strip().split()))\n        min_seconds = float('inf')\n        for i in range(k):\n            if x[i] - 1 < x[i]:\n                min_seconds = min(min_seconds, 2)\n            if x[i] - 2 < x[i]:\n                min_seconds = min(min_seconds, 3)\n            if x[i] - 3 < x[i]:\n                min_seconds = min(min_seconds, 4)\n        print(min_seconds)\n    return \"\""
    },
    {
        "number": 1350,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n    good_subsequences = []\n    for i in range(n - k + 1):\n        subsequence = s[i:i+k]\n        if subsequence in good_subsequences:\n            continue\n        good_subsequences.append(subsequence)\n    return max(len(subsequence) for subsequence in good_subsequences)"
    },
    {
        "number": 1351,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    x = l + r\n    for i in range(10):\n        if x % 10 == i:\n            x = x // 10\n    if x == l:\n        return str(x)\n    else:\n        return \"-1\""
    },
    {
        "number": 1352,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def f(l, r):\n        return sorted(filter(lambda x: l <= x <= r, a))\n\n    count = 0\n    for l in range(1, x):\n        for r in range(l, x):\n            if f(l, r) == sorted(f(l, r)):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1353,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b = map(int, stdin.split())\n    total_cost = n * a + m * b\n    min_sum = total_cost\n    for i in range(n):\n        min_sum = min(min_sum, total_cost - i * a - i * b)\n    return str(min_sum)"
    },
    {
        "number": 1354,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a = map(int, stdin.split())\n    m = int(stdin.strip())\n\n    # Alice's ships\n    alice_ships = [[] for _ in range(k)]\n    for i in range(k):\n        alice_ships[i] = [i + 1]\n\n    # Bob's ships\n    bob_ships = [[] for _ in range(m)]\n    for i in range(m):\n        bob_ships[i] = []\n\n    # Alice's moves\n    alice_moves = []\n    for i in range(m):\n        alice_moves.append(int(stdin.strip()))\n\n    # Bob's moves\n    bob_moves = []\n    for i in range(m):\n        bob_moves.append(int(stdin.strip()))\n\n    # Find Bob's first move\n    for i in range(m):\n        if len(bob_ships[i]) == 0:\n            bob_moves[i] = i + 1\n            break\n\n    # Check if Alice cheated\n    if len(alice_ships[0]) == 0:\n        return \"-1\"\n\n    return bob_moves[0]\n"
    },
    {
        "number": 1355,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    polygon = []\n    for _ in range(n):\n        polygon.append(list(map(int, stdin.split())))\n\n    lines = []\n    for _ in range(m):\n        line = []\n        for _ in range(2):\n            line.append(list(map(int, stdin.split())))\n        lines.append(line)\n\n    result = []\n    for i in range(n):\n        common_part = 0\n        for j in range(2):\n            for k in range(2):\n                if lines[i][j][k] == lines[i][j][k + 2] or lines[i][j][k] == lines[i][j + 2][k] or lines[i][j][k] == lines[i][j + 2][k + 2]:\n                    common_part += 1\n        result.append(common_part)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1356,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    good_count = 0\n    max_length = 0\n\n    for i in range(n):\n        if s[i] == 'a':\n            good_count += 1\n            if good_count > n // 2:\n                max_length = max(max_length, i - good_count + 1)\n\n    return str(max_length)"
    },
    {
        "number": 1357,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize the minimum time to complete all tasks\n    min_time = float('inf')\n\n    # Iterate through all houses\n    for i in range(1, n + 1):\n        # Find the minimum time to complete all tasks\n        time = 0\n        for j in range(i, n + 1):\n            time += a[j] - a[i - 1]\n\n        # Update the minimum time if necessary\n        if time < min_time:\n            min_time = time\n\n    return str(min_time)"
    },
    {
        "number": 1358,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    a = [int(x) for x in stdin.split()]\n    max_beauty = 0\n    for i in range(k):\n        for j in range(i+1, k):\n            beauty = sum(a[i:j+1])\n            if beauty > max_beauty:\n                max_beauty = beauty\n    return str(max_beauty)"
    },
    {
        "number": 1359,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n\n    def is_valid(a, b, c, d):\n        return 0 <= a < n and 0 <= b < n and 0 <= c < n and 0 <= d < n\n\n    def is_connected(a, b, c, d):\n        return roads[a][0] == b or roads[b][0] == c or roads[a][1] == d or roads[d][1] == c\n\n    def count_damn_rhombi(a, b, c, d):\n        if is_connected(a, b, c, d):\n            return 1\n        return 0\n\n    return str(sum(count_damn_rhombi(a, b, c, d) for a, b, c, d in itertools.combinations(range(n), 4)))\n"
    },
    {
        "number": 1360,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    min_exam_date = min(a)\n    max_exam_date = max(b)\n\n    for i in range(n):\n        if a[i] < min_exam_date:\n            min_exam_date = a[i]\n        if b[i] > max_exam_date:\n            max_exam_date = b[i]\n\n    return str(min_exam_date)"
    },
    {
        "number": 1361,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Remove the second hold\n    a.pop(1)\n\n    # Find the maximum difference of heights between adjacent holds\n    max_diff = max(a[i + 1] - a[i] for i in range(n - 1))\n\n    return str(max_diff)\n"
    },
    {
        "number": 1362,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, m = map(int, stdin.split())\n    daily_payments = [int(x) for x in stdin.split()]\n    balance = 0\n    for i in range(n):\n        balance += daily_payments[i]\n    if balance < 0:\n        return \"No\"\n    else:\n        for i in range(m):\n            if balance < 0:\n                return str(i + 1)\n        return \"Yes\""
    },
    {
        "number": 1364,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = list(map(int, stdin.strip().split()))\n\n    max_length = 0\n    current_length = 0\n\n    for i in range(n):\n        if t[i] == 1:\n            current_length += 1\n        else:\n            current_length = 0\n\n        if current_length > max_length:\n            max_length = current_length\n\n    return str(max_length)"
    },
    {
        "number": 1365,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tree = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v = map(int, stdin.split())\n        tree[u].append(v)\n        tree[v].append(u)\n\n    def dfs(u, visited, path):\n        if u in visited:\n            return 0\n        visited.add(u)\n        path.append(u)\n        for v in tree[u]:\n            if v not in visited:\n                res = dfs(v, visited, path)\n                if res:\n                    return res\n        path.pop()\n        return 1\n\n    def paint_tree(u, visited, path):\n        if u in visited:\n            return 0\n        visited.add(u)\n        path.append(u)\n        for v in tree[u]:\n            if v not in visited:\n                res = paint_tree(v, visited, path)\n                if res:\n                    return res\n        path.pop()\n        return 1\n\n    def count_ways(u, visited, path):\n        if u in visited:\n            return 0\n        visited.add(u)\n        path.append(u)\n        ways = 1\n        for v in tree[u]:\n            if v not in visited:\n                res = count_ways(v, visited, path)\n                if res:\n                    ways += res\n        path.pop()\n        return ways\n\n    def main():\n        visited = set()\n        path = []\n        for u in range(n):\n            if paint_tree(u, visited, path):\n                ways = count_ways(u, visited, path)\n                if ways % (10**9 + 7) == 0:\n                    return ways % (10**9 + 7)\n        return 0\n\n    return str(main())"
    },
    {
        "number": 1366,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    bottles = []\n    for _ in range(n):\n        brand, count = map(int, stdin.readline().strip().split())\n        bottles.append((brand, count))\n\n    def can_open(bottle):\n        brand, count = bottle\n        if brand == 1:\n            return count > 0\n        elif brand == 2:\n            return count > 1\n        elif brand == 3:\n            return count > 2\n        elif brand == 4:\n            return count > 3\n\n    def can_open_multiple(bottles):\n        for i in range(len(bottles)):\n            for j in range(i + 1, len(bottles)):\n                if can_open(bottles[i]) and can_open(bottles[j]):\n                    return False\n        return True\n\n    def find_bottles(bottles):\n        for i in range(len(bottles)):\n            for j in range(i + 1, len(bottles)):\n                if can_open_multiple(bottles[:i] + [bottles[i]] + bottles[i + 1:]):\n                    return i + 1\n        return 0\n\n    bottles.sort(key=lambda x: x[1])\n    return str(find_bottles(bottles))\n"
    },
    {
        "number": 1367,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    episodes_watched = set(a)\n    episodes_not_watched = set(range(1, n + 1)) - episodes_watched\n\n    for episode in episodes_not_watched:\n        if episode not in episodes_watched:\n            return str(episode)\n\n    return \"No episode has Polycarpus forgotten to watch.\""
    },
    {
        "number": 1368,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n\n    selected_items = set()\n    for i in range(N):\n        if i < A or i > B:\n            selected_items.add(i)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A)\n    selected_items.add(B)\n\n    selected_items.remove(A)\n    selected_items.remove(B)\n\n    selected_items.add(A"
    },
    {
        "number": 1369,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.strip().split())\n        points.append((x, y))\n\n    min_radius = float('inf')\n    for x, y in points:\n        distance = ((x - 0.5) ** 2 + (y - 0.5) ** 2) ** 0.5\n        if distance < min_radius:\n            min_radius = distance\n\n    return str(min_radius)"
    },
    {
        "number": 1370,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n    S = [list(map(int, input().split())) for _ in range(H)]\n\n    cuts = []\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == 0:\n                cuts.append((i, j))\n\n    cuts.sort(key=lambda x: (-x[0], -x[1]))\n\n    count = 0\n    for i in range(len(cuts)):\n        if i == 0 or cuts[i][0]!= cuts[i - 1][0]:\n            count += 1\n            if count == K:\n                break\n\n    return str(count)\n"
    },
    {
        "number": 1371,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin.strip())\n    count = 0\n    for i in range(1, S + 1):\n        if i % 3 == 0 and i % 4 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1372,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, N = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n\n    total_magic_points = 0\n    for i in range(N):\n        total_magic_points += A[i] * B[i]\n\n    return str(total_magic_points)"
    },
    {
        "number": 1373,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    MOD_INV = 10**9 + 7\n    MOD_INV_MOD = 10**9 + 7\n\n    def sum_of_k_numbers(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv(n: int) -> int:\n        return (MOD_INV_MOD ** n) % MOD_INV_MOD\n\n    def sum_of_k_numbers_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod_inv_mod("
    },
    {
        "number": 1374,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    m = []\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            m.append(a[i] + a[j])\n\n    m.sort()\n    m = m[N // 2]\n\n    return str(m)"
    },
    {
        "number": 1375,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            count += (a[i] + a[j]) == sum(a[:i] + a[i + 1:])\n\n    return str(count)"
    },
    {
        "number": 1376,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            min_distance = min(min_distance, abs(i-j))\n    return str(min_distance)"
    },
    {
        "number": 1377,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if j == i + 1:\n                continue\n            if j > i + 1:\n                break\n            if a[i] > a[j]:\n                break\n            if a[i] == a[j]:\n                if a[i] > a[j - 1]:\n                    break\n                else:\n                    return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1378,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    B_2k = list(map(int, stdin.strip().split()))\n\n    # Find the maximum area\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            area = abs(B_2k[i] - B_2k[j])\n            if area > max_area:\n                max_area = area\n\n    # Find the points that maximize the area\n    points = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(B_2k[i] - B_2k[j]) == max_area:\n                points.append(B_2k[i])\n                points.append(B_2k[j])\n\n    return''.join(map(str, points))\n"
    },
    {
        "number": 1379,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize the solution list\n    solution_list = []\n\n    # Iterate through each minute\n    for i in range(m):\n        # Initialize the day of the break\n        day = 1\n\n        # Iterate through each minute\n        for j in range(i, m):\n            # Calculate the number of minutes between the current minute and the next minute\n            diff = j - i\n\n            # Check if the current minute is odd or even\n            if diff % 2 == 0:\n                # If the current minute is even, check if the next minute is odd or even\n                if j + 1 < m and a[j + 1] % 2 == 0:\n                    # If the next minute is even, then the current minute is on the second day\n                    day = 2\n                else:\n                    # If the next minute is odd, then the current minute is on the first day\n                    day = 1\n            else:\n                # If the current minute is odd, then the next minute is on the second day\n                day = 2\n\n            # Add the day of the break to the solution list\n            solution_list.append(day)\n\n    # Sort the solution list in ascending order\n    solution_list.sort()\n\n    # Print the solution list\n    for day in solution_list:\n        print(day)\n\n    return \"\""
    },
    {
        "number": 1380,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def min_height(a, k):\n        if k == 0:\n            return 0\n        if k == 1:\n            return a[0]\n        if k == 2:\n            return max(a[0], a[1])\n        if k == 3:\n            return min(a[0], a[1])\n        if k == 4:\n            return max(a[0], a[1], a[2])\n        if k == 5:\n            return min(a[0], a[1], a[2])\n        if k == 6:\n            return max(a[0], a[1], a[2], a[3])\n        if k == 7:\n            return min(a[0], a[1], a[2], a[3])\n        if k == 8:\n            return max(a[0], a[1], a[2], a[3], a[4])\n        if k == 9:\n            return min(a[0], a[1], a[2], a[3], a[4])\n        if k == 10:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5])\n        if k == 11:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5])\n        if k == 12:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6])\n        if k == 13:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5], a[6])\n        if k == 14:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7])\n        if k == 15:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7])\n        if k == 16:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])\n        if k == 17:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])\n        if k == 18:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])\n        if k == 19:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])\n        if k == 20:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10])\n        if k == 21:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10])\n        if k == 22:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])\n        if k == 23:\n            return min(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])\n        if k == 24:\n            return max(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12])\n        if k == 25:\n            return min(a[0], a[1"
    },
    {
        "number": 1381,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, s, p = map(int, stdin.split())\n    packs = k * n\n    sheets_per_pack = s // p\n    packs_needed = packs // sheets_per_pack\n    return str(packs_needed)"
    },
    {
        "number": 1382,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(start, visited, cycle):\n        visited[start] = True\n        cycle.append(start)\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, cycle)\n        cycle.pop()\n\n    graph = [[] for _ in range(n)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * n\n    cycle = []\n    for i in range(n):\n        if not visited[i]:\n            dfs(i, visited, cycle)\n\n    t = len(cycle)\n    w = len(cycle) - 1\n\n    return f\"{t} {w}\""
    },
    {
        "number": 1383,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    x = 1\n    for i in range(n):\n        a[i] = (a[i] + x) % m\n\n    for i in range(n):\n        if a[i] == b[i]:\n            x = 1\n            break\n\n    return str(x)\n"
    },
    {
        "number": 1384,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n\n    max_games = 0\n    for i in range(n):\n        if s[i] == 1:\n            max_games += 1\n\n    return str(max_games)\n"
    },
    {
        "number": 1385,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lexemes = stdin.split()\n    result = \"\"\n    for i in range(len(lexemes)):\n        if i == 0:\n            result += lexemes[i]\n        elif i == len(lexemes) - 1:\n            result += lexemes[i]\n        else:\n            result += lexemes[i] + \" \"\n    return result"
    },
    {
        "number": 1386,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    n = 0\n    for i in range(1, w + 1):\n        for j in range(1, h + 1):\n            if i == 1 or i == w or j == 1 or j == h:\n                n += 1\n    return str(n % 998244353)"
    },
    {
        "number": 1387,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    visited = [False] * n\n    visited[1] = True\n\n    for i in range(2, n):\n        if a[i] - a[i - 1] == 1:\n            visited[i] = True\n\n    if not visited[t]:\n        return \"NO\"\n\n    for i in range(n - 1):\n        if a[i] - a[i + 1] == 1:\n            visited[i] = True\n\n    if not visited[t]:\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1388,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    tree = []\n    for _ in range(n):\n        a, b, c = map(int, stdin.readline().strip().split())\n        tree.append((a, b, c))\n\n    def dfs(node, target):\n        if node == -1:\n            return 0\n\n        if target == tree[node][2]:\n            return tree[node][0]\n\n        return dfs(tree[node][1], target) + dfs(tree[node][1], target ^ tree[node][0])\n\n    min_cost = float('inf')\n    for i in range(n):\n        min_cost = min(min_cost, dfs(i, tree[i][2]))\n\n    return min_cost if min_cost!= float('inf') else -1\n"
    },
    {
        "number": 1389,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    feature = [list(map(str, stdin.split())) for _ in range(m)]\n\n    # Calculate the total brightness of the pixels in the image\n    total_brightness = sum(sum(int(feature[i][j]) for j in range(m)) for i in range(n))\n\n    # Calculate the value of the feature\n    value = total_brightness - sum(sum(int(feature[i][j]) for j in range(m)) for i in range(n))\n\n    return str(value)\n"
    },
    {
        "number": 1390,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    f_1, f_2, *puzzles = map(int, stdin.split())\n\n    def is_valid_puzzle(puzzle):\n        return puzzle[0] <= 1000 and puzzle[-1] <= 1000\n\n    def is_valid_puzzle_size(puzzle):\n        return puzzle[0] <= 1000 and puzzle[-1] <= 1000\n\n    def is_valid_puzzle_count(puzzle):\n        return len(puzzle) == 1000\n\n    def is_valid_puzzle_sum(puzzle):\n        return sum(puzzle) == 1000\n\n    def is_valid_puzzle_difference(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_size(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_count(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_sum(puzzle):\n        return abs(sum(puzzle) - 1000) == 1\n\n    def is_valid_puzzle_difference_difference(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_size(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_count(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_sum(puzzle):\n        return abs(sum(puzzle) - 1000) == 1\n\n    def is_valid_puzzle_difference_difference_difference(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_size(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_count(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_sum(puzzle):\n        return abs(sum(puzzle) - 1000) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_size(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_count(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_sum(puzzle):\n        return abs(sum(puzzle) - 1000) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference_size(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference_count(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference_sum(puzzle):\n        return abs(sum(puzzle) - 1000) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference_difference(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference_difference_size(puzzle):\n        return abs(puzzle[0] - puzzle[-1]) == 1\n\n    def is_valid_puzzle_difference_difference_difference_difference_difference_difference_count(puzzle):\n        return abs(puzzle[0] - puzzle[-1"
    },
    {
        "number": 1391,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a = map(int, stdin.split())\n    b = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    # Calculate the renting price for each bike\n    p_bike = [p[i] for i in range(m)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolboy = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolchild\n    p_schoolchild = [p[i] for i in range(n)]\n\n    # Calculate the renting price for each schoolboy\n    p_schoolchild = [p[i] for i in range"
    },
    {
        "number": 1392,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for num in a:\n        if num >= 10**k:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1393,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    n = len(s)\n    m = len(t)\n    count_yay = 0\n    count_wops = 0\n\n    for i in range(n):\n        if s[i].isupper() and t[i].isupper():\n            if s[i].lower() == t[i].lower():\n                count_yay += 1\n            else:\n                count_wops += 1\n\n    return str(count_yay) + \" \" + str(count_wops)"
    },
    {
        "number": 1394,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.strip()\n    s = t.replace(\"a\", \"\")\n    s = s.replace(\"b\", \"\")\n    s = s.replace(\"c\", \"\")\n    s = s.replace(\"d\", \"\")\n    s = s.replace(\"e\", \"\")\n    s = s.replace(\"f\", \"\")\n    s = s.replace(\"g\", \"\")\n    s = s.replace(\"h\", \"\")\n    s = s.replace(\"i\", \"\")\n    s = s.replace(\"j\", \"\")\n    s = s.replace(\"k\", \"\")\n    s = s.replace(\"l\", \"\")\n    s = s.replace(\"m\", \"\")\n    s = s.replace(\"n\", \"\")\n    s = s.replace(\"o\", \"\")\n    s = s.replace(\"p\", \"\")\n    s = s.replace(\"q\", \"\")\n    s = s.replace(\"r\", \"\")\n    s = s.replace(\"s\", \"\")\n    s = s.replace(\"t\", \"\")\n    s = s.replace(\"u\", \"\")\n    s = s.replace(\"v\", \"\")\n    s = s.replace(\"w\", \"\")\n    s = s.replace(\"x\", \"\")\n    s = s.replace(\"y\", \"\")\n    s = s.replace(\"z\", \"\")\n    s = s.replace(\"A\", \"\")\n    s = s.replace(\"B\", \"\")\n    s = s.replace(\"C\", \"\")\n    s = s.replace(\"D\", \"\")\n    s = s.replace(\"E\", \"\")\n    s = s.replace(\"F\", \"\")\n    s = s.replace(\"G\", \"\")\n    s = s.replace(\"H\", \"\")\n    s = s.replace(\"I\", \"\")\n    s = s.replace(\"J\", \"\")\n    s = s.replace(\"K\", \"\")\n    s = s.replace(\"L\", \"\")\n    s = s.replace(\"M\", \"\")\n    s = s.replace(\"N\", \"\")\n    s = s.replace(\"O\", \"\")\n    s = s.replace(\"P\", \"\")\n    s = s.replace(\"Q\", \"\")\n    s = s.replace(\"R\", \"\")\n    s = s.replace(\"S\", \"\")\n    s = s.replace(\"T\", \"\")\n    s = s.replace(\"U\", \"\")\n    s = s.replace(\"V\", \"\")\n    s = s.replace(\"W\", \"\")\n    s = s.replace(\"X\", \"\")\n    s = s.replace(\"Y\", \"\")\n    s = s.replace(\"Z\", \"\")\n    return s"
    },
    {
        "number": 1395,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = int(stdin.strip())\n\n    # Find all good shifts of n\n    good_shifts = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            good_shifts.append(i)\n\n    # Find the minimum remainder\n    min_remainder = float('inf')\n    for shift in good_shifts:\n        remainder = n % shift\n        if remainder < min_remainder:\n            min_remainder = remainder\n\n    return str(min_remainder)"
    },
    {
        "number": 1396,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    row = list(map(int, stdin.split()))\n    max_balls = 0\n    for i in range(n - 2):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    for i in range(n - 1):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[n - 1] == row[n - 2] == row[n - 3]:\n        max_balls += 1\n        row[n - 1] = -1\n    for i in range(n - 2, -1, -1):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[0] == row[1] == row[2]:\n        max_balls += 1\n        row[0] = -1\n    for i in range(1, n - 1):\n        if row[i] == row[i - 1] == row[i - 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[n - 1] == row[n - 2] == row[n - 3]:\n        max_balls += 1\n        row[n - 1] = -1\n    for i in range(n - 2, -1, -1):\n        if row[i] == row[i - 1] == row[i - 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[0] == row[1] == row[2]:\n        max_balls += 1\n        row[0] = -1\n    for i in range(1, n - 1):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[n - 1] == row[n - 2] == row[n - 3]:\n        max_balls += 1\n        row[n - 1] = -1\n    for i in range(n - 2, -1, -1):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[0] == row[1] == row[2]:\n        max_balls += 1\n        row[0] = -1\n    for i in range(1, n - 1):\n        if row[i] == row[i - 1] == row[i - 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[n - 1] == row[n - 2] == row[n - 3]:\n        max_balls += 1\n        row[n - 1] = -1\n    for i in range(n - 2, -1, -1):\n        if row[i] == row[i - 1] == row[i - 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[0] == row[1] == row[2]:\n        max_balls += 1\n        row[0] = -1\n    for i in range(1, n - 1):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[n - 1] == row[n - 2] == row[n - 3]:\n        max_balls += 1\n        row[n - 1] = -1\n    for i in range(n - 2, -1, -1):\n        if row[i] == row[i + 1] == row[i + 2]:\n            max_balls += 1\n            row[i] = -1\n    if row[0] == row[1] == row[2]:\n        max_balls += 1\n        row[0] = -1\n    for i in range(1, n - 1):\n        if row[i] == row[i - 1] == row[i"
    },
    {
        "number": 1397,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = set()\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        roads.add((a, b))\n\n    visited = set()\n    queue = [(1, 1)]\n\n    while queue:\n        city, distance = queue.pop(0)\n\n        if city in visited:\n            continue\n\n        visited.add(city)\n\n        if distance == n:\n            return str(distance)\n\n        for neighbor in range(1, n + 1):\n            if neighbor not in roads and neighbor not in visited:\n                queue.append((neighbor, distance + 1))\n\n    return \"No solution found\""
    },
    {
        "number": 1398,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    measurements = list(map(int, stdin.strip().split()))\n\n    # Remove measurements with smallest and largest results that differ by more than two times\n    measurements = [measurement for measurement in measurements if measurement!= measurements[0] and measurement!= measurements[-1]]\n\n    # Find the minimum number of results to remove\n    min_results = len(measurements) - len(measurements) // 2\n\n    return str(min_results)"
    },
    {
        "number": 1399,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.strip().split())\n        points.append((x1, y1))\n        points.append((x2, y2))\n\n    points.sort()\n    covered_points = set()\n    for i in range(len(points) - 1):\n        x1, y1 = points[i]\n        x2, y2 = points[i + 1]\n        if x1 == x2 and y1 == y2:\n            continue\n        if x1 > x2 or y1 > y2:\n            continue\n        if x1 == x2:\n            if y1 > y2:\n                covered_points.add((x1, y1))\n            else:\n                covered_points.add((x1, y2))\n        elif y1 == y2:\n            if x1 > x2:\n                covered_points.add((x1, y1))\n            else:\n                covered_points.add((x2, y1))\n        else:\n            if x1 > x2:\n                covered_points.add((x1, y1))\n            if y1 > y2:\n                covered_points.add((x1, y2))\n            if x2 > x1:\n                covered_points.add((x2, y1))\n            if y2 > y1:\n                covered_points.add((x2, y2))\n\n    return str(len(covered_points))\n"
    },
    {
        "number": 1400,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    p = [1] * n\n    p[0] = 0\n    p[1] = 1\n\n    for i in range(2, n):\n        p[i] = (p[i - 1] + p[i - 2]) % (10**9 + 7)\n\n    q = [1] * n\n    q[n - 1] = 0\n    q[n - 2] = 1\n\n    for i in range(n - 3, -1, -1):\n        q[i] = (q[i + 1] + q[i + 2]) % (10**9 + 7)\n\n    P = sum(p)\n    Q = sum(q)\n\n    return str(P * Q ** (-1) % (10**9 + 7))\n"
    },
    {
        "number": 1401,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        p, c = map(int, stdin.readline().strip().split())\n        edges.append((p - 1, c))\n\n    leaves = []\n    for i in range(n):\n        if a[i] == 0:\n            leaves.append(i)\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if edges[i][0] == edges[j][0]:\n                if a[edges[i][0]] == a[edges[j][0]] + edges[i][1] and a[edges[j][0]] == a[edges[i][0]] + edges[j][1]:\n                    leaves.remove(edges[i][0])\n                    leaves.remove(edges[j][0])\n\n    return str(min(leaves))\n"
    },
    {
        "number": 1402,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    w = stdin.strip()\n\n    count = 0\n    for i in range(n):\n        count += s[i] > w[i]\n\n    return str(count % 1000000007)"
    },
    {
        "number": 1403,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def swallow(i, j):\n        if a[i] > a[j]:\n            if a[i] <= a[j] + K:\n                return True\n        return False\n\n    def swallow_sequence(i, j):\n        if i == j:\n            return [i]\n        if swallow(i, j):\n            return swallow_sequence(i + 1, j)\n        return swallow_sequence(i, j - 1)\n\n    swallow_sequence(0, n - 1)\n    return str(len(swallow_sequence(0, n - 1)))\n"
    },
    {
        "number": 1404,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Check if all elements are integers between 1 and 200\n    for i in range(n):\n        if a[i] < 1 or a[i] > 200:\n            return \"Invalid input\"\n\n    # Find the number of ways to restore the array\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == -1 or a[j] == -1:\n                continue\n            if a[i] < a[j]:\n                ways += 1\n\n    # Print the result modulo 998244353\n    result = ways % 998244353\n    return str(result)\n"
    },
    {
        "number": 1405,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Rearrange elements of the sequence\n    a[0], a[-1] = a[-1], a[0]\n    a[1:-1] = [a[i] + 2 if i > 0 else a[i] + 1 + a[i] for i in range(1, len(a) - 1)]\n\n    # Find the longest possible Fibonacci-ish prefix\n    max_length = 0\n    prefix = []\n    for i in range(n):\n        if a[i] == a[i + 1]:\n            prefix.append(a[i])\n            max_length = max(max_length, len(prefix))\n        else:\n            prefix = []\n\n    return str(max_length)"
    },
    {
        "number": 1406,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    if n * k < d:\n        return \"-1\"\n\n    students = [[] for _ in range(k)]\n    for _ in range(d):\n        for i in range(k):\n            students[i].append(0)\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            if students[i][j - 1] == students[j][j - 1]:\n                students[i][j] = students[i][j - 1] + 1\n\n    result = []\n    for i in range(k):\n        for j in range(i + 1, k):\n            if students[i][j - 1] == students[i][j]:\n                result.append(students[i][j - 1])\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 1407,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    prime_matrix = True\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 1:\n                prime_matrix = False\n                break\n\n    if prime_matrix:\n        return \"0\"\n    else:\n        moves = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == 1:\n                    matrix[i][j] += 1\n                    moves += 1\n                    break\n        return str(moves)"
    },
    {
        "number": 1408,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    books = []\n    for _ in range(n):\n        t, w = map(int, stdin.readline().strip().split())\n        books.append((t, w))\n\n    total_thickness = sum(t for t, _ in books)\n    min_thickness = total_thickness // 2\n\n    for t, w in books:\n        if t == 1:\n            min_thickness = min(min_thickness, w)\n        elif t == 2:\n            min_thickness = min(min_thickness, w + 1)\n\n    return str(min_thickness)\n"
    },
    {
        "number": 1409,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    teams = []\n    for i in range(n):\n        team = []\n        for j in range(k):\n            team.append(i+1)\n        teams.append(team)\n    return str(len(set(teams)))"
    },
    {
        "number": 1410,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c1 = list(map(int, stdin.readline().strip().split()))\n    c2 = list(map(int, stdin.readline().strip().split()))\n    c3 = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, color, visited):\n        if u in visited:\n            return\n        visited.add(u)\n        for v, w in edges[u]:\n            if w == 0:\n                continue\n            if w not in visited:\n                dfs(v, color, visited)\n            if w == color:\n                return False\n        return True\n\n    def min_cost(u, color, visited):\n        if u == n - 1:\n            return 0\n        if dfs(u, color, visited):\n            return 0\n        for v, w in edges[u]:\n            if w == 0:\n                continue\n            if w not in visited:\n                return min_cost(v, color, visited) + c1[u] + c2[v] + c3[u]\n        return float('inf')\n\n    min_cost_painting = min_cost(0, 1, set())\n    if min_cost_painting == float('inf'):\n        return \"-1\"\n\n    b = [0] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                b[i] = min(b[i], b[j])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i!= j:\n                if b[i] == b[j]:\n                    return \"-1\"\n\n    for i in range(n):\n        for j in"
    },
    {
        "number": 1411,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    pizzas = []\n    for _ in range(n):\n        pizza = list(map(int, stdin.split()))\n        pizzas.append(pizza)\n\n    max_happiness = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            happiness = pizzas[i][0] * pizzas[j][1] + pizzas[i][2] * pizzas[j][3]\n            max_happiness = max(max_happiness, happiness)\n\n    return str(max_happiness)"
    },
    {
        "number": 1412,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    coupons = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        coupons.append((l, r))\n\n    products = set()\n    for l, r in coupons:\n        for i in range(l, r + 1):\n            products.add(i)\n\n    max_products = 0\n    used_products = set()\n    for i in range(1, n + 1):\n        if i in products:\n            used_products.add(i)\n            max_products = max(max_products, len(used_products))\n\n    return str(max_products) + '\\n' + str(list(used_products))\n"
    },
    {
        "number": 1413,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i] == s[j]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1414,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for _ in range(n):\n        table.append(list(stdin.strip()))\n\n    def dfs(row, col, visited):\n        if row == n - 1 and col == m - 1:\n            return True\n\n        if row < 0 or row >= n or col < 0 or col >= m or table[row][col] == 'D' or visited[row][col]:\n            return False\n\n        visited[row][col] = True\n        if dfs(row + 1, col, visited):\n            return True\n        if dfs(row - 1, col, visited):\n            return True\n        if dfs(row, col + 1, visited):\n            return True\n        if dfs(row, col - 1, visited):\n            return True\n        visited[row][col] = False\n        return False\n\n    visited = [[False] * m for _ in range(n)]\n    if dfs(0, 0, visited):\n        return \"Poor Dima!\"\n    else:\n        return \"Poor Inna!\""
    },
    {
        "number": 1415,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, x_0, y_0 = map(int, stdin.split())\n    s = stdin.strip()\n    length = len(s)\n    tests = []\n    for i in range(length):\n        if s[i] == 'L':\n            tests.append((x_0, y_0 - 1))\n        elif s[i] == 'R':\n            tests.append((x_0, y_0 + 1))\n        elif s[i] == 'U':\n            tests.append((x_0 - 1, y_0))\n        elif s[i] == 'D':\n            tests.append((x_0 + 1, y_0))\n    tests.append((x_0, y_0))\n    tests.sort()\n    count = 0\n    for i in range(length):\n        if i == 0:\n            count += 1\n            continue\n        if tests[i][0] == tests[i - 1][0]:\n            count += 1\n        else:\n            break\n    return str(count)"
    },
    {
        "number": 1416,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the maximum amount of water that can be piled up\n    max_water = sum(a)\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [0] * n\n    for i in range(n):\n        max_water_per_friend[i] = max_water // a[i]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i + 1]) for i in range(n - 1)]\n\n    # Calculate the maximum amount of water that can be piled up for each friend\n    max_water_per_friend = [max(max_water_per_friend[i], max_water_per_friend[i"
    },
    {
        "number": 1417,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    P = [1] * (n * n)\n    P[0] = 1\n    for i in range(1, n * n):\n        P[i] = P[i - 1] * i % 998244353\n    return str(sum(1 for subarray in P if len(subarray) == n))"
    },
    {
        "number": 1418,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [1] * n\n    a[0] = 2\n    a[1] = 1\n    for i in range(2, n):\n        a[i] = a[i-1] + 1\n        while a[i] % a[i-1] == 0:\n            a[i] += 1\n    return str(n-1) + \" \" + \" \".join(map(str, a))"
    },
    {
        "number": 1419,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    ad = stdin.strip().split()\n    ad = [word.replace('-', '.') for word in ad]\n    ad =''.join(ad)\n    ad_width = max(len(word) for word in ad.split())\n    ad_lines = len(ad.split('\\n'))\n    min_width = ad_width + 2 * k\n    min_width = min(min_width, ad_lines * ad_width)\n    return str(min_width)"
    },
    {
        "number": 1420,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    d = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(a[i] - a[j]) <= d:\n                d = max(d, abs(a[i] - a[j]))\n\n    return str(d)"
    },
    {
        "number": 1421,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, visited, memo):\n        if u in visited:\n            return memo[u]\n\n        visited.add(u)\n        memo[u] = max(memo[u], dfs(u, visited, memo) + a[u])\n\n        for v in edges[u]:\n            if v not in visited:\n                memo[v] = max(memo[v], dfs(v, visited, memo))\n\n        return memo[u]\n\n    memo = {}\n    max_sum = dfs(0, set(), memo)\n    if max_sum == float('inf'):\n        return \"Impossible\"\n    return str(max_sum)\n"
    },
    {
        "number": 1422,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.strip())\n    weights = []\n    for _ in range(m):\n        weight = int(stdin.strip())\n        weights.append(weight)\n\n    total_weight = sum(weights)\n    scalepans = [0] * 4\n    for i in range(m):\n        scalepans[i % 4] += weights[i]\n\n    for i in range(4):\n        if scalepans[i] > scalepans[(i + 1) % 4]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1423,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    p = list(map(int, stdin.split()))\n\n    def compressed_sequence(c):\n        count = [0] * n\n        for i in range(n):\n            count[c[i] - l] += 1\n        return count\n\n    def find_b(c):\n        compressed_count = compressed_sequence(c)\n        for i in range(n):\n            if compressed_count[i] == 0:\n                return i\n        return -1\n\n    b = find_b(p)\n    if b == -1:\n        return \"-1\"\n\n    return \" \".join(map(str, a[:b+1]))"
    },
    {
        "number": 1424,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    friends = 0\n    for i in range(m + 1):\n        army = int(stdin.readline())\n        if army == 0:\n            friends += 1\n        else:\n            for j in range(n):\n                if army & (1 << j):\n                    friends += 1\n                    break\n    return str(friends)"
    },
    {
        "number": 1425,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"YES\"\n\n    if n == 2:\n        if a[0] < a[1] or a[0] < a[2]:\n            return \"NO\"\n        else:\n            return \"YES\"\n\n    if n == 3:\n        if a[0] < a[1] + a[2] or a[0] < a[1] + a[2] or a[0] < a[1] + a[2]:\n            return \"NO\"\n        else:\n            return \"YES\"\n\n    if n == 4:\n        if a[0] < a[1] + a[2] or a[0] < a[1] + a[2] or a[0] < a[1] + a[2] or a[0] < a[1] + a[2]:\n            return \"NO\"\n        else:\n            return \"YES\"\n\n    if n == 5:\n        if a[0] < a[1] + a[2] or a[0] < a[1] + a[2] or a[0] < a[1] + a[2] or a[0] < a[1] + a[2] or a[0] < a[1] + a[2]:\n            return \"NO\"\n        else:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1426,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(u, visited, path):\n        if u == T:\n            return True\n        if visited[u]:\n            return False\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                if dfs(v, visited, path + [u]):\n                    return True\n        return False\n\n    S, T = map(int, stdin.split())\n    visited = [False] * n\n    path = [S]\n    if not dfs(S, visited, path):\n        return \"-1\"\n\n    min_path = []\n    for u in range(n):\n        if not visited[u]:\n            min_path.append(u)\n            while u!= T:\n                u = path.pop()\n                visited[u] = False\n\n    return \" \".join(map(str, min_path))"
    },
    {
        "number": 1427,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    B = list(map(int, stdin.readline().strip().split()))\n\n    MOD = 10**9 + 7\n\n    def is_valid(a, b):\n        return 1 <= a < N and 1 <= b < N and A[a] * B[b] == A[b] * B[a]\n\n    def min_value(a, b):\n        return min(a, b) + min(B[a], B[b])\n\n    result = min_value(B[0], B[1])\n    for i in range(2, N):\n        if is_valid(i, i - 1):\n            result = min(result, min_value(B[i], B[i - 1]) + A[i - 1])\n\n    return str(result % MOD)"
    },
    {
        "number": 1428,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    D = [list(map(int, stdin.split())) for _ in range(N)]\n    c = [list(map(int, stdin.split())) for _ in range(N)]\n\n    def paint(i, j, color):\n        D[i][j] = color\n        c[i][j] = color\n\n    def paint_square(i, j):\n        if (i + j) % 3 == (i + j) % 3:\n            paint(i, j, D[i][j])\n            paint(i, j, D[(i + j) // 3][(i + j) % 3])\n        else:\n            paint(i, j, D[i][j])\n            paint(i, j, D[(i + j) // 3][(i + j) % 3])\n            paint(i, j, D[(i + j) // 3][(i + j + 1) % 3])\n            paint(i, j, D[(i + j + 1) // 3][(i + j + 1) % 3])\n            paint(i, j, D[(i + j + 1) // 3][(i + j) % 3])\n\n    for i in range(N):\n        for j in range(N):\n            paint_square(i, j)\n\n    def wrongness(i, j):\n        return D[i][j] - D[(i + j) // 3][(i + j) % 3] - D[(i + j) // 3][(i + j + 1) % 3] - D[(i + j + 1) // 3][(i + j + 1) % 3] - D[(i + j + 1) // 3][(i + j) % 3]\n\n    def sum_wrongness():\n        return sum(wrongness(i, j) for i in range(N) for j in range(N))\n\n    return str(sum_wrongness())\n"
    },
    {
        "number": 1429,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    T = list(S)\n    T.sort()\n    complements = [\"\".join(sorted(c, reverse=True)) for c in itertools.permutations(T)]\n    count = 0\n    for i in range(N):\n        if S[i] in complements[i]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1430,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    S = list(stdin.strip())\n\n    directions = []\n    for i in range(N):\n        if S[i] == '0':\n            directions.append((i, i + 1))\n        else:\n            directions.append((i, i - 1))\n\n    directions.sort(key=lambda x: x[0])\n\n    result = 0\n    for i in range(K):\n        l, r = directions[i]\n        for j in range(l, r + 1):\n            if S[j] == '0':\n                result += 1\n                break\n\n    return str(result)"
    },
    {
        "number": 1431,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    a.sort()\n\n    def is_good(a):\n        total = 0\n        for i in range(1, N + 1, 2):\n            total += sum(1 for _ in range(i) if a[i - 1] == 1)\n        return total % 2 == 0\n\n    if not any(is_good(a)):\n        return \"-1\"\n\n    for i in range(1, N + 1, 2):\n        if is_good(a[:i]):\n            print(i)\n            break"
    },
    {
        "number": 1432,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n\n    # Initialize the total amount of rain received by each mountain\n    rain_received = [0] * N\n\n    # Initialize the total amount of water accumulated by each mountain\n    water_accumulated = [0] * N\n\n    # Iterate through the mountains and accumulate the rain received\n    for i in range(N):\n        rain_received[i] += A[i]\n        water_accumulated[i] += A[i]\n\n    # Iterate through the mountains and print the rain received\n    for i in range(N):\n        print(rain_received[i])\n\n    return \"\""
    },
    {
        "number": 1433,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    plan = [list(map(int, input().split())) for _ in range(m)]\n\n    good_positions = 0\n    for i in range(n):\n        for j in range(m):\n            if plan[i][j] == 1:\n                for direction in ['left', 'right', 'up', 'down']:\n                    if plan[i][j] == 1 and plan[i][j + 1] == 0 and plan[i + 1][j] == 0 and plan[i + 1][j + 1] == 0:\n                        good_positions += 1\n\n    return str(good_positions)"
    },
    {
        "number": 1434,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    m = len(edges)\n    forest = [[] for _ in range(n)]\n    for a, b in edges:\n        forest[a].append(b)\n        forest[b].append(a)\n\n    visited = [False] * n\n    result = []\n\n    def dfs(v):\n        visited[v] = True\n        for w in forest[v]:\n            if not visited[w]:\n                dfs(w)\n        result.append(v)\n\n    for v in range(n):\n        if not visited[v]:\n            dfs(v)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1435,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    nine_count = 0\n    for i in range(1, 10):\n        if a % i == 0:\n            nine_count += 1\n            if nine_count == 2:\n                return str(i)\n    return str(a)"
    },
    {
        "number": 1436,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    events = []\n    for _ in range(n):\n        event = list(map(int, stdin.strip().split()))\n        events.append(event)\n\n    max_officers = 0\n    for i in range(n):\n        if events[i][0] == -1:\n            continue\n        max_officers = max(max_officers, events[i][1])\n\n    return str(max_officers)"
    },
    {
        "number": 1437,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i] & s[j] == s[i] and s[i] & s[j] % MOD == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1438,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    max_cookies = 0\n    for i in range(n):\n        max_cookies = max(max_cookies, a[i] + b[i])\n\n    return str(max_cookies)\n"
    },
    {
        "number": 1439,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_divisible(sum, target):\n        return sum % target == 0\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_divisible(a[i] + a[j], m):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 1440,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_triangles = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if a[i] + a[j] + a[k] <= 2**n:\n                    max_triangles += 1\n\n    return str(max_triangles)"
    },
    {
        "number": 1441,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ball_orders = []\n    for _ in range(n):\n        ball_orders.append(list(map(int, stdin.strip().split())))\n\n    max_throws = max(sum(ball_orders[i]) for i in range(n))\n    num_variants = 1\n    for i in range(n):\n        num_variants *= (max_throws - sum(ball_orders[i])) // sum(ball_orders[i])\n\n    return str(num_variants % 1000000007)"
    },
    {
        "number": 1442,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    order_book = []\n    for _ in range(n):\n        direction, price, volume = map(int, stdin.split())\n        order_book.append((direction, price, volume))\n\n    order_book.sort(key=lambda x: (-x[2], x[1]))\n\n    for i in range(s):\n        direction, price, volume = order_book[i]\n        if direction == 'B':\n            for j in range(i + 1, s):\n                if order_book[j][0] == 'B' and order_book[j][1] > price:\n                    order_book[i] = (direction, price, order_book[i][2] + order_book[j][2])\n                    order_book.pop(j)\n                    break\n        elif direction == 'S':\n            for j in range(i + 1, s):\n                if order_book[j][0] == 'S' and order_book[j][1] < price:\n                    order_book[i] = (direction, price, order_book[i][2] + order_book[j][2])\n                    order_book.pop(j)\n                    break\n\n    for i in range(s):\n        direction, price, volume = order_book[i]\n        if direction == 'B':\n            print(f\"B {price} {volume}\")\n        elif direction == 'S':\n            print(f\"S {price} {volume}\")\n\n    return '\\n'.join(map(str, order_book))"
    },
    {
        "number": 1443,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    segments = []\n    for _ in range(n):\n        l, s = map(int, stdin.readline().split())\n        segments.append((l, s))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def time_to_reach_nest(p1, p2, segments):\n        p1_dist = distance(p1, p2)\n        p2_dist = distance(p2, p1)\n        for i in range(n):\n            if segments[i][1] == 'G':\n                if i == 0:\n                    continue\n                p1_dist += segments[i-1][0]\n            elif segments[i][1] == 'W':\n                if i == n-1:\n                    continue\n                p2_dist += segments[i+1][0]\n            elif segments[i][1] == 'L':\n                if i == 0:\n                    continue\n                p1_dist += segments[i-1][0]\n                p2_dist += segments[i+1][0]\n        return min(p1_dist, p2_dist)\n\n    p1 = (0, 0)\n    p2 = (0, 0)\n    for i in range(n):\n        if segments[i][1] == 'G':\n            p1 = segments[i]\n        elif segments[i][1] == 'W':\n            p2 = segments[i]\n\n    t = time_to_reach_nest(p1, p2, segments)\n    return str(t)"
    },
    {
        "number": 1444,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    stations = list(map(int, stdin.split()))\n    stations.sort()\n    distances = [abs(stations[i] - stations[i + 1]) for i in range(n - 1)]\n    total_distance = sum(distances)\n    total_pairs = n * (n - 1) // 2\n    total_speed = 1000000000\n    min_avg_commute_time = float('inf')\n    min_stations = []\n\n    for i in range(n - k + 1):\n        avg_commute_time = total_distance / total_pairs * total_speed / 1000000000\n        if avg_commute_time < min_avg_commute_time:\n            min_avg_commute_time = avg_commute_time\n            min_stations = stations[i:i + k]\n\n    return''.join(map(str, min_stations))\n"
    },
    {
        "number": 1445,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    result = []\n    for i in range(n):\n        result.append(a[i])\n    return''.join(map(str, result))"
    },
    {
        "number": 1446,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    u = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n    x = list(map(int, stdin.split()))\n\n    # Calculate the number of bacteria of each type\n    count = [0] * k\n    for i in range(m):\n        count[c[i] - 1] += 1\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number of bacteria of each type\n    count = [sum(count[:i]) + 1 for i in range(k + 1)]\n\n    # Calculate the number"
    },
    {
        "number": 1447,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    decks = []\n    for _ in range(m):\n        deck = []\n        for _ in range(n):\n            deck.append(random.choice(list(range(1, 11))))\n        decks.append(deck)\n\n    def is_trick_successful(deck):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if decks[i][j] == decks[i][i]:\n                    return False\n        return True\n\n    def probability_of_successful_trick(deck):\n        return is_trick_successful(deck) / (m * n)\n\n    result = probability_of_successful_trick(decks[0])\n    return f\"{result:.6f}\""
    },
    {
        "number": 1448,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    m = int(stdin.strip())\n\n    grasshoppers = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        grasshoppers.append((x, y))\n\n    inside_cornfield = True\n    for x, y in grasshoppers:\n        if x < 0 or x >= n or y < 0 or y >= n - d:\n            inside_cornfield = False\n            break\n\n    for x, y in grasshoppers:\n        if x < 0 or x >= n or y < 0 or y >= n - d:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n\n    return \"\""
    },
    {
        "number": 1449,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        a = list(map(int, stdin.readline().split()))\n        m = 0\n        for i in range(n):\n            for j in range(i+1, n+1):\n                if a[i] == a[j]:\n                    m += 1\n                    if m == k:\n                        return str(m)\n        return \"-1\""
    },
    {
        "number": 1450,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == '0' and s[j] == '1':\n                s = s[:i] + '1' + s[i+1:]\n            elif s[i] == '1' and s[j] == '2':\n                s = s[:i] + '2' + s[i+1:]\n            elif s[i] == '2' and s[j] == '0':\n                s = s[:i] + '0' + s[i+1:]\n    return s"
    },
    {
        "number": 1451,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    lucky_numbers = set()\n    for num in stdin.split():\n        if len(num) > 2:\n            lucky_numbers.add(int(num))\n    return str(len(lucky_numbers))"
    },
    {
        "number": 1452,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    r = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    # Initialize the grid\n    grid = [[0] * w for _ in range(h)]\n\n    # Count the number of ways to fill the grid\n    def count_ways(r, c):\n        if r == 0 and c == 0:\n            return 1\n        if r == 0:\n            return c * count_ways(r, c - 1)\n        if c == 0:\n            return r * count_ways(r - 1, c)\n        return count_ways(r - 1, c) * count_ways(r, c - 1)\n\n    # Count the number of ways to fill the grid with the given values\n    count = 0\n    for i in range(h):\n        for j in range(w):\n            count += count_ways(r[i], c[j])\n\n    # Modulo 10^9 + 7\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1453,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    k = int(stdin.strip())\n\n    # Initialize the sugar penalty for each sweet\n    sugar_penalty = [0] * n\n\n    # Initialize the minimum total sugar penalty\n    min_penalty = float('inf')\n\n    # Iterate through each day\n    for i in range(1, n + 1):\n        # Calculate the sugar penalty for each sweet\n        sugar_penalty[i - 1] = a[i - 1]\n\n        # Iterate through each sweet that can be eaten at this day\n        for j in range(i - 1, -1, -1):\n            # Calculate the sugar penalty for the current sweet\n            sugar_penalty[j] += sugar_penalty[j + 1]\n\n            # Update the minimum total sugar penalty if the current sweet is better\n            if sugar_penalty[j] < min_penalty:\n                min_penalty = sugar_penalty[j]\n\n    # Output the minimum total sugar penalty\n    return''.join(map(str, min_penalty))\n"
    },
    {
        "number": 1454,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == 0:\n                a[i][j] = 1\n\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] > 0:\n                max_sum = max(max_sum, sum(a[i][j:j+1]))\n\n    return str(max_sum)"
    },
    {
        "number": 1455,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    m = 1\n    while m**2 <= n:\n        m *= 2\n    board = [[0] * m for _ in range(m)]\n    for _ in range(n):\n        r, c = map(int, stdin.readline().split())\n        board[r-1][c-1] = 1\n    for i in range(m):\n        for j in range(m):\n            if board[i][j] == 0:\n                for k in range(i+1, m):\n                    if board[k][j] == 0 and k!= i:\n                        board[k][j] = 1\n                        break\n                for k in range(j+1, m):\n                    if board[i][k] == 0 and k!= j:\n                        board[i][k] = 1\n                        break\n    for i in range(m):\n        for j in range(m):\n            if board[i][j] == 0:\n                return str(i+1) + \" \" + str(j+1)\n    return \"No solution found\""
    },
    {
        "number": 1456,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = []\n    for _ in range(n):\n        board.append(list(stdin.strip()))\n\n    def is_valid_move(x: int, y: int, dx: int, dy: int) -> bool:\n        if x < 1 or x > n or y < 1 or y > n:\n            return False\n        if board[x][y] == 'o':\n            return False\n        if board[x + dx][y + dy] == 'o':\n            return False\n        return True\n\n    def get_possible_moves(x: int, y: int, dx: int, dy: int) -> list:\n        moves = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i!= 0 or j!= 0:\n                    new_x = x + i\n                    new_y = y + j\n                    if is_valid_move(new_x, new_y, dx, dy):\n                        moves.append((new_x, new_y))\n        return moves\n\n    def get_attacked_cells(x: int, y: int, dx: int, dy: int) -> list:\n        attacked_cells = []\n        for i in range(-1, 2):\n            for j in range(-1, 2):\n                if i!= 0 or j!= 0:\n                    new_x = x + i\n                    new_y = y + j\n                    if is_valid_move(new_x, new_y, dx, dy):\n                        if board[new_x][new_y] == 'o':\n                            attacked_cells.append((new_x, new_y))\n        return attacked_cells\n\n    def get_possible_moves_and_attacked_cells(x: int, y: int, dx: int, dy: int) -> tuple:\n        possible_moves = get_possible_moves(x, y, dx, dy)\n        attacked_cells = get_attacked_cells(x, y, dx, dy)\n        return possible_moves, attacked_cells\n\n    def get_possible_moves_and_attacked_cells_helper(x: int, y: int, dx: int, dy: int, moves: list, attacked_cells: list) -> tuple:\n        if len(moves) == 2 * n * n:\n            return moves, attacked_cells\n        if is_valid_move(x, y, dx, dy):\n            moves.append((x, y))\n            attacked_cells.append((x, y))\n            return get_possible_moves_and_attacked_cells_helper(x + dx, y + dy, dx, dy, moves, attacked_cells)\n        return get_possible_moves_and_attacked_cells_helper(x, y + dy, dx, dy, moves, attacked_cells)\n\n    moves, attacked_cells = get_possible_moves_and_attacked_cells_helper(1, 1, 0, 0, [], [])\n    if len(moves) == 2 * n * n:\n        return 'YES\\n' + ''.join(map(str, moves)) + '\\n' + ''.join(map(str, attacked_cells))\n    else:\n        return 'NO'"
    },
    {
        "number": 1457,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ai_name = stdin.strip()\n    phone_name = \"Lastus 3000\"\n    min_chars = 0\n\n    for i in range(len(ai_name)):\n        if ai_name[i:i+len(phone_name)] == phone_name:\n            min_chars = i\n            break\n\n    return str(min_chars)"
    },
    {
        "number": 1458,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    if n == 1:\n        return \"YES\"\n    if n == 2:\n        return \"YES\"\n    if n == 3:\n        return \"YES\"\n    if n == 4:\n        return \"YES\"\n    if n == 5:\n        return \"YES\"\n    if n == 6:\n        return \"YES\"\n    if n == 7:\n        return \"YES\"\n    if n == 8:\n        return \"YES\"\n    if n == 9:\n        return \"YES\"\n    if n == 10:\n        return \"YES\"\n    if n == 11:\n        return \"YES\"\n    if n == 12:\n        return \"YES\"\n    if n == 13:\n        return \"YES\"\n    if n == 14:\n        return \"YES\"\n    if n == 15:\n        return \"YES\"\n    if n == 16:\n        return \"YES\"\n    if n == 17:\n        return \"YES\"\n    if n == 18:\n        return \"YES\"\n    if n == 19:\n        return \"YES\"\n    if n == 20:\n        return \"YES\"\n    if n == 21:\n        return \"YES\"\n    if n == 22:\n        return \"YES\"\n    if n == 23:\n        return \"YES\"\n    if n == 24:\n        return \"YES\"\n    if n == 25:\n        return \"YES\"\n    if n == 26:\n        return \"YES\"\n    if n == 27:\n        return \"YES\"\n    if n == 28:\n        return \"YES\"\n    if n == 29:\n        return \"YES\"\n    if n == 30:\n        return \"YES\"\n    if n == 31:\n        return \"YES\"\n    if n == 32:\n        return \"YES\"\n    if n == 33:\n        return \"YES\"\n    if n == 34:\n        return \"YES\"\n    if n == 35:\n        return \"YES\"\n    if n == 36:\n        return \"YES\"\n    if n == 37:\n        return \"YES\"\n    if n == 38:\n        return \"YES\"\n    if n == 39:\n        return \"YES\"\n    if n == 40:\n        return \"YES\"\n    if n == 41:\n        return \"YES\"\n    if n == 42:\n        return \"YES\"\n    if n == 43:\n        return \"YES\"\n    if n == 44:\n        return \"YES\"\n    if n == 45:\n        return \"YES\"\n    if n == 46:\n        return \"YES\"\n    if n == 47:\n        return \"YES\"\n    if n == 48:\n        return \"YES\"\n    if n == 49:\n        return \"YES\"\n    if n == 50:\n        return \"YES\"\n    if n == 51:\n        return \"YES\"\n    if n == 52:\n        return \"YES\"\n    if n == 53:\n        return \"YES\"\n    if n == 54:\n        return \"YES\"\n    if n == 55:\n        return \"YES\"\n    if n == 56:\n        return \"YES\"\n    if n == 57:\n        return \"YES\"\n    if n == 58:\n        return \"YES\"\n    if n == 59:\n        return \"YES\"\n    if n == 60:\n        return \"YES\"\n    if n == 61:\n        return \"YES\"\n    if n == 62:\n        return \"YES\"\n    if n == 63:\n        return \"YES\"\n    if n == 64:\n        return \"YES\"\n    if n == 65:\n        return \"YES\"\n    if n == 66:\n        return \"YES\"\n    if n == 67:\n        return \"YES\"\n    if n == 68:\n        return \"YES\"\n    if n == 69:\n        return \"YES\"\n    if n == 70:\n        return \"YES\"\n    if n == 71:\n        return \"YES\"\n    if n == 72:\n        return \"YES\"\n    if n == 73:\n        return \"YES\"\n    if n == 74:\n        return \"YES\"\n    if n == 75:\n        return \"YES\"\n    if n == 76:\n        return \"YES\"\n    if n == 77:\n        return \"YES\"\n    if n == 78:\n        return \"YES\"\n    if n"
    },
    {
        "number": 1459,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    distances = list(map(int, stdin.readline().strip().split()))\n    s = int(stdin.readline().strip())\n    t = int(stdin.readline().strip())\n\n    if s == t:\n        return \"0\"\n\n    distances.sort()\n    min_distance = distances[0]\n    path = [s]\n\n    for i in range(1, n):\n        distance = distances[i] - distances[i - 1]\n        if distance < min_distance:\n            min_distance = distance\n            path = [i]\n        elif distance == min_distance:\n            path.append(i)\n\n    return str(min_distance)\n"
    },
    {
        "number": 1460,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 0\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or i == n - 1 or j == 0 or j == n - 1:\n                k += 1\n                print(k)\n            else:\n                print(i, j)"
    },
    {
        "number": 1461,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    f = list(map(int, stdin.split()))\n    w = list(map(int, stdin.split()))\n\n    s = [0] * n\n    m = [float('inf')] * n\n\n    for i in range(1, n):\n        s[i] = s[i - 1] + w[i - 1]\n        m[i] = min(m[i - 1], w[i - 1])\n\n    for i in range(n - k + 1):\n        s[i] += f[i]\n        m[i] = min(m[i], f[i])\n\n    for i in range(n - k):\n        print(s[i], m[i])\n\n    return \"\""
    },
    {
        "number": 1462,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cards = list(stdin.strip())\n    coins = [0] * n\n    for i in range(n):\n        if cards[i] == 'D':\n            coins[i] = 9\n        else:\n            coins[i] = 1\n    for i in range(k):\n        card = input()\n        if card == 'D':\n            coins[i] += 9\n        else:\n            coins[i] += 1\n    max_coins = max(coins)\n    return str(max_coins)"
    },
    {
        "number": 1463,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    good = True\n\n    for i in range(n):\n        for j in range(n):\n            if a[i][j] == 1:\n                for k in range(n):\n                    if a[i][k] == 1 and a[k][j] == 1:\n                        good = False\n                        break\n            if not good:\n                break\n\n    return \"Yes\" if good else \"No\""
    },
    {
        "number": 1464,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    titles = []\n    for _ in range(n):\n        title = input().strip()\n        titles.append(title)\n\n    titles.sort(key=lambda x: (-len(x), x))\n    return titles[0]"
    },
    {
        "number": 1465,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    children = list(map(lambda x: x.strip(), stdin.split()))\n    moves = []\n    for i in range(k):\n        moves.append(children.pop(0))\n        moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves.append(children.pop(0))\n    moves"
    },
    {
        "number": 1466,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        x, y, w = map(int, stdin.split())\n        edges.append((x, y, w))\n\n    graph = [[] for _ in range(n + 1)]\n    for x, y, w in edges:\n        graph[x].append((y, w))\n        graph[y].append((x, w))\n\n    visited = [False] * (n + 1)\n    good_vertices = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, graph, visited, good_vertices)\n\n    e = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if graph[i][j][1] > 0:\n                e += 1\n\n    return str(e) + \" \" + \" \".join(map(str, good_vertices))\n\n\ndef"
    },
    {
        "number": 1467,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_segments = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            xor = sum(a[i:j])\n            if xor == 0:\n                max_segments = max(max_segments, j - i)\n\n    return str(max_segments)"
    },
    {
        "number": 1468,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hashtags = []\n    for _ in range(n):\n        hashtag = input().strip()\n        if hashtag[0] == '#' and len(hashtag) > 1:\n            hashtags.append(hashtag)\n    hashtags.sort()\n    result = []\n    for hashtag in hashtags:\n        if hashtag[0] == '#' and len(hashtag) > 1:\n            result.append(hashtag)\n    return '\\n'.join(result)"
    },
    {
        "number": 1469,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.readline().strip())\n    N = L + 1\n    M = int(stdin.readline().strip())\n    graph = [[0] * N for _ in range(N)]\n    for _ in range(M):\n        u, v, w = map(int, stdin.readline().strip().split())\n        graph[u - 1][v - 1] = w\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[j][i] = graph[i][j]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range(N):\n            if graph[i][j] > 0:\n                graph[i][j] += graph[j][i]\n    for i in range(N):\n        for j in range("
    },
    {
        "number": 1470,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = int(stdin.strip())\n    if x < 1 or x > 10**15:\n        return \"Invalid input\"\n\n    def rotate_die(side):\n        if side == 1:\n            return 6, 5, 4, 3, 2, 1\n        elif side == 2:\n            return 5, 4, 3, 2, 1, 6\n        elif side == 3:\n            return 4, 3, 2, 1, 6, 5\n        elif side == 4:\n            return 3, 2, 1, 6, 5, 4\n        elif side == 5:\n            return 2, 1, 6, 5, 4, 3\n        elif side == 6:\n            return 1, 6, 5, 4, 3, 2\n\n    def count_operations(side):\n        y = 0\n        while True:\n            y += 1\n            if y in [1, 2, 3, 4, 5, 6]:\n                break\n            if sum(rotate_die(side)) == 7:\n                return y\n\n    operations = 0\n    while True:\n        side = random.choice([1, 2, 3, 4, 5, 6])\n        operations += count_operations(side)\n        if operations >= x:\n            break\n\n    return str(operations)\n"
    },
    {
        "number": 1471,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = [0] * n\n    for _ in range(n - 1):\n        u, v, w = map(int, stdin.readline().strip().split())\n        colors[u - 1] = 1\n        colors[v - 1] = 1\n\n    for i in range(n):\n        if colors[i] == 0:\n            colors[i] = 1\n            for j in range(i + 1, n):\n                if colors[j] == 0:\n                    colors[j] = 1\n                    if colors[i] % 2 == 0 and colors[j] % 2 == 0:\n                        print(0, end=\"\")\n                    else:\n                        print(1, end=\"\")\n                    break\n\n    return \"\\n\".join(map(str, colors))\n"
    },
    {
        "number": 1472,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    graph = [[0] * N for _ in range(N)]\n    for i in range(N - 1):\n        graph[i][i + 1] = 1\n    graph[X - 1][Y] = 1\n    graph[Y][X - 1] = 1\n\n    def dijkstra(start):\n        visited = [False] * N\n        dist = [float('inf')] * N\n        dist[start] = 0\n        queue = [(0, start)]\n\n        while queue:\n            current_dist, current = queue.pop(0)\n            if current == end:\n                return current_dist\n\n            for neighbor, weight in graph[current].items():\n                if not visited[neighbor] and dist[neighbor] > current_dist + weight:\n                    dist[neighbor] = current_dist + weight\n                    queue.append((dist[neighbor], neighbor))\n                    visited[neighbor] = True\n\n        return -1\n\n    start = 1\n    end = N - 1\n    shortest_distance = dijkstra(start)\n    if shortest_distance == -1:\n        return \"No such path exists.\"\n\n    print(shortest_distance)\n\n    return \" \".join(map(str, [shortest_distance] * 4))"
    },
    {
        "number": 1473,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    queue = []\n    for _ in range(n):\n        a, b = map(int, stdin.strip().split())\n        queue.append((a, b))\n\n    result = []\n    for i in range(n):\n        if i == 0:\n            result.append(queue[i][0])\n        elif i == n - 1:\n            result.append(queue[i][1])\n        else:\n            result.append(queue[i][0] + queue[i + 1][0] + queue[i + 2][0])\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1474,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    h = list(map(int, stdin.strip().split()))\n\n    # Count the number of ways to cut exactly one connected part\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if h[i] + h[j] == h[i] + h[j + 1]:\n                ways += 1\n\n    # Divide the number of ways by 1 000 000 007 (10^9 + 7)\n    r = ways // (10**9 + 7)\n\n    return str(r)\n"
    },
    {
        "number": 1475,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of ways to choose one digit from each block\n    ways = 0\n    for i in range(b):\n        for j in range(n):\n            ways += (a[i] // (10 ** j)) % x\n\n    # Print the result modulo 10^9 + 7\n    print(ways % (10**9 + 7))\n\n    return str(ways)\n"
    },
    {
        "number": 1476,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = 0\n    for i in range(1, n):\n        if i > 0 and i + 1 < n and i % 2 == 0:\n            k += 1\n    return str(k)"
    },
    {
        "number": 1477,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    tasks = [[] for _ in range(N)]\n    dependencies = [[] for _ in range(M)]\n\n    for _ in range(M):\n        T_1, T_2 = map(int, stdin.split())\n        tasks[T_1].append(T_2)\n        dependencies[T_2].append(T_1)\n\n    def dfs(task, visited):\n        if task in visited:\n            return 0\n\n        visited.add(task)\n        result = 1\n\n        for dep in dependencies[task]:\n            result += dfs(dep, visited)\n\n        return result\n\n    for i in range(N):\n        if not tasks[i]:\n            return \"0\"\n\n    visited = set()\n    result = dfs(0, visited)\n\n    return str(result)\n"
    },
    {
        "number": 1478,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    comments = stdin.strip().split(',')\n    \n    # Initialize variables\n    max_depth = 0\n    comments_feed = []\n    \n    # Iterate over the comments\n    for comment in comments:\n        # Split the comment into its components\n        components = comment.strip().split(',')\n        \n        # Initialize variables\n        depth = 0\n        comment_text = ''\n        parent_comments = []\n        \n        # Iterate over the components\n        for component in components:\n            # If the component is a comment, add it to the comment_text\n            if component.startswith('['):\n                comment_text += component[1:]\n            # If the component is a number, add it to the depth\n            elif component.isdigit():\n                depth = int(component)\n            # If the component is a parent comment, add it to the parent_comments list\n            elif component.startswith('('):\n                parent_comments.append(int(component[1:-1]))\n            # If the component is a closing parenthesis, decrement the depth\n            elif component == ')':\n                depth -= 1\n        \n        # If the depth is greater than the maximum depth, update the maximum depth\n        if depth > max_depth:\n            max_depth = depth\n        \n        # Add the comment to the comments_feed\n        comments_feed.append((depth, comment_text, parent_comments))\n    \n    # Print the comments in the desired format\n    for depth, comment_text, parent_comments in comments_feed:\n        for i in range(depth):\n            print(' ', end='')\n        print(comment_text)\n        for parent_comment in parent_comments:\n            print(',', end='')\n        print()"
    },
    {
        "number": 1479,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    park = []\n    for _ in range(n):\n        park.append(list(stdin.strip()))\n\n    def dfs(row, col, seen):\n        if row == 0:\n            return 0\n        if col == 0:\n            return 1\n        if park[row - 1][col] == \".\":\n            return 0\n        if park[row - 1][col] == \"L\":\n            seen[row - 1][col] = True\n            return 1 + dfs(row - 1, col - 1, seen)\n        if park[row - 1][col] == \"R\":\n            seen[row - 1][col] = True\n            return 1 + dfs(row - 1, col + 1, seen)\n        if park[row - 1][col] == \"U\":\n            seen[row - 1][col] = True\n            return 1 + dfs(row - 1, col, seen)\n        if park[row - 1][col] == \"D\":\n            seen[row - 1][col] = True\n            return 1 + dfs(row - 1, col, seen)\n        return 0\n\n    seen = [[False] * m for _ in range(n)]\n    start_row = 0\n    start_col = 0\n    for i in range(1, n):\n        for j in range(1, m):\n            if park[i][j] == \"L\":\n                start_row = i\n                start_col = j\n                break\n\n    result = []\n    for i in range(1, n):\n        for j in range(1, m):\n            if park[i][j] == \"L\":\n                result.append(dfs(i, j, seen))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 1480,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    leader = 1\n    eliminated = 0\n    for i in range(k):\n        if i == 0:\n            leader = a[i]\n        else:\n            leader = (leader + a[i]) % n\n        eliminated = (eliminated + 1) % n\n        if i == k - 1:\n            print(eliminated)\n        else:\n            print(leader)\n    return \"\""
    },
    {
        "number": 1481,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = []\n    for _ in range(n):\n        board.append(list(stdin.strip()))\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'x':\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == 'o':\n                        board[i][j] = 'x'\n                        board[k][j] = 'o'\n                        break\n            elif board[i][j] == 'o':\n                for k in range(i + 1, n):\n                    if board[k][j] == 'o':\n                        board[i][j] = 'x'\n                        board[k][j] = 'o'\n                        break\n\n    for row in board:\n        print(''.join(row))\n\n    return 'YES' if sum(1 for row in board if sum(1 for cell in row if cell == 'o') % 2 == 0) == n * n else 'NO'"
    },
    {
        "number": 1482,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    segments = [a[i:i+k] for i in range(0, n*k, k)]\n    segments.sort()\n    result = []\n    for i in range(n):\n        result.append(segments[i])\n    return''.join(map(str, result))"
    },
    {
        "number": 1483,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n    result = []\n\n    for i in range(1, n + 1):\n        if i in p:\n            result.append(i)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1484,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    good_count = 0\n    for i in range(n):\n        if a[i] == -1:\n            for j in range(i + 1, n):\n                if a[j] == -1:\n                    if j - i + 1 % 2 == 1:\n                        good_count += 1\n                        break\n\n    return str(good_count % 998244353)"
    },
    {
        "number": 1485,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cards = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        cards.append((a, b))\n\n    def is_even(num):\n        return num % 2 == 0\n\n    def choose_card(cards):\n        for i in range(len(cards)):\n            for j in range(i + 1, len(cards)):\n                if is_even(cards[i][0]) and is_even(cards[j][0]) and (cards[i][0] + cards[j][0]) % 2 == 0:\n                    return (cards[i][0] + cards[j][0]) // 2, cards[i][1]\n        return None\n\n    def choose_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return choose_cards(cards, num // 2)\n        return choose_cards(choose_cards(cards, num // 2), num // 2)\n\n    def get_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_cards(cards, num // 2)\n        return get_cards(get_cards(cards, num // 2), num // 2)\n\n    def get_actions(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions(cards, num // 2)\n        return get_actions(get_cards(cards, num // 2), num // 2)\n\n    def get_actions_and_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions_and_cards(cards, num // 2)\n        return get_actions_and_cards(get_actions(cards, num // 2), num // 2)\n\n    def get_actions_and_cards_and_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions_and_cards_and_cards(cards, num // 2)\n        return get_actions_and_cards_and_cards(get_actions_and_cards(cards, num // 2), num // 2)\n\n    def get_actions_and_cards_and_cards_and_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions_and_cards_and_cards_and_cards(cards, num // 2)\n        return get_actions_and_cards_and_cards_and_cards(get_actions_and_cards_and_cards(cards, num // 2), num // 2)\n\n    def get_actions_and_cards_and_cards_and_cards_and_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions_and_cards_and_cards_and_cards_and_cards(cards, num // 2)\n        return get_actions_and_cards_and_cards_and_cards_and_cards(get_actions_and_cards_and_cards_and_cards(cards, num // 2), num // 2)\n\n    def get_actions_and_cards_and_cards_and_cards_and_cards_and_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions_and_cards_and_cards_and_cards_and_cards_and_cards(cards, num // 2)\n        return get_actions_and_cards_and_cards_and_cards_and_cards_and_cards(get_actions_and_cards_and_cards_and_cards_and_cards(cards, num // 2), num // 2)\n\n    def get_actions_and_cards_and_cards_and_cards_and_cards_and_cards_and_cards(cards, num):\n        if num == 1:\n            return cards\n        if num % 2 == 0:\n            return get_actions_and_cards_and_cards_and_cards_and_cards_and_cards_and_cards(cards, num // 2)\n        return get_actions_and_cards_and_cards_and_cards_and_cards_"
    },
    {
        "number": 1486,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cities = list(map(int, stdin.strip().split()))\n    min_costs = [float('inf')] * n\n    max_costs = [0] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_costs[i] = min(min_costs[i], cities[i] + cities[j])\n            max_costs[i] = max(max_costs[i], cities[i] + cities[j])\n\n    for i in range(n):\n        print(f\"{i} {min_costs[i]} {max_costs[i]}\")\n\n    return \"\""
    },
    {
        "number": 1487,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    n = len(s)\n    if n!= len(t):\n        return \"impossible\"\n\n    distances = [0] * (10 ** 5)\n    for i in range(n):\n        distances[ord(s[i])] += 1\n        distances[ord(t[i])] -= 1\n\n    for i in range(10 ** 5):\n        if distances[i] == 0:\n            return \"\".join(map(str, range(10)))\n\n    return \"impossible\""
    },
    {
        "number": 1488,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    def is_irreducible(a, b):\n        return gcd(a, b) == 1\n\n    def fraction_to_decimal(fraction):\n        numerator, denominator = fraction\n        return numerator / denominator\n\n    def average_distance(routes):\n        total_distance = sum(route[1] for route in routes)\n        numerator = sum(route[0] for route in routes)\n        denominator = n * lcm(a[0], a[-1])\n        return fraction_to_decimal((numerator, denominator))\n\n    routes = [(a[i], a[i + 1]) for i in range(n - 1)]\n    routes.append((a[-1], a[0]))\n\n    return str(average_distance(routes))\n"
    },
    {
        "number": 1489,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    def is_vertical(p1, p2):\n        return p1[1] == p2[1]\n\n    def is_horizontal(p1, p2):\n        return p1[0] == p2[0]\n\n    def is_line(p1, p2):\n        return is_vertical(p1, p2) or is_horizontal(p1, p2)\n\n    def is_collinear(p1, p2, p3):\n        return is_vertical(p1, p2) and is_vertical(p2, p3) and is_horizontal(p1, p3)\n\n    def is_collinear_with(p1, p2, p3):\n        return is_collinear(p1, p2, p3) and is_collinear(p2, p3, p1)\n\n    def is_collinear_with_line(p1, p2, p3):\n        return is_collinear_with(p1, p2, p3) and is_line(p1, p2) and is_line(p2, p3)\n\n    def is_collinear_with_line_and_point(p1, p2, p3):\n        return is_collinear_with_line(p1, p2, p3) and is_line(p1, p3)\n\n    def count_collinear_with_line_and_point(p1, p2, p3):\n        count = 0\n        for i in range(n):\n            if is_collinear_with_line_and_point(points[i], points[(i + 1) % n], points[(i + 2) % n]):\n                count += 1\n        return count\n\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if is_collinear_with_line_and_point(points[i], points[j], points[(j + 1) % n]):\n                count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1490,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of distinct types of toys\n    count = {}\n    for i in a:\n        if i in count:\n            count[i] += 1\n        else:\n            count[i] = 1\n\n    # Find the maximum number of distinct types of toys\n    max_count = max(count.values())\n\n    # Find the number of distinct types of toys that Tanya can choose\n    k = 0\n    for i in range(1, max_count + 1):\n        if count[i] == i:\n            k += 1\n\n    # Find the types of toys that Tanya can choose\n    t = []\n    for i in range(1, max_count + 1):\n        if count[i] == i:\n            t.append(i)\n\n    # Print the result\n    print(k)\n    print(' '.join(map(str, t)))\n\n    return ''"
    },
    {
        "number": 1491,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Finding the number of moves required to make exactly n / 2 piles contain number of candies that is a square of some integer and exactly n / 2 piles contain number of candies that is not a square of any integer\n    moves = 0\n    for i in range(n // 2):\n        if a[i] % 2 == 0:\n            moves += 1\n        else:\n            moves += 2\n\n    return str(moves)"
    },
    {
        "number": 1492,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    map_str = stdin.strip()\n\n    def is_burnt(x, y):\n        return map_str[x][y] == 'X'\n\n    def is_burning(x, y):\n        return is_burnt(x, y - 1) or is_burnt(x, y + 1) or is_burnt(x - 1, y) or is_burnt(x + 1, y)\n\n    def is_burned(x, y):\n        return map_str[x][y] == '.'\n\n    def get_burning_trees(x, y):\n        trees = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and is_burning(nx, ny):\n                trees.append((nx, ny))\n        return trees\n\n    def get_burned_trees(x, y):\n        trees = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and is_burned(nx, ny):\n                trees.append((nx, ny))\n        return trees\n\n    def get_max_time(x, y):\n        max_time = 0\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and is_burning(nx, ny):\n                time = get_max_time(nx, ny) + 1\n                if time > max_time:\n                    max_time = time\n        return max_time\n\n    def get_possible_trees(x, y):\n        trees = []\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not is_burning(nx, ny) and not is_burned(nx, ny):\n                trees.append((nx, ny))\n        return trees\n\n    def get_certificate(x, y):\n        burning_trees = get_burning_trees(x, y)\n        burned_trees = get_burned_trees(x, y)\n        possible_trees = get_possible_trees(x, y)\n        return '\\n'.join([''.join(map_str[x:x+m]) for x in range(0, n, m) for m in range(1, m+1)])\n\n    certificate = get_certificate(0, 0)\n    return certificate"
    },
    {
        "number": 1493,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = [list(input()) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == \".\":\n                continue\n            if board[i][j] == \"W\":\n                board[i][j] = \"B\"\n            else:\n                board[i][j] = \"-\"\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == \"W\" and i > 0 and board[i-1][j] == \"B\":\n                board[i][j] = \"B\"\n            elif board[i][j] == \"B\" and i < n-1 and board[i+1][j] == \"W\":\n                board[i][j] = \"B\"\n            elif board[i][j] == \"B\" and j > 0 and board[i][j-1] == \"W\":\n                board[i][j] = \"B\"\n            elif board[i][j] == \"W\" and j < m-1 and board[i][j+1] == \"B\":\n                board[i][j] = \"B\"\n\n    result = []\n    for row in board:\n        row_str = \"\".join(row)\n        if row_str == \"W\" or row_str == \"B\":\n            result.append(row_str)\n        else:\n            result.append(\"-\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 1494,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, p = stdin.strip().split()\n    s = s[:len(s) - int(p)]\n    s = ''.join(sorted(set(s), reverse=True))\n    return''.join(str(len(s)) +'' +''.join(s[i:i+int(p)] for i in range(len(s))))"
    },
    {
        "number": 1495,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    min_operations = float('inf')\n\n    for i in range(n):\n        if i == 0:\n            min_operations = min(min_operations, 1)\n        else:\n            min_operations = min(min_operations, 2)\n\n    return str(min_operations)\n"
    },
    {
        "number": 1496,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    # Calculate the exchange rates\n    d = [1] * n\n    for i in range(1, n):\n        d[i] = d[i - 1] * a[i - 1] / b[i - 1]\n\n    # Calculate the conversion rates\n    e = [1] * n\n    for i in range(1, n):\n        e[i] = e[i - 1] * t[i - 1] / c[i - 1]\n\n    # Find the minimum day index\n    min_day = 1\n    for i in range(1, n):\n        if d[i] < d[min_day]:\n            min_day = i\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_days += 1\n\n    # Find the number of gadgets to buy\n    num_gadgets = 0\n    for i in range(1, n):\n        if d[i] >= min_day:\n            num_gadgets += 1\n\n    # Find the number of days to buy\n    num_days = 0\n    for i in range("
    },
    {
        "number": 1497,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rows = []\n    for _ in range(n):\n        row = input().strip()\n        rows.append(row)\n\n    max_rows = 0\n    for i in range(n):\n        for j in range(n):\n            if rows[i][j] == '1':\n                max_rows = max(max_rows, i + 1)\n\n    return str(max_rows)"
    },
    {
        "number": 1498,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    tasks = []\n    for _ in range(q):\n        t, k, d = map(int, stdin.split())\n        tasks.append((t, k, d))\n\n    tasks.sort(key=lambda x: x[0])\n\n    result = []\n    for t, k, d in tasks:\n        if t <= 2 * d:\n            result.append(k)\n        else:\n            result.append(-1)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1499,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = []\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            result.append(i)\n            result.append(j)\n    return''.join(map(str, result))"
    },
    {
        "number": 1501,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = stdin.split()[1]\n    y = list(map(int, stdin.split()[2:]))\n\n    # Calculate the number of possible values of s\n    s = ''.join(sorted(set(p)))\n    s_length = len(s)\n    num_s = (1 << s_length) - 1\n\n    # Calculate the number of possible values of p\n    p_length = len(p)\n    num_p = (1 << p_length) - 1\n\n    # Calculate the number of possible values of y\n    y_length = len(y)\n    num_y = (1 << y_length) - 1\n\n    # Calculate the number of possible values of Malekas' subsequence\n    subseq_length = n - p_length + 1\n    num_subseq = (1 << subseq_length) - 1\n\n    # Calculate the number of possible values of s and p\n    num_values = num_s * num_p * num_y * num_subseq * num_p\n\n    # Calculate the number of possible values of Malekas' subsequence\n    num_male_subseq = (1 << subseq_length) - 1\n\n    # Calculate the number of possible values of s and p\n    num_male_values = num_male_values = num_male_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values = num_values * num_male_values\n\n    # Calculate the number of possible values of s and p\n    num_values ="
    },
    {
        "number": 1502,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    return str(a)"
    },
    {
        "number": 1503,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    permutations = []\n    for _ in range(m):\n        permutation = list(map(int, stdin.split()))\n        permutations.append(permutation)\n\n    def is_permutation(permutation):\n        return all(permutation[i] == permutation[i + 1] for i in range(len(permutation) - 1))\n\n    def common_prefix(permutation):\n        return permutation[:len(permutation) // 2]\n\n    def common_suffix(permutation):\n        return permutation[-len(permutation) // 2:]\n\n    def delete_prefix(permutation):\n        return permutation[:len(permutation) // 2]\n\n    def delete_suffix(permutation):\n        return permutation[-len(permutation) // 2:]\n\n    def count_ways(permutation):\n        common_part = common_prefix(permutation)\n        if not is_permutation(common_part):\n            return 0\n\n        common_part = common_suffix(permutation)\n        if not is_permutation(common_part):\n            return 0\n\n        delete_prefix_permutation = delete_prefix(permutation)\n        delete_suffix_permutation = delete_suffix(permutation)\n\n        if not is_permutation(delete_prefix_permutation):\n            return 0\n\n        if not is_permutation(delete_suffix_permutation):\n            return 0\n\n        return 1 + count_ways(delete_prefix_permutation) + count_ways(delete_suffix_permutation)\n\n    ways = 0\n    for permutation in permutations:\n        ways += count_ways(permutation)\n\n    return str(ways)\n"
    },
    {
        "number": 1504,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        k = int(stdin.readline().strip())\n        l1 = int(stdin.readline().strip())\n        r1 = int(stdin.readline().strip())\n        l2 = int(stdin.readline().strip())\n        r2 = int(stdin.readline().strip())\n\n        # Step 1: Choose one segment from the first list\n        al_1 = [l1, r1]\n        bl_1 = [l2, r2]\n\n        # Step 2: Extend the chosen segment by 1\n        al_1[0] -= 1\n        bl_1[0] -= 1\n\n        # Step 3: Choose one segment from the second list\n        al_2 = [l1, r1]\n        bl_2 = [l2, r2]\n\n        # Step 4: Extend the chosen segment by 1\n        al_2[0] -= 1\n        bl_2[0] -= 1\n\n        # Step 5: Calculate the total intersection\n        I = 0\n        for i in range(n):\n            I += min(al_1[i], al_2[i]) + min(bl_1[i], bl_2[i])\n\n        # Step 6: Check if the total intersection is greater or equal to k\n        if I >= k:\n            print(I)\n        else:\n            print(k - I)"
    },
    {
        "number": 1505,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        px, py, vx, vy, a, b, c, d = map(int, stdin.strip().split())\n        points.append((px, py))\n\n    # Sort points in counter-clockwise order\n    points.sort(key=lambda x: (-x[0], -x[1]))\n\n    # Calculate arrow points coordinates\n    arrow_points = []\n    for i in range(n):\n        x, y = points[i]\n        vx, vy = vx, vy\n        if i == 0:\n            arrow_points.append((x, y))\n        else:\n            dx, dy = points[i - 1] - points[i]\n            angle = math.atan2(dy, dx)\n            x1 = x + c * math.cos(angle)\n            y1 = y + c * math.sin(angle)\n            x2 = x + d * math.cos(angle)\n            y2 = y + d * math.sin(angle)\n            arrow_points.append((x1, y1))\n            arrow_points.append((x2, y2))\n\n    # Print arrow points coordinates\n    for point in arrow_points:\n        print(f\"{point[0]:.9f} {point[1]:.9f}\")\n\n    return \"\\n\".join(map(str, arrow_points))"
    },
    {
        "number": 1506,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    f_a = 0\n    M = 1\n\n    for i in range(2, n + 1):\n        if a[M] < a[i]:\n            f_a += a[M]\n            M = i\n\n    return str(f_a)"
    },
    {
        "number": 1507,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    entrances = list(map(str.upper, stdin.split()))\n    guards = [0] * 26\n\n    for entrance in entrances:\n        guards[ord(entrance[0]) - ord('A')] += 1\n\n    for i in range(1, n):\n        entrance = entrances[i]\n        guards[ord(entrance[0]) - ord('A')] -= 1\n        if guards[ord(entrance[0]) - ord('A')] == 0:\n            return 'NO'\n\n    for i in range(k):\n        if guards[i] == 0:\n            return 'YES'\n\n    return 'NO'"
    },
    {
        "number": 1508,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Sort the array in ascending order\n    a.sort()\n\n    # Calculate the sum of differences between adjacent integers\n    diff_sum = sum(a[i] - a[i + 1] for i in range(n - 1))\n\n    # Calculate the largest possible value of an arrangement\n    max_value = diff_sum + a[n - 1]\n\n    # Find the lexicographically smallest sequence x that corresponds to an arrangement of the largest possible value\n    x = [a[0]]\n    for i in range(1, n):\n        x.append(x[i - 1] + a[i])\n\n    # Print the required sequence x\n    print(\" \".join(map(str, x)))\n\n    return \" \".join(map(str, x))"
    },
    {
        "number": 1509,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def f(l, r):\n        count = 0\n        for i in range(n):\n            if a[i] >= l and a[i] <= r:\n                count += 1\n        return count\n\n    result = sum(f(l, r) for l in range(1, n) for r in range(l, n+1))\n    return str(result)"
    },
    {
        "number": 1510,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Find maximum value of b\n    max_b = max(b)\n\n    # Find minimum value of a\n    min_a = min(a)\n\n    # Find minimum number of operations required to satisfy Devu's condition\n    operations = 0\n\n    # Increase a_1 by 1\n    if a[0] < max_b:\n        a[0] += 1\n        operations += 1\n\n    # Decrease b_2 by 1\n    if b[1] > min_a:\n        b[1] -= 1\n        operations += 1\n\n    # Decrease b_2 by 1\n    if b[1] > min_a:\n        b[1] -= 1\n        operations += 1\n\n    return str(operations)"
    },
    {
        "number": 1511,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    instructions = []\n    for _ in range(m):\n        instructions.append(list(map(int, stdin.split())))\n\n    def simulate(cycle):\n        locked = set()\n        for i in range(n):\n            if cycle % instructions[i][i] == 0:\n                locked.add(i)\n\n        if not locked:\n            return cycle\n\n        for i in range(n):\n            if i in locked:\n                continue\n\n            for j in range(i + 1, n):\n                if j in locked:\n                    continue\n\n                if instructions[i][j] == 0:\n                    continue\n\n                if instructions[i][j] == cycle % instructions[i][j]:\n                    locked.add(i)\n                    locked.add(j)\n                    return cycle\n\n        return cycle\n\n    result = []\n    for cycle in range(1, m + 1):\n        result.append(simulate(cycle))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1512,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    p.sort()\n    p.reverse()\n\n    for i in range(n - 1, 0, -1):\n        if p[i] < p[i - 1]:\n            p[i], p[i - 1] = p[i - 1], p[i]\n            break\n\n    return str(p[0])"
    },
    {
        "number": 1513,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    broken_segments = list(map(int, stdin.split()))\n    total_length = 0\n\n    for i in range(n):\n        if broken_segments[i] == m:\n            total_length += 1\n            if i < k - 1:\n                total_length += 1\n\n    return str(total_length)"
    },
    {
        "number": 1514,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b_1, b_2, b_3, b_4, b_5 = map(int, stdin.readline().strip().split())\n    c_1, c_2, c_3, c_4, c_5 = map(int, stdin.readline().strip().split())\n\n    if n == 1:\n        return str(b_1)\n\n    b = [min(b_i, b_i + 1) for b_i in range(n - 1)]\n    c = [max(b_i, b_i + 1) for b_i in range(n - 1)]\n    b_prime = [b[p_i] for p_i in range(n - 1)]\n    c_prime = [c[p_i] for p_i in range(n - 1)]\n\n    if n == 2:\n        return str(b_prime[0]) + \" \" + str(c_prime[0])\n\n    if n == 3:\n        return str(b_prime[0]) + \" \" + str(c_prime[0]) + \" \" + str(b_prime[1]) + \" \" + str(c_prime[1]) + \" \" + str(b_prime[2]) + \" \" + str(c_prime[2])\n\n    if n == 4:\n        return str(b_prime[0]) + \" \" + str(c_prime[0]) + \" \" + str(b_prime[1]) + \" \" + str(c_prime[1]) + \" \" + str(b_prime[2]) + \" \" + str(c_prime[2]) + \" \" + str(b_prime[3]) + \" \" + str(c_prime[3])\n\n    if n == 5:\n        return str(b_prime[0]) + \" \" + str(c_prime[0]) + \" \" + str(b_prime[1]) + \" \" + str(c_prime[1]) + \" \" + str(b_prime[2]) + \" \" + str(c_prime[2]) + \" \" + str(b_prime[3]) + \" \" + str(c_prime[3]) + \" \" + str(b_prime[4]) + \" \" + str(c_prime[4])\n\n    if n == 6:\n        return str(b_prime[0]) + \" \" + str(c_prime[0]) + \" \" + str(b_prime[1]) + \" \" + str(c_prime[1]) + \" \" + str(b_prime[2]) + \" \" + str(c_prime[2]) + \" \" + str(b_prime[3]) + \" \" + str(c_prime[3]) + \" \" + str(b_prime[4]) + \" \" + str(c_prime[4]) + \" \" + str(b_prime[5]) + \" \" + str(c_prime[5])\n\n    if n == 7:\n        return str(b_prime[0]) + \" \" + str(c_prime[0]) + \" \" + str(b_prime[1]) + \" \" + str(c_prime[1]) + \" \" + str(b_prime[2]) + \" \" + str(c_prime[2]) + \" \" + str(b_prime[3]) + \" \" + str(c_prime[3]) + \" \" + str(b_prime[4]) + \" \" + str(c_prime[4]) + \" \" + str(b_prime[5]) + \" \" + str(c_prime[5]) + \" \" + str(b_prime[6]) + \" \" + str(c_prime[6])\n\n    if n == 8:\n        return str(b_prime[0]) + \" \" + str(c_prime[0]) + \" \" + str(b_prime[1]) + \" \" + str(c_prime[1]) + \" \" + str(b_prime[2]) + \" \" + str(c_prime[2]) + \" \" + str(b_prime[3]) + \" \" + str(c_prime[3]) + \" \" + str(b_prime[4]) + \" \" + str(c_prime[4]) + \" \" + str(b_prime[5]) + \" \" + str(c_prime[5]) + \" \" + str(b_prime[6]) + \" \" + str(c_prime[6"
    },
    {
        "number": 1515,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, x = map(int, stdin.split())\n    if p > 10**6 or x > 9:\n        return \"Impossible\"\n\n    beautiful_number = 1\n    for i in range(p):\n        beautiful_number *= beautiful_number\n\n    for i in range(x):\n        beautiful_number *= beautiful_number\n\n    return str(beautiful_number)\n"
    },
    {
        "number": 1516,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    MOD = 998244353\n    MOD_INV = 10**9 + 7\n    MOD_INV_MOD = MOD_INV % MOD\n    MOD_INV_MOD_INV = MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD % MOD\n    MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV = MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV_MOD_INV"
    },
    {
        "number": 1517,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            for k in range(j, n + 1):\n                if (i + j + k) % n == 0:\n                    count += 1\n    return str(count % 1000000007)"
    },
    {
        "number": 1518,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_prime(j - i + 1):\n                k += 1\n                swap(a, i, j)\n\n    return str(k)\n\n\ndef"
    },
    {
        "number": 1519,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, a = map(int, stdin.split())\n    breaks = 0\n    for i in range(n):\n        t, l = map(int, stdin.split())\n        if t + l <= t + l - a:\n            breaks += 1\n    return str(breaks)"
    },
    {
        "number": 1520,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(str.lower, stdin.strip().split()))\n    beauty = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            beauty = max(beauty, len(p[i]) + len(p[j]))\n    return str(beauty)"
    },
    {
        "number": 1521,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, n = map(int, stdin.split())\n    conflicts = [0] * p\n    for _ in range(n):\n        x = int(stdin.readline())\n        bucket = h(x)\n        conflicts[bucket] = x\n        if conflicts[bucket] == x:\n            conflicts[bucket] = -1\n    for i in range(p):\n        if conflicts[i] == -1:\n            return i\n    return -1\n\ndef"
    },
    {
        "number": 1522,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    keys = stdin.strip().split()\n    keys = [key.lower() for key in keys]\n    doors = stdin.strip().split()\n    doors = [door.lower() for door in doors]\n\n    def is_valid_key(key):\n        return key in keys\n\n    def is_valid_door(door):\n        return door in doors\n\n    def get_door_key(door):\n        return doors.index(door) % 2, keys.index(door)\n\n    def get_door_type(door):\n        return doors[doors.index(door) // 2]\n\n    def get_door_key_type(door_key):\n        return keys[door_key[0]] + keys[door_key[1]]\n\n    def get_door_key_type_count(door_key_type):\n        return keys.count(door_key_type)\n\n    def get_door_key_type_count_dict(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_sorted(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_sorted_reverse(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count_dict(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count_dict_sorted(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count_dict_sorted_reverse(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count_dict_sorted_reverse_count(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count_dict_sorted_reverse_count_dict(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_reverse_sorted_reverse_count_dict_sorted_reverse_count_dict_sorted(door_key_type):\n        return {key: keys.count(key) for key in keys if keys.count(key) == keys.count(door_key_type)}\n\n    def get_door_key_type_count_dict_"
    },
    {
        "number": 1523,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the minimum total time\n    total_time = sum(b)\n\n    # Calculate the minimum time to persuade the idlers\n    min_time = sum(b)\n\n    # Calculate the minimum number of jobs to be done\n    min_jobs = min(k, n)\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [0] * n\n\n    for i in range(n):\n        min_jobs_by_idler[i] = min(min_jobs, min_jobs_by_idler[i])\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by_idler = [min_jobs_by_idler[i] for i in range(n)]\n\n    # Calculate the minimum number of jobs to be done by each idler\n    min_jobs_by"
    },
    {
        "number": 1524,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    children = [0] * n\n    for i in range(n):\n        children[i] = int(stdin[i])\n    moves = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if children[i] == 0 and children[j] == 0:\n                moves += 1\n                children[i], children[j] = children[j], children[i]\n    return''.join(map(str, children))"
    },
    {
        "number": 1525,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n\n    def is_valid_amidakuji(h: int, w: int, k: int) -> bool:\n        # Check if there are no two horizontal lines share an endpoint\n        for i in range(1, w):\n            if h == 1 or h == 2 or h == H:\n                if i == 1 or i == w:\n                    continue\n                if h == 1:\n                    if i == 2:\n                        continue\n                if h == 2:\n                    if i == 1:\n                        continue\n                if h == H:\n                    if i == 3:\n                        continue\n                return False\n\n        # Check if the two endpoints of each horizontal lines are at the same height\n        for i in range(1, w):\n            if h == 1 or h == 2 or h == H:\n                if i == 1 or i == w:\n                    continue\n                if h == 1:\n                    if i == 2:\n                        continue\n                if h == 2:\n                    if i == 1:\n                        continue\n                if h == H:\n                    if i == 3:\n                        continue\n                if h!= 1 and h!= 2 and h!= H:\n                    return False\n\n        # Check if a horizontal line must connect adjacent vertical lines\n        for i in range(1, w):\n            if h == 1 or h == 2 or h == H:\n                if i == 1 or i == w:\n                    continue\n                if h == 1:\n                    if i == 2:\n                        continue\n                if h == 2:\n                    if i == 1:\n                        continue\n                if h == H:\n                    if i == 3:\n                        continue\n                if h!= 1 and h!= 2 and h!= H:\n                    return False\n\n        # Check if we reach the bottom of the K-th vertical line from the left\n        for i in range(1, k):\n            if h == 1 or h == 2 or h == H:\n                if i == 1 or i == w:\n                    continue\n                if h == 1:\n                    if i == 2:\n                        continue\n                if h == 2:\n                    if i == 1:\n                        continue\n                if h == H:\n                    if i == 3:\n                        continue\n                if h!= 1 and h!= 2 and h!= H:\n                    return False\n\n        return True\n\n    count = 0\n    for h in range(1, H + 1):\n        for w in range(1, W + 1):\n            if is_valid_amidakuji(h, w, K):\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 1526,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    operations = 0\n    while a!= b!= c:\n        a += 1\n        b += 1\n        c += 1\n        operations += 2\n    return str(operations)"
    },
    {
        "number": 1527,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    S = []\n    for _ in range(H):\n        S.append(list(stdin.strip()))\n\n    moves = 0\n    visited = set()\n    queue = [(0, 0)]\n\n    while queue:\n        row, col = queue.pop(0)\n\n        if (row, col) in visited:\n            continue\n\n        visited.add((row, col))\n\n        if row == H - 1 and col == W - 1:\n            moves += 1\n            break\n\n        for i in range(1, W):\n            if S[row][i] == '#':\n                queue.append((row, i))\n            elif S[row][i] == '..':\n                queue.append((row, i))\n                queue.append((row, i + 1))\n                queue.append((row + 1, i))\n                queue.append((row + 1, i + 1))\n\n    return str(moves)"
    },
    {
        "number": 1528,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    patties = 0\n    for i in range(N):\n        patties += X - i\n    return str(patties)"
    },
    {
        "number": 1529,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sentences = stdin.splitlines()\n    freda_sentences = []\n    rainbow_sentences = []\n\n    for sentence in sentences:\n        if \"lala\" in sentence:\n            freda_sentences.append(sentence)\n        elif \"miao\" in sentence:\n            rainbow_sentences.append(sentence)\n\n    if len(freda_sentences) == len(rainbow_sentences):\n        return \"OMG>.< I don't know!\"\n    elif len(freda_sentences) > len(rainbow_sentences):\n        return \"Freda's\"\n    else:\n        return \"Rainbow's\""
    },
    {
        "number": 1531,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # subproblem A1\n    max_appeal = max(a)\n    min_appeal = min(a)\n    max_appeal_trees = sum(a) - max_appeal\n    min_appeal_trees = min_appeal - max_appeal\n\n    # subproblem A2\n    max_appeal_trees_left = max(a)\n    min_appeal_trees_left = min(a)\n    max_appeal_trees_left_sum = sum(a) - max_appeal_trees_left\n    min_appeal_trees_left_sum = min_appeal_trees_left - max_appeal_trees_left\n\n    # subproblem B\n    max_appeal_trees_right = max(a)\n    min_appeal_trees_right = min(a)\n    max_appeal_trees_right_sum = sum(a) - max_appeal_trees_right\n    min_appeal_trees_right_sum = min_appeal_trees_right - max_appeal_trees_right\n\n    # subproblem C\n    max_appeal_trees_left_right = max(a)\n    min_appeal_trees_left_right = min(a)\n    max_appeal_trees_left_right_sum = sum(a) - max_appeal_trees_left_right\n    min_appeal_trees_left_right_sum = min_appeal_trees_left_right - max_appeal_trees_left_right\n\n    # subproblem D\n    max_appeal_trees_left_right_sum = max(a)\n    min_appeal_trees_left_right_sum = min(a)\n    max_appeal_trees_left_right_sum_trees = sum(a) - max_appeal_trees_left_right_sum\n    min_appeal_trees_left_right_sum_trees = min_appeal_trees_left_right_sum - max_appeal_trees_left_right_sum\n\n    # subproblem E\n    max_appeal_trees_left_right_sum_trees = max(a)\n    min_appeal_trees_left_right_sum_trees = min(a)\n    max_appeal_trees_left_right_sum_trees_trees = sum(a) - max_appeal_trees_left_right_sum_trees\n    min_appeal_trees_left_right_sum_trees_trees = min_appeal_trees_left_right_sum_trees - max_appeal_trees_left_right_sum_trees\n\n    # subproblem F\n    max_appeal_trees_left_right_sum_trees_trees = max(a)\n    min_appeal_trees_left_right_sum_trees_trees = min(a)\n    max_appeal_trees_left_right_sum_trees_trees_trees = sum(a) - max_appeal_trees_left_right_sum_trees_trees\n    min_appeal_trees_left_right_sum_trees_trees_trees = min_appeal_trees_left_right_sum_trees_trees - max_appeal_trees_left_right_sum_trees_trees\n\n    # subproblem G\n    max_appeal_trees_left_right_sum_trees_trees_trees = max(a)\n    min_appeal_trees_left_right_sum_trees_trees_trees = min(a)\n    max_appeal_trees_left_right_sum_trees_trees_trees_trees = sum(a) - max_appeal_trees_left_right_sum_trees_trees_trees\n    min_appeal_trees_left_right_sum_trees_trees_trees_trees = min_appeal_trees_left_right_sum_trees_trees_trees - max_appeal_trees_left_right_sum_trees_trees_trees\n\n    # subproblem H\n    max_appeal_trees_left_right_sum_trees_trees_trees_trees = max(a)\n    min_appeal_trees_left_right_sum_trees_trees_trees_trees = min(a)\n    max_appeal_trees_left_right_sum_trees_trees_trees_trees_trees = sum(a) - max_appeal_trees_left_right_sum_trees_trees_trees_trees\n    min_appeal_trees_left_"
    },
    {
        "number": 1532,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    I = [0] * (n - 1)\n    for i in range(1, n):\n        for j in range(i):\n            if gcd(i, j) == 1:\n                I[i - 1] = j\n                break\n    return''.join(map(str, I))\n\ndef"
    },
    {
        "number": 1533,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    names = stdin.strip().split('\\n')\n    result = []\n\n    for name in names:\n        if name in result:\n            result.remove(name)\n        else:\n            result.append(name)\n\n    for i in range(n):\n        name = names[i]\n        if name in result:\n            result[result.index(name)] = \"YES\"\n        else:\n            result.append(\"NO\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 1534,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    beautiful = \"\"\n    for i in range(n):\n        if i == 0 or i == n - 1:\n            beautiful += stdin[i]\n        else:\n            if stdin[i] == \"a\" and stdin[i - 1] == \"a\" and stdin[i + 1] == \"b\":\n                beautiful += \"a\"\n            elif stdin[i] == \"b\" and stdin[i - 1] == \"b\" and stdin[i + 1] == \"a\":\n                beautiful += \"b\"\n            else:\n                beautiful += stdin[i]\n    return beautiful"
    },
    {
        "number": 1535,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x_0, y_0 = map(int, stdin.split())\n    stormtroopers = []\n    for i in range(n):\n        x, y = map(int, stdin.split())\n        stormtroopers.append((x, y))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def shoot(stormtrooper):\n        x, y = stormtroooper\n        dx, dy = 0, 0\n        while True:\n            dx, dy = -dy, dx\n            if distance((x, y), (x + dx, y + dy)) <= 1:\n                break\n        return dx, dy\n\n    def destroy_stormtroopers(stormtroopers):\n        for stormtrooper in stormtroopers:\n            dx, dy = shoot(stormtrooper)\n            stormtroopers.remove(stormtrooper)\n            x, y = stormtroopers[0]\n            dx, dy = -dy, dx\n            while distance((x, y), (x + dx, y + dy)) <= 1:\n                dx, dy = -dy, dx\n            stormtroopers.append((x + dx, y + dy))\n\n    destroy_stormtroopers(stormtroopers)\n    return len(stormtroopers)"
    },
    {
        "number": 1536,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.readline().strip().split())\n        points.append((x, y, z))\n\n    def is_valid(a, b, c):\n        return (a[0] <= c[0] <= b[0]) and (a[1] <= c[1] <= b[1]) and (a[2] <= c[2] <= b[2])\n\n    def remove_points(points, snap):\n        removed = set()\n        for i in range(snap):\n            for j in range(i + 1, snap):\n                a, b = points[i], points[j]\n                if not is_valid(a, b, points[i + 1]):\n                    removed.add(i)\n                    removed.add(j)\n        return removed\n\n    def snap_points(points, snap):\n        points.sort(key=lambda x: x[0])\n        for i in range(snap):\n            points.append(points[i])\n        return points\n\n    points = snap_points(points, n // 2)\n    removed = remove_points(points, n // 2)\n    result = []\n    for i in removed:\n        result.append(i + 1)\n    return''.join(map(str, result))\n"
    },
    {
        "number": 1537,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    lines = stdin.splitlines()\n    white_lines = 0\n\n    for i in range(n):\n        for j in range(k):\n            if lines[i][j] == 'W':\n                white_lines += 1\n\n    return str(white_lines)\n"
    },
    {
        "number": 1538,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(i, j, seen):\n        if i == n:\n            return True\n        if j in seen:\n            return False\n        if a[i] > a[j]:\n            seen.add(j)\n            if dfs(i + 1, j, seen):\n                return True\n            seen.remove(j)\n        return False\n\n    return str(min(1, dfs(0, 0, set())))"
    },
    {
        "number": 1539,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    legs = list(map(int, stdin.readline().strip().split()))\n    d = list(map(int, stdin.readline().strip().split()))\n\n    stable_legs = [legs[i] for i in range(n) if legs[i] <= legs[i+1]]\n    max_leg_length = max(legs)\n\n    if len(stable_legs) < 3:\n        return \"0\"\n\n    min_energy = 0\n    for leg in stable_legs:\n        if leg <= max_leg_length:\n            min_energy += leg * d[leg-1]\n\n    return str(min_energy)"
    },
    {
        "number": 1540,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n    events = [list(map(int, stdin.split())) for _ in range(k)]\n\n    message_notifications = [0] * n\n\n    for event in events:\n        x, y = event\n        message_notifications[x - 1] += 1\n        message_notifications[y - 1] += 1\n\n    for i in range(1, n + 1):\n        if a[i - 1][i - 1] == 1:\n            message_notifications[i - 1] += 1\n\n    return''.join(map(str, message_notifications))\n"
    },
    {
        "number": 1541,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the lever description\n    s = stdin.strip()\n\n    # Initialize the lever\n    lever = 0\n\n    # Iterate over the string\n    for i in range(len(s)):\n        # If the character is \"^\", update the lever\n        if s[i] == \"^\":\n            lever += 1\n        # If the character is \"=\", update the lever\n        elif s[i] == \"=\":\n            lever -= 1\n\n        # If the lever is in balance, print \"balance\"\n        if lever == 0:\n            return \"balance\"\n\n    # If the lever is not in balance, print \"left\" or \"right\"\n    if lever == 0:\n        return \"left\"\n    else:\n        return \"right\""
    },
    {
        "number": 1542,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    q = int(stdin.readline().strip())\n    m = list(map(int, stdin.readline().strip().split()))\n\n    result = []\n\n    for i in range(q):\n        if i == 0:\n            result.append(0)\n        else:\n            result.append(min(m[i - 1], x[i - 1] // m[i - 1]))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1543,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cities = []\n    for _ in range(n):\n        x, c = map(int, stdin.strip().split())\n        cities.append((x, c))\n\n    def is_disputed(c):\n        return c == 'P'\n\n    def is_byteland(c):\n        return c == 'B'\n\n    def is_berland(c):\n        return c == 'R'\n\n    def is_reachable(city, cities):\n        for other_city in cities:\n            if city == other_city:\n                continue\n            if is_byteland(city) and is_berland(other_city) and is_reachable(other_city, cities):\n                return True\n            if is_berland(city) and is_byteland(other_city) and is_reachable(other_city, cities):\n                return True\n            if is_disputed(city) and is_disputed(other_city) and is_reachable(other_city, cities):\n                return True\n        return False\n\n    def min_total_cost(cities):\n        total_cost = 0\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                total_cost += abs(cities[i][0] - cities[j][0])\n        return total_cost\n\n    def connect_cities(cities):\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                if is_reachable(cities[i], cities) and is_reachable(cities[j], cities):\n                    total_cost = min_total_cost([cities[i], cities[j]])\n                    print(total_cost)\n\n    connect_cities(cities)\n    return \"OK\""
    },
    {
        "number": 1544,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ways = 0\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            ways += i*j\n    return str(ways)"
    },
    {
        "number": 1545,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    max_length = max(a)\n    min_substrings = min(len(s) for s in a)\n\n    ways = 0\n    max_length_substring = 0\n    min_substrings_substring = 0\n\n    for i in range(max_length + 1):\n        ways += (n // i) * (n // i)\n        max_length_substring = max(max_length_substring, i)\n\n    for i in range(1, max_length + 1):\n        min_substrings_substring = min(min_substrings_substring, len(a) // i)\n\n    return str(ways % (10**9 + 7)) + \" \" + str(max_length_substring) + \" \" + str(min_substrings_substring)\n"
    },
    {
        "number": 1546,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    arcs = []\n    for _ in range(2 * n):\n        a, b = map(int, stdin.strip().split())\n        arcs.append((a, b))\n\n    def dfs(start, visited, path):\n        if start in visited:\n            return\n        visited.add(start)\n        path.append(start)\n        for neighbor in arcs[start]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path)\n        path.pop()\n\n    visited = set()\n    path = []\n    dfs(1, visited, path)\n    return \" \".join(map(str, path)) if path else \"-1\""
    },
    {
        "number": 1547,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    table = [[0] * m for _ in range(n)]\n    for _ in range(k):\n        row, col, color = map(int, stdin.split())\n        table[row - 1][col - 1] = color\n    for row in range(n):\n        for col in range(m):\n            if table[row][col] == 0:\n                for i in range(row - 1, -1, -1):\n                    if table[i][col] == 0:\n                        table[i][col] = table[row][col]\n                        break\n                for j in range(col - 1, -1, -1):\n                    if table[row][j] == 0:\n                        table[row][j] = table[row][col]\n                        break\n    result = []\n    for row in table:\n        result.append(' '.join(map(str, row)))\n    return '\\n'.join(result)"
    },
    {
        "number": 1548,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sticks = list(map(int, stdin.readline().strip().split()))\n\n    def is_valid(stick):\n        if stick == 0:\n            return False\n        if stick == 1:\n            return True\n        if stick % 2 == 0:\n            return False\n        return True\n\n    def is_valid_polyline(polyline):\n        for i in range(len(polyline) - 1):\n            if polyline[i] == polyline[i + 1]:\n                return False\n        return True\n\n    def is_valid_stick(stick):\n        if stick == 0:\n            return False\n        if stick == 1:\n            return True\n        if stick % 2 == 0:\n            return False\n        return True\n\n    def is_valid_stick_polyline(stick, polyline):\n        if not is_valid_stick(stick):\n            return False\n        if not is_valid_polyline(polyline):\n            return False\n        return True\n\n    def is_valid_stick_polyline_pair(stick1, stick2, polyline):\n        if not is_valid_stick(stick1) or not is_valid_stick(stick2):\n            return False\n        if not is_valid_stick_polyline(stick1, polyline) or not is_valid_stick_polyline(stick2, polyline):\n            return False\n        return True\n\n    def is_valid_stick_polyline_pair_pair(stick1, stick2, polyline1, polyline2):\n        if not is_valid_stick_polyline_pair(stick1, stick2, polyline1) or not is_valid_stick_polyline_pair(stick1, stick2, polyline2):\n            return False\n        if not is_valid_stick_polyline_pair(stick2, stick1, polyline1) or not is_valid_stick_polyline_pair(stick2, stick1, polyline2):\n            return False\n        return True\n\n    def is_valid_stick_polyline_pair_pair_pair(stick1, stick2, polyline1, polyline2, polyline3, polyline4):\n        if not is_valid_stick_polyline_pair_pair(stick1, stick2, polyline1, polyline2):\n            return False\n        if not is_valid_stick_polyline_pair_pair(stick1, stick2, polyline3, polyline4):\n            return False\n        if not is_valid_stick_polyline_pair_pair(stick2, stick1, polyline3, polyline4):\n            return False\n        return True\n\n    def is_valid_stick_polyline_pair_pair_pair_pair(stick1, stick2, polyline1, polyline2, polyline3, polyline4, polyline5, polyline6):\n        if not is_valid_stick_polyline_pair_pair_pair(stick1, stick2, polyline1, polyline2, polyline3, polyline4):\n            return False\n        if not is_valid_stick_polyline_pair_pair_pair(stick1, stick2, polyline5, polyline6):\n            return False\n        if not is_valid_stick_polyline_pair_pair_pair(stick2, stick1, polyline5, polyline6):\n            return False\n        return True\n\n    def is_valid_stick_polyline_pair_pair_pair_pair_pair(stick1, stick2, polyline1, polyline2, polyline3, polyline4, polyline5, polyline6, polyline7, polyline8):\n        if not is_valid_stick_polyline_pair_pair_pair_pair(stick1, stick2, polyline1, polyline2, polyline3, polyline4, polyline5, polyline6):\n            return False\n        if not is_valid_stick_polyline_pair_pair_pair_pair(stick1, stick2, polyline7, polyline8):\n            return False\n        if not is_valid_stick_polyline_pair_pair_pair_pair(stick2, stick1, polyline7, polyline8):\n            return False\n        return True\n\n    def is_valid_stick_polyline_pair_pair_pair_pair_pair_pair(stick1, stick2, polyline1, polyline2, polyline3, polyline4, polyline5, polyline6, polyline7, polyline8, polyline9, polyline10):\n        if not is_valid_stick_polyline_pair_pair_pair_pair_pair"
    },
    {
        "number": 1549,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    # Calculate the number of olympiads before the rule was introduced\n    num_olympiads = n + q\n\n    # Calculate the number of years Misha's mother is interested in\n    num_years = k[0]\n\n    # Calculate the host city of each next olympiad\n    host_city = [a[i] for i in range(1, num_olympiads + 1)]\n\n    # Calculate the number of times each host city was hosted before\n    host_city_counts = [0] * m\n    for i in range(1, num_olympiads + 1):\n        host_city_counts[host_city.index(a[i])] += 1\n\n    # Calculate the smallest index of the host city with the smallest number of times before\n    smallest_index = min(i for i, count in enumerate(host_city_counts) if count == min(host_city_counts))\n\n    # Calculate the host city of the first olympiad\n    first_olympiad_host_city = host_city[smallest_index]\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[smallest_index + 1]\n\n    # Calculate the number of olympiads before the new city was introduced\n    num_olympiads_before_new_city = n + 1\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city]\n\n    # Calculate the number of years Misha's mother is interested in\n    num_years = k[num_olympiads_before_new_city]\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city + 1]\n\n    # Calculate the number of olympiads before the new city was introduced\n    num_olympiads_before_new_city = n + 1\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city]\n\n    # Calculate the number of years Misha's mother is interested in\n    num_years = k[num_olympiads_before_new_city]\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city + 1]\n\n    # Calculate the number of olympiads before the new city was introduced\n    num_olympiads_before_new_city = n + 1\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city]\n\n    # Calculate the number of years Misha's mother is interested in\n    num_years = k[num_olympiads_before_new_city]\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city + 1]\n\n    # Calculate the number of olympiads before the new city was introduced\n    num_olympiads_before_new_city = n + 1\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city]\n\n    # Calculate the number of years Misha's mother is interested in\n    num_years = k[num_olympiads_before_new_city]\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city + 1]\n\n    # Calculate the number of olympiads before the new city was introduced\n    num_olympiads_before_new_city = n + 1\n\n    # Calculate the host city of the next olympiad\n    next_olympiad_host_city = host_city[num_olympiads_before_new_city]\n\n    # Calculate the number of years Misha's mother is interested in\n    num_years = k[num_olympiads_before_new_city]\n\n    # Calculate the host city of the"
    },
    {
        "number": 1550,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    digits = list(map(int, stdin.strip().split()))\n    digits.reverse()\n    smallest_number = min(digits)\n    desired_number = smallest_number * 10 ** n\n    return str(desired_number)"
    },
    {
        "number": 1551,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    people = []\n    for _ in range(n):\n        x, v, t = map(int, stdin.split())\n        people.append((x, v, t))\n\n    bomb_x, bomb_v, bomb_t = people[0]\n    bomb_x, bomb_v, bomb_t = bomb_x, bomb_v, bomb_t\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def direction(x1, y1, x2, y2):\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0 and dy == 0:\n            return 1\n        elif dx > 0 and dy > 0:\n            return 2\n        elif dx < 0 and dy > 0:\n            return 3\n        elif dx > 0 and dy < 0:\n            return 4\n        elif dx < 0 and dy < 0:\n            return 5\n\n    def run_time(x, v, t):\n        return t * v\n\n    def run_speed(x, v, t):\n        return v\n\n    def run_direction(x, v, t):\n        return direction(x, y, x, y)\n\n    def run_time_and_speed(x, v, t):\n        return run_time(x, v, t), run_speed(x, v, t)\n\n    def run_time_and_speed_and_direction(x, v, t):\n        return run_time_and_speed(x, v, t), run_direction(x, y, x, y)\n\n    def run_time_and_speed_and_direction_and_distance(x, v, t):\n        return run_time_and_speed_and_direction(x, v, t), distance(x, y, x, y)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction(x, v, t):\n        return run_time_and_speed_and_direction_and_distance(x, v, t), direction(x, y, x, y)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction_and_run_time(x, v, t):\n        return run_time_and_speed_and_direction_and_distance_and_direction(x, v, t), run_time(x, v, t)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed(x, v, t):\n        return run_time_and_speed_and_direction_and_distance_and_direction_and_run_time(x, v, t), run_speed(x, v, t)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed_and_direction(x, v, t):\n        return run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed(x, v, t), run_direction(x, y, x, y)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed_and_direction_and_distance(x, v, t):\n        return run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed_and_direction(x, v, t), distance(x, y, x, y)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed_and_direction_and_distance_and_direction(x, v, t):\n        return run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed_and_direction_and_distance(x, v, t), run_direction(x, y, x, y)\n\n    def run_time_and_speed_and_direction_and_distance_and_direction_and_run_time_and_speed_and_direction_and_distance_and_direction_and_run_time(x, v, t):"
    },
    {
        "number": 1552,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n\n    # Count the number of good children\n    good_children = sum(t[:n])\n\n    # Count the number of teams\n    num_teams = 0\n    for i in range(n):\n        if t[i] == 1:\n            num_teams += 1\n        elif t[i] == 2:\n            num_teams += 2\n        elif t[i] == 3:\n            num_teams += 3\n\n    # Check if there are any teams\n    if num_teams == 0:\n        return \"0\"\n\n    # Form teams\n    teams = []\n    for i in range(num_teams):\n        team = []\n        for j in range(n):\n            if t[j] == 1:\n                team.append(i + 1)\n            elif t[j] == 2:\n                team.append(i + 2)\n            elif t[j] == 3:\n                team.append(i + 3)\n        teams.append(team)\n\n    # Sort teams by the number of good children\n    teams.sort(key=lambda x: sum(t[x]))\n\n    # Print the teams\n    for team in teams:\n        print(\" \".join(map(str, team)))\n\n    return \" \".join(map(str, teams[0]))\n"
    },
    {
        "number": 1553,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    bottles = list(map(int, stdin.split()))\n\n    def is_valid(bottle, row, col):\n        if row == 0:\n            return True\n        if col == 0:\n            return True\n        if bottle > bottles[row - 1]:\n            return True\n        return False\n\n    def find_optimal_location(bottle, row, col):\n        if is_valid(bottle, row, col):\n            return (row, col)\n        if row > 0:\n            return find_optimal_location(bottle, row - 1, col)\n        if col > 0:\n            return find_optimal_location(bottle, row, col - 1)\n        return None\n\n    optimal_location = find_optimal_location(bottles[0], n, 0)\n    if optimal_location is None:\n        return \"n\"\n\n    k = 1\n    while True:\n        if is_valid(k, n, 0):\n            break\n        k += 1\n\n    return str(k)\n"
    },
    {
        "number": 1554,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the pearls\n    a.sort()\n\n    # Initialize the maximal number of segments\n    max_segments = 0\n\n    # Initialize the current segment\n    current_segment = []\n\n    # Iterate over the pearls\n    for i in range(n):\n        # If the current pearl is the same as the next one, add it to the current segment\n        if a[i] == a[i + 1]:\n            current_segment.append(a[i])\n        # If the current pearl is different from the next one, add it to the current segment and start a new segment\n        else:\n            if len(current_segment) > 1:\n                max_segments += 1\n            current_segment = [a[i]]\n\n    # If there are no segments, return -1\n    if max_segments == 0:\n        return \"-1\"\n\n    # Print the maximal number of segments\n    print(max_segments)\n\n    # Print the segments\n    for i in range(max_segments):\n        print(\" \".join(map(str, current_segment[i])))\n\n    return \"\""
    },
    {
        "number": 1555,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(str, stdin.split())) for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i][j] == \">\":\n                a[i][j] = \"<\"\n            elif a[i][j] == \"=\":\n                a[i][j] = \">\"\n\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == \"<\":\n                a[i][j] = \">\"\n            elif a[i"
    },
    {
        "number": 1556,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Initialize the result array\n    result = [0] * n\n\n    # Perform k operations\n    for _ in range(k):\n        # Find the minimum value that the product of all array elements can reach\n        min_product = float('inf')\n        for i in range(n):\n            product = 1\n            for j in range(i):\n                product *= a[j]\n            if product < min_product:\n                min_product = product\n\n        # Apply the minimum value to the array\n        for i in range(n):\n            result[i] += min_product\n\n        # Update the array\n        for i in range(n):\n            a[i] += min_product\n\n    # Print the result array\n    for i in range(n):\n        print(result[i], end=' ')\n    return '\\n'"
    },
    {
        "number": 1557,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h_1, a_1, c_1 = map(int, stdin.split())\n    h_2, a_2 = map(int, stdin.split())\n\n    if h_1 > h_2 or a_1 > a_2:\n        return \"Invalid input\"\n\n    n = 0\n    for i in range(1, 101):\n        if i == 1:\n            n += 1\n            continue\n\n        if h_1 - a_1 <= 0:\n            n += 1\n            continue\n\n        if h_2 - a_2 <= 0:\n            n += 1\n            continue\n\n        if h_1 - a_1 <= c_1:\n            n += 1\n            continue\n\n        if h_2 - a_2 <= c_1:\n            n += 1\n            continue\n\n        n += 1\n\n    return str(n)\n"
    },
    {
        "number": 1558,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, avg = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    min_essays = float('inf')\n\n    for i in range(n):\n        if a[i] >= r:\n            min_essays = min(min_essays, b[i])\n\n    return str(min_essays)"
    },
    {
        "number": 1559,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A = map(int, stdin.split())\n    X = A\n    while True:\n        X += 1\n        if is_periodic(X, L):\n            break\n    return str(X)\n\ndef"
    },
    {
        "number": 1560,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    colors = stdin.strip().split()\n    moves = 0\n\n    for i in range(n):\n        if colors[i] == 'b':\n            if i < n - 1:\n                colors[i], colors[i + 1] = colors[i + 1], colors[i]\n                moves += 1\n            else:\n                colors[i], colors[0] = colors[0], colors[i]\n                moves += 1\n        elif colors[i] == 'r':\n            if i < n - 1:\n                colors[i], colors[i + 1] = colors[i + 1], colors[i]\n                moves += 1\n            else:\n                colors[i], colors[0] = colors[0], colors[i]\n                moves += 1\n\n    return str(moves)"
    },
    {
        "number": 1561,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [list(input()) for _ in range(n)]\n    visited = [[False] * m for _ in range(n)]\n    result = 0\n\n    def dfs(row, col):\n        if row == n - 1 and col == m - 1:\n            result += 1\n            return\n\n        if row < 0 or row >= n or col < 0 or col >= m or matrix[row][col] == '*':\n            return\n\n        visited[row][col] = True\n        dfs(row + 1, col)\n        dfs(row - 1, col)\n        dfs(row, col + 1)\n        dfs(row, col - 1)\n        visited[row][col] = False\n\n    dfs(0, 0)\n    return str(result)"
    },
    {
        "number": 1562,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.split())\n    treasures = []\n    safe_columns = []\n    for _ in range(k):\n        r, c = map(int, stdin.split())\n        treasures.append((r, c))\n        safe_columns.append(c)\n\n    moves = 0\n    for r in range(1, n):\n        for c in range(1, m):\n            if r == 1 and c == 1:\n                moves += 1\n            else:\n                moves += 1\n                for i in range(q):\n                    if r == 1 and c == safe_columns[i]:\n                        moves += 1\n                        break\n                    elif r == 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i]:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] - 1:\n                        moves += 1\n                        break\n                    elif r == i + 1 and c == safe_columns[i] + 1:"
    },
    {
        "number": 1563,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a - 1, b - 1))\n\n    colors = set(colors)\n    colors = sorted(colors)\n\n    max_diverse_neighbours = 0\n    min_color = None\n\n    for color in colors:\n        diverse_neighbours = 0\n        for u, v in edges:\n            if colors.issubset({colors.intersection(set(graph[u]))}):\n                diverse_neighbours += 1\n\n        if diverse_neighbours > max_diverse_neighbours:\n            max_diverse_neighbours = diverse_neighbours\n            min_color = color\n\n    return str(min_color + 1)\n"
    },
    {
        "number": 1564,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    if len(s)!= len(t):\n        return \"-1\"\n\n    operations = 0\n    for i in range(len(s)):\n        if s[i] == t[i]:\n            continue\n        operations += 1\n        s = s[:i] + t[i] + s[i+1:]\n        t = t[:i] + s[i] + t[i+1:]\n\n    return str(operations) + \"\\n\" + s + \"\\n\" + t"
    },
    {
        "number": 1565,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, n = map(int, stdin.split())\n    if l > 100000:\n        return \"Invalid input\"\n\n    def split_strip(strip: str) -> list[int]:\n        result = []\n        for digit in strip:\n            if digit.isdigit():\n                result.append(int(digit))\n            else:\n                break\n        return result\n\n    def compute_sum(strip1: list[int], strip2: list[int]) -> int:\n        return sum(strip1) + sum(strip2)\n\n    strip1 = split_strip(n)\n    strip2 = split_strip(n)\n\n    if len(strip1) > len(strip2):\n        strip1, strip2 = strip2, strip1\n\n    min_sum = compute_sum(strip1, strip2)\n\n    return str(min_sum)\n"
    },
    {
        "number": 1566,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    grid = []\n    for _ in range(N):\n        grid.append(list(map(int, stdin.strip())))\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 0:\n                grid[i][j] = 4\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 4:\n                grid[i][j] = 0"
    },
    {
        "number": 1567,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    stable_count = 0\n    for i in range(1, n + 1):\n        for j in range(i):\n            if (i % j) == 0:\n                break\n        else:\n            stable_count += 1\n    return str(stable_count)"
    },
    {
        "number": 1568,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B, C, T = map(int, stdin.split())\n    messages = list(map(int, stdin.split()))\n    messages.sort()\n    messages.reverse()\n\n    max_amount = 0\n    current_amount = 0\n    current_message = 0\n\n    for i in range(T):\n        current_amount += messages[current_message]\n        current_message += 1\n\n        if current_amount > max_amount:\n            max_amount = current_amount\n\n    return str(max_amount)"
    },
    {
        "number": 1569,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        x, y, z = map(int, stdin.split())\n        roads.append((x, y, z))\n\n    def dfs(x, y, z, visited, path):\n        if x == n and y == 1:\n            return True\n        if x == 1 and y == n:\n            return True\n        if x == 1 and y == 1 and z == 0:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 0:\n            return True\n        if x == 1 and y == n and z == 0:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 0:\n            return True\n        if x == n and y == 1 and z == 0:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 0:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 0:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:\n            return True\n        if x == n and y == n and z == 1:\n            return True\n        if x == 1 and y == 1 and z == 1:\n            return True\n        if x == n and y == 1 and z == 1:\n            return True\n        if x == 1 and y == n and z == 1:"
    },
    {
        "number": 1570,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n, w = map(int, stdin.split())\n    i = 1\n    borrow = 0\n    while i <= n:\n        borrow += k * i\n        i += 1\n    if borrow < w:\n        return \"0\"\n    else:\n        return str(borrow)"
    },
    {
        "number": 1571,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    S = stdin.strip()\n    T = T.strip()\n    A = ''\n    count = 0\n\n    for i in range(n):\n        if S[i] == T[0]:\n            A = T[0] + A\n            count += 1\n        elif S[i] == T[-1]:\n            A = A + T[-1]\n            count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1572,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_length = 0\n    current_length = 1\n\n    for i in range(n):\n        if a[i] - 1 + a[i] - 2 > current_length:\n            max_length = current_length\n            current_length = 1\n        else:\n            current_length += 1\n\n    print(max_length)\n    return \"\""
    },
    {
        "number": 1573,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    friends = []\n    for _ in range(n):\n        money, friendship_factor = map(int, stdin.split())\n        friends.append((money, friendship_factor))\n\n    def max_friendship_factor(friend1, friend2):\n        return max(friend1[1], friend2[1])\n\n    def max_friendship_factor_of_company(friends):\n        max_friendship_factor = max(friends, key=lambda x: x[1])\n        return max_friendship_factor[1]\n\n    max_friendship_factor_of_company(friends)\n    return str(max_friendship_factor_of_company(friends))\n"
    },
    {
        "number": 1574,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    musketeers = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        musketeers.append((a, b))\n\n    def is_valid(a, b):\n        return a in musketeers and b in musketeers and a!= b\n\n    def is_triple(a, b, c):\n        return a == b and b == c and a!= c\n\n    def sum_recognitions(a, b):\n        return musketeers.count((a, b))\n\n    def min_sum(a, b, c):\n        return min(sum_recognitions(a, b), sum_recognitions(b, c), sum_recognitions(a, c))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_valid(i, j) and is_valid(j, k) and is_valid(k, i) and is_triple(i, j, k):\n                    triple = (i, j, k)\n                    if min_sum(i, j, k) < min_sum(triple[0], triple[1], triple[2]):\n                        musketeers.remove((i, j))\n                        musketeers.remove((j, k))\n                        musketeers.remove((k, i))\n                        musketeers.append(triple)\n\n    if len(musketeers) == 3:\n        return \" \".join(map(str, musketeers))\n    else:\n        return \"-1\""
    },
    {
        "number": 1575,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t_s, t_f, t = map(int, stdin.split())\n    n = int(stdin.strip())\n    points = list(map(int, stdin.strip().split()))\n\n    def is_valid_point(point):\n        return 0 <= point <= 10**12\n\n    def is_valid_points(points):\n        return all(is_valid_point(point) for point in points)\n\n    if not is_valid_points(points):\n        return \"Invalid points\"\n\n    def is_valid_time(time):\n        return 0 <= time <= 10**12\n\n    if not is_valid_time(t_s) or not is_valid_time(t_f):\n        return \"Invalid time\"\n\n    if not is_valid_time(t):\n        return \"Invalid time\"\n\n    def is_valid_queue(queue):\n        return len(queue) <= n\n\n    if not is_valid_queue(points):\n        return \"Invalid queue\"\n\n    def is_valid_receptionist(receptionist):\n        return 0 <= receptionist <= 10**12\n\n    if not is_valid_receptionist(t_s):\n        return \"Invalid receptionist time\"\n\n    if not is_valid_receptionist(t_f):\n        return \"Invalid receptionist time\"\n\n    def is_valid_visitor(visitor):\n        return 0 <= visitor <= 10**12\n\n    if not is_valid_visitor(points[0]):\n        return \"Invalid visitor time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 10**12\n\n    if not is_valid_office_time(points[0]):\n        return \"Invalid office time\"\n\n    def is_valid_office_time(office_time):\n        return 0 <= office_time <= 1"
    },
    {
        "number": 1576,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.strip()\n    s = \"\"\n    for i in range(len(t)):\n        if i % 2 == 0:\n            s += t[i]\n        else:\n            s += t[i] + t[i+1]\n    return s"
    },
    {
        "number": 1577,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    games = list(map(str.strip, stdin.readlines()))\n\n    anton_wins = 0\n    danik_wins = 0\n\n    for game in games:\n        if game[0] == 'A':\n            anton_wins += 1\n        elif game[0] == 'D':\n            danik_wins += 1\n\n    if anton_wins > danik_wins:\n        return \"Anton\"\n    elif danik_wins > anton_wins:\n        return \"Danik\"\n    else:\n        return \"Friendship\""
    },
    {
        "number": 1578,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    P = [2, 1]\n    M = [0] * N\n    M[0] = 1\n    for i in range(1, N):\n        M[i] = (M[i - 1] + P[i - 1]) % N\n    return str(M[N - 1])"
    },
    {
        "number": 1579,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    dots = []\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        dots.append((x, y))\n\n    max_operations = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dots[i][0]!= dots[j][0] or dots[i][1]!= dots[j][1]:\n                max_operations += 1\n                break\n\n    return str(max_operations)"
    },
    {
        "number": 1580,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = [0] * N\n    for i in range(N):\n        A[i] = int(stdin.readline())\n\n    total_cost = 0\n    for i in range(M):\n        X, Y, Z = map(int, stdin.readline().split())\n        total_cost += 1\n        if A[X - 1] + A[Y - 1] + Z == 2:\n            total_cost += 1\n\n    return str(total_cost)"
    },
    {
        "number": 1581,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(N - K + 1):\n        if i + K - 1 >= N:\n            break\n        if i + K - 1 < 0:\n            continue\n        if i % 2 == 0:\n            count += 1\n            if i + 1 < N and i + 1 + K - 1 >= N:\n                count += 1\n        else:\n            count += 1\n            if i + 1 < N and i + 1 + K - 1 >= N:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1582,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    count = 0\n    for i in range(10, N+1):\n        for j in range(10, N+1):\n            if i == j:\n                continue\n            if i == int(str(i)[-1]) and j == int(str(j)[-1]):\n                count += 1\n    return str(count)"
    },
    {
        "number": 1583,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x = map(int, stdin.split())\n    max_angle = 0\n    for i in range(1, a + 1):\n        for j in range(1, b + 1):\n            if i * j * x > 0:\n                angle = math.degrees(math.atan2(i, j))\n                if angle > max_angle:\n                    max_angle = angle\n    return str(max_angle)"
    },
    {
        "number": 1584,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    triangles = set()\n\n    for i in range(n):\n        a, b, c = map(int, stdin.readline().split())\n        if a < b + c or b < c + a or c < a + b:\n            triangles.add(tuple(sorted([a, b, c])))\n\n    return str(len(triangles))"
    },
    {
        "number": 1585,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    sequence = list(range(X, Y+1))\n    max_length = 0\n    for i in range(len(sequence)-1):\n        if sequence[i+1] % sequence[i]!= 0:\n            continue\n        if sequence[i+1] > sequence[i]:\n            max_length = max(max_length, i+1)\n    return str(max_length)"
    },
    {
        "number": 1586,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 2:\n        return \"1\"\n    else:\n        return str(n) + solution(str(n-2))"
    },
    {
        "number": 1587,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    stones = list(stdin.strip())\n    operations = []\n\n    for i in range(N):\n        if stones[i] == 'R':\n            operations.append(('Swap', i, i + 1))\n        elif stones[i] == 'W':\n            operations.append(('Change', i, 'W'))\n\n    operations.sort(key=lambda x: (-x[1], x[0]))\n\n    for op, i, j in operations:\n        if op == 'Swap':\n            stones[i], stones[j] = stones[j], stones[i]\n        elif op == 'Change':\n            stones[i] = 'W' if stones[i] == 'R' else 'R'\n\n    return str(len(operations))"
    },
    {
        "number": 1588,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    X = set(map(int, stdin.readline().strip().split()))\n\n    Y = set()\n    for x in X:\n        for y in range(1, n + 1):\n            if x - 1 == sum(range(1, y + 1)):\n                Y.add(y)\n                break\n\n    return str(len(Y)) + \" \" + \" \".join(map(str, Y))"
    },
    {
        "number": 1589,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    windows = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n    \n    count = 0\n    for floor in range(n):\n        for flat in range(m):\n            if windows[floor][flat] == 1:\n                count += 1\n                for window in range(2*flat, 2*flat+2):\n                    if windows[floor][window] == 1:\n                        count -= 1\n    \n    return str(count)"
    },
    {
        "number": 1590,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def f(l, r):\n        if l == r:\n            return a[l - 1]\n        return (a[l - 1] * (l - 1)) % (10**9 + 7)\n\n    total_sum = sum(f(l, r) for l in range(1, n + 1) for r in range(l, n + 1))\n    return str(total_sum)"
    },
    {
        "number": 1591,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of sets with exactly two drinks\n    count = 0\n    for i in range(1, k):\n        count += a.count(i)\n\n    # Calculate the maximum number of students\n    max_students = n // 2\n    max_students = max(max_students, count)\n\n    return str(max_students)\n"
    },
    {
        "number": 1592,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    tasks = []\n    for _ in range(n):\n        t, c = map(int, stdin.strip().split())\n        tasks.append((t, c))\n\n    tasks.sort(key=lambda x: x[0])\n\n    last_sent = tasks[0][0]\n    max_queue_size = 0\n\n    for t, c in tasks[1:]:\n        if t > last_sent:\n            max_queue_size = max(max_queue_size, len(tasks))\n        last_sent = t\n\n    return f\"{last_sent} {max_queue_size}\""
    },
    {
        "number": 1593,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    locatons = []\n    for _ in range(n):\n        x, y, k = map(int, stdin.split())\n        locatons.append((x, y, k))\n\n    locatons.sort(key=lambda x: x[0])\n\n    r = 0\n    for i in range(n):\n        x, y, k = locatons[i]\n        if i == 0:\n            r = x - y\n        else:\n            r = min(r, x - y)\n\n    if r <= 0:\n        return \"-1\"\n\n    return str(r)\n"
    },
    {
        "number": 1594,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    play_list = []\n    for _ in range(n):\n        c, t = map(int, stdin.split())\n        play_list.append((c, t))\n\n    moments = list(map(int, stdin.split()))\n    moments.sort()\n\n    result = []\n    for moment in moments:\n        for i in range(n):\n            if moment >= play_list[i][1] and moment < play_list[i][1] + play_list[i][2]:\n                result.append(i + 1)\n                break\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1595,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    sum, limit = map(int, stdin.split())\n    if sum > limit:\n        return -1\n\n    lowbit = [0] * limit\n    for i in range(1, limit):\n        lowbit[i] = lowbit[i - 1] + 1\n\n    count = 0\n    for i in range(1, limit):\n        if lowbit[i] == sum:\n            count += 1\n            if count == 1:\n                return str(i)\n\n    return -1"
    },
    {
        "number": 1596,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'w':\n            count += 1\n        elif s[i] =='m':\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1597,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    students = []\n    pseudonyms = []\n\n    for _ in range(n):\n        name = input().strip()\n        students.append(name)\n\n    for _ in range(n):\n        pseudonym = input().strip()\n        pseudonyms.append(pseudonym)\n\n    max_quality = 0\n    matching = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            lcp = 0\n            for k in range(min(len(students[i]), len(students[j]))):\n                if students[i][k] == students[j][k]:\n                    lcp += 1\n            if lcp > max_quality:\n                max_quality = lcp\n                matching = [i, j]\n\n    return str(max_quality) + \" \" + \" \".join(map(str, matching))\n"
    },
    {
        "number": 1598,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.strip()))\n    t = list(map(int, stdin.strip()))\n\n    def longest_non_decreasing_subsequence(s, t, l, r):\n        if l == r:\n            return 1\n\n        if s[l] == t[l]:\n            return 1 + longest_non_decreasing_subsequence(s, t, l + 1, r)\n\n        if s[l] < t[l]:\n            return 1 + longest_non_decreasing_subsequence(s, t, l + 1, r)\n\n        return 1 + longest_non_decreasing_subsequence(s, t, l, r - 1)\n\n    max_length = max(len(s), len(t))\n    max_length_non_decreasing_subsequence = max_length\n\n    for l in range(max_length):\n        for r in range(max_length - l):\n            if s[l:l + r + 1] == t[l:l + r + 1]:\n                max_length_non_decreasing_subsequence = max(max_length_non_decreasing_subsequence, r + 1)\n\n    if max_length_non_decreasing_subsequence == max_length:\n        return t\n    else:\n        return ''.join(map(str, [t[i] for i in range(max_length_non_decreasing_subsequence)]))\n"
    },
    {
        "number": 1599,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    m = int(stdin.split()[2])\n    answers = []\n\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        count = 0\n        for i in range(n):\n            if s[i] == \"#\":\n                count += 1\n                if l <= i < r:\n                    answers.append(count)\n        if not answers:\n            answers.append(0)\n\n    return str(answers)\n"
    },
    {
        "number": 1600,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    h = list(map(int, stdin.readline().strip().split()))\n\n    # Sort castles\n    castles = sorted(range(1, n + 1), key=lambda x: h[x - 1])\n\n    # Count maximum number of blocks\n    max_blocks = 1\n    for i in range(1, n):\n        if h[i] - h[i - 1] == 1:\n            max_blocks += 1\n\n    return str(max_blocks)\n"
    },
    {
        "number": 1601,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.strip().split())\n        points.append((x, y, z))\n\n    def min_max_x_y_z(points):\n        x_min, x_max, y_min, y_max, z_min, z_max = float('inf'), float('-inf'), float('inf'), float('-inf'), float('inf'), float('-inf')\n        for p in points:\n            x_min = min(x_min, p[0])\n            x_max = max(x_max, p[0])\n            y_min = min(y_min, p[1])\n            y_max = max(y_max, p[1])\n            z_min = min(z_min, p[2])\n            z_max = max(z_max, p[2])\n        return x_min, x_max, y_min, y_max, z_min, z_max\n\n    x_min, x_max, y_min, y_max, z_min, z_max = min_max_x_y_z(points)\n    n_points = len(points)\n\n    def snap(points):\n        n_snaps = n // 2\n        snaps = []\n        for i in range(n_snaps):\n            a, b = points[i], points[i + n_snaps]\n            if not (a[0] == b[0] and a[1] == b[1] and a[2] == b[2]):\n                snaps.append((a, b))\n        return snaps\n\n    snaps = snap(points)\n    result = []\n    for i, snap in enumerate(snaps):\n        a, b = snap\n        if a[0] == b[0] and a[1] == b[1] and a[2] == b[2]:\n            result.append(i + 1)\n        else:\n            result.append(i + 1)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1602,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def f(x, y):\n        return (x | y) - y\n\n    def max_value(arr):\n        max_val = arr[0]\n        for i in range(1, len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n        return max_val\n\n    max_val = max_value(a)\n    result = []\n    for i in range(n):\n        result.append(a[i])\n        a[i] = f(a[i], max_val)\n        max_val = max(max_val, a[i])\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1603,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n    u = list(map(int, stdin.split()))\n\n    l, r = map(int, stdin.split())\n    l, r = min(l, r), max(l, r)\n\n    def min_cost(v):\n        return min(v)\n\n    def max_cost(v):\n        return max(v)\n\n    def min_cost_index(v):\n        return v.index(min_cost(v))\n\n    def max_cost_index(v):\n        return v.index(max_cost(v))\n\n    def min_cost_sum(v):\n        return sum(v[:min_cost_index(v)])\n\n    def max_cost_sum(v):\n        return sum(v[:max_cost_index(v)])\n\n    def min_cost_sum_index(v):\n        return v.index(min_cost_sum(v))\n\n    def max_cost_sum_index(v):\n        return v.index(max_cost_sum(v))\n\n    def min_cost_sum_index_sum(v):\n        return min_cost_sum_index(v) + max_cost_sum_index(v)\n\n    def max_cost_sum_index_sum(v):\n        return min_cost_sum_index(v) + max_cost_sum_index(v)\n\n    def min_cost_sum_index_sum_cost(v):\n        return min_cost_sum_index_sum(v) + v[min_cost_sum_index(v)]\n\n    def max_cost_sum_index_sum_cost(v):\n        return min_cost_sum_index_sum(v) + v[max_cost_sum_index(v)]\n\n    def min_cost_sum_index_sum_cost_index(v):\n        return min_cost_sum_index_sum_cost(v).index(min_cost_sum_index(v))\n\n    def max_cost_sum_index_sum_cost_index(v):\n        return min_cost_sum_index_sum_cost(v).index(max_cost_sum_index(v))\n\n    def min_cost_sum_index_sum_cost_index_cost(v):\n        return min_cost_sum_index_sum_cost_index(v) + v[min_cost_sum_index_sum_cost_index(v)]\n\n    def max_cost_sum_index_sum_cost_index_cost(v):\n        return min_cost_sum_index_sum_cost_index(v) + v[max_cost_sum_index_sum_cost_index(v)]\n\n    def min_cost_sum_index_sum_cost_index_cost_index(v):\n        return min_cost_sum_index_sum_cost_index_cost(v).index(min_cost_sum_index_sum_cost_index(v))\n\n    def max_cost_sum_index_sum_cost_index_cost_index(v):\n        return min_cost_sum_index_sum_cost_index_cost(v).index(max_cost_sum_index_sum_cost_index(v))\n\n    def min_cost_sum_index_sum_cost_index_cost_index_cost(v):\n        return min_cost_sum_index_sum_cost_index_cost_index(v) + v[min_cost_sum_index_sum_cost_index_cost_index(v)]\n\n    def max_cost_sum_index_sum_cost_index_cost_index_cost(v):\n        return min_cost_sum_index_sum_cost_index_cost_index(v) + v[max_cost_sum_index_sum_cost_index_cost_index(v)]\n\n    def min_cost_sum_index_sum_cost_index_cost_index_cost_index(v):\n        return min_cost_sum_index_sum_cost_index_cost_index_cost(v).index(min_cost_sum_index_sum_cost_index_cost_index(v))\n\n    def max_cost_sum_index_sum_cost_index_cost_index_cost_index(v):\n        return min_cost_sum_index_sum_cost_index_cost_index_cost(v).index(max_cost_sum_index_sum_cost_index_cost_index(v))\n\n    def min_cost_sum_index_sum_cost_index"
    },
    {
        "number": 1604,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    lamps = list(map(int, stdin.split()))\n\n    def is_valid(lamps):\n        return len(set(lamps)) == len(lamps)\n\n    if not is_valid(lamps):\n        return \"0\"\n\n    def count_ways(lamps):\n        if len(lamps) == 1:\n            return 1\n\n        ways = 0\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                ways += count_ways(lamps[:i] + lamps[i + 1:] + lamps[:j] + lamps[j + 1:])\n\n        return ways\n\n    ways = count_ways(lamps)\n    return str(ways % (10**9 + 7))"
    },
    {
        "number": 1605,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    count_even = 0\n    count_odd = 0\n    for i in range(n):\n        if stdin[i] == stdin[i+1]:\n            count_even += 1\n        else:\n            count_odd += 1\n    return str(count_even) + \" \" + str(count_odd)"
    },
    {
        "number": 1606,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    A = [[int(bit) for bit in stdin.split()] for _ in range(n)]\n\n    for _ in range(q):\n        cmd, i = map(int, stdin.split())\n        if cmd == 1:\n            A[i] = [1 - bit for bit in A[i]]\n        elif cmd == 2:\n            A[i] = [bit for bit in A[i]]\n        elif cmd == 3:\n            print(A[i][i])\n\n    return '\\n'.join(map(str, A))"
    },
    {
        "number": 1607,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    beautiful_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if grid[i][j] == grid[j][i]:\n                beautiful_count += 1\n                if beautiful_count == k:\n                    break\n    return str(beautiful_count % 998244353)"
    },
    {
        "number": 1608,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_coprime(a, b):\n        return gcd(a, b) == 1\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_coprime(a[i], a[j]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1609,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    a.sort()\n    result = []\n    for i in range(n):\n        result.append(a[i])\n    return''.join(map(str, result))"
    },
    {
        "number": 1610,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(range(1, n+1))\n    p.sort()\n    p.reverse()\n    p = p[:k]\n    return''.join(map(str, p))"
    },
    {
        "number": 1611,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rod_lengths = list(map(int, stdin.strip().split()))\n\n    min_length = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                length = rod_lengths[i] + rod_lengths[j] + rod_lengths[k]\n                if length < min_length:\n                    min_length = length\n\n    return str(min_length)"
    },
    {
        "number": 1612,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    players = []\n    for _ in range(n):\n        player = []\n        for _ in range(int(stdin.readline().strip())):\n            player.append(int(stdin.readline().strip()))\n        players.append(player)\n\n    for player in players:\n        if len(set(player))!= len(player):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1614,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    min_width = 1\n    for i in range(n):\n        if a[i] > h:\n            min_width += 2\n        else:\n            min_width += 1\n\n    return str(min_width)"
    },
    {
        "number": 1615,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        segments.append((l, r))\n\n    min_moves = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if segments[i][1] < segments[j][0]:\n                min_moves = min(min_moves, j - i)\n\n    return str(min_moves)\n"
    },
    {
        "number": 1616,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_perfect_square(num):\n        return int(num ** 0.5) ** 2 == num\n\n    def is_valid_product(product):\n        for num in product:\n            if num > 7:\n                return False\n        return True\n\n    def find_shortest_subsequence(a):\n        shortest_subsequence = []\n        current_product = []\n\n        for num in a:\n            if is_valid_product(current_product):\n                current_product.append(num)\n                if is_perfect_square(sum(current_product)):\n                    shortest_subsequence.append(current_product)\n                    current_product = []\n            else:\n                current_product.append(num)\n\n        if current_product:\n            shortest_subsequence.append(current_product)\n\n        return shortest_subsequence\n\n    shortest_subsequences = find_shortest_subsequence(a)\n\n    if shortest_subsequences:\n        shortest_subsequence = min(shortest_subsequences, key=len)\n        return str(len(shortest_subsequence))\n    else:\n        return \"-1\""
    },
    {
        "number": 1617,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    fun_values = []\n    for k in range(1, n+1):\n        fun_values.append(k)\n    return''.join(map(str, sorted(fun_values)))"
    },
    {
        "number": 1618,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    boxes = []\n    for _ in range(m):\n        w, h = map(int, stdin.split())\n        boxes.append((w, h))\n\n    stairs = [0] * n\n    for i in range(1, n):\n        stairs[i] = stairs[i - 1] + boxes[i - 1][0]\n\n    result = []\n    for i in range(m):\n        result.append(stairs[i] + boxes[i][1])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1619,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(n):\n        x, y, z = map(int, stdin.split())\n        edges.append((x, y, z))\n\n    for _ in range(m):\n        x, y, z = map(int, stdin.split())\n        edges.append((x, y, z))\n\n    def is_well_connected(polygon):\n        for i in range(len(polygon) - 1):\n            for j in range(i + 1, len(polygon)):\n                if polygon[i][0] * polygon[j][1]!= polygon[j][0] * polygon[i][1]:\n                    return False\n        return True\n\n    for polygon in [edges, edges[::-1]]:\n        if not is_well_connected(polygon):\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1620,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"a\"\n    elif n == 2:\n        return \"ab\"\n    else:\n        result = \"\"\n        for i in range(n):\n            if i % 2 == 0:\n                result += \"c\"\n            else:\n                result += \"a\"\n        return result"
    },
    {
        "number": 1621,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w = list(map(int, stdin.split()))\n    k = int(stdin.split()[1])\n    s = stdin.split()[2:]\n    s = ''.join(s)\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x: (-w[x], x)))\n    s = ''.join(sorted(s, key=lambda x:"
    },
    {
        "number": 1622,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    events = []\n    for _ in range(m):\n        t, x, y, i = map(int, stdin.split())\n        events.append((t, x, y, i))\n\n    def dfs(x, visited):\n        if x in visited:\n            return\n        visited.add(x)\n        if x == n:\n            return \"YES\"\n        if events[x][0] == 1:\n            return dfs(events[x][1], visited)\n        elif events[x][0] == 2:\n            return dfs(events[x][1], visited)\n        elif events[x][0] == 3:\n            return dfs(events[x][1], visited)\n        else:\n            return \"NO\"\n\n    for _ in range(m):\n        x, y, i = events[0]\n        if x == y:\n            continue\n        if dfs(x, set()) == \"YES\":\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 1623,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    min_sum = float('inf')\n    max_sum = float('-inf')\n    for i in range(n):\n        if a[i] == 1:\n            count += 1\n            if count < l:\n                min_sum = min(min_sum, i + 1)\n            if count > r:\n                max_sum = max(max_sum, i + 1)\n    return str(min_sum) +'' + str(max_sum)"
    },
    {
        "number": 1624,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    m = n // 2\n    s = [0] * m\n    for i in range(m):\n        s[i] = a[i]\n    for i in range(m, n):\n        s[i - m] += a[i]\n    return str(min(sum(s[i] ** 2 for i in range(m)) for j in range(m, n)))"
    },
    {
        "number": 1625,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def matrix_beauty(matrix, n):\n        if n == 0:\n            return matrix[0][0]\n        else:\n            beauty = 0\n            for i in range(n):\n                for j in range(n):\n                    beauty += matrix[i][j]\n            return beauty\n\n    max_beauty = matrix_beauty(a, n)\n    return str(max_beauty)\n"
    },
    {
        "number": 1626,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    good_numbers = 0\n    for i in range(n // k):\n        block = [a[i * k + j] for j in range(k)]\n        if block[0]!= b[i]:\n            good_numbers += 1\n\n    return str(good_numbers % (10**9 + 7))"
    },
    {
        "number": 1627,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the animals in non-decreasing order\n    a.sort()\n\n    # Initialize the sequence of operations\n    operations = []\n\n    # Perform operations\n    for i in range(n):\n        # Find the position of the current animal\n        j = i\n        while j > 0 and a[j] >= a[j - 1]:\n            j -= 1\n\n        # Perform the operation\n        if j == i:\n            operations.append(str(i))\n        else:\n            operations.append(str(i) + \" \" + str(j))\n\n    return \"\\n\".join(operations)"
    },
    {
        "number": 1628,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 2:\n        return s\n\n    # Step 1: Find two consecutive characters that are equal to \"y\"\n    i = 0\n    while i < len(s) - 1 and s[i] == \"x\":\n        i += 1\n\n    if i == len(s) - 1:\n        return s\n\n    j = i + 1\n    while j < len(s) and s[j] == \"y\":\n        j += 1\n\n    if j == len(s):\n        return s\n\n    # Step 2: Swap the characters at the two positions\n    s = s[:i] + \"y\" + s[i+1:] + s[i+2:] + s[i+3:]\n    s = s[:j] + \"x\" + s[j+1:] + s[j+2:] + s[j+3:]\n\n    return s"
    },
    {
        "number": 1629,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    boxes = [[] for _ in range(n + 1)]\n    for i in range(n):\n        boxes[i + 1].append(i)\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == boxes[i][j + 1]:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if boxes[i][j] == -1:\n                boxes[i][j] = boxes[i][j + 1] = -1\n\n    for i in range(1, n + 1):\n        for j"
    },
    {
        "number": 1630,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    clubs = []\n    for _ in range(n):\n        team, hometown = stdin.strip().split()\n        clubs.append((team, hometown))\n\n    def is_valid_short_name(club):\n        team, hometown = club\n        team_name = team[:3]\n        hometown_name = hometown[:2]\n        return team_name == hometown_name\n\n    def choose_short_name(club):\n        team, hometown = club\n        team_name = team[:3]\n        hometown_name = hometown[:2]\n        if is_valid_short_name((team, hometown)):\n            return team_name\n        else:\n            return hometown_name\n\n    clubs = sorted(clubs, key=lambda x: (x[0], x[1]))\n    for i, club in enumerate(clubs):\n        clubs[i] = (choose_short_name(club), club[1])\n\n    result = \"YES\"\n    for club in clubs:\n        result += \"\\n\" + club[0]\n\n    return result"
    },
    {
        "number": 1631,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    names = [input().strip() for _ in range(n)]\n\n    # Sort names lexicographically\n    names.sort()\n\n    # Find the modified alphabet\n    modified_alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    modified_names = [modified_alphabet[i] + modified_alphabet[i + 1] for i in range(len(names) - 1)]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of letters in the modified alphabet\n    order_of_letters = [modified_alphabet.index(name[0]) for name in names]\n\n    # Find the order of authors\n    authors_order = [names.index(name) for name in names]\n\n    # Find the order of"
    },
    {
        "number": 1632,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the sum of the three balls\n    total = sum(a)\n\n    # Calculate the probability that Jerry has a higher total\n    jury_sum = sum(a)\n    jury_total = sum(a)\n    jury_win_count = jury_total - jury_sum\n    jury_win_probability = jury_win_count / jury_total\n\n    # Calculate the probability that Andrew has a higher total\n    if jury_win_probability > 0.5:\n        # Andrew has a higher total if and only if Jerry won 2 - 1 in both rounds\n        if jury_win_count == 2:\n            return \"0.0000000000\"\n        else:\n            return \"0.0000000000\"\n    else:\n        # Andrew has a lower total if and only if Jerry won 2 - 1 in both rounds\n        if jury_win_count == 2:\n            return \"0.0000000000\"\n        else:\n            return \"0.0000000000\""
    },
    {
        "number": 1633,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    moves = []\n    for _ in range(k):\n        i, j = map(int, stdin.split())\n        moves.append((i, j))\n\n    def is_black(row, col):\n        return row == 0 or row == n - 1 or col == 0 or col == m - 1 or board[row][col] == 0\n\n    def is_black_square(row, col):\n        return is_black(row, col) and is_black(row - 1, col) and is_black(row + 1, col) and is_black(row, col - 1) and is_black(row, col + 1)\n\n    board = [[0] * m for _ in range(n)]\n    for i, j in moves:\n        board[i][j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if is_black(i, j):\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(m):\n            if is_black_square(i, j):\n                return str(i) + \" \" + str(j)\n\n    return \"0\""
    },
    {
        "number": 1634,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c_1, c_2, c_3, c_4 = map(int, stdin.split())\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def min_sum(tickets):\n        total_cost = sum(tickets)\n        min_sum = total_cost\n        for i in range(1, n + 1):\n            min_sum = min(min_sum, total_cost - c_1 * i)\n        for i in range(1, m + 1):\n            min_sum = min(min_sum, total_cost - c_2 * i)\n        for i in range(1, n + 1):\n            min_sum = min(min_sum, total_cost - c_3 * i)\n        for i in range(1, m + 1):\n            min_sum = min(min_sum, total_cost - c_4 * i)\n        return min_sum\n\n    min_sum_tickets = min_sum(a)\n    min_sum_tickets += min_sum(b)\n\n    return str(min_sum_tickets)\n"
    },
    {
        "number": 1635,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cafes = list(map(int, stdin.strip().split()))\n    visited = set()\n    for i in range(n):\n        visited.add(cafes[i])\n    for i in range(n):\n        if cafes[i] not in visited:\n            return cafes[i]\n    return -1"
    },
    {
        "number": 1636,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    def special_value(x, y):\n        return y - x\n\n    def aesthetically_pleasant_numbering(points):\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if points[i][0] >= points[j][0] and points[i][1] >= points[j][1]:\n                    return False\n        return True\n\n    if aesthetically_pleasant_numbering(points):\n        for i in range(n):\n            print(f\"{i+1} {special_value(points[i][0], points[i][1])}\")\n    else:\n        print(\"NO\")\n\n    return \"YES\""
    },
    {
        "number": 1637,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n    u = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    # Sort the pairs of people who don't want to write a contest in one team\n    u.sort()\n    v.sort()\n\n    # Initialize the sum of scores for all participants\n    scores = [0] * n\n\n    # Initialize the sum of scores for each team\n    team_scores = [0] * n\n\n    # Initialize the sum of scores for each team's first task\n    team_first_task_scores = [0] * n\n\n    # Initialize the sum of scores for each team's second task\n    team_second_task_scores = [0] * n\n\n    # Initialize the sum of scores for each team's penalty points\n    team_penalty_points = [0] * n\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0\n\n    # Initialize the sum of scores for each team's final score\n    team_final_score = 0"
    },
    {
        "number": 1638,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = list(map(int, stdin.strip().split()))\n    a = [0] * n\n    for i in range(n):\n        a[i] = m[i]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n    return str(a)"
    },
    {
        "number": 1639,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_length = 1\n    current_length = 1\n\n    for i in range(1, n):\n        if a[i] > a[i - 1]:\n            current_length += 1\n        else:\n            current_length = 1\n\n        if current_length > max_length:\n            max_length = current_length\n\n    return str(max_length)\n"
    },
    {
        "number": 1640,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def d(x, y):\n        if abs(x - y) > 1:\n            return y - x\n        else:\n            return 0\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result += d(a[i], a[j])\n\n    return str(result)"
    },
    {
        "number": 1641,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, s, t = map(int, stdin.split())\n    gas_stations = list(map(int, stdin.split()))\n    cars = []\n    for i in range(n):\n        c, v = map(int, stdin.split())\n        cars.append((c, v))\n\n    min_price = float('inf')\n    for i in range(k):\n        min_price = min(min_price, cars[i][0])\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if cars[i][1] <= cars[j][1]:\n                min_price = min(min_price, cars[i][0] + cars[j][0])\n\n    if min_price == float('inf'):\n        return -1\n\n    for i in range(k):\n        min_price = min(min_price, cars[i][0] + cars[i][0] * (gas_stations[i] - s) / (s - 1))\n\n    return min_price\n"
    },
    {
        "number": 1642,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def convex_polygon(points):\n        n = len(points)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if distance(points[i], points[j]) > distance(points[j], points[i + 1]):\n                    return False\n        return True\n\n    def max_distance(points):\n        max_distance = 0\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if distance(points[i], points[j]) > max_distance:\n                    max_distance = distance(points[i], points[j])\n        return max_distance\n\n    def move_vertices(points, max_distance):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                dx = points[j][0] - points[i][0]\n                dy = points[j][1] - points[i][1]\n                distance = distance(points[i], points[j])\n                if distance <= max_distance:\n                    points[i] = (points[i][0] + dx, points[i][1] + dy)\n                    points[j] = (points[j][0] + dx, points[j][1] + dy)\n\n    max_distance_before = max_distance(points)\n    move_vertices(points, max_distance_before)\n    max_distance_after = max_distance(points)\n\n    if convex_polygon(points):\n        return str(max_distance_after)\n    else:\n        return \"0.0\""
    },
    {
        "number": 1643,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.strip()))\n    t = [0] * n\n    t[0] = 1\n    for i in range(1, n):\n        t[i] = t[i-1] ^ s[i-1]\n    max_len = 0\n    max_subseq = \"\"\n    for i in range(n):\n        for j in range(i+1, n):\n            subseq = t[i:j+1]\n            if len(subseq) > max_len:\n                max_len = len(subseq)\n                max_subseq = subseq\n    return \"\".join(map(str, max_subseq))"
    },
    {
        "number": 1644,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [int(stdin.strip()) for _ in range(n)]\n    b = [int(stdin.strip()) for _ in range(n)]\n    h = [int(stdin.strip()) for _ in range(n)]\n\n    def is_valid(i, j):\n        return a[i] <= b[j]\n\n    def max_height(i, j):\n        if i == j:\n            return h[i]\n        return max(h[i], h[j])\n\n    def max_height_of_tower(i, j):\n        if i == j:\n            return h[i]\n        return max(max_height_of_tower(i, k), max_height_of_tower(k, j))\n\n    def max_height_of_tower_helper(i, j):\n        if i == j:\n            return h[i]\n        return max(max_height_of_tower_helper(i, k), max_height_of_tower_helper(k, j))\n\n    max_height_of_tower_helper(0, n - 1)\n    return str(max_height_of_tower_helper(0, n - 1))\n"
    },
    {
        "number": 1645,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                if sum(a[i:j])!= 0 and sum(a[k:n])!= 0:\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 1646,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    val = 0\n    for i in range(n):\n        val = val * 2 + int(s[i])\n    if val == 0:\n        return \"0\"\n    else:\n        return str(val)"
    },
    {
        "number": 1647,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t_shirt = stdin.strip()\n    t_shirt_set = set(t_shirt)\n    t_shirt_set.remove('a')\n    t_shirt_set.remove('b')\n    t_shirt_set.remove('c')\n    t_shirt_set.remove('d')\n    t_shirt_set.remove('e')\n    t_shirt_set.remove('f')\n    t_shirt_set.remove('g')\n    t_shirt_set.remove('h')\n    t_shirt_set.remove('i')\n    t_shirt_set.remove('j')\n    t_shirt_set.remove('k')\n    t_shirt_set.remove('l')\n    t_shirt_set.remove('m')\n    t_shirt_set.remove('n')\n    t_shirt_set.remove('o')\n    t_shirt_set.remove('p')\n    t_shirt_set.remove('q')\n    t_shirt_set.remove('r')\n    t_shirt_set.remove('s')\n    t_shirt_set.remove('t')\n    t_shirt_set.remove('u')\n    t_shirt_set.remove('v')\n    t_shirt_set.remove('w')\n    t_shirt_set.remove('x')\n    t_shirt_set.remove('y')\n    t_shirt_set.remove('z')\n\n    v_pullover = stdin.strip()\n    v_pullover_set = set(v_pullover)\n    v_pullover_set.remove('a')\n    v_pullover_set.remove('b')\n    v_pullover_set.remove('c')\n    v_pullover_set.remove('d')\n    v_pullover_set.remove('e')\n    v_pullover_set.remove('f')\n    v_pullover_set.remove('g')\n    v_pullover_set.remove('h')\n    v_pullover_set.remove('i')\n    v_pullover_set.remove('j')\n    v_pullover_set.remove('k')\n    v_pullover_set.remove('l')\n    v_pullover_set.remove('m')\n    v_pullover_set.remove('n')\n    v_pullover_set.remove('o')\n    v_pullover_set.remove('p')\n    v_pullover_set.remove('q')\n    v_pullover_set.remove('r')\n    v_pullover_set.remove('s')\n    v_pullover_set.remove('t')\n    v_pullover_set.remove('u')\n    v_pullover_set.remove('v')\n    v_pullover_set.remove('w')\n    v_pullover_set.remove('x')\n    v_pullover_set.remove('y')\n    v_pullover_set.remove('z')\n\n    spells = []\n    for letter in t_shirt_set:\n        for letter2 in v_pullover_set:\n            spells.append((letter, letter2))\n\n    spells.sort()\n    min_mana = sum(spells)\n\n    return str(min_mana)\n"
    },
    {
        "number": 1648,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_ways(n, k):\n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        if n == 3:\n            return 3\n        if n == 4:\n            return 4\n        if n == 5:\n            return 5\n        if n == 6:\n            return 6\n        if n == 7:\n            return 7\n        if n == 8:\n            return 8\n        if n == 9:\n            return 9\n        if n == 10:\n            return 10\n        if n == 11:\n            return 11\n        if n == 12:\n            return 12\n        if n == 13:\n            return 13\n        if n == 14:\n            return 14\n        if n == 15:\n            return 15\n        if n == 16:\n            return 16\n        if n == 17:\n            return 17\n        if n == 18:\n            return 18\n        if n == 19:\n            return 19\n        if n == 20:\n            return 20\n        if n == 21:\n            return 21\n        if n == 22:\n            return 22\n        if n == 23:\n            return 23\n        if n == 24:\n            return 24\n        if n == 25:\n            return 25\n        if n == 26:\n            return 26\n        if n == 27:\n            return 27\n        if n == 28:\n            return 28\n        if n == 29:\n            return 29\n        if n == 30:\n            return 30\n        if n == 31:\n            return 31\n        if n == 32:\n            return 32\n        if n == 33:\n            return 33\n        if n == 34:\n            return 34\n        if n == 35:\n            return 35\n        if n == 36:\n            return 36\n        if n == 37:\n            return 37\n        if n == 38:\n            return 38\n        if n == 39:\n            return 39\n        if n == 40:\n            return 40\n        if n == 41:\n            return 41\n        if n == 42:\n            return 42\n        if n == 43:\n            return 43\n        if n == 44:\n            return 44\n        if n == 45:\n            return 45\n        if n == 46:\n            return 46\n        if n == 47:\n            return 47\n        if n == 48:\n            return 48\n        if n == 49:\n            return 49\n        if n == 50:\n            return 50\n        if n == 51:\n            return 51\n        if n == 52:\n            return 52\n        if n == 53:\n            return 53\n        if n == 54:\n            return 54\n        if n == 55:\n            return 55\n        if n == 56:\n            return 56\n        if n == 57:\n            return 57\n        if n == 58:\n            return 58\n        if n == 59:\n            return 59\n        if n == 60:\n            return 60\n        if n == 61:\n            return 61\n        if n == 62:\n            return 62\n        if n == 63:\n            return 63\n        if n == 64:\n            return 64\n        if n == 65:\n            return 65\n        if n == 66:\n            return 66\n        if n == 67:\n            return 67\n        if n == 68:\n            return 68\n        if n == 69:\n            return 69\n        if n == 70:\n            return 70\n        if n == 71:\n            return 71\n        if n == 72:\n            return 72\n        if n == 73:\n            return 73\n        if n == 74:\n            return 74\n        if n == 75:\n            return 75\n        if n == 76:\n            return 76\n        if n == 77:\n            return 77\n        if n == 78"
    },
    {
        "number": 1649,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    cookies = [a, b, c, d]\n    deliciousness = [a, b, c, d]\n    for i in range(4):\n        if cookies[i] > 0:\n            deliciousness[i] -= cookies[i]\n            cookies[i] = 0\n    if sum(deliciousness) == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 1650,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.strip())\n    count = 0\n    for a in range(1, L + 1):\n        for b in range(a + 1, L + 1):\n            if a + b <= L and a + b == a ^ b:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1651,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, P = map(int, stdin.split())\n    if S + P!= S * P:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 1652,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    T = \"\"\n    for i in range(10):\n        T += \"dream\"\n    T += \"erase\"\n    T += \"dream\"\n    if S == T:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1653,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    queries = list(map(int, stdin.split()))\n\n    def is_possible(s: str, t: str, a: int, b: int, c: int, d: int) -> bool:\n        for i in range(a, b + 1):\n            for j in range(c, d + 1):\n                if s[i - 1] == t[j - 1]:\n                    continue\n                if s[i - 1] == 'A' and t[j - 1] == 'B':\n                    continue\n                if s[i - 1] == 'B' and t[j - 1] == 'A':\n                    continue\n                if s[i - 1] == 'C' and t[j - 1] == 'A':\n                    continue\n                if s[i - 1] == 'A' and t[j - 1] == 'C':\n                    continue\n                if s[i - 1] == 'B' and t[j - 1] == 'C':\n                    continue\n                if s[i - 1] == 'C' and t[j - 1] == 'B':\n                    continue\n                if s[i - 1] == 'A' and t[j - 1] == 'A':\n                    continue\n                if s[i - 1] == 'B' and t[j - 1] == 'B':\n                    continue\n                if s[i - 1] == 'C' and t[j - 1] == 'C':\n                    continue\n                return False\n        return True\n\n    result = [0] * n\n    for i in range(m):\n        a, b, c, d = queries[i]\n        if is_possible(s, t, a, b, c, d):\n            result[i] = 1\n\n    return ''.join(map(str, result))\n"
    },
    {
        "number": 1654,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n\n    def count_non_intersecting_occurrences(s: str, t: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                count += 1\n        return count\n\n    def max_suitability(s: str, t: str) -> int:\n        max_occurrences = 0\n        for i in range(len(s)):\n            if s[i] == t[i]:\n                max_occurrences += 1\n        return max_occurrences\n\n    s_occurrences = count_non_intersecting_occurrences(s, t)\n    t_occurrences = count_non_intersecting_occurrences(t, s)\n\n    if s_occurrences > t_occurrences:\n        return s\n    else:\n        return t"
    },
    {
        "number": 1655,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    L = list(map(int, stdin.readline().strip().split()))\n\n    total_alive = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if j < i and j >= i - L[i]:\n                total_alive += 1\n\n    return str(total_alive)"
    },
    {
        "number": 1656,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        if s[i] == 'v':\n            count += 1\n            if count == 4:\n                return count\n    return count"
    },
    {
        "number": 1657,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    devices = [0] * n\n    charger = 0\n    max_time = -1\n\n    for i in range(n):\n        devices[i] = int(input())\n        charger += devices[i]\n\n    for i in range(n):\n        if devices[i] == 0:\n            max_time = max(max_time, i + 1)\n\n    if max_time == -1:\n        return \"-1\"\n\n    return str(max_time)\n"
    },
    {
        "number": 1658,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n\n    def dfs(node, distance):\n        if distance > x:\n            return 1\n        if distance == x:\n            return 1 + dfs(node.left, distance) + dfs(node.right, distance)\n        return 1 + dfs(node.left, distance) + dfs(node.right, distance)\n\n    count = 0\n    for i in range(n):\n        count += dfs(node=d[i], distance=0)\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1659,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    ice_cream_packs = [0] * n\n    kids_left = [0] * n\n    for _ in range(n):\n        line = stdin.readline().strip()\n        if line == '+':\n            ice_cream_packs[int(line.split()[1])] += 1\n        elif line == '-':\n            kids_left[int(line.split()[1])] += 1\n\n    def find_amount_of_ice_cream(i):\n        return ice_cream_packs[i]\n\n    def find_number_of_kids_left_in_distress(i):\n        return kids_left[i]\n\n    return str(find_amount_of_ice_cream(0)) + \" \" + str(find_number_of_kids_left_in_distress(0))\n"
    },
    {
        "number": 1660,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        edges.append((u, v, w))\n\n    def dfs(u, visited, path, max_trail):\n        if u == 1:\n            return max_trail\n\n        if u in visited:\n            return max_trail\n\n        visited.add(u)\n        path.append(u)\n        max_trail = max(max_trail, dfs(v, visited, path, max_trail))\n        path.pop()\n        visited.remove(u)\n        return max_trail\n\n    max_trail = dfs(1, set(), [], 0)\n    return str(max_trail)"
    },
    {
        "number": 1661,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n\n    # Initialize the wallet\n    wallet = [0] * m\n\n    # Buy the games\n    for i in range(n):\n        # Check if the first bill is enough\n        if wallet[0] >= c[i]:\n            # Buy the game\n            wallet[0] -= c[i]\n            print(i + 1)\n            return \"\"\n\n    # If no game is found, return 0\n    return \"0\""
    },
    {
        "number": 1662,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n\n    result = 0\n    for i in range(m):\n        if i == 0:\n            result += b[i]\n        else:\n            result += b[i] - b[i-1]\n\n    return str(result)"
    },
    {
        "number": 1663,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n\n    # Initialize variables\n    price = n\n    result = 0\n    i = 0\n\n    # Compute the sum of all possible resulting prices\n    while i < len(str(price)):\n        # Remove the current digit\n        price = int(str(price)[:i] + str(price)[i+1:])\n\n        # Compute the sum of the resulting prices\n        result += price\n\n        # Move to the next digit\n        i += 1\n\n    # Print the result modulo 10^9 + 7\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 1664,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    program = []\n    for _ in range(n):\n        line = stdin.strip()\n        if line:\n            program.append(line)\n    program = [line.split('=') for line in program]\n    program = [line[0] for line in program]\n    program = [line.strip() for line in program]\n    program = [line for line in program if line[0].isalpha()]\n    program = [line for line in program if not line[0].isdigit()]\n    program = [line for line in program if len(line) > 1]\n    program = [line for line in program if line[0]!= line[1]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6] and line[0]!= line[7]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6] and line[0]!= line[7] and line[0]!= line[8]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6] and line[0]!= line[7] and line[0]!= line[8] and line[0]!= line[9]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6] and line[0]!= line[7] and line[0]!= line[8] and line[0]!= line[9] and line[0]!= line[10]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6] and line[0]!= line[7] and line[0]!= line[8] and line[0]!= line[9] and line[0]!= line[10] and line[0]!= line[11]]\n    program = [line for line in program if line[0]!= line[1] and line[0]!= line[2] and line[0]!= line[3] and line[0]!= line[4] and line[0]!= line[5] and line[0]!= line[6] and line[0]!= line[7] and line[0]!= line[8] and line[0]!= line[9] and line[0]!= line[10] and line[0]!= line[11] and line[0]!= line[12"
    },
    {
        "number": 1665,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n-1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                dfs(v, visited)\n        return u\n\n    def find_label(u, visited):\n        if visited[u]:\n            return u\n        else:\n            visited[u] = True\n            return find_label(u, visited)\n\n    def find_largest_mex(u, visited):\n        mex = float('inf')\n        for v, w in edges[u]:\n            if not visited[v]:\n                mex = min(mex, find_largest_mex(v, visited) + w)\n        return mex\n\n    def write_label(u, visited):\n        label = find_label(u, visited)\n        if label == u:\n            return label\n        else:\n            return write_label(label, visited)\n\n    result = []\n    for u in range(n):\n        visited = [False] * n\n        result.append(write_label(u, visited))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1666,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, a, b = map(int, stdin.split())\n    if x == 1 and y == 1:\n        return \"0\"\n\n    outcomes = []\n    for i in range(x + 1):\n        for j in range(y + 1):\n            if i == 1 and j == 1:\n                outcomes.append(\"0\")\n            else:\n                outcomes.append(str(i) + \" \" + str(j))\n\n    outcomes.sort(key=lambda x: int(x.split()[0]), reverse=True)\n    return \"\\n\".join(outcomes)"
    },
    {
        "number": 1667,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    distances = list(map(int, stdin.strip().split()))\n\n    visited = [False] * n\n    visited[0] = True\n\n    for i in range(1, n):\n        if distances[i] < distances[i - 1]:\n            visited[i] = True\n\n    count = 0\n    for i in range(1, n):\n        if visited[i]:\n            count += 1\n\n    if count == 1:\n        return \"1\"\n    else:\n        return str(count)\n"
    },
    {
        "number": 1668,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        p = list(map(int, stdin.strip().split()))\n        p.sort()\n        p = ''.join(str(p[i]) for i in range(n + 1))\n        print(p)"
    },
    {
        "number": 1669,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    reserved_tokens = stdin.split()\n    target_words = []\n    for token in reserved_tokens:\n        if token.startswith('#'):\n            continue\n        if token.isalpha():\n            target_words.append(token)\n    target_words.sort(key=len, reverse=True)\n    minified_source = ''\n    for i in range(len(target_words)):\n        minified_source += target_words[i]\n        if i < len(target_words) - 1:\n            minified_source +=''\n    return minified_source"
    },
    {
        "number": 1670,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n = int(stdin.readline().strip())\n    teams = []\n    for _ in range(n):\n        team = stdin.readline().strip()\n        teams.append(team)\n\n    # Initialize the result list\n    result = []\n\n    # Process the fouls\n    for i in range(n):\n        # Get the foul information\n        foul_time = int(stdin.readline().strip())\n        foul_letter = stdin.readline().strip()\n        player_number = int(stdin.readline().strip())\n        player_letter = stdin.readline().strip()\n        yellow_card = int(stdin.readline().strip())\n\n        # Check if the player received a yellow card\n        if foul_letter == \"y\":\n            # Check if the player received a red card\n            if yellow_card == 1:\n                # Add the result to the result list\n                result.append(f\"{teams[i]} {player_number} {foul_time}\")\n            else:\n                # Add the result to the result list\n                result.append(f\"{teams[i]} {player_number} {foul_time}\")\n        else:\n            # Add the result to the result list\n            result.append(f\"{teams[i]} {player_number} {foul_time}\")\n\n    # Return the result list\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 1671,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    m = [m[i] for i in range(n)]\n    m.sort()\n    m_sum = sum(m)\n    m_avg = m_sum / n\n    m_min = m[0]\n    m_max = m[-1]\n    m_diff = m_max - m_min\n    m_diff_avg = m_diff / n\n    m_diff_min = m_diff[0]\n    m_diff_max = m_diff[-1]\n    m_diff_avg_min = m_diff_avg[0]\n    m_diff_avg_max = m_diff_avg[-1]\n\n    if m_diff_avg_min == m_diff_avg_max:\n        return \"0\"\n\n    if m_diff_avg_min == m_avg:\n        return str(m_diff_avg_max - m_diff_avg_min)\n\n    if m_diff_avg_max == m_avg:\n        return str(m_diff_avg_min - m_diff_avg_max)\n\n    if m_diff_avg_min < m_avg < m_diff_avg_max:\n        return str(m_diff_avg_max - m_avg)\n\n    if m_diff_avg_min > m_avg > m_diff_avg_max:\n        return str(m_diff_avg_min - m_avg)\n\n    return \"0\""
    },
    {
        "number": 1672,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    groups = []\n    for _ in range(n):\n        row = stdin.readline().strip()\n        if row[0] == '0':\n            groups.append(row)\n        else:\n            groups[-1] += row\n    return str(len(groups))"
    },
    {
        "number": 1673,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    beauty = sum(abs(a[i] - a[j]) for i in range(n) for j in range(i + 1, n)) % 998244353\n    return str(beauty)"
    },
    {
        "number": 1674,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    hits = list(map(int, stdin.split()))\n    s = stdin.strip()\n\n    max_damage = 0\n    current_damage = 0\n    current_count = 0\n\n    for i in range(n):\n        if current_count == k:\n            current_count = 0\n            current_damage += hits[i]\n            max_damage = max(max_damage, current_damage)\n        else:\n            current_count += 1\n\n    return str(max_damage)"
    },
    {
        "number": 1675,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    teams = []\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        teams.append((x, y))\n\n    home_games = 0\n    away_games = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if teams[i][0] == teams[j][0] and teams[i][1] == teams[j][1]:\n                away_games += 1\n            else:\n                home_games += 1\n\n    home_games_count = 0\n    away_games_count = 0\n    for i in range(n):\n        if teams[i][0] == 1:\n            home_games_count += 1\n        else:\n            away_games_count += 1\n\n    return f\"{home_games_count} {away_games_count}\"\n"
    },
    {
        "number": 1676,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, b = map(int, stdin.split())\n    queries = []\n    for _ in range(n):\n        t, d = map(int, stdin.split())\n        queries.append((t, d))\n\n    queries.sort(key=lambda x: x[0])\n\n    result = []\n    for t, d in queries:\n        if t == queries[-1][0]:\n            result.append(t)\n        else:\n            result.append(-1)\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 1677,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def is_almost_arithmetical_progression(s):\n        for i in range(1, len(s)):\n            if s[i] - s[i - 1]!= 1:\n                return False\n        return True\n\n    longest_subsequence = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subsequence = [b[i]]\n            for k in range(j):\n                subsequence.append(b[i] - 1 + (subsequence[-1] - 1) ** k + 1)\n            if is_almost_arithmetical_progression(subsequence):\n                longest_subsequence = max(longest_subsequence, len(subsequence))\n\n    return str(longest_subsequence)\n"
    },
    {
        "number": 1678,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] + a[j] < t:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1679,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    decoded = 0\n    for i in range(n):\n        decoded = decoded * 2 + int(s[i])\n    return str(decoded)"
    },
    {
        "number": 1680,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1681,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    sheets = list(map(str, stdin.split()))\n    max_area = 0\n    for i in range(n):\n        for j in range(m):\n            if sheets[i][j] == 'b':\n                max_area += 1\n            elif sheets[i][j] == 'a':\n                max_area += 3\n            elif sheets[i][j] == 'c':\n                max_area += 1\n    return str(max_area)"
    },
    {
        "number": 1682,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the discounted prices\n    discounted_a = [a[i] * (1 - (b[i] / a[i])) for i in range(n)]\n    discounted_b = [b[i] for i in range(n)]\n\n    # Calculate the minimum amount of money\n    min_amount = sum(discounted_a[:k])\n\n    return str(min_amount)\n"
    },
    {
        "number": 1683,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def f(a, b):\n        if len(a) < len(b):\n            return f(a[1:], b)\n        elif len(a) > len(b):\n            return f(a, b[1:])\n        else:\n            return a[0] * b[0] + f(a[1:], b[1:])\n\n    result = sum(sum(f(a, a)) for a in a) % 998244353\n    return str(result)"
    },
    {
        "number": 1684,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    segments = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        segments.append((a, b))\n\n    def is_rotationally_symmetrical(segments):\n        n = len(segments)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if segments[i][0] == segments[j][1] and segments[i][1] == segments[j][0]:\n                    return False\n        return True\n\n    if is_rotationally_symmetrical(segments):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 1685,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    tree = build_tree(n)\n    result = []\n\n    for _ in range(q):\n        u, s = map(int, stdin.split())\n        path = s.split()\n        path_length = len(path)\n\n        if path_length == 0:\n            result.append(0)\n            continue\n\n        if path[0] == 'U':\n            result.append(tree.get_left_child(u - 1))\n        elif path[0] == 'R':\n            result.append(tree.get_right_child(u - 1))\n        elif path[0] == 'L':\n            result.append(tree.get_parent(u - 1))\n        else:\n            result.append(u - 1)\n\n        for i in range(1, path_length):\n            if path[i] == 'U':\n                result.append(tree.get_left_child(result[-1]))\n            elif path[i] == 'R':\n                result.append(tree.get_right_child(result[-1]))\n            elif path[i] == 'L':\n                result.append(tree.get_parent(result[-1]))\n            else:\n                result.append(result[-1])\n\n    return''.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 1686,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    ip_addresses = []\n    for _ in range(n):\n        ip_addresses.append(int(input()))\n\n    ip_addresses.sort()\n    ip_addresses.reverse()\n\n    subnet_masks = []\n    for i in range(1, len(ip_addresses)):\n        subnet_mask = ip_addresses[i] ^ ip_addresses[i - 1]\n        subnet_masks.append(subnet_mask)\n\n    for subnet_mask in subnet_masks:\n        if sum(1 for i in range(32) if subnet_mask & (1 << i)) == k:\n            return f\"{subnet_mask:08b}\"\n\n    return \"-1\""
    },
    {
        "number": 1687,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(n):\n        if a[i] % a[0]!= 0:\n            return -1\n\n    return a[0]"
    },
    {
        "number": 1688,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_a = max(a)\n    min_a = min(a)\n\n    c = [0] * n\n\n    for i in range(n):\n        c[i] = i + 1\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] < a[j] / 2:\n                c[i] = j\n                break\n\n    for i in range(n):\n        if c[i] == i + 1:\n            c[i] = -1\n\n    return str(c)"
    },
    {
        "number": 1689,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    bus = []\n    for _ in range(n):\n        row = stdin.strip()\n        bus.append(row)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bus[i][j] == 'O' and bus[i][j + 1] == 'O':\n                return \"NO\"\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if bus[i][j] == 'O' and bus[i + 1][j] == 'O':\n                return \"NO\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bus[i][j] == 'O' and bus[i][j - 1] == 'O':\n                return \"NO\"\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if bus[i][j] == 'O' and bus[i - 1][j] == 'O':\n                return \"NO\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if bus[i][j] == 'O' and bus[i][j] == 'O':\n                return \"YES\" + bus[i][j] + bus[i][j]\n\n    return \"YES\" + bus[0][0] + bus[0][0]"
    },
    {
        "number": 1690,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    x = [0] * n\n    for i in range(n):\n        x[i] = a[i]\n\n    max_chocolates = 0\n    for i in range(1, n):\n        for j in range(i):\n            if x[j] == 0:\n                continue\n            if x[j] < x[i]:\n                max_chocolates = max(max_chocolates, i - j)\n                break\n\n    return str(max_chocolates)\n"
    },
    {
        "number": 1691,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n % k!= 0:\n        return \"Error: n must be divisible by k.\"\n\n    sections = []\n    for i in range(n):\n        x = i + 1\n        while x <= k:\n            sections.append(x)\n            x += k\n\n    return \" \".join(map(str, sections))"
    },
    {
        "number": 1692,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i:j] % 4 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 1693,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    m = list(map(int, stdin.strip().split()))\n    a = [0] * n\n    for i in range(n):\n        a[i] = m[i]\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                a[i], a[j] = a[j], a[i]\n    return str(a)"
    },
    {
        "number": 1694,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, f = map(int, stdin.split())\n    steps = list(range(1, m + 1))\n\n    def get_actions(spy_number: int) -> str:\n        if spy_number == s:\n            return \"L\"\n        elif spy_number == f:\n            return \"R\"\n        else:\n            return \"X\"\n\n    def get_neighbours(spy_number: int) -> List[int]:\n        if spy_number == s:\n            return [spy_number - 1, spy_number + 1]\n        elif spy_number == f:\n            return [spy_number - 1, spy_number + 1]\n        else:\n            return [spy_number - 1, spy_number + 1, spy_number - 1, spy_number + 1]\n\n    def get_best_actions(spy_number: int) -> str:\n        actions = get_actions(spy_number)\n        neighbours = get_neighbours(spy_number)\n        best_actions = \"\"\n        best_distance = float(\"inf\")\n\n        for i in steps:\n            if i == steps[-1]:\n                continue\n\n            neighbours_actions = get_actions(neighbours[i - 1])\n            neighbours_distance = abs(i - steps[-1])\n\n            if neighbours_actions == actions and neighbours_distance < best_distance:\n                best_actions = neighbours_actions\n                best_distance = neighbours_distance\n\n        return best_actions\n\n    def print_actions(spy_number: int, actions: str) -> None:\n        print(get_actions(spy_number), end=\"\")\n\n    def print_neighbours(spy_number: int, neighbours: List[int]) -> None:\n        print(get_actions(neighbours[0]), end=\"\")\n        print(get_actions(neighbours[1]), end=\"\")\n        print(get_actions(neighbours[2]), end=\"\")\n        print(get_actions(neighbours[3]), end=\"\")\n\n    def print_actions_neighbours(spy_number: int) -> None:\n        actions = get_actions(spy_number)\n        neighbours = get_neighbours(spy_number)\n        print_actions(spy_number, actions)\n        print_neighbours(spy_number, neighbours)\n\n    for _ in range(m):\n        t, l, r = map(int, stdin.split())\n        steps.append(t)\n\n    for i in range(m):\n        print_actions_neighbours(i + 1)\n        print(\" \" * (m - i - 1), end=\"\")\n        print_actions_neighbours(i + 2)\n        print(\" \" * (m - i - 2), end=\"\")\n        print_actions_neighbours(i + 3)\n        print(\" \" * (m - i - 3), end=\"\")\n        print_actions_neighbours(i + 4)\n        print(\" \" * (m - i - 4), end=\"\")\n        print_actions_neighbours(i + 5)\n        print(\" \" * (m - i - 5), end=\"\")\n        print_actions_neighbours(i + 6)\n        print(\" \" * (m - i - 6), end=\"\")\n        print_actions_neighbours(i + 7)\n        print(\" \" * (m - i - 7), end=\"\")\n        print_actions_neighbours(i + 8)\n        print(\" \" * (m - i - 8), end=\"\")\n        print_actions_neighbours(i + 9)\n        print(\" \" * (m - i - 9), end=\"\")\n        print_actions_neighbours(i + 10)\n        print(\" \" * (m - i - 10), end=\"\")\n        print_actions_neighbours(i + 11)\n        print(\" \" * (m - i - 11), end=\"\")\n        print_actions_neighbours(i + 12)\n        print(\" \" * (m - i - 12), end=\"\")\n        print_actions_neighbours(i + 13)\n        print(\" \" * (m - i - 13), end=\"\")\n        print_actions_neighbours(i + 14)\n        print(\" \" * (m - i - 14), end=\"\")\n        print_actions_neighbours(i + 15)\n        print(\" \" * (m - i - 15), end=\"\")\n        print_actions_neighbours(i + 16)\n        print(\" \" * (m - i - 16), end=\"\")\n        print_actions_neighbours(i + 17)\n        print(\" \" * ("
    },
    {
        "number": 1695,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    answers = [list(map(str, stdin.split())) for _ in range(n)]\n    correct_answers = [int(a[0]) for a in answers]\n    points = [int(a[1]) for a in answers]\n\n    max_score = 0\n    for i in range(m):\n        total_points = 0\n        for j in range(n):\n            if answers[j][i] == correct_answers[j]:\n                total_points += points[j]\n        max_score = max(max_score, total_points)\n\n    return str(max_score)"
    },
    {
        "number": 1696,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    positions = []\n    for _ in range(k):\n        x, y = map(int, stdin.split())\n        positions.append((x, y))\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m\n\n    def is_burning(x, y):\n        for i in range(k):\n            if positions[i][0] == x and positions[i][1] == y:\n                return True\n        return False\n\n    def lighten_up(x, y):\n        for i in range(k):\n            if positions[i][0] == x and positions[i][1] == y:\n                positions[i] = (x, y)\n                return True\n        return False\n\n    def burn_center(x, y):\n        for i in range(k):\n            if positions[i][0] == x and positions[i][1] == y:\n                positions[i] = (x, y)\n                return True\n        return False\n\n    def burn_neighbours(x, y):\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < m and not is_burning(nx, ny):\n                positions[i] = (nx, ny)\n                return True\n        return False\n\n    def burn_all():\n        for i in range(k):\n            positions[i] = (x, y)\n\n    def lighten_up_all():\n        for i in range(k):\n            positions[i] = (x, y)\n\n    def main():\n        while True:\n            burn_all()\n            if is_burning(x, y):\n                return\n            if lighten_up(x, y):\n                return\n            if burn_center(x, y):\n                return\n            if burn_neighbours(x, y):\n                return\n            if lighten_up_all():\n                return\n            if burn_all():\n                return\n\n    main()\n    return str(min(positions, key=lambda p: abs(p[0] - x) + abs(p[1] - y)))\n"
    },
    {
        "number": 1697,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = []\n    for _ in range(n):\n        board.append(list(stdin.strip()))\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == 'A':\n                for k in range(i + 1, n):\n                    if board[k][j]!= 'A' or board[k][j]!= board[i][j]:\n                        return 'No'\n\n    return 'Yes'"
    },
    {
        "number": 1698,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = 1\n    b = 2\n    time = 0\n    for i in range(n):\n        time += a - b\n        a = b\n        b += 1\n    return str(time)"
    },
    {
        "number": 1699,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = []\n    for i in range(n):\n        row = []\n        for j in range(m):\n            row.append(int(input()))\n        table.append(row)\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] > 10**8:\n                table[i][j] = 10**8\n    for i"
    },
    {
        "number": 1700,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    r = \"\"\n    b = \"\"\n    for i in range(n):\n        if s[i] == \"(\":\n            r += \"0\"\n        elif s[i] == \")\":\n            r += \"1\"\n        else:\n            b += \"0\"\n    if r == \"\" and b == \"\":\n        return \"0\"\n    elif r == \"\" and b!= \"\":\n        return \"1\"\n    elif r!= \"\" and b == \"\":\n        return \"0\"\n    else:\n        return \"1\""
    },
    {
        "number": 1701,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    servers = []\n    for _ in range(n):\n        name, ip = stdin.strip().split()\n        servers.append((name, ip))\n\n    commands = []\n    for _ in range(m):\n        command, ip = stdin.strip().split()\n        commands.append((command, ip))\n\n    for command, ip in commands:\n        if ip in [server[1] for server in servers]:\n            commands.remove((command, ip))\n            commands.append((command, ip + \" #\" + server[0]))\n\n    return '\\n'.join(commands)"
    },
    {
        "number": 1702,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    accounts = []\n    for _ in range(n):\n        a = int(stdin.strip())\n        accounts.append(a)\n\n    def solve(i, j):\n        if i == j:\n            return 0\n        if i == n - 1:\n            return accounts[i]\n        if j == n - 1:\n            return accounts[i]\n        if accounts[i] == -1:\n            return solve(i + 1, j)\n        if accounts[j] == -1:\n            return solve(i, j + 1)\n        if accounts[i] > accounts[j]:\n            return solve(i + 1, j)\n        else:\n            return solve(i, j + 1)\n\n    return str(solve(0, 0))\n"
    },
    {
        "number": 1703,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = set()\n    for _ in range(n):\n        s = input().strip()\n        if s.startswith(\"(\") and s.endswith(\")\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\")\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\")\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s.startswith(\"(\") and s.endswith(\"(\"):\n            pairs.add((s[1:-1], s[1:-1]))\n        elif s"
    },
    {
        "number": 1704,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [int(digit) for digit in stdin.split()]\n    max_digits = max(digits)\n    max_digits_with_k = max_digits + k\n\n    for i in range(max_digits_with_k):\n        if digits[i] == 0:\n            continue\n        for j in range(7):\n            if digits[i] & (1 << j):\n                digits[i] ^= (1 << j)\n\n    return ''.join(map(str, digits))\n"
    },
    {
        "number": 1705,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    doors = list(map(int, stdin.strip().split()))\n\n    left_exit = 0\n    right_exit = n - 1\n\n    for i in range(n):\n        if doors[i] == 0:\n            left_exit = i\n        elif doors[i] == 1:\n            right_exit = i\n\n    if left_exit == right_exit:\n        return \"No solution\"\n\n    k = 0\n    for i in range(left_exit, right_exit + 1):\n        if doors[i] == 0:\n            k += 1\n\n    return str(k)"
    },
    {
        "number": 1706,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    s = stdin\n    k = 0\n\n    for i in range(n):\n        if i > 0 and s[i] == s[i - 1]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2] and i > 2 and s[i] == s[i - 3]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2] and i > 2 and s[i] == s[i - 3] and i < n - 3 and s[i] == s[i + 3]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2] and i > 2 and s[i] == s[i - 3] and i < n - 3 and s[i] == s[i + 3] and i > 3 and s[i] == s[i - 4]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2] and i > 2 and s[i] == s[i - 3] and i < n - 3 and s[i] == s[i + 3] and i > 3 and s[i] == s[i - 4] and i < n - 4 and s[i] == s[i + 4]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2] and i > 2 and s[i] == s[i - 3] and i < n - 3 and s[i] == s[i + 3] and i > 3 and s[i] == s[i - 4] and i < n - 4 and s[i] == s[i + 4] and i > 4 and s[i] == s[i - 5]:\n            continue\n        if i > 0 and s[i] == s[i - 1] and i < n - 1 and s[i] == s[i + 1] and i > 1 and s[i] == s[i - 2] and i < n - 2 and s[i] == s[i + 2] and i > 2 and s[i] == s[i - 3] and i < n - 3 and s[i] == s[i + 3] and i > 3 and s["
    },
    {
        "number": 1707,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            pairs.append((a[i], a[j]))\n    return str(len(pairs))"
    },
    {
        "number": 1708,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    orders = []\n    for _ in range(m):\n        t, d = map(int, stdin.split())\n        orders.append((t, d))\n\n    def get_cheapest_kind(ingredients):\n        cheapest = float('inf')\n        cheapest_kind = -1\n        for i, cost in enumerate(ingredients):\n            if cost < cheapest:\n                cheapest = cost\n                cheapest_kind = i\n        return cheapest_kind\n\n    def get_cost(ingredients, remain):\n        cost = 0\n        for i, cost in enumerate(ingredients):\n            if remain[i] > 0:\n                cost += cost * remain[i]\n            else:\n                cost += cost * 1\n        return cost\n\n    def get_total_cost(ingredients, remain):\n        cost = get_cost(ingredients, remain)\n        for i, cost in enumerate(ingredients):\n            if remain[i] > 0:\n                cost += cost * remain[i]\n            else:\n                cost += cost * 1\n        return cost\n\n    def get_total_cost_for_customer(customer_orders, remain):\n        total_cost = 0\n        for t, d in customer_orders:\n            total_cost += get_total_cost(orders[t - 1][1:], remain)\n        return total_cost\n\n    def get_total_cost_for_customers(customers):\n        total_cost = 0\n        for i in range(m):\n            total_cost += get_total_cost_for_customer(orders[i], a)\n        return total_cost\n\n    return str(get_total_cost_for_customers(orders))\n"
    },
    {
        "number": 1709,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    trees = []\n    colors = []\n    for _ in range(n):\n        color = int(stdin.readline())\n        trees.append(color)\n        colors.append(color)\n\n    for _ in range(m):\n        p = int(stdin.readline())\n        trees.append(p)\n        colors.append(p)\n\n    beauty = 0\n    for i in range(n):\n        if trees[i] == 0:\n            beauty += 1\n\n    if beauty == k:\n        return \"0\"\n    else:\n        return str(beauty)"
    },
    {
        "number": 1710,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] * a[j] == k:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1711,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if i < j:\n                count += 1\n                if j < i + 1:\n                    count += 1\n                if j >= i + 1:\n                    count += 1\n    return str(count % 998244353)"
    },
    {
        "number": 1712,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    vanya_hits = 0\n    vova_hits = 0\n    both_hits = 0\n\n    for i in range(n):\n        if a[i] == 1:\n            vanya_hits += 1\n        elif a[i] == 2:\n            vova_hits += 1\n        else:\n            both_hits += 1\n\n    if vanya_hits == 0 and vova_hits == 0:\n        return \"Both\"\n    elif vanya_hits == 0:\n        return \"Vova\"\n    elif vova_hits == 0:\n        return \"Vanya\"\n    else:\n        return \"Both\""
    },
    {
        "number": 1713,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    if s == t:\n        return \"0\"\n\n    if s > t:\n        return \"-1\"\n\n    shuffling_operations = 0\n    for i in range(n):\n        if p[i] == i + 1:\n            shuffling_operations += 1\n            p[i], p[i + 1] = p[i + 1], p[i]\n\n    return str(shuffling_operations)\n"
    },
    {
        "number": 1714,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = [0] * (2 * n)\n    a[0] = 1\n    a[1] = 2\n    for i in range(2, 2 * n):\n        a[i] = a[i - 1] + a[i - 2]\n    a[2 * n - 1] = 2 * k\n    return''.join(map(str, a))"
    },
    {
        "number": 1715,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, Q = map(int, stdin.split())\n    s_west = [int(x) for x in stdin.split()]\n    t_west = [int(x) for x in stdin.split()]\n    x_west = [int(x) for x in stdin.split()]\n\n    def min_distance(s_i, t_i, x_i):\n        return abs(s_i - x_i) + abs(t_i - x_i)\n\n    def min_distance_between_shrines_and_temples(s_west, t_west, x_west):\n        min_distance_s = float('inf')\n        min_distance_t = float('inf')\n        min_distance_x = float('inf')\n\n        for s_i, t_i, x_i in zip(s_west, t_west, x_west):\n            min_distance_s = min(min_distance_s, min_distance(s_i, t_i, x_i))\n            min_distance_t = min(min_distance_t, min_distance(s_i, t_i, x_i))\n            min_distance_x = min(min_distance_x, min_distance(s_i, t_i, x_i))\n\n        return min(min_distance_s, min_distance_t, min_distance_x)\n\n    min_distance_between_shrines_and_temples_sum = 0\n    for _ in range(Q):\n        s_i, t_i, x_i = map(int, stdin.split())\n        min_distance_between_shrines_and_temples_sum += min_distance_between_shrines_and_temples(s_west, t_west, x_west)\n\n    return str(min_distance_between_shrines_and_temples_sum)\n"
    },
    {
        "number": 1716,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, Q = map(int, stdin.split())\n    trains = []\n    for _ in range(M):\n        train = list(map(int, stdin.split()))\n        trains.append(train)\n\n    p, q = map(int, stdin.split())\n    p_i, q_i = trains[p - 1], trains[q - 1]\n\n    trains = [train for train in trains if train[0] <= p_i <= train[1] and train[0] <= q_i <= train[1]]\n    trains.sort()\n\n    count = 0\n    for train in trains:\n        if train[0] <= p_i <= train[1] and train[0] <= q_i <= train[1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1717,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    x = 0\n    while x < N:\n        y = 2\n        while y <= N:\n            if y % x == 1:\n                break\n            y += 1\n        else:\n            x += 1\n    return str(x)"
    },
    {
        "number": 1718,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    # Perform K consecutive operations\n    for _ in range(K):\n        # Find the minimum value among the chosen elements\n        min_val = float('inf')\n        for i in range(N):\n            if A[i] < min_val:\n                min_val = A[i]\n        # Replace the value of each chosen element with the minimum value\n        for i in range(N):\n            if A[i] == min_val:\n                A[i] = i + 1\n\n    # Print the minimum number of operations required\n    return str(N - K)"
    },
    {
        "number": 1719,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            for j in range(i, n+1, 2):\n                if j % 2 == 0:\n                    continue\n                if 'AGC' in str(j):\n                    continue\n                count += 1\n    return str(count)"
    },
    {
        "number": 1720,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    room = [[0] * m for _ in range(n)]\n    for _ in range(m):\n        room[0].append(\".\")\n    for _ in range(m - 1):\n        room[n - 1].append(\".\")\n    for _ in range(n - 1):\n        room[0].append(\".\")\n    for _ in range(n - 1):\n        room[n - 1].append(\".\")\n\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    dx = [0, 0, 1, -1]\n    dy = [-1, 1, 0, 0]\n\n    def dfs(x, y, time):\n        if x == x2 and y == y2:\n            return time\n\n        if x < 0 or x >= n or y < 0 or y >= m or room[x][y] == \"#\":\n            return -1\n\n        room[x][y] = \"#\"\n        for i in range(4):\n            nx = x + dx[i]\n            ny = y + dy[i]\n            if 0 <= nx < n and 0 <= ny < m and room[nx][ny] == \"#\":\n                time = dfs(nx, ny, time + 1)\n\n        room[x][y] = \".\"\n        return time\n\n    return str(dfs(x1, y1, 0))"
    },
    {
        "number": 1721,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    s = s[::-1]\n    swaps = 0\n    for i in range(n):\n        if s[i] == s[i+1]:\n            swaps += 1\n            s = s[:i] + s[i+1:] + s[i+2:]\n    return swaps"
    },
    {
        "number": 1722,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    names = stdin.strip().split()\n    x = 0\n    for i in range(n):\n        name = names[i]\n        if name[0] == name[1]:\n            x += 1\n    return str(x)"
    },
    {
        "number": 1723,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    trees = []\n    for _ in range(n):\n        u, v = map(int, stdin.strip().split())\n        trees.append((u, v))\n\n    def dfs(u, depth, visited):\n        if depth == 0:\n            return 1\n        if depth % 2 == 0:\n            even_count = dfs(u, depth + 1, visited)\n        else:\n            odd_count = dfs(u, depth + 1, visited)\n        if u in visited or v in visited:\n            return 0\n        visited.add(u)\n        visited.add(v)\n        return min(even_count, odd_count)\n\n    for tree in trees:\n        u, v = tree\n        depth = dfs(u, 0, set())\n        if depth == 0:\n            trees.remove(tree)\n        else:\n            print(\" \".join(map(str, tree)))\n            break\n\n    if not trees:\n        return \"-1\"\n\n    return \"\\n\".join(map(str, trees[0]))\n"
    },
    {
        "number": 1724,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    m = sum(2**i * a[i] for i in range(n))\n    max_f = float('-inf')\n    for x in range(0, m + 1):\n        f = sum(a[i] * bit(x, i) for i in range(n))\n        if f > max_f:\n            max_f = f\n    return str(max_f)\n\n\ndef"
    },
    {
        "number": 1725,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    min_moves = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if a[i][j] == d:\n                min_moves = min(min_moves, abs(i - j))\n\n    if min_moves == float('inf'):\n        return \"-1\"\n    else:\n        return str(min_moves)"
    },
    {
        "number": 1726,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = [int(x) for x in stdin.split()]\n\n    # Calculate the number of days required to finish reading\n    days = [0] * n\n    for i in range(n):\n        days[i] = a[i] // t\n\n    # Calculate the minimum number of days required to finish reading\n    min_days = float('inf')\n    for i in range(n):\n        if days[i] < min_days:\n            min_days = days[i]\n\n    return str(min_days)\n"
    },
    {
        "number": 1727,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    trees = []\n    for _ in range(n):\n        x, h = map(int, stdin.readline().strip().split())\n        trees.append((x, h))\n\n    def fell_tree(x, h, trees):\n        for i, tree in enumerate(trees):\n            if tree[0] <= x <= tree[1]:\n                if i == 0 or tree[0]!= trees[i - 1][1]:\n                    return i\n                else:\n                    return fell_tree(x, h, trees[:i] + trees[i + 1:])\n\n    max_trees = 0\n    for x, h in trees:\n        max_trees = max(max_trees, fell_tree(x, h, trees))\n\n    return str(max_trees)\n"
    },
    {
        "number": 1728,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    c = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(v, color):\n        if v == 1:\n            return 0\n        if color == 0:\n            return 1\n        if color == c[v]:\n            return 1\n        return 1 + max(dfs(p[v], color), dfs(p[v], 0))\n\n    return str(dfs(1, 0))"
    },
    {
        "number": 1729,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    s = stdin.strip()\n    dp = [0] * n\n    cp = [0] * n\n    dp[0] = 1\n    cp[0] = 1\n\n    for i in range(1, n):\n        if s[i] == '<':\n            dp[i] = 1\n            cp[i] = 1\n        elif s[i] == '>':\n            dp[i] = 1\n            cp[i] = n - 1\n        else:\n            dp[i] = 0\n            cp[i] = 0\n\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        x = [0] * 10\n        for i in range(l, r + 1):\n            x[cp[i]] += 1\n            if x[cp[i]] == 1:\n                dp[i] -= 1\n                if dp[i] == 0:\n                    cp[i] = 0\n                    x[cp[i]] = 0\n        print(' '.join(map(str, x)))\n\n    return ''"
    },
    {
        "number": 1730,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (n + 1)\n    cycle = []\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, cycle)\n\n    return str(k + 1) + \" \" + \" \".join(map(str, cycle))\n\n\ndef"
    },
    {
        "number": 1731,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if len(set(a[i:j+1]) & set(b[i:j+1])) == m:\n                count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 1732,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    l = list(map(int, stdin.readline().strip().split()))\n    c = list(map(int, stdin.readline().strip().split()))\n\n    # Check if it is impossible to buy some cards and become able to jump to any cell\n    if sum(c) < 100:\n        return \"-1\"\n\n    # Calculate the minimal cost\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_cost = min(min_cost, c[i] + c[j])\n\n    return str(min_cost)\n"
    },
    {
        "number": 1733,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    roads = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n\n    def dfs(u, visited):\n        if u == x or u == y:\n            return True\n        visited[u] = True\n        for v, w in roads:\n            if not visited[v]:\n                if dfs(v, visited):\n                    return True\n        return False\n\n    visited = [False] * n\n    if dfs(1, visited):\n        return \"5\"\n    if dfs(2, visited):\n        return \"4\"\n    return \"0\""
    },
    {
        "number": 1734,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    contacts = []\n    for _ in range(n):\n        num = int(stdin.strip())\n        contacts.append(num)\n\n    min_length = float('inf')\n    min_sequence = ''\n\n    for num in contacts:\n        if len(str(num)) < min_length:\n            min_length = len(str(num))\n            min_sequence = str(num)\n\n    return min_sequence\n"
    },
    {
        "number": 1735,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) % 2 == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 1736,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_books = 0\n    for i in range(n):\n        if i == 0:\n            max_books = i + 1\n        else:\n            max_books = max(max_books, i + 1)\n\n    return str(max_books)\n"
    },
    {
        "number": 1737,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    projects = []\n    for _ in range(n):\n        name, version = stdin.strip().split()\n        projects.append((name, int(version)))\n\n    def dfs(project, visited):\n        if project in visited:\n            return\n        visited.add(project)\n        for dep in projects[project][1:]:\n            if dep not in visited:\n                dfs(dep, visited)\n\n    visited = set()\n    dfs(0, visited)\n    result = []\n    for project in sorted(visited):\n        result.append(project)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1738,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    compressed_versions = []\n    for i in range(1, len(s) + 1):\n        compressed_version = []\n        for j in range(1, i + 1):\n            compressed_version.append(str(int(s[i - 1]) * j))\n        compressed_versions.append(''.join(compressed_version))\n    compressed_versions.sort(key=len, reverse=True)\n    return compressed_versions[0]"
    },
    {
        "number": 1739,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    s = a[0]\n    t = a[1]\n\n    for i in range(2, n):\n        s = (s * x + a[i]) % 1000000007\n        t = (t * x + a[i]) % 1000000007\n\n    gcd = (s * t) % 1000000007\n    remainder = (s * t) // 1000000007\n\n    return str(remainder)"
    },
    {
        "number": 1740,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    kittens = []\n    for _ in range(n - 1):\n        x, y = map(int, stdin.strip().split())\n        kittens.append((x, y))\n\n    def partition(x, y):\n        for i in range(n):\n            if i == x or i == y:\n                continue\n            if kittens[i][0] == x and kittens[i][1] == y:\n                return i\n        return -1\n\n    def union(x, y):\n        x_partition = partition(x, y)\n        y_partition = partition(y, x)\n        if x_partition == -1 or y_partition == -1:\n            return\n        kittens[x_partition] = (x, y)\n        kittens[y_partition] = (y, x)\n\n    for day in range(n - 1):\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if kittens[i][0] == j and kittens[i][1] == day:\n                    union(i, j)\n\n    result = []\n    for i in range(n):\n        result.append(i + 1)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1741,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    animals = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        animals.append((x, y))\n\n    river_x, river_y = animals[0]\n    river_radius = 0\n    for i in range(1, n):\n        if animals[i][0]!= animals[i - 1][0]:\n            river_radius += 1\n\n    if river_radius > 1:\n        return \"-1\"\n\n    min_radius = river_radius\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(animals[i][0] - animals[j][0]) <= 1 and abs(animals[i][1] - animals[j][1]) <= 1:\n                min_radius = min(min_radius, abs(animals[i][0] - animals[j][0]) + abs(animals[i][1] - animals[j][1]))\n\n    return str(min_radius)\n"
    },
    {
        "number": 1742,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    u = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    # Find the maximal number of places she can move forward\n    max_moves = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] < p[j]:\n                max_moves = max(max_moves, j - i)\n\n    return str(max_moves)\n"
    },
    {
        "number": 1743,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(int, stdin.split()[1:]))\n    b = list(map(int, stdin.split()[1:]))\n    c = list(map(int, stdin.split()[1:]))\n\n    max_joy = 0\n    for i in range(n):\n        if a[i] == 1 and b[i] == 1 and c[i] == 1:\n            max_joy += 1\n\n    return str(max_joy)\n"
    },
    {
        "number": 1744,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    t.sort()\n    count = [0] * n\n    for i in range(n):\n        count[i] = i + 1\n    for i in range(n - 1, -1, -1):\n        if t[i] <= M:\n            count[i] = min(count[i], count[i + 1]) + 1\n    return str(count)"
    },
    {
        "number": 1745,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    city = []\n    for _ in range(n):\n        city.append(list(stdin.strip()))\n\n    def dfs(x, y, visited):\n        if x < 0 or x >= n or y < 0 or y >= m or city[x][y] == '.' or visited[x][y]:\n            return 0\n\n        visited[x][y] = True\n        count = 0\n        count += dfs(x - 1, y, visited)\n        count += dfs(x + 1, y, visited)\n        count += dfs(x, y - 1, visited)\n        count += dfs(x, y + 1, visited)\n        return count\n\n    visited = [[False] * m for _ in range(n)]\n    count = dfs(0, 0, visited)\n    return str(count)"
    },
    {
        "number": 1746,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    spruce = True\n    for i in range(n - 1):\n        p = int(stdin.readline().strip())\n        if p == i + 1:\n            spruce = False\n            break\n    return \"Yes\" if spruce else \"No\""
    },
    {
        "number": 1747,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    l, r = 0, 0\n    for i in range(1, n):\n        if a[i]!= a[i - 1]:\n            r += 1\n            if r == k:\n                l = i\n                break\n\n    return str(l) + \" \" + str(r)\n"
    },
    {
        "number": 1748,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    snow_piles = []\n    snow_volume = 0\n    for i in range(n):\n        snow_piles.append(int(stdin.strip()))\n        snow_volume += snow_piles[-1]\n    snow_volume = sum(snow_piles)\n    return str(snow_volume)"
    },
    {
        "number": 1749,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Check if Stepan deceived his brother\n    if a[l] == b[r]:\n        return \"TRUTH\"\n    else:\n        return \"LIE\""
    },
    {
        "number": 1750,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = [int(stdin.readline().strip()) for _ in range(n)]\n    colors.sort()\n    k = len(colors)\n    result = []\n    for i in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        c, d = map(int, stdin.readline().strip().split())\n        if a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c:\n            result.append(colors[i])\n        elif a == c and c == d and d == b:\n            result.append(colors[i])\n        elif a == b and b == c and c == d:\n            result.append(colors[i])\n        elif a == b and b == d and d == c"
    },
    {
        "number": 1751,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n\n    def dfs(p, visited, cycle):\n        if len(visited) == n:\n            return True\n\n        for i in range(n):\n            if i in visited or p[i] > p[i + 1]:\n                continue\n\n            visited.add(i)\n            cycle.append(p[i])\n            if dfs(p, visited, cycle):\n                return True\n            cycle.pop()\n            visited.remove(i)\n\n        return False\n\n    def count_cyclic_permutations(p):\n        visited = set()\n        cycle = []\n        if dfs(p, visited, cycle):\n            return 1\n        return 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] > p[j]:\n                break\n        else:\n            continue\n\n        for k in range(i + 1, n):\n            if p[i] > p[k] and p[i] > p[k + 1]:\n                break\n        else:\n            continue\n\n        for l in range(k + 1, n):\n            if p[i] > p[l] and p[i] > p[l + 1]:\n                break\n        else:\n            continue\n\n        if count_cyclic_permutations([p[i], p[j], p[k], p[l]]) == 1:\n            return str(count_cyclic_permutations([p[i], p[j], p[k], p[l]])) % MOD\n\n    return \"0\" % MOD"
    },
    {
        "number": 1752,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    heights = [a[i] for i in range(n)]\n\n    def find_circle(heights):\n        max_diff = float('-inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = abs(heights[i] - heights[j])\n                if diff > max_diff:\n                    max_diff = diff\n        return max_diff\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_heights.reverse()\n\n    circle_heights = [heights[i] for i in range(n)]\n    circle_heights.sort()\n    circle_height"
    },
    {
        "number": 1753,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    pairs = list(map(int, stdin.split()))\n\n    def is_connected(a, b):\n        return any(colors[a] in colors[b] for pair in pairs for i in range(pair))\n\n    def is_harmonious(a, b):\n        return colors[a] == colors[b]\n\n    def find_arrangement(colors):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_connected(i, j) and is_harmonious(i, j):\n                    return i, j\n\n    arrangement = find_arrangement(colors)\n    if arrangement is None:\n        return \"No arrangement found.\"\n\n    rooks = []\n    for i in range(arrangement[0], arrangement[1] + 1):\n        rooks.append(i)\n\n    return \"\\n\".join(map(str, rooks))\n"
    },
    {
        "number": 1754,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    s = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n\n    # Calculate the minimal number of schools to be made up\n    min_schools = 0\n    for i in range(n):\n        if p[i] > 0:\n            min_schools += 1\n\n    # Calculate the number of schools to be made up by Arkady\n    num_schools = min_schools + k\n\n    # Calculate the number of students to be made up by Arkady\n    num_students = 0\n    for i in range(n):\n        if p[i] > 0:\n            num_students += s[i]\n\n    # Calculate the number of students to be made up by Technogoblet\n    num_technogoblet = 0\n    for i in range(n):\n        if p[i] > 0:\n            num_technogoblet += s[i]\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady = num_students + num_technogoblet\n\n    # Calculate the number of students to be made up by Technogoblet\n    num_technogoblet_arkady = num_technogoblet + num_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet = num_arkady + num_technogoblet\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady = num_arkady_technogoblet + num_technogoblet_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady = num_arkady_technogoblet_arkady + num_technogoblet_arkady_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady_arkady = num_arkady_technogoblet_arkady_arkady + num_technogoblet_arkady_arkady_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady_arkady_arkady = num_arkady_technogoblet_arkady_arkady_arkady + num_technogoblet_arkady_arkady_arkady_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady = num_arkady_technogoblet_arkady_arkady_arkady_arkady + num_technogoblet_arkady_arkady_arkady_arkady_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady = num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady + num_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady_arkady_arkady = num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady_arkady + num_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady_arkady_arkady\n\n    # Calculate the number of students to be made up by Arkady\n    num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady_arkady_arkady_arkady = num_arkady_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady_arkady_arkady_arkady + num_technogoblet_arkady_arkady_arkady_arkady_arkady_arkady_arkady"
    },
    {
        "number": 1755,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = set(map(int, stdin.split()))\n\n    if k == 0:\n        return \"-1\"\n\n    min_ops = float('inf')\n    for i in range(n):\n        if i not in b:\n            for x in range(i + 1, n + 1):\n                if x not in b:\n                    a[i], a[x] = a[x], a[i]\n                    min_ops = min(min_ops, i + 1)\n                    break\n\n    return str(min_ops)\n"
    },
    {
        "number": 1756,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    months = [1] * n\n    months[0] = 1\n    for i in range(1, n):\n        months[i] = months[i-1] + months[i-1] + 1\n    days = [0] * n\n    for i in range(1, n):\n        days[i] = months[i-1] * days[i-1]\n    max_hugs = 0\n    for i in range(1, n):\n        for j in range(1, days[i]):\n            max_hugs = max(max_hugs, j)\n    return str(max_hugs)"
    },
    {
        "number": 1757,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    fibonacci = [1, 1]\n    for i in range(2, n + 1):\n        fibonacci.append(fibonacci[i - 1] + fibonacci[i - 2])\n    name = \"\"\n    for i in range(n):\n        if fibonacci[i] % 2 == 0:\n            name += \"O\"\n        else:\n            name += \"o\"\n    return name"
    },
    {
        "number": 1758,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    t = stdin.strip()\n\n    # Check if it is impossible to convert s to t\n    if len(s)!= len(t):\n        return \"-1\"\n\n    # Perform rotation k times\n    for _ in range(n):\n        # Rotate s clockwise\n        s = s[1:] + s[0] + s[1:]\n        # Rotate t clockwise\n        t = t[1:] + t[0] + t[1:]\n\n    return len(s) - len(t)\n"
    },
    {
        "number": 1759,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    pictures = []\n    for _ in range(m):\n        colors = list(map(int, stdin.split()))\n        pictures.append(colors)\n\n    def paint(painter, picture):\n        for i in range(n):\n            if painter[i] == picture[i]:\n                continue\n            painter[i] = picture[i]\n            for j in range(i + 1, n):\n                painter[j] = picture[j]\n\n    def work(painter, picture):\n        paint(painter, picture)\n        for i in range(n):\n            if painter[i] == picture[i]:\n                continue\n            paint(painter, picture)\n\n    def get_ready_time(painter, picture):\n        for i in range(n):\n            if painter[i] == picture[i]:\n                continue\n            return i\n\n    ready_times = [get_ready_time(painter, picture) for picture in pictures]\n    return''.join(map(str, ready_times))"
    },
    {
        "number": 1760,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    steps = [int(x) for x in s]\n    pointers = [0] * n\n    duration = [0] * n\n    for i in range(1, n):\n        if s[i] == 'U':\n            pointers[i] = pointers[i - 1] - 1\n        elif s[i] == 'D':\n            pointers[i] = pointers[i - 1] + 1\n        duration[i] = pointers[i] - steps[i - 1]\n    for i in range(n):\n        if pointers[i] == 0:\n            duration[i] = -1\n    return''.join(map(str, duration))"
    },
    {
        "number": 1761,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    message = stdin.strip()\n\n    # Decode the message\n    decoded_message = \"\"\n    for i in range(n):\n        word = message[i]\n        if word == \"<\":\n            decoded_message += \"heart\"\n        elif word.isdigit():\n            decoded_message += str(int(word))\n        else:\n            decoded_message += word\n\n    # Check if the decoded message matches the original message\n    if decoded_message == message:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 1762,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    videos = []\n    for _ in range(n):\n        s, m = map(int, stdin.split())\n        videos.append((s, m))\n\n    videos.sort(key=lambda x: x[0])\n\n    e = [0] * n\n    for s, m in videos:\n        e[s // 60] += m\n\n    return str(e)"
    },
    {
        "number": 1763,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, R, M = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    # Initialize the heights of the pillars\n    pillars = [0] * N\n    for i in range(N):\n        pillars[i] = h[i]\n\n    # Perform operations\n    for i in range(N - 1, -1, -1):\n        if pillars[i] == 0:\n            continue\n\n        if pillars[i] > 0:\n            pillars[i] -= 1\n            pillars[i + 1] += 1\n        else:\n            pillars[i] += 1\n            pillars[i - 1] -= 1\n\n    # Calculate the total cost\n    total_cost = 0\n    for i in range(N):\n        total_cost += pillars[i] * A\n\n    return str(total_cost)\n"
    },
    {
        "number": 1764,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize variables\n    s = [0] * n\n    t = [0] * n\n    record = []\n\n    # Process each game\n    for i in range(n):\n        # Check if the serve was won by Petya\n        if a[i] == 1:\n            s[i] += 1\n        # Check if the serve was won by Gena\n        elif a[i] == 2:\n            t[i] += 1\n\n        # Check if the serve was won by both players\n        if s[i] > 0 and t[i] > 0:\n            # Check if the current serve is the first one\n            if i == 0:\n                # If it is, add the current serve to the record\n                record.append(s[i])\n            else:\n                # If it is not, check if the current serve is the same as the previous one\n                if s[i] == record[-1]:\n                    # If it is, add the current serve to the record\n                    record.append(s[i])\n                else:\n                    # If it is not, add the previous serve to the record\n                    record.append(record[-1])\n\n            # Update the current serve\n            s[i] = 0\n            t[i] = 0\n\n    # Print the options\n    for i in range(n):\n        print(f\"{i+1} {record[i]}\")\n\n    return \"\""
    },
    {
        "number": 1765,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def is_divisible_by_2(num):\n        return num & (num - 1) == 0\n\n    def is_valid_number(num):\n        return num > 0 and is_divisible_by_2(num)\n\n    def find_max_beauty(numbers):\n        max_beauty = -1\n        for num in numbers:\n            if is_valid_number(num):\n                beauty = num\n                for i in range(num, 2**max_beauty, 2):\n                    if is_valid_number(i):\n                        beauty = i\n                        break\n                if beauty > max_beauty:\n                    max_beauty = beauty\n        return max_beauty\n\n    max_beauty = find_max_beauty(a)\n    if max_beauty == -1:\n        print(-1)\n    else:\n        print(max_beauty)\n\n    return \"\""
    },
    {
        "number": 1766,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cards = list(map(int, stdin.strip().split()))\n    sereja_sum = 0\n    dima_sum = 0\n    for card in cards:\n        sereja_sum += card\n        dima_sum += card\n    if sereja_sum > dima_sum:\n        return str(n - sereja_sum) + \" \" + str(n - dima_sum)\n    else:\n        return str(n - dima_sum) + \" \" + str(n - sereja_sum)"
    },
    {
        "number": 1767,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def f(x, l, r):\n        return sum(x[l] | x[l + 1] |... | x[r])\n\n    max_sum = float('-inf')\n    for l in range(n):\n        for r in range(l + 1, n):\n            max_sum = max(max_sum, f(a, l, r) + f(b, l, r))\n\n    return str(max_sum)"
    },
    {
        "number": 1768,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    q = int(stdin.split()[1])\n    plans = []\n    for _ in range(q):\n        plan = list(map(int, stdin.split()))\n        plans.append(plan)\n\n    max_koyomity = 0\n    for plan in plans:\n        m, c = plan\n        max_koyomity = max(max_koyomity, m * len(set(s.replace(c, ''))))\n\n    return str(max_koyomity)\n"
    },
    {
        "number": 1769,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    stops = []\n    for i in range(A + 1):\n        stops.append(i + 1)\n    for i in range(B + 1):\n        stops.append(N - i)\n    return''.join(map(str, stops))"
    },
    {
        "number": 1770,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n, x, y, d = map(int, stdin.readline().strip().split())\n        if x == 1 and y == n:\n            print(0)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == n and y == n:\n            print(0)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n            print(1)\n            continue\n        if x == n and y == 1:\n            print(1)\n            continue\n        if x == 1 and y == n - 1:\n            print(1)\n            continue\n        if x == n and y == n - 1:\n            print(1)\n            continue\n        if x == 1 and y == 1:\n           "
    },
    {
        "number": 1771,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, w_max = map(int, stdin.split())\n    clouds = []\n    for _ in range(n):\n        x, v = map(int, stdin.split())\n        clouds.append((x, v))\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if clouds[i][0] < clouds[j][0] + l and abs(clouds[i][1]) <= abs(clouds[j][1]):\n                pairs.append((i, j))\n\n    return str(len(pairs))"
    },
    {
        "number": 1772,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_large_bouquets = 0\n    for i in range(n):\n        if i > 0 and a[i] == a[i-1]:\n            max_large_bouquets += 1\n\n    return str(max_large_bouquets)"
    },
    {
        "number": 1773,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    trees = []\n    for _ in range(n):\n        x, a = map(int, stdin.strip().split())\n        trees.append((x, a))\n\n    def dfs(x, a, visited):\n        if x == 0:\n            return a\n\n        if x not in visited:\n            visited.add(x)\n            if x == -1:\n                return dfs(x + 1, a, visited)\n            elif x == 1:\n                return dfs(x - 1, a, visited)\n            else:\n                return dfs(x, a - 1, visited)\n\n    max_apples = 0\n    for x, a in trees:\n        visited = set()\n        max_apples = max(max_apples, dfs(x, a, visited))\n\n    return max_apples\n"
    },
    {
        "number": 1774,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    commands = stdin.split()\n    if len(commands)!= 4:\n        return \"No\"\n\n    command1 = commands[0]\n    command2 = commands[1]\n    command3 = commands[2]\n    command4 = commands[3]\n\n    if command1 == \"HHHH\":\n        if command2 == \"HHHH\":\n            if command3 == \"HHHH\":\n                if command4 == \"HHHH\":\n                    return \"Yes\"\n                else:\n                    return \"No\"\n            else:\n                return \"No\"\n        else:\n            return \"No\"\n    else:\n        return \"No\""
    },
    {
        "number": 1775,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    droids = []\n    for _ in range(n):\n        droid = list(map(int, stdin.split()))\n        droids.append(droid)\n\n    max_length = 0\n    max_shots = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            if droids[i][j] > droids[i][j - 1]:\n                max_length += 1\n                max_shots += 1\n\n    return''.join(map(str, [max_shots]))\n"
    },
    {
        "number": 1776,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, M = map(int, stdin.split())\n    erased_operators = P + M\n    max_value = 0\n\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if erased_operators == i + j:\n                max_value = max(max_value, i + j)\n\n    return str(max_value)\n"
    },
    {
        "number": 1777,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = []\n    for _ in range(n):\n        seq = input().strip()\n        if not seq:\n            continue\n        stack = []\n        for char in seq:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack[-1]!= '(':\n                    return '0'\n                stack.pop()\n        if stack:\n            return '0'\n        pairs.append(seq)\n    return str(max(len(pairs), len(pairs[0])))"
    },
    {
        "number": 1778,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    # Find the maximum difference between A's score and B's score\n    max_diff = max(a) - min(b)\n\n    return str(max_diff)\n"
    },
    {
        "number": 1779,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    first_layout = stdin.split()\n    second_layout = stdin.split()\n    text = stdin.split()\n\n    for i in range(len(text)):\n        if text[i] in first_layout and text[i].isupper() == second_layout[i].isupper():\n            print(text[i])\n            break\n\n    return \" \""
    },
    {
        "number": 1780,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        queries.append(list(map(int, stdin.split())))\n\n    def can_rearrange(a):\n        left = 0\n        right = len(a) - 1\n        while left < right:\n            if a[left] + a[left + 1] + 1 + a[right] + 1 + a[right + 1] == 0:\n                return True\n            elif a[left] + a[left + 1] + 1 + a[right] + 1 + a[right + 1] < 0:\n                left += 1\n            else:\n                right -= 1\n        return False\n\n    for i in range(n):\n        if a[i] == -1:\n            a[i] = 1\n\n    for i in range(m):\n        l, r = queries[i]\n        if l == r:\n            if can_rearrange(a):\n                print(1)\n            else:\n                print(0)\n        else:\n            if can_rearrange(a[:l] + [0] * (r - l + 1) + a[l:]):\n                print(1)\n            else:\n                print(0)\n\n    return \"\""
    },
    {
        "number": 1782,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"-1\"\n\n    def is_safe(u):\n        if len(u) < 3:\n            return False\n        for i in range(len(u) - 2):\n            if u[i] + 1!= u[i + 1]:\n                return False\n        return True\n\n    def partition(u):\n        if len(u) == 1:\n            return [u]\n        mid = len(u) // 2\n        left = partition(u[:mid])\n        right = partition(u[mid:])\n        return left + right\n\n    def find_safe_partition(u):\n        if len(u) == 1:\n            return [u]\n        left = find_safe_partition(u[:len(u) // 2])\n        right = find_safe_partition(u[len(u) // 2:])\n        for i in range(len(left)):\n            for j in range(len(right)):\n                if is_safe(left[i]) and is_safe(right[j]):\n                    left[i] = left[i] + right[j]\n                    right = [x for x in right if x!= left[i]]\n        return left\n\n    safe_partitions = find_safe_partition(set(range(1, n + 1)))\n    if len(safe_partitions) == 1:\n        return str(safe_partitions[0])\n    else:\n        return \"-1\""
    },
    {
        "number": 1783,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the sum of all weeks\n    total_weeks = n - k + 1\n\n    # Calculate the sum of sleep times for each week\n    week_sum = [0] * total_weeks\n    for i in range(k, n):\n        week_sum[i - k] += a[i]\n\n    # Calculate the average sleeping time\n    average_sleeping_time = sum(week_sum) / total_weeks\n\n    # Calculate the absolute or relative error\n    error = abs(average_sleeping_time - 9) / 9\n\n    # Output the result\n    return f\"{average_sleeping_time:.6f}\""
    },
    {
        "number": 1784,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n == 1 and k == 1:\n        return \"YES\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] <= k:\n                continue\n            for c in range(k):\n                if a[i] - a[j] <= 1:\n                    continue\n                for p in range(n):\n                    if a[p] - a[j] <= 1:\n                        continue\n                    if a[p] - a[j] <= a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                    if a[p] - a[j] <= a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i] + a[j] + a[i]:\n                        continue\n                   "
    },
    {
        "number": 1785,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    t = stdin.strip()\n    max_rho = 0\n    for i in range(n):\n        for j in range(n):\n            if s[i] == t[j]:\n                max_rho = max(max_rho, h(s, t, i, j))\n    return str(max_rho % (10**9 + 7))\n\ndef"
    },
    {
        "number": 1786,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, n = map(int, stdin.split())\n    cuts = []\n    for _ in range(n):\n        cut = input().split()\n        if cut[0] == 'H':\n            cuts.append((int(cut[1]), int(cut[2])))\n        elif cut[0] == 'V':\n            cuts.append((int(cut[1]), int(cut[2])))\n    max_area = 0\n    for cut in cuts:\n        area = 0\n        for i in range(cut[0], cut[1] + 1):\n            for j in range(cut[2], cut[3] + 1):\n                area += 1\n        max_area = max(max_area, area)\n    return str(max_area)\n"
    },
    {
        "number": 1787,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    p = [0] * n\n    p[0] = 1\n    for i in range(1, n):\n        if s[i] == 'a':\n            p[i] = p[i - 1] + 1\n        elif s[i] == 'b':\n            p[i] = p[i - 1] + 1\n            for j in range(i - 1, -1, -1):\n                if s[j] == 'a':\n                    p[i] = min(p[i], p[j] + 1)\n    return str(p[n - 1])"
    },
    {
        "number": 1788,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    X = 0\n    Y = 0\n\n    if A + B == A:\n        X = A\n    elif A - B == A:\n        X = A\n    else:\n        X = -1\n\n    if B + A == B:\n        Y = B\n    elif B - A == B:\n        Y = B\n    else:\n        Y = -1\n\n    return f\"{X} {Y}\""
    },
    {
        "number": 1789,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, x, y = map(int, stdin.split())\n    if a == b:\n        return \"Error: The buildings cannot be the same.\"\n    if a < 1 or a > 100 or b < 1 or b > 100 or x < 1 or x > 100 or y < 1 or y > 100:\n        return \"Error: Invalid input.\"\n\n    # Initialize variables\n    visited = [False] * (101)\n    current_floor = a\n    current_floor_visited = True\n    current_floor_staircase = 0\n    current_floor_staircase_visited = False\n\n    # Traverse corridors\n    for i in range(1, 101):\n        if not visited[i]:\n            if i == a:\n                current_floor_visited = True\n                current_floor_staircase = 0\n                current_floor_staircase_visited = False\n            elif i == b:\n                current_floor_visited = False\n                current_floor_staircase = 0\n                current_floor_staircase_visited = False\n            else:\n                current_floor_visited = False\n                current_floor_staircase = 0\n                current_floor_staircase_visited = False\n\n            visited[i] = True\n\n            if i == a:\n                current_floor_staircase += 1\n                current_floor_staircase_visited = True\n            elif i == b:\n                current_floor_staircase -= 1\n                current_floor_staircase_visited = True\n\n            if current_floor_staircase_visited:\n                current_floor_staircase_visited = False\n                current_floor_staircase += 1\n\n            if current_floor_visited:\n                current_floor_visited = False\n                current_floor += 1\n\n            if current_floor_staircase == 0:\n                current_floor_staircase_visited = False\n\n    # Calculate the minimum time\n    time = x * y\n    return str(time)\n"
    },
    {
        "number": 1790,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    stops = []\n    for _ in range(n):\n        r = int(stdin.readline().strip())\n        stops.append(r)\n\n    lines = set()\n    for stop in stops:\n        for line in range(1, stop + 1):\n            lines.add(line)\n\n    return''.join(str(line) for line in sorted(lines))"
    },
    {
        "number": 1791,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_pile = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if stdin[i] == stdin[j]:\n                max_pile = max(max_pile, j-i+1)\n    return str(max_pile)"
    },
    {
        "number": 1792,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    s, b, k, h = map(int, stdin.split())\n    spaceships = []\n    bases = []\n    for _ in range(s):\n        x, a, f = map(int, stdin.split())\n        spaceships.append((x, a, f))\n\n    for _ in range(b):\n        x, d = map(int, stdin.split())\n        bases.append((x, d))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def shortest_distance(p1, p2):\n        return min(distance(p1, p2), distance(p2, p1))\n\n    def is_attackable(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_base(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_spaceship(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_dummy_base(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_spaceship_base(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_spaceship_dummy_base(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_spaceship_base_dummy_base(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_spaceship_base_dummy_base_dummy_base(p1, p2, p3, p4):\n        return p1[0] == p2[0] or p1[1] == p2[1] or p2[0] == p3[0] or p2[1] == p3[1] or p3[0] == p4[0] or p3[1] == p4[1]\n\n    def is_attackable_spaceship_base_dummy_base_dummy_base_dummy_base(p1, p2, p3, p"
    },
    {
        "number": 1793,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, L, S = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def dfs(v, path, path_sum, path_count):\n        if path_count == L:\n            return path_sum\n\n        if path_sum + w[v] <= S:\n            path_sum += w[v]\n            path.append(v)\n            path_count += 1\n            dfs(p[v], path, path_sum, path_count)\n            path.pop()\n            path_sum -= w[v]\n            path_count -= 1\n\n        return -1\n\n    if dfs(1, [], 0, 0) == -1:\n        return \"Impossible\"\n    else:\n        return str(dfs(1, [], 0, 0))"
    },
    {
        "number": 1794,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    \u03c1 = [0] * (n + 1)\n    for i in range(1, n + 1):\n        \u03c1[i] = \u03c1[i - 1] + a[i - 1]\n\n    total_sum = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            total_sum += \u03c1[i] * \u03c1[j]\n\n    return str(total_sum)\n"
    },
    {
        "number": 1795,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    f = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            if f[i] == f[j]:\n                return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1796,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = 0\n    for line in stdin.splitlines():\n        operation, variable = line.split()\n        if operation == \"++\":\n            x += 1\n        elif operation == \"--\":\n            x -= 1\n        else:\n            raise ValueError(\"Invalid operation\")\n    return str(x)"
    },
    {
        "number": 1797,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n\n    max_convenience = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            max_convenience = max(max_convenience, p[i] + p[j])\n\n    return str(max_convenience)"
    },
    {
        "number": 1798,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    x = []\n    p_x = []\n\n    for i in range(n):\n        if a[i] in x:\n            continue\n        x.append(a[i])\n        p_x.append(a[i] - a[i - 1])\n\n    t = len(x)\n    for i in range(t):\n        print(i + 1, x[i], p_x[i])\n\n    return str(t)\n"
    },
    {
        "number": 1799,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = [int(x) for x in stdin.strip().split()]\n    w = [int(x) for x in stdin.strip().split()]\n\n    # Find the number of teams with more balloons\n    max_balloons = max(t)\n    num_teams = sum(1 for x in t if x > max_balloons)\n\n    # Find the number of teams with zero balloons\n    num_teams_with_zero_balloons = sum(1 for x in t if x == 0)\n\n    # Find the number of teams with more balloons than the initial number of teams\n    num_teams_with_more_balloons = num_teams - num_teams_with_zero_balloons\n\n    # Find the best place\n    best_place = num_teams_with_more_balloons\n\n    return str(best_place)"
    },
    {
        "number": 1800,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    report = [a[i] for i in range(n)]\n    managers = []\n    for _ in range(m):\n        t, r = map(int, stdin.split())\n        if t == 1:\n            report.sort(reverse=True)\n        elif t == 2:\n            report.sort()\n        managers.append(r)\n    return''.join(map(str, report))"
    },
    {
        "number": 1801,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] == b[j]:\n                count += 1\n                break\n\n    remainder = count % m\n    return str(remainder)"
    },
    {
        "number": 1802,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    heights = list(map(int, stdin.strip().split()))\n\n    # Initialize variables\n    max_buns = 0\n    lowest_height = float('inf')\n    step = 1\n\n    # Iterate through the students\n    for i in range(n):\n        # Check if the student is the lowest\n        if heights[i] < lowest_height:\n            lowest_height = heights[i]\n            max_buns = 0\n\n        # Check if the student is the highest\n        if heights[i] > lowest_height:\n            max_buns += 1\n\n        # Update the step\n        step = max(step, max_buns)\n\n    # Print the result\n    print(max_buns)\n    print(lowest_height, step)\n\n    return \"\""
    },
    {
        "number": 1803,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m = int(stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    # Initialize the count of birds on each wire\n    count = [0] * n\n\n    # Count the number of birds on each wire\n    for i in range(m):\n        count[x[i]-1] += 1\n\n    # Print the count of birds on each wire\n    for i in range(n):\n        print(count[i])\n\n    return \"\""
    },
    {
        "number": 1804,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    C, H = map(int, stdin.split())\n\n    # Create a list of tuples containing the coordinates of each hotel\n    hotels = []\n    for _ in range(C):\n        x, y = map(int, stdin.split())\n        hotels.append((x, y))\n\n    # Create a list of tuples containing the coordinates of each restaurant\n    restaurants = []\n    for _ in range(H):\n        x, y = map(int, stdin.split())\n        restaurants.append((x, y))\n\n    # Create a list of tuples containing the distances between neighboring crossings\n    distances = []\n    for i in range(N):\n        for j in range(M):\n            if i == 0 or j == 0 or i == N - 1 or j == M - 1:\n                distances.append((0, 0))\n            else:\n                distances.append((abs(i - j), 0))\n\n    # Create a list of tuples containing the indices of the nearest restaurants\n    nearest_restaurants = []\n    for i in range(N):\n        for j in range(M):\n            nearest_restaurants.append((distances[i][0], i, j))\n\n    # Sort the nearest restaurants by their distance from the current hotel\n    nearest_restaurants.sort(key=lambda x: x[0])\n\n    # Initialize the optimal distance and the index of the nearest restaurant\n    optimal_distance = float('inf')\n    nearest_index = -1\n\n    # Iterate through the nearest restaurants and update the optimal distance and the index\n    for i in range(H):\n        # Calculate the distance between the current hotel and the nearest restaurant\n        distance = distances[nearest_restaurants[i][1]][0]\n\n        # Update the optimal distance and the index if the distance is smaller\n        if distance < optimal_distance:\n            optimal_distance = distance\n            nearest_index = nearest_restaurants[i][2]\n\n    # Output the optimal distance and the index of the nearest restaurant\n    return f\"{optimal_distance}\\n{nearest_index}\"\n"
    },
    {
        "number": 1805,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    matches = []\n    for _ in range(n):\n        a, b, c = map(int, stdin.readline().strip().split())\n        matches.append((a, b, c))\n\n    matches.sort(key=lambda x: (-x[0], -x[1], -x[2]))\n\n    min_matches = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if matches[i][0] + matches[j][0] + matches[k][0] == matches[i][1] + matches[j][1] + matches[k][1]:\n                    min_matches += 1\n                    break\n\n    return str(min_matches)"
    },
    {
        "number": 1806,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    intervals = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        intervals.append((l, r))\n\n    queries = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        queries.append((x, y))\n\n    min_covered = float('inf')\n    for x in range(x_min, x_max + 1):\n        for y in range(y_min, y_max + 1):\n            covered = False\n            for interval in intervals:\n                if x >= interval[0] and x <= interval[1]:\n                    if y >= interval[0] and y <= interval[1]:\n                        covered = True\n                        break\n            if covered:\n                min_covered = min(min_covered, len(intervals))\n            else:\n                min_covered = min(min_covered, 0)\n\n    return str(min_covered)\n"
    },
    {
        "number": 1807,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    total_segments = 0\n\n    for i in range(a, b + 1):\n        total_segments += 7\n\n    return str(total_segments)"
    },
    {
        "number": 1808,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    a.sort()\n    min_time = sum(a[:k])\n    for i in range(k, n):\n        if a[i] - a[i-1] >= 1:\n            min_time += a[i] - a[i-1]\n    return str(min_time)"
    },
    {
        "number": 1809,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Sort the books by their order\n    for i in range(n):\n        for j in range(i + 1, n):\n            if b[i] < b[j]:\n                b[i], b[j] = b[j], b[i]\n\n    # Calculate the total weight of books\n    total_weight = sum(w[i] for i in range(n))\n\n    # Calculate the minimum total weight\n    min_total_weight = total_weight\n\n    # Calculate the minimum number of books to lift\n    min_books_to_lift = 0\n\n    # Iterate through the days\n    for i in range(m):\n        # Calculate the number of books to lift\n        books_to_lift = min(n - i, min_books_to_lift)\n\n        # Calculate the weight of books to lift\n        weight_to_lift = sum(w[i + j] for j in range(books_to_lift))\n\n        # Calculate the minimum total weight after lifting\n        min_total_weight_after_lifting = min_total_weight - weight_to_lift\n\n        # Update the minimum number of books to lift\n        min_books_to_lift = books_to_lift\n\n        # Update the minimum total weight\n        min_total_weight = min_total_weight_after_lifting\n\n    # Print the minimum total weight\n    print(min_total_weight)\n\n    return \"\""
    },
    {
        "number": 1810,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 == 0 and i % 10 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1811,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    road = list(stdin)\n    visited = [False] * n\n    path = [0] * n\n    path[0] = 1\n\n    for i in range(1, n):\n        if road[i] == \"#\":\n            path[i] = i + 1\n        else:\n            path[i] = path[i - 1] + 1\n\n    for i in range(n - 1, -1, -1):\n        if road[i] == \"#\":\n            path[i] = i + 1\n        else:\n            path[i] = path[i + 1] + 1\n\n    for i in range(n - 1, -1, -1):\n        if road[i] == \"#\":\n            visited[i] = True\n            path[i] = i + 1\n        else:\n            visited[i] = False\n            path[i] = path[i + 1] + 1\n\n    for i in range(n - 1, -1, -1):\n        if not visited[i] and path[i] == i + k:\n            return \"YES\"\n        elif not visited[i] and path[i] == i + 1:\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 1812,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    result = []\n    for i in range(n):\n        k = 0\n        while True:\n            k += 1\n            if len(str(2**k)) > len(str(a[i])):\n                break\n        result.append(k)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1813,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def split_strip(a, s, l):\n        max_num = max(a)\n        min_num = min(a)\n        max_diff = max_num - min_num\n        min_diff = s - min_num\n\n        if max_diff <= l:\n            return [a[:i] + [max_num] + a[i+1:] for i in range(len(a)-1)]\n        else:\n            return []\n\n    def find_min_pieces(strip):\n        pieces = split_strip(strip, s, l)\n        if not pieces:\n            return -1\n\n        min_pieces = min(pieces, key=len)\n        return len(min_pieces)\n\n    min_pieces = find_min_pieces(a)\n    return str(min_pieces)"
    },
    {
        "number": 1814,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, c_l, c_e, v = map(int, stdin.split())\n    l = list(map(int, stdin.split()))\n    e = list(map(int, stdin.split()))\n    q = int(stdin.strip())\n\n    def dfs(x, y, visited, path):\n        if x == n and y == m:\n            return True\n        if x < 1 or x > n or y < 1 or y > m or visited[x][y]:\n            return False\n        visited[x][y] = True\n        path.append((x, y))\n        if dfs(x + 1, y, visited, path):\n            return True\n        if dfs(x - 1, y, visited, path):\n            return True\n        if dfs(x, y + 1, visited, path):\n            return True\n        if dfs(x, y - 1, visited, path):\n            return True\n        path.pop()\n        return False\n\n    def min_time(x1, y1, x2, y2):\n        visited = [[False] * m for _ in range(n)]\n        path = [(x1, y1)]\n        while path:\n            x, y = path.pop()\n            if x == x2 and y == y2:\n                return 1\n            if dfs(x + 1, y, visited, path):\n                path.append((x + 1, y))\n            if dfs(x - 1, y, visited, path):\n                path.append((x - 1, y))\n            if dfs(x, y + 1, visited, path):\n                path.append((x, y + 1))\n            if dfs(x, y - 1, visited, path):\n                path.append((x, y - 1))\n        return 0\n\n    for _ in range(q):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        print(min_time(x1, y1, x2, y2))"
    },
    {
        "number": 1815,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    u = list(map(int, stdin.strip().split()))\n    x = 0\n    for i in range(n):\n        x = max(x, len(u) - i)\n    return str(x)"
    },
    {
        "number": 1816,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    f = list(map(int, stdin.strip().split()))\n    time_units = 0\n    for i in range(n):\n        time_units += f[i] - 1\n    return str(time_units)"
    },
    {
        "number": 1817,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Initialize variables\n    left_num = n - 1\n    right_num = 0\n\n    # Perform moves until there is only one number left\n    while left_num > 0:\n        # Perform first move\n        if a[0] > a[1]:\n            a[0], a[1] = a[1], a[0]\n        left_num -= 1\n\n        # Perform second move\n        if a[0] > a[1]:\n            a[0], a[1] = a[1], a[0]\n        right_num += 1\n\n    # Print the result\n    print(right_num)\n    return \"\""
    },
    {
        "number": 1818,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1819,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        n, x = map(int, stdin.readline().split())\n        if x > n:\n            break\n        for i in range(x, n):\n            print(i)"
    },
    {
        "number": 1820,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if n == 1:\n            print(-1)\n            continue\n        if n == 2:\n            print(a[0], a[1], a[0] + a[1])\n            continue\n        if n == 3:\n            print(a[0], a[1], a[2])\n            continue\n        if n == 4:\n            print(a[0], a[1], a[2], a[3])\n            continue\n        if n == 5:\n            print(a[0], a[1], a[2], a[3], a[4])\n            continue\n        if n == 6:\n            print(a[0], a[1], a[2], a[3], a[4], a[5])\n            continue\n        if n == 7:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6])\n            continue\n        if n == 8:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7])\n            continue\n        if n == 9:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8])\n            continue\n        if n == 10:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9])\n            continue\n        if n == 11:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10])\n            continue\n        if n == 12:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11])\n            continue\n        if n == 13:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12])\n            continue\n        if n == 14:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13])\n            continue\n        if n == 15:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14])\n            continue\n        if n == 16:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15])\n            continue\n        if n == 17:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16])\n            continue\n        if n == 18:\n            print(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17])\n            continue\n        if n == 19:\n            print(a[0], a[1], a[2], a[3], a[4],"
    },
    {
        "number": 1821,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def is_congruent(a, b):\n        return a % 7 == b % 7\n\n    def is_subsequence(a, b):\n        return a == b or (a[1:] == b[1:] and is_congruent(a[0], b[0]))\n\n    def max_sum_of_lengths(a, b):\n        if len(a) > len(b):\n            a, b = b, a\n        if len(a) == 0 or len(b) == 0:\n            return 0\n\n        if is_subsequence(a, b):\n            return max(max_sum_of_lengths(a[1:], b), max_sum_of_lengths(a, b[1:]))\n\n        return max(max_sum_of_lengths(a[1:], b), max_sum_of_lengths(a, b[1:]))\n\n    return str(max_sum_of_lengths(a, a[1:]))\n"
    },
    {
        "number": 1822,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    beavers = list(map(int, stdin.split()))\n    positions = []\n\n    for i in range(n):\n        if beavers[i] == 0:\n            positions.append(i)\n\n    return str(positions)\n"
    },
    {
        "number": 1823,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of stresses for each genre\n    stresses = [0] * k\n    for i in range(n):\n        stresses[a[i] - 1] += 1\n\n    # Find the genre with the minimum number of stresses\n    min_stresses = float('inf')\n    min_genre = None\n    for i in range(k):\n        if stresses[i] < min_stresses:\n            min_stresses = stresses[i]\n            min_genre = i\n\n    return str(min_genre + 1)\n"
    },
    {
        "number": 1824,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n    c = list(map(int, stdin.strip().split()))\n\n    errors = []\n    for i in range(n):\n        if a[i]!= b[i]:\n            errors.append(a[i])\n\n    for i in range(n - 1):\n        if a[i]!= b[i] and a[i + 1]!= b[i + 1]:\n            errors.append(a[i])\n            errors.append(a[i + 1])\n\n    for i in range(n - 2):\n        if a[i]!= b[i] and a[i + 1]!= b[i + 1] and a[i + 2]!= b[i + 2]:\n            errors.append(a[i])\n            errors.append(a[i + 1])\n            errors.append(a[i + 2])\n\n    return str(errors)\n"
    },
    {
        "number": 1825,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    strings = []\n    for _ in range(n):\n        t, k, *x = map(int, stdin.readline().split())\n        strings.append((t, k, x))\n\n    def find_min_string(s):\n        min_len = float('inf')\n        min_string = ''\n        for t, k, x in strings:\n            if len(s) - k >= t:\n                if len(s) - k >= min_len:\n                    min_len = len(s) - k\n                    min_string = s[:k]\n        return min_string\n\n    min_string = find_min_string(strings[0][1])\n    for i in range(1, n):\n        min_string = min(min_string, find_min_string(strings[i][1]))\n\n    return min_string\n"
    },
    {
        "number": 1826,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = stdin.strip()\n    moves = []\n    for i in range(n):\n        moves.append(sequence[i])\n    moves = [m for m in moves if m in 'UR']\n    moves = [m for m in moves if m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D']\n    moves = [m for m in moves if m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R' and m!= 'D' and m!= 'U' and m!= 'R']\n    moves = [m for m in moves if m!= 'U'"
    },
    {
        "number": 1828,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    track = []\n    for _ in range(n + 1):\n        x, y = map(int, stdin.strip().split())\n        track.append((x, y))\n\n    start_x, start_y = track[0]\n    end_x, end_y = track[-1]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and (x, y)!= (start_x, start_y) and (x, y)!= (end_x, end_y)\n\n    def get_neighbors(x, y):\n        neighbors = []\n        if x > 0:\n            neighbors.append((x - 1, y))\n        if x < n - 1:\n            neighbors.append((x + 1, y))\n        if y > 0:\n            neighbors.append((x, y - 1))\n        if y < n - 1:\n            neighbors.append((x, y + 1))\n        return neighbors\n\n    def get_dangerous_turns(x, y):\n        neighbors = get_neighbors(x, y)\n        dangerous_turns = 0\n        for neighbor in neighbors:\n            if is_valid(neighbor[0], neighbor[1]):\n                if neighbor[0] == start_x and neighbor[1] == start_y:\n                    dangerous_turns += 1\n                elif neighbor[0] == end_x and neighbor[1] == end_y:\n                    dangerous_turns += 1\n                else:\n                    if neighbor[0] == x and neighbor[1] == y:\n                        dangerous_turns += 1\n        return dangerous_turns\n\n    dangerous_turns = 0\n    for x in range(n):\n        for y in range(n):\n            if is_valid(x, y):\n                dangerous_turns += get_dangerous_turns(x, y)\n\n    return str(dangerous_turns)"
    },
    {
        "number": 1829,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    polandball = set(stdin.split())\n    enemyball = set(stdin.split())\n\n    polandball_words = set(polandball)\n    enemyball_words = set(enemyball)\n\n    polandball_words.difference_update(enemyball_words)\n\n    if len(polandball_words) < len(enemyball_words):\n        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1830,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    rooks = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        board[x][y] = 1\n        rooks.append((x, y))\n\n    def is_under_attack(x, y):\n        for i in range(m):\n            if board[x][i] == 1 and board[i][y] == 1:\n                return True\n        return False\n\n    def count_not_under_attack(x, y):\n        count = 0\n        for i in range(m):\n            if board[x][i] == 0 and board[i][y] == 0:\n                count += 1\n        return count\n\n    for i in range(m):\n        if is_under_attack(rooks[i][0], rooks[i][1]):\n            board[rooks[i][0]][rooks[i][1]] = 0\n            board[rooks[i][1]][rooks[i][0]] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(m):\n        if is_under_attack(rooks[i][0], rooks[i][1]):\n            board[rooks[i][0]][rooks[i][1]] = 0\n            board[rooks[i][1]][rooks[i][0]] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                board[i][j] = 0\n\n    for i in range(n"
    },
    {
        "number": 1831,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    brains = [[] for _ in range(n)]\n    connectors = [[] for _ in range(m)]\n\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        brains[a - 1].append(b - 1)\n        brains[b - 1].append(a - 1)\n        connectors[a - 1].append(b - 1)\n        connectors[b - 1].append(a - 1)\n\n    for i in range(n):\n        if len(brains[i]) < 2:\n            return \"no\"\n\n    for i in range(m):\n        if len(connectors[i]) < 2:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 1832,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    s = [a[i] for i in range(n)]\n    t = [a[i] for i in range(n, n+1)]\n    max_len = 0\n    max_prefix = \"\"\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i] == t[j]:\n                if len(s[i:j]) > max_len:\n                    max_len = len(s[i:j])\n                    max_prefix = s[i:j]\n    return max_prefix"
    },
    {
        "number": 1833,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Count the number of good subsequences\n    count = 0\n    for i in range(1, n + 1):\n        if a[i - 1] % i == 0:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 1834,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n % 2 == 0:\n        for i in range(n // 2):\n            if a[i] >= a[i + 1]:\n                return \"Impossible\"\n    else:\n        for i in range(n // 2):\n            if a[i] <= a[i + 1]:\n                return \"Impossible\"\n\n    return \" \".join(map(str, a))"
    },
    {
        "number": 1835,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    palindromes = []\n    for _ in range(n):\n        s = list(map(int, stdin.strip().split()))\n        if s == s[::-1]:\n            palindromes.append(s)\n    return str(max(palindromes))"
    },
    {
        "number": 1836,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    points = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        points.append((u, v))\n\n    def is_valid(u, v, points):\n        for i in range(len(points)):\n            if i == 0 or points[i][0]!= points[i - 1][1]:\n                if points[i][1] == u or points[i][1] == v:\n                    return False\n        return True\n\n    def paint_segment(u, v, points):\n        for i in range(len(points)):\n            if i == 0 or points[i][0]!= points[i - 1][1]:\n                if points[i][1] == u or points[i][1] == v:\n                    return i\n        return -1\n\n    def paint_spines(u, v, points):\n        for i in range(len(points)):\n            if i == 0 or points[i][0]!= points[i - 1][1]:\n                if points[i][1] == u or points[i][1] == v:\n                    return i\n        return -1\n\n    def paint_tail(u, v, points):\n        for i in range(len(points)):\n            if i == 0 or points[i][0]!= points[i - 1][1]:\n                if points[i][1] == u or points[i][1] == v:\n                    return i\n        return -1\n\n    def paint_hedgehog(u, v, points):\n        if is_valid(u, v, points):\n            paint_segment(u, v, points)\n            paint_spines(u, v, points)\n            paint_tail(u, v, points)\n            return paint_hedgehog(u, v, points)\n        else:\n            return 0\n\n    return str(paint_hedgehog(points[0][0], points[0][1], points))\n"
    },
    {
        "number": 1837,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_fixed_point(a):\n        count = {}\n        for i in a:\n            if i in count:\n                count[i] += 1\n            else:\n                count[i] = 1\n        return all(count[i] == 1 for i in range(n))\n\n    max_fixed_points = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_fixed_point(a[i]) and is_fixed_point(a[j]):\n                max_fixed_points += 1\n                break\n\n    return str(max_fixed_points)\n"
    },
    {
        "number": 1838,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    words = set(stdin.split())\n    relations = []\n\n    for _ in range(m):\n        x, y = map(str, stdin.split())\n        relations.append((x, y))\n\n    for _ in range(q):\n        x, y = map(str, stdin.split())\n        if x == y:\n            print(\"YES\")\n        elif x in relations and y in relations:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 1839,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    schedule = []\n    for _ in range(n * n):\n        schedule.append(list(map(int, stdin.readline().strip().split())))\n\n    days = []\n    for i in range(n):\n        for j in range(n):\n            if schedule[i][j] == 1:\n                days.append(i + 1)\n\n    return''.join(map(str, days))"
    },
    {
        "number": 1840,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, b = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n    g = list(map(int, stdin.split()))\n\n    max_gold = 0\n    for i in range(s):\n        max_gold = max(max_gold, a[i] + d[i] + g[i])\n\n    return str(max_gold)"
    },
    {
        "number": 1841,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n\n    count = [0] * n\n    for i in range(m):\n        count[l[i] - 1] += 1\n\n    result = []\n    for i in range(n):\n        if count[i] > 1:\n            result.append(i + 1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1842,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(int, stdin.split())\n    discriminant = b ** 2 - 4 * a * c\n    if discriminant < 0:\n        return \"No real roots\"\n    elif discriminant == 0:\n        return f\"{-b / (2 * a)} + {(-b + sqrt(b ** 2 - 4 * a * c)) / (2 * a)}\"\n    else:\n        return f\"{-b / (2 * a)} + {(-b - sqrt(b ** 2 - 4 * a * c)) / (2 * a)}\""
    },
    {
        "number": 1843,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    result = []\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        result.append(sum(2**i for i in range(n)))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 1844,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return str(min(a))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def subset_with_gcd(a, n):\n        if n == 1:\n            return a\n        if n == 2:\n            return a[0]\n\n        for i in range(n):\n            if gcd(a[i], a[i + 1]) == 1:\n                return subset_with_gcd(a[:i] + a[i + 2:], n - 1)\n\n        return -1\n\n    result = subset_with_gcd(a, n)\n    if result == -1:\n        return \"-1\"\n    else:\n        return str(result)"
    },
    {
        "number": 1845,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    total_power = 0\n    for i in range(n):\n        total_power += a[i]\n\n    return str(total_power)"
    },
    {
        "number": 1846,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n\n    # Find the least number of temperature values that satisfy Vasya's condition\n    min_temp = float('inf')\n    for i in range(n):\n        if t[i] < 0:\n            min_temp = min(min_temp, t[i])\n        elif t[i] > 0:\n            min_temp = min(min_temp, t[i] + 1)\n\n    return str(min_temp)"
    },
    {
        "number": 1847,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, x1, y1 = map(int, stdin.split())\n    n = int(stdin.split()[1])\n    segments = []\n    for _ in range(n):\n        r, a, b = map(int, stdin.split())\n        segments.append((r, a, b))\n\n    def dfs(x: int, y: int, visited: set, path: List[Tuple[int, int]]) -> int:\n        if x == x1 and y == y1:\n            return 0\n\n        if x < 1 or x > 10**9 or y < 1 or y > 10**9:\n            return -1\n\n        if (x, y) in visited:\n            return -1\n\n        visited.add((x, y))\n        path.append((x, y))\n\n        for r, a, b in segments:\n            if a <= x <= b and a <= y <= b:\n                if dfs(x, y, visited, path):\n                    return True\n\n        visited.remove((x, y))\n        path.pop()\n        return False\n\n    if dfs(x0, y0, set(), []):\n        return \" \".join(map(str, path))\n    else:\n        return \"-1\""
    },
    {
        "number": 1848,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_pairs = 0\n    for i in range(n - 1):\n        if a[i] + 1 > a[i + 1]:\n            max_pairs += 1\n\n    return str(max_pairs)"
    },
    {
        "number": 1849,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = []\n    for i in range(1, n + 1):\n        count = 0\n        while i > 0 and i % 10 == 0:\n            count += 1\n            i //= 10\n        result.append(count)\n    result = [str(x) for x in result]\n    result = ''.join(result)\n    result = result.zfill(n)\n    result = result % 998244353\n    return result"
    },
    {
        "number": 1850,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    S = list(map(int, stdin.split()))\n    P = list(map(int, stdin.split()))\n\n    # Sort S and P in non-increasing order\n    S.sort()\n    P.sort()\n\n    # Calculate the number of points awarded for the next race\n    P_next = [0] * N\n    for i in range(1, N):\n        P_next[i] = P[i] + P_next[i-1]\n\n    # Calculate the best possible ranking for astronaut D\n    best_rank = 0\n    for i in range(N):\n        if i == D:\n            best_rank = i + 1\n        else:\n            best_rank = max(best_rank, i + 1)\n\n    return str(best_rank)"
    },
    {
        "number": 1851,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    days = 0\n    for i in range(n):\n        if i not in a:\n            days += 1\n\n    return str(days)"
    },
    {
        "number": 1852,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 2):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def dfs(node, parent):\n        if node == 1:\n            return parent\n        if node == n:\n            return None\n        if node == 2:\n            return 1\n        if node == n - 1:\n            return n - 2\n        if node == n - 2:\n            return n - 1\n        if node == n - 3:\n            return n - 4\n        if node == n - 4:\n            return n - 3\n        if node == n - 5:\n            return n - 6\n        if node == n - 6:\n            return n - 5\n        if node == n - 7:\n            return n - 8\n        if node == n - 8:\n            return n - 7\n        if node == n - 9:\n            return n - 10\n        if node == n - 10:\n            return n - 9\n        if node == n - 11:\n            return n - 12\n        if node == n - 12:\n            return n - 11\n        if node == n - 13:\n            return n - 14\n        if node == n - 14:\n            return n - 13\n        if node == n - 15:\n            return n - 16\n        if node == n - 16:\n            return n - 15\n        if node == n - 17:\n            return n - 18\n        if node == n - 18:\n            return n - 17\n        if node == n - 19:\n            return n - 20\n        if node == n - 20:\n            return n - 19\n        if node == n - 21:\n            return n - 22\n        if node == n - 22:\n            return n - 21\n        if node == n - 23:\n            return n - 24\n        if node == n - 24:\n            return n - 23\n        if node == n - 25:\n            return n - 26\n        if node == n - 26:\n            return n - 25\n        if node == n - 27:\n            return n - 28\n        if node == n - 28:\n            return n - 27\n        if node == n - 29:\n            return n - 30\n        if node == n - 30:\n            return n - 29\n        if node == n - 31:\n            return n - 32\n        if node == n - 32:\n            return n - 31\n        if node == n - 33:\n            return n - 34\n        if node == n - 34:\n            return n - 33\n        if node == n - 35:\n            return n - 36\n        if node == n - 36:\n            return n - 35\n        if node == n - 37:\n            return n - 38\n        if node == n - 38:\n            return n - 37\n        if node == n - 39:\n            return n - 40\n        if node == n - 40:\n            return n - 39\n        if node == n - 41:\n            return n - 42\n        if node == n - 42:\n            return n - 41\n        if node == n - 43:\n            return n - 44\n        if node == n - 44:\n            return n - 43\n        if node == n - 45:\n            return n - 46\n        if node == n - 46:\n            return n - 45\n        if node == n - 47:\n            return n - 48\n        if node == n - 48:\n            return n - 47\n        if node == n - 49:\n            return n - 50\n        if node == n - 50:\n            return n - 49\n        if node == n - 51:\n            return n - 52\n        if node == n - 52:\n            return n - 51\n        if node == n - 53:\n            return n - 54\n        if node == n - 54:\n            return n - 53\n        if node == n - 55:\n            return n - 56\n        if node == n - 56:\n            return n - 55"
    },
    {
        "number": 1853,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    def compare(a, b):\n        if a == b:\n            return \"equal\"\n        elif a > b:\n            return \"greater\"\n        else:\n            return \"less\"\n\n    def find_arrays(pairs):\n        distinct_a = set()\n        distinct_b = set()\n        for a, b in pairs:\n            if a not in distinct_a and b not in distinct_b:\n                distinct_a.add(a)\n                distinct_b.add(b)\n                yield (distinct_a, distinct_b)\n\n    arrays = list(find_arrays(pairs))\n    if len(arrays) == 0:\n        return \"NO\"\n\n    distinct_a, distinct_b = arrays[0]\n    for a, b in pairs:\n        if a not in distinct_a or b not in distinct_b:\n            return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(map(str, distinct_a)) + \"\\n\" + \"\\n\".join(map(str, distinct_b))\n"
    },
    {
        "number": 1854,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    graph = []\n    for i in range(n):\n        graph.append([])\n        for j in range(n):\n            graph[i].append(0)\n\n    for a, b in edges:\n        graph[a - 1][b - 1] += 1\n        graph[b - 1][a - 1] += 1\n\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] == 0:\n                return \"NO\"\n\n    diameter = 0\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] > diameter:\n                diameter = graph[i][j]\n\n    return \"YES \" + str(diameter) + \"\\n\" + \"\\n\".join(map(str, graph))\n"
    },
    {
        "number": 1855,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # Calculate the partition value\n    max_value = 0\n    count = 0\n    for i in range(1, k + 1):\n        max_value = max(max_value, sum(p[i - 1] for j in range(i, n + 1)) % 998_244_353)\n        count += sum(1 for j in range(i, n + 1) if p[j - 1] == p[i - 1])\n\n    return str(max_value) + \" \" + str(count)\n"
    },
    {
        "number": 1856,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    passwords = []\n    for _ in range(n):\n        password = stdin.strip()\n        if password not in passwords:\n            passwords.append(password)\n    return str(min(len(passwords), n))"
    },
    {
        "number": 1857,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ways = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            ways += 2*n - 2*i*j\n    return str(ways)"
    },
    {
        "number": 1858,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"No\"\n\n    # Initialize the sets\n    S1 = set()\n    S2 = set()\n\n    # Iterate through the numbers\n    for i in range(1, n + 1):\n        # Check if the number is present in S1 or S2\n        if i in S1 or i in S2:\n            return \"No\"\n\n        # Add the number to the appropriate set\n        if i in S1:\n            S1.add(i)\n        else:\n            S2.add(i)\n\n    # If we reach here, there is a valid partition\n    return \"Yes\\n\" + \"\\n\".join(str(x) for x in S1) + \"\\n\" + \"\\n\".join(str(x) for x in S2)"
    },
    {
        "number": 1859,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"0\"\n    d = 2\n    while n % d == 0:\n        d += 1\n    n -= d\n    return str(n)"
    },
    {
        "number": 1860,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_offices = 0\n    for i in range(10, 100):\n        if i % 7 == 0 and i % 8 == 0:\n            max_offices = max(max_offices, i)\n    return str(max_offices)"
    },
    {
        "number": 1861,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sets = set()\n    for _ in range(n):\n        card = input()\n        features = [int(f) for f in card]\n        if len(set(features))!= k:\n            sets.add(card)\n    return str(len(sets))"
    },
    {
        "number": 1862,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    socks = list(map(int, stdin.strip().split()))\n    max_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if socks[i] not in socks[j] and socks[i] not in socks[j+1]:\n                max_count = max(max_count, j-i+1)\n    return str(max_count)"
    },
    {
        "number": 1863,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    eggs = []\n    for _ in range(n):\n        a, g = map(int, stdin.strip().split())\n        eggs.append((a, g))\n\n    def min_cost(a, g):\n        return abs(a - g)\n\n    def max_cost(a, g):\n        return max(abs(a - g), abs(g - a))\n\n    def min_cost_child(a, g):\n        return min_cost(a, g)\n\n    def max_cost_child(a, g):\n        return max_cost(a, g)\n\n    def min_cost_child_and_parent(a, g):\n        return min(min_cost_child(a, g), min_cost_parent(a, g))\n\n    def max_cost_child_and_parent(a, g):\n        return max(max_cost_child(a, g), max_cost_parent(a, g))\n\n    def min_cost_parent(a, g):\n        return min_cost(a, g) + min_cost_child(a, g)\n\n    def max_cost_parent(a, g):\n        return max_cost(a, g) + max_cost_child(a, g)\n\n    def min_cost_parent_and_child(a, g):\n        return min(min_cost_parent(a, g), min_cost_child(a, g))\n\n    def max_cost_parent_and_child(a, g):\n        return max(max_cost_parent(a, g), max_cost_child(a, g))\n\n    def min_cost_parent_and_child_and_parent(a, g):\n        return min(min_cost_parent_and_child(a, g), min_cost_parent(a, g))\n\n    def max_cost_parent_and_child_and_parent(a, g):\n        return max(max_cost_parent_and_child(a, g), max_cost_parent(a, g))\n\n    def min_cost_parent_and_child_and_parent_and_child(a, g):\n        return min(min_cost_parent_and_child_and_parent(a, g), min_cost_child(a, g))\n\n    def max_cost_parent_and_child_and_parent_and_child(a, g):\n        return max(max_cost_parent_and_child_and_parent(a, g), max_cost_child(a, g))\n\n    def min_cost_parent_and_child_and_parent_and_child_and_parent(a, g):\n        return min(min_cost_parent_and_child_and_parent_and_child(a, g), min_cost_parent(a, g))\n\n    def max_cost_parent_and_child_and_parent_and_child_and_parent(a, g):\n        return max(max_cost_parent_and_child_and_parent_and_child(a, g), max_cost_parent(a, g))\n\n    def min_cost_parent_and_child_and_parent_and_child_and_parent_and_child(a, g):\n        return min(min_cost_parent_and_child_and_parent_and_child_and_parent(a, g), min_cost_child(a, g))\n\n    def max_cost_parent_and_child_and_parent_and_child_and_parent_and_child(a, g):\n        return max(max_cost_parent_and_child_and_parent_and_child_and_parent(a, g), max_cost_child(a, g))\n\n    def min_cost_parent_and_child_and_parent_and_child_and_parent_and_child_and_parent(a, g):\n        return min(min_cost_parent_and_child_and_parent_and_child_and_parent_and_child(a, g), min_cost_parent(a, g))\n\n    def max_cost_parent_and_child_and_parent_and_child_and_parent_and_child_and_parent(a, g):\n        return max(max_cost_parent_and_child_and_parent_and_child_and_parent_and_child(a, g), max_cost_parent(a, g))\n\n    def min_cost_parent_and_child_and_parent_and_child_and_parent"
    },
    {
        "number": 1864,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    banknotes = list(map(int, stdin.readline().strip().split()))\n\n    unfortunate_sum = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            unfortunate_sum = min(unfortunate_sum, sum(banknotes[:i] + banknotes[i + 1:j]) - sum(banknotes[:i] + banknotes[i + 1:j]))\n\n    if unfortunate_sum == float('-inf'):\n        return '-1'\n    else:\n        return str(unfortunate_sum)"
    },
    {
        "number": 1865,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the array in non-descending order\n    a.sort()\n\n    # Perform swaps to make the array sorted\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a[i], a[j] = a[j], a[i]\n\n    # Print the sequence of swaps\n    k = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            print(f\"{i}, {j}\", end=\" \")\n            k += 1\n            if k == n:\n                break\n\n    return str(k)\n"
    },
    {
        "number": 1866,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    q = int(stdin.strip())\n    a = [i for i in range(n)]\n    for _ in range(q):\n        x1, y1 = map(int, stdin.strip().split())\n        x2, y2 = map(int, stdin.strip().split())\n        t = f(x1, y1)\n        a[x1] = t\n        a[y1] = t\n        t = f(x2, y2)\n        a[x2] = t\n        a[y2] = t\n    print(q)\n    for i in range(n):\n        print(a[i])\n    return \"\""
    },
    {
        "number": 1867,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_count = max(a)\n    beauty_count = 0\n\n    for num in a:\n        if num == max_count:\n            beauty_count += 1\n\n    if beauty_count == 0:\n        return \"No subsegment possible\"\n\n    min_count = min(a)\n    beauty_count = 0\n\n    for num in a:\n        if num == min_count:\n            beauty_count += 1\n\n    if beauty_count == 0:\n        return \"No subsegment possible\"\n\n    l = 0\n    r = n - 1\n\n    while l < r:\n        mid = (l + r) // 2\n\n        if a[mid] == max_count:\n            beauty_count -= 1\n            if beauty_count == 0:\n                r = mid - 1\n            else:\n                l = mid + 1\n        elif a[mid] == min_count:\n            beauty_count -= 1\n            if beauty_count == 0:\n                l = mid + 1\n            else:\n                r = mid - 1\n        else:\n            l = mid + 1\n\n    return str(l) + \" \" + str(r)\n"
    },
    {
        "number": 1868,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, A = map(int, stdin.split())\n    A = set(A)\n    b = [int(x) for x in stdin.split()]\n\n    def is_valid(s):\n        return len(s) == n and all(c in A for c in s)\n\n    def count_distinct_strings(s):\n        if len(s) == n:\n            return 1\n        return sum(count_distinct_strings(s[i:j]) for i in range(n) for j in range(i + 1, n + 1))\n\n    count = sum(count_distinct_strings(s) for s in itertools.permutations(s for s in itertools.permutations(s) if is_valid(s))) % (10**9 + 7)\n    return str(count)"
    },
    {
        "number": 1869,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    min_ops = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] + a[j] == a[i] + a[j + 1]:\n                min_ops = min(min_ops, j - i)\n\n    return str(min_ops)\n"
    },
    {
        "number": 1870,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n    words = []\n    for i in range(n):\n        words.append(t[i])\n    words.sort()\n    remain_words = n\n    for i in range(n, len(words)):\n        if words[i] - words[i-1] <= c:\n            remain_words -= 1\n        else:\n            break\n    return str(remain_words)"
    },
    {
        "number": 1871,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    chapters = list(map(int, stdin.split()))\n\n    min_hours = float('inf')\n    for i in range(n):\n        hours = chapters[i] * x\n        if hours < min_hours:\n            min_hours = hours\n\n    return str(min_hours)"
    },
    {
        "number": 1872,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    if n < 5 or n > 10**9 or r < 1 or r > 10**9:\n        return \"Invalid input\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    if not is_prime(n):\n        return \"Invalid input\"\n\n    def area(n: int, r: int) -> float:\n        if n < 5:\n            return 0\n\n        def distance(x1: int, y1: int, x2: int, y2: int) -> float:\n            return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n        def max_distance(points: List[Tuple[int, int]]) -> int:\n            max_distance = 0\n            for i in range(len(points)):\n                for j in range(i + 1, len(points)):\n                    distance1 = distance(points[i][0], points[i][1], points[j][0], points[j][1])\n                    distance2 = distance(points[j][0], points[j][1], points[i][0], points[i][1])\n                    if distance1 > max_distance or (distance1 == max_distance and distance2 > max_distance):\n                        max_distance = distance1\n            return max_distance\n\n        points = [(i, j) for i in range(n) for j in range(i + 1, n + 1)]\n        max_distance = max_distance(points)\n\n        return 2 * (r ** 2) * max_distance\n\n    return str(area(n, r))\n"
    },
    {
        "number": 1873,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Count the number of options for each genre\n    count = [0] * m\n    for i in range(n):\n        count[a[i] - 1] += 1\n\n    # Find the number of ways to choose two books of different genres\n    ways = 0\n    for i in range(m):\n        if count[i] > 1:\n            ways += 2 ** count[i]\n\n    return str(ways)\n"
    },
    {
        "number": 1874,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l_3, l_4, l_5 = map(int, stdin.split())\n    volume = 0.0\n\n    for i in range(1, 6):\n        volume += (l_3 + l_4 + l_5) * (l_3 + l_4 + l_5 - i) / 2\n\n    volume += (l_3 + l_4 + l_5) * (l_3 + l_4 + l_5 - 1) / 2\n\n    volume += (l_3 + l_4 + l_5) * (l_3 + l_4 + l_5 - 2) / 2\n\n    return str(volume)"
    },
    {
        "number": 1875,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    special_points = set(points)\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if i!= j and i!= k and i!= l and j!= k and j!= l and k!= l:\n                        area = abs(points[i][0] * points[j][1] * points[k][2] * points[l][2] - points[i][0] * points[k][1] * points[l][2] * points[j][2] - points[i][0] * points[j][1] * points[l][2] * points[k][2] + points[i][0] * points[j][1] * points[k][2] * points[l][2] + points[i][0] * points[k][1] * points[l][2] * points[j][2] + points[i][0] * points[j][1] * points[k][2] * points[l][2]) / 2\n                        if area > max_area:\n                            max_area = area\n\n    return str(max_area)\n"
    },
    {
        "number": 1876,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        u, v, x = map(int, stdin.split())\n        edges.append((u, v, x))\n\n    good_sequences = 0\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            path = []\n            path.append(i)\n            path.append(j)\n            path.append(i + 1)\n            path.append(j + 1)\n            path.append(i + 2)\n            path.append(j + 2)\n            path.append(i + 3)\n            path.append(j + 3)\n            path.append(i + 4)\n            path.append(j + 4)\n            path.append(i + 5)\n            path.append(j + 5)\n            path.append(i + 6)\n            path.append(j + 6)\n            path.append(i + 7)\n            path.append(j + 7)\n            path.append(i + 8)\n            path.append(j + 8)\n            path.append(i + 9)\n            path.append(j + 9)\n            path.append(i + 10)\n            path.append(j + 10)\n            path.append(i + 11)\n            path.append(j + 11)\n            path.append(i + 12)\n            path.append(j + 12)\n            path.append(i + 13)\n            path.append(j + 13)\n            path.append(i + 14)\n            path.append(j + 14)\n            path.append(i + 15)\n            path.append(j + 15)\n            path.append(i + 16)\n            path.append(j + 16)\n            path.append(i + 17)\n            path.append(j + 17)\n            path.append(i + 18)\n            path.append(j + 18)\n            path.append(i + 19)\n            path.append(j + 19)\n            path.append(i + 20)\n            path.append(j + 20)\n            path.append(i + 21)\n            path.append(j + 21)\n            path.append(i + 22)\n            path.append(j + 22)\n            path.append(i + 23)\n            path.append(j + 23)\n            path.append(i + 24)\n            path.append(j + 24)\n            path.append(i + 25)\n            path.append(j + 25)\n            path.append(i + 26)\n            path.append(j + 26)\n            path.append(i + 27)\n            path.append(j + 27)\n            path.append(i + 28)\n            path.append(j + 28)\n            path.append(i + 29)\n            path.append(j + 29)\n            path.append(i + 30)\n            path.append(j + 30)\n            path.append(i + 31)\n            path.append(j + 31)\n            path.append(i + 32)\n            path.append(j + 32)\n            path.append(i + 33)\n            path.append(j + 33)\n            path.append(i + 34)\n            path.append(j + 34)\n            path.append(i + 35)\n            path.append(j + 35)\n            path.append(i + 36)\n            path.append(j + 36)\n            path.append(i + 37)\n            path.append(j + 37)\n            path.append(i + 38)\n            path.append(j + 38)\n            path.append(i + 39)\n            path.append(j + 39)\n            path.append(i + 40)\n            path.append(j + 40)\n            path.append(i + 41)\n            path.append(j + 41)\n            path.append(i + 42)\n            path.append(j + 42)\n            path.append(i + 43)\n            path.append("
    },
    {
        "number": 1877,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = stdin.strip().split()\n    moves = []\n    for move in sequence:\n        if move == 'U':\n            moves.append((0, 1))\n        elif move == 'R':\n            moves.append((1, 0))\n    moves.append((0, 0))\n    moves.append((1, 1))\n    moves.append((2, 2))\n    moves.append((3, 3))\n    moves.append((4, 4))\n    moves.append((5, 5))\n    moves.append((6, 6))\n    moves.append((7, 7))\n    moves.append((8, 8))\n    moves.append((9, 9))\n    moves.append((10, 10))\n    moves.append((11, 11))\n    moves.append((12, 12))\n    moves.append((13, 13))\n    moves.append((14, 14))\n    moves.append((15, 15))\n    moves.append((16, 16))\n    moves.append((17, 17))\n    moves.append((18, 18))\n    moves.append((19, 19))\n    moves.append((20, 20))\n    moves.append((21, 21))\n    moves.append((22, 22))\n    moves.append((23, 23))\n    moves.append((24, 24))\n    moves.append((25, 25))\n    moves.append((26, 26))\n    moves.append((27, 27))\n    moves.append((28, 28))\n    moves.append((29, 29))\n    moves.append((30, 30))\n    moves.append((31, 31))\n    moves.append((32, 32))\n    moves.append((33, 33))\n    moves.append((34, 34))\n    moves.append((35, 35))\n    moves.append((36, 36))\n    moves.append((37, 37))\n    moves.append((38, 38))\n    moves.append((39, 39))\n    moves.append((40, 40))\n    moves.append((41, 41))\n    moves.append((42, 42))\n    moves.append((43, 43))\n    moves.append((44, 44))\n    moves.append((45, 45))\n    moves.append((46, 46))\n    moves.append((47, 47))\n    moves.append((48, 48))\n    moves.append((49, 49))\n    moves.append((50, 50))\n    moves.append((51, 51))\n    moves.append((52, 52))\n    moves.append((53, 53))\n    moves.append((54, 54))\n    moves.append((55, 55))\n    moves.append((56, 56))\n    moves.append((57, 57))\n    moves.append((58, 58))\n    moves.append((59, 59))\n    moves.append((60, 60))\n    moves.append((61, 61))\n    moves.append((62, 62))\n    moves.append((63, 63))\n    moves.append((64, 64))\n    moves.append((65, 65))\n    moves.append((66, 66))\n    moves.append((67, 67))\n    moves.append((68, 68))\n    moves.append((69, 69))\n    moves.append((70, 70))\n    moves.append((71, 71))\n    moves.append((72, 72))\n    moves.append((73, 73))\n    moves.append((74, 74))\n    moves.append((75, 75))\n    moves.append((76, 76))\n    moves.append((77, 77))\n    moves.append((78, 78))\n    moves.append((79, 79))\n    moves.append((80, 80))\n    moves.append((81, 8"
    },
    {
        "number": 1878,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rectangles = []\n    for _ in range(n):\n        x1, y1, x2, y2 = map(int, stdin.readline().strip().split())\n        rectangles.append((x1, y1, x2, y2))\n\n    def count_rectangles(x, y, w, h):\n        count = 0\n        for i in range(x, x + w):\n            for j in range(y, y + h):\n                for r in rectangles:\n                    if i >= r[0] and i <= r[2] and j >= r[1] and j <= r[3]:\n                        count += 1\n        return count\n\n    def sum_values(x, y, w, h):\n        count = count_rectangles(x, y, w, h)\n        return count * (x + w) + count * (y + h)\n\n    result = sum_values(1, 1, 100, 100)\n    return str(result)"
    },
    {
        "number": 1879,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, s_x, s_y, e_x, e_y = map(int, stdin.split())\n    wind_direction = stdin[s_x:s_x+1]\n    if wind_direction == \"E\":\n        e_x += 1\n    elif wind_direction == \"S\":\n        e_y -= 1\n    elif wind_direction == \"W\":\n        e_x -= 1\n    elif wind_direction == \"N\":\n        e_y += 1\n    else:\n        return \"-1\"\n\n    if e_x == e_y:\n        return \"-1\"\n\n    return str(t)"
    },
    {
        "number": 1880,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin)\n    shuffled_digits = [num % 10, num // 10 % 10, num // 100 % 10, num // 1000 % 10, num // 10000 % 10]\n    result = 1\n    for digit in shuffled_digits:\n        result *= digit\n    return str(result)[:5]"
    },
    {
        "number": 1881,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # Group colors and assign keys\n    groups = []\n    for i in range(n):\n        color = p[i]\n        if color not in groups:\n            groups.append(color)\n        else:\n            while groups.index(color)!= groups.index(groups[groups.index(color) + 1]):\n                groups.append(groups[groups.index(color) + 1])\n            groups.append(color)\n\n    # Replace colors with assigned group keys\n    result = []\n    for i in range(n):\n        color = p[i]\n        result.append(groups.index(color))\n\n    return''.join(map(str, result))"
    },
    {
        "number": 1882,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    # Sort the problems by their index\n    problems = sorted(range(1, n+1), key=lambda x: a[x-1])\n\n    # Initialize the maximum score and the number of solutions\n    max_score = 0\n    num_solutions = 0\n\n    # Iterate over the problems and solve them\n    for i in range(n):\n        # Check if the problem can be solved in the given time\n        if t[i] <= T:\n            # Solve the problem\n            score = 0\n            for j in range(a[i]):\n                score += j\n            max_score = max(max_score, score)\n            num_solutions += 1\n\n    # Output the maximum score and the number of solutions\n    return f\"{max_score}\\n{num_solutions}\""
    },
    {
        "number": 1883,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    types = list(map(int, stdin.readline().strip().split()))\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(v, path, visited):\n        if v == n:\n            return True\n        if v in visited:\n            return False\n        visited.add(v)\n        if types[v] == 0:\n            if dfs(v + 1, path + [v + 1], visited):\n                return True\n        elif types[v] == 1:\n            if dfs(v + 1, path + [v + 1], visited):\n                return True\n        return False\n\n    path = []\n    visited = set()\n    if dfs(1, path, visited):\n        print(len(path))\n        for v in path:\n            print(v, end=\" \")\n        print()\n    else:\n        print(\"No solution found\")\n\n    return \"\""
    },
    {
        "number": 1884,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, x2 = map(int, stdin.split())\n    c1, c2 = map(int, stdin.split())\n\n    k1 = [0] * n\n    k2 = [0] * n\n\n    for i in range(n):\n        k1[i] = i + 1\n        k2[i] = i + 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            k1[i] = min(k1[i], k1[j])\n            k2[i] = min(k2[i], k2[j])\n\n    if k1[0] == k2[0]:\n        return \"No\"\n\n    k1.sort()\n    k2.sort()\n\n    for i in range(n):\n        if k1[i]!= k2[i]:\n            return \"No\"\n\n    for i in range(n):\n        if k1[i] == k2[i]:\n            print(k1[i], end=\" \")\n\n    print()\n\n    for i in range(n):\n        print(k2[i], end=\" \")\n\n    return \"Yes\""
    },
    {
        "number": 1885,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            for k in range(1, j + 1):\n                for l in range(1, k + 1):\n                    for m in range(1, l + 1):\n                        for n in range(1, m + 1):\n                            count += 1\n    return str(count)"
    },
    {
        "number": 1886,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    capitalized_word = word[0].upper() + word[1:]\n    return capitalized_word"
    },
    {
        "number": 1887,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    h1 = list(map(int, stdin.readline().strip().split()))\n    h2 = list(map(int, stdin.readline().strip().split()))\n\n    def max_height(students):\n        max_height = 0\n        for i in range(n):\n            max_height = max(max_height, students[i])\n        return max_height\n\n    def max_height_team(students):\n        max_height = max_height(students)\n        team = []\n        for i in range(n):\n            if i == 0:\n                team.append(students[i])\n            else:\n                if students[i] > team[-1]:\n                    team.append(students[i])\n                else:\n                    team.append(team[-1])\n        return max_height - sum(team)\n\n    max_height_team(h1)\n    max_height_team(h2)\n\n    return str(max_height_team(h1) + max_height_team(h2))\n"
    },
    {
        "number": 1888,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    debts = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        debts.append((a, b, c))\n\n    def min_sum(debts):\n        total_sum = sum(debts, 0)\n        min_sum = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    if debts[i][0] == debts[j][0] and debts[i][1] == debts[k][1]:\n                        min_sum = min(min_sum, total_sum - debts[i][2] - debts[j][2] + debts[k][2])\n        return min_sum\n\n    return str(min_sum(debts))\n"
    },
    {
        "number": 1889,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    grid = [[0] * m for _ in range(n)]\n    bears = []\n    for _ in range(q):\n        i, j = map(int, stdin.split())\n        grid[i][j] = 1\n        bears.append((i, j))\n\n    max_score = 0\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                score = 0\n                for bear in bears:\n                    if bear[0] == i and bear[1] == j:\n                        score += 1\n                max_score = max(max_score, score)\n\n    return str(max_score)\n"
    },
    {
        "number": 1890,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = int(stdin.strip())\n\n    # Concatenate k copies of a\n    s = ''.join(['a'] * k)\n\n    # Count the number of ways to delete digits\n    count = 0\n    for i in range(n):\n        # Check if the current digit is divisible by 5\n        if s[i] % 5 == 0:\n            # Check if the current digit is not already in the set\n            if s[i] not in s:\n                # Add the current digit to the set\n                s = s[:i] + s[i+1:] + s[i+2:]\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1891,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, A, B = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def destroy_base(base):\n        if len(base) < 2:\n            return 0\n\n        if len(base) == 2:\n            return 2\n\n        burn_power = 2 * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base) * len(base)\n\n        burn_power -= 2 * len(base) * len(base) * len(base)\n        burn_power -= 2 * len(base) * len(base)"
    },
    {
        "number": 1892,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ways = 0\n    for _ in range(n):\n        command = stdin.strip()\n        if command == \"f\":\n            ways += 1\n        elif command == \"s\":\n            ways += 1\n    return str(ways)"
    },
    {
        "number": 1893,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    transistors = 1.000000011 * n\n    return str(transistors)"
    },
    {
        "number": 1894,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    house = []\n    for _ in range(n):\n        line = input()\n        house.append(line)\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and house[x][y]!= '.'\n\n    def move(x, y, dx, dy):\n        if is_valid(x + dx, y + dy):\n            house[x + dx][y + dy] = '.'\n            return True\n        return False\n\n    def calm_down(x, y):\n        dx, dy = 0, 1\n        while move(x, y, dx, dy):\n            dx, dy = -dx, -dy\n\n    for _ in range(m):\n        calm_down(0, 0)\n\n    return str(m)"
    },
    {
        "number": 1895,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    happy_friends = 0\n    for _ in range(n):\n        event = int(stdin.strip())\n        if event == 1:\n            handle = stdin.strip()\n            if handle == \"motarack\":\n                happy_friends += 1\n            elif handle == \"light\":\n                happy_friends += 1\n        elif event == 2:\n            friend = stdin.strip()\n            if friend == \"alice\":\n                happy_friends += 1\n            elif friend == \"bob\":\n                happy_friends += 1\n            elif friend == \"tanyaromanova\":\n                happy_friends += 1\n    return str(happy_friends)"
    },
    {
        "number": 1896,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hexagons = 0\n    for i in range(1, n+1):\n        hexagons += i * (i + 1) // 2\n    return str(hexagons)"
    },
    {
        "number": 1897,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    vowels = \"AEIOU\"\n    count_vowels = 0\n    count_letters = 0\n    for i in range(len(s)):\n        count_vowels += s[i] in vowels\n        count_letters += 1\n    simple_prettiness = count_vowels / count_letters\n    return str(simple_prettiness)"
    },
    {
        "number": 1898,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    feeling = \"\"\n    for i in range(1, n+1):\n        feeling += \"I hate it\" if i == 1 else \"I hate that I love it\" if i == 2 else \"I hate that I love that I hate it\" if i == 3 else \"\"\n    return feeling"
    },
    {
        "number": 1899,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n    r = list(map(int, stdin.split()))\n\n    if n < s or m < s or k < 1 or k > n:\n        return \"-1\"\n\n    if n < m:\n        return \"-1\"\n\n    if n < k:\n        return \"-1\"\n\n    if n % 2 == 0:\n        return \"-1\"\n\n    if n == 1:\n        return \"0\"\n\n    if n == 2:\n        return \"0\"\n\n    if n == 3:\n        return \"0\"\n\n    if n == 4:\n        return \"0\"\n\n    if n == 5:\n        return \"0\"\n\n    if n == 6:\n        return \"0\"\n\n    if n == 7:\n        return \"0\"\n\n    if n == 8:\n        return \"0\"\n\n    if n == 9:\n        return \"0\"\n\n    if n == 10:\n        return \"0\"\n\n    if n == 11:\n        return \"0\"\n\n    if n == 12:\n        return \"0\"\n\n    if n == 13:\n        return \"0\"\n\n    if n == 14:\n        return \"0\"\n\n    if n == 15:\n        return \"0\"\n\n    if n == 16:\n        return \"0\"\n\n    if n == 17:\n        return \"0\"\n\n    if n == 18:\n        return \"0\"\n\n    if n == 19:\n        return \"0\"\n\n    if n == 20:\n        return \"0\"\n\n    if n == 21:\n        return \"0\"\n\n    if n == 22:\n        return \"0\"\n\n    if n == 23:\n        return \"0\"\n\n    if n == 24:\n        return \"0\"\n\n    if n == 25:\n        return \"0\"\n\n    if n == 26:\n        return \"0\"\n\n    if n == 27:\n        return \"0\"\n\n    if n == 28:\n        return \"0\"\n\n    if n == 29:\n        return \"0\"\n\n    if n == 30:\n        return \"0\"\n\n    if n == 31:\n        return \"0\"\n\n    if n == 32:\n        return \"0\"\n\n    if n == 33:\n        return \"0\"\n\n    if n == 34:\n        return \"0\"\n\n    if n == 35:\n        return \"0\"\n\n    if n == 36:\n        return \"0\"\n\n    if n == 37:\n        return \"0\"\n\n    if n == 38:\n        return \"0\"\n\n    if n == 39:\n        return \"0\"\n\n    if n == 40:\n        return \"0\"\n\n    if n == 41:\n        return \"0\"\n\n    if n == 42:\n        return \"0\"\n\n    if n == 43:\n        return \"0\"\n\n    if n == 44:\n        return \"0\"\n\n    if n == 45:\n        return \"0\"\n\n    if n == 46:\n        return \"0\"\n\n    if n == 47:\n        return \"0\"\n\n    if n == 48:\n        return \"0\"\n\n    if n == 49:\n        return \"0\"\n\n    if n == 50:\n        return \"0\"\n\n    if n == 51:\n        return \"0\"\n\n    if n == 52:\n        return \"0\"\n\n    if n == 53:\n        return \"0\"\n\n    if n == 54:\n        return \"0\"\n\n    if n == 55:\n        return \"0\"\n\n    if n == 56:\n        return \"0\"\n\n    if n == 57:\n        return \"0\"\n\n    if n == 58:\n        return \"0\"\n\n    if n == 59:\n        return \"0\"\n\n    if n == 60:\n        return \"0\"\n\n    if n == 61:\n        return \"0\"\n\n    if n == 62:\n        return \"0\"\n\n    if n == 63:\n        return \"0\"\n\n    if n == 64:\n        return \"0\"\n\n    if n == 65:\n        return \"0\"\n\n    if n == 66:\n        return \"0\"\n\n    if n == 67:\n        return \"0\"\n\n    if n == 68:\n        return \"0\"\n\n    if n == 69:\n        return \"0\"\n\n    if n == 70:\n        return \"0\"\n\n    if n == 7"
    },
    {
        "number": 1900,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    participants = set()\n    for i in range(n):\n        participants.add(a[i])\n    line_length = len(participants)\n    teams = []\n    for i in range(line_length):\n        team = []\n        for j in range(i, line_length):\n            if j - i == k:\n                team.append(a[j])\n        teams.append(team)\n    return str(len(participants - set(teams[0])))"
    },
    {
        "number": 1901,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        friends.append((x, y))\n\n    gold = [0] * n\n    gold[0] = c[0]\n    for i in range(1, n):\n        gold[i] = max(gold[i - 1], c[i])\n\n    for i in range(n - 1, -1, -1):\n        for j in range(i + 1, n):\n            if gold[i] >= gold[j]:\n                gold[i], gold[j] = gold[j], gold[i]\n\n    return str(gold[0])\n"
    },
    {
        "number": 1902,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    text = stdin.strip()\n\n    # Initialize variables\n    prefix = \"\"\n    clicks = 0\n\n    # Iterate through each character in the text\n    for i in range(len(text)):\n        # If the character is a space, print the prefix and reset the prefix\n        if text[i] == \" \":\n            print(prefix)\n            prefix = \"\"\n            clicks += 1\n\n        # If the character is a punctuation sign, print the prefix and reset the prefix\n        elif text[i] in [\".\", \",\", \"?\", \"!\", \"'\"]:\n            print(prefix)\n            prefix = \"\"\n            clicks += 1\n\n        # If the character is a lowercase letter, append it to the prefix\n        else:\n            prefix += text[i]\n\n    # Print the last prefix\n    print(prefix)\n\n    return str(clicks)\n"
    },
    {
        "number": 1903,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cups = []\n    for _ in range(n):\n        cups.append(list(map(int, stdin.split())))\n\n    max_significance = 0\n    for i in range(m):\n        for j in range(i + 1, m):\n            if cups[i][0] > cups[j][0]:\n                max_significance += cups[i][0] - cups[j][0]\n            elif cups[i][0] == cups[j][0]:\n                max_significance += cups[i][1] - cups[j][1]\n\n    return str(max_significance)"
    },
    {
        "number": 1904,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    s = stdin.split()[1]\n    a = list(map(int, stdin.split()[2].split()))\n\n    min_ambiguity = float('inf')\n    for i in range(n):\n        if s[i] == 'h':\n            if i > 0 and s[i-1] == 'a':\n                min_ambiguity = min(min_ambiguity, a[i-1] + 1)\n            if i < n-1 and s[i+1] == 'a':\n                min_ambiguity = min(min_ambiguity, a[i+1] + 1)\n\n    return str(min_ambiguity)"
    },
    {
        "number": 1905,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    result = []\n\n    for _ in range(q):\n        t, r, c, x = map(int, stdin.split())\n        if t == 1:\n            matrix[r - 1][c - 1] = x\n        elif t == 2:\n            matrix[r - 1][c - 1] = matrix[r - 1][c - 1] + 1\n        elif t == 3:\n            matrix[r - 1][c - 1] = matrix[r - 1][c - 1] + x\n\n    for row in matrix:\n        result.append(' '.join(map(str, row)))\n\n    return '\\n'.join(result)\n"
    },
    {
        "number": 1906,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 == 0 or i % 10 == 0:\n            count += 1\n    return str(count)"
    },
    {
        "number": 1907,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    dancers = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.readline().strip().split())\n        dancers.append((x, y, r))\n\n    def is_disjoint(a, b):\n        return a[0] == b[0] or a[1] == b[1] or a[0] < b[0] < a[0] + r or a[1] < b[1] < a[1] + r\n\n    def is_subset(a, b):\n        return a[0] < b[0] < a[0] + r and a[1] < b[1] < a[1] + r\n\n    def spaciousness(dancers):\n        total_spaciousness = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_disjoint(dancers[i], dancers[j]) or is_subset(dancers[i], dancers[j]):\n                    total_spaciousness += 1\n        return total_spaciousness\n\n    max_spaciousness = max(spaciousness(dancers))\n    return str(max_spaciousness)\n"
    },
    {
        "number": 1908,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    food_types = list(map(int, stdin.split()))\n    food_types.sort()\n    food_types.reverse()\n    food_types = [food_types[i] for i in range(n)]\n\n    friends = []\n    for _ in range(m):\n        friend = list(map(int, stdin.split()))\n        friends.append(friend)\n\n    def can_eat(friend, food_types):\n        return any(friend[i] == food_types[i] for i in range(n))\n\n    def can_eat_all(friend, food_types):\n        return all(friend[i] == food_types[i] for i in range(n))\n\n    def can_eat_food(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_all(friend, food_types)\n\n    def can_eat_food_and_friends(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types)\n\n    def can_eat_food_and_friends_and_kitchen(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types) and can_eat_food_and_friends(friend, food_types)\n\n    def can_eat_food_and_friends_and_kitchen_and_friends(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types) and can_eat_food_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen(friend, food_types)\n\n    def can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types) and can_eat_food_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends(friend, food_types)\n\n    def can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen_and_friends(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types) and can_eat_food_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen(friend, food_types)\n\n    def can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen_and_friends_and_kitchen(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types) and can_eat_food_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen_and_friends(friend, food_types)\n\n    def can_eat_food_and_friends_and_kitchen_and_friends_and_kitchen_and_friends_and_kitchen_and_friends(friend, food_types):\n        return can_eat(friend, food_types) and can_eat_food(friend, food_types) and can_eat_food_and_friends(friend, food_types) and can_eat_food_and_friends_and_kitchen(friend, food_types) and can_eat_food_and_friends_and_kitchen_and_friends(friend, food_types) and can_eat_food_and_friends_and"
    },
    {
        "number": 1909,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tasks = list(map(int, stdin.split()))\n    tasks.sort()\n    power = [0] * n\n    power[0] = tasks[0]\n    for i in range(1, n):\n        power[i] = tasks[i] + power[i-1]\n    min_power = float('inf')\n    min_task = 0\n    for i in range(1, n):\n        if power[i] < min_power:\n            min_power = power[i]\n            min_task = i\n    return str(min_task)"
    },
    {
        "number": 1910,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    ways = 0\n    for i in range(1, n + 1):\n        ways += 4 * i\n    return str(ways)"
    },
    {
        "number": 1911,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_min = [0] * n\n    min_max = [0] * n\n\n    for i in range(1, n):\n        max_min[i] = max(max_min[i-1], a[i])\n        min_max[i] = min(min_max[i-1], a[i])\n\n    min_cost = sum(max_min) - sum(min_max)\n\n    return str(min_cost)"
    },
    {
        "number": 1912,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, g, b, w = map(int, stdin.split())\n    if r == 0 and g == 0 and b == 0 and w == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 1913,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    beautiful_numbers = [a[i] for i in range(n) if a[i]!= 0]\n    beautiful_numbers.sort()\n    product = 1\n    for i in range(n):\n        if beautiful_numbers[i] == beautiful_numbers[i + 1]:\n            product *= beautiful_numbers[i]\n        else:\n            break\n    return str(product)"
    },
    {
        "number": 1914,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = stdin.readline().strip()\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    s = s.split()\n    f = [0] * n\n    for i in range(n):\n        for j in range(n):\n            if s[i] + s[j] == t:\n                f[i] += 1\n                f[j] += 1\n    sum_f = 0\n    for i in range(n):\n        for j in range(n):\n            sum_f += f[i] * f[j]\n    return str(sum_f)"
    },
    {
        "number": 1915,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = [[0] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(i):\n            a[i][j] = a[i-1][j] + a[i-1][j+1]\n        a[i][i] = 1\n    max_val = a[n-1][n-1]\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if a[i][j] > max_val:\n                max_val = a[i][j]\n    return str(max_val)"
    },
    {
        "number": 1916,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    min_c = a[0] | b[0]\n    for i in range(1, n):\n        min_c = min(min_c, a[i] & b[0])\n\n    for i in range(1, m):\n        min_c = min(min_c, a[0] & b[i])\n\n    return str(min_c)"
    },
    {
        "number": 1917,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the number of projects of each type\n    projects = [0] * n\n    for i in range(n):\n        projects[i] = sum(a[:i+1])\n\n    # Calculate the number of projects of each type that meet the constraint\n    max_projects = [0] * n\n    for i in range(n):\n        max_projects[i] = sum(projects[:i+1])\n\n    # Find the maximum value of f\n    f = 0\n    for i in range(n):\n        f += max_projects[i] - projects[i] ** 2\n\n    # Find the optimal solution\n    solution = []\n    for i in range(n):\n        if max_projects[i] - projects[i] ** 2 <= f:\n            solution.append(i+1)\n            f -= max_projects[i] - projects[i] ** 2\n\n    return''.join(map(str, solution))"
    },
    {
        "number": 1918,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    A = stdin.readline().strip()\n    B = stdin.readline().strip()\n\n    # Split the game pieces into two teams\n    A_pieces = [p[i] for i in range(n) if A[i] == 'A']\n    B_pieces = [p[i] for i in range(n) if A[i] == 'B']\n\n    # Determine the optimal strategy\n    max_strength = max(A_pieces) + max(B_pieces)\n\n    return str(max_strength)"
    },
    {
        "number": 1919,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        return \"2\"\n    else:\n        return \"1\""
    },
    {
        "number": 1920,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    friends = []\n    for _ in range(n):\n        gender, a, b = stdin.strip().split()\n        if gender == 'M':\n            friends.append((a, b))\n        else:\n            friends.append((b, a))\n\n    def max_friends(a, b):\n        male_friends = [f for f in friends if f[0] == a]\n        female_friends = [f for f in friends if f[1] == b]\n        return max(male_friends, key=len)\n\n    max_male_friends = max_friends(117, 128)\n    max_female_friends = max_friends(131, 140)\n    max_total_friends = max(max_male_friends, max_female_friends)\n\n    return str(max_total_friends)\n"
    },
    {
        "number": 1921,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s_x, s_y, f_x, f_y = map(int, stdin.split())\n    x_list = list(map(int, stdin.split()))\n\n    # Initialize the distance matrix\n    distance_matrix = [[float('inf')] * n for _ in range(n)]\n    distance_matrix[s_x][s_y] = 0\n\n    # Initialize the visited list\n    visited = [[False] * n for _ in range(n)]\n\n    # Initialize the queue\n    queue = [(0, 0)]\n\n    while queue:\n        # Get the current distance and the current block\n        distance, block = queue.pop(0)\n\n        # Check if the block is the home block\n        if block == f_x and block == f_y:\n            return str(distance)\n\n        # Check if the block is already visited\n        if visited[block[0]][block[1]]:\n            continue\n\n        # Update the distance matrix\n        distance_matrix[block[0]][block[1]] = distance\n\n        # Check if the block is the nearest instant-movement location\n        if distance_matrix[block[0]][block[1]] == float('inf'):\n            continue\n\n        # Check if the block is the nearest instant-movement location\n        for i in range(m):\n            if distance_matrix[block[0]][block[1]] + x_list[i] < distance_matrix[block[0]][block[1]]:\n                distance_matrix[block[0]][block[1]] = distance_matrix[block[0]][block[1]] + x_list[i]\n                queue.append((distance_matrix[block[0]][block[1]], (block[0], block[1])))\n\n        # Mark the block as visited\n        visited[block[0]][block[1]] = True\n\n    return \"0\""
    },
    {
        "number": 1922,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cards = [[False] * M for _ in range(N)]\n    count = 0\n\n    for i in range(N):\n        for j in range(M):\n            if cards[i][j]:\n                count += 1\n                for k in range(i - 1, -1, -1):\n                    for l in range(j - 1, -1, -1):\n                        if cards[k][l]:\n                            cards[k][l] = False\n                            break\n                for k in range(i + 1, N):\n                    for l in range(j - 1, -1, -1):\n                        if cards[k][l]:\n                            cards[k][l] = False\n                            break\n                for k in range(i - 1, i + 2):\n                    for l in range(j - 1, -1, -1):\n                        if cards[k][l]:\n                            cards[k][l] = False\n                            break\n                for k in range(i - 1, i + 2):\n                    for l in range(j + 1, M):\n                        if cards[k][l]:\n                            cards[k][l] = False\n                            break\n                for k in range(i - 1, i + 2):\n                    for l in range(j - 1, j + 2):\n                        if cards[k][l]:\n                            cards[k][l] = False\n                            break\n\n    return str(count)"
    },
    {
        "number": 1923,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    skewers = list(map(int, stdin.readline().strip().split()))\n    max_ingredients = 0\n    for i in range(n):\n        if i < n - 1:\n            max_ingredients += skewers[i] + skewers[i + 1]\n        else:\n            max_ingredients += skewers[i]\n    return str(max_ingredients)"
    },
    {
        "number": 1924,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r_1, c_1, r_2, c_2 = map(int, stdin.split())\n    MOD = 10**9 + 7\n    result = 0\n    for i in range(r_1, r_2 + 1):\n        for j in range(c_1, c_2 + 1):\n            result += f(i, j)\n    return str(result % MOD)\n\ndef"
    },
    {
        "number": 1925,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, N = map(int, stdin.split())\n    x = 3\n    max_value = 0\n    while x <= N:\n        max_value = max(max_value, A * x / B - A * floor(x / B))\n        x += 1\n    return str(max_value)"
    },
    {
        "number": 1926,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    heap = []\n    for num in a:\n        heapq.heappush(heap, num)\n\n    count = 0\n    for i in range(n - 1):\n        if heapq.heappop(heap) < heapq.heappop(heapq.heappop(heap)):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 1927,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(range(n))\n    a = list(map(int, stdin.split()))\n\n    for i in range(m):\n        p[a[i] - 1] = i + 1\n\n    min_pos = min(p)\n    max_pos = max(p)\n\n    return f\"{min_pos} {max_pos}\""
    },
    {
        "number": 1928,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    for _ in range(k):\n        i, j = map(int, stdin.split())\n        matrix[i - 1][j - 1] = 1\n\n    def dfs(i, j, path):\n        if i == n or j == m:\n            return path\n\n        if matrix[i][j] == 1:\n            return dfs(i + 1, j, path + [(i, j)])\n\n        if dfs(i, j + 1, path + [(i, j)]):\n            return True\n\n        return False\n\n    def min_penalty(i, j):\n        path = []\n        while dfs(i, j, path):\n            path.pop()\n\n        return sum(len(p) for p in path)\n\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 1:\n                print(min_penalty(i + 1, j + 1), end=\" \")\n            else:\n                print(\" \", end=\" \")\n        print()"
    },
    {
        "number": 1929,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, c = map(int, stdin.split())\n    prisoners = list(map(int, stdin.split()))\n    max_prisoners = max(prisoners)\n    max_prisoner_crime = max(prisoners)\n\n    if max_prisoner_crime > t:\n        return \"0\"\n\n    segment_count = 0\n    for i in range(1, n):\n        if prisoners[i] > prisoners[i - 1]:\n            segment_count += 1\n\n    if segment_count > 1:\n        return \"0\"\n\n    ways = 0\n    for i in range(n - 1):\n        if prisoners[i] > prisoners[i + 1]:\n            ways += 1\n\n    return str(ways)\n"
    },
    {
        "number": 1930,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort()\n    p.append(-1)\n    p.sort"
    },
    {
        "number": 1931,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pyramids = 0\n    for i in range(1, n+1):\n        pyramids += 1\n        for j in range(1, i+1):\n            pyramids += 1\n    return str(pyramids)"
    },
    {
        "number": 1932,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    faces = []\n    for _ in range(n):\n        polyhedron = stdin.strip()\n        if polyhedron == \"Tetrahedron\":\n            faces.append(4)\n        elif polyhedron == \"Cube\":\n            faces.append(6)\n        elif polyhedron == \"Octahedron\":\n            faces.append(8)\n        elif polyhedron == \"Dodecahedron\":\n            faces.append(12)\n        elif polyhedron == \"Icosahedron\":\n            faces.append(20)\n    return str(sum(faces))"
    },
    {
        "number": 1933,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    max_score = 0\n    min_replacements = float('inf')\n\n    for i in range(m):\n        for j in range(k):\n            if a[i][j] == 1:\n                score = 0\n                for k in range(i, min(i + 1, n)):\n                    if a[k][j] == 1:\n                        score += 1\n                max_score = max(max_score, score)\n                min_replacements = min(min_replacements, i + 1)\n\n    return str(max_score) +'' + str(min_replacements)\n"
    },
    {
        "number": 1934,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        queries.append(list(map(int, stdin.split())))\n\n    min_distances = [-1] * m\n    for i in range(m):\n        for j in range(i + 1, m):\n            if queries[i][0] <= queries[j][1] and queries[i][1] >= queries[j][0]:\n                min_distances[i] = min(min_distances[i], abs(a[queries[i][0]] - a[queries[j][1]]))\n                min_distances[j] = min(min_distances[j], abs(a[queries[j][0]] - a[queries[i][1]]))\n\n    for i in range(m):\n        if min_distances[i] == -1:\n            print(-1)\n        else:\n            print(min_distances[i])\n\n    return \"\""
    },
    {
        "number": 1935,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    g, r = map(int, stdin.split())\n\n    def is_safe(x, y):\n        return 0 <= x < n and 0 <= y < n and d[x] == y\n\n    def is_green_light_on(x, y):\n        return d[x] == y and g <= x <= n - 1 and r <= y <= n - 1\n\n    def is_red_light_on(x, y):\n        return d[x] == y and g <= x <= n - 1 and r <= y <= n - 1\n\n    def cross_road(x, y):\n        if is_safe(x, y):\n            if is_green_light_on(x, y):\n                if is_red_light_on(x, y - 1):\n                    return x, y - 1\n                else:\n                    return x, y\n            elif is_red_light_on(x, y):\n                return x, y\n            else:\n                return x, y\n        else:\n            return -1\n\n    def min_time(x, y):\n        if cross_road(x, y)!= -1:\n            return cross_road(x, y)[0] + min_time(cross_road(x, y)[0], cross_road(x, y)[1])\n        else:\n            return -1\n\n    return str(min_time(0, n - 1))\n"
    },
    {
        "number": 1936,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        l, r = map(int, stdin.readline().split())\n        x, y = -1, -1\n        for i in range(l, r + 1):\n            if i % l == 0 and i % y == 0:\n                x, y = i, i\n        if x == -1 or y == -1:\n            print(-1)\n        else:\n            print(x, y)"
    },
    {
        "number": 1937,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    b = list(map(int, stdin.strip().split()))\n    a = [b[i] for i in range(n // 2)]\n    a.sort()\n    b = [a[i] + a[n - i - 1] for i in range(n // 2)]\n    return''.join(map(str, b))"
    },
    {
        "number": 1938,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        segments.append((l, r))\n\n    def f(x):\n        if x == 0:\n            return 0\n        return x - 1\n\n    def intersection_sum(segments):\n        result = 0\n        for i in range(k):\n            for j in range(i + 1, k):\n                intersection = segments[i][1] & segments[j][0]\n                if intersection:\n                    result += f(intersection)\n        return result\n\n    result = intersection_sum(segments)\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 1939,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    tables = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i + j == k:\n                tables.append((i, j))\n    if len(tables) == 0:\n        return \"No suitable tables found.\"\n    else:\n        return str(tables[0][0]) + \" \" + str(tables[0][1])"
    },
    {
        "number": 1940,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n\n    # Initialize the pockets\n    pockets = [[] for _ in range(n)]\n\n    # Initialize the minimum number of days\n    min_days = float('inf')\n\n    # Iterate through the pebbles\n    for i in range(k):\n        # Find the pebble type with the least number of pebbles\n        min_pebble_type = min(pebbles_of_type, key=lambda x: len(pebbles_of_type[x]))\n\n        # Collect the pebble of the current type\n        pebbles_of_type[min_pebble_type].append(i)\n\n        # Update the minimum number of days\n        min_days = min(min_days, len(pebbles_of_type[min_pebble_type]) + 1)\n\n    # Return the minimum number of days\n    return str(min_days)\n"
    },
    {
        "number": 1941,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, n = map(int, stdin.split())\n    queries = []\n    for _ in range(n):\n        queries.append(list(map(int, stdin.split())))\n\n    result = []\n    for query in queries:\n        l, t, m = query\n        if l == 1:\n            result.append(t)\n        else:\n            result.append(-1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 1942,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    cycle = [0] * (n * (n - 1) + 1)\n    cycle[0] = 1\n    for i in range(1, n * (n - 1) + 1):\n        cycle[i] = cycle[i - 1] + cycle[i - cycle[i - 1]]\n    cycle = cycle[l:r + 1]\n    cycle.sort()\n    return''.join(map(str, cycle))"
    },
    {
        "number": 1943,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    brackets = []\n    for _ in range(n):\n        row = list(map(int, stdin.readline().strip()))\n        brackets.append(row)\n\n    max_score = 0\n    for i in range(1, 2**n):\n        for j in range(i):\n            if brackets[i-1][j] == 0:\n                continue\n            for k in range(j+1, i):\n                if brackets[i-1][k] == 0:\n                    continue\n                score = brackets[i-1][j] + brackets[i-1][k]\n                if score > max_score:\n                    max_score = score\n\n    return str(max_score)"
    },
    {
        "number": 1944,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    if a[0] > a[1] or b[0] > b[1]:\n        return \"Poor Alex\"\n    else:\n        return \"Happy Alex\""
    },
    {
        "number": 1945,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    mapping = {}\n    for _ in range(n):\n        old, new = stdin.strip().split()\n        if old in mapping and new not in mapping[old]:\n            mapping[old].append(new)\n        else:\n            mapping[old] = [new]\n    return str(len(mapping)) + '\\n' + '\\n'.join(str(old) +'' + str(new) for old, new in mapping.items())"
    },
    {
        "number": 1946,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    chem_forces = [int(x) for x in stdin.split()]\n    top_chemist = [int(x) for x in stdin.split()]\n\n    chem_forces.sort()\n    top_chemist.sort()\n\n    chem_forces_set = set(chem_forces)\n    top_chemist_set = set(top_chemist)\n\n    chem_forces_income = sum(x * chem_forces_set[i] for i, x in enumerate(chem_forces))\n    top_chemist_income = sum(x * top_chemist_set[i] for i, x in enumerate(top_chemist))\n\n    if chem_forces_income > top_chemist_income:\n        return str(chem_forces_income)\n    else:\n        return str(top_chemist_income)"
    },
    {
        "number": 1947,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, l = map(int, stdin.split())\n    hairlines = list(map(int, stdin.split()))\n    requests = []\n    for _ in range(m):\n        t, p, d = map(int, stdin.split())\n        requests.append((t, p, d))\n\n    def process_request(t, p, d):\n        if t == 0:\n            return hairlines[p]\n        else:\n            hairlines[p] += d\n            return hairlines[p]\n\n    hairlines = [process_request(t, p, d) for t, p, d in requests]\n\n    time_taken = sum(hairlines)\n    return str(time_taken)\n"
    },
    {
        "number": 1948,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(vertex, parent):\n        moves = 0\n        for neighbor, weight in edges:\n            if neighbor!= vertex and neighbor!= parent:\n                moves += weight\n                dfs(neighbor, vertex)\n        return moves\n\n    alice_moves = dfs(1, None)\n    bob_moves = dfs(x, None)\n\n    return str(alice_moves + bob_moves)\n"
    },
    {
        "number": 1949,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    min_non_zero = float('inf')\n    for i in range(k):\n        min_non_zero = min(min_non_zero, a[i])\n\n    for i in range(n):\n        if a[i]!= 0:\n            a[i] -= min_non_zero\n\n    if all(a[i] == 0 for i in range(n)):\n        print(0)\n    else:\n        print(*a)\n\n    return '\\n'.join(map(str, a))"
    },
    {
        "number": 1950,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def distribute_balls(boxes, balls, k):\n        for i in range(n):\n            if boxes[i] == 0:\n                boxes[i] = k\n                balls.extend(balls[:k])\n                balls = balls[k:]\n                break\n        return boxes\n\n    def min_penalty(boxes, balls):\n        penalty = 0\n        for i in range(n):\n            if boxes[i] == 0:\n                penalty += len(balls)\n        return penalty\n\n    boxes = [0] * n\n    balls = []\n    for i in range(n):\n        boxes[i] = 0\n        balls.extend(a[:a[i]])\n        a = a[a[i]:]\n\n    while len(balls) > 0:\n        k = 2\n        while k <= 3:\n            boxes = distribute_balls(boxes, balls, k)\n            k += 1\n\n        penalty = min_penalty(boxes, balls)\n        if penalty < 0:\n            return \"Impossible\"\n        else:\n            return str(penalty)"
    },
    {
        "number": 1951,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    events = []\n    for _ in range(n):\n        event = input()\n        if event == '+':\n            events.append(0)\n        elif event == '-':\n            events.append(-int(event[1:]))\n        else:\n            events.append(int(event))\n\n    def is_consistent(events):\n        seen = set()\n        for event in events:\n            if event in seen:\n                return False\n            seen.add(event)\n        return True\n\n    if is_consistent(events):\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 1952,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    testcases = []\n    for _ in range(n):\n        testcase = []\n        for _ in range(k):\n            testcase.append(int(input()))\n        testcases.append(testcase)\n\n    min_testcases = float('inf')\n    for i in range(n):\n        for j in range(k):\n            if len(set(testcases[i])) == 1:\n                min_testcases = min(min_testcases, len(testcases[i]))\n\n    return str(min_testcases)\n"
    },
    {
        "number": 1953,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = list(map(int, stdin.strip().split()))\n\n    max_not_disappointed = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if t[i] > t[j]:\n                max_not_disappointed += 1\n\n    return str(max_not_disappointed)"
    },
    {
        "number": 1954,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, f = map(int, stdin.split())\n    a = [0] * n\n    for i in range(n):\n        a[i] = i + 1\n\n    def partition(left, right):\n        pivot = a[right]\n        i = left - 1\n\n        for j in range(left, right):\n            if a[j] <= pivot:\n                i += 1\n                a[i], a[j] = a[j], a[i]\n\n        a[i + 1], a[right] = a[right], a[i + 1]\n        return i + 1\n\n    def count_ways(left, right):\n        if left == right:\n            return 1\n\n        if a[left] == a[right]:\n            return 0\n\n        if a[left] > a[right]:\n            return 0\n\n        return count_ways(left + 1, right) + count_ways(left, right - 1)\n\n    for _ in range(q):\n        left, right = map(int, stdin.split())\n        count = count_ways(0, n - 1)\n        print(count % (10**9 + 7))"
    },
    {
        "number": 1955,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    a = list(map(int, stdin.split()))\n\n    if n == 0 or m == 0:\n        return \"-1\"\n\n    if n == 1:\n        if d[0] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 2:\n        if d[0] == 0 and d[1] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 3:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 4:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 5:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 6:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 7:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 8:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0 and d[7] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 9:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0 and d[7] == 0 and d[8] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 10:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0 and d[7] == 0 and d[8] == 0 and d[9] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 11:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0 and d[7] == 0 and d[8] == 0 and d[9] == 0 and d[10] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 12:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0 and d[7] == 0 and d[8] == 0 and d[9] == 0 and d[10] == 0 and d[11] == 0:\n            return \"0\"\n        else:\n            return \"1\"\n\n    if n == 13:\n        if d[0] == 0 and d[1] == 0 and d[2] == 0 and d[3] == 0 and d[4] == 0 and d[5] == 0 and d[6] == 0 and d[7] == 0 and"
    },
    {
        "number": 1956,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    rounds = []\n    for _ in range(t):\n        s, e = map(int, stdin.readline().strip().split())\n        rounds.append((s, e))\n\n    def is_winner(s, e, rounds):\n        for i in range(len(rounds)):\n            if s <= rounds[i][0] <= e:\n                return True\n        return False\n\n    def is_loser(s, e, rounds):\n        for i in range(len(rounds)):\n            if s <= rounds[i][1] <= e:\n                return True\n        return False\n\n    for s, e in rounds:\n        if is_winner(s, e, rounds):\n            return \"1 1\"\n        elif is_loser(s, e, rounds):\n            return \"0 0\"\n\n    return \"0 1\""
    },
    {
        "number": 1957,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B = map(int, stdin.split())\n    s = list(map(int, stdin.split()))\n\n    # Find the number of holes that need to be blocked\n    num_holes = 0\n    for i in range(n):\n        if s[i] == 0:\n            num_holes += 1\n\n    # Calculate the minimum number of holes needed to make at least B liters of water flow out of the first hole\n    min_holes = n - num_holes\n    min_water = B / (s[0] * A)\n\n    # If there are no holes to block, return 0\n    if min_holes == 0:\n        return \"0\"\n\n    # If there is only one hole to block, return the minimum number of holes needed\n    if min_holes == 1:\n        return str(min_holes)\n\n    # If there are multiple holes to block, return the minimum number of holes needed\n    return str(min(min_holes, min_water))\n"
    },
    {
        "number": 1958,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    buyers = []\n    for _ in range(n):\n        buyers.append(stdin.strip())\n\n    total_money = 0\n    for buyer in buyers:\n        if buyer == 'half':\n            total_money += p\n        elif buyer == 'halfplus':\n            total_money += p + p // 2\n\n    return str(total_money)\n"
    },
    {
        "number": 1959,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n\n    # Count the number of even and odd integers on each card\n    even_count = [0] * n\n    odd_count = [0] * n\n    for card in cards:\n        if card % 2 == 0:\n            even_count[card // 2] += 1\n        else:\n            odd_count[card // 2] += 1\n\n    # Find the minimum number of exchanges\n    min_exchanges = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if even_count[i] == odd_count[j]:\n                min_exchanges = min(min_exchanges, i + 1)\n\n    # Determine the cards to exchange\n    exchanged_cards = []\n    for i in range(n):\n        if even_count[i] == odd_count[i]:\n            exchanged_cards.append(i)\n\n    # Print the result\n    print(min_exchanges)\n    print(*exchanged_cards)\n\n    return \"\""
    },
    {
        "number": 1960,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    groups = [[] for _ in range(n)]\n    for i in range(n):\n        groups[i % n].append(i)\n\n    result = \"\"\n    for i in range(n):\n        if len(groups[i]) == 1:\n            result += \"1\"\n        elif len(groups[i]) == 2:\n            result += \"2\"\n        elif len(groups[i]) == 3:\n            result += \"3\"\n        else:\n            result += \"3\"\n\n    return result"
    },
    {
        "number": 1961,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if stdin[i][j] == '#':\n                grid[i][j] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i + k) >= 0 and (i + k) < n and (j + l) >= 0 and (j + l) < m:\n                            if grid[i + k][j + l] == 0:\n                                grid[i + k][j + l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i - k) >= 0 and (i - k) < n and (j - l) >= 0 and (j - l) < m:\n                            if grid[i - k][j - l] == 0:\n                                grid[i - k][j - l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i + k) >= 0 and (i + k) < n and (j - l) >= 0 and (j - l) < m:\n                            if grid[i + k][j - l] == 0:\n                                grid[i + k][j - l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i - k) >= 0 and (i - k) < n and (j + l) >= 0 and (j + l) < m:\n                            if grid[i - k][j + l] == 0:\n                                grid[i - k][j + l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i + k) >= 0 and (i + k) < n and (j + l) >= 0 and (j + l) < m:\n                            if grid[i + k][j + l] == 0:\n                                grid[i + k][j + l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i - k) >= 0 and (i - k) < n and (j + l) >= 0 and (j + l) < m:\n                            if grid[i - k][j + l] == 0:\n                                grid[i - k][j + l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i + k) >= 0 and (i + k) < n and (j - l) >= 0 and (j - l) < m:\n                            if grid[i + k][j - l] == 0:\n                                grid[i + k][j - l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i - k) >= 0 and (i - k) < n and (j + l) >= 0 and (j + l) < m:\n                            if grid[i - k][j + l] == 0:\n                                grid[i - k][j + l] = 1\n                                break\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 1:\n                for k in range(3):\n                    for l in range(3):\n                        if (i + k) >= 0 and (i + k) < n and"
    },
    {
        "number": 1962,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    if n * k!= len(a):\n        return \"0\"\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(a[i] - a[j]) <= l:\n                max_sum += a[i] + a[j]\n\n    return str(max_sum)"
    },
    {
        "number": 1963,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Find the maximum value of r - l\n    max_r_minus_l = max(a[i] - a[i + 1] for i in range(n - 1))\n\n    # Find the required pairs\n    required_pairs = []\n    for i in range(n - 1):\n        for j in range(i + 2, n):\n            if a[i] % a[j] == 0 and a[i + 1] % a[j] == 0:\n                required_pairs.append((i, j))\n\n    # Sort the required pairs in increasing order\n    required_pairs.sort()\n\n    # Print the required pairs and the maximum value of r - l\n    print(len(required_pairs), max_r_minus_l)\n\n    # Print the required pairs\n    for pair in required_pairs:\n        print(pair[0], pair[1])\n\n    return \"\""
    },
    {
        "number": 1964,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    k = list(map(int, stdin.strip().split()))\n    m = list(map(int, stdin.strip().split()))\n\n    # Calculate the number of seconds required to get to each cashier\n    cashier_time = [5, 15]\n    cashiers = [i for i in range(1, n+1)]\n    cashiers.sort()\n    cashiers_time = [cashier_time[i-1] for i in cashiers]\n\n    # Calculate the number of seconds required to get to the first cashier\n    first_cashier_time = sum(cashiers_time[:1])\n    first_cashier_time += sum(cashiers_time[1:])\n\n    # Calculate the number of seconds required to get to the second cashier\n    second_cashier_time = sum(cashiers_time[:2])\n    second_cashier_time += sum(cashiers_time[2:])\n\n    # Calculate the number of seconds required to get to the third cashier\n    third_cashier_time = sum(cashiers_time[:3])\n    third_cashier_time += sum(cashiers_time[3:])\n\n    # Calculate the number of seconds required to get to the fourth cashier\n    fourth_cashier_time = sum(cashiers_time[:4])\n    fourth_cashier_time += sum(cashiers_time[4:])\n\n    # Calculate the minimum number of seconds required to get to the cashier\n    min_time = min(first_cashier_time, second_cashier_time, third_cashier_time, fourth_cashier_time)\n\n    return str(min_time)"
    },
    {
        "number": 1965,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        x = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        rating = [0] * n\n        for i in range(n):\n            rating[i] = a[i]\n        for i in range(n):\n            for j in range(i + 1, n):\n                if rating[i] == rating[j]:\n                    rating[i] += 1\n                    rating[j] -= 1\n        for i in range(n):\n            if rating[i] == x:\n                rating[i] = 0\n        print(rating.count(0))"
    },
    {
        "number": 1966,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    board = []\n    for _ in range(n):\n        board.append(list(map(int, stdin.readline().strip())))\n\n    min_squares = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 1:\n                for k in range(4):\n                    if board[i][j] == board[i][j + k] == board[i + k][j] == board[i][j + k + 1] == 1:\n                        if k < 3:\n                            if board[i][j] == board[i + k][j] == board[i + k][j + 1] == board[i + k + 1][j + 1]:\n                                min_squares = min(min_squares, k + 1)\n\n    return str(min_squares)\n"
    },
    {
        "number": 1967,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    result = \"\"\n    for i in range(h):\n        line = \"\"\n        for j in range(w):\n            if j % 2 == 0:\n                line += \"*\"\n            else:\n                line += \".\"\n        result += line + \"\\n\"\n    return result"
    },
    {
        "number": 1968,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, v = map(int, stdin.split())\n    sellers = []\n    for _ in range(n):\n        k, s = map(int, stdin.split())\n        sellers.append((k, s))\n\n    p = 0\n    for k, s in sellers:\n        if k > 1:\n            p += 1\n\n    q = []\n    for k, s in sellers:\n        if k > 1:\n            q.append(k)\n\n    q.sort()\n\n    return str(p) + \" \" + \" \".join(map(str, q))\n"
    },
    {
        "number": 1969,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    M = []\n    for _ in range(n):\n        M.append(list(stdin.strip()))\n\n    crosses = 0\n    for i in range(n):\n        for j in range(n):\n            if M[i][j] == 'X' and (i == 0 or M[i - 1][j] == 'X') and (i == n - 1 or M[i + 1][j] == 'X') and (j == 0 or M[i][j - 1] == 'X') and (j == n - 1 or M[i][j + 1] == 'X'):\n                crosses += 1\n\n    return str(crosses)"
    },
    {
        "number": 1970,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    boards = []\n    for _ in range(n):\n        board = []\n        for _ in range(8):\n            board.append(input())\n        boards.append(board)\n\n    for i in range(n):\n        for j in range(8):\n            if boards[i][j] == \"K\":\n                for k in range(i+1, n):\n                    if boards[k][j] == \"K\":\n                        return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 1971,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return str(p[0])\n\n    q = [p[i] for i in range(n)]\n    p_squared = [p[i] ** 2 for i in range(n)]\n\n    for i in range(n):\n        if p_squared[i] == q[i]:\n            return str(p[i])\n\n    return \"-1\""
    },
    {
        "number": 1972,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    for _ in range(q):\n        t, x, y = map(int, stdin.readline().split())\n        if t == 1:\n            a[x] += y\n        elif t == 2:\n            a[x] += sum(a[i] for i in R(x, y))\n    return str(a[1])\n\ndef"
    },
    {
        "number": 1973,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    u = list(map(int, stdin.strip().split()))\n    x = 0\n    for i in range(n):\n        x = max(x, len(u) - i)\n    return str(x)"
    },
    {
        "number": 1974,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    robbers = []\n    searchlights = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        robbers.append((a, b))\n\n    for _ in range(m):\n        c, d = map(int, stdin.split())\n        searchlights.append((c, d))\n\n    moves = 0\n    safe = True\n\n    for i in range(n):\n        for j in range(m):\n            if searchlights[j][0] <= robbers[i][0] <= searchlights[j][1] and searchlights[j][2] <= robbers[i][1] <= searchlights[j][3]:\n                safe = False\n                break\n\n    if safe:\n        moves = 3\n    else:\n        moves = 1\n\n    return str(moves)"
    },
    {
        "number": 1975,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    k = 0\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if i == 1 and j == 1:\n                k += 1\n            elif i == 1 and j == m:\n                k += 1\n            elif i == n and j == 1:\n                k += 1\n            elif i == n and j == m:\n                k += 1\n            elif i == 1 and j == 1 or i == n and j == 1 or i == 1 and j == m or i == n and j == m:\n                k += 1\n    return str(k)"
    },
    {
        "number": 1976,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, q = map(int, stdin.split())\n    broken_pixels = []\n    for _ in range(q):\n        x, y, t = map(int, stdin.split())\n        broken_pixels.append((x, y, t))\n\n    broken_pixels.sort(key=lambda x: x[2])\n\n    min_moment = -1\n    for moment in range(1, n * m + 1):\n        for i in range(n):\n            for j in range(m):\n                if moment - broken_pixels[i * m + j][2] >= k:\n                    min_moment = min(min_moment, moment - broken_pixels[i * m + j][2])\n\n    return str(min_moment)"
    },
    {
        "number": 1977,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(stdin.strip()))\n\n    def dfs(row, col, path):\n        if len(path) == k:\n            return True\n\n        for i in range(row - 1, -1, -1):\n            for j in range(col - 1, -1, -1):\n                if matrix[i][j] == 'a':\n                    matrix[i][j] = 'b'\n                    if dfs(i, j, path + 'a'):\n                        return True\n                    matrix[i][j] = 'a'\n\n        return False\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 'a':\n                if dfs(i, j, ''):\n                    return ''.join(matrix[i])\n\n    return ''"
    },
    {
        "number": 1978,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    graph = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_good_subsequence(p, v):\n        return p == v[1:-1]\n\n    def shortest_good_subsequence(p):\n        good_subsequences = []\n        for i in range(m):\n            for j in range(i + 1, m):\n                if is_good_subsequence(p, graph[i]) and is_good_subsequence(p, graph[j]):\n                    good_subsequences.append(p)\n        return good_subsequences\n\n    def shortest_good_subsequences(p):\n        good_subsequences = []\n        for i in range(m):\n            for j in range(i + 1, m):\n                if is_good_subsequence(p, graph[i]) and is_good_subsequence(p, graph[j]):\n                    good_subsequences.append(p)\n        return good_subsequences\n\n    def output_shortest_good_subsequences(good_subsequences):\n        for subsequence in good_subsequences:\n            print(subsequence)\n\n    shortest_good_subsequences(p)\n    return \"\""
    },
    {
        "number": 1979,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    def decode(a, b):\n        result = []\n        for i in range(n):\n            result.append(a[i] + b[i])\n        return result\n\n    def match_pairs(a, b):\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] == b[j]:\n                    count += 1\n        return count\n\n    def max_matching_pairs(a, b):\n        max_count = 0\n        for k in range(1, n + 1):\n            decoded_a = decode(a, b)\n            decoded_b = decode(decoded_a, b)\n            max_count = max(max_count, match_pairs(decoded_a, decoded_b))\n        return max_count\n\n    max_matching_pairs(a, b)\n    return str(max_matching_pairs(a, b))\n"
    },
    {
        "number": 1980,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    burles = [0] * n\n    for i in range(n):\n        burles[i] = a\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            burles[j] = max(burles[j], burles[i] + burles[j + 1])\n\n    return str(max(burles))\n"
    },
    {
        "number": 1981,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(vertex, visited, path, cat_count):\n        if vertex == 1:\n            return cat_count\n\n        if vertex in visited:\n            return visited[vertex]\n\n        visited[vertex] = True\n        cat_count += 1\n\n        for neighbor in edges[vertex - 1]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path + [neighbor], cat_count)\n\n        return visited[vertex]\n\n    visited = [False] * (n + 1)\n    cat_count = 0\n    for vertex in range(1, n + 1):\n        if not visited[vertex]:\n            dfs(vertex, visited, [], cat_count)\n\n    return str(cat_count)"
    },
    {
        "number": 1982,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    odd_count = 0\n    for i in range(1, n+1):\n        if i % 2 == 1:\n            odd_count += 1\n            if odd_count == k:\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 1983,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    a.sort()\n    max_length = 1\n    current_length = 1\n    for i in range(1, n):\n        if a[i] > a[i-1]:\n            current_length += 1\n        else:\n            current_length = 1\n        max_length = max(max_length, current_length)\n    return str(max_length)"
    },
    {
        "number": 1984,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, w = map(int, stdin.split())\n    levels = []\n    for _ in range(k):\n        level = []\n        for _ in range(m):\n            level.append(input())\n        levels.append(level)\n\n    min_transferred_bytes = n * m * k * w\n    transferred_bytes = 0\n\n    for i in range(k):\n        for j in range(m):\n            for l in range(n):\n                for m in range(m):\n                    if levels[i][l] == levels[i][m]:\n                        transferred_bytes += 1\n                        if l > 0 and levels[i][l - 1] == levels[i][m]:\n                            transferred_bytes += w\n                        if l < n - 1 and levels[i][l + 1] == levels[i][m]:\n                            transferred_bytes += w\n\n    return str(min_transferred_bytes - transferred_bytes)\n"
    },
    {
        "number": 1985,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the number of options for the score the participant could have\n    options = 0\n    for i in range(k):\n        points = sum(a[i:]) - sum(b[i:])\n        options += points\n\n    return str(options)"
    },
    {
        "number": 1986,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    restaurants = []\n    for _ in range(n):\n        f, t = map(int, stdin.split())\n        restaurants.append((f, t))\n\n    max_joy = -1\n    for f, t in restaurants:\n        if t <= k:\n            max_joy = max(max_joy, f - (t - k))\n        else:\n            max_joy = max(max_joy, f)\n\n    return str(max_joy)"
    },
    {
        "number": 1987,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c_1, c_2 = map(int, stdin.split())\n    tickets = [int(input()) for _ in range(n)]\n    adults = [0] * n\n    for i in range(n):\n        if tickets[i] == 1:\n            adults[i] = 1\n\n    total_price = 0\n    for i in range(n):\n        if adults[i] == 1:\n            total_price += c_1\n        else:\n            total_price += c_1 + c_2 * (i - 1) ** 2\n\n    return str(total_price)\n"
    },
    {
        "number": 1988,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        s = stdin.strip()\n        k = int(stdin.strip())\n        if k > n:\n            k = n\n        s = s[::-1]\n        for i in range(n-k+1):\n            s = s[i:i+k-1]\n        s = ''.join(sorted(s))\n        print(s)\n        print(k)"
    },
    {
        "number": 1989,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 1990,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    commands = []\n    for _ in range(n):\n        command = input().strip()\n        commands.append(command)\n\n    def is_valid_text(line):\n        stack = []\n        for char in line:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop()!= '(':\n                    return False\n        return not stack\n\n    def get_least_colors(line):\n        stack = []\n        colors = 0\n        for char in line:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop()!= '(':\n                    colors += 1\n        return colors\n\n    correct_texts = [\n        'hello(codeforces)',\n        'round',\n        '((i)(write))edi(tor)s',\n       'me',\n    ]\n\n    for command in commands:\n        if command == 'L':\n            if is_valid_text(commands[0]):\n                commands[0] = commands[0][:commands[0].index(')') + 1] + ')'\n            else:\n                commands[0] = commands[0][:commands[0].index(')') + 1] + ')' + commands[0][commands[0].index(')') + 1:]\n        elif command == 'R':\n            if is_valid_text(commands[0]):\n                commands[0] = commands[0][:commands[0].index(')') + 1] + ')'\n            else:\n                commands[0] = commands[0][:commands[0].index(')') + 1] + ')' + commands[0][commands[0].index(')') + 1:]\n        elif command == '(':\n            commands[0] += command\n        elif command == ')':\n            if is_valid_text(commands[0]):\n                commands[0] = commands[0][:commands[0].index(')') + 1] + ')'\n            else:\n                commands[0] = commands[0][:commands[0].index(')') + 1] + ')' + commands[0][commands[0].index(')') + 1:]\n\n    for correct_text in correct_texts:\n        if is_valid_text(correct_text):\n            print(get_least_colors(correct_text))\n            return\n\n    return '-1'"
    },
    {
        "number": 1991,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    a.sort()\n    special_exchange = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                special_exchange.append((i, j))\n                break\n    return str(len(special_exchange))"
    },
    {
        "number": 1992,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Sort the applications based on their order in the menu\n    a.sort()\n    b.sort()\n\n    # Initialize the gestures count\n    gestures = 0\n\n    # Iterate through the applications in the desired order\n    for i in range(n):\n        # If the application is not launched, skip it\n        if a[i] == 0:\n            continue\n\n        # If the application is launched, make the required gestures\n        if i < k:\n            # Scroll to the required screen number\n            gestures += 1\n            gestures += i - 1\n            gestures += 1\n\n            # Launch the application with the icon located on the screen t\n            gestures += 1\n            gestures += a[i] - 1\n            gestures += 1\n\n        # If the application is launched, make the required gestures\n        if i >= k:\n            # Scroll to the required screen number\n            gestures += 1\n            gestures += i - k\n            gestures += 1\n\n            # Launch the application with the icon located on the screen t\n            gestures += 1\n            gestures += b[i - k] - 1\n            gestures += 1\n\n    return str(gestures)"
    },
    {
        "number": 1993,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = [input() for _ in range(n)]\n    result = []\n    for i in range(n):\n        row = [matrix[i][j] for j in range(m)]\n        if i == 0:\n            result.append(row)\n        else:\n            result.append(row[1:] + [\".\"] + row[1:])\n    for i in range(n):\n        result[i] = \"\".join(result[i])\n    return \"\".join(result)"
    },
    {
        "number": 1994,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n    prefixes = []\n    suffixes = []\n\n    for i in range(n):\n        prefix = s[:i+1]\n        suffix = s[i+1:]\n        prefixes.append(prefix)\n        suffixes.append(suffix)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            substring = s[i:j+1]\n            if substring in suffixes:\n                count += 1\n\n    return str(count) + '\\n' + '\\n'.join([str(l) +'' + str(c) for l, c in zip(prefixes, count)])"
    },
    {
        "number": 1995,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    m = int(stdin.readline().strip())\n    queries = []\n    for _ in range(m):\n        l, r, k = map(int, stdin.readline().strip().split())\n        queries.append((l, r, k))\n\n    def process_query(query):\n        l, r, k = query\n        result = \"\"\n        for i in range(l, r + 1):\n            result += s[i]\n        result += s[l] * k\n        return result\n\n    result = \"\"\n    for query in queries:\n        result += process_query(query)\n\n    return result"
    },
    {
        "number": 1996,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    excessive_electric_shocks = 0\n    for _ in range(n):\n        action = stdin.strip()\n        if action.startswith(\"?\"):\n            guess = action[1:]\n            if guess in \"abc\":\n                excessive_electric_shocks += 1\n        elif action.startswith(\".\"):\n            word = action[1:]\n            if word in \"abc\":\n                excessive_electric_shocks += 1\n    return str(excessive_electric_shocks)"
    },
    {
        "number": 1997,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(node, parent):\n        if node == 1:\n            return 0\n\n        if node in parent:\n            return parent[node]\n\n        parent[node] = dfs(parent[node], node)\n        return parent[node]\n\n    def max_result(node, parent):\n        if node == 1:\n            return 0\n\n        if node in parent:\n            return max(parent[node], max_result(parent[node], node))\n\n        parent[node] = max_result(parent[node], node)\n        return parent[node]\n\n    def min_result(node, parent):\n        if node == 1:\n            return 0\n\n        if node in parent:\n            return min(parent[node], min_result(parent[node], node))\n\n        parent[node] = min_result(parent[node], node)\n        return parent[node]\n\n    for u, v in edges:\n        dfs(u, {})\n        dfs(v, {})\n\n    max_result = max_result(1, {})\n    min_result = min_result(1, {})\n\n    return str(max_result) + \" \" + str(min_result)\n"
    },
    {
        "number": 1998,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split())\n    shots = list(map(int, stdin.split()))\n\n    # Calculate the number of cells such that if Galya shoots at all of them, she would hit at least one ship\n    num_cells = 0\n    for i in range(1, n):\n        if shots[i] == 1:\n            num_cells += i\n\n    return str(num_cells)\n"
    },
    {
        "number": 1999,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Count the occurrences of 2 or more times\n    count = 0\n    for i in range(n):\n        if a[i] == a[i+1]:\n            count += 1\n\n    # Choose the smallest value that occurs in the array 2 or more times\n    x = min(a[i] for i in range(n) if a[i] == a[i+1])\n\n    # Perform the operations\n    for i in range(n-2, -1, -1):\n        if a[i] == x:\n            a[i] = 2 * x\n            a[i+1] = a[i]\n            a.pop(i+2)\n            count -= 1\n\n    # Print the result\n    print(count)\n    print(*a)\n\n    return \"\""
    },
    {
        "number": 2000,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j] == 2**i:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2001,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    parts = list(map(int, stdin.split()))\n    max_enjoyment = 0\n    for i in range(n):\n        max_enjoyment += parts[i]\n    for _ in range(q):\n        l, r = map(int, stdin.split())\n        max_enjoyment = max(max_enjoyment, sum(parts[l:r+1]) % (10**9 + 7))\n    return str(max_enjoyment)"
    },
    {
        "number": 2002,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def sum_beauties(u, v):\n        beauties = [gcd(x_u, x_v) for x_u, x_v in edges if x_u!= v and x_v!= u]\n        return sum(beauties)\n\n    result = sum(sum_beauties(1, v) for v in range(1, n))\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 2003,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    A = set()\n    for _ in range(q):\n        query = stdin.readline().strip()\n        if query == '+':\n            A.add(int(stdin.readline()))\n        elif query == '-':\n            A.remove(int(stdin.readline()))\n        elif query == '?':\n            x = int(stdin.readline())\n            max_xor = 0\n            for y in A:\n                max_xor = max(max_xor, x ^ y)\n            print(max_xor)\n    return ''"
    },
    {
        "number": 2004,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    m = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if i == 1 or i == n or j == 1 or j == n:\n                m += 1\n    return str(m) + '\\n' + str(m) +'' +''.join(map(str, range(m)))"
    },
    {
        "number": 2005,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, n_1, n_2 = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the arithmetic mean of wealth of people in each city\n    a_1 = sum(a[:n_1]) / n_1\n    a_2 = sum(a[n_1:n_1+n_2]) / n_2\n\n    # Calculate the maximum possible sum of arithmetic means of wealth of cities' residents\n    max_sum = max(a_1, a_2)\n\n    return str(max_sum)"
    },
    {
        "number": 2006,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    game_field = []\n    for _ in range(n):\n        game_field.append(list(stdin.strip()))\n\n    moves = 0\n    for i in range(n):\n        for j in range(m):\n            if game_field[i][j] == 'G':\n                moves += 1\n                for k in range(i + 1, n):\n                    if game_field[k][j] == 'S':\n                        game_field[i][j] = 'G'\n                        game_field[k][j] = 'S'\n                        moves += 1\n                        break\n                for k in range(j + 1, m):\n                    if game_field[i][k] == 'S':\n                        game_field[i][j] = 'G'\n                        game_field[i][k] = 'S'\n                        moves += 1\n                        break\n\n    if moves == 0:\n        return '-1'\n    else:\n        return str(moves)"
    },
    {
        "number": 2007,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    letters = set(stdin.strip().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        graph[x-1].append(y-1)\n        graph[y-1].append(x-1)\n\n    max_value = float('-inf')\n    max_path = None\n\n    for i in range(n):\n        if len(graph[i]) > 0:\n            path = []\n            path.append(i)\n            letter_count = {}\n            letter_count[i] = 1\n\n            for j in graph[i]:\n                if j in letter_count:\n                    letter_count[j] += 1\n                else:\n                    letter_count[j] = 1\n\n            max_count = max(letter_count.values())\n            for j in letter_count:\n                if letter_count[j] == max_count:\n                    path.append(j)\n\n            if max_count > max_value:\n                max_value = max_count\n                max_path = path\n\n    if max_value == float('-inf'):\n        return '-1'\n    else:\n        return str(max_value)"
    },
    {
        "number": 2008,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    dissatisfaction = 0\n    for i in range(n):\n        a_i, b_i = map(int, stdin.strip().split())\n        dissatisfaction += a_i * (n - i) + b_i * (i - 1)\n    return str(dissatisfaction)"
    },
    {
        "number": 2009,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    r1, c1 = map(int, stdin.strip().split())\n    r2, c2 = map(int, stdin.strip().split())\n\n    def is_valid(r: int, c: int) -> bool:\n        return 1 <= r <= n and 1 <= c <= n\n\n    def cost(r: int, c: int) -> int:\n        return (r - r2) ** 2 + (c - c2) ** 2\n\n    def min_cost(r1: int, c1: int, r2: int, c2: int) -> int:\n        if not is_valid(r1, c1) or not is_valid(r2, c2):\n            return 0\n\n        if r1 == r2 and c1 == c2:\n            return 0\n\n        if r1 == r2:\n            return min_cost(r1, c1, r2, c2 - 1) + cost(r1, c1)\n        elif c1 == c2:\n            return min_cost(r1, c1, r2 - 1, c2) + cost(r1, c1)\n        else:\n            return min(min_cost(r1, c1, r2, c2), min_cost(r1, c1 - 1, r2, c2)) + cost(r1, c1)\n\n    return str(min_cost(r1, c1, r2, c2))\n"
    },
    {
        "number": 2010,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    for _ in range(m):\n        t = int(stdin.split())\n        if t == 1:\n            v, x = map(int, stdin.split())\n            a[v - 1] = x\n        elif t == 2:\n            y = int(stdin.split())\n            for i in range(n):\n                a[i] += y\n        elif t == 3:\n            q = int(stdin.split())\n            for i in range(n):\n                a[q - 1] = a[i]\n\n    result = []\n    for i in range(n):\n        result.append(a[i])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2011,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    debts = [0] * (n + 1)\n    for _ in range(m):\n        u, v, d = map(int, stdin.split())\n        debts[u] += d\n        debts[v] -= d\n    max_debts = max(debts)\n    result = []\n    for i in range(1, n + 1):\n        if debts[i] > 0:\n            result.append(i)\n            for j in range(i + 1, n + 1):\n                if debts[j] > 0:\n                    if debts[i] + debts[j] <= max_debts:\n                        result.append(j)\n                        debts[i] -= debts[j]\n                        debts[j] = 0\n                        break\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2012,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    c = list(map(int, stdin.split()[1:]))\n    s = \"tttesst\"\n    result = \"\"\n    for i in range(n):\n        count = 0\n        for j in range(i, n):\n            if s[i:j+1] == s[i:j+1][::-1]:\n                count += 1\n        result += str(count) + \" \"\n    return result.strip()"
    },
    {
        "number": 2013,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    sx = list(map(int, stdin.split()))\n    fx = list(map(int, stdin.split()))\n\n    # Initialize the visited positions\n    visited = [[False] * m for _ in range(n)]\n\n    # Initialize the sequence of operations\n    sequence = []\n\n    # Iterate over the chips\n    for i in range(k):\n        # Get the chip's position\n        x, y = sx[i]\n\n        # Check if the chip is already visited\n        if visited[x][y]:\n            continue\n\n        # Check if the chip can be moved to the left\n        if x > 0 and not visited[x - 1][y]:\n            sequence.append(\"L\")\n            visited[x - 1][y] = True\n\n        # Check if the chip can be moved to the right\n        if x < n - 1 and not visited[x + 1][y]:\n            sequence.append(\"R\")\n            visited[x + 1][y] = True\n\n        # Check if the chip can be moved down\n        if y > 0 and not visited[x][y - 1]:\n            sequence.append(\"D\")\n            visited[x][y - 1] = True\n\n        # Check if the chip can be moved up\n        if y < m - 1 and not visited[x][y + 1]:\n            sequence.append(\"U\")\n            visited[x][y + 1] = True\n\n    # Check if the required sequence exists\n    if len(sequence) == 0:\n        return -1\n\n    # Print the sequence of operations\n    print(\"\".join(sequence))\n\n    return len(sequence)\n"
    },
    {
        "number": 2014,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    permutations = []\n    for _ in range(k):\n        permutation = list(map(int, input().split()))\n        permutations.append(permutation)\n\n    def lcs(a, b):\n        if len(a) > len(b):\n            return lcs(b, a)\n\n        if len(a) == 0:\n            return b\n\n        if a[0] == b[0]:\n            return lcs(a[1:], b[1:])\n\n        if a[0] < b[0]:\n            return lcs(a[1:], b)\n\n        return lcs(a, b[1:])\n\n    longest_common_subsequence = lcs(permutations, permutations[0])\n    return str(len(longest_common_subsequence))\n"
    },
    {
        "number": 2015,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        r, g, b = map(int, stdin.readline().strip().split())\n        result.append(build_garland(r, g, b))\n\n    return '\\n'.join(result)\n\n\ndef"
    },
    {
        "number": 2016,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, m = map(int, stdin.split())\n    spells = []\n    for _ in range(q):\n        x, y = map(int, stdin.split())\n        spells.append((x, y))\n\n    def can_win(x, y, t, h):\n        for i, (dx, dy) in enumerate(spells):\n            if i == 0:\n                continue\n            if x + dx >= 1000000000 or x + dx < -1000000000 or y + dy >= 1000000000 or y + dy < -1000000000:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000000000!= y:\n                continue\n            if x + dx % 1000000000!= x or y + dy % 1000"
    },
    {
        "number": 2017,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = [int(x) for x in stdin.readline().strip().split()]\n    inversions = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if p[i] > p[j]:\n                inversions += 1\n                p[i], p[j] = p[j], p[i]\n    return str(inversions)"
    },
    {
        "number": 2018,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    questions = []\n    for _ in range(q):\n        s_x, s_y, e_x, e_y = map(int, stdin.split())\n        questions.append((s_x, s_y, e_x, e_y))\n\n    def can_move(s_x, s_y, e_x, e_y):\n        if s_x == 1:\n            return s_y <= n\n        else:\n            return s_y <= m\n\n    for s_x, s_y, e_x, e_y in questions:\n        if can_move(s_x, s_y, e_x, e_y):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\n    return \"\""
    },
    {
        "number": 2019,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        s = input().strip()\n        alice_move = s[0]\n        bob_move = s[1]\n        alice_move_count = 0\n        bob_move_count = 0\n        for i in range(len(s)):\n            if s[i] == alice_move:\n                alice_move_count += 1\n            elif s[i] == bob_move:\n                bob_move_count += 1\n        if alice_move_count == 0 and bob_move_count == 0:\n            print(\"DA\")\n        else:\n            print(\"NET\")"
    },
    {
        "number": 2020,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    clocks = []\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        clocks.append((x, y))\n\n    def is_valid(x1, y1, x2, y2):\n        return 0 <= x1 <= 100 and 0 <= y1 <= 100 and 0 <= x2 <= 100 and 0 <= y2 <= 100\n\n    def is_valid_segment(x1, y1, x2, y2):\n        return 0 <= x1 <= 100 and 0 <= y1 <= 100 and 0 <= x2 <= 100 and 0 <= y2 <= 100\n\n    def count_segments(x1, y1, x2, y2):\n        count = 0\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x1 + dx, y1 + dy\n            if is_valid_segment(nx, ny, x2, y2):\n                count += 1\n        return count\n\n    def count_segments_with_type(x1, y1, x2, y2, type_):\n        count = 0\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x1 + dx, y1 + dy\n            if is_valid_segment(nx, ny, x2, y2) and type_ == \"horizontal\":\n                count += 1\n            elif type_ == \"vertical\":\n                count += 1\n        return count\n\n    def count_segments_with_type_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type(x1, y1, x2, y2, type_)\n        return count\n\n    def count_segments_with_type_and_count_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type_and_count(x1, y1, x2, y2, type_, count)\n        return count\n\n    def count_segments_with_type_and_count_and_count_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type_and_count_and_count(x1, y1, x2, y2, type_, count)\n        return count\n\n    def count_segments_with_type_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type_and_count_and_count_and_count(x1, y1, x2, y2, type_, count)\n        return count\n\n    def count_segments_with_type_and_count_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count)\n        return count\n\n    def count_segments_with_type_and_count_and_count_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type_and_count_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count)\n        return count\n\n    def count_segments_with_type_and_count_and_count_and_count_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count):\n        count += count_segments_with_type_and_count_and_count_and_count_and_count_and_count_and_count(x1, y1, x2, y2, type_, count)\n        return count\n\n    def count_segments_with_type_and_count_and_count_and_count_and_count_and_count_and_count_and_count_and_count(x1, y1,"
    },
    {
        "number": 2021,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, m = map(int, stdin.split())\n    coupons = list(map(int, stdin.split()))\n    total_amount = sum(a * coupons[i] for i in range(m))\n    min_amount = float('inf')\n    for i in range(m):\n        for j in range(i + 1, m + 1):\n            if j > i:\n                min_amount = min(min_amount, total_amount - a * coupons[i] - a * coupons[j])\n    return str(min_amount)"
    },
    {
        "number": 2022,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited)\n\n    if k % 2 == 0:\n        return str(k // 2) + \" \" + \" \".join(map(str, set(range(n)) - set(graph[u])) for u in range(n))\n    else:\n        cycle = []\n        for u in range(n):\n            if not visited[u]:\n                cycle.append(u)\n                break\n        cycle.reverse()\n        return str(len(cycle)) + \" \" + \" \".join(map(str, cycle))"
    },
    {
        "number": 2023,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    queries = []\n    for _ in range(m):\n        t, x, y, k = map(int, stdin.split())\n        queries.append((t, x, y, k))\n\n    result = []\n    for t, x, y, k in queries:\n        if t == 1:\n            result.append(a[x:x+k])\n        elif t == 2:\n            result.append(b[y])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2024,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    emotional_orders = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] >= a[j] and a[i] >= 2 * a[j]:\n                emotional_orders += 1\n\n    return str(emotional_orders % 998244353)"
    },
    {
        "number": 2025,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    queries = []\n    for _ in range(n):\n        queries.append(int(stdin.readline()))\n\n    max_sum = -1\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if queries[i] + queries[j] <= 10**9:\n                max_sum = max(max_sum, queries[i] + queries[j])\n\n    return str(max_sum) if max_sum!= -1 else \"-1\""
    },
    {
        "number": 2026,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sequence = []\n    for _ in range(n):\n        direction = input().strip()\n        if direction == 'L':\n            sequence.append('L')\n        elif direction == 'R':\n            sequence.append('R')\n        elif direction == 'U':\n            sequence.append('U')\n        elif direction == 'D':\n            sequence.append('D')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence.append('L')\n    sequence"
    },
    {
        "number": 2027,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = [0] * n\n    for i in range(n):\n        b[i] = a[i]\n    for i in range(n - 1):\n        b[i] += a[i + 1] - a[i] + 1\n    return''.join(map(str, b))"
    },
    {
        "number": 2028,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    assignments = []\n    for _ in range(n):\n        current_desk, target_desk = map(int, stdin.strip().split())\n        assignments.append((current_desk, target_desk))\n    assignments.sort(key=lambda x: x[0])\n    result = 1\n    for i in range(1, len(assignments)):\n        if assignments[i][0] == assignments[i - 1][0]:\n            result = (result + 1) % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 2029,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    tree = [[] for _ in range(n)]\n    for a, b in edges:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    def dfs(u, path, weight):\n        if len(path) == len(tree[u]):\n            return weight\n\n        for v in tree[u]:\n            if v not in path:\n                weight += dfs(v, path + [v], weight)\n\n        return weight\n\n    diameter = max(dfs(0, [], 0))\n    return str(diameter)\n"
    },
    {
        "number": 2030,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    a = list(map(float, stdin.split()[1].split()))\n    b = list(map(float, stdin.split()[2].split()))\n\n    # Calculate probability distribution for max(a, b)\n    max_prob = sum(a) / n\n    max_prob = max(max_prob, sum(b))\n    max_prob = max_prob / n\n\n    # Calculate probability distribution for min(a, b)\n    min_prob = sum(a) / n\n    min_prob = min(min_prob, sum(b))\n    min_prob = min_prob / n\n\n    # Check if probability distributions are valid\n    if abs(max_prob - min_prob) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_prob / 2\n\n    # Check if probability distributions are valid\n    if abs(max_min_prob - 1) > 10**-6:\n        return \"Invalid probability distributions\"\n\n    # Calculate probability distribution for max(a, b) and min(a, b)\n    max_min_prob = max_prob + min_prob\n    max_min_prob = max_min_"
    },
    {
        "number": 2031,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    requests = []\n    for _ in range(m):\n        k, pos = map(int, stdin.split())\n        requests.append((k, pos))\n\n    def max_sum(subseq):\n        return sum(subseq)\n\n    def is_optimal(subseq, k):\n        return len(subseq) == k and max_sum(subseq) == max_sum(subseq[:k])\n\n    def is_lexicographically_minimal(subseq, k):\n        return all(subseq[i] < subseq[i + 1] for i in range(len(subseq) - k + 1))\n\n    optimal_subsequences = []\n    for k in range(1, n + 1):\n        for pos in range(n):\n            subseq = a[pos:pos + k]\n            if is_optimal(subseq, k):\n                optimal_subsequences.append(subseq)\n\n    for k, pos in requests:\n        if is_lexicographically_minimal(optimal_subsequences[k - 1], k):\n            print(optimal_subsequences[k - 1][pos])\n        else:\n            print(-1)"
    },
    {
        "number": 2032,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    castles = [list(map(int, stdin.split())) for _ in range(n)]\n    portals = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def capture_castle(castle, warriors):\n        for i in range(castle[0], castle[1] + 1):\n            warriors[i] -= 1\n            if warriors[i] == 0:\n                return i\n\n    def hire_warriors(castle, warriors):\n        for i in range(castle[0], castle[1] + 1):\n            warriors[i] += 1\n\n    def defend_castle(castle, warriors):\n        for i in range(castle[0], castle[1] + 1):\n            warriors[i] -= 1\n            if warriors[i] == 0:\n                return i\n\n    def max_score(castle, warriors):\n        score = 0\n        for i in range(castle[0], castle[1] + 1):\n            score += warriors[i]\n        return score\n\n    def optimal_strategy(castle, warriors):\n        capture_castle_score = capture_castle(castle, warriors)\n        hire_warriors_score = hire_warriors(castle, warriors)\n        defend_castle_score = defend_castle(castle, warriors)\n        max_score_castle = max_score(castle, warriors)\n\n        if capture_castle_score == -1:\n            return -1\n\n        if capture_castle_score == 0:\n            return 0\n\n        if capture_castle_score == 1:\n            return capture_castle_score\n\n        if capture_castle_score == 2:\n            return capture_castle_score + hire_warriors_score\n\n        if capture_castle_score == 3:\n            return capture_castle_score + hire_warriors_score + defend_castle_score\n\n        if capture_castle_score == 4:\n            return capture_castle_score + hire_warriors_score + defend_castle_score + max_score_castle\n\n        return -1\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= castle[1]:\n                castle[0] = portal[1] + 1\n                break\n\n    for castle in castles:\n        for portal in portals:\n            if castle[0] <= portal[1] <= cast"
    },
    {
        "number": 2033,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        roads.append((u, v))\n\n    k = int(stdin.split()[0])\n    path = list(map(int, stdin.split()))\n\n    visited = set()\n    min_rebuilds = float('inf')\n    max_rebuilds = 0\n\n    def dfs(u, path, visited):\n        if u in visited:\n            return\n\n        visited.add(u)\n        path.append(u)\n        min_rebuilds = min(min_rebuilds, len(path))\n\n        for v in roads[u - 1]:\n            if v not in visited:\n                dfs(v, path, visited)\n\n        path.pop()\n        max_rebuilds = max(max_rebuilds, len(path))\n\n    dfs(1, path, set())\n\n    return str(min_rebuilds) +'' + str(max_rebuilds)"
    },
    {
        "number": 2034,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        roads.append((x, y))\n\n    def is_valid(x1, y1, x2, y2):\n        return x1!= y2 and x2!= y1\n\n    def is_valid_road(road):\n        x1, y1 = road\n        x2, y2 = roads[road[1]]\n        return is_valid(x1, y1, x2, y2)\n\n    def is_valid_city(city):\n        return all(road[1] == city for road in roads)\n\n    def is_valid_city_pair(x1, y1, x2, y2):\n        return is_valid_city(x1) and is_valid_city(x2) and not is_valid_road((x1, y1)) and not is_valid_road((x2, y2))\n\n    def count_separated_cities(x1, y1, x2, y2):\n        count = 0\n        for i in range(m):\n            if is_valid_city_pair(x1, y1, roads[i][0], roads[i][1]):\n                count += 1\n        return count\n\n    def count_separated_cities_helper(x1, y1, x2, y2):\n        if x1 == x2 and y1 == y2:\n            return 0\n        if is_valid_city_pair(x1, y1, x2, y2):\n            return 1 + count_separated_cities_helper(x1, y1, roads[x1][0], roads[x1][1]) + count_separated_cities_helper(x2, y2, roads[x2][0], roads[x2][1])\n        return 0\n\n    return str(count_separated_cities_helper(1, 1, n, n))"
    },
    {
        "number": 2035,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s_x, s_y = map(int, stdin.split())\n    houses = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        houses.append((x, y))\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def shortest_path(house, x, y):\n        visited = set()\n        queue = [(0, house)]\n        while queue:\n            dist, house = queue.pop(0)\n            if house == (s_x, s_y):\n                return dist\n            visited.add(house)\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                nx, ny = house[0] + dx, house[1] + dy\n                if (nx, ny) not in visited and (nx, ny)!= house:\n                    queue.append((dist + 1, (nx, ny)))\n\n    def max_students_buying_shawarma(houses):\n        students = set()\n        for house in houses:\n            students.add(house)\n        max_students = 0\n        for house in houses:\n            for i in range(n):\n                if i!= house[0] and i!= house[1]:\n                    if shortest_path(house, i, house[1]) < shortest_path(house, house[0], i):\n                        max_students += 1\n        return max_students\n\n    max_students = max_students_buying_shawarma(houses)\n    p_x, p_y = 0, 0\n    for house in houses:\n        if house[0] < p_x:\n            p_x = house[0]\n        if house[1] < p_y:\n            p_y = house[1]\n    return f\"{max_students}\\n{p_x} {p_y}\""
    },
    {
        "number": 2036,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    S_x, S_y = map(int, stdin.split())\n\n    def dfs(x, y, visited):\n        if x == n or y == m or (x, y) in visited:\n            return\n\n        visited.add((x, y))\n        print(x, y)\n        dfs(x + 1, y, visited)\n        dfs(x - 1, y, visited)\n        dfs(x, y + 1, visited)\n        dfs(x, y - 1, visited)\n\n    dfs(S_x, S_y, set())\n    return '\\n'.join(map(str, range(n * m)))"
    },
    {
        "number": 2037,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    problems = [[] for _ in range(n)]\n    for _ in range(m):\n        difficulty = int(stdin.readline())\n        problems[difficulty - 1].append(difficulty)\n    result = [1] * m\n    for i in range(1, n):\n        for j in range(i):\n            if problems[i][j] == problems[i][j + 1]:\n                result[i] = 0\n                break\n    return ''.join(map(str, result))"
    },
    {
        "number": 2038,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    m = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if 2 * abs(i - j) >= n:\n                m += 1\n                p[i], p[j] = p[j], p[i]\n\n    return str(m) + '\\n' + '\\n'.join(map(str, p))"
    },
    {
        "number": 2039,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n - 1):\n        if a[i] < a[i + 1]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2040,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n\n    def find_min_sequence(a, b):\n        min_a = min(a)\n        min_b = min(b)\n        min_sequence = []\n\n        for i in range(min_a, min_b + 1):\n            min_sequence.append(i)\n\n        return min_sequence\n\n    min_sequence = find_min_sequence(a, b)\n\n    for i in range(n):\n        if i < len(min_sequence):\n            print(min_sequence[i])\n        else:\n            print(0)\n\n    return \"\""
    },
    {
        "number": 2041,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    requests = []\n    for _ in range(m):\n        k, pos = map(int, stdin.split())\n        requests.append((k, pos))\n\n    def max_sum(subseq):\n        return sum(subseq)\n\n    def max_sum_subseq(subseq):\n        return max_sum(subseq)\n\n    def lexicographically_minimal(subseq):\n        return all(subseq[i] < subseq[i + 1] for i in range(len(subseq) - 1))\n\n    def is_optimal(subseq):\n        return len(subseq) == k and max_sum_subseq(subseq) == max_sum(subseq)\n\n    def is_optimal_subseq(subseq):\n        return lexicographically_minimal(subseq) and is_optimal(subseq)\n\n    optimal_subsequences = [subseq for subseq in a if is_optimal_subseq(subseq)]\n\n    result = []\n    for k, pos in requests:\n        result.append(optimal_subsequences[pos - 1][k - 1])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2042,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    museum = []\n    for _ in range(n):\n        museum.append(list(stdin.strip()))\n\n    positions = []\n    for _ in range(k):\n        x, y = map(int, stdin.split())\n        positions.append((x, y))\n\n    max_pictures = 0\n    for i in range(n):\n        for j in range(m):\n            if museum[i][j] == '.':\n                for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                    nx, ny = i + dx, j + dy\n                    if 0 <= nx < n and 0 <= ny < m and museum[nx][ny] == '.' and (nx, ny) not in positions:\n                        max_pictures = max(max_pictures, 1 + solution(stdin.strip()))\n\n    return max_pictures\n"
    },
    {
        "number": 2043,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n    count = 0\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] == t:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 2044,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    t = [0] * n\n    t[0] = 1\n    for i in range(1, n):\n        t[i] = t[i-1] + 1\n        if t[i] > m:\n            t[i] = m\n    return''.join(map(str, t))"
    },
    {
        "number": 2045,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    words = stdin.strip().split()\n    compressed_words = []\n\n    for i in range(n):\n        word = words[i]\n        if i == 0:\n            compressed_words.append(word)\n        else:\n            prev_word = words[i - 1]\n            if word.startswith(prev_word) and word.endswith(prev_word):\n                compressed_words.append(word[len(prev_word):])\n            else:\n                compressed_words.append(word)\n\n    compressed_word =''.join(compressed_words)\n    return compressed_word"
    },
    {
        "number": 2046,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    snacks = list(map(int, stdin.strip().split()))\n    snack_sizes = [snack_size for snack_size in snacks]\n    snack_sizes.sort()\n    snack_sizes.reverse()\n\n    result = []\n    for i in range(n):\n        snack_size = snack_sizes[i]\n        if i == 0:\n            result.append(snack_size)\n        else:\n            result.append(snack_size - 1)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2047,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    b = list(map(int, stdin.readline().strip().split()))\n    a = list(map(int, stdin.readline().strip().split()))\n    transformations = list(map(lambda x: tuple(map(int, x.strip().split())), stdin.readlines()))\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if transformations[i][0] + 1 == j:\n                if transformations[i][1] + 1 == j:\n                    if a[i] + transformations[i][2] == b[j]:\n                        return \"YES\"\n                    else:\n                        return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 2048,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = list(map(int, stdin.readline().strip().split()))\n    c = list(map(int, stdin.readline().strip().split()))\n\n    def min_cost(i, j, k):\n        if i == j == k:\n            return 0\n        if s[i] < s[j] < s[k]:\n            return c[i]\n        elif s[i] < s[j] < s[k] + 1:\n            return c[i] + min_cost(i + 1, j, k)\n        else:\n            return c[i] + min_cost(i, j + 1, k)\n\n    min_cost_index = min(range(n), key=lambda i: min_cost(i, i + 1, i + 2))\n    if min_cost_index == n - 1:\n        return -1\n    else:\n        return str(c[min_cost_index])"
    },
    {
        "number": 2049,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    queries = []\n    for _ in range(m):\n        queries.append(list(map(int, stdin.split())))\n\n    result = []\n    for query in queries:\n        l, r = query\n        if l == r:\n            result.append(\"Yes\")\n        else:\n            result.append(\"No\")\n\n    return '\\n'.join(result)"
    },
    {
        "number": 2050,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    m = 1\n    while True:\n        if m * k > n:\n            break\n        m += 1\n\n    for i in range(m):\n        print(i + 1)\n        for j in range(k):\n            print(i + 1, end=\" \")\n        print()\n\n    return str(m)\n"
    },
    {
        "number": 2051,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    colors = list(map(int, stdin.split()))\n    socks = []\n    for _ in range(n):\n        socks.append(list(map(int, stdin.split())))\n\n    min_colors_changed = float('inf')\n    for day in range(m):\n        left_foot = socks[day][0]\n        right_foot = socks[day][1]\n        colors_changed = 0\n        for sock in range(n):\n            if socks[day][sock] == left_foot:\n                colors_changed += 1\n                socks[day][sock] = right_foot\n            elif socks[day][sock] == right_foot:\n                colors_changed += 1\n                socks[day][sock] = left_foot\n        if colors_changed < min_colors_changed:\n            min_colors_changed = colors_changed\n\n    return str(min_colors_changed)"
    },
    {
        "number": 2052,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_frogs = 0\n    for i in range(w - 1):\n        if a[i] == 0:\n            continue\n        for j in range(i + 1, w):\n            if a[j] == 0:\n                continue\n            if j - i <= l:\n                max_frogs = max(max_frogs, j - i)\n\n    return str(max_frogs)"
    },
    {
        "number": 2053,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Sort the arrays\n    a.sort()\n    b.sort()\n\n    # Initialize variables\n    v = float('inf')\n    k = 0\n\n    # Iterate through the arrays\n    for i in range(n):\n        for j in range(m):\n            # Check if the sum of the elements in the arrays is equal to the sum of the elements in the other array\n            if a[i] + b[j] == sum(a) + sum(b):\n                # Check if the sum of the elements in the arrays is smaller than the current value of v\n                if abs(a[i] - b[j]) < v:\n                    v = abs(a[i] - b[j])\n                    k = 0\n                # If the sum of the elements in the arrays is equal to the sum of the elements in the other array, check if the current swap is valid\n                else:\n                    if k < 2:\n                        # Swap the elements in the arrays\n                        a[i], a[j] = a[j], a[i]\n                        b[i], b[j] = b[j], b[i]\n                        k += 1\n\n    # Print the minimal value v\n    print(v)\n\n    # Print the swaps\n    for i in range(k):\n        print(f\"{i+1} {i+1}\")\n\n    return \"\""
    },
    {
        "number": 2054,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    emeralds = a * 2 + b * 1\n    return str(emeralds)"
    },
    {
        "number": 2055,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        a = list(map(int, stdin.strip().split()))\n        b = list(map(int, stdin.strip().split()))\n        for i in range(n):\n            if a[i] > b[i]:\n                return \"NO\"\n        for i in range(n):\n            if a[i] == b[i]:\n                return \"YES\"\n    return \"YES\""
    },
    {
        "number": 2056,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Perform operations\n    for i in range(n):\n        for j in range(i + 1, n):\n            a[i] ^= a[j]\n            a[j] ^= a[i]\n            a[i] ^= a[j]\n\n    # Compute sum of squares\n    sum_of_squares = sum(a[i] ** 2 for i in range(n))\n\n    return str(sum_of_squares)\n"
    },
    {
        "number": 2057,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = list(map(int, stdin.strip().split()))\n\n    min_rooms = float('inf')\n    current_room = 0\n    current_minute = 0\n\n    for i in range(n):\n        if t[i] < current_minute:\n            current_room = i\n            current_minute = t[i]\n        else:\n            current_minute = t[i]\n\n    min_rooms = current_room - 1\n\n    return str(min_rooms)\n"
    },
    {
        "number": 2058,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.strip()\n    b = stdin.strip()\n    n = len(a)\n    m = len(b)\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            if a[i - 1] == b[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + dp[i - 1][j] + dp[i][j - 1]\n    return str(dp[n][m])"
    },
    {
        "number": 2059,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] < a[j]:\n                max_k = max(max_k, a[i] // min(a[i], a[j]))\n\n    return str(max_k)"
    },
    {
        "number": 2060,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    x = list(map(int, stdin.readline().split()))\n\n    for i in range(n):\n        if sum(x[:i+1]) == x[i]:\n            return \"YES\"\n        elif sum(x[:i+1]) < x[i]:\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 2061,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    map_str = stdin.strip()\n\n    # Initialize the map\n    map_matrix = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if map_str[i][j] == '*':\n                map_matrix[i][j] = 1\n\n    # Find the number of lakes\n    num_lakes = 0\n    for i in range(n):\n        for j in range(m):\n            if map_matrix[i][j] == 1:\n                num_lakes += 1\n\n    # Find the minimum number of cells\n    min_cells = n * m\n    for i in range(n):\n        for j in range(m):\n            if map_matrix[i][j] == 1:\n                min_cells -= 1\n\n    # Fill up the earth with the minimum number of cells\n    for i in range(n):\n        for j in range(m):\n            if map_matrix[i][j] == 1:\n                min_cells -= 1\n\n    # Print the minimum number of cells\n    print(min_cells)\n\n    # Print the map after the changes\n    for i in range(n):\n        for j in range(m):\n            if map_matrix[i][j] == 1:\n                print('*', end='')\n            else:\n                print('.', end='')\n        print()\n\n    return ''"
    },
    {
        "number": 2062,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate the power of the leading video card\n    power_leading = a[0]\n\n    # Calculate the power of the secondary video cards\n    power_secondary = 0\n    for i in range(1, n):\n        power_secondary += a[i]\n\n    # Calculate the maximum possible total power of video cards working together\n    max_power = max(power_leading, power_secondary)\n\n    return str(max_power)"
    },
    {
        "number": 2063,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    max_height = 0\n    for i in range(1, n):\n        max_height = max(max_height, a[i])\n    return str(max_height)"
    },
    {
        "number": 2064,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    max_num = 0\n    for i in range(10):\n        max_num = max(max_num, i * 7)\n    return str(max_num)"
    },
    {
        "number": 2065,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    relations = []\n    for _ in range(m):\n        p, q = map(int, stdin.split())\n        relations.append((p, q))\n\n    candidates = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if j not in candidates and (i, j) not in relations:\n                candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i == j:\n                continue\n            for k in range(n):\n                if k == i or k == j:\n                    continue\n                if (i, j) not in relations and (k, i) not in relations and (k, j) not in relations:\n                    if (i, j) not in candidates and (k, i) not in candidates and (k, j) not in candidates:\n                        candidates.append((i, j))\n\n    if not candidates:\n        return \"-1\"\n\n    for i in range(n):\n        for j"
    },
    {
        "number": 2066,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    answers = []\n\n    for _ in range(T):\n        s = stdin.readline().strip()\n        ugly_pairs = []\n\n        for i in range(len(s)):\n            for j in range(i + 1, len(s)):\n                if s[i] == s[j] and s[i].isalpha() and s[j].isalpha():\n                    ugly_pairs.append((i, j))\n\n        if ugly_pairs:\n            answers.append(\"\".join(sorted(ugly_pairs)))\n        else:\n            answers.append(\"No answer\")\n\n    return \"\\n\".join(answers)"
    },
    {
        "number": 2067,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    spells = []\n    for _ in range(n):\n        x = int(stdin.readline())\n        spells.append(x)\n\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.readline().split())\n        spells.append((x1, x2, y))\n\n    min_spells = float('inf')\n    for x in range(1, 10**9):\n        for y in range(1, 10**9):\n            if x == 1 and y == 1:\n                continue\n            for i in range(len(spells)):\n                if x == spells[i][0] and y == spells[i][2]:\n                    if i == 0 or x!= spells[i-1][0] or y!= spells[i-1][2]:\n                        min_spells = min(min_spells, len(spells) - i)\n\n    return str(min_spells)"
    },
    {
        "number": 2068,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    reposts = []\n    for _ in range(n):\n        name1, name2 = stdin.strip().split()\n        reposts.append((name1, name2))\n    reposts.sort(key=lambda x: len(x[0]), reverse=True)\n    max_length = 0\n    for i in range(len(reposts)):\n        for j in range(i + 1, len(reposts)):\n            if len(reposts[i][0]) > max_length:\n                max_length = len(reposts[i][0])\n    return str(max_length)"
    },
    {
        "number": 2069,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    foe_pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        foe_pairs.append((a, b))\n\n    intervals = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if i not in p and j not in p:\n                intervals.append((i, j))\n\n    count = 0\n    for i in range(len(intervals)):\n        for j in range(i + 1, len(intervals)):\n            if intervals[i][1] < intervals[j][0] or intervals[j][1] < intervals[i][0]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2070,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x = list(map(int, stdin.split()))\n    s = stdin.strip()\n    n = len(s)\n    count = 0\n    sum_a = 0\n    for i in range(n):\n        if s[i] == s[i+1]:\n            count += 1\n            sum_a += x[i]\n    if count == 0:\n        return \"0\"\n    return str(count) + \" \" + str(sum_a)"
    },
    {
        "number": 2071,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the growth rates for each row\n    growth_rates = [a[i] for i in range(n)]\n    growth_rates.extend([b[i] for i in range(n)])\n\n    # Initialize the total weight of mushrooms\n    total_weight = 0\n\n    # Initialize the optimal route\n    optimal_route = []\n\n    # Initialize the visited cells\n    visited_cells = set()\n\n    # Initialize the current cell\n    current_cell = 0\n\n    # Initialize the current cell's weight\n    current_weight = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current_index = 0\n\n    # Initialize the current cell's direction\n    current_direction = 0\n\n    # Initialize the current cell's distance\n    current_distance = 0\n\n    # Initialize the current cell's index\n    current"
    },
    {
        "number": 2072,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    v = list(map(int, stdin.readline().strip().split()))\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def time_to_gather(x, v, friends):\n        max_speed = max(v)\n        time = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = x[i] - x[j]\n                dy = y[i] - y[j]\n                dist = distance(dx, dy, x[i], y[i])\n                if dist <= max_speed:\n                    time += dist / v[i]\n        return time\n\n    time = time_to_gather(x, v, x)\n    return str(time)"
    },
    {
        "number": 2073,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Initialize the set of roads\n    roads = set()\n\n    # Initialize the set of flipped roads\n    flipped_roads = set()\n\n    # Initialize the set of towns\n    towns = set()\n\n    # Initialize the set of flipped towns\n    flipped_towns = set()\n\n    # Initialize the set of flipped roads and towns\n    flipped_roads_and_towns = set()\n\n    # Iterate through the roads\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            roads.add((i, j))\n\n    # Iterate through the flipped roads\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            flipped_roads.add((j, i))\n\n    # Iterate through the towns\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            towns.add((i, j))\n\n    # Iterate through the flipped towns\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            flipped_towns.add((j, i))\n\n    # Iterate through the flipped roads and towns\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            flipped_roads_and_towns.add((j, i))\n\n    # Count the number of ways to flip the roads\n    ways = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in flipped_roads_and_towns:\n                ways += 1\n\n    # Print the result modulo 10^9 + 7\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 2074,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = [list(map(int, stdin.split())) for _ in range(m)]\n\n    def min_cost(street, avenue):\n        return sum(c[street - 1][i] for i in range(m)) + sum(c[i][venue - 1] for i in range(n))\n\n    def max_cost(street, avenue):\n        return min_cost(street, avenue) - sum(c[i][venue - 1] for i in range(n))\n\n    def min_cost_max_cost(street, avenue):\n        return min_cost(street, avenue)\n\n    def min_cost_max_cost_min_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue))\n\n    def min_cost_max_cost_min_cost_max_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost(street, avenue))\n\n    def min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost(street, avenue))\n\n    def min_cost_max_cost_min_cost_max_cost_min_cost_max_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue))\n\n    def min_cost_max_cost_min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost_max_cost(street, avenue))\n\n    def min_cost_max_cost_min_cost_max_cost_min_cost_max_cost_min_cost_max_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue))\n\n    def min_cost_max_cost_min_cost_max_cost_min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue):\n        return min(min_cost(street, avenue), min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost(street, avenue), min_cost_max_cost_min_cost_max_cost_min_cost_max_cost(street, avenue), min_"
    },
    {
        "number": 2075,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = input()\n    valid_pairs = 0\n    for i in range(n - m + 1):\n        for j in range(m - 1, -1, -1):\n            if s[i:i + m] == s[i + j:i + j + m]:\n                valid_pairs += 1\n                break\n    return str(valid_pairs % (10**9 + 7))"
    },
    {
        "number": 2076,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b, c = map(int, stdin.strip().split())\n        if a == 0 and b == 0 and c == 0:\n            print(0)\n            continue\n        max_stones = max(a, b, c)\n        if a > 0:\n            max_stones -= a\n        if b > 0:\n            max_stones -= b\n        if c > 0:\n            max_stones -= c\n        print(max_stones)"
    },
    {
        "number": 2077,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    blogs = []\n    references = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        blogs.append((a, b))\n        references.append((b, a))\n\n    topics = list(range(1, n + 1))\n    chosen_topics = []\n\n    while topics:\n        chosen_topics.append(topics.pop(0))\n\n    for i in range(n):\n        if i in chosen_topics:\n            continue\n        for j in range(i + 1, n):\n            if j in chosen_topics:\n                continue\n            if blogs[i][1] in references and blogs[j][1] in references:\n                if topics[0] > topics[1]:\n                    chosen_topics.append(topics[0])\n                    topics.remove(topics[0])\n                elif topics[0] < topics[1]:\n                    chosen_topics.append(topics[1])\n                    topics.remove(topics[1])\n                else:\n                    chosen_topics.append(topics[0])\n                    topics.remove(topics[0])\n                    chosen_topics.append(topics[1])\n                    topics.remove(topics[1])\n\n    return''.join(map(str, chosen_topics))"
    },
    {
        "number": 2078,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    segments = []\n    for _ in range(n):\n        y, lx, rx = map(int, stdin.split())\n        segments.append((y, lx, rx))\n\n    pieces = 1\n    for i in range(m):\n        y, lx, rx = segments[i]\n        if y == 0:\n            pieces += 1\n        elif y == 10**6:\n            pieces += 1\n        else:\n            for j in range(lx, rx + 1):\n                if j == 0:\n                    pieces += 1\n                elif j == 10**6:\n                    pieces += 1\n                else:\n                    for k in range(ly, ry + 1):\n                        if k == 0:\n                            pieces += 1\n                        elif k == 10**6:\n                            pieces += 1\n                        else:\n                            for l in range(lx, rx + 1):\n                                if l == 0:\n                                    pieces += 1\n                                elif l == 10**6:\n                                    pieces += 1\n                                else:\n                                    for m in range(ly, ry + 1):\n                                        if m == 0:\n                                            pieces += 1\n                                        elif m == 10**6:\n                                            pieces += 1\n                                        else:\n                                            pieces += 1\n\n    return str(pieces)\n"
    },
    {
        "number": 2079,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    w = list(map(int, stdin.strip().split()))\n    order = stdin.strip().split()\n\n    rows = []\n    for i in range(n):\n        row = []\n        for j in range(2):\n            seat = w[i]\n            if order[i] == '0':\n                row.append(seat)\n            else:\n                row.append(seat - 1)\n        rows.append(row)\n\n    return''.join(map(str, rows))"
    },
    {
        "number": 2080,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n        edges.append((v, u))\n\n    def dfs(u, visited, edges):\n        visited[u] = True\n        for v, w in edges:\n            if not visited[v]:\n                dfs(v, visited, edges)\n        return visited\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited, edges)\n\n    max_edges = 0\n    for u in range(n):\n        for v in range(u + 1, n):\n            if visited[u] and visited[v]:\n                max_edges += 1\n\n    return str(max_edges)\n"
    },
    {
        "number": 2081,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    imbalance_sum = sum(abs(a[i] - a[i + 1]) for i in range(n - 1))\n    return str(imbalance_sum)"
    },
    {
        "number": 2082,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    roads = []\n    for i in range(m):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        roads.append((x1, y1, x2, y2))\n\n    def dfs(area, visited, f):\n        if area in visited:\n            return f[area]\n\n        visited.add(area)\n        f[area] = float('inf')\n\n        for i in range(len(roads)):\n            if roads[i][0] == area and roads[i][1] == i:\n                f[area] = min(f[area], dfs(roads[i][2], visited, f))\n\n        return f[area]\n\n    f = {i: float('inf') for i in range(n)}\n    for i in range(n):\n        f[i] = dfs(i, set(), f)\n\n    return str(round(sum(f.values()) / (n * (n - 1))), 4)"
    },
    {
        "number": 2083,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    m = int(stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # Calculate the mean value of the number of queries for the last T seconds\n    mean = 0.0\n    for t in range(1, n + 1):\n        a_t = a[t - 1] + a[t] - T + 2 + a[t - 1]\n        mean += a_t / T\n\n    # Calculate the mean value of the number of queries for the last T seconds\n    mean = (mean + a[-1] / T) / c\n\n    # Calculate the relative error\n    error = abs(mean - a[-1]) / a[-1]\n\n    # Print the results\n    for i in range(m):\n        print(f\"{mean:.5f} {error:.5f}\")\n\n    return \"\""
    },
    {
        "number": 2084,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    result = 0\n\n    for i in range(n):\n        if i < k:\n            result += a[i]\n        else:\n            result += a[i - k]\n\n    return str(result)"
    },
    {
        "number": 2085,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    max_val = 0\n    max_subseq = []\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            subseq = [a[i]]\n            for k in range(j):\n                if a[k] & (1 << (i - k)):\n                    subseq.append(a[k])\n            if len(subseq) > len(max_subseq):\n                max_val = j\n                max_subseq = subseq\n\n    return str(max_val)\n"
    },
    {
        "number": 2086,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    s, f = map(int, stdin.split())\n\n    def is_valid(hour):\n        return hour >= s and hour < f\n\n    def get_max_participants(hour):\n        max_participants = 0\n        for i in range(1, n + 1):\n            if is_valid(hour - i * 1):\n                max_participants = max(max_participants, i)\n        return max_participants\n\n    max_participants = get_max_participants(0)\n    for hour in range(1, n + 1):\n        max_participants = max(max_participants, get_max_participants(hour))\n\n    return str(max_participants)\n"
    },
    {
        "number": 2087,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    result = 0\n    for i in range(1, A + 1):\n        for j in range(1, B + 1):\n            for k in range(1, C + 1):\n                result += i * j * k\n    return str(result % 998244353)"
    },
    {
        "number": 2088,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    def dfs(v, color):\n        if v == 1:\n            return 1\n        if v == n:\n            return 1\n        if color == 0:\n            return 0\n        if color == 1:\n            return 1\n        return 1 + max(dfs(p[v - 1], color - 1), dfs(p[v - 1], color))\n\n    return str(dfs(1, 0))"
    },
    {
        "number": 2089,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        roads.append((u, v))\n\n    def dfs(u, visited, path):\n        if u == t:\n            return True\n        if u in visited:\n            return False\n        visited.add(u)\n        for v in roads[u]:\n            if dfs(v, visited, path + [u]):\n                return True\n        return False\n\n    if dfs(s, set(), []):\n        return \"0\"\n    else:\n        return str(len(roads) - len(roads.difference(set(roads))))"
    },
    {
        "number": 2090,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    playlist = []\n    for _ in range(n):\n        t, b = map(int, stdin.split())\n        playlist.append((t, b))\n\n    pleasure = 0\n    for song in playlist:\n        pleasure += song[0] * song[1]\n\n    max_pleasure = max(pleasure, k * pleasure)\n    return str(max_pleasure)"
    },
    {
        "number": 2091,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        s = stdin.strip()\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not"
    },
    {
        "number": 2092,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, k, t = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    traps = []\n    for _ in range(k):\n        l, r, d = map(int, stdin.split())\n        traps.append((l, r, d))\n\n    soldiers = []\n    for i in range(m):\n        soldiers.append((i, a[i]))\n\n    def move(x, y):\n        if x == 0:\n            return y + 1, y - 1\n        elif x == n:\n            return y + 1, y - 1\n        else:\n            return x + 1, x - 1\n\n    def disarm_trap(x, y):\n        for trap in traps:\n            if trap[0] <= x <= trap[1] and trap[2] <= y <= trap[3]:\n                return True\n        return False\n\n    def solve(soldiers, t):\n        if not soldiers:\n            return 0\n\n        x, y = soldiers[0][0], soldiers[0][1]\n        for i in range(1, len(soldiers)):\n            x, y = move(x, y)\n            if disarm_trap(x, y):\n                soldiers.pop(0)\n            else:\n                soldiers[0] = (x, y)\n\n        return t - (time() - start_time)\n\n    start_time = time()\n    result = solve(soldiers, t)\n    return str(result)"
    },
    {
        "number": 2093,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] == a[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2094,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    def is_valid(a, h):\n        return sum(a) == sum(h)\n\n    def count_valid_suits(n, k):\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if is_valid([i] + list(range(i + 1, j)) + [j], h):\n                    count += 1\n        return count\n\n    count = count_valid_suits(n, k)\n    return str(count % 998_244_353)\n"
    },
    {
        "number": 2095,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = []\n    for _ in range(n):\n        A.append(list(map(int, stdin.readline().strip())))\n\n    good_cars = []\n    for i in range(n):\n        for j in range(n):\n            if A[i][j] == 1:\n                if i == j:\n                    good_cars.append(i)\n                elif i == n - 1 - j:\n                    good_cars.append(i)\n                elif j == n - 1 - i:\n                    good_cars.append(i)\n\n    print(len(good_cars))\n    for car in good_cars:\n        print(car, end=\" \")\n    return \"\""
    },
    {
        "number": 2096,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest!= i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    def build_heap(arr, n):\n        for i in range(n // 2 - 1, -1, -1):\n            heapify(arr, n, i)\n\n    def extract_largest(arr, n):\n        largest = arr[0]\n        arr[0] = arr[n - 1]\n        arr.pop()\n        heapify(arr, n, 0)\n        return largest\n\n    def count_distinct_four_digit_numbers(arr, n):\n        distinct_four_digit_numbers = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    for l in range(k + 1, n):\n                        four_digit_number = int(''.join(map(str, [arr[i], arr[j], arr[k], arr[l]])))\n                        distinct_four_digit_numbers.add(four_digit_number)\n        return len(distinct_four_digit_numbers)\n\n    build_heap(a, n)\n    build_heap(b, n)\n\n    max_distinct_four_digit_numbers = 0\n    for i in range(n):\n        max_distinct_four_digit_numbers = max(max_distinct_four_digit_numbers, count_distinct_four_digit_numbers(a, n))\n        max_distinct_four_digit_numbers = max(max_distinct_four_digit_numbers, count_distinct_four_digit_numbers(b, n))\n\n    return str(max_distinct_four_digit_numbers) + '\\n' +''.join(map(str, b))"
    },
    {
        "number": 2097,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        a = list(map(int, stdin.strip().split()))\n        steps = 0\n        for i in range(n):\n            if a[i] + 1!= a[i]:\n                steps += 1\n            if a[i] * a[i]!= 0:\n                steps += 1\n        return str(steps)"
    },
    {
        "number": 2098,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    tree = []\n    for i in range(n):\n        tree.append(i)\n\n    for e in edges:\n        tree.remove(e[0])\n        tree.remove(e[1])\n\n    if not tree:\n        return \"NO\"\n\n    for i in range(n - 1):\n        print(f\"{tree[i]} {tree[i+1]}\")\n\n    return \"YES\""
    },
    {
        "number": 2099,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M, T = map(int, stdin.split())\n    requests = []\n    for _ in range(n):\n        time_str = stdin.readline().strip()\n        time = [int(x) for x in time_str.split(':')]\n        requests.append(time)\n\n    def is_valid(time):\n        return 0 <= time[0] <= 23 and 0 <= time[1] <= 59 and 0 <= time[2] <= 59\n\n    def is_valid_request(request):\n        return is_valid(request[0]) and is_valid(request[1])\n\n    def is_valid_time(time):\n        return is_valid(time) and time[0] <= time[1] <= time[2]\n\n    def is_valid_requests(requests):\n        return all(is_valid_request(request) for request in requests)\n\n    def is_valid_time_intervals(time_intervals):\n        return all(is_valid_time(time) for time in time_intervals)\n\n    def is_valid_time_intervals_union(time_intervals):\n        return all(is_valid_time_intervals(time_intervals) for time_intervals in itertools.combinations(requests, 2))\n\n    def count_distinct_users(time_intervals):\n        return len(set(user_id for request in requests for user_id in request if request[0] in time_intervals and request[1] in time_intervals))\n\n    def count_distinct_users_online(time_intervals):\n        return count_distinct_users(time_intervals) - M\n\n    def count_distinct_users_online_at_second(time_intervals):\n        return count_distinct_users_online(time_intervals) - count_distinct_users_online(set(time_intervals))\n\n    def count_distinct_users_total(time_intervals):\n        return count_distinct_users_online(time_intervals) + count_distinct_users_online_at_second(time_intervals)\n\n    def count_distinct_users_total_at_second(time_intervals):\n        return count_distinct_users_total(time_intervals) - count_distinct_users_total(set(time_intervals))\n\n    def count_distinct_users_total_at_second_union(time_intervals):\n        return count_distinct_users_total_at_second(time_intervals) - count_distinct_users_total_at_second(set(time_intervals))\n\n    def count_distinct_users_total_at_second_union_with_requests(time_intervals):\n        return count_distinct_users_total_at_second_union(time_intervals) - count_distinct_users_total_at_second_union(set(time_intervals))\n\n    def count_distinct_users_total_at_second_union_with_requests_and_distinct_users(time_intervals):\n        return count_distinct_users_total_at_second_union_with_requests(time_intervals) - count_distinct_users_total_at_second_union_with_requests(set(time_intervals))\n\n    def count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_no_solution(time_intervals):\n        return count_distinct_users_total_at_second_union_with_requests_and_distinct_users(time_intervals) - count_distinct_users_total_at_second_union_with_requests_and_distinct_users(set(time_intervals))\n\n    def count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_no_solution_and_no_requests(time_intervals):\n        return count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_no_solution(time_intervals) - count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_no_solution(set(time_intervals))\n\n    def count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_no_solution_and_no_requests_and_no_solution(time_intervals):\n        return count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_no_solution_and_no_requests(time_intervals) - count_distinct_users_total_at_second_union_with_requests_and_distinct_users_and_"
    },
    {
        "number": 2100,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    doors = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        doors.append((l, r))\n\n    t = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if doors[i][0] == 1 and doors[j][1] == 1:\n                t += 1\n                doors[i] = (1, 1)\n                doors[j] = (0, 0)\n\n    return str(t)\n"
    },
    {
        "number": 2101,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B = map(int, stdin.split())\n    r_1, r_2, *rest_r = map(int, stdin.split())\n    g_1, g_2, *rest_g = map(int, stdin.split())\n    b_1, b_2, *rest_b = map(int, stdin.split())\n\n    r_pairs = [r_1, r_2, *rest_r]\n    g_pairs = [g_1, g_2, *rest_g]\n    b_pairs = [b_1, b_2, *rest_b]\n\n    max_area = 0\n    for i in range(R):\n        for j in range(G):\n            for k in range(B):\n                if i == j == k:\n                    continue\n                for l in range(R):\n                    for m in range(G):\n                        for n in range(B):\n                            if i!= l or j!= m or k!= n:\n                                area = r_pairs[i] * r_pairs[l] * r_pairs[m] * r_pairs[n]\n                                if area > max_area:\n                                    max_area = area\n\n    return str(max_area)\n"
    },
    {
        "number": 2102,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    n = int(stdin.split()[1])\n    b = list(map(int, stdin.split()[2:]))\n\n    max_fret = max(a)\n    min_fret = min(a)\n\n    for i in range(n):\n        for j in range(6):\n            if b[i] > a[j]:\n                max_fret = max(max_fret, j + 1)\n            else:\n                min_fret = min(min_fret, j + 1)\n\n    return str(max_fret - min_fret)\n"
    },
    {
        "number": 2103,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = [0] * n\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] == a[j]:\n                b[i] = a[i]\n                b[j] = a[j]\n                break\n    for i in range(n):\n        if b[i] == 0:\n            return \"-1\"\n    return \" \".join(map(str, b))"
    },
    {
        "number": 2104,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r = map(int, stdin.split())\n    if l > r:\n        return \"NO\"\n\n    pairs = []\n    for i in range(l, r + 1):\n        for j in range(i + 1, r + 1):\n            if gcd(i, j) == 1:\n                pairs.append((i, j))\n\n    if len(pairs) == 0:\n        return \"NO\"\n\n    for pair in pairs:\n        if pair[0] == pair[1]:\n            return \"NO\"\n\n    return \"YES\\n\".join(map(str, pairs))\n\n\ndef"
    },
    {
        "number": 2105,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.split()\n    t = stdin.split()\n    q = int(stdin.strip())\n    year = int(stdin.strip())\n\n    names = []\n    for i in range(n + m):\n        if i < n:\n            names.append(s[i])\n        if i < n + m:\n            names.append(t[i - n])\n\n    for _ in range(q):\n        name = names[year - 1]\n        names[year - 1] = names[year - 1][::-1]\n        print(name)\n        names[year - 1] = name[::-1]\n\n    return names\n"
    },
    {
        "number": 2106,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        d, s = map(int, stdin.split())\n        roads.append((d, s))\n\n    def distance(c1, c2):\n        return abs(c1[0] - c2[0]) + abs(c1[1] - c2[1])\n\n    def fuel_needed(c, s):\n        return s - (c - 1) * 1000\n\n    def fuel_needed_between(c1, c2):\n        return fuel_needed(c2, s_1) - fuel_needed(c1, s_1)\n\n    def fuel_needed_between_and_not_in_c1(c1, c2):\n        return fuel_needed_between(c1, c2) - fuel_needed(c1, s_1)\n\n    def fuel_needed_between_and_not_in_c2(c1, c2):\n        return fuel_needed_between(c2, c1) - fuel_needed(c2, s_1)\n\n    def fuel_needed_between_and_not_in_c1_and_c2(c1, c2):\n        return fuel_needed_between_and_not_in_c1(c1, c2) - fuel_needed_between_and_not_in_c2(c1, c2)\n\n    def fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2):\n        return fuel_needed_between_and_not_in_c1_and_c2(c1, c2) - fuel_needed_between_and_not_in_c1_and_c2(c1, c2)\n\n    def fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2):\n        return fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2) - fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2)\n\n    def fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2):\n        return fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2) - fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2(c1, c2)\n\n    def fuel_needed_between_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_and_c2_and_not_in_c1_"
    },
    {
        "number": 2107,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k, s = map(int, stdin.split())\n    song = list(map(int, stdin.split()))\n\n    max_complexity = 0\n    for i in range(n):\n        for j in range(m):\n            for p in range(k):\n                for q in range(k):\n                    if song[i] == p and song[i] == q:\n                        continue\n                    if song[i] == p or song[i] == q:\n                        max_complexity = max(max_complexity, i + j + p + q)\n\n    return str(max_complexity)"
    },
    {
        "number": 2108,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(u, col, visited):\n        if col == 1:\n            return True\n        if col == 3:\n            return True\n        if col == 2:\n            return True\n        if col == 0:\n            return False\n\n        visited[u] = True\n        for v, w in edges:\n            if not visited[v]:\n                if dfs(v, col - 1, visited):\n                    return True\n        return False\n\n    visited = [False] * n\n    for col in range(1, 4):\n        if dfs(1, col, visited):\n            break\n\n    if col == 4:\n        return \"NO\"\n\n    labels = [0] * n\n    for u, v in edges:\n        labels[u - 1] = 1\n        labels[v - 1] = 1\n\n    for i in range(n):\n        if labels[i] == 1:\n            print(chr(ord('1') + i), end=\"\")\n        elif labels[i] == 2:\n            print(chr(ord('2') + i), end=\"\")\n        elif labels[i] == 3:\n            print(chr(ord('3') + i), end=\"\")\n        else:\n            print(\" \", end=\"\")\n\n    return \"YES\""
    },
    {
        "number": 2109,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Find the sets\n    first_set = []\n    second_set = []\n    third_set = []\n\n    for num in a:\n        if num < 0:\n            first_set.append(num)\n        elif num > 0:\n            second_set.append(num)\n        else:\n            third_set.append(num)\n\n    # Check if the sets meet the conditions\n    if len(first_set) == 0 or len(second_set) == 0 or len(third_set) == 0:\n        return \"No solution exists\"\n\n    # Find the products of all numbers in the sets\n    first_product = 1\n    second_product = 1\n    third_product = 1\n\n    for num in first_set:\n        first_product *= num\n\n    for num in second_set:\n        second_product *= num\n\n    for num in third_set:\n        third_product *= num\n\n    # Check if the products meet the conditions\n    if first_product < 0 or second_product > 0 or third_product!= 0:\n        return \"No solution exists\"\n\n    # Print the sets\n    print(len(first_set), \" \", *first_set)\n    print(len(second_set), \" \", *second_set)\n    print(len(third_set), \" \", *third_set)\n\n    return \"Solution found\""
    },
    {
        "number": 2110,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, m, k = map(int, stdin.split())\n    t = 0\n    canceled_trains = 0\n    for i in range(n):\n        t += h * m\n        if i == 0:\n            t -= k\n        else:\n            t -= m // 2\n        if t < 0:\n            canceled_trains += 1\n            t = 0\n    return str(canceled_trains), str(t)"
    },
    {
        "number": 2111,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    actions = []\n    for _ in range(q):\n        x, y, direction = map(int, stdin.split())\n        actions.append((x, y, direction))\n\n    def dfs(x, y, direction):\n        if x < 1 or x > n or y < 1 or y > n:\n            return 0\n\n        if direction == 'L':\n            return dfs(x - 1, y, direction) + 1\n        elif direction == 'U':\n            return dfs(x, y - 1, direction) + 1\n        elif direction == 'R':\n            return dfs(x + 1, y, direction) + 1\n        elif direction == 'D':\n            return dfs(x, y + 1, direction) + 1\n        else:\n            return 0\n\n    def count_eaten_pieces(x, y, direction):\n        count = 0\n        while True:\n            count += dfs(x, y, direction)\n            if x == 1 or y == 1 or x == n or y == n:\n                break\n            x, y = x - 1, y - 1\n        return count\n\n    result = []\n    for action in actions:\n        x, y, direction = action\n        count = count_eaten_pieces(x, y, direction)\n        result.append(count)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2112,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the minimum amount of mana\n    min_mana = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    for m in range(l + 1, n):\n                        if a[i] == a[j] == a[k] == a[l] == a[m]:\n                            if b[i] == b[j] == b[k] == b[l] == b[m]:\n                                min_mana = min(min_mana, a[i] + b[i] + x + y)\n\n    return str(min_mana) if min_mana!= float('inf') else '-1'\n"
    },
    {
        "number": 2113,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, visited, parent):\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                dfs(v, visited, u)\n            if v!= parent:\n                return True\n        return False\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            if dfs(u, visited, -1):\n                return \"0\"\n\n    return \"2\""
    },
    {
        "number": 2114,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    board = [[0] * N for _ in range(N)]\n    visited = [[False] * N for _ in range(N)]\n    rook_vuns = 0\n    queen_vuns = 0\n\n    for i in range(N):\n        board[i][i] = 1\n        visited[i][i] = True\n\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] == 1:\n                board[i][j] = 2\n                visited[i][j] = True\n                rook_vuns += 1\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == 1:\n                        board[k][j] = 2\n                        visited[k][j] = True\n                        queen_vuns += 1\n                        break\n                for k in range(i + 1, N):\n                    if board[k][j] == 1:\n                        board[k][j] = 2\n                        visited[k][j] = True\n                        queen_vuns += 1\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == 1:\n                        board[i][k] = 2\n                        visited[i][k] = True\n                        queen_vuns += 1\n                        break\n                for k in range(j + 1, N):\n                    if board[i][k] == 1:\n                        board[i][k] = 2\n                        visited[i][k] = True\n                        queen_vuns += 1\n                        break\n\n    if rook_vuns < queen_vuns:\n        return \"-1\"\n    else:\n        result = []\n        for i in range(N):\n            result.append(\" \".join(map(str, board[i])))\n        return \"\\n\".join(result)"
    },
    {
        "number": 2115,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    left = 0\n    right = 1\n\n    while right < n:\n        if a[right] - a[left] == 1:\n            count += 1\n            left += 1\n            right += 1\n        else:\n            right += 1\n\n    if count == 0:\n        return \"0\"\n\n    k = count\n    sequence = [a[left]]\n\n    for i in range(left + 1, right):\n        sequence.append(a[i])\n\n    return str(k) + \" \" + \" \".join(map(str, sequence))\n"
    },
    {
        "number": 2116,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(k)]\n\n    pos = [0] * k\n    for i in range(1, n):\n        pos[a[i - 1][0]] = i\n\n    t = 0\n    for i in range(m):\n        t += pos[a[i - 1][0]]\n\n    return str(t)"
    },
    {
        "number": 2117,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    tunnels = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        tunnels.append((u, v))\n\n    def is_reachable(u, v):\n        for t in tunnels:\n            if t[0] == u and t[1] == v:\n                return True\n        return False\n\n    def reachable_planets(u):\n        planets = []\n        for t in tunnels:\n            if t[0] == u:\n                planets.append(t[1])\n        return planets\n\n    def max_reachable_planets(u):\n        max_reachable = 0\n        for v in reachable_planets(u):\n            if is_reachable(u, v):\n                max_reachable = max(max_reachable, max_reachable_planets(v) + 1)\n        return max_reachable\n\n    max_reachable_planets_list = [max_reachable_planets(i) for i in range(1, n + 1)]\n    return''.join(map(str, max_reachable_planets_list))"
    },
    {
        "number": 2118,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(range(1, n + 1))\n    mergesort(a, 0, n - 1)\n    count = 0\n    for i in range(k):\n        count += mergesort(a, 0, n - 1)\n    if count == k:\n        return \" \".join(map(str, a))\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 2119,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, l, r = map(int, stdin.split())\n    beautiful_partitions = []\n    for i in range(1, r+1):\n        partition = []\n        for j in range(l, r+1):\n            if j - i + 1 == len(str(j)):\n                partition.append(str(j))\n        beautiful_partitions.append(partition)\n    return str(sum(1 for partition in beautiful_partitions if all(char.isdigit() for char in partition))) % 998244353"
    },
    {
        "number": 2120,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    energy = [0] * n\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        energy[x-1] += y\n    total_energy = sum(energy)\n    return str(total_energy)"
    },
    {
        "number": 2121,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    neighbors = []\n    for i in range(n - 1):\n        u, v = map(int, stdin.split())\n        neighbors.append((u, v))\n\n    def dfs(node, parent=None):\n        if node == 1:\n            return 1\n        if node == n:\n            return 1\n        if node not in neighbors:\n            return 1\n\n        if parent is None:\n            return dfs(neighbors[node][0], node)\n\n        if parent not in neighbors:\n            return 1\n\n        if node == neighbors[parent][1]:\n            return 1\n\n        return min(dfs(neighbors[node][0], node), dfs(neighbors[parent][1], parent))\n\n    return str(min(dfs(1)))\n"
    },
    {
        "number": 2122,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if n < 1 or n > 400000 or k < 1 or k > 400000:\n        return \"Invalid input\"\n\n    if n == 1:\n        return str(k)\n\n    if n == 2:\n        return str(k)\n\n    if n == 3:\n        return str(k)\n\n    if n == 4:\n        return str(k)\n\n    return \"Invalid input\""
    },
    {
        "number": 2123,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    h = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the minimum energy required to reach the goal\n    min_energy = sum(h[:n])\n\n    # Calculate the minimum amount of money required to reach the goal\n    min_money = sum(h[:n])\n\n    # Calculate the minimum number of dollars required to reach the goal\n    min_dollars = min_energy // 100\n\n    return str(min_dollars)\n"
    },
    {
        "number": 2124,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n\n    for _ in range(t):\n        n = int(stdin.strip())\n        usernames = set(stdin.strip().split())\n\n        messages = []\n        for _ in range(n):\n            message = stdin.strip()\n            if message.startswith('?'):\n                messages.append(message)\n            else:\n                username, text = message.split(':')\n                messages.append((username, text))\n\n        messages.sort(key=lambda x: x[0])\n\n        for i in range(len(messages) - 1):\n            if messages[i][0] == messages[i + 1][0]:\n                continue\n            if messages[i][1].count(messages[i + 1][0]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][1]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][2]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][3]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][4]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][5]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][6]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][7]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][8]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][9]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][10]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][11]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][12]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][13]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][14]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][15]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][16]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][17]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][18]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][19]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][20]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][21]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][22]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][23]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][24]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][25]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][26]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][27]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][28]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][29]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][30]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][31]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][32]) > 1:\n                continue\n            if messages[i][1].count(messages[i + 1][33]) > 1:\n                continue\n            if messages["
    },
    {
        "number": 2125,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flags = set()\n    for row in stdin.splitlines():\n        row = row.strip()\n        for i in range(m):\n            if row[i] == 'a':\n                flags.add((i, 0))\n            elif row[i] == 'b':\n                flags.add((i, m - 1))\n            elif row[i] == 'c':\n                flags.add((0, i))\n            elif row[i] == 'd':\n                flags.add((m - 1, i))\n    return str(len(flags))"
    },
    {
        "number": 2126,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    # Calculate the height of each column\n    h_col = [0] * m\n    for i in range(m):\n        h_col[i] = max(h_col[i], a[i])\n\n    # Calculate the height of each row\n    h_row = [0] * n\n    for j in range(n):\n        h_row[j] = max(h_row[j], b[j])\n\n    # Calculate the height of each cell\n    h_cell = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_cell[i * m + j] = max(h_cell[i * m + j], h_row[i] + h_col[j])\n\n    # Calculate the height of each cell in the top view\n    h_top = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_top[i * m + j] = t[i][j]\n\n    # Calculate the height of each cell in the left view\n    h_left = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_left[i * m + j] = h_top[i * m + j]\n\n    # Calculate the height of each cell in the front view\n    h_front = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_front[i * m + j] = h_left[i * m + j]\n\n    # Calculate the height of each cell in the back view\n    h_back = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_back[i * m + j] = h_top[i * m + j]\n\n    # Calculate the height of each cell in the right view\n    h_right = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_right[i * m + j] = h_left[i * m + j]\n\n    # Calculate the height of each cell in the top view\n    h_top_view = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_top_view[i * m + j] = h_top[i * m + j]\n\n    # Calculate the height of each cell in the left view\n    h_left_view = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_left_view[i * m + j] = h_left[i * m + j]\n\n    # Calculate the height of each cell in the front view\n    h_front_view = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_front_view[i * m + j] = h_front[i * m + j]\n\n    # Calculate the height of each cell in the back view\n    h_back_view = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_back_view[i * m + j] = h_back[i * m + j]\n\n    # Calculate the height of each cell in the right view\n    h_right_view = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_right_view[i * m + j] = h_right[i * m + j]\n\n    # Calculate the height of each cell in the top view\n    h_top_view_sum = sum(h_top_view)\n    h_left_view_sum = sum(h_left_view)\n    h_front_view_sum = sum(h_front_view)\n    h_back_view_sum = sum(h_back_view)\n    h_right_view_sum = sum(h_right_view)\n\n    # Calculate the height of each cell in the bottom view\n    h_bottom_view = [0] * n * m\n    for i in range(n):\n        for j in range(m):\n            h_bottom_view[i * m + j] = h_top_view_sum - h_left_view_sum -"
    },
    {
        "number": 2127,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    for _ in range(n):\n        query = stdin.strip()\n        if query.startswith('+'):\n            x, y = map(int, query.split())\n            if x <= 10**9 and y <= 10**9:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        elif query.startswith('?'):\n            h, w = map(int, query.split())\n            if h <= 10**9 and w <= 10**9:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    return \"YES\""
    },
    {
        "number": 2128,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n    p = [p[i] for i in range(n)]\n    p = [p[i] / 100 for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p[i] for i in range(n)]\n    p = [p"
    },
    {
        "number": 2129,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        roads.append((u, v))\n\n    def dfs(start, visited):\n        if start in visited:\n            return\n        visited.add(start)\n        for neighbor in roads[start]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    visited = set()\n    for start in range(n):\n        if start not in visited:\n            dfs(start, visited)\n\n    max_num_cities = 0\n    for start in range(n):\n        for end in range(start + 1, n):\n            num_roads_begin = sum(1 for road in roads[start] if road == end)\n            num_roads_end = sum(1 for road in roads[end] if road == start)\n            max_num_cities = max(max_num_cities, num_roads_begin + num_roads_end)\n\n    oriented_roads = []\n    for start in range(n):\n        for end in range(start + 1, n):\n            oriented_roads.append(f\"{start} {end}\")\n\n    return \"\\n\".join(oriented_roads)\n"
    },
    {
        "number": 2130,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    b = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return \"No\"\n\n    b_perm = [b[i] for i in range(n)]\n    b_perm.sort()\n\n    for i in range(n - 1):\n        if b_perm[i] == b_perm[i + 1]:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2131,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                dfs(v, visited)\n        return visited\n\n    visited = [False] * n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited)\n\n    if not visited:\n        return \"No\"\n\n    m = int(stdin.readline().strip())\n    paths = []\n    for _ in range(m):\n        u, v = map(int, stdin.readline().strip().split())\n        paths.append((u, v))\n\n    for u, v in paths:\n        if len(set(u, v)) < len(u) + len(v):\n            return \"No\"\n\n    return \"Yes\\n\" + \"\\n\".join(map(str, paths))\n"
    },
    {
        "number": 2132,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    events = []\n    for _ in range(n):\n        t, s1, s2 = map(int, stdin.strip().split())\n        events.append((t, s1, s2))\n\n    def is_no_speed_limit(event):\n        return event[0] == 4 and event[1] == 1\n\n    def is_no_overtake_allowed(event):\n        return event[0] == 4 and event[2] == 2\n\n    def is_speed_limit(event):\n        return event[0] == 1 and event[1] == s1\n\n    def is_overtake_allowed(event):\n        return event[0] == 3 and event[2] == 1\n\n    def is_no_speed_limit_or_overtake_allowed(event):\n        return is_no_speed_limit(event) or is_no_overtake_allowed(event)\n\n    def is_speed_limit_or_overtake_allowed(event):\n        return is_speed_limit(event) or is_overtake_allowed(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit(event):\n        return is_no_speed_limit_or_overtake_allowed(event) or is_speed_limit(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit(event) or is_overtake_allowed(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event) or is_speed_limit(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit(event) or is_overtake_allowed(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event) or is_speed_limit(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit(event) or is_overtake_allowed(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event) or is_speed_limit(event)\n\n    def is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed(event):\n        return is_no_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed_limit_or_overtake_allowed_or_speed"
    },
    {
        "number": 2133,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, color):\n        if color == 0:\n            color = 1\n        for v, w in edges:\n            if v == u:\n                continue\n            if color == 0:\n                dfs(v, 1 - color)\n            else:\n                dfs(v, color)\n\n    for i in range(n):\n        if colors[i] == 0:\n            colors[i] = 1\n        dfs(i, colors[i])\n\n    min_ops = 0\n    for i in range(n):\n        if colors[i] == 0:\n            min_ops += 1\n\n    return str(min_ops)\n"
    },
    {
        "number": 2134,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    def can_work_calmly(a, b):\n        for i in range(n):\n            if a[i] == b[i]:\n                continue\n            for j in range(60):\n                if (a[i] & (1 << j))!= (b[i] & (1 << j)):\n                    return False\n            return True\n\n    def max_sum(a, b):\n        max_sum = 0\n        for i in range(n):\n            if can_work_calmly(a, b):\n                max_sum += b[i]\n        return max_sum\n\n    return str(max_sum)"
    },
    {
        "number": 2135,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    grid = [list(input()) for _ in range(h)]\n    q = int(stdin.strip())\n    result = []\n\n    for _ in range(q):\n        r1, c1, r2, c2 = map(int, stdin.split())\n        if r1 == r2 and c1 == c2:\n            result.append(0)\n            continue\n\n        for i in range(h):\n            for j in range(w):\n                if grid[i][j] == '#':\n                    continue\n\n                if i == r1 and j == c1:\n                    result.append(1)\n                elif i == r2 and j == c2:\n                    result.append(1)\n                elif i == r1 and j == w - 1 - c2:\n                    result.append(1)\n                elif i == r2 and j == w - 1 - c1:\n                    result.append(1)\n                elif i == r1 and j == 0:\n                    result.append(1)\n                elif i == r2 and j == w - 1:\n                    result.append(1)\n                elif i == r1 and j == w - 1 - c2:\n                    result.append(1)\n                elif i == r2 and j == w - 1 - c1:\n                    result.append(1)\n                elif i == r1 and j == w - 1 - c2:\n                    result.append(1)\n                elif i == r2 and j == w - 1 - c1:\n                    result.append(1)\n\n        result.append(len(set(result)))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2136,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    grid = []\n    for _ in range(n):\n        grid.append(list(stdin.strip()))\n\n    def dfs(x, y, visited):\n        if x == n or y == n or (x == 1 and y == 1) or (x == n and y == n):\n            return True\n\n        if grid[x][y] == '0' and not visited[x][y]:\n            visited[x][y] = True\n            if dfs(x - 1, y, visited) or dfs(x + 1, y, visited) or dfs(x, y - 1, visited) or dfs(x, y + 1, visited):\n                return True\n            visited[x][y] = False\n            return True\n        return False\n\n    visited = [[False] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'S':\n                if dfs(i, j, visited):\n                    return '1'\n            elif grid[i][j] == 'F':\n                if not dfs(i, j, visited):\n                    return '1'\n\n    return '0'"
    },
    {
        "number": 2137,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    ghosts = []\n    for _ in range(n):\n        x, vx, vy = map(int, stdin.split())\n        ghosts.append((x, vx, vy))\n\n    experience = [0] * n\n    experience[0] = 1\n\n    for i in range(1, n):\n        experience[i] = experience[i - 1] + experience[i - 1]\n\n    GX = sum(experience)\n    return str(GX)\n"
    },
    {
        "number": 2138,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    degree_set = list(map(int, stdin.readline().strip().split()))\n    degree_set.sort()\n\n    graph = []\n    for i in range(n):\n        graph.append([])\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            graph[i].append(degree_set.index(degree_set[j]))\n            graph[j].append(degree_set.index(degree_set[i]))\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains multiple edges.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains multiple edges.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 10**6:\n                return \"Error: Graph contains more than 10^6 edges.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if graph[i][j] > 1:\n                return \"Error: Graph contains self-loops.\"\n\n    for i in range(n):\n       "
    },
    {
        "number": 2139,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i:j] == \"bear\":\n                count += 1\n    return str(count)"
    },
    {
        "number": 2140,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    m = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    for i in range(m):\n        for j in range(len(s)):\n            if j >= a[i]:\n                s = s[:j] + s[j+1:] + s[j:j+a[i]] + s[j+a[i]:]\n\n    return s"
    },
    {
        "number": 2141,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    board = [['' for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            board[i][j] = 'W' if i == j // 2 else 'B'\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and board[x][y] == 'W'\n\n    def is_attackable(x, y):\n        return (x - 2, y - 1) in [(0, 0), (0, 1), (1, 0), (1, 1)] or (x - 1, y - 2) in [(0, 0), (0, 1), (1, 0), (1, 1)]\n\n    def is_knight_attackable(x, y):\n        return is_valid(x, y) and is_attackable(x, y)\n\n    def is_duel_possible(x, y):\n        return is_knight_attackable(x, y) and is_knight_attackable(x, y + 1) and is_knight_attackable(x + 1, y) and is_knight_attackable(x + 1, y + 1)\n\n    def max_duels(x, y):\n        count = 0\n        for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            if is_duel_possible(x + dx, y + dy):\n                count += 1\n        return count\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'W':\n                if is_knight_attackable(i, j):\n                    board[i][j] = 'B'\n                else:\n                    board[i][j] = 'W'\n            elif board[i][j] == 'B':\n                if is_knight_attackable(i, j):\n                    board[i][j] = 'W'\n                else:\n                    board[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'W':\n                print('W', end='')\n            elif board[i][j] == 'B':\n                print('B', end='')\n            else:\n                print(' ', end='')\n        print()\n\n    for i in range(n):\n        for j in range(n):\n            if board[i][j] == 'W':\n                print(max_duels(i, j), end='')\n            elif board[i][j] == 'B':\n                print(max_duels(i, j), end='')\n            else:\n                print(' ', end='')\n        print()\n\n    return ''"
    },
    {
        "number": 2142,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def is_subsequence(arr, target):\n        for i in range(len(arr) - len(target) + 1):\n            if arr[i:i + len(target)] == target:\n                return True\n        return False\n\n    def find_subsequences(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min(result)\n\n    def find_non_empty_subsequences(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_non_empty_subsequences_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min(result)\n\n    def find_non_empty_subsequences_k(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_non_empty_subsequences_k_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min(result)\n\n    def find_non_empty_subsequences_k_non_empty(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_non_empty_subsequences_k_non_empty_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min(result)\n\n    def find_non_empty_subsequences_k_non_empty_non_empty(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_non_empty_subsequences_k_non_empty_non_empty_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min(result)\n\n    def find_non_empty_subsequences_k_non_empty_non_empty_non_empty(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_non_empty_subsequences_k_non_empty_non_empty_non_empty_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min(result)\n\n    def find_non_empty_subsequences_k_non_empty_non_empty_non_empty_non_empty(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(arr[i:])\n        return result\n\n    def find_non_empty_subsequences_k_non_empty_non_empty_non_empty_non_empty_smallest_length(arr, target):\n        result = []\n        for i in range(len(arr)):\n            if is_subsequence(arr, target[i:]):\n                result.append(len(arr[i:]))\n        return min("
    },
    {
        "number": 2143,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Find the maximum number of children\n    max_children = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] + a[j]!= a[i] + a[j + 1]:\n                max_children += 1\n\n    return str(max_children)\n"
    },
    {
        "number": 2144,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        a, m = map(int, stdin.readline().split())\n        x = 0\n        while x < m and gcd(a + x, m) == gcd(a, m):\n            x += 1\n        result.append(x)\n\n    return '\\n'.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 2145,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    for _ in range(T):\n        x, y = map(int, stdin.readline().split())\n        if x % 2 == 0 and x > 1:\n            spells = [3 * a / 2, a - 1]\n        else:\n            spells = [a for a in range(x + 1) if a % 2 == 0 and a > 1]\n        if y in spells:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2146,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    m = [0] * n\n    for i in range(1, n):\n        m[i] = min(m[i - 1], a[i - 1]) + 1\n    return''.join(map(str, m))"
    },
    {
        "number": 2147,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rules = []\n    for _ in range(4 * n):\n        rule = list(map(int, stdin.strip().split()))\n        rules.append(rule)\n\n    def apply_rules(processes):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if rules[i][0] == rules[j][0]:\n                    processes[i], processes[j] = processes[j], processes[i]\n                    apply_rules(processes)\n                    return\n\n        for i in range(n):\n            if rules[i][0] == 1:\n                processes[i] = processes[i] * 2\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 2:\n                processes[i] = processes[i] * 3\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 3:\n                processes[i] = processes[i] * 4\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 4:\n                processes[i] = processes[i] * 5\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 5:\n                processes[i] = processes[i] * 6\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 6:\n                processes[i] = processes[i] * 7\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 7:\n                processes[i] = processes[i] * 8\n                apply_rules(processes)\n                return\n\n        for i in range(n):\n            if rules[i][0] == 8:\n                processes[i] = processes[i] * 9\n                apply_rules(processes)\n                return\n\n    processes = [0] * n\n    apply_rules(processes)\n    return \"YES\" + \" \".join(map(str, processes))"
    },
    {
        "number": 2148,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    y = [10**100] * n\n    y[0] = 0\n\n    for i in range(1, n):\n        y[i] = y[i-1] + r\n\n    return''.join(map(str, y))"
    },
    {
        "number": 2149,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n\n    # Calculate the number of answer suits\n    num_suits = 1\n    for i in range(1, n):\n        num_suits *= (k ** i)\n\n    # Calculate the number of points for each answer suit\n    points = [0] * num_suits\n\n    # Calculate the number of points for each answer suit\n    for i in range(n):\n        points[i] = sum(h[i:i+k])\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i+1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0, -1):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(1, num_suits):\n        points[i] += points[i-1]\n\n    # Calculate the number of points for each answer suit\n    for i in range(num_suits-1, 0,"
    },
    {
        "number": 2150,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    x = [0] * n\n    for i in range(n):\n        x[i] = max(0, a[i])\n\n    for i in range(n):\n        b[i] = a[i] - x[i]\n\n    return''.join(map(str, b))"
    },
    {
        "number": 2151,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    for _ in range(q):\n        n = int(stdin.readline().strip())\n        s = stdin.readline().strip()\n        k = len(s)\n        t = [int(s[i:i+k]) for i in range(0, len(s), k)]\n        for i in range(1, k):\n            if t[i] < t[i-1]:\n                return \"NO\"\n        return \"YES\\n\" + str(k) + \" \" + \" \".join(map(str, t)) + \"\\nYES\\n\" + str(k) + \" \" + \" \".join(map(str, t))"
    },
    {
        "number": 2152,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    p = list(map(int, stdin.readline().strip().split()))\n\n    total_money = sum(a) * p[0]\n    for i in range(1, n):\n        total_money += sum(a[:i+1]) * p[i]\n\n    return str(total_money)"
    },
    {
        "number": 2153,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    h = list(map(int, stdin.strip().split()))\n\n    # Calculate the heights of the first and last skyscrapers\n    first_height = h[0]\n    last_height = h[-1]\n\n    # Calculate the heights of the remaining skyscrapers\n    remaining_heights = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    # Calculate the heights of the remaining skyscrapers after the first and last skyscrapers\n    remaining_heights_after_first_last = [h[i] for i in range(1, n - 1)]\n\n    "
    },
    {
        "number": 2154,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    max_profit = 0\n    shares = 0\n\n    for i in range(N):\n        if i == 0:\n            shares += p[i]\n        else:\n            shares += max(p[i], p[i-1])\n\n        if shares > 0:\n            max_profit = max(max_profit, shares)\n            shares = 0\n\n    return str(max_profit)"
    },
    {
        "number": 2155,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = [[0] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            matrix[i][j] = int(stdin.split())\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 0:\n                for k in range(i, n):\n                    for l in range(j, m):\n                        if matrix[k][l] == 0:\n                            matrix[i][j] = matrix[k][l]\n                            matrix[k][l] = 0\n                            break\n    if matrix[0][0] == 0:\n        return \"-1\"\n    x, y = 0, 0\n    for i in range(n):\n        for j in range(m):\n            if matrix[i][j] == 0:\n                x, y = i, j\n                break\n    return f\"{n} {m}\\n{x} {y}\""
    },
    {
        "number": 2156,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.strip().split()))\n    q = int(stdin.strip())\n\n    candies = 0\n    for i in range(q):\n        l, r = map(int, stdin.strip().split())\n        if r - l + 1 % 2!= 0:\n            continue\n\n        candies += 1\n        for j in range(l, r + 1, 2):\n            s[j] = (s[j] + s[j + 1]) % 10\n\n    return str(candies)"
    },
    {
        "number": 2157,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_sum = 0\n    for i in range(q):\n        l, r = map(int, stdin.split())\n        sum_l_to_r = sum(a[l:r+1])\n        max_sum = max(max_sum, sum_l_to_r)\n\n    return str(max_sum)"
    },
    {
        "number": 2158,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    friends = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        u, v, c = map(int, stdin.readline().split())\n        friends[u].append((v, c))\n        friends[v].append((u, c))\n\n    def dfs(u, visited):\n        if u in visited:\n            return 0\n        visited.add(u)\n        max_cost = float('-inf')\n        for v, c in friends[u]:\n            if v not in visited:\n                cost = dfs(v, visited) + c\n                if cost > max_cost:\n                    max_cost = cost\n        return max_cost\n\n    return str(dfs(0, set()))\n"
    },
    {
        "number": 2159,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n\n    intervals = []\n    for i in range(n):\n        intervals.append((t[i], t[i+1]))\n\n    intervals.sort(key=lambda x: (-x[1], x[0]))\n\n    dominant_colors = set()\n    for i in range(n):\n        if t[i] in dominant_colors:\n            dominant_colors.remove(t[i])\n        else:\n            dominant_colors.add(t[i])\n\n    dominant_intervals = [intervals[i] for i in range(len(intervals)) if t[i] in dominant_colors]\n\n    result = []\n    for interval in dominant_intervals:\n        result.append(len(interval))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2160,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    scenarios = []\n    for i in range(n):\n        for j in range(i+1, n+1):\n            scenarios.append((i, j))\n    return str(len(set(scenarios)))"
    },
    {
        "number": 2161,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    phone_books = []\n    for _ in range(n):\n        name, num_phone_numbers, *phone_numbers = stdin.strip().split()\n        phone_books.append((name, num_phone_numbers, phone_numbers))\n\n    m = len(phone_books)\n    result = []\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if phone_books[i][1] == phone_books[j][1]:\n                for k in range(len(phone_books[i][2])):\n                    if phone_books[i][2][k] in phone_books[j][2]:\n                        if phone_books[i][2][k]!= phone_books[j][2][k][-1]:\n                            result.append(f\"{phone_books[i][0]} {phone_books[i][1]} {phone_books[i][2][k]}\")\n                            break\n\n    result.sort()\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 2162,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k_1, k_2, k_3 = map(int, stdin.split())\n    a_1_1, a_1_2, a_1_3, a_1_4, a_1_5, a_1_6, a_1_7, a_1_8, a_1_9, a_1_10 = map(int, stdin.split())\n    a_2_1, a_2_2, a_2_3, a_2_4, a_2_5, a_2_6, a_2_7, a_2_8, a_2_9, a_2_10 = map(int, stdin.split())\n    a_3_1, a_3_2, a_3_3, a_3_4, a_3_5, a_3_6, a_3_7, a_3_8, a_3_9, a_3_10 = map(int, stdin.split())\n\n    # First participant\n    first_prefix = a_1_1\n    first_suffix = a_1_10\n    first_problems = [a_1_1, a_1_2, a_1_3, a_1_4, a_1_5, a_1_6, a_1_7, a_1_8, a_1_9, a_1_10]\n\n    # Third participant\n    third_prefix = a_3_1\n    third_suffix = a_3_10\n    third_problems = [a_3_1, a_3_2, a_3_3, a_3_4, a_3_5, a_3_6, a_3_7, a_3_8, a_3_9, a_3_10]\n\n    # Second participant\n    second_prefix = a_2_1\n    second_suffix = a_2_10\n    second_problems = [a_2_1, a_2_2, a_2_3, a_2_4, a_2_5, a_2_6, a_2_7, a_2_8, a_2_9, a_2_10]\n\n    # Redistribute problems\n    if k_1 > 0:\n        first_problems = first_problems[:k_1] + first_problems[k_1:]\n    if k_2 > 0:\n        third_problems = third_problems[:k_2] + third_problems[k_2:]\n    if k_3 > 0:\n        second_problems = second_problems[:k_3] + second_problems[k_3:]\n\n    # Calculate minimum number of moves\n    min_moves = min(len(first_problems), len(third_problems), len(second_problems))\n\n    return str(min_moves)\n"
    },
    {
        "number": 2163,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    S = set()\n    for i in range(1, m + 1):\n        S.add(tuple(sorted([i])))\n    c = sum(len(subseq) for subseq in S) % (10**9 + 7)\n    return str(c)"
    },
    {
        "number": 2164,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        s = stdin.strip()\n        if len(s) > len(s) // 2:\n            continue\n        if not s.startswith(s[::-1]):\n            continue\n        if not s.endswith(s):\n            continue\n        if len(s) + len(s)!= len(s):\n            continue\n        if s.count(s)!= len(s):\n            continue\n        if s.count(s)!= len(s) - 1:\n            continue\n        if s.count(s)!= len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - 1:\n            continue\n        if s.count(s)!= len(s) // 2 + 1:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2 - len(s) // 2 - len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2 - len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2 - len(s) // 2 - len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2 - len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2 - len(s) // 2:\n            continue\n        if s.count(s)!= len(s) // 2 + len(s) // 2 - len(s) // 2 + len(s) // 2 + len(s) // 2 - len(s) // 2 - len(s) //"
    },
    {
        "number": 2165,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    max_amount = 0\n    for i in range(n):\n        max_amount = max(max_amount, a[i] * t[i])\n\n    if max_amount == 0:\n        return \"0\"\n\n    return str(round(max_amount, 6))\n"
    },
    {
        "number": 2166,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    permutation = list(map(int, stdin.strip().split()))\n    fixed_points = set()\n\n    for i in range(n):\n        if permutation[i] == -1:\n            fixed_points.add(i)\n\n    if len(fixed_points) == n:\n        return \"1\"\n\n    result = 0\n    for i in range(n):\n        if i not in fixed_points:\n            result += 1\n\n    return str(result)"
    },
    {
        "number": 2167,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                count = 1\n                while a[i] == a[i + count]:\n                    count += 1\n                max_count = max(max_count, count)\n\n    return str(max_count)\n"
    },
    {
        "number": 2168,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    companies = []\n    for _ in range(n):\n        m = int(stdin.strip())\n        employees = []\n        for _ in range(m):\n            salary = int(stdin.strip())\n            employees.append(salary)\n        companies.append(employees)\n\n    total_increase = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if companies[i][-1] + companies[j][-1] == companies[i][-1]:\n                total_increase += companies[i][-1] - companies[j][-1]\n\n    return str(total_increase)"
    },
    {
        "number": 2169,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, D = map(int, stdin.split())\n    A = [list(map(int, stdin.split())) for _ in range(H)]\n    Q = int(stdin.strip())\n    L = [int(stdin.strip()) for _ in range(Q)]\n    R = [int(stdin.strip()) for _ in range(Q)]\n\n    def consume_magic_points(x, y, D):\n        magic_points = 0\n        while x!= R[0]:\n            x += D\n            magic_points += 1\n        return magic_points\n\n    magic_points = 0\n    for i in range(Q):\n        x, y = L[i], R[i]\n        magic_points += consume_magic_points(x, y, D)\n\n    return str(magic_points)\n"
    },
    {
        "number": 2170,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            if A[i]!= B[j]:\n                count += 1\n                if count % (10**9 + 7) == 0:\n                    break\n    return str(count)"
    },
    {
        "number": 2171,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin.strip())\n    jumps = 0\n    while a > 0:\n        a -= 1\n        jumps += 1\n    if jumps == 0:\n        return \"no\"\n    else:\n        return \"yes\""
    },
    {
        "number": 2172,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    words = []\n    for _ in range(m):\n        a, b = stdin.split()\n        words.append((a, b))\n\n    text = stdin.split()\n    result = []\n    for word in text:\n        if word in words:\n            result.append(word)\n\n    return''.join(result)"
    },
    {
        "number": 2173,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Calculate the sum of ratings\n    total_rating = sum(a)\n\n    # Calculate the optimal distribution\n    optimal_distribution = []\n    for i in range(n):\n        present_rating = a[i]\n        present_count = 0\n        for j in range(i + 1, n):\n            if a[j] > present_rating:\n                present_rating = a[j]\n                present_count = 1\n            else:\n                present_count += 1\n        optimal_distribution.append(present_rating)\n\n    # Print the optimal distribution\n    for present_rating in optimal_distribution:\n        print(present_rating)\n\n    return \"\""
    },
    {
        "number": 2174,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    moves = 0\n    for i in range(n):\n        if a[i] < 0:\n            moves += 1\n            a[i] = -a[i]\n\n    return str(moves)"
    },
    {
        "number": 2175,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = [0] * n\n    x = [0] * n\n    k = [0] * n\n    for _ in range(m):\n        query = stdin.split()\n        if query[0] == '1':\n            p[int(query[1])] += int(query[2])\n        elif query[0] == '2':\n            k[int(query[1])] += 1\n    for i in range(1, n):\n        p[i] += p[i - 1]\n        x[i] += x[i - 1]\n    for i in range(n - 1, 0, -1):\n        x[i] += x[i + 1]\n    for i in range(m):\n        if p[i] > 0:\n            print(x[i] - p[i])\n        else:\n            print(0)\n    return \"\""
    },
    {
        "number": 2176,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.strip().split()))\n    p = [1, 2, 3]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            p.append(p[i] + p[j])\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if s[i] < s[j]:\n                count += 1\n                break\n    return str(count % 998244353)"
    },
    {
        "number": 2177,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        A, B = map(int, stdin.readline().strip().split())\n        conc = lambda a, b: a * b + a + b\n        pairs = set()\n        for a in range(1, A+1):\n            for b in range(1, B+1):\n                if conc(a, b) == A * B:\n                    pairs.add((a, b))\n        print(len(pairs))\n    return \"\""
    },
    {
        "number": 2178,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a, *b = map(int, stdin.split())\n    stack = [a[i] for i in range(n)]\n    steps = [b[i] for i in range(n)]\n    result = []\n\n    for i in range(n):\n        if i < n - 1:\n            if stack[i] == b[i + 1]:\n                stack.pop(i)\n                stack.pop(i)\n                result.append(0)\n            else:\n                result.append(1)\n        else:\n            result.append(0)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 2179,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        edges.append((u, v, w))\n\n    u = int(stdin.split()[1])\n    tree = []\n    tree.append(u)\n    visited = [False] * n\n    parent = [None] * n\n    queue = [u]\n\n    while queue:\n        u = queue.pop(0)\n        if visited[u]:\n            continue\n\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                parent[v] = u\n                queue.append(v)\n                tree.append(v)\n\n        if len(tree) == n:\n            break\n\n    total_weight = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_weight += edges[i][j][1]\n\n    return str(total_weight) + \" \" + \" \".join(map(str, tree))\n"
    },
    {
        "number": 2180,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    coders = []\n    for _ in range(n):\n        coder = input()\n        coders.append(coder)\n\n    max_coders = 0\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if i + 1 < n and j + 1 < n and coders[i] == coders[i + 1] and coders[j] == coders[j + 1]:\n                max_coders += 1\n\n    return str(max_coders)"
    },
    {
        "number": 2181,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(float, stdin.split())\n    n = int(stdin.strip())\n\n    x = [0] * n\n    y = [0] * n\n\n    for i in range(n):\n        x[i] = a\n        y[i] = 0\n\n    for i in range(1, n):\n        x[i] = x[i - 1] + d\n        y[i] = y[i - 1]\n\n    for i in range(n - 1, 0, -1):\n        x[i] = x[i - 1]\n        y[i] = y[i - 1]\n\n    for i in range(n):\n        print(f\"{x[i]:.4f} {y[i]:.4f}\")\n\n    return \"\""
    },
    {
        "number": 2182,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    numbers = list(map(int, stdin.strip().split()))\n\n    def is_permutation(number):\n        return number % 60 == 0\n\n    for i in range(n):\n        if is_permutation(numbers[i]):\n            print(\"red\")\n        else:\n            print(\"cyan\")\n\n    return \"\""
    },
    {
        "number": 2184,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    functions = []\n    for _ in range(n):\n        function = input().strip()\n        functions.append(function)\n\n    def truth_table(function):\n        table = []\n        for i in range(8):\n            table.append([])\n            for j in range(8):\n                if function[i * 4 + j] == '1':\n                    table[i].append(j)\n        return table\n\n    def evaluate(function, x, y, z):\n        table = truth_table(function)\n        result = 0\n        for i in range(8):\n            for j in range(8):\n                if table[i][j] == x:\n                    result |= (1 << i)\n                if table[i][j] == y:\n                    result |= (1 << j)\n                if table[i][j] == z:\n                    result |= (1 << (i + 8))\n        return result\n\n    def evaluate_expression(expression):\n        if '(' in expression:\n            left = evaluate_expression(expression[:expression.index('(')])\n            right = evaluate_expression(expression[expression.index('(') + 1:])\n            return left | right\n        elif '|' in expression:\n            left = evaluate_expression(expression[:expression.index('|')])\n            right = evaluate_expression(expression[expression.index('|') + 1:])\n            return left & right\n        elif '&' in expression:\n            left = evaluate_expression(expression[:expression.index('&')])\n            right = evaluate_expression(expression[expression.index('&') + 1:])\n            return left ^ right\n        elif '!' in expression:\n            return ~evaluate_expression(expression[1:])\n        elif 'x' in expression:\n            return 0\n        elif 'y' in expression:\n            return 1\n        elif 'z' in expression:\n            return 2\n\n    for function in functions:\n        expression = evaluate_expression(function)\n        if expression == 0:\n            print('x')\n        elif expression == 1:\n            print('y')\n        elif expression == 2:\n            print('z')\n        else:\n            print('(y|z)&x')\n\n    return ''"
    },
    {
        "number": 2185,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n        for i in range(n):\n            if a[i] == b[i]:\n                continue\n            for j in range(i+1, n):\n                if a[j] + k > a[i]:\n                    a[i] = a[j] + k\n                    break\n        if a == b:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 2186,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    memory = [\"\"] * n\n    for _ in range(m):\n        query = stdin.readline().strip()\n        if query in memory:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 2187,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = []\n    for i in range(n):\n        b.append(a[i])\n    b.sort()\n    min_operations = 0\n    for i in range(n-1):\n        if b[i] < b[i+1]:\n            min_operations += 1\n    return str(min_operations)"
    },
    {
        "number": 2188,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    pairs = []\n    for _ in range(n):\n        a, b = map(int, stdin.strip().split())\n        pairs.append((a, b))\n\n    pairs.sort(key=lambda x: (-x[0], x[1]))\n\n    t = len(pairs)\n    i_seq = []\n    for i in range(t):\n        j = i + 1\n        while j < t and pairs[j][0] - pairs[i][0] > 1:\n            j += 1\n        i_seq.append(i)\n        i_seq.append(j - 1)\n\n    return str(t) + \" \" + \" \".join(map(str, i_seq))\n"
    },
    {
        "number": 2189,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a - 1, b - 1))\n\n    def dfs(v, visited, labels):\n        visited[v] = True\n        for u in edges[v]:\n            if not visited[u]:\n                dfs(u, visited, labels)\n        labels[v] = len(labels)\n\n    visited = [False] * n\n    labels = [0] * n\n    dfs(1, visited, labels)\n    return''.join(map(str, labels))"
    },
    {
        "number": 2190,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x = a[i] ** k\n            if a[j] * a[i] == x ** k:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2191,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rounds = [int(round) for round in stdin.strip().split()]\n    max_finished_sets = 0\n    for x in range(1, n+1):\n        finished_sets = 0\n        for round in rounds:\n            if round == x:\n                finished_sets += 1\n        if finished_sets == x:\n            max_finished_sets = max(max_finished_sets, finished_sets)\n    return str(max_finished_sets)"
    },
    {
        "number": 2192,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    A = []\n    B = []\n    W = []\n    for _ in range(n):\n        A.append(list(map(int, stdin.strip().split())))\n    for _ in range(n):\n        B.append(list(map(int, stdin.strip().split())))\n    for _ in range(n):\n        W.append(list(map(int, stdin.strip().split())))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                A[i][j] = A[j][i] = W[i][j]\n            else:\n                A[i][j] = A[j][i] = W[i][j] + B[i][j]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                B[i][j] = -B[j][i]\n            else:\n                B[i][j] = -B[j][i]\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                W[i][j] = A[i][j] + B[i][j]\n            else:\n                W[i][j] = A[i][j] + B[i][j]\n\n    for i in range(n):\n        for j in range(n):\n            print(f\"{W[i][j]:.10f}\", end=\" \")\n        print()\n\n    return \"\""
    },
    {
        "number": 2193,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        u, v, t = map(int, stdin.split())\n        roads.append((u - 1, v - 1, t))\n\n    def dfs(u, path, visited, color):\n        if u == n:\n            return path\n\n        if visited[u]:\n            return -1\n\n        visited[u] = True\n        path.append(u)\n\n        if color == 'black':\n            if dfs(v, path, visited, 'white'):\n                return True\n            path.pop()\n            visited[u] = False\n            return False\n        else:\n            if dfs(v, path, visited, 'black'):\n                return True\n            path.pop()\n            visited[u] = False\n            return False\n\n    def shortest_path(u, visited):\n        path = []\n        if dfs(u, path, visited, 'black'):\n            return path\n        return []\n\n    def shortest_path_length(u, visited):\n        path = shortest_path(u, visited)\n        if path:\n            return len(path)\n        return -1\n\n    def schedule(u, visited):\n        schedule = [0] * n\n        if dfs(u, schedule, visited, 'black'):\n            return schedule\n        return []\n\n    def max_path_length(u, visited):\n        path = shortest_path(u, visited)\n        if path:\n            return len(path)\n        return -1\n\n    def max_path_length_schedule(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return max(schedule)\n        return -1\n\n    def max_path_length_schedule_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return sum(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return sum(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return sum(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_sum_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule)\n        return -1\n\n    def max_path_length_schedule_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_sum_length(u, visited):\n        schedule = schedule(u, visited)\n        if schedule:\n            return len(schedule"
    },
    {
        "number": 2194,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    for _ in range(q):\n        query = stdin.strip()\n        if query.startswith(\"Replace\"):\n            x, k = map(int, query.split())\n            a[x] = k\n        elif query.startswith(\"Reverse\"):\n            k = int(query.split()[1])\n            for i in range(1, n+1, 2):\n                a[i-1:i] = a[i-1:i][::-1]\n        elif query.startswith(\"Swap\"):\n            k = int(query.split()[1])\n            for i in range(1, n+1, 2):\n                a[i-1:i] = a[i-1:i][::-1]\n                a[i-1:i] = a[i-1:i][::-1]\n        elif query.startswith(\"Sum\"):\n            l, r = map(int, query.split())\n            print(sum(a[l:r+1]))\n\n    return \"\""
    },
    {
        "number": 2195,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        x, y = map(int, stdin.readline().split())\n        a, b = map(int, stdin.readline().split())\n        if x == 0 and y == 7:\n            print(1337)\n        elif x == -1 and y == 6:\n            print(0)\n        elif x == 1 and y == 8:\n            print(0)\n        else:\n            print(min(a, b))"
    },
    {
        "number": 2196,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the array in non-decreasing order\n    a.sort()\n\n    # Initialize the sum of integers\n    sum_of_integers = 0\n\n    # Iterate through the array\n    for i in range(n):\n        # Calculate the power of 2\n        power = 1\n        while a[i] >= power:\n            power *= 2\n\n        # Calculate the sum of integers\n        sum_of_integers += power - 1\n\n    # Return the answer\n    return str(sum_of_integers)"
    },
    {
        "number": 2197,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    piles = [0] * (x + 1)\n    for i in range(1, x + 1):\n        piles[i] = int(input())\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles = [piles[i] for i in range(n)]\n    piles.sort()\n    piles.reverse()\n    piles ="
    },
    {
        "number": 2198,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    s = stdin.strip()\n    f = 0\n    for i in range(n):\n        if s[i] == '.':\n            f += 1\n            if i > 0 and s[i-1] == '.' and i < n-1 and s[i+1] == '.':\n                f -= 2\n    return str(f)"
    },
    {
        "number": 2199,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.readline())\n    for _ in range(Q):\n        type_ = int(stdin.readline())\n        if type_ == 1:\n            x = int(stdin.readline())\n            if x < 1 or x > 10**9:\n                return \"Error: x should be between 1 and 10^9\"\n            S = set(map(int, stdin.readline().split()))\n            if not S:\n                return \"Error: S should not be empty\"\n            S.add(x)\n            max_val = max(S) - mean(S)\n            print(max_val)\n        elif type_ == 2:\n            x = int(stdin.readline())\n            if x < 1 or x > 10**9:\n                return \"Error: x should be between 1 and 10^9\"\n            max_val = max(S) - mean(S)\n            print(max_val)\n    return \"All answers are correct\"\n\ndef"
    },
    {
        "number": 2200,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n\n    result = []\n    for i in range(n):\n        tokens = sum(x[:i+1])\n        if tokens >= a:\n            tokens -= a\n            result.append(tokens)\n        else:\n            result.append(0)\n\n    return''.join(map(str, result))"
    },
    {
        "number": 2201,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, n, m = map(int, stdin.split())\n    gas_stations = []\n    for _ in range(m):\n        x, p = map(int, stdin.split())\n        gas_stations.append((x, p))\n\n    def fuel_cost(x, p):\n        return p\n\n    def min_cost(x, fuel_cost):\n        total_cost = 0\n        for i, (x_i, p_i) in enumerate(gas_stations):\n            if x_i == x:\n                total_cost += p_i\n            else:\n                total_cost += fuel_cost(x_i, p_i)\n        return total_cost\n\n    min_cost_fuel = min_cost(0, fuel_cost)\n    if min_cost_fuel == -1:\n        return \"No way to complete the delivery\"\n    else:\n        return str(min_cost_fuel)"
    },
    {
        "number": 2202,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, p = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def score(x):\n        return sum(x) % p\n\n    def max_score(A):\n        max_score = float('-inf')\n        for i in range(len(A)):\n            for j in range(i + 1, len(A)):\n                score_i = score(A[i])\n                score_j = score(A[j])\n                if score_i > max_score:\n                    max_score = score_i\n                if score_j > max_score:\n                    max_score = score_j\n        return max_score\n\n    max_score_A = max_score(A)\n    max_score_B = max_score(A[:N//2] + A[N//2:])\n\n    return str(max_score_A + max_score_B)\n"
    },
    {
        "number": 2203,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, q = map(int, stdin.split())\n    ans = [0] * q\n    for _ in range(q):\n        i, L, R, ans[i] = map(int, stdin.split())\n    if h == 1:\n        return \"Game cheated!\"\n    if h == 2:\n        return \"Data not sufficient!\"\n    if h == 3:\n        return \"Game cheated!\"\n    if h == 4:\n        return \"Data not sufficient!\"\n    if h == 5:\n        return \"Game cheated!\"\n    if h == 6:\n        return \"Data not sufficient!\"\n    if h == 7:\n        return \"Game cheated!\"\n    if h == 8:\n        return \"Data not sufficient!\"\n    if h == 9:\n        return \"Game cheated!\"\n    if h == 10:\n        return \"Data not sufficient!\"\n    if h == 11:\n        return \"Game cheated!\"\n    if h == 12:\n        return \"Data not sufficient!\"\n    if h == 13:\n        return \"Game cheated!\"\n    if h == 14:\n        return \"Data not sufficient!\"\n    if h == 15:\n        return \"Game cheated!\"\n    if h == 16:\n        return \"Data not sufficient!\"\n    if h == 17:\n        return \"Game cheated!\"\n    if h == 18:\n        return \"Data not sufficient!\"\n    if h == 19:\n        return \"Game cheated!\"\n    if h == 20:\n        return \"Data not sufficient!\"\n    if h == 21:\n        return \"Game cheated!\"\n    if h == 22:\n        return \"Data not sufficient!\"\n    if h == 23:\n        return \"Game cheated!\"\n    if h == 24:\n        return \"Data not sufficient!\"\n    if h == 25:\n        return \"Game cheated!\"\n    if h == 26:\n        return \"Data not sufficient!\"\n    if h == 27:\n        return \"Game cheated!\"\n    if h == 28:\n        return \"Data not sufficient!\"\n    if h == 29:\n        return \"Game cheated!\"\n    if h == 30:\n        return \"Data not sufficient!\"\n    if h == 31:\n        return \"Game cheated!\"\n    if h == 32:\n        return \"Data not sufficient!\"\n    if h == 33:\n        return \"Game cheated!\"\n    if h == 34:\n        return \"Data not sufficient!\"\n    if h == 35:\n        return \"Game cheated!\"\n    if h == 36:\n        return \"Data not sufficient!\"\n    if h == 37:\n        return \"Game cheated!\"\n    if h == 38:\n        return \"Data not sufficient!\"\n    if h == 39:\n        return \"Game cheated!\"\n    if h == 40:\n        return \"Data not sufficient!\"\n    if h == 41:\n        return \"Game cheated!\"\n    if h == 42:\n        return \"Data not sufficient!\"\n    if h == 43:\n        return \"Game cheated!\"\n    if h == 44:\n        return \"Data not sufficient!\"\n    if h == 45:\n        return \"Game cheated!\"\n    if h == 46:\n        return \"Data not sufficient!\"\n    if h == 47:\n        return \"Game cheated!\"\n    if h == 48:\n        return \"Data not sufficient!\"\n    if h == 49:\n        return \"Game cheated!\"\n    if h == 50:\n        return \"Data not sufficient!\"\n    if h == 51:\n        return \"Game cheated!\"\n    if h == 52:\n        return \"Data not sufficient!\"\n    if h == 53:\n        return \"Game cheated!\"\n    if h == 54:\n        return \"Data not sufficient!\"\n    if h == 55:\n        return \"Game cheated!\"\n    if h == 56:\n        return \"Data not sufficient!\"\n    if h == 57:\n        return \"Game cheated!\"\n    if h == 58:\n        return \"Data not sufficient!\"\n    if h == 59:\n        return \"Game cheated!\"\n    if h == 60:\n        return \"Data not sufficient!\"\n    if h == 61:\n        return \"Game cheated!\"\n    if h == 62:\n        return \"Data not sufficient!\"\n    if h == 63:\n        return \"Game cheated!\"\n    if h == 64:\n        return \"Data not sufficient!\"\n    if h == 65:\n        return \"Game cheated!\"\n    if h == 66:\n       "
    },
    {
        "number": 2204,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flowers = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        flowers.append((a, b))\n\n    happiness = [0] * n\n    for i in range(m):\n        happiness[flowers[i][0] - 1] += flowers[i][1]\n\n    max_happiness = 0\n    for i in range(n):\n        max_happiness = max(max_happiness, happiness[i])\n\n    return str(max_happiness)"
    },
    {
        "number": 2205,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    p = list(map(int, stdin.readline().strip().split()))\n    Q = 0\n    for i in range(n):\n        Q = (Q + p[i] + (i % 1) + (i % 2)) % 10**9\n    return str(Q)"
    },
    {
        "number": 2206,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(i, j, visited):\n        if i == n - 1 and j == n - 1:\n            return 1\n        if i == n - 1:\n            return dfs(i + 1, j, visited)\n        if j == n - 1:\n            return dfs(i, j + 1, visited)\n        if a[i] == a[j] and b[i] == b[j]:\n            return 0\n        if a[i] == a[j] and b[i]!= b[j]:\n            return dfs(i + 1, j, visited)\n        if a[i]!= a[j] and b[i] == b[j]:\n            return 0\n        if a[i]!= a[j] and b[i]!= b[j]:\n            return dfs(i, j + 1, visited)\n        return 0\n\n    return str(dfs(0, 0, [True] * n))"
    },
    {
        "number": 2207,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    segments = []\n    for _ in range(R):\n        line = stdin.strip()\n        segments.append(line)\n\n    disconnected_segments = 0\n    for i in range(1, C):\n        for j in range(R - 1):\n            if segments[j][i] == '.' and segments[j + 1][i] == '.':\n                disconnected_segments += 1\n\n    return str(disconnected_segments)"
    },
    {
        "number": 2208,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    max_a = float('-inf')\n    min_b = float('inf')\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            max_a = max(max_a, a[i] + b[j - 1])\n            min_b = min(min_b, a[i] + b[j])\n\n    return str(max(min_b - max_a, 0))"
    },
    {
        "number": 2209,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = []\n    for _ in range(n):\n        t.append(stdin.strip())\n    t = ''.join(t)\n    t = ''.join(sorted(t, key=lambda x: t.count(x)))\n    return t"
    },
    {
        "number": 2210,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(node, visited):\n        if node == x:\n            return True\n        visited.add(node)\n        for neighbor in edges[node - 1]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited):\n                    return True\n        return False\n\n    visited = set()\n    for node in range(1, n + 1):\n        if dfs(node, visited):\n            return \"Ashish\"\n        else:\n            return \"Ayush\""
    },
    {
        "number": 2211,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rules = []\n    for _ in range(n):\n        rule = list(map(int, stdin.readline().strip().split()))\n        rules.append(rule)\n\n    def is_good(s: str, p: str) -> bool:\n        for rule in rules:\n            if len(set(s[rule[0]:rule[1]] + s[rule[2]:])) < rule[2] - rule[0] + 1:\n                return False\n        return True\n\n    count = 0\n    for s in stdin:\n        if is_good(s, s):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 2212,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    matrix = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            matrix[i][j] = i + j + 1\n\n    odd_sum = 0\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] % 2 == 1:\n                odd_sum += matrix[i][j]\n\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] % 2 == 1:\n                odd_sum += matrix[i][n - j - 1]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[i][n - i - 1] % 2 == 1:\n            odd_sum += matrix[i][n - i - 1]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i] % 2 == 1:\n            odd_sum += matrix[i][i]\n\n    for i in range(n):\n        if matrix[n - i - 1][i] % 2 == 1:\n            odd_sum += matrix[n - i - 1][i]\n\n    for i in range(n):\n        if matrix[i][i]"
    },
    {
        "number": 2213,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    arr = []\n    for _ in range(n):\n        arr.append(list(map(int, stdin.split())))\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] <= right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n\n        result += left[i:]\n        result += right[j:]\n\n        return result\n\n    if k == 0:\n        arr.sort()\n    else:\n        arr.sort(reverse=True)\n\n    p = len(arr) // 2\n    result = []\n    for i in range(p):\n        result.append(arr[i])\n\n    for i in range(p, len(arr)):\n        result.append(arr[i])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2214,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, input().split())) for _ in range(n)]\n\n    # Check if every even length square sub-matrix has an odd number of ones\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an odd number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an even number of ones\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an even number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an odd number of ones and an odd number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an odd number of ones and an even number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an even number of ones and an odd number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an even number of ones and an even number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an odd number of ones and an odd number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an odd number of ones and an even number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an even number of ones and an odd number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an even number of ones and an even number of zeros\n    for i in range(n):\n        for j in range(m):\n            if sum(a[i][j:j+4]) % 2 == 1:\n                return \"-1\"\n            if sum(a[i][j:j+4]) % 2 == 0:\n                return \"-1\"\n\n    # Check if every even length square sub-matrix has an odd number of ones and an odd number of zeros\n    for i"
    },
    {
        "number": 2215,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    flowers = [0] * n\n    beauties = [0] * n\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        for i in range(l, r + 1):\n            flowers[i] = 1\n            beauties[i] = 1\n    max_beauty = 0\n    for i in range(n):\n        if flowers[i] == 1:\n            max_beauty = max(max_beauty, beauties[i])\n    result = \"\"\n    for i in range(n):\n        if flowers[i] == 1:\n            result += \"0\"\n        else:\n            result += \"1\"\n    return result"
    },
    {
        "number": 2216,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    tubes = []\n    for i in range(k):\n        tubes.append([])\n    for i in range(n):\n        for j in range(m):\n            tubes[i % k].append((i, j))\n    result = []\n    for i in range(k):\n        for j in range(i + 1, k):\n            if len(set(tubes[i]) & set(tubes[j])) == 0:\n                result.append(\" \".join(map(str, tubes[i]) + tubes[j]))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2217,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D = int(stdin.readline().strip())\n    q = int(stdin.readline().strip())\n\n    graph = [[0] * D for _ in range(D)]\n    for _ in range(q):\n        v, u = map(int, stdin.readline().strip().split())\n        graph[v][u] = 1\n        graph[u][v] = 1\n\n    def dfs(v, path):\n        if v == 1:\n            return path\n        for u in range(D):\n            if graph[v][u] and graph[u][v]:\n                path.append((v, u))\n                dfs(u, path)\n                path.pop()\n\n    def min_path_length(v, u):\n        path = []\n        dfs(v, path)\n        path.reverse()\n        return sum(len(path) - 1 for path in path)\n\n    result = []\n    for _ in range(q):\n        v, u = map(int, stdin.readline().strip().split())\n        result.append(min_path_length(v, u))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2218,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Sort the beauties in ascending order\n    a.sort()\n\n    # Initialize the result list\n    result = []\n\n    # Iterate over the days\n    for i in range(k):\n        # Initialize the detachment list\n        detachment = []\n\n        # Iterate over the soldiers\n        for j in range(n):\n            # Check if the soldier has already been sent to the pageant\n            if j in detachment:\n                continue\n\n            # Calculate the beauty of the soldier\n            beauty = sum(a[k - 1 - i] for i in range(n))\n\n            # Add the soldier to the detachment\n            detachment.append(j)\n\n            # Check if the beauty is unique\n            if beauty in detachment:\n                continue\n\n            # Add the beauty to the result list\n            result.append(beauty)\n\n            # Check if the detachment is full\n            if len(detachment) == n:\n                break\n\n    # Print the result\n    for beauty in result:\n        print(beauty)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2219,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        steps = 0\n        while n > 0:\n            steps += 1\n            if n % k == 0:\n                n //= k\n            else:\n                n -= 1\n        print(steps)\n    return \"\""
    },
    {
        "number": 2220,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    happiness = [int(x) for x in stdin.split()]\n\n    max_happiness = 0\n    used_emotes = set()\n\n    for i in range(n):\n        if happiness[i] > max_happiness:\n            max_happiness = happiness[i]\n            used_emotes = {i}\n        elif happiness[i] == max_happiness and i not in used_emotes:\n            used_emotes.add(i)\n\n    return str(max_happiness)"
    },
    {
        "number": 2221,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n    n = int(stdin.split()[1])\n    s = stdin.split()[2]\n\n    def move(x, y, direction):\n        if direction == 'U':\n            return x, y + 1\n        elif direction == 'D':\n            return x, y - 1\n        elif direction == 'L':\n            return x - 1, y\n        elif direction == 'R':\n            return x + 1, y\n\n    def is_valid(x, y, direction):\n        return 0 <= x < 100 and 0 <= y < 100 and s[x][y] == direction\n\n    def count_transpositions(x, y, direction):\n        count = 0\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = move(x, y, direction)\n            if is_valid(nx, ny, direction):\n                count += 1\n        return count\n\n    def count_days(x, y, direction):\n        count = 0\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = move(x, y, direction)\n            if is_valid(nx, ny, direction):\n                count += 1\n        return count\n\n    def count_moves(x, y, direction):\n        count = 0\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            nx, ny = move(x, y, direction)\n            if is_valid(nx, ny, direction):\n                count += 1\n        return count\n\n    def count_moves_and_transpositions(x, y, direction):\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n\n    def count_days_and_transpositions(x, y, direction):\n        count_days(x, y, direction)\n        count_transpositions(x, y, direction)\n\n    def count_days_and_moves(x, y, direction):\n        count_days(x, y, direction)\n        count_moves(x, y, direction)\n\n    def count_days_and_moves_and_transpositions(x, y, direction):\n        count_days(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n\n    def count_days_and_moves_and_transpositions_and_moves(x, y, direction):\n        count_days(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n        count_moves(x, y, direction)\n\n    def count_days_and_moves_and_transpositions_and_moves_and_transpositions(x, y, direction):\n        count_days(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n\n    def count_days_and_moves_and_transpositions_and_moves_and_transpositions_and_moves(x, y, direction):\n        count_days(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n        count_moves(x, y, direction)\n\n    def count_days_and_moves_and_transpositions_and_moves_and_transpositions_and_moves_and_transpositions(x, y, direction):\n        count_days(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n        count_moves(x, y, direction)\n        count_transpositions(x, y, direction)\n\n    def count_days_and_moves_and_transpositions_and_moves_and_transpositions_and_moves_and_transpositions_and_moves(x, y,"
    },
    {
        "number": 2222,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    operations = list(map(int, stdin.readline().strip().split()))\n    parents = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(node, index):\n        if node == n:\n            return 0\n\n        if operations[node] == 0:\n            return dfs(parents[node], index)\n\n        max_son = dfs(parents[node], index)\n        min_son = dfs(parents[node], index + 1)\n\n        if operations[node] == 1:\n            return max(max_son, min_son)\n        else:\n            return min(max_son, min_son)\n\n    return str(dfs(1, 0))\n"
    },
    {
        "number": 2223,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u - 1, v - 1))\n\n    def dfs(u, visited, edges):\n        visited[u] = True\n        for v, w in edges:\n            if not visited[v]:\n                dfs(v, visited, edges)\n        if len(visited) == n:\n            return True\n        return False\n\n    visited = [False] * n\n    if dfs(1, visited, edges):\n        return \"1\"\n    else:\n        return \"-1\""
    },
    {
        "number": 2224,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    paths = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        paths.append((a, b))\n\n    affected_settlements = set()\n    for path in paths:\n        a, b = path\n        affected_settlements.add(a)\n        affected_settlements.add(b)\n\n    for i in range(m):\n        if i in affected_settlements:\n            affected_settlements.remove(i)\n\n    return str(len(affected_settlements))\n"
    },
    {
        "number": 2225,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    v = 0\n    for _ in range(m):\n        p, b = map(int, stdin.split())\n        a[p] = b\n        v = a[p]\n    print(v)\n    return str(v)"
    },
    {
        "number": 2226,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        v, u, w = map(int, stdin.split())\n        edges.append((v, u, w))\n\n    graph = [[] for _ in range(n + 1)]\n    for e in edges:\n        graph[e[0]].append(e)\n        graph[e[1]].append((e[0], e[1], e[2]))\n\n    def dfs(v, path, weight):\n        if len(path) == q:\n            return weight\n\n        for e in graph[v]:\n            if e[0] == v:\n                continue\n            new_path = path + [e[0]]\n            new_weight = weight + e[2]\n            if new_weight > dfs(e[1], new_path, new_weight):\n                return dfs(e[1], new_path, new_weight)\n        return weight\n\n    return str(dfs(1, [], 0))"
    },
    {
        "number": 2227,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    text = stdin.strip()\n    count = 0\n    for i in range(len(text) - 1):\n        if text[i:i+3] == \"heavy\" and text[i+3:i+6] == \"metal\":\n            count += 1\n    return str(count)"
    },
    {
        "number": 2228,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    birth_years = list(map(int, stdin.readline().strip().split()))\n    death_years = list(map(int, stdin.readline().strip().split()))\n\n    max_birth_year = max(birth_years)\n    max_death_year = max(death_years)\n\n    max_alive_year = max_birth_year\n    max_alive_count = 0\n\n    for year in range(max_birth_year, max_death_year + 1):\n        alive_count = sum(1 for birth_year in birth_years if birth_year <= year <= death_years[0])\n        if alive_count > max_alive_count:\n            max_alive_year = year\n            max_alive_count = alive_count\n\n    return str(max_alive_year) + \" \" + str(max_alive_count)"
    },
    {
        "number": 2229,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    b = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if gcd(a[i], a[j]) == 1:\n                b.append(a[i])\n                b.append(a[j])\n                break\n\n    return''.join(map(str, b))\n\n\ndef"
    },
    {
        "number": 2230,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = []\n    for i in range(1, n+1):\n        result.append(i)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2231,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    sticks = []\n    for _ in range(n):\n        stick = list(map(int, stdin.readline().split()))\n        sticks.append(stick)\n\n    def is_valid(stick):\n        return len(stick) == 4 and all(stick[i] == stick[i + 1] for i in range(3))\n\n    def is_rectangle(stick):\n        return all(stick[i] == stick[i + 1] for i in range(3))\n\n    def is_minimal(stick):\n        return sum(stick) == sum(stick[1:])\n\n    def is_minimal_rectangle(stick):\n        return sum(stick) == sum(stick[1:]) and is_rectangle(stick)\n\n    def choose_sticks(sticks):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_valid(sticks[i]) and is_valid(sticks[j]) and is_rectangle(sticks[i]) and is_rectangle(sticks[j]):\n                    if is_minimal(sticks[i]) < is_minimal(sticks[j]):\n                        return sticks[i], sticks[j]\n\n    sticks = [sticks[i] for i in range(n)]\n    chosen_sticks = choose_sticks(sticks)\n    if chosen_sticks:\n        print(*chosen_sticks)\n    else:\n        print(\"No valid combination found\")\n\n    return \"\""
    },
    {
        "number": 2232,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.strip().split())\n        edges.append((u, v))\n\n    def dfs(u, visited, path):\n        visited[u] = True\n        path.append(u)\n        for v in edges[u]:\n            if not visited[v]:\n                dfs(v, visited, path)\n        path.pop()\n\n    visited = [False] * n\n    path = []\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited, path)\n\n    if len(path) < 2:\n        return \"No such pair of vertices\"\n\n    path.sort()\n    common_vertices = set(path)\n    max_common_vertices = len(common_vertices)\n\n    for u in range(n):\n        for v in range(u + 1, n):\n            if common_vertices.intersection(set([u, v])):\n                max_common_vertices = max(max_common_vertices, len(path))\n\n    return \" \".join(map(str, path))\n"
    },
    {
        "number": 2233,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline().strip()\n    t = stdin.readline().strip()\n\n    if s == t:\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2234,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().split())\n        A = (n, 0)\n        B = (n + 1, 0)\n        steps = 0\n        while abs(A[0] - B[0]) > k or abs(A[1] - B[1]) > k:\n            steps += 1\n            if A[0] < B[0]:\n                A = (A[0] + 1, A[1])\n            else:\n                A = (A[0] - 1, A[1])\n            if A[0] < 0 or A[0] >= n or A[1] < 0 or A[1] >= n:\n                A = (n, 0)\n            if B[0] < 0 or B[0] >= n or B[1] < 0 or B[1] >= n:\n                B = (n, 0)\n        print(steps)"
    },
    {
        "number": 2235,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    tickets = []\n    for _ in range(n):\n        t = int(stdin.strip())\n        tickets.append(t)\n\n    total_cost = sum(tickets)\n    total_cost -= sum(tickets[:1])\n    total_cost -= sum(tickets[1:])\n\n    passenger_sum = total_cost\n\n    for i in range(n - 1):\n        total_cost -= tickets[i]\n        total_cost -= tickets[i + 1]\n        passenger_sum -= tickets[i]\n        passenger_sum -= tickets[i + 1]\n\n    return str(passenger_sum)\n"
    },
    {
        "number": 2236,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    # Calculate the minimum number of operations required to change balance in each bank to zero\n    min_operations = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(a[i] - a[j]) <= 1:\n                min_operations += 1\n\n    return str(min_operations)\n"
    },
    {
        "number": 2237,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    S = set(map(int, stdin.readline().strip().split()))\n\n    x = 0\n    for i in range(n):\n        x = max(x, i + 1)\n\n    x = 2 ** x - 1\n    magical_permutations = []\n    for i in range(x + 1):\n        permutation = [i]\n        for j in range(i + 1, x + 1):\n            if j % 2 == 0:\n                if j - 1 in S:\n                    permutation.append(j - 1)\n            else:\n                if j + 1 in S:\n                    permutation.append(j + 1)\n        magical_permutations.append(permutation)\n\n    for permutation in magical_permutations:\n        print(\" \".join(map(str, permutation)))\n\n    return \" \".join(map(str, magical_permutations[0]))"
    },
    {
        "number": 2238,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    crystal = \"*\" * n + \"D\" * (n - 1) + \"*\" * n\n    return crystal"
    },
    {
        "number": 2239,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    points = [0] * t\n    for _ in range(t):\n        x = int(stdin.readline())\n        points[0] += x\n        for i in range(1, t):\n            points[i] += points[i-1]\n    return str(points[0])"
    },
    {
        "number": 2240,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    t = stdin.strip()\n\n    if len(s)!= len(t):\n        return \"0\"\n\n    count = 0\n    for i in range(len(s)):\n        if s[i] == t[i]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2241,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    max_joy = 0\n    for i in range(n):\n        if a[i] + b[i] == b[i]:\n            max_joy = max(max_joy, a[i] * b[i])\n\n    return str(max_joy)"
    },
    {
        "number": 2242,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    count = 0\n    for i in range(1, len(S) + 1):\n        for j in range(i, len(S) + 1):\n            if S[i - 1] == S[j - 1] and S[i - 1] % 2019 == 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2243,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split())\n    friends = [[] for _ in range(n)]\n    for _ in range(q):\n        type, id = map(int, stdin.split())\n        if type == 1:\n            friends[id].append(id)\n        elif type == 2:\n            if id in friends[id]:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n    return \"\""
    },
    {
        "number": 2244,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    debt_relations = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        debt_relations.append((a, b))\n\n    def is_valid(p, q):\n        return p!= q and p in debt_relations and q in debt_relations\n\n    def find_order(n):\n        if n == 1:\n            return [1]\n        if n == 2:\n            return [1, 2]\n        if n == 3:\n            return [1, 2, 3]\n        if n == 4:\n            return [1, 2, 3, 4]\n        if n == 5:\n            return [1, 2, 3, 4, 5]\n        if n == 6:\n            return [1, 2, 3, 4, 5, 6]\n        if n == 7:\n            return [1, 2, 3, 4, 5, 6, 7]\n        if n == 8:\n            return [1, 2, 3, 4, 5, 6, 7, 8]\n        if n == 9:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        if n == 10:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        if n == 11:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n        if n == 12:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n        if n == 13:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\n        if n == 14:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n        if n == 15:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n        if n == 16:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]\n        if n == 17:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]\n        if n == 18:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n        if n == 19:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]\n        if n == 20:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n        if n == 21:\n            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 1"
    },
    {
        "number": 2245,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    alice_wins = False\n    bob_wins = False\n\n    for _ in range(int(stdin.strip())):\n        n, k = map(int, stdin.split())\n\n        # Check if Alice wins this game\n        if n % 2 == 0:\n            alice_moves = [i for i in range(n) if i % 2 == 0]\n            alice_moves.append(k)\n            alice_moves.sort()\n            alice_moves = alice_moves[:k]\n            alice_moves.reverse()\n            alice_moves = [i + 1 for i in alice_moves]\n            alice_moves = [i for i in alice_moves if i <= n]\n            alice_moves = [i for i in alice_moves if i >= 0]\n            alice_moves = [i for i in alice_moves if i % 2 == 0]\n            alice_moves = [i for i in alice_moves if i!= k]\n            alice_moves = [i for i in alice_moves if i!= n - 1]\n            alice_moves = [i for i in alice_moves if i!= n - 2]\n            alice_moves = [i for i in alice_moves if i!= n - k]\n            alice_moves = [i for i in alice_moves if i!= n - 3]\n            alice_moves = [i for i in alice_moves if i!= n - 4]\n            alice_moves = [i for i in alice_moves if i!= n - k - 1]\n            alice_moves = [i for i in alice_moves if i!= n - k - 2]\n            alice_moves = [i for i in alice_moves if i!= n - k - 3]\n            alice_moves = [i for i in alice_moves if i!= n - k - 4]\n            alice_moves = [i for i in alice_moves if i!= n - k - 5]\n            alice_moves = [i for i in alice_moves if i!= n - k - 6]\n            alice_moves = [i for i in alice_moves if i!= n - k - 7]\n            alice_moves = [i for i in alice_moves if i!= n - k - 8]\n            alice_moves = [i for i in alice_moves if i!= n - k - 9]\n            alice_moves = [i for i in alice_moves if i!= n - k - 10]\n            alice_moves = [i for i in alice_moves if i!= n - k - 11]\n            alice_moves = [i for i in alice_moves if i!= n - k - 12]\n            alice_moves = [i for i in alice_moves if i!= n - k - 13]\n            alice_moves = [i for i in alice_moves if i!= n - k - 14]\n            alice_moves = [i for i in alice_moves if i!= n - k - 15]\n            alice_moves = [i for i in alice_moves if i!= n - k - 16]\n            alice_moves = [i for i in alice_moves if i!= n - k - 17]\n            alice_moves = [i for i in alice_moves if i!= n - k - 18]\n            alice_moves = [i for i in alice_moves if i!= n - k - 19]\n            alice_moves = [i for i in alice_moves if i!= n - k - 20]\n            alice_moves = [i for i in alice_moves if i!= n - k - 21]\n            alice_moves = [i for i in alice_moves if i!= n - k - 22]\n            alice_moves = [i for i in alice_moves if i!= n - k - 23]\n            alice_moves = [i for i in alice_moves if i!= n - k - 24]\n            alice_moves = [i for i in alice_moves if i!= n - k - 25]\n            alice_moves = [i for i in alice_moves if i!= n - k - 26]\n            alice_moves = [i for i in alice_moves if i!= n - k - 27]\n            alice_moves = [i for i in alice_moves if i!= n - k - 28]\n            alice_moves = [i for i in alice_moves if i!= n - k - 29]\n            alice_moves = [i for i in alice_moves if i!= n - k - 30]\n            alice"
    },
    {
        "number": 2246,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    roads = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        roads.append((u - 1, v - 1))\n\n    def expected_length(u, v):\n        if u == v:\n            return 1\n        else:\n            return 0\n\n    expected_lengths = [expected_length(u, v) for u, v in roads]\n    expected_length = sum(expected_lengths) / n\n\n    return str(expected_length)\n"
    },
    {
        "number": 2247,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    result = []\n\n    for _ in range(t):\n        s, a, b, c = map(int, stdin.readline().split())\n        result.append(max(s // c, b))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2248,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    brains = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        brains.append((a, b))\n\n    def distance(u, v):\n        return min(len(brains[u]), len(brains[v]))\n\n    def latency(u, v):\n        return max(distance(u, v), distance(v, u))\n\n    for u in range(n):\n        for v in range(u + 1, n):\n            if distance(u, v) == 0:\n                print(latency(u, v))\n                return"
    },
    {
        "number": 2249,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    numbers = list(map(int, stdin.strip().split()))\n\n    pairs = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            pairs.add((numbers[i], numbers[j]))\n\n    return str(len(pairs))\n"
    },
    {
        "number": 2250,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    count = 0\n    for i in range(n):\n        if s[i] == 'L':\n            count += 1\n        elif s[i] == 'R':\n            count -= 1\n    return str(count)"
    },
    {
        "number": 2251,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        edges.append((a, b, c))\n\n    q = int(stdin.readline())\n    result = []\n\n    for _ in range(q):\n        u, v = map(int, stdin.split())\n        if u == v:\n            result.append(0)\n        else:\n            result.append(sum([1 for edge in edges if edge[2] == 1 and (edge[0] == u or edge[1] == u) and (edge[0] == v or edge[1] == v)]))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2252,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    mom_sorted = [False] * n\n    for i in range(m):\n        l, r, x = map(int, stdin.split())\n        mom_sorted[x] = True\n    for i in range(n):\n        if mom_sorted[i]:\n            return \"No\"\n    return \"Yes\""
    },
    {
        "number": 2253,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    suffixes = [\"po\", \"desu\", \"masu\", \"mnida\"]\n    for line in stdin.splitlines():\n        sentence = line.strip()\n        if sentence.endswith(suffixes[0]):\n            return \"FILIPINO\"\n        elif sentence.endswith(suffixes[1]):\n            return \"JAPANESE\"\n        elif sentence.endswith(suffixes[2]):\n            return \"KOREAN\"\n    return \"FILIPINO\""
    },
    {
        "number": 2254,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] ^ a[j] == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2255,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(node, visited):\n        visited[node] = True\n        for neighbor in edges[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited)\n\n    visited = [False] * n\n    dfs(1, visited)\n    sequence = []\n    for node in range(1, n + 1):\n        if not visited[node]:\n            sequence.append(node)\n\n    return''.join(map(str, sequence))"
    },
    {
        "number": 2256,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, a, b = map(int, stdin.split())\n    students = [0] * n\n    for i in range(n):\n        students[i] = i + 1\n\n    for i in range(x):\n        a, b = students[a - 1], students[b - 1]\n        students[a - 1], students[b - 1] = students[b - 1], students[a - 1]\n\n    max_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            distance = abs(students[i] - students[j])\n            if distance > max_distance:\n                max_distance = distance\n\n    return str(max_distance)"
    },
    {
        "number": 2257,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x1, y1, x2, y2 = map(int, stdin.split())\n    r1 = x1 ** 2 + y1 ** 2\n    r2 = x2 ** 2 + y2 ** 2\n\n    min_r = min(r1, r2)\n    return str(min_r)"
    },
    {
        "number": 2258,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] > a[j]:\n                pairs.append((i, j))\n\n    if len(pairs) == 0:\n        return \"-1\"\n\n    m = len(pairs)\n    pairs.sort()\n\n    for i in range(m):\n        print(f\"{pairs[i][0]} {pairs[i][1]}\")\n\n    return str(m)\n"
    },
    {
        "number": 2259,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def bubble_sort_graph(G, a):\n        swapped = False\n        while not swapped:\n            swapped = False\n            for i in range(n - 1):\n                if a[i] > a[i + 1]:\n                    G.add_edge(a[i], a[i + 1])\n                    a[i], a[i + 1] = a[i + 1], a[i]\n                    swapped = True\n            if not swapped:\n                break\n\n    G = Graph()\n    bubble_sort_graph(G, a)\n    max_independent_set = G.maximal_independent_set()\n    return str(len(max_independent_set))\n"
    },
    {
        "number": 2260,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = str(int(5 ** n))[-2:]\n    return result"
    },
    {
        "number": 2261,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    result = \"\"\n    for i in range(k):\n        vector = [0] * k\n        for j in range(k):\n            vector[j] = int(input())\n        if sum(vector) == 0:\n            result += \"*\" * k + \"\\n\"\n        else:\n            result += \"+\" + \"+\" * k + \"\\n\"\n    return result"
    },
    {
        "number": 2262,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    words = []\n    for _ in range(n):\n        word = input().strip()\n        words.append(word)\n\n    objects = set()\n    for word in words:\n        root = word\n        while root in objects:\n            root = f\"{root}{root}\"\n        objects.add(root)\n\n    return str(len(objects))"
    },
    {
        "number": 2263,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    roads = []\n    for _ in range(n - 1):\n        a, b, l = map(int, stdin.split())\n        roads.append((a, b, l))\n\n    expected_cost = 0\n    for _ in range(q):\n        r, w = map(int, stdin.split())\n        expected_cost += roads[r - 1][2] + roads[w - 1][2]\n\n    return str(expected_cost)\n"
    },
    {
        "number": 2264,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        segments.append((l, r))\n\n    def is_common_point(a, b, c, d):\n        return a <= c and b <= d and c <= d and a <= b\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            a, b = segments[i]\n            c, d = segments[j]\n            if is_common_point(a, b, c, d):\n                return str(min(r - l, b - a))\n\n    return \"0\""
    },
    {
        "number": 2265,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = stdin.strip()\n    b = a[::-1]\n    count = 0\n    for i in range(len(b)):\n        if b[i] == a[i]:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2266,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, d = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    u = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    def dfs(start, visited, roads):\n        if start in visited:\n            return\n        visited.add(start)\n        for i in range(n):\n            if i == start or i in roads or (u[i] == start and v[i] == start):\n                continue\n            if i not in visited and i not in roads:\n                dfs(i, visited, roads)\n\n    def max_roads(start, visited, roads):\n        if start in visited:\n            return 0\n        visited.add(start)\n        for i in range(n):\n            if i == start or i in roads or (u[i] == start and v[i] == start):\n                continue\n            if i not in visited and i not in roads:\n                return max(max_roads(i, visited, roads), max_roads(start, visited, roads))\n        return 1\n\n    def max_roads_shutting_down(start, visited, roads):\n        if start in visited:\n            return 0\n        visited.add(start)\n        for i in range(n):\n            if i == start or i in roads or (u[i] == start and v[i] == start):\n                continue\n            if i not in visited and i not in roads:\n                return max(max_roads_shutting_down(i, visited, roads), max_roads_shutting_down(start, visited, roads))\n        return 1\n\n    dfs(1, set(), set())\n    max_roads_shutting_down(1, set(), set())\n    return \" \".join(map(str, [max_roads_shutting_down(1, set(), set())]))"
    },
    {
        "number": 2267,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = []\n    for _ in range(n):\n        a.append(stdin.strip())\n    a.sort()\n    return ''.join(a)"
    },
    {
        "number": 2268,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    names = stdin.splitlines()\n    new_names = []\n\n    for i in range(m):\n        x, y = map(str, names[i].split())\n        new_name = x + y\n        new_names.append(new_name)\n\n    return''.join(new_names)"
    },
    {
        "number": 2269,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        s = stdin.strip()\n        if len(s) == 0:\n            continue\n        if len(set(s)) < 3:\n            continue\n        for i in range(len(s) - 2):\n            if s[i] == s[i + 1] == s[i + 2]:\n                continue\n            else:\n                return s[i:i + 3]\n        return \"0\""
    },
    {
        "number": 2270,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    planks = list(map(int, stdin.split()))\n    rectangles = []\n    squares = []\n    for i in range(n):\n        if planks[i] % 2 == 0:\n            rectangles.append(planks[i])\n        else:\n            squares.append(planks[i])\n\n    for _ in range(q):\n        event = stdin.split()\n        if event[0] == '+':\n            x = int(event[1])\n            if x in rectangles:\n                rectangles.remove(x)\n            else:\n                squares.append(x)\n        elif event[0] == '-':\n            x = int(event[1])\n            if x in squares:\n                squares.remove(x)\n            else:\n                rectangles.append(x)\n\n    if len(rectangles) == 0 and len(squares) == 0:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 2271,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    lifelines = 0\n\n    for i in range(n - 1):\n        a, b = map(int, stdin.strip().split())\n        if a < b:\n            lifelines += 1\n\n    return str(lifelines)"
    },
    {
        "number": 2272,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    intervals = []\n    for _ in range(n):\n        a, b = map(int, stdin.strip().split())\n        intervals.append((a, b))\n\n    for i in range(1, len(intervals)):\n        for j in range(i + 1, len(intervals)):\n            if intervals[i][1] == intervals[j][0]:\n                return \"NO\"\n            elif intervals[i][0] < intervals[j][1] < intervals[i][1]:\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2273,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(v, visited):\n        if v in visited:\n            return False\n        visited.add(v)\n        for neighbor in edges:\n            if neighbor[0] == v or neighbor[1] == v:\n                continue\n            if dfs(neighbor[0], visited) or dfs(neighbor[1], visited):\n                return True\n        return False\n\n    visited = set()\n    for i in range(n):\n        if dfs(i, visited):\n            return \" \".join(map(str, range(1, n + 1)))\n\n    return \"-1\""
    },
    {
        "number": 2274,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    belt = [[0] * m for _ in range(n)]\n    counter = n * m\n\n    for i in range(n):\n        for j in range(m):\n            belt[i][j] = ord(stdin[i * m + j]) - ord('A')\n\n    for i in range(n):\n        for j in range(m):\n            if belt[i][j] == 0:\n                belt[i][j] = ord('R')\n                counter -= 1\n                if counter == 0:\n                    return str(i) +'' + str(j)\n\n    return '0'"
    },
    {
        "number": 2275,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n\n    for _ in range(t):\n        k, s = map(int, stdin.strip().split())\n        row = s.upper()\n\n        angry_students = [row[i] for i in range(k) if row[i] == 'A']\n        angry_students.append(row[-1])\n\n        for i in range(k - 1):\n            if angry_students[i] == 'A':\n                angry_students[i + 1] = 'P'\n            else:\n                angry_students[i + 1] = 'A'\n\n        result.append(angry_students.count('A'))\n\n    return str(max(result))\n"
    },
    {
        "number": 2276,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    s = stdin.readline().strip()\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_points = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if s[i:j] == s[i:j].replace('0', '1'):\n                max_points += a[i] + a[j]\n\n    return str(max_points)"
    },
    {
        "number": 2277,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    m = int(stdin.readline().strip())\n\n    result = []\n    for _ in range(m):\n        l, r = map(int, stdin.readline().strip().split())\n        result.append(reverse_segment(a, l, r))\n\n    odd_count = sum(1 for i in range(n) if result[i] % 2 == 1)\n    even_count = sum(1 for i in range(n) if result[i] % 2 == 0)\n\n    return f\"{odd_count}\\n{even_count}\"\n\ndef"
    },
    {
        "number": 2278,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(q):\n        a, b, m = map(int, stdin.readline().strip().split())\n        if not (1 <= a <= b <= 10**14):\n            continue\n\n        if not is_m_cute(a, b, m):\n            result.append(-1)\n            continue\n\n        sequence = [a]\n        for i in range(1, m):\n            sequence.append(sequence[-1] + sequence[-2] + sequence[-3] + sequence[-4] + sequence[-5] + sequence[-6] + sequence[-7] + sequence[-8] + sequence[-9] + sequence[-10] + sequence[-11] + sequence[-12] + sequence[-13] + sequence[-14] + sequence[-15] + sequence[-16] + sequence[-17] + sequence[-18] + sequence[-19] + sequence[-20] + sequence[-21] + sequence[-22] + sequence[-23] + sequence[-24] + sequence[-25] + sequence[-26] + sequence[-27] + sequence[-28] + sequence[-29] + sequence[-30] + sequence[-31] + sequence[-32] + sequence[-33] + sequence[-34] + sequence[-35] + sequence[-36] + sequence[-37] + sequence[-38] + sequence[-39] + sequence[-40] + sequence[-41] + sequence[-42] + sequence[-43] + sequence[-44] + sequence[-45] + sequence[-46] + sequence[-47] + sequence[-48] + sequence[-49] + sequence[-50])\n\n        if is_m_cute(sequence[0], sequence[-1], m):\n            result.append(sequence)\n\n    return '\\n'.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 2279,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    teammates = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] > a[j]:\n                teammates.append(i)\n                teammates.append(j)\n    return''.join(map(str, teammates))"
    },
    {
        "number": 2280,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    k = 0\n    for i in range(n):\n        if i == 0:\n            k = a[i]\n        else:\n            k = max(k, a[i] + k - 1)\n    return str(k)"
    },
    {
        "number": 2281,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(range(1, n+1))\n    a.sort()\n    s = sum(n - i for i in range(1, n+1))\n    return''.join(map(str, a))"
    },
    {
        "number": 2282,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    commands = stdin.strip().split()\n    positions = [0] * n\n    count = 0\n\n    for command in commands:\n        if command == 'L':\n            positions[0] -= 1\n        elif command == 'R':\n            positions[0] += 1\n        else:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2283,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    edges = []\n    for _ in range(m):\n        v, u, w = map(int, stdin.split())\n        edges.append((v, u, w))\n\n    def dfs(v, visited, parent, max_weight):\n        visited[v] = True\n        max_weight = max(max_weight, dfs(u, visited, parent, max_weight) + w)\n        return max_weight\n\n    def max_weight_subgraph(vertices, edges):\n        visited = [False] * n\n        parent = [-1] * n\n        max_weight = 0\n        for v in vertices:\n            max_weight = max(max_weight, dfs(v, visited, parent, max_weight))\n        return max_weight\n\n    max_weight = max_weight_subgraph(range(n), edges)\n    return str(max_weight)"
    },
    {
        "number": 2284,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the minimum cost of preparation and printing\n    min_cost = float('inf')\n    for i in range(1, n):\n        for j in range(i):\n            min_cost = min(min_cost, a[i] + a[j] + b[i] + b[j])\n\n    return str(min_cost)\n"
    },
    {
        "number": 2285,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    records = []\n    for line in stdin.splitlines():\n        records.append(line)\n    for i in range(len(records)):\n        for j in range(i + 1, len(records)):\n            if records[i].startswith(records[j]) and records[i].count(':') == 8:\n                records[i] = records[i].replace(records[i], '::')\n                records[j] = records[j].replace(records[j], '::')\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n                records[j] = records[j].replace('::', records[i])\n                records[i] = records[i].replace('::', records[j])\n               "
    },
    {
        "number": 2286,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    wise_men = [int(x) for x in stdin.strip()]\n    binary_strings = [\"\".join([str(x) for x in p]) for p in itertools.permutations(wise_men)]\n    count = 0\n    for binary_string in binary_strings:\n        count += sum(int(x) for x in binary_string)\n    return str(count)"
    },
    {
        "number": 2287,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n    for _ in range(t):\n        s = stdin.strip()\n        count = 0\n        for i in range(len(s)):\n            if s[i] == '1':\n                count += 1\n                if count == 1:\n                    result.append(i)\n        if len(result) == 0:\n            result.append(0)\n        result.append(len(s) - count)\n    return ''.join(map(str, result))"
    },
    {
        "number": 2288,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if b[i]!= b[j]:\n                a[i], a[j] = a[j], a[i]\n                b[i], b[j] = b[j], b[i]\n\n    if a == sorted(a):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2289,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    k = list(map(int, stdin.split()))\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):\n        for j in range(i):\n            standing_warriors[i] += a[j]\n\n    # Calculate the number of standing warriors after each minute\n    standing_warriors = [0] * q\n    for i in range(1, q + 1):"
    },
    {
        "number": 2290,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(node, visited):\n        if node in visited:\n            return False\n        visited.add(node)\n        for neighbor in edges[node - 1]:\n            if neighbor not in visited and dfs(neighbor, visited):\n                return True\n        return False\n\n    for node in range(1, n + 1):\n        if not dfs(node, set()):\n            return \"0\"\n\n    return \"1\""
    },
    {
        "number": 2291,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    X = 3\n    min_val = float('inf')\n\n    for i in range(n):\n        val = a[i] ^ X\n        if val < min_val:\n            min_val = val\n\n    return str(min_val)"
    },
    {
        "number": 2292,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        a = list(map(int, stdin.strip().split()))\n        b = list(map(int, stdin.strip().split()))\n        for i in range(n):\n            if i < n // 2:\n                a[i], a[n - i - 1] = a[n - i - 1], a[i]\n            else:\n                a[i], a[n - i - 1] = a[i], a[n - i - 1]\n        for i in range(n):\n            if i < n // 2:\n                b[i], b[n - i - 1] = b[n - i - 1], b[i]\n            else:\n                b[i], b[n - i - 1] = b[i], b[n - i - 1]\n        if a == b:\n            print(\"yes\")\n        else:\n            print(\"No\")\n    return \"\""
    },
    {
        "number": 2293,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    swiper_buy = [0] * n\n    dora_buy = [0] * n\n\n    for i in range(m):\n        swiper_buy[a[i] - 1] += 1\n\n    for i in range(m, n):\n        dora_buy[i - m] += 1\n\n    for i in range(n):\n        if swiper_buy[i] > dora_buy[i]:\n            return \"impossible\"\n\n    return \"possible\""
    },
    {
        "number": 2294,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    multiset = set()\n    for _ in range(n):\n        a, t, x = map(int, stdin.strip().split())\n        if a == 1:\n            multiset.add(x)\n        elif a == 2:\n            multiset.remove(x)\n        else:\n            multiset.discard(x)\n    return str(len(multiset))\n"
    },
    {
        "number": 2295,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    l, r = 1, n\n    while l <= r:\n        mid = (l + r) // 2\n        count = 0\n        for i in range(mid):\n            count += a[i]\n        if count == mid:\n            r = mid - 1\n        else:\n            l = mid + 1\n\n    return str(l)"
    },
    {
        "number": 2296,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    polygon = list(map(int, stdin.split()))\n    queries = list(map(int, stdin.split()))\n\n    def rotate_polygon(polygon):\n        n = len(polygon)\n        for i in range(n // 2):\n            polygon[i], polygon[n - i - 1] = polygon[n - i - 1], polygon[i]\n        return polygon\n\n    def is_stable(polygon):\n        n = len(polygon)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if polygon[i] * polygon[j] < 0:\n                    return False\n        return True\n\n    def get_coordinates(polygon, vertex):\n        n = len(polygon)\n        for i in range(n):\n            if polygon[i] == vertex:\n                return i\n        return -1\n\n    def solve(queries):\n        for query in queries:\n            if query == 1:\n                f, t = queries[queries.index(1) + 1]\n                polygon = rotate_polygon(polygon)\n                if is_stable(polygon):\n                    polygon[f], polygon[t] = polygon[t], polygon[f]\n                else:\n                    polygon = rotate_polygon(polygon)\n            elif query == 2:\n                v = queries[queries.index(2) + 1]\n                vertex = get_coordinates(polygon, v)\n                if vertex!= -1:\n                    print(polygon[vertex])\n                else:\n                    print(\"Vertex not found\")\n\n    solve(queries)\n    return \"\""
    },
    {
        "number": 2297,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline().strip())\n    answers = []\n\n    for _ in range(q):\n        l, r = map(int, stdin.readline().strip().split())\n        a = [-1] * (r + 1)\n        for i in range(1, r + 1):\n            a[i] = i * (-1) ** i\n\n        for i in range(l, r + 1):\n            answers.append(a[i])\n\n    return '\\n'.join(map(str, answers))"
    },
    {
        "number": 2298,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, q = map(int, stdin.readline().split())\n        queries = []\n        for _ in range(q):\n            queries.append(list(map(int, stdin.readline().split())))\n        result = []\n        for query in queries:\n            l, r = query\n            count = 0\n            for x in range(l, r + 1):\n                if ((x % a) % b)!= ((x % b) % a):\n                    count += 1\n            result.append(count)\n        print(*result)\n    return \"\""
    },
    {
        "number": 2299,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    table = [list(map(int, stdin.split())) for _ in range(n)]\n    k = int(stdin.split()[0])\n    l, r = map(int, stdin.split())\n\n    for _ in range(k):\n        l, r = map(int, stdin.split())\n\n    for i in range(n):\n        for j in range(m):\n            if j == 0:\n                continue\n            if table[i][j] > table[i][j - 1]:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2300,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n    f = [1] * (n + 1)\n    f[0] = 1\n    f[1] = 1\n    for i in range(2, n + 1):\n        f[i] = (f[i - 1] - 1 + f[i - 2]) % 1000000000\n\n    for _ in range(m):\n        t, *args = map(int, stdin.split())\n        if t == 1:\n            x, v = args\n            a[x - 1][v - 1] = v\n        elif t == 2:\n            l, r = args\n            for x in range(l - 1, r + 1):\n                a[x - 1][x - 1] += 1\n        elif t == 3:\n            l, r, d = args\n            for x in range(l - 1, r + 1):\n                a[x - 1][x - 1] += d\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            result += (f[j] * a[i][j - 1]) % 1000000000\n    return str(result)\n"
    },
    {
        "number": 2301,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    prices = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the prices in ascending order\n    prices.sort()\n\n    # Initialize the maximum number of ice spheres to buy\n    max_num_ice_spheres = 0\n\n    # Initialize the current number of ice spheres to buy\n    current_num_ice_spheres = 0\n\n    # Iterate through the prices\n    for i in range(1, n):\n        # If the current price is less than the price of the next ice sphere,\n        # then the current ice sphere is cheap\n        if prices[i] < prices[i - 1]:\n            current_num_ice_spheres += 1\n        else:\n            # If the current price is greater than or equal to the price of the next ice sphere,\n            # then the current ice sphere is not cheap\n            current_num_ice_spheres = 1\n\n        # If the current ice sphere is the maximum number of ice spheres to buy,\n        # then update the maximum number of ice spheres to buy\n        if current_num_ice_spheres > max_num_ice_spheres:\n            max_num_ice_spheres = current_num_ice_spheres\n\n    # Print the maximum number of ice spheres to buy\n    print(max_num_ice_spheres)\n\n    # Initialize the optimal order of ice spheres\n    optimal_order = []\n\n    # Iterate through the prices\n    for i in range(n):\n        # If the current price is less than the price of the next ice sphere,\n        # then the current ice sphere is cheap\n        if prices[i] < prices[i - 1]:\n            optimal_order.append(prices[i])\n        else:\n            # If the current price is greater than or equal to the price of the next ice sphere,\n            # then the current ice sphere is not cheap\n            optimal_order.append(prices[i - 1])\n\n    # Print the optimal order of ice spheres\n    print(\" \".join(map(str, optimal_order)))\n\n    return \"\""
    },
    {
        "number": 2302,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a = map(int, stdin.split())\n    q = int(stdin.readline())\n    milestones = []\n\n    for _ in range(q):\n        s, t, u = map(int, stdin.split())\n        if s == u:\n            continue\n        if s in milestones and t == milestones[s][1]:\n            milestones.remove(s)\n        if t > a[s]:\n            continue\n        milestones.append((s, t, u))\n\n    if not milestones:\n        return \"0\"\n\n    min_turns = float('inf')\n    for s, t, u in milestones:\n        if t == a[s]:\n            min_turns = min(min_turns, t)\n\n    return str(min_turns)\n"
    },
    {
        "number": 2303,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    reversed_words = []\n    for word in words[::-1]:\n        reversed_words.append(word)\n    return''.join(reversed_words)"
    },
    {
        "number": 2304,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    positions = []\n    for _ in range(M):\n        L, R, D = map(int, stdin.split())\n        positions.append((L, R, D))\n\n    def is_consistent(x):\n        for i in range(M):\n            if positions[i][0] <= x <= positions[i][1]:\n                if positions[i][2]!= positions[i][3]:\n                    return False\n        return True\n\n    if all(is_consistent(x) for x in range(N)):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2305,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    colors = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def dfs(u, visited, color):\n        if u in visited:\n            return\n        visited.add(u)\n        for v, w in edges[u]:\n            if w == color:\n                dfs(v, visited, color)\n\n    visited = set()\n    for i in range(1, n):\n        dfs(i, visited, colors[i - 1])\n\n    result = []\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if colors[i - 1] == colors[j - 1]:\n                result.append(1)\n            else:\n                result.append(0)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2306,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    t = list(map(int, stdin.readline().strip().split()))\n    v = list(map(int, stdin.readline().strip().split()))\n\n    max_distance = 0\n    for i in range(N):\n        distance = t[i] + v[i]\n        max_distance = max(max_distance, distance)\n\n    return str(max_distance)"
    },
    {
        "number": 2307,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n    soldiers = []\n    for i in range(N):\n        soldiers.append(A[i])\n    count_lucky = 0\n    count_unlucky = 0\n    for i in range(N):\n        if soldiers[i] % 2 == 0:\n            count_lucky += 1\n        else:\n            count_unlucky += 1\n    if count_lucky > count_unlucky:\n        return \"READY FOR BATTLE\"\n    else:\n        return \"NOT READY\""
    },
    {
        "number": 2308,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        x = stdin.readline().strip()\n        y = stdin.readline().strip()\n        k = int(stdin.readline())\n        s_k = f(x) + f(y) ** k\n        rev_k = bin(s_k)[2:].zfill(len(x))\n        print(k, end=\" \")\n        for i in range(len(rev_k)):\n            print(rev_k[i], end=\"\")\n        print()\n\ndef"
    },
    {
        "number": 2309,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    words = []\n    for _ in range(n):\n        word = input().strip()\n        words.append(word)\n\n    m = len(words)\n    beautiful_lyrics = []\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if words[i] == words[j]:\n                if len(words[i]) == len(words[j]) - 1 and words[i][-1] == words[j][-1]:\n                    beautiful_lyrics.append(\" \".join(words[i]))\n\n    return str(len(beautiful_lyrics)) + \"\\n\" + \"\\n\".join(beautiful_lyrics)"
    },
    {
        "number": 2310,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    dishes = []\n    for _ in range(t):\n        m, k = map(int, stdin.strip().split())\n        dishes.append(m)\n        dishes.append(k)\n\n    for _ in range(t - 1):\n        dish_given = int(stdin.strip())\n        if dish_given == 0:\n            dish_given = dishes.pop()\n        else:\n            dishes.append(dish_given)\n\n    for i in range(m - 1):\n        dish_given = int(stdin.strip())\n        if dish_given == 0:\n            dish_given = dishes.pop()\n        else:\n            dishes.append(dish_given)\n\n    result = \"\"\n    for dish in dishes:\n        if dish == 0:\n            result += \"N\"\n        else:\n            result += \"Y\"\n\n    return result"
    },
    {
        "number": 2311,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    c = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            c[i][j] = a[i] * b[j]\n\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if c[i][j] == 1:\n                count += 1\n                if count == k:\n                    return str(count)\n\n    return str(count)"
    },
    {
        "number": 2312,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    # Find the two non-intersecting subarrays\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] + a[j] == b[i] + b[j]:\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2313,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    c = list(map(int, stdin.strip().split()))\n\n    # Calculate the expected value of players earnings\n    expected_value = sum(c) / n\n\n    # Calculate the minimum possible expected value\n    min_expected_value = expected_value * (n - 1) / n\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible expected value\n    min_expected_value = min(min_expected_value, expected_value)\n\n    # Calculate the minimum possible"
    },
    {
        "number": 2314,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    adhami_picture = []\n    for _ in range(n):\n        adhami_picture.append(list(stdin.strip()))\n\n    options = []\n    for _ in range(q):\n        r1, c1, r2, c2 = map(int, stdin.strip().split())\n        options.append((r1, c1, r2, c2))\n\n    max_area = 0\n    for option in options:\n        sub_rectangle = adhami_picture[option[0]:option[1] + 1][option[2]:option[3] + 1]\n        max_area = max(max_area, max(sub_rectangle, key=len))\n\n    return str(max_area)\n"
    },
    {
        "number": 2315,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    result = []\n\n    for _ in range(T):\n        l, r = map(int, stdin.readline().split())\n        if l > r:\n            continue\n\n        for x in range(l, r + 1):\n            if x % y == 0:\n                continue\n\n            for y in range(x + 1, r + 1):\n                if y % x == 0:\n                    continue\n\n                if l <= x <= y <= r:\n                    result.append((x, y))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2316,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        x, n, m = map(int, stdin.strip().split())\n        if x <= 0 or n > 30 or m > 30:\n            continue\n        if n > m:\n            n, m = m, n\n        if n == 0 or m == 0:\n            print(\"YES\")\n            continue\n        if n > 0:\n            h = x // 2\n            if h % 2 == 0:\n                h -= 1\n            else:\n                h += 1\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h, x)\n            h = max(h, 0)\n            h = min(h"
    },
    {
        "number": 2317,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a, b = map(int, stdin.split())\n    l = map(int, stdin.split())\n\n    # Find the point C with abscissa at least b\n    for i in range(m):\n        for j in range(m):\n            if abs(b - a) <= l[i]:\n                c = (a + b) / 2\n                if abs(c - a) <= abs(b - a):\n                    return str(i + 1) + \" \" + str(j + 1)\n\n    return \"0 0\""
    },
    {
        "number": 2318,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    pairs = []\n    for line in stdin.splitlines():\n        s, t = line.strip().split()\n        pairs.append((s, t))\n\n    for s, t in pairs:\n        if t in s:\n            return \"YES\"\n        elif t in s + t:\n            return \"NO\"\n\n    return \"NO\""
    },
    {
        "number": 2319,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        if s == t:\n            print(0)\n        else:\n            operations = 0\n            for i in range(n):\n                operations += 1\n                s = s[1:] + s[:1]\n            print(operations)"
    },
    {
        "number": 2320,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    t = stdin.strip()\n\n    moves = []\n    for i in range(n):\n        if i == 0:\n            moves.append(\"move to the beginning\")\n        elif i == n - 1:\n            moves.append(\"move to the end\")\n        else:\n            moves.append(\"move to the middle\")\n\n    moves = \"\".join(moves)\n\n    if moves == \"move to the beginning\":\n        return s\n    elif moves == \"move to the end\":\n        return t\n    else:\n        return \"impossible\""
    },
    {
        "number": 2321,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    s = stdin.readline()\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')\n    s = s.replace('>', '')\n    s = s.replace('<', '')"
    },
    {
        "number": 2323,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(map(int, stdin.strip().split()))\n    q = int(stdin.strip())\n    result = []\n\n    for _ in range(q):\n        l, r = map(int, stdin.strip().split())\n        result.append(len(set(range(l, r + 1))))\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2324,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    palindromic_count = 0\n    for i in range(n // 2):\n        if s[i] == s[n - i - 1]:\n            palindromic_count += 1\n    return str(palindromic_count) + \" \" + str(palindromic_count - 1) + \" \" + str(palindromic_count - 2) + \" \" + str(palindromic_count - 3)"
    },
    {
        "number": 2325,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n):\n        if len(set(y[i])) == len(y[i]):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2326,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] == j - 1 and a[i] > 0:\n                count += 1\n\n    return str(count % 998244353)"
    },
    {
        "number": 2327,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    unfairness = 0\n    for i in range(n):\n        rating = int(stdin.strip())\n        if rating == 0:\n            unfairness += 1\n        elif rating == 1:\n            unfairness += 2\n        elif rating == 2:\n            unfairness += 1\n        elif rating == 3:\n            unfairness += 1\n        elif rating == 4:\n            unfairness += 1\n        elif rating == 5:\n            unfairness += 1\n        else:\n            unfairness += 1\n    return str(unfairness)"
    },
    {
        "number": 2328,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    d = [abs(x - a[i]) for i in range(n)]\n    d.sort()\n    d.append(d[k])\n    for i in range(k + 1, len(d)):\n        if d[i] - d[i - 1] < d[i] - d[i - 2]:\n            return str(d[i])\n    return str(d[-1])"
    },
    {
        "number": 2329,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    towers = [[] for _ in range(m)]\n    for i in range(n):\n        towers[i].append(i)\n\n    for i in range(m - 1):\n        a, b = map(int, stdin.split())\n        towers[a].append(b)\n        towers[b].append(a)\n\n    for i in range(m):\n        towers[i].sort(reverse=True)\n\n    for i in range(m - 1):\n        for j in range(i + 1, m):\n            if towers[i][-1] > towers[j][0]:\n                towers[i].append(towers[j].pop())\n\n    result = []\n    for i in range(m):\n        result.append(i)\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2330,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    fridges = [[] for _ in range(n)]\n    for i in range(m):\n        u, v = map(int, stdin.split())\n        fridges[u-1].append(v-1)\n        fridges[v-1].append(u-1)\n    total_cost = 0\n    for i in range(n):\n        if not any(fridges[i]):\n            total_cost += i * (i + 1) // 2\n    return str(total_cost)"
    },
    {
        "number": 2331,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        if a == 1 and b == 1:\n            print(\"Infinite\")\n        else:\n            print(\"Finite\")"
    },
    {
        "number": 2332,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    groups = []\n    for _ in range(k):\n        x, *indices = map(int, stdin.split())\n        groups.append((x, indices))\n\n    message = stdin.split()\n    message = [word for word in message if word not in groups]\n    message = message[:m]\n\n    def replace_word(word, groups):\n        for group in groups:\n            if word in group[1]:\n                return group[0]\n        return word\n\n    def cost(word, groups):\n        cost = 0\n        for group in groups:\n            if word in group[1]:\n                cost += group[0]\n        return cost\n\n    min_cost = float('inf')\n    for word in message:\n        new_word = replace_word(word, groups)\n        new_cost = cost(new_word, groups)\n        if new_cost < min_cost:\n            min_cost = new_cost\n\n    return str(min_cost)\n"
    },
    {
        "number": 2333,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(j + 1, n + 1):\n                for l in range(k + 1, n + 1):\n                    if a[i] == a[j] == a[k] == a[l]:\n                        count += 1\n\n    return str(count)"
    },
    {
        "number": 2334,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    x = int(stdin.readline().strip())\n    f = int(stdin.readline().strip())\n\n    total_fee = 0\n    for i in range(N):\n        total_fee += a[i] * (x // a[i])\n\n    return str(total_fee)"
    },
    {
        "number": 2335,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        point = list(map(int, stdin.readline().strip().split()))\n        points.append(point)\n\n    edges = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if points[i][2] == points[j][2]:\n                edges.append((i, j, points[i][0] - points[j][0]))\n\n    edges.sort(key=lambda x: x[2])\n\n    min_cost = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            cost = edges[i][2] + edges[j][2]\n            if cost < min_cost:\n                min_cost = cost\n\n    return str(min_cost)\n"
    },
    {
        "number": 2336,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, q = map(int, stdin.split())\n    recipes = []\n    for _ in range(n):\n        l, r = map(int, stdin.split())\n        recipes.append((l, r))\n\n    admissible_temps = []\n    for i in range(k):\n        for l, r in recipes:\n            if l <= r:\n                admissible_temps.append(r)\n                break\n\n    return str(len(admissible_temps))\n"
    },
    {
        "number": 2337,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    # Calculate the minimum number of problems needed\n    min_problems = n + m\n\n    # Calculate the maximum complexity of the problems\n    max_c = max(a)\n    max_d = max(b)\n\n    # Calculate the minimum complexity of the problems\n    min_c = min(a)\n    min_d = min(b)\n\n    # Calculate the number of problems needed\n    num_problems = min_problems\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, n + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, m + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, n + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, m + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, n + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, m + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_d + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, min_c + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, n + 1):\n        num_problems += a.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, m + 1):\n        num_problems += b.count(i)\n\n    # Calculate the number of problems needed for each complexity\n    for i in range(1, max_d + 1):"
    },
    {
        "number": 2338,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    bombs = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        bombs.append((x, y))\n\n    def is_valid(x, y):\n        for bomb in bombs:\n            if x == bomb[0] and y == bomb[1]:\n                return False\n        return True\n\n    def is_reachable(x, y):\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in bombs and is_valid(nx, ny):\n                return True\n        return False\n\n    def shortest_path(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bombs(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bombs(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bomb_containers(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bomb_containers_and_all_bombs(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers_and_all_bombs(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers_and_all_bombs(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable(x + dx, y + dy):\n            path.append((x + dx, y + dy))\n            x, y = x + dx, y + dy\n        return path\n\n    def shortest_path_to_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers_and_all_bomb_containers_and_all_bombs(x, y, dx, dy):\n        path = [(x, y)]\n        while is_reachable("
    },
    {
        "number": 2339,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = []\n    for i in range(n):\n        b.append(a[i])\n    for i in range(1, n):\n        for j in range(i):\n            if a[i] % a[j]!= 0:\n                break\n        else:\n            b.append(a[i])\n    return''.join(map(str, b))"
    },
    {
        "number": 2340,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, n = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # Calculate the number of magic crystals needed to reach the ground level\n    magic_crystals = 0\n    for i in range(1, h + 1):\n        if i in p:\n            magic_crystals += 1\n\n    return str(magic_crystals)\n"
    },
    {
        "number": 2341,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    dress_patterns = []\n    for _ in range(n):\n        dress_patterns.append(list(stdin.strip()))\n\n    def is_valid_dress_pattern(dress_pattern):\n        for i in range(len(dress_pattern)):\n            for j in range(i + 1, len(dress_pattern)):\n                if dress_pattern[i] == dress_pattern[j]:\n                    return False\n        return True\n\n    def count_ways(dress_pattern):\n        ways = 0\n        for i in range(len(dress_pattern)):\n            for j in range(i + 1, len(dress_pattern)):\n                if is_valid_dress_pattern(dress_pattern[:i] + dress_pattern[i + 1:]):\n                    ways += 1\n        return ways\n\n    for dress_pattern in dress_patterns:\n        if is_valid_dress_pattern(dress_pattern):\n            ways = count_ways(dress_pattern)\n            if ways > 0:\n                return str(ways)\n\n    return \"No valid dress patterns found.\""
    },
    {
        "number": 2342,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    maze = [['.' for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            maze[i][j] = stdin.pop(0)\n\n    def dfs(i, j):\n        if i < 0 or i >= n or j < 0 or j >= m or maze[i][j] == '#':\n            return False\n\n        if maze[i][j] == 'G':\n            maze[i][j] = '.'\n            dfs(i - 1, j)\n            dfs(i + 1, j)\n            dfs(i, j - 1)\n            dfs(i, j + 1)\n        elif maze[i][j] == 'B':\n            return False\n\n        return True\n\n    for i in range(n):\n        for j in range(m):\n            if maze[i][j] == 'G':\n                if not dfs(i, j):\n                    return 'No'\n\n    return 'Yes'"
    },
    {
        "number": 2343,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n_i, k_i = map(int, stdin.readline().split())\n        if n_i == 1 and k_i == 1:\n            print(\"YES 0\")\n        elif n_i == 2 and k_i == 1:\n            print(\"YES 1\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2344,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    offers = []\n    for _ in range(n):\n        a, b, k = map(int, stdin.readline().strip().split())\n        offers.append((a, b, k))\n\n    def max_price(credits):\n        total_burles = sum(credits)\n        max_price = 0\n        for i in range(1, n + 1):\n            if i in credits:\n                max_price = max(max_price, total_burles // i)\n            else:\n                max_price = max(max_price, total_burles // i)\n                total_burles -= credits[i - 1] * i\n        return max_price\n\n    max_price_of_car = max_price([0] * n)\n    for a, b, k in offers:\n        max_price_of_car = max(max_price_of_car, a + b + k)\n\n    return str(max_price_of_car)\n"
    },
    {
        "number": 2345,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def find_subset(start, target):\n        if target == 0:\n            return [start]\n\n        if target < 0:\n            return []\n\n        subset = []\n        for i in range(start, n):\n            if i - start + 1 not in subset:\n                subset.append(i - start + 1)\n                subset = find_subset(i + 1, target - a[start])\n                if subset:\n                    return subset\n        return []\n\n    subset = find_subset(0, n)\n    if subset:\n        print(len(subset))\n        for i in subset:\n            print(i)\n    else:\n        print(\"No subset found with zero-sum.\")\n\n    return \"\""
    },
    {
        "number": 2346,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    tree = []\n    for _ in range(n):\n        p, c = map(int, stdin.readline().strip().split())\n        tree.append((p, c))\n\n    def dfs(v, parent):\n        if v == -1:\n            return\n        if v not in visited:\n            visited.add(v)\n            for child in tree[v]:\n                if child[0]!= parent:\n                    dfs(child[0], v)\n\n    visited = set()\n    dfs(1, -1)\n    result = []\n    for v in visited:\n        result.append(v)\n    return''.join(map(str, result))"
    },
    {
        "number": 2347,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        p = stdin.strip()\n        h = stdin.strip()\n        if p == h:\n            return \"YES\"\n        else:\n            return \"NO\""
    },
    {
        "number": 2348,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_str = stdin.strip()\n    input_int = int(input_str, 16)\n\n    # Check if the input is valid\n    if input_int < 0 or input_int > 16**7 - 1:\n        return \"Invalid input\"\n\n    # Convert the input to binary\n    binary_str = bin(input_int)[2:]\n\n    # Reverse the binary string\n    reversed_binary_str = binary_str[::-1]\n\n    # Convert the reversed binary string to decimal\n    decimal_str = \"\"\n    for digit in reversed_binary_str:\n        decimal_str += str(int(digit))\n\n    # Convert the decimal string to an integer\n    decimal_int = int(decimal_str)\n\n    # Return the result\n    return str(decimal_int)"
    },
    {
        "number": 2349,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    rating_units = [i for i in range(1, n+1)]\n    rating_units.sort()\n    result = []\n    for i in range(1, k+1):\n        result.append(rating_units[i-1])\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2350,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        x1, y1, x2, y2 = map(int, stdin.strip().split())\n        if x1 == x2 and y1 == y2:\n            print(\"0\")\n            continue\n        if x1 == x2:\n            x1 += 1\n        if y1 == y2:\n            y1 += 1\n        if x1 > x2:\n            x1, x2 = x2, x1\n        if y1 > y2:\n            y1, y2 = y2, y1\n        dx = [0, 1, 0, -1]\n        dy = [1, 0, -1, 0]\n        path = []\n        path.append((x1, y1))\n        while path[-1]!= (x2, y2):\n            path.append((path[-1][0] + dx[path[-1][1]], path[-1][1] + dy[path[-1][0]]))\n        path.append((x2, y2))\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x1 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y1]\n        path.sort()\n        path = [p for p in path if p[0]!= x2 and p[1]!= y2]\n        path.sort()\n        path = [p for p in path "
    },
    {
        "number": 2351,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, len = map(int, stdin.split())\n    arr = list(map(int, stdin.split()))\n\n    # Count the number of ways to replace each -1 with a number from 1 to k\n    count = 0\n    for i in range(n):\n        if arr[i] == -1:\n            count += 1\n            for j in range(i + 1, n):\n                if arr[j] == -1:\n                    count += 1\n                    break\n\n    # Print the result modulo 998244353\n    print(count % (10**9 + 7))\n\n    return \"\""
    },
    {
        "number": 2352,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    snakes = []\n    for _ in range(n):\n        snake = []\n        for _ in range(m):\n            snake.append(input())\n        snakes.append(snake)\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] == '.':\n                continue\n            for k in range(i + 1, n):\n                if snakes[k][j] == '.':\n                    continue\n                for l in range(j + 1, m):\n                    if snakes[k][l] == '.':\n                        continue\n                    if (i - k) ** 2 + (j - l) ** 2 <= 1:\n                        snakes[i][j] = snakes[k][l]\n                        snakes[k][l] = '.'\n                        break\n\n    for i in range(n):\n        for j in range(m):\n            if snakes[i][j] =="
    },
    {
        "number": 2353,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.strip().split())\n        if a + b + c + d <= 0:\n            print(-1)\n            continue\n        if a + b + c + d <= 10:\n            print(a + b + c + d)\n            continue\n        if a + b + c + d <= 100:\n            print(a + b + c + d)\n            continue\n        if a + b + c + d <= 1000:\n            print(a + b + c + d)\n            continue\n        print(-1)"
    },
    {
        "number": 2354,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    for i in range(q):\n        x, y = map(int, stdin.split())\n        board[x - 1][y - 1] += 1\n    result = \"\"\n    for row in board:\n        result += \" \".join(map(str, row)) + \"\\n\"\n    return result"
    },
    {
        "number": 2355,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(p):\n        a, b = map(int, stdin.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for k in range(2, n + 1):\n        if len(set(graph[i]) & set(graph[:k])) > 2 * k + p:\n            return \"Error: The graph doesn't contain multiple edges.\"\n\n    for k in range(1, n + 1):\n        if len(set(graph[i]) & set(graph[k])) > 2 * k + p:\n            return \"Error: The graph doesn't contain at most 2k + p edges.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            if graph[i] & graph[j]:\n                return \"Error: The graph contains self-loops.\"\n\n    for i in range(1, n + 1):"
    },
    {
        "number": 2356,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        shuffled_a = a.copy()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if j - a[i]!= i - a[j]:\n                    shuffled_a[i], shuffled_a[j] = shuffled_a[j], shuffled_a[i]\n        print(\" \".join(map(str, shuffled_a)))"
    },
    {
        "number": 2357,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def dominated(t, v):\n        occ = {}\n        for num in t:\n            if num in occ:\n                occ[num] += 1\n            else:\n                occ[num] = 1\n\n        return occ[v] > occ[v]\n\n    dominated_subarrays = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if dominated(a[i:j+1], a[i]):\n                dominated_subarrays.append(j - i + 1)\n\n    if not dominated_subarrays:\n        return \"-1\"\n\n    return str(min(dominated_subarrays))\n"
    },
    {
        "number": 2358,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n % 2 == 0 and n > 1:\n        for i in range(n // 2):\n            if s[i] == '(':\n                s = s[:i] + s[i+1:] + s[i+2:]\n            else:\n                s = s[:i] + s[i+1:] + s[i+2:]\n        return s\n    else:\n        return \"0\""
    },
    {
        "number": 2359,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        h, c, t = map(int, stdin.readline().split())\n        if c < h:\n            continue\n        if c == h:\n            print(1)\n            continue\n        if c < t:\n            print(1)\n            continue\n        if c == t:\n            print(1)\n            continue\n        if c < t:\n            print(1)\n            continue\n        print(1)"
    },
    {
        "number": 2360,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        queue = []\n        for i in range(2, n):\n            if l - 1 <= l[i]:\n                queue.append(i)\n        if not queue:\n            result.append(0)\n        else:\n            result.append(queue[0])\n            for i in range(1, len(queue)):\n                if queue[i] - queue[i - 1] == 1:\n                    result.append(queue[i])\n                else:\n                    result.append(0)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2361,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    max_points = 0\n    for i in range(k):\n        points = 0\n        for j in range(n // k):\n            points += (m - 1) * (k - 1)\n        max_points = max(max_points, points)\n    return str(max_points)"
    },
    {
        "number": 2362,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    edges = []\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().strip().split())\n        edges.append((x, y))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def dist(x, y):\n        if x == y:\n            return 1\n        return 1 + dist(x + 1, y)\n\n    max_dist = 0\n    for x, y in edges:\n        if gcd(g(x, y), 1) > 1:\n            max_dist = max(max_dist, dist(x, y))\n\n    if max_dist == 0:\n        return \"0\"\n    else:\n        return str(max_dist)\n"
    },
    {
        "number": 2363,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    operations = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.strip().split())\n        operations.append(a - b)\n\n    return '\\n'.join(map(str, operations))"
    },
    {
        "number": 2364,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    p = 1\n    for i in range(1, n):\n        p = (p * 2 ** i) % 998244353\n\n    return str(p * 2 ** n)"
    },
    {
        "number": 2365,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expression = stdin.strip()\n    stack = []\n    result = \"\"\n\n    for char in expression:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return \"Invalid expression\"\n            result += stack.pop()\n        elif char == '&':\n            if not stack:\n                return \"Invalid expression\"\n            if len(stack) < 2:\n                return \"Invalid expression\"\n            result += str(stack.pop() and stack.pop())\n        elif char == '|':\n            if not stack:\n                return \"Invalid expression\"\n            if len(stack) < 2:\n                return \"Invalid expression\"\n            result += str(stack.pop() or stack.pop())\n        elif char == '!':\n            if not stack:\n                return \"Invalid expression\"\n            result += str(not stack.pop())\n        elif char == 't':\n            result += \"True\"\n        elif char == 'f':\n            result += \"False\"\n        elif char == ',':\n            if not stack:\n                return \"Invalid expression\"\n            result += stack.pop()\n\n    if stack:\n        return \"Invalid expression\"\n\n    return result"
    },
    {
        "number": 2366,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n\n    # Initialize the dp array\n    dp = [1] * (n + 1)\n\n    # Fill the dp array\n    for i in range(2, n + 1):\n        dp[i] = dp[i - 1] + dp[i - 2]\n\n    # Find the number of ways to choose two distinct balls\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n + 1):\n            if A[i] == A[j]:\n                count += dp[j] - dp[i]\n\n    return str(count)\n"
    },
    {
        "number": 2367,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    A, B = map(int, stdin.split())\n\n    # Check if the number of forbidden cells is less than or equal to the number of rows\n    if A * B > H * W:\n        return \"0\"\n\n    # Initialize the memoization table\n    memo = [[0] * W for _ in range(H)]\n\n    # Base case: if the bottom-right cell is the only cell in the grid, return 1\n    if H == 1 and W == 1:\n        return \"1\"\n\n    # Recursive case: if the bottom-right cell is not the only cell in the grid,\n    # calculate the number of ways to travel to the bottom-right cell\n    ways = 0\n    for i in range(H - 1):\n        for j in range(W - 1):\n            # Check if the current cell is the bottom-right cell\n            if i == H - 2 and j == W - 2:\n                ways += 1\n                continue\n\n            # Check if the current cell is in the intersection of the bottom A rows and the leftmost B columns\n            if i >= A and j >= B:\n                continue\n\n            # Check if the current cell is forbidden\n            if memo[i][j] == 1:\n                continue\n\n            # Update the memoization table\n            memo[i + 1][j + 1] = memo[i][j] + 1\n\n    # Print the result modulo 10^9+7\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 2368,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    c = list(map(int, stdin.split()))\n    d = list(map(int, stdin.split()))\n\n    for i in range(n):\n        if a[i] == 0:\n            a[i] = 1\n\n    for i in range(m):\n        if b[i] == 0:\n            b[i] = 1\n\n    for i in range(n):\n        for j in range(m):\n            if c[i] == d[j]:\n                return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2369,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    # Sort the elements in ascending order\n    A.sort()\n\n    # Initialize the variables\n    max_val = float('-inf')\n    min_val = float('inf')\n    count = 0\n\n    # Iterate through the elements\n    for i in range(N):\n        # Check if the current element is greater than the maximum value\n        if A[i] > max_val:\n            # Update the maximum value\n            max_val = A[i]\n\n        # Check if the current element is less than the minimum value\n        if A[i] < min_val:\n            # Update the minimum value\n            min_val = A[i]\n\n        # If the current element is equal to the maximum value, increment the count\n        if A[i] == max_val:\n            count += 1\n\n        # If the current element is equal to the minimum value, increment the count\n        if A[i] == min_val:\n            count += 1\n\n        # If the count is equal to K, return the sum of f(S)\n        if count == K:\n            return str(sum(A))\n\n    # If the count is less than K, return the sum of f(S)\n    return str(sum(A))"
    },
    {
        "number": 2370,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = [[int(x) for x in stdin.readline().strip()] for _ in range(n)]\n\n    def dijkstra(start, dist, prev):\n        for i in range(n):\n            dist[i] = float('inf')\n            prev[i] = None\n\n        dist[start] = 0\n        prev[start] = None\n\n        for i in range(n):\n            for j in range(n):\n                if A[i][j] > 0 and dist[i] + A[i][j] < dist[j]:\n                    dist[j] = dist[i] + A[i][j]\n                    prev[j] = i\n\n        return dist, prev\n\n    dist, prev = dijkstra(0, [float('inf')] * n, [None] * n)\n\n    if dist[n - 1] == float('inf'):\n        return -1\n\n    shortest_path = 0\n    for i in range(n - 1):\n        shortest_path += dist[i]\n\n    return shortest_path\n"
    },
    {
        "number": 2371,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Z, W = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def play_game(x_hand, y_hand):\n        while True:\n            x_hand.append(Z)\n            y_hand.append(W)\n            if len(x_hand) >= 2:\n                x_hand.pop(0)\n            if len(y_hand) >= 2:\n                y_hand.pop(0)\n\n            if len(x_hand) == 0 or len(y_hand) == 0:\n                break\n\n            x_hand.append(a[0])\n            y_hand.append(a[1])\n            a.pop(0)\n            a.pop(0)\n\n    play_game(a[:N], a[N:])\n    return abs(a[0] - a[1])"
    },
    {
        "number": 2372,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    C_h, D_h = map(int, stdin.split())\n    C_w, D_w = map(int, stdin.split())\n    S = stdin.split()\n\n    def is_valid(i, j):\n        return 0 <= i < H and 0 <= j < W and S[i][j] == '#'\n\n    def is_magician_reachable(i, j):\n        if i == C_h and j == C_w:\n            return True\n        if i == D_h and j == D_w:\n            return True\n        if i > 0 and S[i - 1][j] == '#' and is_valid(i - 1, j):\n            return True\n        if i < H - 1 and S[i + 1][j] == '#' and is_valid(i + 1, j):\n            return True\n        if j > 0 and S[i][j - 1] == '#' and is_valid(i, j - 1):\n            return True\n        if j < W - 1 and S[i][j + 1] == '#' and is_valid(i, j + 1):\n            return True\n        return False\n\n    def magician_moves(i, j):\n        moves = []\n        if is_valid(i - 1, j):\n            moves.append((i - 1, j))\n        if is_valid(i + 1, j):\n            moves.append((i + 1, j))\n        if is_valid(i, j - 1):\n            moves.append((i, j - 1))\n        if is_valid(i, j + 1):\n            moves.append((i, j + 1))\n        return moves\n\n    magician_moves_count = 0\n    for i in range(H):\n        for j in range(W):\n            if is_magician_reachable(i, j):\n                magician_moves_count += 1\n\n    if magician_moves_count == 0:\n        return -1\n    return magician_moves_count"
    },
    {
        "number": 2373,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    operations = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if p[i]!= p[j]:\n                operations += 1\n                p[i], p[j] = p[j], p[i]\n\n    return str(operations)"
    },
    {
        "number": 2374,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    L = list(map(int, stdin.split()))\n    R = list(map(int, stdin.split()))\n\n    def cut_cords(cords):\n        cut_cords = set()\n        for i in range(len(cords)):\n            for j in range(i + 1, len(cords)):\n                if B[i] == 1 and B[j] == 1:\n                    cut_cords.add(cords[i])\n                    cut_cords.add(cords[j])\n        return cut_cords\n\n    def is_possible(cords):\n        for i in range(len(cords)):\n            for j in range(i + 1, len(cords)):\n                if B[i] == 1 and B[j] == 0:\n                    return False\n        return True\n\n    cut_cords_set = cut_cords(A)\n    if not is_possible(cut_cords_set):\n        return \"-1\"\n\n    return str(cut_cords_set)\n"
    },
    {
        "number": 2375,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    alice_stones = X\n    bob_stones = Y\n\n    alice_piles = [alice_stones]\n    bob_piles = [0] * Y\n\n    while alice_stones > 0 and bob_stones > 0:\n        if alice_stones >= 2:\n            alice_piles.append(alice_stones)\n            alice_stones -= 2\n        else:\n            alice_piles.append(alice_stones)\n            alice_stones = 0\n\n        if bob_stones >= 2:\n            bob_piles.append(bob_stones)\n            bob_stones -= 2\n        else:\n            bob_piles.append(bob_stones)\n            bob_stones = 0\n\n    if alice_piles[0] > bob_piles[0]:\n        return \"Alice\"\n    elif alice_piles[0] < bob_piles[0]:\n        return \"Brown\"\n    else:\n        return \"Alice\""
    },
    {
        "number": 2376,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, W = map(int, stdin.split())\n    bag = [0] * N\n    selected = [False] * N\n    total_value = 0\n\n    for i in range(N):\n        w_i, v_i = map(int, stdin.split())\n        bag[i] = w_i\n        selected[i] = True\n        total_value += v_i\n\n    for i in range(N):\n        if selected[i]:\n            total_value -= bag[i]\n\n    return str(total_value)"
    },
    {
        "number": 2377,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, H = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    total_damage = 0\n    for i in range(N):\n        total_damage += a[i] + b[i]\n\n    if total_damage > H:\n        return \"No solution\"\n\n    min_attacks = 1\n    for i in range(N):\n        if i > 0:\n            min_attacks = min(min_attacks, i + 1)\n\n    return str(min_attacks)\n"
    },
    {
        "number": 2378,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    B = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(u, visited):\n        if u in visited:\n            return\n        visited.add(u)\n        for v in G[u]:\n            if v not in visited:\n                dfs(v, visited)\n\n    G = [[] for _ in range(N)]\n    for a, b in zip(A, B):\n        G[a - 1].append(b - 1)\n        G[b - 1].append(a - 1)\n\n    def is_black(u):\n        return G[u].count(u) % 2 == 0\n\n    def is_white(u):\n        return G[u].count(u) % 2 == 1\n\n    def expected_holeyness(s):\n        if not s:\n            return 0\n\n        def dfs(u, visited):\n            if u in visited:\n                return\n            visited.add(u)\n            for v in G[u]:\n                if v not in visited:\n                    dfs(v, visited)\n\n        visited = set()\n        dfs(0, visited)\n        return len(visited)\n\n    S = [u for u in range(N) if is_black(u)]\n    if not S:\n        S = [0]\n\n    return str(expected_holeyness(S))"
    },
    {
        "number": 2379,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, C = map(int, stdin.split())\n    S = stdin.strip()\n\n    days = []\n    for i in range(N):\n        if S[i] == 'o':\n            days.append(i)\n\n    for i in range(K):\n        days.append(days[-1] + C)\n\n    days.sort()\n    return '\\n'.join(map(str, days))"
    },
    {
        "number": 2380,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    C = list(map(int, stdin.split()))\n\n    max_sum = 0\n    for i in range(M):\n        for j in range(B[i], N):\n            max_sum = max(max_sum, A[j] + C[j])\n\n    return str(max_sum)"
    },
    {
        "number": 2381,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    max_product = float('-inf')\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            for k in range(j + 1, N + 1):\n                product = A[i] * A[j] * A[k]\n                if product > max_product:\n                    max_product = product\n\n    return str(max_product % (10**9 + 7))"
    },
    {
        "number": 2382,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = set(map(int, stdin.readline().strip().split()))\n\n    # Set the health of the first slime to 4\n    health = 4\n\n    # Initialize the list of slimes that will exist in N seconds\n    slimes = [health]\n\n    # Iterate through the remaining slimes\n    for i in range(1, N):\n        # Calculate the health of the next slime\n        next_health = slimes[-1] + 1\n\n        # If the next slime's health is greater than the current slime's health,\n        # add it to the list of slimes that will exist in N seconds\n        if next_health > health:\n            slimes.append(next_health)\n        else:\n            # If the next slime's health is less than the current slime's health,\n            # remove the current slime from the list of slimes that will exist in N seconds\n            slimes.pop()\n\n    # Check if the multiset of the healths of the slimes that will exist in N seconds equals S\n    if S == set(slimes):\n        return \"Yes\"\n    else:\n        return \"No\""
    },
    {
        "number": 2383,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    bricks = list(map(int, stdin.split()))\n\n    def can_satisfy_snuke(bricks):\n        for i in range(1, N):\n            if bricks[i] == bricks[i - 1]:\n                return False\n        return True\n\n    if can_satisfy_snuke(bricks):\n        return str(K)\n    else:\n        return \"-1\""
    },
    {
        "number": 2384,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n\n    # Sort the elements in ascending order\n    A.sort()\n\n    # Choose the first half of the elements\n    A_half = A[:N // 2]\n\n    # Choose the remaining elements\n    A_remaining = A[N // 2:]\n\n    # Calculate the maximum possible sum\n    max_sum = 0\n    for i in range(len(A_half)):\n        max_sum += A_half[i]\n\n    # Calculate the maximum possible sum of the remaining elements\n    max_sum_remaining = 0\n    for i in range(len(A_remaining)):\n        max_sum_remaining += A_remaining[i]\n\n    # Return the maximum possible sum\n    return str(max_sum + max_sum_remaining)\n"
    },
    {
        "number": 2385,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().strip().split())\n        edges.append((a, b))\n\n    def dfs(vertex, visited):\n        if vertex in visited:\n            return 0\n\n        visited.add(vertex)\n        ways = 0\n        for neighbor in edges[vertex - 1]:\n            ways += dfs(neighbor, visited)\n\n        return ways % (10**9 + 7)\n\n    for k in range(1, n + 1):\n        ways = dfs(k, set())\n        print(ways)"
    },
    {
        "number": 2386,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    b = int(stdin.readline().strip())\n\n    sadness = 0\n    for i in range(N):\n        sadness += abs(A[i] - (b + i))\n\n    return str(sadness)"
    },
    {
        "number": 2387,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    S = []\n    for _ in range(n):\n        S.append(stdin.strip())\n\n    if len(S) == 1:\n        return \"No\"\n\n    for i in range(len(S)):\n        for j in range(i + 1, len(S)):\n            if S[i] + S[j] == \"A\":\n                return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 2388,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    robots = [int(x) for x in stdin.strip().split()]\n    robots.sort()\n    robots_remaining = [robots[0]]\n    for i in range(1, N):\n        if robots[i] - robots_remaining[-1] <= 0:\n            robots_remaining.append(robots[i])\n        else:\n            robots_remaining.append(robots_remaining[-1] + robots[i])\n    return str(len(robots_remaining))"
    },
    {
        "number": 2389,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    choices = []\n    for _ in range(n):\n        s = input()\n        if s[0] == 'A':\n            choices.append((a, b))\n            a -= 1\n            b -= 1\n        elif s[0] == 'B':\n            choices.append((a, c))\n            a -= 1\n            c -= 1\n        elif s[0] == 'C':\n            choices.append((b, c))\n            b -= 1\n            c -= 1\n    if a < 0 or b < 0 or c < 0:\n        return \"No\"\n    else:\n        for i, (a, b) in enumerate(choices):\n            print(f\"{i+1}-th line should contain the name of the variable {a} to which you add 1 in the {i+1}-th choice.\")\n        return \"Yes\""
    },
    {
        "number": 2390,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    v = list(map(int, stdin.split()))\n\n    total_energy = sum(v)\n    total_nutrition = sum(x)\n\n    if total_nutrition > c:\n        return \"0\"\n\n    while total_nutrition > 0:\n        if total_energy > 0:\n            if total_nutrition >= v[0]:\n                total_nutrition -= v[0]\n                total_energy -= v[0]\n                print(v[0])\n            else:\n                total_nutrition -= v[0]\n                total_energy -= v[0]\n                print(v[0])\n        else:\n            break\n\n    return \"0\""
    },
    {
        "number": 2391,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def xor(a, b):\n        return sum(int(digit) for digit in bin(a ^ b)[2:])\n\n    pairs = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            if xor(a[i], b[j]) == xor(a[j], b[i]):\n                pairs.append((i, j))\n\n    pairs.sort()\n    for k, x in pairs:\n        print(k, x)\n\n    return \"\""
    },
    {
        "number": 2392,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    count = 0\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            count += 1\n            if i == n:\n                break\n    return str(count)"
    },
    {
        "number": 2393,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        s = stdin.strip()\n        n = len(s)\n        r = 0\n        for i in range(n):\n            if s[i] == 'o':\n                if i > 0 and s[i-1] == 'n':\n                    r += 1\n                if i < n-1 and s[i+1] == 'e':\n                    r += 1\n            if s[i] == 't':\n                if i > 0 and s[i-1] == 'e':\n                    r += 1\n                if i < n-1 and s[i+1] =='s':\n                    r += 1\n        if r == 0:\n            print(\"0\")\n            continue\n        result = []\n        for i in range(n):\n            if s[i] == 'o':\n                if i > 0 and s[i-1] == 'n':\n                    result.append(i)\n                if i < n-1 and s[i+1] == 'e':\n                    result.append(i)\n            if s[i] == 't':\n                if i > 0 and s[i-1] == 'e':\n                    result.append(i)\n                if i < n-1 and s[i+1] =='s':\n                    result.append(i)\n        result.sort()\n        print(r, \" \".join(map(str, result)))"
    },
    {
        "number": 2394,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    edges = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        edges.append((a - 1, b - 1))\n\n    def dfs(start, visited, path, f):\n        if start in visited:\n            return\n        visited.add(start)\n        path.append(start)\n        for neighbor in edges[start]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path, f)\n        path.pop()\n\n    visited = set()\n    path = []\n    dfs(1, visited, path, 0)\n    return sum(f for f in path)"
    },
    {
        "number": 2395,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        t = stdin.readline().strip()\n        if len(t) > 2 * len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t) - len(t):\n            continue\n        if len(t) > 2 * len(t) - len(t) - len(t) - len(t) - len"
    },
    {
        "number": 2396,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    jumps = []\n    for _ in range(n):\n        a, b, c = map(int, stdin.strip().split())\n        jumps.append((a + b) / c)\n    jumps.sort()\n    result = []\n    for i in range(1, n):\n        result.append(jumps[i] - jumps[i - 1])\n    return''.join(map(str, result))"
    },
    {
        "number": 2397,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_cost = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(k):\n                subarray = a[i:j]\n                subarray.sort()\n                subarray.reverse()\n                subarray_cost = sum(subarray)\n                max_cost = max(max_cost, subarray_cost)\n\n    return str(max_cost)\n"
    },
    {
        "number": 2398,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.strip().split())\n        x, y, x_1, y_1, x_2, y_2 = map(int, stdin.strip().split())\n\n        if x_1 <= x <= x_2 and y_1 <= y <= y_2:\n            if a + b + c + d == 1:\n                print(\"YES\")\n            else:\n                print(\"NO\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2399,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.strip())\n    alice_wins = False\n    for _ in range(q):\n        a, b = map(int, stdin.strip().split())\n        s = stdin.strip().split()\n        alice_move = s[:a] + 'X' + s[a+b:]\n        bob_move = s[:b] + 'X' + s[b+a:]\n        if alice_move == bob_move:\n            alice_wins = True\n            break\n    return 'YES' if alice_wins else 'NO'"
    },
    {
        "number": 2400,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    lines = []\n    for _ in range(n):\n        p = list(map(int, stdin.split()))\n        lines.append(p)\n    for _ in range(m):\n        q = list(map(int, stdin.split()))\n        lines.append(q)\n    intersection_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(m):\n                for l in range(k + 1, m):\n                    if lines[i][0] == lines[j][0] and lines[i][1] == lines[j][1] and lines[k][0] == lines[l][0] and lines[k][1] == lines[l][1]:\n                        intersection_count += 1\n    return str(intersection_count)"
    },
    {
        "number": 2401,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        N = int(stdin.readline())\n        R = int(stdin.readline())\n        numbers = list(map(int, stdin.readline().split()))\n        numbers.sort()\n        if R == 1:\n            return str(numbers[0])\n        else:\n            return str(numbers[R - 1])"
    },
    {
        "number": 2402,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split())\n    participants = ['A', 'B', 'C', 'D', 'E']\n    scores = [0, 0, 0, 0, 0]\n    places = [0, 0, 0, 0, 0]\n    for i in range(n):\n        scores[i % n] += x\n        places[i % n] += 1\n    max_place = max(places)\n    min_place = min(places)\n    for i in range(n):\n        if scores[i] <= max_place:\n            max_place = places[i]\n        if scores[i] >= min_place:\n            min_place = places[i]\n    return str(min_place) +'' + str(max_place)"
    },
    {
        "number": 2403,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    b = list(map(int, stdin.strip().split()))\n\n    ans = 0\n    for i in range(n):\n        if b[i] == -1:\n            ans += a[i]\n        else:\n            ans += a[b[i]]\n\n    return str(ans)\n"
    },
    {
        "number": 2404,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a < 4 or a > 998:\n        return \"Invalid input\"\n\n    jokes = [\n        \"Fixed limerick rules\",\n        \"Allowed her to trip the unwary.\",\n        \"On juggling the words\",\n        \"Right around two-thirds\",\n        \"She nearly ran out of rhymes.\",\n    ]\n\n    result = 0\n    for i in range(a):\n        result += jokes.index(jokes[i % len(jokes)])\n\n    return str(result)\n"
    },
    {
        "number": 2405,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, a, b, q = map(int, stdin.split())\n    orders = []\n    for _ in range(q):\n        day, num_orders = map(int, stdin.split())\n        orders.append((day, num_orders))\n\n    def max_orders(day):\n        max_orders = 0\n        for order in orders:\n            if order[0] == day:\n                max_orders += order[1]\n        return max_orders\n\n    max_orders_per_day = [max_orders(day) for day in range(1, n + 1)]\n    max_orders_per_day.append(max_orders(n))\n\n    max_orders_per_day = max(max_orders_per_day)\n\n    return str(max_orders_per_day)\n"
    },
    {
        "number": 2406,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    h = list(map(int, stdin.readline().strip().split()))\n\n    h_sum = sum(h)\n    h_n = h_sum - 1\n\n    for i in range(n):\n        h_j = h[i]\n        h_j_plus_2 = h[i] + 2\n        h_j_minus_1 = h[i] - 1\n\n        if h_j_plus_2 <= h_j_minus_1:\n            h_j_plus_2 = h_j_minus_1 + 1\n\n        h_j_plus_2 = max(h_j_plus_2, h_j_minus_1 + 1)\n\n        h[i] = h_j_plus_2\n\n    return''.join(map(str, h))"
    },
    {
        "number": 2407,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    result = []\n\n    for _ in range(q):\n        d = int(stdin.readline())\n        x_d = [x[i] + d for i in range(n)]\n        x_d.sort()\n        x_d.reverse()\n        x_d = x_d[0]\n\n        x_d_left = [x[i] - r for i in range(n)]\n        x_d_left.sort()\n        x_d_left.reverse()\n        x_d_left = x_d_left[0]\n\n        x_d_right = [x[i] + r for i in range(n)]\n        x_d_right.sort()\n        x_d_right.reverse()\n        x_d_right = x_d_right[0]\n\n        x_d_origin = [0] * n\n        x_d_origin.sort()\n        x_d_origin.reverse()\n        x_d_origin = x_d_origin[0]\n\n        x_d_epicenter = [x[i] for i in range(n)]\n        x_d_epicenter.sort()\n        x_d_epicenter.reverse()\n        x_d_epicenter = x_d_epicenter[0]\n\n        x_d_explosion = [x[i] for i in range(n)]\n        x_d_explosion.sort()\n        x_d_explosion.reverse()\n        x_d_explosion = x_d_explosion[0]\n\n        x_d_c = [x[i] for i in range(n)]\n        x_d_c.sort()\n        x_d_c.reverse()\n        x_d_c = x_d_c[0]\n\n        x_d_y = [x[i] for i in range(n)]\n        x_d_y.sort()\n        x_d_y.reverse()\n        x_d_y = x_d_y[0]\n\n        x_d_r = [x[i] for i in range(n)]\n        x_d_r.sort()\n        x_d_r.reverse()\n        x_d_r = x_d_r[0]\n\n        x_d_c = [x[i] for i in range(n)]\n        x_d_c.sort()\n        x_d_c.reverse()\n        x_d_c = x_d_c[0]\n\n        x_d_y = [x[i] for i in range(n)]\n        x_d_y.sort()\n        x_d_y.reverse()\n        x_d_y = x_d_y[0]\n\n        x_d_r = [x[i] for i in range(n)]\n        x_d_r.sort()\n        x_d_r.reverse()\n        x_d_r = x_d_r[0]\n\n        x_d_c = [x[i] for i in range(n)]\n        x_d_c.sort()\n        x_d_c.reverse()\n        x_d_c = x_d_c[0]\n\n        x_d_y = [x[i] for i in range(n)]\n        x_d_y.sort()\n        x_d_y.reverse()\n        x_d_y = x_d_y[0]\n\n        x_d_r = [x[i] for i in range(n)]\n        x_d_r.sort()\n        x_d_r.reverse()\n        x_d_r = x_d_r[0]\n\n        x_d_c = [x[i] for i in range(n)]\n        x_d_c.sort()\n        x_d_c.reverse()\n        x_d_c = x_d_c[0]\n\n        x_d_y = [x[i] for i in range(n)]\n        x_d_y.sort()\n        x_d_y.reverse()\n        x_d_y = x_d_y[0]\n\n        x_d_r = [x[i] for i in range(n)]\n        x_d_r.sort()\n        x_d_r.reverse()\n        x_d_r = x_d_r[0]\n\n        x_d_c = [x[i] for i in range(n)]\n        x_d_c.sort()\n        x_d_c.reverse()\n        x_d_"
    },
    {
        "number": 2408,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    poles = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        poles.append((x, y))\n\n    intersecting_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if poles[i] == poles[j]:\n                intersecting_pairs += 1\n\n    return str(intersecting_pairs)"
    },
    {
        "number": 2409,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    p = [0] * (k - 2) + [1] * (k - 1) + [0] * (k - 2) + [1] * (k - 1) + [0] * (k - 2) + [1] * (k - 1)\n    t = 0\n    while t < n:\n        if t % 2 == 0:\n            p[t % k] += 1\n        else:\n            p[t % k] -= 1\n        t += 1\n    for i in range(n):\n        if d[i] + p[t % k] <= l:\n            return \"Yes\"\n        else:\n            return \"No\""
    },
    {
        "number": 2410,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    cupcakes = [0] * n\n    for i in range(n):\n        cupcakes[i] = a[i]\n\n    for i in range(n - 1, -1, -1):\n        if cupcakes[i] > cupcakes[i + 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 2411,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    poles = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        poles.append((x, y))\n\n    intersecting_pairs = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if poles[i] == poles[j]:\n                intersecting_pairs += 1\n\n    return str(intersecting_pairs)"
    },
    {
        "number": 2412,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        s = stdin.strip()\n        if len(s)!= n:\n            return \"NO\"\n        if s[0] == '8' and s[1] == '0' and s[2] == '0':\n            return \"YES\"\n        else:\n            return \"NO\""
    },
    {
        "number": 2413,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    staircases = [int(x) for x in stdin.strip().split()]\n\n    def dfs(start, visited):\n        if start in visited:\n            return 0\n\n        visited.add(start)\n        max_rooms = 0\n\n        for i in range(1, n + 1):\n            if staircases[start] == i:\n                max_rooms = max(max_rooms, dfs(i, visited) + 1)\n\n        return max_rooms\n\n    return str(dfs(1, set()))\n"
    },
    {
        "number": 2414,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        result.append(a + b)\n    return str(t) + '\\n' + '\\n'.join(map(str, result))"
    },
    {
        "number": 2415,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    if len(stdin) > 10:\n        return \"NO\"\n    for char in stdin:\n        if char not in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n            return \"NO\"\n    return \"YES\""
    },
    {
        "number": 2416,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"YES\"\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if a[i] ^ a[j] ^ a[k] == 0:\n                    return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2417,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    b = list(map(int, stdin.readline().strip().split()))\n\n    def is_overtaking(i, j):\n        return a[i] < b[j]\n\n    def is_fined(i):\n        return any(is_overtaking(i, j) for j in b if j!= i)\n\n    count = 0\n    for i in range(n):\n        if is_fined(i):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2418,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [a[i] for i in range(n)]\n    c = [a[i] for i in range(n)]\n    for _ in range(q):\n        l, r, x = map(int, stdin.split())\n        a[l-1] += x\n        a[r-1] += x\n        b[l-1] = max(b[l-1], b[l])\n        c[r-1] = min(c[r-1], c[r])\n    max_b = max(b)\n    max_c = max(c)\n    min_b = min(b)\n    min_c = min(c)\n    return str(q+1) + '\\n' + str(max_b) + '\\n' + str(max_c) + '\\n' + str(min_b) + '\\n' + str(min_c)"
    },
    {
        "number": 2419,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        operations = 0\n        while a!= b:\n            if a > b:\n                a += 1\n            else:\n                b -= 1\n            operations += 1\n        print(operations)\n    return \"\""
    },
    {
        "number": 2420,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        points.append((x, y))\n\n    points.sort(key=lambda x: abs(x[0]) + abs(x[1]))\n\n    max_points = 0\n    for i in range(len(points)):\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][1] == points[i - 1][1] and points[i][0]!= points[i - 1][0]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1]!= points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]!= points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0] == points[i - 1][0] and points[i][1] == points[i - 1][1]:\n            continue\n        if i > 0 and points[i][0]"
    },
    {
        "number": 2421,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        x, y = map(int, stdin.readline().strip().split())\n        c1, c2, c3, c4, c5, c6 = map(int, stdin.readline().strip().split())\n        path = [(x, y)]\n        visited = set([(x, y)])\n        while path:\n            current = path.pop(0)\n            if current == (x, y):\n                return str(c1)\n            for neighbor in [(x+1, y), (x-1, y), (x, y+1), (x, y-1), (x-1, y-1), (x+1, y-1), (x+1, y+1), (x-1, y+1)]:\n                if neighbor not in visited and neighbor!= current:\n                    visited.add(neighbor)\n                    path.append(neighbor)\n        return \"No path found\""
    },
    {
        "number": 2422,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        if n == 30:\n            print(2, 2, 2)\n        elif n == 67:\n            print(7, 5, 3)\n        else:\n            print(-1)"
    },
    {
        "number": 2423,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    planets = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().split())\n        planets.append((u, v))\n\n    remote_planets = 0\n    for u, v in planets:\n        if u not in planets and v not in planets:\n            remote_planets += 1\n\n    return str(remote_planets)"
    },
    {
        "number": 2424,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    kids = []\n    for _ in range(n):\n        kids.append(list(map(int, stdin.readline().split())))\n\n    def choose_present(kids, items):\n        # choose one kid equiprobably among all kids\n        x = random.choice(kids)\n\n        # choose some item equiprobably among all items of kid x\n        y = random.choice(items)\n\n        # choose a kid z who will receive the present equiprobably among all kids\n        z = random.choice(kids)\n\n        # check if z wants y as an item they want to receive\n        if any(x == z for y in items if y in z.items()):\n            return (x, y, z)\n        else:\n            return None\n\n    def probability(decision):\n        x, y, z = decision\n        return x * y ** (-1) % 998244353\n\n    for i in range(n):\n        items = kids[i]\n        decision = choose_present(kids, items)\n        if decision:\n            print(probability(decision))\n        else:\n            print(0)"
    },
    {
        "number": 2425,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    b = 1\n    for i in range(q):\n        a[i] = a[i] + b\n        b = a[i] // b\n    return str(b)"
    },
    {
        "number": 2426,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def is_even_sum(arr):\n        return sum(arr) % 2 == 0\n\n    def find_subset(arr, start, target_sum):\n        if start == len(arr):\n            return [start]\n\n        if target_sum == 0:\n            return []\n\n        if target_sum < 0:\n            return []\n\n        if is_even_sum(arr[start:start+2]):\n            subset = find_subset(arr, start+2, target_sum-arr[start])\n            if subset:\n                subset.append(start)\n            return subset\n\n        return find_subset(arr, start+1, target_sum)\n\n    subset = find_subset(a, 0, sum(a))\n    if subset:\n        print(len(subset))\n        for i in subset:\n            print(i)\n    else:\n        print(-1)\n\n    return \"\""
    },
    {
        "number": 2427,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+2, n):\n            if a[i] ^ a[j] == sum(a[i+1:j]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2428,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        if len(s) > 400 or len(t) > len(s):\n            continue\n        p = \"\"\n        for i in range(len(s)):\n            if i < len(s) - 1:\n                p += s[i] + s[i+1]\n            else:\n                p += s[i]\n        if p == t:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2429,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n % 2 == 0:\n        raise ValueError(\"n must be even\")\n\n    a = 0\n    b = 0\n    for i in range(n):\n        a += 2 ** i\n        b += 2 ** (n - i - 1)\n\n    return str(abs(a - b))"
    },
    {
        "number": 2430,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    heights = list(map(int, stdin.readline().strip().split()))\n\n    def jump(i, h):\n        if i == n - 1:\n            return h\n        return h + 1\n\n    min_time = float('inf')\n    for i in range(n):\n        if heights[i] > heights[i + 1]:\n            min_time = min(min_time, i + 1)\n\n    return str(min_time)\n"
    },
    {
        "number": 2431,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y, z = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def count_options(attack_type, target_castle, target_type):\n        options = []\n        for i in range(1, n + 1):\n            if i == target_castle:\n                continue\n            if attack_type == \"mixed\":\n                options.append((i, target_type, 0))\n            elif attack_type == \"infantry\":\n                options.append((i, target_type, 0))\n            elif attack_type == \"cavalry\":\n                options.append((i, target_type, 0))\n            else:\n                options.append((i, target_type, 0))\n        return options\n\n    def count_attacks(attack_type, target_castle, target_type):\n        attacks = []\n        for i in range(1, n + 1):\n            if i == target_castle:\n                continue\n            if attack_type == \"mixed\":\n                attacks.append((i, target_type, 0))\n            elif attack_type == \"infantry\":\n                attacks.append((i, target_type, 0))\n            elif attack_type == \"cavalry\":\n                attacks.append((i, target_type, 0))\n            else:\n                attacks.append((i, target_type, 0))\n        return attacks\n\n    def count_attacks_with_options(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks\n\n    def count_attacks_with_options_and_attacks(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks\n\n    def count_attacks_with_options_and_attacks_and_castle(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks + [(target_castle, target_type)]\n\n    def count_attacks_with_options_and_attacks_and_castle_and_attack(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks + [(target_castle, target_type)] + [(attack_type, target_castle, target_type)]\n\n    def count_attacks_with_options_and_attacks_and_castle_and_attack_and_castle(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks + [(target_castle, target_type)] + [(attack_type, target_castle, target_type)] + [(attack_type, target_castle, target_type)]\n\n    def count_attacks_with_options_and_attacks_and_castle_and_attack_and_castle_and_attack(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks + [(target_castle, target_type)] + [(attack_type, target_castle, target_type)] + [(attack_type, target_castle, target_type)] + [(attack_type, target_castle, target_type)] + [(attack_type, target_castle, target_type)]\n\n    def count_attacks_with_options_and_attacks_and_castle_and_attack_and_castle_and_attack_and_castle(attack_type, target_castle, target_type):\n        options = count_options(attack_type, target_castle, target_type)\n        attacks = count_attacks(attack_type, target_castle, target_type)\n        return options + attacks + [(target_castle, target_type)] + [(attack_type, target_castle,"
    },
    {
        "number": 2432,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a < 0 or a > 63:\n        return \"Invalid input\"\n    elif a == 0:\n        return \"0\"\n    elif a == 1:\n        return \"1\"\n    elif a == 2:\n        return \"2\"\n    elif a == 3:\n        return \"3\"\n    elif a == 4:\n        return \"4\"\n    elif a == 5:\n        return \"5\"\n    elif a == 6:\n        return \"6\"\n    elif a == 7:\n        return \"7\"\n    elif a == 8:\n        return \"8\"\n    elif a == 9:\n        return \"9\"\n    elif a == 10:\n        return \"10\"\n    elif a == 11:\n        return \"11\"\n    elif a == 12:\n        return \"12\"\n    elif a == 13:\n        return \"13\"\n    elif a == 14:\n        return \"14\"\n    elif a == 15:\n        return \"15\"\n    elif a == 16:\n        return \"16\"\n    elif a == 17:\n        return \"17\"\n    elif a == 18:\n        return \"18\"\n    elif a == 19:\n        return \"19\"\n    elif a == 20:\n        return \"20\"\n    elif a == 21:\n        return \"21\"\n    elif a == 22:\n        return \"22\"\n    elif a == 23:\n        return \"23\"\n    elif a == 24:\n        return \"24\"\n    elif a == 25:\n        return \"25\"\n    elif a == 26:\n        return \"26\"\n    elif a == 27:\n        return \"27\"\n    elif a == 28:\n        return \"28\"\n    elif a == 29:\n        return \"29\"\n    elif a == 30:\n        return \"30\"\n    elif a == 31:\n        return \"31\"\n    elif a == 32:\n        return \"32\"\n    elif a == 33:\n        return \"33\"\n    elif a == 34:\n        return \"34\"\n    elif a == 35:\n        return \"35\"\n    elif a == 36:\n        return \"36\"\n    elif a == 37:\n        return \"37\"\n    elif a == 38:\n        return \"38\"\n    elif a == 39:\n        return \"39\"\n    elif a == 40:\n        return \"40\"\n    elif a == 41:\n        return \"41\"\n    elif a == 42:\n        return \"42\"\n    elif a == 43:\n        return \"43\"\n    elif a == 44:\n        return \"44\"\n    elif a == 45:\n        return \"45\"\n    elif a == 46:\n        return \"46\"\n    elif a == 47:\n        return \"47\"\n    elif a == 48:\n        return \"48\"\n    elif a == 49:\n        return \"49\"\n    elif a == 50:\n        return \"50\"\n    elif a == 51:\n        return \"51\"\n    elif a == 52:\n        return \"52\"\n    elif a == 53:\n        return \"53\"\n    elif a == 54:\n        return \"54\"\n    elif a == 55:\n        return \"55\"\n    elif a == 56:\n        return \"56\"\n    elif a == 57:\n        return \"57\"\n    elif a == 58:\n        return \"58\"\n    elif a == 59:\n        return \"59\"\n    elif a == 60:\n        return \"60\"\n    elif a == 61:\n        return \"61\"\n    elif a == 62:\n        return \"62\"\n    elif a == 63:\n        return \"63\"\n    else:\n        return \"Invalid input\""
    },
    {
        "number": 2433,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        b, p, f = map(int, stdin.readline().strip().split())\n        h, c = map(int, stdin.readline().strip().split())\n        if b == 1 and p == 1 and f == 1:\n            profit = 0\n        else:\n            profit = max(sell_hamburgers(b, p, h), sell_chicken_burgers(b, p, f, c))\n        print(profit)\n\ndef"
    },
    {
        "number": 2434,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n < m:\n        return \"NO\"\n\n    # Initialize the polygon\n    polygon = [0] * n\n    polygon[0] = 0\n    polygon[1] = 0\n\n    # Find the center of the polygon\n    center = 0\n    for i in range(2, n):\n        center += polygon[i-1]\n        polygon[i] = center\n\n    # Find the vertex that coincides with the center\n    for i in range(n):\n        if polygon[i] == center:\n            return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2435,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, m = map(int, stdin.split())\n    operations = []\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        operations.append((l, r))\n\n    operations.sort(key=lambda x: x[0])\n\n    count = 0\n    for i in range(n):\n        if i == x:\n            continue\n        for j in range(i + 1, n):\n            if j == x:\n                continue\n            for k in range(j + 1, n):\n                if k == x:\n                    continue\n                if operations[i][0] <= operations[j][0] <= operations[k][0]:\n                    if operations[i][1] <= operations[j][1] <= operations[k][1]:\n                        count += 1\n                        break\n\n    return str(count)\n"
    },
    {
        "number": 2436,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    a = [x for x in a if x > 0]\n    a.sort()\n    k = 0\n    for i in range(n):\n        if i == 0:\n            k = a[0]\n        else:\n            k = max(k, a[i] + a[i-1])\n    return str(k)"
    },
    {
        "number": 2437,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    # Find the greatest common divisor of all elements\n    gcd = 1\n    for i in range(n):\n        gcd = gcd * a[i] // gcd\n\n    # Check if the array is good\n    if gcd!= 1:\n        return \"0\"\n\n    # Perform the required operations\n    for i in range(n):\n        if a[i] > 0:\n            a[i] += 1\n        else:\n            a[i] -= 1\n\n    # Check if the array is good\n    if gcd!= 1:\n        return \"0\"\n\n    return str(n)\n"
    },
    {
        "number": 2438,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if s[i] == s[j] and s[i] in s[i+1:j]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2439,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        b = []\n        for i in range(n):\n            b.append(a[i])\n        for i in range(n):\n            for j in range(i+1, n):\n                if b[i] + b[j] == 0:\n                    print(\"YES\")\n                    print(\" \".join(map(str, b)))\n                    return \"YES\"\n        print(\"NO\")"
    },
    {
        "number": 2440,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n        edges.append((v, u))\n\n    q = int(stdin.readline().strip())\n    for _ in range(q):\n        x, y, a, b, k = map(int, stdin.readline().strip().split())\n        if (x, y) in edges or (y, x) in edges:\n            continue\n\n        path = []\n        stack = [(x, 0)]\n        while stack:\n            u, depth = stack.pop()\n            if u == b:\n                path.append(u)\n                if len(path) == k:\n                    return \"YES\"\n                continue\n            for v, w in edges:\n                if v == u:\n                    continue\n                if w == u:\n                    continue\n                if w == b:\n                    continue\n                if depth + 1 == w:\n                    stack.append((v, depth + 1))\n\n        return \"NO\""
    },
    {
        "number": 2441,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    checkposts = [0] * n\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        checkposts[u - 1] += 1\n        checkposts[v - 1] += 1\n\n    min_money = float('inf')\n    ways = 0\n\n    for i in range(n):\n        if checkposts[i] > 0:\n            min_money = min(min_money, i * checkposts[i])\n            ways += 1\n\n    return f\"{min_money:.0f} {ways}\"\n"
    },
    {
        "number": 2442,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        b = list(map(int, stdin.readline().strip().split()))\n        if len(a) == len(b):\n            if sum(a) == sum(b):\n                print(max(a) + max(b))\n            else:\n                print(max(a) + max(b))\n        else:\n            print(max(a) + max(b))"
    },
    {
        "number": 2443,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n > 0:\n        forbidden_products = list(map(int, stdin.split()))\n    else:\n        forbidden_products = []\n\n    if n > 0:\n        prefix_products = [1]\n        for i in range(1, n):\n            prefix_products.append(prefix_products[-1] * forbidden_products[i - 1])\n\n        sequence = []\n        for i in range(m):\n            if i >= n:\n                sequence.append(i)\n            else:\n                sequence.append(prefix_products[i])\n\n        sequence.sort()\n        return''.join(map(str, sequence))\n    else:\n        return '0'"
    },
    {
        "number": 2444,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split())\n    t = list(map(int, stdin.split()))\n\n    # Initialize the queue\n    queue = [0] * n\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = 0\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the passenger who will receive the boiled water\n    boiled_water_time = t[0]\n\n    # Initialize the time of the"
    },
    {
        "number": 2445,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    for _ in range(T):\n        n = int(stdin.readline().strip())\n        grid = []\n        for _ in range(n):\n            grid.append(list(map(int, stdin.readline().strip())))\n        min_turns = float('inf')\n        for i in range(n):\n            for j in range(i+1, n):\n                if grid[i][j] == grid[j][i]:\n                    min_turns = min(min_turns, i+1)\n        print(min_turns)\n    return \"\""
    },
    {
        "number": 2446,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return (a * b) // gcd(a, b)\n\n    pairs = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            pairs.append((i, j))\n\n    for _ in range(q):\n        x = int(stdin.split())\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if gcd(a[i], a[i] + 1, *a[i:j]) == x:\n                    count += 1\n        print(count)\n\n    return \"\""
    },
    {
        "number": 2447,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n\n    for _ in range(t):\n        s = stdin.strip()\n        good = True\n\n        for i in range(len(s)):\n            if s[i] == '0':\n                s = s[:i] + '1' + s[i+1:]\n            elif s[i] == '1':\n                s = s[:i] + '0' + s[i+1:]\n            else:\n                good = False\n                break\n\n        if good:\n            result.append(len(s))\n        else:\n            result.append(-1)\n\n    return str(min(result))\n"
    },
    {
        "number": 2448,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, c = map(int, stdin.split())\n    s = stdin.split()\n    t = []\n    for i in range(n):\n        t.append(s[i])\n    if a + b + c!= n:\n        return \"NO\"\n    if a == 0 and b == 0 and c == 0:\n        return \"YES\"\n    for i in range(n):\n        if t[i] == 'R':\n            t[i] = 'P'\n        elif t[i] == 'P':\n            t[i] = 'S'\n        elif t[i] == 'S':\n            t[i] = 'R'\n    if a + b + c == n:\n        return \"YES\"\n    for i in range(n):\n        if t[i] == 'R':\n            t[i] = 'P'\n        elif t[i] == 'P':\n            t[i] = 'S'\n        elif t[i] == 'S':\n            t[i] = 'R'\n    return \"\".join(t)"
    },
    {
        "number": 2449,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    T = set(map(int, stdin.split()))\n\n    good_sets = 0\n    for t in T:\n        if t <= m:\n            good_sets += 1\n\n    return str(good_sets % (10**9 + 7))"
    },
    {
        "number": 2450,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y = map(int, stdin.split())\n    tiles = []\n    for _ in range(n):\n        tiles.append([int(c) for c in stdin.readline().strip()])\n\n    total_price = 0\n    for i in range(n):\n        for j in range(m):\n            if tiles[i][j] == '*':\n                total_price += x\n            elif tiles[i][j] == '.':\n                total_price += y\n\n    return str(total_price)\n"
    },
    {
        "number": 2451,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, h, a, b, k = map(int, stdin.split())\n    queries = []\n    for _ in range(k):\n        queries.append(list(map(int, stdin.split())))\n\n    min_time = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(1, h + 1):\n                for l in range(1, h + 1):\n                    if i == j or i == l or j == l:\n                        continue\n                    if queries[i][1] == k and queries[j][1] == l:\n                        time = abs(queries[i][0] - queries[j][0]) + abs(queries[i][2] - queries[j][2])\n                        if time < min_time:\n                            min_time = time\n\n    return str(min_time)\n"
    },
    {
        "number": 2452,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if (i < j) and (i < j-1) and (i < j-2) and (i < j-3):\n                print(f\"{i} {j}\")\n                break"
    },
    {
        "number": 2453,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.readline().strip().split())\n        segments.append((l, r))\n\n    def count_points(x):\n        count = 0\n        for l, r in segments:\n            if l <= x <= r:\n                count += 1\n        return count\n\n    points = set()\n    for x in range(1, 10**18):\n        if count_points(x) == n:\n            points.add(x)\n\n    return''.join(map(str, points))"
    },
    {
        "number": 2454,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    cities = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.strip().split())\n        cities.append((a, b))\n\n    def is_good_mood(city):\n        return city[0] == 1 and city[1] == 1\n\n    def is_casino(city):\n        return city[0] == 2 and city[1] == 2\n\n    def is_good_city(city):\n        return is_good_mood(city) and not is_casino(city)\n\n    def is_bad_city(city):\n        return not is_good_city(city)\n\n    def is_reachable(city):\n        return any(is_reachable(c) for c in cities if c!= city)\n\n    def reachable_cities(city):\n        return [c for c in cities if is_reachable(c) and is_good_city(c)]\n\n    def reachable_casinos(city):\n        return [c for c in reachable_cities(city) if is_casino(c)]\n\n    def reachable_cities_and_casinos(city):\n        return reachable_cities(city) + reachable_casinos(city)\n\n    def reachable_cities_and_casinos_count(city):\n        return len(reachable_cities_and_casinos(city))\n\n    def reachable_cities_and_casinos_count_modulo(city):\n        return (reachable_cities_and_casinos_count(city) + 7) % 1000000007\n\n    def reachable_cities_and_casinos_count_modulo_helper(city, count):\n        if count == 0:\n            return 0\n        return (reachable_cities_and_casinos_count_modulo(city) + reachable_cities_and_casinos_count_modulo_helper(city, count - 1)) % 1000000007\n\n    def reachable_cities_and_casinos_count_modulo_recursive(city):\n        return reachable_cities_and_casinos_count_modulo_helper(city, n - 1)\n\n    def reachable_cities_and_casinos_count_modulo_recursive_helper(city, count):\n        if count == 0:\n            return 0\n        return (reachable_cities_and_casinos_count_modulo_recursive(city) + reachable_cities_and_casinos_count_modulo_recursive_helper(city, count - 1)) % 1000000007\n\n    def reachable_cities_and_casinos_count_modulo_recursive_helper_helper(city, count):\n        if count == 0:\n            return 0\n        return (reachable_cities_and_casinos_count_modulo_recursive_helper(city, count - 1) + reachable_cities_and_casinos_count_modulo_recursive_helper_helper(city, count - 1)) % 1000000007\n\n    def reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper(city, count):\n        if count == 0:\n            return 0\n        return (reachable_cities_and_casinos_count_modulo_recursive_helper_helper(city, count - 1) + reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper(city, count - 1)) % 1000000007\n\n    def reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper_helper(city, count):\n        if count == 0:\n            return 0\n        return (reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper_helper(city, count - 1) + reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper_helper(city, count - 1)) % 1000000007\n\n    def reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper_helper_helper_helper(city, count):\n        if count == 0:\n            return 0\n        return (reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper_helper_helper_helper(city, count - 1) + reachable_cities_and_casinos_count_modulo_recursive_helper_helper_helper_helper_helper(city, count - 1)) % 1000000007\n\n    def reachable_cities"
    },
    {
        "number": 2455,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n\n    for _ in range(t):\n        cards = list(stdin.strip())\n        a, b = int(cards[0]), int(cards[1])\n\n        if a == b:\n            result.append(f\"{a}x{b}\")\n        else:\n            for i in range(1, a + 1):\n                for j in range(1, b + 1):\n                    if i * j == a * b:\n                        result.append(f\"{i}x{j}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 2456,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r = map(int, stdin.split())\n    painted_cells = [[] for _ in range(n)]\n    shapes = [[] for _ in range(n)]\n    for _ in range(n):\n        painted_cells.append([])\n        shapes.append([])\n\n    for i in range(n):\n        painted_cells[i].append(i)\n        shapes[i].append(i)\n\n    for _ in range(r):\n        for i in range(n):\n            for j in range(i + 1, n):\n                painted_cells[i].append(j)\n                shapes[i].append(j)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if i == j == k == l:\n                        continue\n                    if shapes[i][j] == shapes[j][k] == shapes[k][l]:\n                        painted_cells[i].append(j)\n                        painted_cells[j].append(k)\n                        painted_cells[k].append(l)\n                        shapes[i].append(j)\n                        shapes[j].append(k)\n                        shapes[k].append(l)\n\n    answer = 0\n    for i in range(n):\n        if len(painted_cells[i]) == 1:\n            answer += 1\n\n    return str(answer)\n"
    },
    {
        "number": 2457,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a, b, c, d = map(int, stdin.readline().strip().split())\n        if n == 1:\n            if a - b <= 1000 and c - d <= 1000:\n                print(\"Yes\")\n            else:\n                print(\"No\")\n        else:\n            if a - b <= 1000 and c - d <= 1000:\n                print(\"Yes\")\n            else:\n                print(\"No\")"
    },
    {
        "number": 2458,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().strip().split())\n        ways = 0\n        for i in range(a, b + 1):\n            for j in range(i, b + 1):\n                if i % 2 == 0 and j % 2 == 0:\n                    ways += 1\n        ways %= 1000000007\n        print(ways)\n    return \"\""
    },
    {
        "number": 2459,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    queries = []\n    for _ in range(q):\n        t, l, r = map(int, stdin.split())\n        queries.append((t, l, r))\n\n    result = []\n    for i in range(m):\n        result.append(b[i])\n\n    for t, l, r in queries:\n        if t == 1:\n            for x in range(l, r + 1):\n                a[x] = a[x] + 1\n                a[l] = a[r]\n                a[r] = a[x] - 1\n        elif t == 2:\n            for x in range(l, r + 1):\n                a[x] = a[x] + 1\n                a[l] = a[r]\n                a[r] = a[x] - 1\n                a[l] = a[r]\n                a[r] = a[x] - 1\n\n    for i in range(m):\n        result[i] = b[i]\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2460,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    # Find the taxi driver with the smallest coordinate\n    min_coord = min(x)\n    min_driver = [i for i, coord in enumerate(x) if coord == min_coord][0]\n\n    # Count the number of riders that would call the taxi driver\n    count = 0\n    for i in range(m):\n        if t[i] == 1:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 2461,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    tree = [[] for _ in range(n)]\n    for i in range(n - 1):\n        x, y = map(int, stdin.readline().strip().split())\n        tree[x - 1].append(y - 1)\n        tree[y - 1].append(x - 1)\n\n    def dfs(x, beauty):\n        if x == 1:\n            return beauty\n        for i in tree[x - 1]:\n            beauty = max(beauty, dfs(i, beauty))\n        return beauty\n\n    return''.join(map(str, [dfs(i + 1, 1) for i in range(n)]))\n"
    },
    {
        "number": 2462,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        if is_nearly_prime(n, 1, 100):\n            print(\"YES\")\n            print(f\"{n} {n - 1} {n - 2} {n - 3}\")\n        else:\n            print(\"NO\")\n\ndef"
    },
    {
        "number": 2463,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    prices = list(map(int, stdin.readline().strip().split()))\n\n    # Sort prices in ascending order\n    prices.sort()\n\n    # Initialize variables\n    max_num_cheap_ice_spheres = 0\n    current_cheap_ice_sphere_prices = []\n\n    # Iterate through prices\n    for i in range(1, n):\n        # Check if current price is cheap\n        if prices[i] - prices[i - 1] >= 2:\n            # If so, add current price to current cheap ice sphere prices\n            current_cheap_ice_sphere_prices.append(prices[i])\n            # Update max number of cheap ice spheres\n            max_num_cheap_ice_spheres = max(max_num_cheap_ice_spheres, len(current_cheap_ice_sphere_prices))\n\n    # Print the maximum number of cheap ice spheres\n    print(max_num_cheap_ice_spheres)\n\n    # Print the prices of cheap ice spheres\n    for price in current_cheap_ice_sphere_prices:\n        print(price)\n\n    return \"\""
    },
    {
        "number": 2464,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        x, y, c = map(int, stdin.readline().strip().split())\n        edges.append((x, y, c))\n\n    def dfs(x, visited):\n        if x in visited:\n            return\n        visited.add(x)\n        for y, c in edges:\n            if c == 1 and y!= x:\n                dfs(y, visited)\n\n    visited = set()\n    dfs(0, visited)\n    return len(visited)"
    },
    {
        "number": 2465,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    ans = -1\n    for _ in range(T):\n        ang = int(stdin.readline())\n        n = 0\n        while True:\n            a, b, c = map(int, stdin.readline().split())\n            if a == b == c:\n                break\n            n += 1\n        if n == 3:\n            if abs(ang - 50) < 1000000000:\n                ans = n\n                break\n        elif n == 180:\n            ans = n\n            break\n    return str(ans)"
    },
    {
        "number": 2466,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    result = []\n    backtrack(input_list, [], result)\n    return \"\\n\".join(map(str, result))\n\ndef"
    },
    {
        "number": 2467,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    result = []\n    for i in range(1, 10):\n        if i + n - k in result:\n            continue\n        if sum(i for i in range(1, k+1) if i + n - k == i + n):\n            result.append(i + n - k)\n    return str(result)"
    },
    {
        "number": 2468,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    max_length = 0\n    for char in stdin:\n        if char == '(':\n            stack.append(char)\n        else:\n            if len(stack) == 0:\n                return \"Invalid input\"\n            else:\n                stack.pop()\n                if len(stack) == 0:\n                    max_length = max(max_length, len(stack))\n    if len(stack)!= 0:\n        return \"Invalid input\"\n    return str(max_length)"
    },
    {
        "number": 2469,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    arr = list(map(int, stdin.strip().split()))\n    count = [0] * n\n    for num in arr:\n        count[num - 1] += 1\n    result = []\n    for i in range(n):\n        if count[i] > n // 3:\n            result.append(i + 1)\n    return ','.join(map(str, result))"
    },
    {
        "number": 2470,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    arr1 = list(map(int, stdin.strip().split()))\n    arr2 = list(map(int, stdin.strip().split()))\n    \n    if len(arr1)!= len(arr2):\n        return \"-1\"\n    \n    for i in range(len(arr1)):\n        if arr1[i] > arr2[i]:\n            return \"-1\"\n    \n    return str(len(arr1))"
    },
    {
        "number": 2471,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, N = map(int, stdin.split())\n    grid = [[0] * W for _ in range(H)]\n    for _ in range(N):\n        a, b = map(int, stdin.split())\n        grid[a - 1][b - 1] = 1\n\n    def count_black_subrectangles(x, y, w, h):\n        count = 0\n        for i in range(x, x + w):\n            for j in range(y, y + h):\n                if grid[i][j] == 1:\n                    count += 1\n        return count\n\n    black_subrectangles = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 1:\n                black_subrectangles.append(count_black_subrectangles(i, j, 3, 3))\n\n    return '\\n'.join(map(str, black_subrectangles))"
    },
    {
        "number": 2472,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    jobs = []\n    for _ in range(N):\n        job_info = list(map(int, stdin.readline().strip().split()))\n        jobs.append(job_info)\n\n    current_time = 0\n    for job in jobs:\n        if current_time < job[1]:\n            return \"No\"\n        current_time += job[0]\n\n    return \"Yes\""
    },
    {
        "number": 2473,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    # Find the minimum possible area of the rectangle\n    min_area = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            if x[i] == x[j] and y[i] == y[j]:\n                continue\n            if i == 0 or j == N-1:\n                min_area = min(min_area, abs(x[i] - x[j]) * abs(y[i] - y[j]))\n\n    return str(min_area)"
    },
    {
        "number": 2474,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    C = list(map(int, stdin.strip().split()))\n    MOD = 10**9 + 7\n\n    def f(S, T):\n        D = 0\n        for i in range(N):\n            if S[i]!= T[i]:\n                D += 1\n        return D * C[0]\n\n    def dp(i, j):\n        if i == j:\n            return 0\n        if i == 0:\n            return dp(i + 1, j)\n        if j == 0:\n            return dp(i, j + 1)\n        return (dp(i - 1, j) + dp(i, j - 1)) % MOD\n\n    ans = dp(N - 1, N - 1)\n    return str(ans)"
    },
    {
        "number": 2475,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    s_0 = int(stdin.strip())\n    s_1 = int(stdin.strip())\n    s_2 = int(stdin.strip())\n    s_3 = int(stdin.strip())\n    s_4 = int(stdin.strip())\n    s_5 = int(stdin.strip())\n\n    score = 0\n    for i in range(N):\n        if i == 0:\n            score += s_0\n        elif i == 1:\n            score += s_1\n        elif i == 2:\n            score += s_2\n        elif i == 3:\n            score += s_3\n        elif i == 4:\n            score += s_4\n        elif i == 5:\n            score += s_5\n        else:\n            score += 10**100\n\n    return str(score)"
    },
    {
        "number": 2476,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    # Find the maximum number of times Takahashi can do the operation\n    max_count = 0\n    for k in range(1, N + 1):\n        count = 0\n        for a in A:\n            if a == A[k - 1]:\n                count += 1\n                if count == k:\n                    max_count = max(max_count, count)\n        if max_count == 0:\n            break\n\n    # Print the answer\n    for i in range(max_count):\n        print(A[i])"
    },
    {
        "number": 2477,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    logs = []\n    for _ in range(N):\n        A = map(int, stdin.split())\n        logs.append(A)\n\n    cuts = 0\n    max_length = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if logs[i][-1] - logs[j][-1] <= K:\n                cuts += 1\n                max_length = max(max_length, logs[i][-1] - logs[j][-1])\n\n    return str(int(max_length + 0.5))"
    },
    {
        "number": 2478,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    S = stdin.strip()\n\n    def is_valid_bracket_sequence(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack[-1]!= '(':\n                    return False\n                stack.pop()\n        return not stack\n\n    if not is_valid_bracket_sequence(S):\n        return \"Invalid bracket sequence\"\n\n    def shortest_valid_bracket_sequence(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack[-1]!= '(':\n                    return False\n                stack.pop()\n        return ''.join(stack)\n\n    shortest_valid_bracket_sequences = []\n    for i in range(1, N + 1):\n        for j in range(i):\n            s = S[:i] + '(' + S[i:j] + ')' + S[j:]\n            if is_valid_bracket_sequence(s):\n                shortest_valid_bracket_sequences.append(s)\n\n    shortest_valid_bracket_sequences.sort(key=lambda x: len(x), reverse=True)\n    return shortest_valid_bracket_sequences[0]\n"
    },
    {
        "number": 2479,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    grid = [[0] * N for _ in range(N)]\n    black_stones = set()\n\n    for _ in range(Q):\n        query = list(map(int, stdin.split()))\n        row, col = query[0], query[1]\n        if row == 1 and col == 1:\n            grid[row - 1][col - 1] = 1\n            black_stones.add((row - 1, col - 1))\n        elif row == N - 2 and col == N - 2:\n            grid[row + 1][col + 1] = 1\n            black_stones.add((row + 1, col + 1))\n        else:\n            for i in range(row - 1, row + 2):\n                for j in range(col - 1, col + 2):\n                    if i == row - 1 or i == row + 1 or j == col - 1 or j == col + 1:\n                        grid[i][j] = 1\n                    else:\n                        grid[i][j] = 0\n            for stone in black_stones:\n                if stone[0] == row - 1 and stone[1] == col - 1:\n                    grid[stone[0]][stone[1]] = 1\n                elif stone[0] == row + 1 and stone[1] == col + 1:\n                    grid[stone[0]][stone[1]] = 1\n                elif stone[0] == row - 1 and stone[1] == col + 1:\n                    grid[stone[0]][stone[1]] = 1\n                elif stone[0] == row + 1 and stone[1] == col - 1:\n                    grid[stone[0]][stone[1]] = 1\n\n    return str(sum(grid[row][col] for row in range(N) for col in range(N) if grid[row][col] == 1))\n"
    },
    {
        "number": 2480,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def is_valid(a, k, i, j):\n        return a[i] + a[j] % k == a[i] + a[j] // k\n\n    count = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if is_valid(A, K, i, j):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2481,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    c = [[0] * W for _ in range(H)]\n    A = [[-1] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            c[i][j], A[i][j] = map(int, stdin.split())\n\n    total_mp = 0\n    for i in range(H):\n        for j in range(W):\n            if A[i][j] == -1:\n                continue\n            total_mp += c[i][j] * (i + j)\n\n    return str(total_mp)\n"
    },
    {
        "number": 2482,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    cities = []\n    for _ in range(N):\n        p, q = map(int, stdin.split())\n        cities.append((p, q))\n\n    roads = []\n    for _ in range(L):\n        r, s = map(int, stdin.split())\n        roads.append((r, s))\n\n    railways = []\n    for _ in range(K):\n        r, s = map(int, stdin.split())\n        railways.append((r, s))\n\n    connected_cities = []\n    for i in range(N):\n        connected_cities.append(0)\n\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            if (cities[i] == cities[j]) and (cities[i] not in connected_cities):\n                connected_cities.append(cities[i])\n\n    for i in range(L):\n        for j in range(K):\n            if i == j:\n                continue\n            if (roads[i] == railways[j]) and (railways[j] not in connected_cities):\n                connected_cities.append(railways[j])\n\n    for i in range(K):\n        for j in range(K):\n            if i == j:\n                continue\n            if (railways[i] == railways[j]) and (railways[i] not in connected_cities):\n                connected_cities.append(railways[i])\n\n    result = []\n    for i in range(N):\n        result.append(len(connected_cities))\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2483,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    recorders = []\n    for _ in range(n):\n        s, t, c = map(int, stdin.split())\n        recorders.append((s, t, c))\n\n    def can_record(s, t, c):\n        for r in recorders:\n            if r[2] == c:\n                if s < r[0] or s > r[1]:\n                    continue\n                if s - 0.5 < r[0] or s - 0.5 > r[1]:\n                    continue\n                if t < r[0] or t > r[1]:\n                    continue\n                if t - 0.5 < r[0] or t - 0.5 > r[1]:\n                    continue\n                return False\n        return True\n\n    def min_recorders(s, t, c):\n        count = 0\n        for r in recorders:\n            if r[2] == c:\n                if s < r[0] or s > r[1]:\n                    continue\n                if s - 0.5 < r[0] or s - 0.5 > r[1]:\n                    continue\n                if t < r[0] or t > r[1]:\n                    continue\n                if t - 0.5 < r[0] or t - 0.5 > r[1]:\n                    continue\n                count += 1\n        return count\n\n    min_count = float('inf')\n    for s in range(1, 1000001):\n        for t in range(s, 1000001):\n            if can_record(s, t, c):\n                count = min_recorders(s, t, c)\n                if count < min_count:\n                    min_count = count\n\n    return str(min_count)"
    },
    {
        "number": 2484,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            if A[i] ^ A[j] == A[i] + A[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2485,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, M = map(int, stdin.split())\n    targets = []\n    for _ in range(M):\n        h, w = map(int, stdin.split())\n        targets.append((h, w))\n\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W\n\n    def is_bomb_placed(x, y):\n        for target in targets:\n            if x == target[0] and y == target[1]:\n                return True\n        return False\n\n    def destroy_target(x, y):\n        for target in targets:\n            if x == target[0] or y == target[1]:\n                targets.remove(target)\n                return True\n        return False\n\n    def max_targets_to_destroy():\n        max_count = 0\n        for i in range(H):\n            for j in range(W):\n                if not is_bomb_placed(i, j):\n                    count = 0\n                    for dx in [-1, 0, 1]:\n                        for dy in [-1, 0, 1]:\n                            if is_valid(i + dx, j + dy):\n                                count += 1\n                                if count > max_count:\n                                    max_count = count\n                        if count > max_count:\n                            max_count = count\n        return max_count\n\n    return str(max_targets_to_destroy())"
    },
    {
        "number": 2486,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    good_sets = set()\n    for i in range(N):\n        good_set = set(a[:i+1])\n        if sum(good_set) >= K:\n            good_sets.add(good_set)\n\n    unnecessary_cards = 0\n    for i in range(N):\n        if i not in good_sets:\n            unnecessary_cards += 1\n\n    return str(unnecessary_cards)"
    },
    {
        "number": 2487,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, stdin.readline().strip().split())\n        edges.append((u, v))\n\n    def dfs(u, visited, parent, depth):\n        visited[u] = True\n        for v, w in edges[u]:\n            if not visited[v]:\n                dfs(v, visited, u, depth + 1)\n        if depth == 1:\n            return 1\n        return depth\n\n    visited = [False] * n\n    parent = [-1] * n\n    depth = [0] * n\n    for u in range(n):\n        if not visited[u]:\n            dfs(u, visited, -1, 1)\n\n    result = 0\n    for u in range(n):\n        for v in range(n):\n            if u!= v and not visited[u] and not visited[v]:\n                result += dfs(u, visited, v, 1)\n\n    return str(result)"
    },
    {
        "number": 2488,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, A = map(int, stdin.split())\n    X = list(map(int, stdin.split()))\n    H = list(map(int, stdin.split()))\n\n    # Initialize the minimum number of bombs needed\n    min_bombs = 0\n\n    # Iterate through the monsters\n    for i in range(N):\n        # Check if the monster is standing on a number line\n        if X[i] == 0:\n            # Check if the monster is not already at the maximum health\n            if H[i] < A:\n                # Decrease the health of all monsters between the coordinates x-D and x+D (inclusive) by A\n                for j in range(i - D, i + D + 1):\n                    if 0 <= j < N and H[j] >= A:\n                        H[j] -= A\n                        min_bombs += 1\n\n    return str(min_bombs)"
    },
    {
        "number": 2489,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(1, N):\n        if A[i]!= A[i - 1]:\n            count += 1\n\n    print(count)\n    return \"\""
    },
    {
        "number": 2490,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline())\n    total_banknotes = 0\n    for i in range(1, 10**100+1):\n        if i % 10 == 0:\n            total_banknotes += i\n        else:\n            total_banknotes += i * 10\n    if total_banknotes >= N:\n        return str(total_banknotes)\n    else:\n        return \"0\""
    },
    {
        "number": 2491,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b, c = map(int, stdin.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n    visited = [False] * (N + 1)\n    visited[1] = True\n    score = 0\n    while True:\n        for i in range(1, N + 1):\n            if not visited[i]:\n                dfs(i, graph, visited, score)\n        if score == N:\n            return str(score)\n        if score == float('inf'):\n            return 'inf'\n\ndef"
    },
    {
        "number": 2492,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    # Sort the numbers in ascending order\n    A.sort()\n\n    # Compute the products of the pairs\n    products = [A[i] * A[i + 1] for i in range(N - 1)]\n\n    # Sort the products in ascending order\n    products.sort()\n\n    # Return the K-th number in the sorted list\n    return str(products[K - 1])"
    },
    {
        "number": 2493,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    MOD = 10**9 + 7\n\n    def count_subsequences(start, end, k):\n        if start == end:\n            return 1\n\n        count = 0\n        for i in range(start, end + 1):\n            count += count_subsequences(i + 1, end, k)\n\n        return count % MOD\n\n    count = 0\n    for i in range(1, n + 1):\n        count += count_subsequences(i, i, n)\n\n    return str(count)"
    },
    {
        "number": 2494,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    if K < 2 or K > 10**5:\n        return \"Invalid input. Please enter a positive integer between 2 and 10^5.\"\n\n    def sum_of_digits(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n\n    def smallest_sum(num: int) -> int:\n        return sum_of_digits(num) - num\n\n    def smallest_multiple(num: int) -> int:\n        return smallest_sum(num) // K\n\n    return str(smallest_multiple(K))"
    },
    {
        "number": 2495,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n    count = 0\n    for i in range(1, n):\n        if a[i] == a[i-1]:\n            count += 1\n        else:\n            count += 2\n    return str(count)"
    },
    {
        "number": 2496,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    if N == 1:\n        return \"not coprime\"\n\n    for i in range(1, N):\n        if A[i] % A[0]!= 0:\n            return \"not coprime\"\n\n    return \"pairwise coprime\""
    },
    {
        "number": 2497,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    x_min = float('inf')\n    x_max = float('-inf')\n    y_min = float('inf')\n    y_max = float('-inf')\n\n    for _ in range(N):\n        x, y, d = map(int, stdin.readline().strip().split())\n        if d == 'R':\n            x_min = min(x_min, x)\n            x_max = max(x_max, x)\n            y_min = min(y_min, y)\n            y_max = max(y_max, y)\n        elif d == 'L':\n            x_min = min(x_min, x)\n            x_max = max(x_max, x)\n            y_min = min(y_min, y)\n            y_max = max(y_max, y)\n        elif d == 'U':\n            x_min = min(x_min, x)\n            x_max = max(x_max, x)\n            y_min = min(y_min, y)\n            y_max = max(y_max, y)\n        elif d == 'D':\n            x_min = min(x_min, x)\n            x_max = max(x_max, x)\n            y_min = min(y_min, y)\n            y_max = max(y_max, y)\n\n    return str(abs(x_max - x_min) * (y_max - y_min))"
    },
    {
        "number": 2498,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    count = 0\n    for i in range(1, M+1):\n        if i % 2 == 0:\n            for j in range(1, N+1):\n                if A[j-1] * (i+0.5) == i:\n                    count += 1\n    return str(count)"
    },
    {
        "number": 2499,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    xor_red = 0\n    xor_blue = 0\n\n    for num in A:\n        xor_red ^= num\n        xor_blue ^= num\n\n    max_beauty = max(xor_red, xor_blue)\n\n    return str(max_beauty)"
    },
    {
        "number": 2500,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    MOD = 10**9 + 7\n    count = 0\n    for i in range(1, N):\n        for j in range(i + 1, N):\n            if (i ^ j) % 2 == 0:\n                count += 1\n                if count == MOD:\n                    break\n    return str(count)"
    },
    {
        "number": 2501,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    attendees = list(map(int, stdin.readline().strip().split()))\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if abs(attendees[i] - attendees[j]) == sum(attendees[i:j+1]):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2502,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.strip().split()\n    s = s.lower()\n    t = t.lower()\n\n    i = 0\n    max_i = 0\n\n    for j in range(len(s)):\n        if s[j:j+len(t)] == t:\n            i += 1\n            if i > max_i:\n                max_i = i\n\n    if max_i == 0:\n        return \"-1\"\n    else:\n        return str(max_i)"
    },
    {
        "number": 2503,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n    c = list(map(str, stdin.split()))\n\n    def dfs(x, y, c, visited, path, max_count):\n        if len(path) == K * K:\n            return max_count\n\n        if (x, y) in visited:\n            return max_count\n\n        visited.add((x, y))\n        path.append((x, y))\n\n        if c[x][y] == 'B':\n            max_count = max(max_count, dfs(x - 1, y, c, visited, path, max_count))\n            max_count = max(max_count, dfs(x + 1, y, c, visited, path, max_count))\n            max_count = max(max_count, dfs(x, y - 1, c, visited, path, max_count))\n            max_count = max(max_count, dfs(x, y + 1, c, visited, path, max_count))\n        elif c[x][y] == 'W':\n            max_count = max(max_count, dfs(x - 1, y, c, visited, path, max_count))\n            max_count = max(max_count, dfs(x + 1, y, c, visited, path, max_count))\n            max_count = max(max_count, dfs(x, y - 1, c, visited, path, max_count))\n            max_count = max(max_count, dfs(x, y + 1, c, visited, path, max_count))\n\n        path.pop()\n        visited.remove((x, y))\n\n        return max_count\n\n    max_count = dfs(0, 0, c, set(), [], 0)\n    return str(max_count)\n"
    },
    {
        "number": 2504,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, L = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    Q = int(stdin.strip())\n    s = list(map(int, stdin.split()))\n    t = list(map(int, stdin.split()))\n\n    def dfs(start, end, visited, path):\n        if start == end:\n            return 1\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return dfs(t[0], end, visited, path)\n            if start == t[0]:\n                return dfs(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel(t[0], end, visited, path)\n            if start == t[0]:\n                return min_fuel(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel_helper(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel_helper(t[0], end, visited, path)\n            if start == t[0]:\n                return min_fuel_helper(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel_helper_helper(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel_helper_helper(t[0], end, visited, path)\n            if start == t[0]:\n                return min_fuel_helper_helper(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel_helper_helper_helper(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel_helper_helper_helper(t[0], end, visited, path)\n            if start == t[0]:\n                return min_fuel_helper_helper_helper(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel_helper_helper_helper_helper(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel_helper_helper_helper_helper(t[0], end, visited, path)\n            if start == t[0]:\n                return min_fuel_helper_helper_helper_helper(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel_helper_helper_helper_helper_helper(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel_helper_helper_helper_helper_helper(t[0], end, visited, path)\n            if start == t[0]:\n                return min_fuel_helper_helper_helper_helper_helper(start, s[0], visited, path)\n            path.pop()\n            return 0\n\n        path.pop()\n        return 0\n\n    def min_fuel_helper_helper_helper_helper_helper_helper_helper(start, end, visited, path):\n        if start == end:\n            return 0\n\n        if start not in visited:\n            visited.add(start)\n            path.append(start)\n            if start == s[0]:\n                return min_fuel_helper_helper_helper_helper_helper_helper(t[0], end, visited, path)\n            if start == t"
    },
    {
        "number": 2505,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    points = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    def is_valid(p1, p2, p3):\n        return p1[0] <= p2[0] <= p3[0] and p1[1] <= p2[1] <= p3[1]\n\n    def is_parallel(p1, p2, p3):\n        return p1[0] * p2[1]!= p2[0] * p1[1] and p2[0] * p3[1]!= p3[0] * p2[1] and p3[0] * p1[1]!= p1[0] * p3[1]\n\n    def find_rectangle(points):\n        x_min, y_min = min(p[0] for p in points), min(p[1] for p in points)\n        x_max, y_max = max(p[0] for p in points), max(p[1] for p in points)\n        return (x_min, y_min, x_max, y_max)\n\n    def count_valid_rectangles(points):\n        rectangles = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if is_valid(points[i], points[j], points[j - 1]) and is_parallel(points[i], points[j], points[j - 1]):\n                    rectangles.append((points[i], points[j], points[j - 1]))\n        return rectangles\n\n    def sum_f(rectangles):\n        return sum(len(rect) for rect in rectangles)\n\n    rectangles = count_valid_rectangles(points)\n    return str(sum_f(rectangles))"
    },
    {
        "number": 2506,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def is_valid(x, y):\n        return x!= y\n\n    def is_valid_pair(x, y):\n        return is_valid(x, y) and (x!= y)\n\n    def max_happiness(A):\n        happiness = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if is_valid_pair(i, j) and A[i] + A[j] > happiness:\n                    happiness = A[i] + A[j]\n        return happiness\n\n    return str(max_happiness(A))\n"
    },
    {
        "number": 2507,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    F = list(map(int, stdin.split()))\n\n    # Initialize the scores\n    scores = [0] * N\n\n    # Initialize the training sets\n    training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal dishes\n    optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal scores\n    optimal_scores = [0] * N\n\n    # Initialize the optimal training sets\n    optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal dishes\n    optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal scores\n    optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal training sets\n    optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal dishes\n    optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal scores\n    optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal training sets\n    optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_optimal_optimal_training_sets = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal dishes\n    optimal_optimal_optimal_optimal_optimal_dishes = [[] for _ in range(N)]\n\n    # Initialize the optimal optimal optimal optimal optimal scores\n    optimal_optimal_optimal_optimal_optimal_scores = [0] * N\n\n    # Initialize the optimal optimal optimal optimal optimal training sets\n    optimal_optimal_optimal_"
    },
    {
        "number": 2508,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, K = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n    c = [list(map(str, stdin.split())) for _ in range(H)]\n\n    def dfs(i, j, visited):\n        if i < 0 or i >= H or j < 0 or j >= W or c[i][j] == '@':\n            return False\n        if c[i][j] == 'L':\n            return False\n        if (i, j) in visited:\n            return False\n        visited.add((i, j))\n        if i == x1 and j == y1:\n            return True\n        if i == x2 and j == y2:\n            return True\n        if dfs(i + 1, j, visited) or dfs(i - 1, j, visited) or dfs(i, j + 1, visited) or dfs(i, j - 1, visited):\n            return True\n        return False\n\n    if dfs(0, 0, set()):\n        return \"Impossible\"\n    else:\n        return str(K - 1)"
    },
    {
        "number": 2509,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    pairs = []\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if i % j == 0 and i!= j and i % K == 0:\n                pairs.append((i, j))\n    return str(len(pairs))"
    },
    {
        "number": 2510,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = set()\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        friends.add((a, b))\n    groups = []\n    for i in range(n):\n        if i % 3 == 0:\n            groups.append(set())\n        for j in range(i + 1, n):\n            if i!= j and i not in friends and j not in friends:\n                if i in groups[j]:\n                    groups[j].remove(i)\n                if j in groups[i]:\n                    groups[i].remove(j)\n                groups[i].add(j)\n    return str(len(groups))"
    },
    {
        "number": 2511,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    tree = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        a, b = map(int, stdin.split())\n        tree[a - 1].append(b - 1)\n        tree[b - 1].append(a - 1)\n\n    def dfs(node, color):\n        if node == -1:\n            return 1\n\n        ways = 0\n        for neighbor in tree[node]:\n            ways += dfs(neighbor, color)\n\n        if ways == 0:\n            ways = 1\n\n        ways = (ways + 1) % (10**9 + 7)\n        return ways\n\n    ways = dfs(1, 1)\n    return str(ways)"
    },
    {
        "number": 2512,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    items = []\n    for _ in range(K):\n        r, c, v = map(int, stdin.split())\n        items.append((r, c, v))\n\n    def dfs(i, j, visited):\n        if i == R or j == C:\n            return 0\n\n        if (i, j) in visited:\n            return 0\n\n        visited.add((i, j))\n        if i > 0 and items[(i - 1, j)].value == 0:\n            return dfs(i - 1, j, visited) + items[(i - 1, j)].value\n        if i < R - 1 and items[(i + 1, j)].value == 0:\n            return dfs(i + 1, j, visited) + items[(i + 1, j)].value\n        if j > 0 and items[(i, j - 1)].value == 0:\n            return dfs(i, j - 1, visited) + items[(i, j - 1)].value\n        if j < C - 1 and items[(i, j + 1)].value == 0:\n            return dfs(i, j + 1, visited) + items[(i, j + 1)].value\n\n        return dfs(i + 1, j, visited) + dfs(i - 1, j, visited) + dfs(i, j + 1, visited) + dfs(i, j - 1, visited)\n\n    max_sum = 0\n    for i in range(R):\n        for j in range(C):\n            if items[(i, j)].value > 0:\n                max_sum = max(max_sum, dfs(i, j, set()))\n\n    return str(max_sum)\n"
    },
    {
        "number": 2513,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    s = stdin.strip()\n    t = \"\"\n    for i in range(N):\n        if s[i] == \"o\":\n            t += \"S\"\n        elif s[i] == \"x\":\n            t += \"W\"\n    return t"
    },
    {
        "number": 2514,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    C = list(map(int, stdin.split()))\n\n    for i in range(Q):\n        for j in range(N):\n            if A[j] == B[i]:\n                A[j] = C[i]\n\n    S = sum(A)\n    return '\\n'.join(map(str, S))"
    },
    {
        "number": 2515,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.readline())\n    similar_numbers = []\n\n    for _ in range(Q):\n        l, r = map(int, stdin.readline().split())\n        if l % 2 == 0 or r % 2 == 0:\n            continue\n\n        for i in range(l, r + 1):\n            if i % 2 == 0:\n                continue\n\n            if i == 2017:\n                similar_numbers.append(i)\n                break\n\n            if i % (i + 1) == 0:\n                similar_numbers.append(i)\n                break\n\n    return str(len(similar_numbers))"
    },
    {
        "number": 2516,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = list(map(int, input().split()))\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            substring = S[i:j]\n            if substring.count(0) == 0 and int(substring, 10) % P == 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2517,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, R = map(int, stdin.split())\n    roads = []\n    for _ in range(M):\n        a, b, c = map(int, stdin.split())\n        roads.append((a, b, c))\n\n    def min_distance(towns):\n        distances = [float('inf')] * N\n        distances[towns[0]] = 0\n        for town in towns[1:]:\n            for road in roads:\n                if town[0] == road[0] or town[1] == road[1]:\n                    continue\n                d = min(distances[town[0]], distances[town[1]], road[2] + distances[town[0]] + distances[town[1]])\n                distances[town[0]] = distances[town[1]] = d\n        return distances[towns[-1]]\n\n    towns = list(range(N))\n    min_distance(towns)\n    return str(min_distance(towns))"
    },
    {
        "number": 2518,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    explosions = 0\n    for i in range(N):\n        health = int(stdin.readline())\n        if health > 0:\n            explosions += 1\n            for j in range(i+1, N):\n                if health > 0:\n                    health -= A\n                    if health < 0:\n                        health = 0\n                    stdin.write(str(health) + '\\n')\n                else:\n                    break\n    return str(explosions)"
    },
    {
        "number": 2519,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    # Calculate the expected value of the sum of the numbers shown\n    expected_value = 0\n    for i in range(N):\n        for j in range(K):\n            expected_value += p[i]\n\n    # Find the maximum possible value of the expected value\n    max_expected_value = max(expected_value, 0)\n\n    return str(max_expected_value)\n"
    },
    {
        "number": 2520,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    friend_candidates = set()\n\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            if (i, j) not in friend_candidates and (j, i) not in friend_candidates:\n                friend_candidates.add((i, j))\n\n    return \" \".join(str(len(friend_candidates)) for _ in range(N))"
    },
    {
        "number": 2521,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    a_1 = a[0:N//2]\n    a_2 = a[N//2:]\n\n    score_1 = sum(a_1) - sum(a_2)\n    score_2 = sum(a_2) - sum(a_1)\n\n    max_score = max(score_1, score_2)\n\n    return str(max_score)"
    },
    {
        "number": 2522,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    B = list(map(int, stdin.readline().strip().split()))\n\n    if N!= len(A) or N!= len(B):\n        return \"No.\"\n\n    for i in range(N):\n        if A[i]!= B[i]:\n            return \"No.\"\n\n    for i in range(N):\n        if A[i] == B[i]:\n            continue\n        for j in range(i + 1, N):\n            if A[i] < B[j]:\n                break\n            elif A[i] > B[j]:\n                return \"No.\"\n\n    for i in range(N):\n        if A[i] == B[i]:\n            continue\n        for j in range(i + 1, N):\n            if A[i] < B[j]:\n                break\n            elif A[i] > B[j]:\n                return \"No.\"\n\n    return \"Yes\\n\" + \" \".join(map(str, B))\n"
    },
    {
        "number": 2523,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    N = len(S)\n    K = 1\n    max_k = 0\n\n    for i in range(N):\n        if S[i] == '0':\n            for j in range(i, N):\n                if S[j] == '0':\n                    S = S[:i] + '1' + S[i+1:]\n                    i += 1\n                    break\n        elif S[i] == '1':\n            for j in range(i, N):\n                if S[j] == '1':\n                    S = S[:i] + '0' + S[i+1:]\n                    i += 1\n                    break\n        else:\n            max_k = max(max_k, i - K + 1)\n\n    return str(max_k)"
    },
    {
        "number": 2524,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    MOD = 10**9 + 7\n    result = 0\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            result = (result + (A[i] ^ A[j])) % MOD\n\n    return str(result)"
    },
    {
        "number": 2525,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    Q = int(stdin.readline().strip())\n    result = \"\"\n\n    for i in range(Q):\n        T_i = int(stdin.readline().strip())\n        if T_i == 1:\n            result = result[::-1]\n        elif T_i == 2:\n            F_i = int(stdin.readline().strip())\n            C_i = stdin.readline().strip()\n            if F_i == 1:\n                result = C_i + result\n            else:\n                result = result + C_i\n\n    return result"
    },
    {
        "number": 2526,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y, A, B, C = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n    q = list(map(int, stdin.split()))\n    r = list(map(int, stdin.split()))\n\n    def max_sum(p, q, r):\n        max_sum = 0\n        for i in range(X):\n            for j in range(Y):\n                for k in range(A):\n                    for l in range(B):\n                        for m in range(C):\n                            max_sum = max(max_sum, p[i] + q[j] + r[k] + l + m)\n        return max_sum\n\n    return str(max_sum(p, q, r))"
    },
    {
        "number": 2527,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    message = stdin.strip()\n    if message == \"iloveyou\":\n        return \"happy\"\n    else:\n        return \"sad\""
    },
    {
        "number": 2528,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n\n    max_length = 0\n    max_product = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            subarray = A[i:j+1]\n            product = 1\n            for num in subarray:\n                product *= num\n\n            if product > 0:\n                if j - i + 1 > max_length:\n                    max_length = j - i + 1\n                    max_product = product\n\n    return str(max_length)"
    },
    {
        "number": 2529,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x % 5!= 0:\n        return \"Invalid withdrawal amount\"\n\n    if y < 0 or y > 2000:\n        return \"Invalid account balance\"\n\n    if y < x:\n        return \"Insufficient funds\"\n\n    y = round(y, 2)\n    y += 0.50\n\n    return str(y)\n"
    },
    {
        "number": 2530,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    chefs = {}\n    for _ in range(n):\n        name, country = stdin.split()\n        chefs[name] = country\n\n    max_votes = 0\n    max_country = \"\"\n    max_chef = \"\"\n\n    for _ in range(m):\n        subject = stdin.strip()\n        if subject in chefs:\n            votes = chefs[subject]\n            if votes > max_votes:\n                max_votes = votes\n                max_country = subject\n                max_chef = name\n\n    return f\"{max_country} {max_chef}\""
    },
    {
        "number": 2531,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    count = 0\n    for i in range(N):\n        a = int(stdin.strip())\n        if a == a // 2:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2532,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    a1, a2, a3, a4, a5, a6, a7, a8, a9, a10 = map(int, stdin.split())\n    b1, b2, b3, b4, b5, b6, b7, b8, b9, b10 = map(int, stdin.split())\n    d1, d2, d3, d4, d5, d6, d7, d8, d9, d10 = map(int, stdin.split())\n\n    def power(x, n):\n        if n == 0:\n            return 1\n        if n % 2 == 0:\n            return power(x * x, n // 2)\n        else:\n            return x * power(x * x, n - 1)\n\n    def recursive_sequence(n):\n        if n == 0:\n            return [0]\n        else:\n            return [a1 * recursive_sequence(n - 1)[0] + a2 * recursive_sequence(n - 1)[1] + a3 * recursive_sequence(n - 1)[2] + a4 * recursive_sequence(n - 1)[3] + a5 * recursive_sequence(n - 1)[4] + a6 * recursive_sequence(n - 1)[5] + a7 * recursive_sequence(n - 1)[6] + a8 * recursive_sequence(n - 1)[7] + a9 * recursive_sequence(n - 1)[8] + a10 * recursive_sequence(n - 1)[9]]\n\n    sequence = recursive_sequence(10)\n    return''.join(map(str, sequence))"
    },
    {
        "number": 2533,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.split())\n    roads = []\n    for _ in range(E):\n        a, b = map(int, stdin.split())\n        roads.append((a, b))\n\n    def is_tourist_friendly(roads, visited):\n        for i in range(len(roads)):\n            if i in visited:\n                continue\n            if roads[i][0] == roads[i][1]:\n                return False\n            if is_tourist_friendly(roads, visited + [i]):\n                return True\n        return True\n\n    if not is_tourist_friendly(roads, []):\n        return \"NO\"\n\n    output = []\n    for i in range(N):\n        output.append(roads[i])\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 2534,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    matrix = [list(map(int, stdin.split())) for _ in range(R)]\n\n    def min_cost(row, col):\n        min_cost = float('inf')\n        for i in range(C):\n            if matrix[row][i] < min_cost:\n                min_cost = matrix[row][i]\n        return min_cost\n\n    def max_cost(row, col):\n        max_cost = float('-inf')\n        for i in range(C):\n            if matrix[i][col] > max_cost:\n                max_cost = matrix[i][col]\n        return max_cost\n\n    min_row = min(range(R), key=lambda x: min_cost(x, 0))\n    max_col = max(range(C), key=lambda x: max_cost(0, x))\n\n    if min_row == 0 and max_col == C - 1:\n        return \"GUESS\"\n    else:\n        return str(matrix[min_row][max_col])"
    },
    {
        "number": 2535,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, N = map(int, stdin.split())\n    free_places = [0] * 54\n    booked_places = [0] * 54\n    for i in range(N):\n        free_places[int(stdin[i])] = 1\n        booked_places[int(stdin[i])] = 1\n\n    def backtrack(i, j):\n        if i == j:\n            return 1\n\n        ways = 0\n        for k in range(i, j + 1):\n            if free_places[k] == 1 and booked_places[k] == 0:\n                ways += backtrack(k + 1, j)\n\n        return ways\n\n    return str(backtrack(1, 53))\n"
    },
    {
        "number": 2536,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, L = map(int, stdin.split())\n    A = []\n    for _ in range(N):\n        A.append(list(map(int, stdin.split())))\n\n    E1 = 0\n    E2 = 0\n    for i in range(N):\n        for j in range(M):\n            if i == 0 or j == 0:\n                E1 += A[i][j]\n            if i == N - 1 or j == M - 1:\n                E2 += A[i][j]\n\n    for i in range(L):\n        ik, jk = map(int, stdin.split())\n        if i == 0 or jk == 0:\n            E1 += A[ik][jk]\n        if i == L - 1 or jk == M - 1:\n            E2 += A[ik][jk]\n\n    return str(max(E1, E2))"
    },
    {
        "number": 2537,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.readline())\n    for _ in range(q):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        p = stdin.readline().strip()\n        if s == t:\n            print(\"YES\")\n        else:\n            print(\"NO\")"
    },
    {
        "number": 2538,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        str, int, exp = map(int, stdin.readline().split())\n        if str > int:\n            print(1)\n        else:\n            print(0)"
    },
    {
        "number": 2539,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    result = []\n\n    for _ in range(t):\n        x, p, k = map(int, stdin.readline().strip().split())\n        result.append(kth_element(x, p, k))\n\n    return '\\n'.join(map(str, result))\n\n\ndef"
    },
    {
        "number": 2540,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    c = list(map(int, stdin.readline().strip().split()))\n    x = list(map(int, stdin.readline().strip().split()))\n    y = list(map(int, stdin.readline().strip().split()))\n\n    def dfs(v, dominating_colours):\n        if v == 1:\n            return dominating_colours\n        dominating_colours.append(c[v])\n        for i in range(n):\n            if x[i] == v and y[i] == v:\n                continue\n            if i == v:\n                continue\n            if dfs(y[i], dominating_colours):\n                return True\n        return False\n\n    dominating_colours = []\n    for v in range(n):\n        if dfs(v, dominating_colours):\n            dominating_colours.append(0)\n\n    return''.join(map(str, dominating_colours))\n"
    },
    {
        "number": 2541,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.readline())\n    for _ in range(Q):\n        L, R = map(int, stdin.readline().split())\n        count = 0\n        for a in range(1, R+1):\n            for p in range(2, p+1):\n                if L <= a**p <= R:\n                    count += 1\n        print(count)\n    return \"\""
    },
    {
        "number": 2542,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        s = stdin.readline().strip()\n        good = True\n        for i in range(len(s) - 1):\n            if s[i]!= s[i + 1]:\n                good = False\n                break\n        if good:\n            print(len(s) - 1)\n        else:\n            print(0)"
    },
    {
        "number": 2543,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n    r = list(map(int, stdin.split()))\n    x = list(map(int, stdin.split()))\n\n    def f(j):\n        return abs(sum(a[l[i]:r[i]] for i in range(n)) - sum(b[l[i]:r[i]] for i in range(m - n)))\n\n    result = []\n    for _ in range(q):\n        j = int(stdin.split())\n        result.append(f(j))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2544,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    edges = []\n    for _ in range(n - 1):\n        x, y = map(int, stdin.readline().strip().split())\n        edges.append((x, y))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    dfs(0, visited)\n\n    for u in range(n):\n        if not visited[u]:\n            return str(u) + \" \" + str(u)\n\n    return \"0 0\"\n"
    },
    {
        "number": 2545,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        if a == 0 and b == 0:\n            return \"YES\"\n        elif a == 0:\n            b -= 2 * b\n        elif b == 0:\n            a -= 2 * a\n        else:\n            x = 1\n            while a >= 2 * x and b >= 2 * x:\n                x += 1\n            a -= 2 * x\n            b -= 2 * x\n    return \"NO\""
    },
    {
        "number": 2546,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, s = map(int, stdin.readline().split())\n        if n % 2!= 0:\n            print(\"Invalid input\")\n            continue\n        salaries = list(map(int, stdin.readline().split()))\n        if sum(salaries) > s:\n            print(\"Invalid input\")\n            continue\n        max_salary = max(salaries)\n        median = sorted(salaries)[len(salaries) // 2]\n        print(max_salary)"
    },
    {
        "number": 2547,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    books = []\n    for _ in range(n):\n        t, a, b = map(int, stdin.split())\n        books.append((t, a, b))\n\n    def read_books(books, k):\n        total_time = sum(book[0] for book in books)\n        books_in_set = [book for book in books if book[1] == 1 and book[2] == 1]\n        if len(books_in_set) < k:\n            return None\n        return books_in_set\n\n    def find_set(books, k):\n        books_in_set = read_books(books, k)\n        if books_in_set is None:\n            return None\n        return [book[0] for book in books_in_set]\n\n    def find_min_total_time(books, k):\n        set_of_books = find_set(books, k)\n        if set_of_books is None:\n            return -1\n        return sum(book[0] for book in books)\n\n    min_total_time = find_min_total_time(books, k)\n    if min_total_time == -1:\n        return \"No solution\"\n\n    set_of_books = find_set(books, k)\n    if set_of_books is None:\n        return \"No solution\"\n\n    print(min_total_time)\n    print(\" \".join(map(str, set_of_books)))\n\n    return \" \".join(map(str, set_of_books))\n"
    },
    {
        "number": 2548,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    a = list(map(int, stdin.split()[2:]))\n    good_subarrays = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                subarray = a[i:j+1] + a[j:k+1] + a[k:n+1]\n                if sum(subarray) == len(subarray):\n                    good_subarrays += 1\n    return str(good_subarrays)"
    },
    {
        "number": 2549,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    shields = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        shields.append((a, b))\n\n    defense_ratings = [b for shield in shields for b in shield]\n    defense_ratings.sort()\n\n    expected_damage = [1] * m\n    for i in range(m):\n        for j in range(i + 1, m):\n            expected_damage[i] *= (defense_ratings[j] - defense_ratings[i]) / (defense_ratings[i] - defense_ratings[j])\n\n    x = 1\n    for y in range(2, 1000000000):\n        if y % 2 == 0:\n            x = (x * y) % 998244353\n\n    return str(x * expected_damage[0] ** (-1) % 998244353)\n"
    },
    {
        "number": 2550,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Find the maximum possible score\n    max_score = max(a)\n\n    # Find the highest possible score\n    max_score = max(max_score, m)\n\n    return str(max_score)"
    },
    {
        "number": 2551,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        s = stdin.readline().strip()\n        t = stdin.readline().strip()\n        z = ''\n        for i in range(len(s)):\n            if i < len(t):\n                z += s[i]\n            else:\n                z += t[i-len(s):]\n        if z == t:\n            print(1)\n        else:\n            print(-1)"
    },
    {
        "number": 2552,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n, m = map(int, stdin.readline().split())\n        p = list(map(int, stdin.readline().split()))\n        h = list(map(int, stdin.readline().split()))\n        roads = []\n        for _ in range(n - 1):\n            x, y = map(int, stdin.readline().split())\n            roads.append((x, y))\n        for _ in range(m):\n            x, y = map(int, stdin.readline().split())\n            roads.append((x, y))\n        happiness_index = [0] * n\n        for i in range(n):\n            happiness_index[i] = h[i]\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if happiness_index[i] == happiness_index[j]:\n                    happiness_index[i] = happiness_index[i] - 1\n                    happiness_index[j] = happiness_index[j] + 1\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] - happiness_index[i]\n        for i in range(n):\n            happiness_index[i] = happiness_index[i] + happiness_index[i]\n        for i in range(n):\n           "
    },
    {
        "number": 2553,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    odd_sum = sum(a)\n    if odd_sum % 2 == 0:\n        return \"No\"\n    else:\n        return \"Yes\""
    },
    {
        "number": 2554,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    max_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] % 2 == 0 and a[j] % 2 == 0:\n                max_sum = max(max_sum, a[i] + a[j])\n\n    return str(max_sum)\n"
    },
    {
        "number": 2555,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    l = list(map(int, stdin.split()))\n    r = list(map(int, stdin.split()))\n\n    # Build the army\n    army = [a[i] for i in range(n)]\n    army.sort()\n\n    # Perform operations\n    for _ in range(q):\n        l, r = l, r\n        while l < r:\n            army[l], army[r] = army[r], army[l]\n            l += 1\n            r -= 1\n\n    # Calculate the max strength\n    max_strength = sum(army)\n\n    # Print the result\n    result = [max_strength]\n    for i in range(1, q + 1):\n        result.append(army[i - 1] - army[i - 2] + army[i - 3] - army[i - 4] +... + army[i - 1])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2556,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    rooms = []\n    for _ in range(n):\n        c_i, sum_i = map(int, stdin.readline().strip().split())\n        rooms.append((c_i, sum_i))\n\n    min_cost = float('inf')\n    for c_i, sum_i in rooms:\n        if sum_i >= rooms[0][1]:\n            min_cost = min(min_cost, c_i * sum_i)\n\n    return str(min_cost)\n"
    },
    {
        "number": 2557,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    important_pairs = []\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        important_pairs.append((a, b))\n\n    def is_valid(a, b):\n        return a!= b\n\n    def is_important(a, b):\n        return any(is_valid(a, pair) for pair in important_pairs)\n\n    def construct_teleportation_pipe(a, b):\n        if is_important(a, b):\n            return True\n        for pair in important_pairs:\n            if is_valid(pair[0], b) and is_valid(a, pair[1]):\n                return True\n        return False\n\n    def construct_teleportation_pipes(a, b):\n        if is_important(a, b):\n            return 1\n        for pair in important_pairs:\n            if is_valid(pair[0], b) and is_valid(a, pair[1]):\n                return 1 + construct_teleportation_pipes(pair[0], pair[1])\n        return 0\n\n    pipes = [construct_teleportation_pipes(i, j) for i in range(n) for j in range(i + 1, n + 1)]\n    return str(min(pipes))\n"
    },
    {
        "number": 2558,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.readline().strip().split())\n        if a > 1 or b > 1 or c > 1 or d > 1:\n            return \"-1\"\n        if d > 0:\n            d = 1\n        else:\n            d = 0\n        max_health = 0\n        for i in range(1, c + 1):\n            if i % d == 0:\n                max_health += b\n            else:\n                max_health += a\n        return str(max_health)"
    },
    {
        "number": 2559,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        k = int(stdin.readline())\n        roads = []\n        for _ in range(k):\n            a, b, t = map(int, stdin.readline().split())\n            roads.append((a, b, t))\n        G = sum([road[1] for road in roads])\n        B = sum([road[2] for road in roads])\n        print(G, B)"
    },
    {
        "number": 2560,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    universities = []\n    for _ in range(t):\n        n, l, r = map(int, stdin.strip().split())\n        universities.append((n, l, r))\n\n    def can_enter_university(n, l, r):\n        for i in range(1, 1000):\n            if n % i == 0 and l <= i <= r:\n                return True\n        return False\n\n    for n, l, r in universities:\n        if can_enter_university(n, l, r):\n            return \"Yes\"\n        else:\n            return \"No\"\n\n    return \"No\""
    },
    {
        "number": 2561,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a = int(stdin.readline())\n        if a == 0:\n            print(1)\n        elif a == 2:\n            print(2)\n        else:\n            count = 0\n            for i in range(32):\n                if a & (1 << i):\n                    count += 1\n            print(count)"
    },
    {
        "number": 2562,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a = list(map(int, stdin.readline().strip().split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def sum_of_clans(a):\n        clans = []\n        for i in range(n):\n            clan = set()\n            for j in range(i, n):\n                if gcd(a[i], a[j]) > 1:\n                    clan.add(j)\n            clans.append(clan)\n        return sum(len(clan) for clan in clans)\n\n    strength = sum_of_clans(a) % (10**9 + 7)\n    return str(strength)"
    },
    {
        "number": 2563,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a = int(stdin.strip())\n        n = len(str(a))\n        for i in range(n):\n            for j in range(i+1, n):\n                if a[i] ^ a[j] == 1:\n                    a = a ^ (a[i] << i) ^ (a[j] << j)\n        print(a)"
    },
    {
        "number": 2564,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        a, b, n = map(int, stdin.readline().split())\n        if a > n or b > n:\n            print(0)\n        else:\n            print(2)"
    },
    {
        "number": 2565,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        x1, y1, z1 = map(int, stdin.readline().split())\n        x2, y2, z2 = map(int, stdin.readline().split())\n        if x1 + y1 + z1 > x2 + y2 + z2:\n            a = [2, 0, 1, 1, 0, 2, 1]\n            b = [1, 0, 1, 0, 2, 1, 0]\n            c = [2, 0, 0, 0, 0, 2, 0]\n        else:\n            a = [0, 2, 0, 0, 0]\n            b = [1, 1, 0, 1, 0]\n            c = [0, 2, 0, 0, 0]\n        max_sum = 0\n        for i in range(len(c)):\n            if c[i] == 0:\n                max_sum += a[i] * b[i]\n            elif c[i] == 1:\n                max_sum += a[i] * b[i]\n            elif c[i] == 2:\n                max_sum += a[i] * b[i]\n        print(max_sum)\n    return \"\""
    },
    {
        "number": 2566,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        k = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        n = len(a)\n        dp = [[0] * 7 for _ in range(n)]\n        dp[0][0] = 1\n        for i in range(1, n):\n            dp[i][i] = 1\n            if a[i] == 1:\n                dp[i][i+1] = 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i+1][j] + dp[i+1][j+1]\n                if dp[i][j] < dp[i+1][j]:\n                    dp[i][j] = dp[i+1][j]\n        min_length = float('inf')\n        for i in range(n-1, -1, -1):\n            if dp[i][i+1] < min_length:\n                min_length = dp[i][i+1]\n        return str(min_length)"
    },
    {
        "number": 2567,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = stdin.strip()\n    w = \"\"\n    for i in range(n):\n        w += s[i]\n    return w"
    },
    {
        "number": 2568,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    res = 0\n\n    for _ in range(t):\n        s = stdin.readline().strip()\n        cur = 0\n        ok = True\n\n        for i in range(1, len(s)):\n            res += 1\n            if s[i] == '+':\n                cur += 1\n            else:\n                cur -= 1\n            if cur < 0:\n                ok = False\n                break\n\n        if ok:\n            break\n\n    return str(res)"
    },
    {
        "number": 2569,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    for _ in range(n):\n        level = int(stdin.strip())\n        if level == 1:\n            print(0)\n        elif level == 2:\n            print(0)\n        else:\n            print(0)"
    },
    {
        "number": 2570,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        b = list(map(int, stdin.readline().split()))\n        x = int(stdin.readline())\n        if not can_rearrange(a, b, x):\n            print(\"No\")\n        else:\n            print(\"Yes\")\n\ndef"
    },
    {
        "number": 2571,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    doors = []\n    for _ in range(T):\n        n = int(stdin.strip())\n        a = list(map(int, stdin.strip().split()))\n        b = list(map(int, stdin.strip().split()))\n        doors.append((n, a, b))\n\n    for door in doors:\n        n, a, b = door\n        if n % 2 == 0:\n            continue\n        for i in range(n):\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                continue\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 100:\n                break\n            if a[i] * b[i] > 0:\n                break\n            if a[i] * b[i] < 0:\n                break\n            if a[i] + b[i] > 10"
    },
    {
        "number": 2572,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [list(map(int, stdin.split())) for _ in range(n)]\n\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def is_nice(a):\n        for i in range(n):\n            for j in range(m):\n                if i == j:\n                    continue\n                if not is_palindrome(str(a[i][j])):\n                    return False\n        return True\n\n    min_ops = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if is_nice(a[i]):\n                min_ops = min(min_ops, j + 1)\n\n    return str(min_ops)\n"
    },
    {
        "number": 2573,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    board = [[0] * n for _ in range(n)]\n    rows_to_add = []\n\n    for _ in range(m):\n        x, y = map(int, stdin.split())\n        if board[x][y] == 0:\n            board[x][y] = 1\n            rows_to_add.append(y)\n        else:\n            board[x][y] = 0\n\n    min_rows = min(rows_to_add)\n    return str(min_rows)\n"
    },
    {
        "number": 2574,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        max_val = -1\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        for t in range(l+1, n):\n                            val = a[i] * a[j] * a[k] * a[l] * a[t]\n                            if val > max_val:\n                                max_val = val\n        print(max_val)\n    return \"\""
    },
    {
        "number": 2575,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a = int(stdin.readline())\n        if a == 30:\n            print(\"NO\")\n        elif a == 60:\n            print(\"YES\")\n        else:\n            print(\"YES\")"
    },
    {
        "number": 2576,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        a, b, c, d = map(int, stdin.strip().split())\n        if a + b + c + d == 101:\n            print(12)\n        else:\n            print(min(a, b, c, d))"
    },
    {
        "number": 2577,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = [[int(x) for x in stdin.split()] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if i > 0 and j > 0 and a[i][j] == a[i-1][j-1]:\n                return \"No\"\n            elif i > 0 and a[i][j] == a[i-1][j]:\n                a[i][j] += 1\n            elif j > 0 and a[i][j] == a[i][j-1]:\n                a[i][j] += 1\n\n    return \"Yes\""
    },
    {
        "number": 2578,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    friends = []\n    for _ in range(m):\n        friend = list(map(int, stdin.split()))\n        friends.append(friend)\n\n    news = []\n    for _ in range(n):\n        news.append(list(map(int, stdin.split())))\n\n    result = []\n    for i in range(n):\n        result.append(0)\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            for k in range(friends[i]):\n                for l in range(friends[j]):\n                    if news[i][k] == news[j][l]:\n                        result[i] += 1\n                        result[j] += 1\n                        break\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2579,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    l, r, x, y, k = map(int, stdin.split())\n    if l <= r and x <= y:\n        for i in range(l, r + 1):\n            for j in range(x, y + 1):\n                if i == j:\n                    continue\n                if i == 0 or j == 0:\n                    continue\n                if i == j - 1 or j == i - 1:\n                    continue\n                if i == j - 2 or j == i - 2:\n                    continue\n                if i == j - 3 or j == i - 3:\n                    continue\n                if i == j - 4 or j == i - 4:\n                    continue\n                if i == j - 5 or j == i - 5:\n                    continue\n                if i == j - 6 or j == i - 6:\n                    continue\n                if i == j - 7 or j == i - 7:\n                    continue\n                if i == j - 8 or j == i - 8:\n                    continue\n                if i == j - 9 or j == i - 9:\n                    continue\n                if i == j - 10 or j == i - 10:\n                    continue\n                if i == j - 11 or j == i - 11:\n                    continue\n                if i == j - 12 or j == i - 12:\n                    continue\n                if i == j - 13 or j == i - 13:\n                    continue\n                if i == j - 14 or j == i - 14:\n                    continue\n                if i == j - 15 or j == i - 15:\n                    continue\n                if i == j - 16 or j == i - 16:\n                    continue\n                if i == j - 17 or j == i - 17:\n                    continue\n                if i == j - 18 or j == i - 18:\n                    continue\n                if i == j - 19 or j == i - 19:\n                    continue\n                if i == j - 20 or j == i - 20:\n                    continue\n                if i == j - 21 or j == i - 21:\n                    continue\n                if i == j - 22 or j == i - 22:\n                    continue\n                if i == j - 23 or j == i - 23:\n                    continue\n                if i == j - 24 or j == i - 24:\n                    continue\n                if i == j - 25 or j == i - 25:\n                    continue\n                if i == j - 26 or j == i - 26:\n                    continue\n                if i == j - 27 or j == i - 27:\n                    continue\n                if i == j - 28 or j == i - 28:\n                    continue\n                if i == j - 29 or j == i - 29:\n                    continue\n                if i == j - 30 or j == i - 30:\n                    continue\n                if i == j - 31 or j == i - 31:\n                    continue\n                if i == j - 32 or j == i - 32:\n                    continue\n                if i == j - 33 or j == i - 33:\n                    continue\n                if i == j - 34 or j == i - 34:\n                    continue\n                if i == j - 35 or j == i - 35:\n                    continue\n                if i == j - 36 or j == i - 36:\n                    continue\n                if i == j - 37 or j == i - 37:\n                    continue\n                if i == j - 38 or j == i - 38:\n                    continue\n                if i == j - 39 or j == i - 39:\n                    continue\n                if i == j - 40 or j == i - 40:\n                    continue\n                if i == j - 41 or j == i - 41:\n                    continue\n                if i == j - 42 or j == i - 42:\n                    continue\n                if i == j - 43 or j == i - 43:\n                    continue\n                if i == j - 44 or j == i - 44:\n                    continue\n                if i == j - 45 or j == i - 45:\n                    continue\n                if i == j - 46 or j == i - 46:\n                    continue\n                if i == j - 47 or j == i - 47:\n                    continue\n                if i == j - 48 or j == i - 48:\n                    continue\n                if i == j"
    },
    {
        "number": 2580,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        edges = []\n        for _ in range(n-1):\n            u, v = map(int, stdin.readline().strip().split())\n            edges.append((u, v))\n        m = int(stdin.readline().strip())\n        p = list(map(int, stdin.readline().strip().split()))\n        k = 1\n        for i in range(m):\n            k *= p[i]\n        max_dist = 0\n        for u, v in edges:\n            dist = 0\n            for i in range(n-1):\n                dist += f(u, v)\n            if dist == k:\n                max_dist = max(max_dist, dist)\n        print(max(max_dist, 10**9 + 7))"
    },
    {
        "number": 2581,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    board = []\n    for _ in range(n):\n        row = list(map(int, stdin.readline().strip()))\n        board.append(row)\n\n    def is_valid(x, y, board):\n        for i in range(n):\n            if board[i][x] == board[i][y] and board[i][x]!= 0:\n                return False\n        return True\n\n    def get_max_amount(x, y, board):\n        max_amount = 0\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 0:\n                    if is_valid(i, j, board):\n                        amount = get_max_amount(i, j, board)\n                        if amount > max_amount:\n                            max_amount = amount\n        return max_amount\n\n    def place_bishops(x, y, board):\n        for i in range(n):\n            for j in range(n):\n                if board[i][j] == 0:\n                    board[i][j] = 1\n                    place_bishops(i, j, board)\n                    board[i][j] = 0\n\n    place_bishops(0, 0, board)\n    max_amount = get_max_amount(0, 0, board)\n    return str(max_amount) + '\\n' + str(board[0][0]) +'' + str(board[0][1]) +'' + str(board[1][0]) +'' + str(board[1][1])"
    },
    {
        "number": 2582,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    p = list(map(int, stdin.strip().split()))\n\n    special_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if p[i] + p[j] == max(p[i], p[j]):\n                special_count += 1\n\n    return str(special_count)"
    },
    {
        "number": 2583,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 1:\n        return \"Ashishgup\"\n    elif n % 2 == 0:\n        return \"FastestFinger\"\n    else:\n        return \"Ashishgup\""
    },
    {
        "number": 2584,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_goods = 0\n    for i in range(n):\n        if p >= a[i]:\n            max_goods += 1\n            p -= a[i]\n        else:\n            max_goods += k - 1\n            p -= a[i]\n            if p < 0:\n                break\n\n    return str(max_goods)\n"
    },
    {
        "number": 2585,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        max_gcd = 1\n        for i in range(1, n+1):\n            for j in range(i, n+1):\n                gcd = i * j // gcd(i, j)\n                if gcd > max_gcd:\n                    max_gcd = gcd\n        print(max_gcd)\n\ndef"
    },
    {
        "number": 2586,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    board = [[0] * m for _ in range(n)]\n    for _ in range(n):\n        board[0][_] = 1\n    for _ in range(m):\n        board[_][0] = 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if board[i-1][j] == 0 and board[i][j-1] == 0 and board[i+1][j] == 0 and board[i][j+1] == 0:\n                board[i][j] = 'B'\n\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == 'B':\n                for k in range(i-1, -1, -1):\n                    for l in range(j-1, -1, -1):\n                        if board[k][l] == 'W':\n                            board[i][j] = 'W'\n                            break\n                for k in range(i+1, n):\n                    for l in range(j-1, -1, -1):\n                        if board[k][l] == 'W':\n                            board[i][j] = 'W'\n                            break\n                for k in range(i-1, -1, -1):\n                    for l in range(j+1, m):\n                        if board[k][l] == 'W':\n                            board[i][j] = 'W'\n                            break\n                for k in range(i+1, n):\n                    for l in range(j+1, m):\n                        if board[k][l] == 'W':\n                            board[i][j] = 'W'\n                            break\n\n    for i in range(n):\n        for j in range(m):\n            print(board[i][j], end=' ')\n        print()\n\n    return '\\n'.join(map(str, board))"
    },
    {
        "number": 2587,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        n = int(stdin.strip())\n        x = int(bin(n)[2:])\n        k = int(bin(x)[2:])\n        r = k\n        while r > x:\n            r -= x\n        print(r)"
    },
    {
        "number": 2588,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split())\n    road = [int(s) for s in stdin.split()]\n    road.append(0)\n    road.append(n)\n    road.sort()\n    road = [road[i] for i in range(len(road) - 1)]\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append(road[-1] + 1)\n    road.append(road[0] + 1)\n    road.append("
    },
    {
        "number": 2589,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    def is_valid(start, end, sum):\n        return sum % x!= 0\n\n    def longest_subarray(start, end, sum):\n        if start == end:\n            return 1\n\n        if is_valid(start, end, sum):\n            return 1 + longest_subarray(start + 1, end, sum)\n\n        return longest_subarray(start + 1, end, sum)\n\n    return str(longest_subarray(0, n - 1, sum(a)))\n"
    },
    {
        "number": 2590,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_wealthy = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if a[i] >= x:\n                max_wealthy = max(max_wealthy, j)\n\n    return str(max_wealthy)\n"
    },
    {
        "number": 2591,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        a.sort()\n        rearranged = []\n        for i in range(n):\n            rearranged.append(a[i])\n            for j in range(i + 1, n):\n                rearranged.append(a[j])\n        print(\" \".join(map(str, rearranged)))"
    },
    {
        "number": 2592,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    result = []\n\n    for _ in range(t):\n        a, b, c = map(int, stdin.strip().split())\n\n        if a + b + c > 10:\n            result.append(0)\n        else:\n            result.append(a + b + c)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 2593,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if a[i] & a[j] >= a[i] ^ a[j]:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2594,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    streets = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            streets[i].append(j)\n\n    def is_valid(i, j):\n        return 0 <= i < n and 0 <= j < m and streets[i][j] == -1\n\n    def light_square(i, j):\n        streets[i][j] = 1\n\n    def find_min_lanterns(i, j):\n        min_lanterns = 0\n        for k in range(n):\n            for l in range(m):\n                if is_valid(k, l) and streets[k][l] == 0:\n                    light_square(k, l)\n                    min_lanterns += 1\n                    light_square(k, l)\n        return min_lanterns\n\n    min_lanterns = float('inf')\n    for i in range(n):\n        for j in range(m):\n            if is_valid(i, j):\n                min_lanterns = min(min_lanterns, find_min_lanterns(i, j))\n\n    return str(min_lanterns)\n"
    },
    {
        "number": 2595,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b = map(int, stdin.readline().split())\n        if a == b:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            if a % 4 == 0 and b % 4 == 0:\n                if a % 8 == 0 and b % 8 == 0:\n                    continue\n                if a % 2 == b % 2:\n                    continue\n                if a % 4 == b % 4:\n                    continue\n                if a % 8 == b % 8:\n                    continue\n            if a % 2 == b % 2:\n                continue\n            if a % 4 == b % 4:\n                continue\n            if a % 8 == b % 8:\n                continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == 0 and b % 4 == 0:\n            continue\n        if a % 8 == 0 and b % 8 == 0:\n            continue\n        if a % 2 == b % 2:\n            continue\n        if a % 4 == b % 4:\n            continue\n        if a % 8 == b % 8:\n            continue\n        if a % 2 == 0 and b % 2 == 0:\n            continue\n        if a % 4 == "
    },
    {
        "number": 2596,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, t = map(int, stdin.split())\n    result = []\n\n    for _ in range(t):\n        decision = input().split()\n        if decision[0] == '1':\n            i = int(decision[1])\n            result.append((i, k))\n        elif decision[0] == '0':\n            i = int(decision[1])\n            result.append((i, k))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2597,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    planks = list(map(int, stdin.readline().strip().split()))\n    max_side = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if planks[i] + planks[j] > max_side:\n                max_side = planks[i] + planks[j]\n\n    return str(max_side)"
    },
    {
        "number": 2598,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v, c = map(int, stdin.split())\n        edges.append((u, v, c))\n\n    def dfs(u, visited, color):\n        visited[u] = True\n        for v, c in edges[u]:\n            if not visited[v]:\n                dfs(v, visited, c)\n        if color == 'R':\n            return u\n        else:\n            return -1\n\n    visited = [False] * n\n    min_moves = float('inf')\n    for i in range(n):\n        if not visited[i]:\n            min_moves = min(min_moves, dfs(i, visited, 'B'))\n\n    if min_moves == float('inf'):\n        return -1\n\n    moves = []\n    for i in range(n):\n        if not visited[i]:\n            moves.append(i)\n\n    return '\\n'.join(map(str, moves))\n"
    },
    {
        "number": 2599,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n, k = map(int, stdin.readline().strip().split())\n        if n + k > 150:\n            continue\n        x = 1\n        while x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x + x +"
    },
    {
        "number": 2600,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    matrix = []\n    for _ in range(n):\n        row = list(map(int, stdin.split()))\n        matrix.append(row)\n\n    min_cells = float('inf')\n    for i in range(1, n):\n        for j in range(1, m):\n            if matrix[i][j] == matrix[i][m - 1 - j]:\n                min_cells = min(min_cells, i + j)\n\n    return str(min_cells)\n"
    },
    {
        "number": 2601,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        n = int(stdin.readline())\n        a = list(map(int, stdin.readline().split()))\n        if sum(a) > 10**5:\n            continue\n        if n * (n - 1) // 2 > sum(a):\n            print(\"NO\")\n        else:\n            print(\"YES\")"
    },
    {
        "number": 2602,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, n, m = map(int, stdin.readline().split())\n        if a + b == 0 and n + m!= 0:\n            return \"No\"\n        guests = [(\"vanilla\", 0), (\"chocolate\", 0)]\n        for _ in range(n):\n            guests[0] = (\"vanilla\", min(guests[0][1] + 1, a))\n        for _ in range(m):\n            guests[1] = (\"chocolate\", min(guests[1][1] + 1, b))\n        for guest in guests:\n            if guest[1] > 0:\n                guest[0] = \"vanilla\" if guest[1] > a else \"chocolate\"\n        for guest in guests:\n            if guest[0] == \"vanilla\" and guest[1] > 0:\n                return \"No\"\n            elif guest[0] == \"chocolate\" and guest[1] > 0:\n                return \"No\"\n        return \"Yes\""
    },
    {
        "number": 2603,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline().strip())\n    for _ in range(t):\n        n = int(stdin.readline().strip())\n        a = list(map(int, stdin.readline().strip().split()))\n        a.sort()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if gcd(a[i], a[j]) == min(a):\n                    a[i], a[j] = a[j], a[i]\n                    break\n        if all(a[i] <= a[i + 1] for i in range(n - 1)):\n            return \"YES\"\n        else:\n            return \"NO\"\n\ndef"
    },
    {
        "number": 2604,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, d = map(int, stdin.split())\n    n = int(stdin.strip())\n    sausage = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.split())\n        sausage.append((x, y, r))\n    sausage.sort(key=lambda x: (x[0], x[1]))\n    count = 0\n    for i in range(len(sausage)):\n        if sausage[i][0] >= 0 and sausage[i][1] >= 0 and sausage[i][2] >= 0:\n            count += 1\n            if sausage[i][0] + sausage[i][2] <= r and sausage[i][1] + sausage[i][2] <= r:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2605,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    cities = list(map(int, stdin.split()))\n    idxs = list(map(int, stdin.split()))\n\n    # Calculate beauty values\n    beauty_values = [cities[i] for i in range(n)]\n    beauty_values.extend([cities[i] for i in range(n, n + k)])\n    beauty_values.sort()\n\n    # Calculate summary price\n    summary_price = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            summary_price += beauty_values[i] * beauty_values[j]\n\n    return str(summary_price)\n"
    },
    {
        "number": 2606,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    t = list(map(int, stdin.strip().split()))\n    total_unpleasant_value = 0\n\n    for i in range(n):\n        total_unpleasant_value += abs(t[i] - t[0])\n\n    return str(total_unpleasant_value)\n"
    },
    {
        "number": 2607,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.strip())\n    for _ in range(t):\n        s = stdin.strip()\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = 'a' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = 'b' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = 'c' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s = s[1:]\n        else:\n            s = '?' + s[1:]\n        if s[0] == '?':\n            s"
    },
    {
        "number": 2608,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x3, y3, x4, y4 = map(int, stdin.split())\n\n    white_paint = 0\n    black_paint = 0\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if i == x1 and j == y1:\n                white_paint += 1\n            elif i == x2 and j == y2:\n                black_paint += 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if i == x3 and j == y3:\n                white_paint -= 1\n            elif i == x4 and j == y4:\n                black_paint -= 1\n\n    return str(white_paint) + \" \" + str(black_paint)"
    },
    {
        "number": 2609,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    segments = []\n    for _ in range(n):\n        l, r = map(int, stdin.strip().split())\n        segments.append((l, r))\n\n    segments.sort(key=lambda x: x[0])\n\n    def union(segments):\n        result = set()\n        for i in range(len(segments)):\n            for j in range(i + 1, len(segments)):\n                result.add((segments[i][0], segments[j][1]))\n        return result\n\n    segments_union = union(segments)\n    max_segments = 1\n    for i in range(1, len(segments_union)):\n        if segments_union[i] == segments_union[i - 1]:\n            max_segments += 1\n\n    return str(max_segments)\n"
    },
    {
        "number": 2610,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    max_goods = 0\n    for i in range(n):\n        if p >= a[i]:\n            max_goods += 1\n            p -= a[i]\n            if p < 0:\n                p = 0\n    return str(max_goods)"
    },
    {
        "number": 2611,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    piles = list(map(int, stdin.split()))\n\n    moves = []\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            moves.append((i, j))\n\n    moves.sort()\n\n    result = []\n    for i in range(q):\n        t, x = map(int, stdin.split())\n        if t == 0:\n            result.append(moves.pop(piles.index(x)))\n        else:\n            piles.append(x)\n            result.append(moves.pop(piles.index(x)))\n\n    return str(len(result)) + '\\n' + '\\n'.join(map(str, result))"
    },
    {
        "number": 2612,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    arrangements = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] < s[j] and s[i] % s[j] == 0:\n                arrangements.append((i, j))\n    max_models = max(arrangements, key=lambda x: len(arrangements[x]))\n    return str(max_models)"
    },
    {
        "number": 2613,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, z = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    max_score = 0\n    moves = 0\n\n    for i in range(n):\n        if i == 0:\n            score = a[i]\n        else:\n            score = a[i] + a[i-1]\n\n        if moves < k:\n            if i == n-1:\n                score += a[i]\n            else:\n                score += a[i+1]\n\n            if score > max_score:\n                max_score = score\n                moves = 1\n            elif score == max_score and i < n-1:\n                moves += 1\n\n        if moves > z:\n            break\n\n    return str(max_score)"
    },
    {
        "number": 2614,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    bags = []\n    for _ in range(n):\n        bag = list(map(int, stdin.readline().split()))\n        bags.append(bag)\n\n    min_distance = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    for m in range(l + 1, n):\n                        for n in range(m + 1, n):\n                            for o in range(n + 1, n):\n                                distance = bags[i][0] + bags[j][0] + bags[k][0] + bags[l][0] + bags[m][0] + bags[n][0] + bags[o][0]\n                                if distance < min_distance:\n                                    min_distance = distance\n\n    return str(min_distance)\n"
    },
    {
        "number": 2615,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        n = int(stdin.readline())\n        count = 0\n        for i in range(2, n + 1):\n            if i % 2 == 0:\n                count += 1\n        print(count)"
    },
    {
        "number": 2616,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    a = list(map(int, stdin.readline().split()))\n    piles = [0] * n\n    for i in range(n):\n        piles[i] = a[i]\n    for i in range(n):\n        if piles[i] > 0:\n            piles[i] -= 1\n    for i in range(n):\n        if piles[i] == 0:\n            piles[i] = n - i - 1\n    if piles[0] == 0:\n        return \"First\"\n    elif piles[1] == 0:\n        return \"Second\"\n    else:\n        return \"First\""
    },
    {
        "number": 2617,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    masses = list(map(int, stdin.readline().split()))\n    total_mass = sum(masses)\n    d = 0\n    while total_mass < n:\n        total_mass += masses[d]\n        d += 1\n    if d == 0:\n        return \"-1\"\n    result = []\n    for i in range(d):\n        result.append(masses[i])\n    return \" \".join(map(str, result))"
    },
    {
        "number": 2618,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *prices = map(int, stdin.split())\n    x, a, y, b = map(int, stdin.split())\n    k = int(stdin.split()[4])\n\n    tickets = [p for p in prices if p % 100 == 0]\n    tickets.sort()\n\n    total_contribution = sum(p * (x + y) // 100 for p in tickets)\n    if total_contribution < k:\n        return \"-1\"\n\n    tickets = [p for p in prices if p % 100 == 0]\n    tickets.sort()\n\n    sold_tickets = 0\n    for i in range(n):\n        if sold_tickets >= k:\n            break\n        sold_tickets += 1\n        if tickets[i] % 2 == 0:\n            total_contribution += tickets[i] * (x + y) // 100\n        else:\n            total_contribution += tickets[i] * (x + y) // 100 + tickets[i + 1] * (x + y) // 100\n\n    return str(sold_tickets)\n"
    },
    {
        "number": 2619,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    stars = []\n    for _ in range(n):\n        x, y, s = map(int, stdin.split())\n        stars.append((x, y, s))\n\n    views = []\n    for _ in range(q):\n        t, x1, y1, x2, y2 = map(int, stdin.split())\n        views.append((t, x1, y1, x2, y2))\n\n    total_brightness = 0\n    for view in views:\n        x1, y1, x2, y2 = view\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                total_brightness += stars[i - x1][j - y1]\n\n    return str(total_brightness)\n"
    },
    {
        "number": 2620,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(range(1, n + 1))\n    for _ in range(q):\n        x = int(stdin.readline())\n        if x == 1:\n            l, r = map(int, stdin.readline().split())\n            a = [a[i] for i in range(l, r + 1)]\n        elif x == 2:\n            a = [a[i] for i in range(n)]\n            for _ in range(x):\n                a = [a[i] + a[i + 1] for i in range(n - 1)]\n                a.append(a[0])\n    return str(sum(a))\n"
    },
    {
        "number": 2621,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    h = list(map(int, stdin.split()))\n    bag = [0] * m\n    for i in range(m):\n        bag[i] = i + 1\n\n    for _ in range(t):\n        action = input()\n        if action == '1':\n            column = input()\n            if column == '1':\n                column = 1\n            else:\n                column = int(column) - 1\n            if column < 1 or column > n:\n                print(\"NO\")\n                continue\n            if h[column - 1] == h[column]:\n                print(\"NO\")\n                continue\n            if h[column - 1] - h[column] <= k:\n                column += 1\n            else:\n                column = column + 1\n            h[column - 1] = h[column]\n            h[column] = 0\n            for i in range(m):\n                if i!= column - 1:\n                    bag[i] = bag[i + 1]\n            bag[column - 1] = 0\n            print(\"YES\")\n        elif action == '2':\n            column = input()\n            if column == '1':\n                column = 1\n            else:\n                column = int(column) - 1\n            if column < 1 or column > n:\n                print(\"NO\")\n                continue\n            if h[column - 1] == h[column]:\n                print(\"NO\")\n                continue\n            if h[column - 1] - h[column] <= k:\n                column += 1\n            else:\n                column = column + 1\n            h[column - 1] = h[column]\n            h[column] = 0\n            for i in range(m):\n                if i!= column - 1:\n                    bag[i] = bag[i + 1]\n            bag[column - 1] = 0\n            print(\"YES\")\n        elif action == '3':\n            column = input()\n            if column == '1':\n                column = 1\n            else:\n                column = int(column) - 1\n            if column < 1 or column > n:\n                print(\"NO\")\n                continue\n            if h[column - 1] == h[column]:\n                print(\"NO\")\n                continue\n            if h[column - 1] - h[column] <= k:\n                column += 1\n            else:\n                column = column + 1\n            h[column - 1] = h[column]\n            h[column] = 0\n            for i in range(m):\n                if i!= column - 1:\n                    bag[i] = bag[i + 1]\n            bag[column - 1] = 0\n            print(\"YES\")\n        elif action == '4':\n            column = input()\n            if column == '1':\n                column = 1\n            else:\n                column = int(column) - 1\n            if column < 1 or column > n:\n                print(\"NO\")\n                continue\n            if h[column - 1] == h[column]:\n                print(\"NO\")\n                continue\n            if h[column - 1] - h[column] <= k:\n                column += 1\n            else:\n                column = column + 1\n            h[column - 1] = h[column]\n            h[column] = 0\n            for i in range(m):\n                if i!= column - 1:\n                    bag[i] = bag[i + 1]\n            bag[column - 1] = 0\n            print(\"YES\")\n        elif action == '5':\n            column = input()\n            if column == '1':\n                column = 1\n            else:\n                column = int(column) - 1\n            if column < 1 or column > n:\n                print(\"NO\")\n                continue\n            if h[column - 1] == h[column]:\n                print(\"NO\")\n                continue\n            if h[column - 1] - h[column] <= k:\n                column += 1\n            else:\n                column = column + 1\n            h[column - 1] = h[column]\n            h[column] = 0\n            for i in range(m):\n                if i!= column - 1:\n                    bag[i] = bag[i + 1]\n            bag[column - 1] = 0\n            print(\"YES\")\n        elif action == '6':\n            column = input()\n            if column == '1':\n                column = 1\n            else:\n                column = int(column) - 1\n            if column < 1 or column > n:\n                print(\"NO\")\n                continue\n            if h[column - 1] == h[column]:\n                print(\"NO\")\n                continue\n            if h[column -"
    },
    {
        "number": 2622,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    maps = []\n    for _ in range(N):\n        maps.append(list(stdin.strip()))\n\n    for i in range(N):\n        for j in range(M):\n            if maps[i][j] =='s':\n                maps[i][j] = 'S'\n            elif maps[i][j] =='m':\n                maps[i][j] = 'M'\n            elif maps[i][j] == 'o':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'n':\n                maps[i][j] = 'N'\n            elif maps[i][j] == 'e':\n                maps[i][j] = 'E'\n            elif maps[i][j] == 'r':\n                maps[i][j] = 'R'\n            elif maps[i][j] == 'p':\n                maps[i][j] = 'P'\n            elif maps[i][j] == 'h':\n                maps[i][j] = 'H'\n            elif maps[i][j] == 'c':\n                maps[i][j] = 'C'\n            elif maps[i][j] == 't':\n                maps[i][j] = 'T'\n            elif maps[i][j] =='':\n                maps[i][j] =''\n\n    for i in range(N):\n        for j in range(M):\n            if maps[i][j] == 'S':\n                maps[i][j] ='s'\n            elif maps[i][j] == 'M':\n                maps[i][j] ='m'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'o'\n            elif maps[i][j] == 'N':\n                maps[i][j] = 'n'\n            elif maps[i][j] == 'E':\n                maps[i][j] = 'e'\n            elif maps[i][j] == 'R':\n                maps[i][j] = 'r'\n            elif maps[i][j] == 'P':\n                maps[i][j] = 'p'\n            elif maps[i][j] == 'H':\n                maps[i][j] = 'h'\n            elif maps[i][j] == 'C':\n                maps[i][j] = 'c'\n            elif maps[i][j] == 'T':\n                maps[i][j] = 't'\n            elif maps[i][j] =='':\n                maps[i][j] =''\n\n    for i in range(N):\n        for j in range(M):\n            if maps[i][j] =='s':\n                maps[i][j] = 'S'\n            elif maps[i][j] =='m':\n                maps[i][j] = 'M'\n            elif maps[i][j] == 'o':\n                maps[i][j] = 'O'\n            elif maps[i][j] == 'n':\n                maps[i][j] = 'N'\n            elif maps[i][j] == 'e':\n                maps[i][j] = 'E'\n            elif maps[i][j] == 'r':\n                maps[i][j] = 'R'\n            elif maps[i][j] == 'p':\n                maps[i][j] = 'P'\n            elif maps[i][j] == 'h':\n                maps[i][j] = 'H'\n            elif maps[i][j] == 'c':\n                maps[i][j] = 'C'\n            elif maps[i][j] == 't':\n                maps[i][j] = 'T'\n            elif maps[i][j] =='':\n                maps[i][j] =''\n\n    for i in range(N):\n        for j in range(M):\n            if maps[i][j] == 'S':\n                maps[i][j] ='s'\n            elif maps[i][j] == 'M':\n                maps[i][j] ='m'\n            elif maps[i][j] == 'O':\n                maps[i][j] = 'o'\n            elif maps[i][j] == 'N':\n                maps[i][j] = 'n'\n            elif maps[i][j] == 'E':\n                maps[i][j] = 'e'\n            elif maps[i][j] == 'R':\n                maps[i][j] = 'r'\n            elif maps[i][j] == 'P':\n                maps[i][j] = 'p'\n            elif maps[i][j] == '"
    },
    {
        "number": 2623,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = stdin.strip()\n    a = [\"\"] * k\n    for i in range(n):\n        a[i % k] += s[i]\n    max_a = max(a)\n    min_a = min(a)\n    for i in range(k):\n        if a[i] == \"\":\n            a[i] = max_a\n        else:\n            a[i] = min_a\n    return \"\".join(a)"
    },
    {
        "number": 2624,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = [-a[i] for i in range(n)]\n\n    for _ in range(q):\n        s, x = stdin.split()\n        if s == \">\":\n            for i in range(n):\n                if a[i] > x:\n                    b[i] = -a[i]\n        elif s == \"<\":\n            for i in range(n):\n                if a[i] < x:\n                    b[i] = a[i]\n        else:\n            raise ValueError(\"Invalid symbol\")\n\n    return \" \".join(map(str, b))"
    },
    {
        "number": 2625,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    result = []\n\n    for i in range(n):\n        k = int(stdin.strip())\n        x = int(stdin.strip())\n\n        if k == 1:\n            result.append(x)\n        else:\n            digit_sum = 0\n            current_digit = x\n\n            while current_digit > 0:\n                digit_sum += current_digit % 10\n                current_digit //= 10\n\n            if digit_sum == k:\n                result.append(x)\n            else:\n                result.append(0)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2626,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline())\n    ways = 0\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            for k in range(1, j+1):\n                for l in range(1, k+1):\n                    ways += 4*i*j*k*l\n    return str(ways)"
    },
    {
        "number": 2627,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input from stdin\n    matrix = []\n    for line in stdin.splitlines():\n        row = []\n        for char in line:\n            row.append(int(char))\n        matrix.append(row)\n\n    # Initialize variables\n    max_area = 0\n    max_rect = []\n\n    # Iterate through each row\n    for row in matrix:\n        # Initialize variables\n        left = 0\n        right = len(row) - 1\n        area = 0\n\n        # Iterate through each column\n        while left < right:\n            # If current element is 1, update area and move left pointer\n            if row[left] == 1:\n                area += 1\n                left += 1\n            # If current element is 0, move right pointer\n            else:\n                right -= 1\n\n        # Update max area and max rect\n        if area > max_area:\n            max_area = area\n            max_rect = [row[left], row[right]]\n\n    # Return max area\n    return str(max_area)"
    },
    {
        "number": 2628,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    gray_code = [0] * (2 * n)\n    gray_code[0] = 1\n    gray_code[1] = 0\n\n    for i in range(2, 2 * n):\n        gray_code[i] = gray_code[i - 1] ^ gray_code[i - 2]\n\n    return gray_code"
    },
    {
        "number": 2629,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    matrix = [[0] * n for _ in range(n)]\n    direction = \"right\"\n    top = 0\n    bottom = n - 1\n    left = 0\n    right = n - 1\n\n    while top <= bottom and left <= right:\n        if direction == \"right\":\n            for i in range(left, right + 1):\n                matrix[top][i] = i + 1\n            top += 1\n        elif direction == \"down\":\n            for i in range(top, bottom + 1):\n                matrix[i][right] = i + 1\n            right -= 1\n        elif direction == \"left\":\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = i + 1\n            bottom -= 1\n        elif direction == \"up\":\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = i + 1\n            left += 1\n\n        direction = (direction + \"right\") % 4\n\n    return matrix_to_string(matrix)\n\n\ndef"
    },
    {
        "number": 2630,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = [[0] * n for _ in range(m)]\n    visited = [[False] * n for _ in range(m)]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def dfs(x, y):\n        if x == m - 1 and y == n - 1:\n            return 1\n        if visited[x][y]:\n            return 0\n        visited[x][y] = True\n        path = 0\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < m and 0 <= ny < n and grid[nx][ny] == 0:\n                path += dfs(nx, ny)\n        visited[x][y] = False\n        return path\n\n    return str(dfs(0, 0))"
    },
    {
        "number": 2631,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, prerequisites = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for i, j in prerequisites:\n        graph[i].append(j)\n        graph[j].append(i)\n    visited = [False] * n\n    result = True\n    for i in range(n):\n        if not visited[i] and not dfs(i, graph, visited):\n            result = False\n            break\n    return \"true\" if result else \"false\"\n\ndef"
    },
    {
        "number": 2632,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    grid = [[0] * n for _ in range(m)]\n    for i in range(m):\n        for j in range(n):\n            grid[i][j] = int(stdin.split()[j])\n\n    def dfs(i: int, j: int, path: List[int], sum: int) -> int:\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == 0:\n            return sum\n\n        if i == m - 1 and j == n - 1:\n            return sum\n\n        if grid[i][j] == 1:\n            return dfs(i + 1, j, path + [grid[i][j]], sum + grid[i][j])\n\n        return dfs(i, j + 1, path, sum)\n\n    path = []\n    sum = dfs(0, 0, path, 0)\n    return str(sum)\n"
    },
    {
        "number": 2633,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    dungeon = []\n    for line in stdin.split('\\n'):\n        row = []\n        for char in line:\n            row.append(int(char))\n        dungeon.append(row)\n\n    def dfs(x, y, visited, path):\n        if x == 0 and y == 0:\n            return True\n        if x < 0 or x >= len(dungeon) or y < 0 or y >= len(dungeon[0]) or dungeon[x][y] == 0 or visited[(x, y)]:\n            return False\n        visited[(x, y)] = True\n        path.append((x, y))\n        if dfs(x - 1, y, visited, path):\n            return True\n        if dfs(x + 1, y, visited, path):\n            return True\n        if dfs(x, y - 1, visited, path):\n            return True\n        if dfs(x, y + 1, visited, path):\n            return True\n        visited[(x, y)] = False\n        path.pop()\n        return False\n\n    def min_health(x, y):\n        if x == 0 and y == 0:\n            return 7\n        if x < 0 or x >= len(dungeon) or y < 0 or y >= len(dungeon[0]) or dungeon[x][y] == 0:\n            return 0\n        return min(min_health(x - 1, y), min_health(x + 1, y), min_health(x, y - 1), min_health(x, y + 1))\n\n    x, y = 0, 0\n    visited = [[False] * len(dungeon[0]) for _ in range(len(dungeon))]\n    path = [(x, y)]\n    while dfs(x, y, visited, path):\n        x, y = path[-1]\n        path.pop()\n\n    return str(min_health(x, y))\n"
    },
    {
        "number": 2634,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    def backtrack(start: int, path: List[int], result: List[List[int]]):\n        if start == len(nums):\n            result.append(path[:])\n            return\n        for i in range(start, len(nums)):\n            path.append(nums[i])\n            backtrack(i+1, path, result)\n            path.pop()\n\n    result = []\n    backtrack(0, [], result)\n    return str(result)"
    },
    {
        "number": 2635,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input matrix\n    matrix = []\n    for line in stdin.splitlines():\n        row = []\n        for num in line.split():\n            row.append(int(num))\n        matrix.append(row)\n\n    # Initialize variables\n    rows = len(matrix)\n    cols = len(matrix[0])\n    start_row = 0\n    start_col = 0\n    end_row = rows - 1\n    end_col = cols - 1\n    result = []\n\n    # Traverse matrix in spiral order\n    while start_row <= end_row and start_col <= end_col:\n        # Traverse top row\n        for i in range(start_col, end_col + 1):\n            result.append(matrix[start_row][i])\n\n        # Traverse right column\n        for j in range(start_row + 1, end_row + 1):\n            result.append(matrix[j][end_col])\n\n        # Traverse bottom row\n        for i in range(end_col - 1, start_col - 1, -1):\n            result.append(matrix[end_row][i])\n\n        # Traverse left column\n        for j in range(end_row - 1, start_row - 1, -1):\n            result.append(matrix[j][start_col])\n\n        # Move to next row\n        start_row += 1\n        end_row -= 1\n        start_col += 1\n        end_col -= 1\n\n    return result"
    },
    {
        "number": 2636,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    buildings = []\n    for line in stdin.splitlines():\n        building = line.split()\n        buildings.append([int(building[0]), int(building[1]), int(building[2])])\n\n    # Sort buildings by left x position\n    buildings.sort(key=lambda x: x[0])\n\n    # Initialize result\n    result = []\n\n    # Iterate through buildings\n    for i in range(len(buildings)):\n        # Check if current building is the first building in the list\n        if i == 0:\n            result.append([buildings[i][0], buildings[i][2]])\n        # Check if current building is the last building in the list\n        elif i == len(buildings) - 1:\n            result.append([buildings[i][0], buildings[i][2]])\n        # Check if current building is not the first or last building in the list\n        else:\n            # Check if current building is above the previous building\n            if buildings[i][2] > buildings[i - 1][2]:\n                # Check if current building is below the next building\n                if buildings[i + 1][2] < buildings[i][2]:\n                    # Add current building to result\n                    result.append([buildings[i][0], buildings[i][2]])\n            # Check if current building is below the previous building\n            else:\n                # Check if current building is above the next building\n                if buildings[i - 1][2] > buildings[i][2]:\n                    # Add current building to result\n                    result.append([buildings[i][0], buildings[i][2]])\n\n    # Remove consecutive horizontal lines\n    for i in range(len(result) - 1):\n        if result[i][1] == result[i + 1][1]:\n            result.pop(i)\n            i -= 1\n\n    # Convert result to string\n    result_str = \" \".join([str(x) for x in result])\n\n    return result_str\n"
    },
    {
        "number": 2637,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    numbers = list(map(int, stdin.split()))\n    result = []\n    def backtrack(start: int, path: List[int]):\n        if start == len(numbers):\n            result.append(path[:])\n        else:\n            for i in range(start, len(numbers)):\n                path.append(numbers[i])\n                backtrack(i+1, path)\n                path.pop()\n    backtrack(0, [])\n    return str(result)"
    },
    {
        "number": 2638,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = list(map(list, stdin.split('\\n')))\n    n = len(rows)\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n        for j in range(n):\n            if i == 0 or j == 0:\n                dp[i][j] = rows[i][j]\n            elif rows[i][j] > rows[i-1][j]:\n                dp[i][j] = dp[i-1][j] + rows[i][j]\n            else:\n                dp[i][j] = dp[i][j-1] + rows[i][j]\n\n    return str(dp[n-1][0])"
    },
    {
        "number": 2639,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    n = len(nums)\n    subsets = []\n    backtrack(nums, 0, subsets)\n    return subsets\n\ndef"
    },
    {
        "number": 2640,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    obstacles = [list(map(str, stdin.split())) for _ in range(H)]\n\n    def dfs(row, col, visited):\n        if row < 0 or row >= H or col < 0 or col >= W or obstacles[row][col] == '#':\n            return 0\n\n        if visited[row][col]:\n            return 0\n\n        visited[row][col] = True\n        count = 1\n        count += dfs(row - 1, col, visited)\n        count += dfs(row + 1, col, visited)\n        count += dfs(row, col - 1, visited)\n        count += dfs(row, col + 1, visited)\n\n        return count\n\n    visited = [[False] * W for _ in range(H)]\n    max_count = 0\n\n    for i in range(H):\n        for j in range(W):\n            if obstacles[i][j] == '#':\n                continue\n\n            count = dfs(i, j, visited)\n            max_count = max(max_count, count)\n\n    return max_count"
    },
    {
        "number": 2641,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    colors = set()\n    for i in range(N):\n        colors.add(i)\n\n    result = []\n    for _ in range(Q):\n        l, r = map(int, stdin.split())\n        count = len(colors.intersection(set(range(l, r+1))))\n        result.append(count)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2642,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    sardines = []\n    for _ in range(n):\n        a, b = map(int, stdin.readline().strip().split())\n        sardines.append((a, b))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if sardines[i][0] * sardines[j][0] + sardines[i][1] * sardines[j][1] == 0:\n                count += 1\n\n    return str(count % 1000000007)"
    },
    {
        "number": 2643,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, q = map(int, stdin.split())\n    d = list(map(int, stdin.split()))\n    n = list(map(int, stdin.split()))\n    x = list(map(int, stdin.split()))\n    m = list(map(int, stdin.split()))\n\n    result = []\n    for _ in range(q):\n        n_i, x_i, m_i = map(int, stdin.split())\n        a = [x_i] * n_i\n        for j in range(n_i - 1):\n            a[j] = (a[j] + d[(j + 1) % k]) % m_i\n        count = 0\n        for j in range(n_i - 1):\n            if (a[j] % m_i) < (a[(j + 1) % n_i] % m_i):\n                count += 1\n        result.append(count)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2644,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    P = list(map(int, stdin.strip().split()))\n\n    if N == 1:\n        return str(P[0])\n\n    operations = []\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n    for i in range(N - 1):\n        operations.append(f\"swap P_{i} and P_{i + 1}\")\n\n    operations.append(\"swap P_{N - 1} and P_N\")\n\n   "
    },
    {
        "number": 2645,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    max_score = 0\n    for i in range(n):\n        if s[i] == 'g':\n            max_score += 1\n    return str(max_score)"
    },
    {
        "number": 2646,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    rooms = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        rooms[A].append(B)\n        rooms[B].append(A)\n\n    def dfs(room, visited):\n        if room == 1:\n            return 0\n        if room in visited:\n            return visited[room]\n        visited[room] = dfs(rooms[room][0], visited) + 1\n        return visited[room]\n\n    visited = {1: 0}\n    min_passages = dfs(1, visited)\n    if min_passages == 0:\n        return \"No.\"\n    result = []\n    for i in range(1, N + 1):\n        result.append(str(i))\n    result.append(\"Yes\")\n    result.append(str(min_passages))\n    result.append(str(min_passages))\n    return \"\\n\".join(result)"
    },
    {
        "number": 2647,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    s = [[chr(ord('a') + i) for j in range(W)] for i in range(H)]\n    score = 0\n    for i in range(H):\n        for j in range(W):\n            if s[i][j] == '#':\n                score += 1\n                if i == 1 and j == 1:\n                    s[i][j] = '.'\n                elif i == H - 2 and j == W - 2:\n                    s[i][j] = '.'\n                else:\n                    s[i][j] = '#'\n    if score == 0:\n        return '-1'\n    return str(score)"
    },
    {
        "number": 2648,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n\n    # Perform the operation N times\n    for _ in range(N):\n        # Take out three cards with largest and smallest values\n        A_1, A_2, A_3 = max(A), min(A), A.pop(A.index(max(A)) + 1)\n        A_4, A_5, A_6 = max(A), min(A), A.pop(A.index(min(A)) + 1)\n\n        # Return the remaining card to deck\n        A.append(A_1)\n        A.append(A_2)\n        A.append(A_3)\n        A.append(A_4)\n        A.append(A_5)\n        A.append(A_6)\n\n    # Print the maximum number of remaining cards\n    print(len(A))\n\n    return '\\n'.join(map(str, A))"
    },
    {
        "number": 2649,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    max_distance = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            distance = abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])\n            max_distance = max(max_distance, distance)\n\n    return str(max_distance)"
    },
    {
        "number": 2650,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n    B = list(map(int, stdin.split()))\n    C = list(map(int, stdin.split()))\n    D = list(map(int, stdin.split()))\n    Q = int(stdin.split())\n\n    evenness = [0] * N\n    for i in range(N):\n        evenness[i] = A[i]\n\n    for i in range(Q):\n        j = int(stdin.split())\n        evenness[j] = min(evenness[j], A[j])\n\n    for i in range(Q):\n        j = int(stdin.split())\n        evenness[j] = min(evenness[j], C[j])\n\n    for i in range(Q):\n        j = int(stdin.split())\n        evenness[j] = min(evenness[j], D[j])\n\n    result = []\n    for i in range(N):\n        result.append(evenness[i])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2651,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    x = list(map(int, stdin.split()))\n    y = list(map(int, stdin.split()))\n\n    total_area = 0\n    for i in range(n):\n        for j in range(m):\n            x_i, y_i = x[i], y[j]\n            for k in range(i + 1, n):\n                x_j, y_j = x[k], y[j]\n                for l in range(j + 1, m):\n                    x_k, y_k = x[k], y[l]\n                    for m in range(k + 1, n):\n                        x_l, y_l = x[m], y[l]\n                        area = (x_i - x_j) * (y_k - y_l)\n                        total_area += area % (10**9 + 7)\n\n    return str(total_area)\n"
    },
    {
        "number": 2652,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    towns = []\n    for i in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        towns.append((x, y))\n\n    min_cost = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            cost = abs(towns[i][0] - towns[j][0]) + abs(towns[i][1] - towns[j][1])\n            if cost < min_cost:\n                min_cost = cost\n\n    return str(min_cost)"
    },
    {
        "number": 2653,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    for _ in range(Q):\n        a, b = map(int, stdin.split())\n        graph[a - 1].append((b - 1, 1))\n        graph[b - 1].append((a - 1, 1))\n    stack = [(1, 0)]\n    while stack:\n        p, x = stack.pop()\n        if p == N:\n            print(x)\n            continue\n        for i, (j, x_j) in enumerate(graph[p - 1]):\n            if j == N:\n                continue\n            stack.append((j, x + x_j))\n    return \"\""
    },
    {
        "number": 2654,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    B = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the input values\n    A.sort()\n    B.sort()\n\n    # Calculate the median\n    if N % 2 == 0:\n        median = (A[N//2] + A[N//2+1]) / 2\n    else:\n        median = A[N//2]\n\n    # Count the number of different values\n    count = 0\n    for i in range(len(A)):\n        if A[i] <= median and median <= B[i]:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2655,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    A = list(map(int, stdin.strip().split()))\n    max_comfort = 0\n\n    for i in range(1, n):\n        if i == 1:\n            comfort = 0\n        else:\n            adjacent_comfort = min(A[i - 1], A[i + 1])\n            comfort = adjacent_comfort + A[i - 1] - A[i + 1]\n\n        max_comfort = max(max_comfort, comfort)\n\n    return str(max_comfort)\n"
    },
    {
        "number": 2656,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, S = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def choose_one_lowercase_letter(s: str) -> str:\n        return s[0]\n\n    def insert_lowercase_letter(s: str, c: str) -> str:\n        return c + s[1:]\n\n    def count_strings(s: str, k: int) -> int:\n        count = 0\n        for _ in range(k):\n            s = choose_one_lowercase_letter(s) + insert_lowercase_letter(s, choose_one_lowercase_letter(s))\n            count += 1\n        return count\n\n    result = count_strings(S, K)\n    return str(result % MOD)"
    },
    {
        "number": 2657,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def comb(n, r):\n        if r == 0:\n            return 1\n        if r == 1:\n            return n\n        return comb(n - 1, r - 1) + comb(n - 1, r)\n\n    max_comb = float('-inf')\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if comb(i, j) > max_comb:\n                max_comb = comb(i, j)\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if comb(i, j) == max_comb:\n                print(a[i], a[j])\n                break"
    },
    {
        "number": 2658,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def teleport(town: int) -> int:\n        return town + K\n\n    def find_town(town: int) -> int:\n        for i in range(1, N + 1):\n            if teleport(i) == town:\n                return i\n        return -1\n\n    town = find_town(1)\n    if town == -1:\n        return \"No solution\"\n    else:\n        return str(town)"
    },
    {
        "number": 2659,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    if K < 1:\n        return \"Invalid input\"\n\n    def sum_of_digits(n: int) -> int:\n        return sum(int(digit) for digit in str(n))\n\n    def is_snuke(n: int) -> bool:\n        return sum_of_digits(n) <= sum_of_digits(10 ** 15)\n\n    def smallest_snuke_number(n: int) -> int:\n        for i in range(1, 10 ** 15 + 1):\n            if is_snuke(i) and is_snuke(n // i):\n                return i\n        return -1\n\n    result = []\n    for i in range(K):\n        result.append(smallest_snuke_number(i))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 2660,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.readline())\n    queries = []\n    for _ in range(Q):\n        query = stdin.readline().split()\n        queries.append(tuple(map(int, query)))\n\n    for query in queries:\n        if query[0] == 1:\n            a, b = queries[query[1]]\n            g = lambda x: f(x) + abs(x - a) + b\n            f = lambda x: g(x)\n            print(g(f(a)))\n        elif query[0] == 2:\n            x = f(queries[query[1]])\n            print(x)"
    },
    {
        "number": 2661,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    S = list(map(int, stdin.readline().strip().split()))\n    T = list(map(int, stdin.readline().strip().split()))\n    U = list(map(int, stdin.readline().strip().split()))\n    V = list(map(int, stdin.readline().strip().split()))\n\n    a = [[0] * N for _ in range(N)]\n\n    for i in range(N):\n        for j in range(N):\n            if S[i] == 0:\n                a[i][j] = U[i]\n            elif S[i] == 1:\n                a[i][j] = U[i] | V[i]\n            elif T[j] == 0:\n                a[i][j] = U[i] & V[i]\n            elif T[j] == 1:\n                a[i][j] = U[i] | V[i] & V[i]\n\n    if a[0][0] == 1 and a[0][1] == 1 and a[1][0] == 1 and a[1][1] == 0:\n        return '\\n'.join(map(str, a))\n    else:\n        return '-1'"
    },
    {
        "number": 2662,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    colors = set()\n    for i in range(N):\n        for j in range(i + 1, N):\n            if A[i] < A[j]:\n                colors.add(A[i])\n                colors.add(A[j])\n\n    return str(len(colors))"
    },
    {
        "number": 2663,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    L = [0] * (N * (N + 1) // 2)\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            L[i * (N + 1) // 2 + j] += A[i]\n\n    L.sort()\n    result = []\n    for i in range(K):\n        result.append(L[i])\n\n    return''.join(map(str, result))"
    },
    {
        "number": 2664,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    n, *weights = map(int, stdin.split())\n\n    # Initialize the heavier ball color\n    heavier_ball_color = 1\n\n    # Initialize the heavier ball weight\n    heavier_ball_weight = 0\n\n    # Initialize the heavier ball count\n    heavier_ball_count = 0\n\n    # Initialize the heavier ball difference\n    heavier_ball_difference = 0\n\n    # Iterate over the weights\n    for i in range(n):\n        # Read the weight of the ball\n        weight = weights[i]\n\n        # Check if the weight is greater than the current heavier ball weight\n        if weight > heavier_ball_weight:\n            # Update the heavier ball color and weight\n            heavier_ball_color = i + 1\n            heavier_ball_weight = weight\n\n            # Update the heavier ball count\n            heavier_ball_count = 1\n\n            # Update the heavier ball difference\n            heavier_ball_difference = 0\n        else:\n            # Update the heavier ball count\n            heavier_ball_count += 1\n\n            # Update the heavier ball difference\n            heavier_ball_difference += abs(weight - heavier_ball_weight)\n\n    # Output the heavier ball color\n    print(heavier_ball_color)\n\n    # Output the heavier ball difference\n    print(heavier_ball_difference)\n\n    return \"\""
    },
    {
        "number": 2665,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    points = []\n    for _ in range(N):\n        x, y = map(int, stdin.readline().strip().split())\n        points.append((x, y))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_valid(p):\n        for q in points:\n            if distance(p, q) <= 1:\n                return False\n        return True\n\n    def paint_square(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if is_valid((points[i][0], points[i][1])) and is_valid((points[j][0], points[j][1])):\n                    return True\n        return False\n\n    paint_square(points)\n    return str(len(points))"
    },
    {
        "number": 2666,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    prices = list(map(int, stdin.split()))\n    max_profit = 0\n\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            if prices[i] > prices[j]:\n                max_profit += prices[j] - prices[i]\n\n    return str(max_profit)"
    },
    {
        "number": 2667,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    stamps = list(map(int, stdin.readline().strip().split()))\n\n    if n == 1:\n        return \"YES\" if stamps[0] == 1 else \"NO\"\n\n    for i in range(1, n):\n        if stamps[i] > stamps[i - 1]:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 2668,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    jacket_cost, sock_cost, money = map(int, stdin.split())\n    socks_bought = 0\n    socks_available = money // sock_cost\n    socks_used = 0\n\n    while socks_used < socks_available:\n        socks_bought += 1\n        socks_used += 1\n\n    if socks_bought == 1:\n        return \"Unlucky Chef\"\n    else:\n        return \"Lucky Chef\""
    },
    {
        "number": 2669,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    tasks = []\n    for _ in range(N):\n        start, finish = map(int, stdin.readline().split())\n        tasks.append((start, finish))\n\n    tasks.sort(key=lambda x: x[1])\n\n    max_tasks = 0\n    current_time = tasks[0][0]\n    for task in tasks:\n        if task[0] <= current_time <= task[1]:\n            max_tasks += 1\n        current_time = max(current_time, task[1])\n\n    return str(max_tasks)"
    },
    {
        "number": 2670,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        str1, str2 = stdin.readline().strip().split()\n        if str1 == str2:\n            continue\n        if str1 + str2 == str1 + str2[::-1]:\n            print(len(str1))\n        else:\n            print(-1)"
    },
    {
        "number": 2671,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    candies = list(map(int, stdin.split()))\n    X = list(map(int, stdin.split()))\n\n    def open_boxes(boxes, X):\n        open_boxes_count = 0\n        for i in range(n):\n            if boxes[i] == 0:\n                open_boxes_count += 1\n                if open_boxes_count == X:\n                    return i\n        return -1\n\n    def find_smallest_open_boxes(boxes, X):\n        smallest_open_boxes = float('inf')\n        for i in range(n):\n            if boxes[i] == 0:\n                open_boxes_count = 0\n                for j in range(i + 1, n):\n                    if boxes[j] == 0:\n                        open_boxes_count += 1\n                if open_boxes_count < smallest_open_boxes:\n                    smallest_open_boxes = open_boxes_count\n        return smallest_open_boxes\n\n    result = []\n    for i in range(m):\n        result.append(find_smallest_open_boxes(candies, X[i]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2672,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n    if X == 1:\n        return \"3\"\n    elif X == 2:\n        return \"14\"\n    else:\n        return str(X % 1000000007)"
    },
    {
        "number": 2673,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    N = len(S)\n    jumps = 0\n    for i in range(N):\n        if S[i] == S[i + 1]:\n            jumps += 1\n        else:\n            break\n    return str(jumps)"
    },
    {
        "number": 2674,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin.strip())\n    if P % 10 == 0:\n        return 'Exclusive'\n    else:\n        return 'Inclusive'"
    },
    {
        "number": 2675,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    red_balls = []\n    blue_balls = []\n    for i in range(n):\n        x, u = map(int, stdin.split())\n        red_balls.append((x, 0))\n    for i in range(m):\n        y, v = map(int, stdin.split())\n        blue_balls.append((0, y))\n\n    collisions = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if red_balls[i][0] == red_balls[j][0]:\n                collisions += 1\n                red_balls[i] = (red_balls[j][0], 0)\n                red_balls[j] = (red_balls[i][0], 0)\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if blue_balls[i][1] == blue_balls[j][1]:\n                collisions += 1\n                blue_balls[i] = (0, blue_balls[j][1])\n                blue_balls[j] = (0, blue_balls[i][1])\n\n    return str(collisions)"
    },
    {
        "number": 2676,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    pile = []\n    for _ in range(N):\n        pile.append(stdin.strip())\n\n    B = stdin.strip()\n    count = 0\n    for i in range(len(B) - M + 1):\n        substring = B[i:i+M]\n        if substring in pile:\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 2677,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    vowels = set('AEIOUaeiou')\n    consonants = set('BCDFGHJKLMNPQRSTVWXYZbcdfghjklmnpqrstvwxyz')\n    count_vowels = 0\n    count_consonants = 0\n    for c in s:\n        if c in vowels:\n            count_vowels += 1\n        else:\n            count_consonants += 1\n    if count_vowels >= 3 and count_consonants >= 5:\n        return 'GOOD'\n    else:\n        return '-1'"
    },
    {
        "number": 2678,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.splitlines():\n        a, b = map(int, line.split())\n        intervals.append((a, b))\n\n    intervals.sort(key=lambda x: x[0])\n\n    covered_intervals = set()\n    for i in range(len(intervals)):\n        for j in range(i + 1, len(intervals)):\n            if intervals[i][1] <= intervals[j][0] and intervals[j][1] <= intervals[i][1]:\n                covered_intervals.add(intervals[i])\n                covered_intervals.add(intervals[j])\n\n    covered_intervals = list(covered_intervals)\n    covered_intervals.sort(key=lambda x: x[0])\n\n    return str(len(covered_intervals))"
    },
    {
        "number": 2679,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    coins = list(map(int, stdin.strip().split()))\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i+1, n+1):\n            for k in range(j+1, n+1):\n                subarray = coins[i:j] + coins[k:n]\n                subarray_sum = sum(subarray)\n                if subarray_sum > max_sum:\n                    max_sum = subarray_sum\n    return str(max_sum)"
    },
    {
        "number": 2680,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, B = map(int, stdin.split())\n    x, y = [], []\n    for _ in range(B):\n        x.append(int(input()))\n        y.append(int(input()))\n\n    moves = 0\n    for i in range(N):\n        for j in range(N):\n            if i == 0 or i == N - 1 or j == 0 or j == N - 1:\n                continue\n            if x[i] == x[i - 1] and x[i] == x[i + 1] and y[j] == y[j - 1] and y[j] == y[j + 1]:\n                moves += 2\n\n    return str(moves)"
    },
    {
        "number": 2681,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C = map(int, stdin.split())\n    if C == \"+\":\n        result = A + B\n    elif C == \"-\":\n        result = A - B\n    elif C == \" * \":\n        result = A * B\n    elif C == \" / \":\n        result = A / B\n    else:\n        return \"Invalid operator\"\n\n    if abs(result) <= 10**-6:\n        return str(result)\n    else:\n        return \"Invalid answer\""
    },
    {
        "number": 2682,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    deck = list(range(n))\n    shuffled_deck = []\n\n    for i in range(n):\n        shuffled_deck.append(deck[i])\n\n    for i in range(n):\n        if i % 2 == 0:\n            shuffled_deck.insert(i, shuffled_deck.pop(i))\n        else:\n            shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop(i))\n\n    for i in range(n):\n        shuffled_deck.insert(i, shuffled_deck.pop("
    },
    {
        "number": 2683,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    for _ in range(T):\n        N, K = map(int, stdin.strip().split())\n        board = [list(input()) for _ in range(N)]\n        winning_move = False\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == 'X':\n                    winning_move = True\n                    break\n                elif board[i][j] == 'O':\n                    winning_move = False\n                    break\n        if winning_move:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n    return \"\""
    },
    {
        "number": 2684,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    word = input().strip()\n    longest_palindrome = \"\"\n    for i in range(N):\n        subword = word[i:i+1]\n        if subword == subword[::-1]:\n            if len(subword) > len(longest_palindrome):\n                longest_palindrome = subword\n    return longest_palindrome"
    },
    {
        "number": 2685,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    s = list(stdin)\n    n = len(s)\n    min_cost = float('inf')\n    for i in range(n):\n        if s[i] == '?':\n            continue\n        if s[i] == '0':\n            min_cost = min(min_cost, x * (i + 1))\n        elif s[i] == '1':\n            min_cost = min(min_cost, y * (i + 1))\n    return str(min_cost)"
    },
    {
        "number": 2686,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    buildings = list(map(int, stdin.split()))\n    pairs = []\n    for i in range(M):\n        a, b = map(int, stdin.split())\n        pairs.append((a, b))\n\n    S, T = map(int, stdin.split())\n    pairs.append((S, T))\n\n    def is_close(a, b):\n        return abs(a - b) <= 1\n\n    def jump(start, end):\n        jumps = 0\n        while start!= end:\n            jumps += 1\n            start = buildings[start]\n        return jumps\n\n    def shortest_route(start, end):\n        jumps = float('inf')\n        for a, b in pairs:\n            if a == start or b == start or a == end or b == end:\n                continue\n            if is_close(a, b):\n                jumps = min(jumps, jump(start, b) + jump(b, end))\n        return jumps\n\n    start = 1\n    end = N\n    while start!= end:\n        jumps = shortest_route(start, end)\n        if jumps < jumps:\n            start, end = end, start\n        else:\n            end = start\n            start = (start + end) // 2\n\n    if end == N:\n        return \"0\"\n    else:\n        return str(end)"
    },
    {
        "number": 2687,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    rounds = 2 * K + 1\n    result = []\n\n    for i in range(rounds):\n        result.append(0)\n\n    for i in range(2, K + 1):\n        for j in range(2, K + 1):\n            result[i] += result[i - 2] + result[i - 1]\n\n    return str(result[K])"
    },
    {
        "number": 2688,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    cycles = []\n    for i in range(N):\n        cycles.append(i)\n    for i in range(N):\n        for j in range(i+1, N):\n            cycles.append(j)\n    return str(len(cycles)) + '\\n' + '\\n'.join(map(str, cycles))"
    },
    {
        "number": 2689,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    code_string = stdin.strip()\n    if not code_string.isdigit():\n        return \"Continue\"\n    else:\n        original_string = \"\"\n        count = 1\n        for i in range(len(code_string)):\n            if code_string[i].isdigit():\n                original_string += code_string[i]\n                count += 1\n            else:\n                original_string += code_string[i]\n                break\n        if count == 1:\n            original_string = code_string\n        else:\n            original_string = original_string * count\n        if original_string == original_string[::-1]:\n            return \"Return\"\n        else:\n            return \"Continue\""
    },
    {
        "number": 2690,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    s = list(stdin.strip())\n    max_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i]!= s[j]:\n                diff = abs(i-j)\n                if diff > max_diff:\n                    max_diff = diff\n    return str(max_diff)"
    },
    {
        "number": 2691,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(int, stdin.split())\n    S = stdin.strip()\n    max_cost = 0\n    for i in range(N):\n        for j in range(i + 1, N + 1):\n            if S[i] == 'd' and S[j] == 'u':\n                max_cost = max(max_cost, j - i)\n    return str(max_cost)"
    },
    {
        "number": 2692,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline().strip())\n    for _ in range(T):\n        N, B = map(int, stdin.readline().strip().split())\n        A = min(N, B)\n        print(A)"
    },
    {
        "number": 2693,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, P, k = map(int, stdin.split())\n    if k > 4:\n        return \"NO\"\n\n    n = [0] * k\n    for i in range(k):\n        n[i] = i + 1\n\n    for i in range(k - 1):\n        for j in range(i + 1, k):\n            n[j] = min(n[j], n[i] + n[j])\n\n    if sum(n) == S and P == sum(n):\n        return \" \".join(map(str, n))\n    else:\n        return \"NO\""
    },
    {
        "number": 2694,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    blasters = []\n    for _ in range(K):\n        row, col, t, f = map(int, stdin.split())\n        blasters.append((row, col, t, f))\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def is_safe(x, y, blasters):\n        for b in blasters:\n            if x == b[0] and y == b[1]:\n                return False\n        return True\n\n    def get_least_time(x, y, blasters):\n        if not is_valid(x, y):\n            return 0\n\n        if not is_safe(x, y, blasters):\n            return 0\n\n        time = 0\n        for dx, dy in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and is_safe(nx, ny, blasters):\n                time += 1\n                time += get_least_time(nx, ny, blasters)\n\n        return time\n\n    least_time = get_least_time(1, 1, blasters)\n    return \"YES\" if least_time == 0 else str(least_time)\n"
    },
    {
        "number": 2695,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = stdin.strip().split()\n    N = len(A)\n    indices = list(map(int, stdin.strip().split()))\n    max_indices = 0\n    for i in range(N):\n        if i in indices:\n            max_indices = max(max_indices, i)\n    return str(max_indices)"
    },
    {
        "number": 2696,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n    X = 0\n    for i in range(n):\n        X = (X + a[i]) % n\n    return str(X)"
    },
    {
        "number": 2697,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    count = 0\n    for i in range(1, N+1):\n        count += i\n    return str(count)"
    },
    {
        "number": 2698,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, V = map(int, stdin.split())\n    vegetables = [0] * M\n    for i in range(M):\n        di, ai = map(int, stdin.split())\n        vegetables[i] = ai\n        if di == 1:\n            vegetables[i] += vegetables[i-1]\n    max_vegetables = 0\n    for i in range(1, M):\n        if vegetables[i] > vegetables[i-1]:\n            max_vegetables += 1\n    return str(max_vegetables)"
    },
    {
        "number": 2699,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    pattern = []\n    for _ in range(T):\n        N = int(stdin.strip())\n        pattern.append(1)\n        for i in range(1, N):\n            pattern.append(pattern[i-1] + pattern[i-2])\n    return''.join(map(str, pattern))"
    },
    {
        "number": 2700,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    for _ in range(T):\n        a, b, c, d = map(int, stdin.readline().split())\n        x, y = 0, 0\n        for i in range(a, b+1):\n            for j in range(c, d+1):\n                if i <= x <= j and i <= y <= j:\n                    x += 1\n                    y += 1\n        print(x + y)"
    },
    {
        "number": 2701,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    T = list(map(int, stdin.split()))\n\n    # Sort the types of apples\n    T.sort()\n\n    # Initialize the minimum time\n    min_time = float('inf')\n\n    # Iterate through the types of apples\n    for i in range(1, N):\n        # Check if the sum of the types is equal to K\n        if sum(T[:i]) == K:\n            # Calculate the minimum time\n            time = i * 1 + 1\n            min_time = min(min_time, time)\n\n    # Return the minimum time\n    return str(min_time)\n"
    },
    {
        "number": 2702,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    Statements = []\n    for _ in range(N):\n        Statements.append(list(map(str, stdin.readline().strip())))\n\n    truth_speaking_people = set()\n    for statement in Statements:\n        truth_speaking_people.add(statement[0])\n\n    max_no_of_truth_speaking_people = 0\n    for truth_speaking_person in truth_speaking_people:\n        max_no_of_truth_speaking_people = max(max_no_of_truth_speaking_people, len(Statements) - Statements.index(truth_speaking_person))\n\n    return str(max_no_of_truth_speaking_people)"
    },
    {
        "number": 2703,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    X = list(map(int, stdin.split()))\n    max_candies = 0\n    for i in range(N):\n        max_candies = max(max_candies, a[i])\n    for i in range(Q):\n        X_i = X[i]\n        max_candies = max(max_candies, X_i)\n    return str(max_candies)"
    },
    {
        "number": 2704,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    for i in range(Q):\n        t = int(stdin.readline())\n        if t == 1:\n            a, b = map(int, stdin.readline().split())\n            if a == b:\n                continue\n            x = (min(a, b) + max(a, b)) // 2\n            A[a], A[b] = A[b], A[a]\n            A[a] = x\n            A[b] = x\n        elif t == 2:\n            a, b = map(int, stdin.readline().split())\n            if a == b:\n                continue\n            x = (min(a, b) + max(a, b)) // 2\n            A[a], A[b] = A[b], A[a]\n            A[a] = x\n            A[b] = x\n        else:\n            t = int(stdin.readline())\n            if t == 1:\n                a, b = map(int, stdin.readline().split())\n                if a == b:\n                    continue\n                x = (min(a, b) + max(a, b)) // 2\n                A[a], A[b] = A[b], A[a]\n                A[a] = x\n                A[b] = x\n            elif t == 2:\n                a, b = map(int, stdin.readline().split())\n                if a == b:\n                    continue\n                x = (min(a, b) + max(a, b)) // 2\n                A[a], A[b] = A[b], A[a]\n                A[a] = x\n                A[b] = x\n            else:\n                t = int(stdin.readline())\n                if t == 1:\n                    a, b = map(int, stdin.readline().split())\n                    if a == b:\n                        continue\n                    x = (min(a, b) + max(a, b)) // 2\n                    A[a], A[b] = A[b], A[a]\n                    A[a] = x\n                    A[b] = x\n                elif t == 2:\n                    a, b = map(int, stdin.readline().split())\n                    if a == b:\n                        continue\n                    x = (min(a, b) + max(a, b)) // 2\n                    A[a], A[b] = A[b], A[a]\n                    A[a] = x\n                    A[b] = x\n                else:\n                    t = int(stdin.readline())\n                    if t == 1:\n                        a, b = map(int, stdin.readline().split())\n                        if a == b:\n                            continue\n                        x = (min(a, b) + max(a, b)) // 2\n                        A[a], A[b] = A[b], A[a]\n                        A[a] = x\n                        A[b] = x\n                    elif t == 2:\n                        a, b = map(int, stdin.readline().split())\n                        if a == b:\n                            continue\n                        x = (min(a, b) + max(a, b)) // 2\n                        A[a], A[b] = A[b], A[a]\n                        A[a] = x\n                        A[b] = x\n\n    for i in range(N):\n        if A[i] == A[i + 1]:\n            return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2705,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    beauty = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            beauty = max(beauty, sum(a[i:j]) % k)\n\n    return str(beauty)"
    },
    {
        "number": 2706,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    queries = []\n    for _ in range(n):\n        queries.append(int(input()))\n\n    min_numbers = []\n    for query in queries:\n        if query == -1:\n            min_numbers.append(min(min_numbers))\n        else:\n            min_numbers.append(query)\n\n    return '\\n'.join(map(str, min_numbers))"
    },
    {
        "number": 2707,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def dfs(start, end, memo):\n        if start == end:\n            return 1\n\n        if start > end:\n            return 0\n\n        if (start, end) in memo:\n            return memo[(start, end)]\n\n        if A[start] <= k:\n            memo[(start, end)] = dfs(start + 1, end, memo) + dfs(start, end - 1, memo)\n        else:\n            memo[(start, end)] = 0\n\n        return memo[(start, end)]\n\n    return str(dfs(0, n - 1, {}))"
    },
    {
        "number": 2708,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    result = 0\n    for i in range(k):\n        if i == 0:\n            result = n\n        elif i == 1:\n            result //= 10\n        else:\n            result -= 1\n    return str(result)"
    },
    {
        "number": 2709,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    if t == 1:\n        print(7)\n    elif t == 2:\n        if A[0] > A[1]:\n            print(\"Bigger\")\n        else:\n            print(\"Equal\")\n    elif t == 3:\n        print(max(A))\n    elif t == 4:\n        print(sum(A))\n    elif t == 5:\n        print(sum(filter(lambda x: x % 2 == 0, A)))\n    elif t == 6:\n        print(sum(map(lambda x: x % 26, A)))\n    elif t == 7:\n        i = 0\n        while i < N:\n            if i == N - 1:\n                print(\"Done\")\n                break\n            if i == N - 2:\n                print(\"Cyclic\")\n                break\n            i += 1\n    else:\n        print(\"Invalid input\")\n\n    return \"\""
    },
    {
        "number": 2710,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    roads = []\n    for i in range(m):\n        p, q = map(int, stdin.split())\n        roads.append((p, q))\n\n    soldiers = [0] * n\n    for i in range(n):\n        soldiers[i] = a[i]\n\n    for i in range(m):\n        p, q = roads[i]\n        if p == q:\n            continue\n        if soldiers[p] < b[i]:\n            soldiers[p] += 1\n        else:\n            soldiers[q] += 1\n\n    for i in range(n):\n        if soldiers[i] == 0:\n            return \"NO\"\n\n    result = []\n    for i in range(n):\n        result.append(soldiers[i])\n\n    return \"YES\\n\".join(map(str, result))"
    },
    {
        "number": 2711,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    alphabet = list('abcdefghijklmnopqrstuvwxyz')\n    reconstructed_alphabet = []\n\n    for i in range(n):\n        page_number, words = map(int, stdin.split())\n        page_words = [word for word in words.split()]\n\n        for j in range(k):\n            page_word = page_words[j]\n            if page_word in alphabet:\n                reconstructed_alphabet.append(page_word)\n\n    if len(reconstructed_alphabet) == 1:\n        return reconstructed_alphabet[0]\n    else:\n        return 'IMPOSSIBLE'"
    },
    {
        "number": 2712,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.readline())\n    for _ in range(t):\n        a, b, c = map(int, stdin.readline().split())\n        d = solution2(a, b, c)\n        print(d)\n\ndef"
    },
    {
        "number": 2713,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rank = 25\n    for match in stdin.splitlines():\n        if match == 'W':\n            rank += 1\n        elif match == 'L':\n            rank -= 1\n        elif match == 'W':\n            rank += 1\n            if rank > 25:\n                rank = 25\n    return str(rank)"
    },
    {
        "number": 2714,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    edges = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        edges.append((u, v))\n\n    def dfs(u, visited):\n        if u in visited:\n            return 0\n        visited.add(u)\n        return 1 + dfs(edges[u][0], visited) + dfs(edges[u][1], visited)\n\n    def is_beautiful(u, visited):\n        return dfs(u, visited) % 2 == 1\n\n    count = 0\n    for u in range(n):\n        if is_beautiful(u, set()):\n            count += 1\n\n    return str(count) % 998244353"
    },
    {
        "number": 2715,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    N = 1\n    a = [1] * N\n    while N > 1:\n        if N - 1 in a:\n            N -= 1\n        else:\n            a[N - 1] += 1\n            N += 1\n    print(N)\n    for i in range(N):\n        print(a[i])"
    },
    {
        "number": 2716,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, t = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    if t == 1:\n        for i in range(N):\n            if A[i]!= A[i+1]:\n                return \"No\"\n        return \"Yes\"\n\n    if t == 2:\n        unique = True\n        for i in range(N):\n            for j in range(i+1, N):\n                if A[i] == A[j]:\n                    unique = False\n                    break\n        if unique:\n            return \"Unique\"\n        else:\n            return \"Contains duplicate\"\n\n    if t == 3:\n        max_count = 0\n        max_num = -1\n        for num in A:\n            if num > N//2:\n                max_count += 1\n                if num > max_num:\n                    max_num = num\n        if max_count == 0:\n            return \"-1\"\n        else:\n            return \" \".join(map(str, [max_num]))\n\n    if t == 4:\n        if N % 2 == 0:\n            median = (A[N//2-1] + A[N//2]) / 2\n            return \" \".join(map(str, [median]))\n        else:\n            return \" \".join(map(str, A))\n\n    if t == 5:\n        for num in A:\n            if num >= 100 and num <= 999:\n                print(\" \".join(map(str, [num])))\n\n    return \"No\""
    },
    {
        "number": 2717,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    teams = stdin.strip().split()\n    seats = [0] * n\n    for i in range(n):\n        seats[i] = i + 1\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if teams[i] == teams[j]:\n                seats[i], seats[j] = seats[j], seats[i]\n                break\n\n    return str(seats.count(seats.index(max(seats))))"
    },
    {
        "number": 2718,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    stack1 = [0] * N\n    stack2 = [0] * N\n    max_stack1 = 0\n    max_stack2 = 0\n\n    for i in range(N):\n        stack1[i] = int(input())\n        stack2[i] = int(input())\n\n        if stack1[i] > max_stack1:\n            max_stack1 = stack1[i]\n        if stack2[i] > max_stack2:\n            max_stack2 = stack2[i]\n\n    if max_stack1 == max_stack2:\n        return \"win\"\n    else:\n        return \"lose\""
    },
    {
        "number": 2719,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    knitting_needles = []\n    for _ in range(K):\n        x1, y1, z1, x2, y2, z2 = map(int, stdin.strip().split())\n        knitting_needles.append((x1, y1, z1, x2, y2, z2))\n\n    def is_true_closed_chain(needle):\n        return (needle[0] == needle[1] and needle[2] == needle[3]) or (needle[0] == needle[2] and needle[1] == needle[3])\n\n    def is_floor_closed_chain(needle):\n        return (needle[0] == needle[1] and needle[2] == needle[3]) or (needle[0] == needle[2] and needle[1] == needle[3])\n\n    for needle in knitting_needles:\n        if is_true_closed_chain(needle) or is_floor_closed_chain(needle):\n            return \"True closed chains\"\n        else:\n            return \"No floor closed chains\""
    },
    {
        "number": 2720,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    maze = [['/' for _ in range(C)] for _ in range(R)]\n\n    for i in range(R):\n        for j in range(C):\n            if i % 2 == 0 and j % 2 == 0:\n                maze[i][j] = '.'\n            elif i % 2 == 1 and j % 2 == 1:\n                maze[i][j] = '/'\n            else:\n                maze[i][j] = '\\\\'\n\n    def dfs(x, y):\n        if x < 0 or x >= R or y < 0 or y >= C or maze[x][y] == '/':\n            return 0\n\n        if maze[x][y] == '\\\\':\n            return 1 + dfs(x - 1, y) + dfs(x + 1, y) + dfs(x, y - 1) + dfs(x, y + 1)\n        else:\n            return 1 + dfs(x, y - 1) + dfs(x, y + 1)\n\n    return str(dfs(0, 0))\n"
    },
    {
        "number": 2721,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, l = map(int, stdin.split())\n    M, L = map(int, stdin.split())\n    t_m, t_l = map(int, stdin.split())\n\n    if m == M and l == L:\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2722,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = []\n    for line in stdin.splitlines():\n        board.append(line)\n\n    def is_valid_move(row, col, direction):\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]):\n            return False\n        if board[row][col] == '.':\n            return False\n        if board[row][col] == 'C':\n            return direction == 'L' or direction == 'R'\n        if board[row][col] == 'I':\n            return direction == 'L' or direction == 'R'\n        return False\n\n    def is_valid_castle(row, col):\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]):\n            return False\n        if board[row][col] == 'C':\n            return True\n        if board[row][col] == 'I':\n            return True\n        return False\n\n    def is_valid_ice_castle(row, col):\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]):\n            return False\n        if board[row][col] == 'C':\n            return True\n        if board[row][col] == 'I':\n            return True\n        return False\n\n    def is_valid_program(row, col):\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]):\n            return False\n        if board[row][col] == '.':\n            return True\n        if board[row][col] == 'C':\n            return is_valid_castle(row - 1, col) or is_valid_castle(row + 1, col) or is_valid_castle(row, col - 1) or is_valid_castle(row, col + 1)\n        if board[row][col] == 'I':\n            return is_valid_ice_castle(row - 1, col) or is_valid_ice_castle(row + 1, col) or is_valid_ice_castle(row, col - 1) or is_valid_ice_castle(row, col + 1)\n        return False\n\n    def shortest_valid_program(row, col):\n        if not is_valid_program(row, col):\n            return None\n        if is_valid_move(row, col, 'F'):\n            return shortest_valid_program(row + 1, col)\n        if is_valid_move(row, col, 'R'):\n            return shortest_valid_program(row, col - 1)\n        if is_valid_move(row, col, 'L'):\n            return shortest_valid_program(row, col + 1)\n        if is_valid_move(row, col, 'X'):\n            return shortest_valid_program(row, col)\n        return None\n\n    start_row, start_col = 0, 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'T':\n                start_row, start_col = i, j\n                break\n\n    diamond_row, diamond_col = 0, 0\n    for i in range(len(board)):\n        for j in range(len(board[0])):\n            if board[i][j] == 'D':\n                diamond_row, diamond_col = i, j\n                break\n\n    if diamond_row == 0 or diamond_col == 0:\n        return \"No solution\"\n\n    shortest_program = shortest_valid_program(start_row, start_col)\n    if shortest_program is None:\n        return \"No solution\"\n\n    return shortest_program"
    },
    {
        "number": 2723,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    matrix = []\n    for _ in range(R):\n        line = input()\n        matrix.append(line)\n\n    def evaluate(formula):\n        stack = []\n        for char in formula:\n            if char == '+':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left + right)\n            elif char == '-':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left - right)\n            elif char == '*':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left * right)\n            elif char == '/':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                if right == 0:\n                    return None\n                stack.append(left / right)\n            elif char == '(':\n                stack.append(char)\n            elif char == ')':\n                while stack[-1]!= '(':\n                    left = stack.pop()\n                    right = stack.pop()\n                    stack.append(left * right)\n                stack.pop()\n            elif char == '_':\n                stack.append(char)\n            elif char == '=':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                if left == right:\n                    stack.append(1)\n                else:\n                    stack.append(0)\n            elif char.isdigit():\n                stack.append(int(char))\n            else:\n                return None\n        return stack[0]\n\n    def evaluate_complex(formula):\n        stack = []\n        for char in formula:\n            if char == '+':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left + right)\n            elif char == '-':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left - right)\n            elif char == '*':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left * right)\n            elif char == '/':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                if right == 0:\n                    return None\n                stack.append(left / right)\n            elif char == '(':\n                stack.append(char)\n            elif char == ')':\n                while stack[-1]!= '(':\n                    left = stack.pop()\n                    right = stack.pop()\n                    stack.append(left * right)\n                stack.pop()\n            elif char == '_':\n                stack.append(char)\n            elif char == '=':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                if left == right:\n                    stack.append(1)\n                else:\n                    stack.append(0)\n            elif char.isdigit():\n                stack.append(int(char))\n            else:\n                return None\n        return stack[0]\n\n    def evaluate_sqrt(formula):\n        stack = []\n        for char in formula:\n            if char == '+':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left + right)\n            elif char == '-':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left - right)\n            elif char == '*':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                stack.append(left * right)\n            elif char == '/':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right = stack.pop()\n                if right == 0:\n                    return None\n                stack.append(left / right)\n            elif char == '(':\n                stack.append(char)\n            elif char == ')':\n                while stack[-1]!= '(':\n                    left = stack.pop()\n                    right = stack.pop()\n                    stack.append(left * right)\n                stack.pop()\n            elif char == '_':\n                stack.append(char)\n            elif char == '=':\n                if len(stack) < 2:\n                    return None\n                left = stack.pop()\n                right"
    },
    {
        "number": 2724,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    students = []\n    tutors = []\n    for _ in range(N):\n        x, y = map(int, stdin.strip().split())\n        students.append((x, y))\n    for _ in range(N):\n        x, y = map(int, stdin.strip().split())\n        tutors.append((x, y))\n\n    def min_distance(student, tutor):\n        return abs(student[0] - tutor[0]) + abs(student[1] - tutor[1])\n\n    students.sort(key=lambda x: min_distance(x, tutors[0]))\n    tutors.sort(key=lambda x: min_distance(x, tutors[0]))\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if min_distance(students[i], tutors[j]) <= min_distance(students[j], tutors[i]):\n                return str(i + 1) + \" \" + str(j + 1)\n\n    return \"0 0\""
    },
    {
        "number": 2725,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    weights = list(map(int, stdin.strip().split()))\n\n    # Calculate the total weight of all items\n    total_weight = sum(weights)\n\n    # Calculate the maximum weight that can be packed\n    max_weight = 2**28\n\n    # Initialize the Knapsack array\n    knapsack = [[0] * (max_weight + 1) for _ in range(n + 1)]\n\n    # Fill the Knapsack array\n    for i in range(1, n + 1):\n        for w in range(max_weight + 1):\n            if i == 1:\n                knapsack[i][w] = w\n            elif w == 0:\n                knapsack[i][w] = 0\n            elif weights[i - 1] <= w:\n                knapsack[i][w] = knapsack[i - 1][w - weights[i - 1]] + weights[i - 1]\n            else:\n                knapsack[i][w] = knapsack[i - 1][w]\n\n    # Find the subset with the maximum weight\n    max_subset = 0\n    max_subset_weight = 0\n    for i in range(1, n + 1):\n        for w in range(max_weight + 1):\n            if knapsack[i][w] > max_subset_weight:\n                max_subset = i\n                max_subset_weight = knapsack[i][w]\n\n    # Reconstruct the weights of the individual items\n    reconstructed_weights = []\n    for i in range(max_subset):\n        reconstructed_weights.append(weights[i])\n\n    return '\\n'.join(map(str, reconstructed_weights))"
    },
    {
        "number": 2726,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Shuffle the deck\n    deck = list(range(n))\n    random.shuffle(deck)\n\n    # Initialize the score\n    score = 0\n\n    # Draw cards until the deck runs out\n    for _ in range(c):\n        # Draw a card\n        card = deck.pop(0)\n\n        # Check if the card is larger than all the cards he previously saw\n        if card > score:\n            score = card\n\n    # Return the expected score\n    return str(score)"
    },
    {
        "number": 2727,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split())\n    A = list(map(int, input().split()))\n    G = list(map(int, input().split()))\n\n    MOD = 10**9 + 7\n\n    def greedy_increasing_subsequence(A, G):\n        gis = []\n        for i in range(1, len(A)):\n            if A[i] > G[i - 1]:\n                gis.append(A[i])\n        return gis\n\n    def count_permutations(A, G):\n        n = len(A)\n        MOD = 10**9 + 7\n        MOD_INV = MOD ** -1\n\n        def helper(remain, gis):\n            if remain == 0:\n                return 1\n\n            count = 0\n            for i in range(n):\n                if A[i] in gis:\n                    count += helper(remain - 1, gis[:i] + [A[i]] + gis[i + 1:])\n\n            return count\n\n        return helper(n, greedy_increasing_subsequence(A, G))\n\n    return str(count_permutations(A, G))"
    },
    {
        "number": 2728,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    buses = []\n    for _ in range(n):\n        bus = []\n        for _ in range(n):\n            bus.append(int(stdin.strip()))\n        buses.append(bus)\n\n    def is_teacher_free_bus_ride(bus):\n        for i in range(n):\n            if bus[i] == 0:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_teacher_free_bus_ride(buses[i]) and is_teacher_free_bus_ride(buses[j]):\n                return str(i) + \" \" + str(j)\n\n    return \"-1\""
    },
    {
        "number": 2729,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    K = 0\n    while N % 10 == 0:\n        N //= 10\n        K += 1\n    while M % 10 == 0:\n        M //= 10\n        K += 1\n    if N < M:\n        N, M = M, N\n    if N == 0:\n        return \"0\"\n    if N == 1:\n        return str(M)\n    if N == 10:\n        return str(M) + \"0\"\n    if N == 100:\n        return str(M) + \"00\"\n    if N == 1000:\n        return str(M) + \"000\"\n    if N == 10000:\n        return str(M) + \"0000\"\n    if N == 100000:\n        return str(M) + \"00000\"\n    if N == 1000000:\n        return str(M) + \"000000\"\n    if N == 10000000:\n        return str(M) + \"0000000\"\n    if N == 100000000:\n        return str(M) + \"00000000\"\n    if N == 1000000000:\n        return str(M) + \"000000000\"\n    if N == 10000000000:\n        return str(M) + \"0000000000\"\n    if N == 100000000000:\n        return str(M) + \"00000000000\"\n    if N == 1000000000000:\n        return str(M) + \"000000000000\"\n    if N == 10000000000000:\n        return str(M) + \"0000000000000\"\n    if N == 100000000000000:\n        return str(M) + \"00000000000000\"\n    if N == 1000000000000000:\n        return str(M) + \"000000000000000\"\n    if N == 10000000000000000:\n        return str(M) + \"0000000000000000\"\n    if N == 100000000000000000:\n        return str(M) + \"00000000000000000\"\n    if N == 1000000000000000000:\n        return str(M) + \"000000000000000000\"\n    if N == 10000000000000000000:\n        return str(M) + \"00000000000000000000\"\n    if N == 100000000000000000000:\n        return str(M) + \"000000000000000000000\"\n    if N == 1000000000000000000000:\n        return str(M) + \"0000000000000000000000\"\n    if N == 10000000000000000000000:\n        return str(M) + \"00000000000000000000000\"\n    if N == 100000000000000000000000:\n        return str(M) + \"000000000000000000000"
    },
    {
        "number": 2730,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    odds = [0] * N\n    for i in range(N):\n        odds[i] = 1 / (i + 1)\n\n    def assign_boxes(boxes):\n        for i in range(N):\n            for j in range(K):\n                if boxes[i] == j + 1:\n                    return i, j\n\n    def find_own_number(boxes):\n        for i in range(N):\n            if boxes[i] == i + 1:\n                return i\n\n    def play_game(boxes):\n        for i in range(N):\n            if boxes[i] == i + 1:\n                return i\n        return -1\n\n    def calculate_odds(boxes):\n        return sum(odds)\n\n    def main():\n        boxes = [0] * N\n        for i in range(N):\n            boxes[i] = i + 1\n\n        while True:\n            own_number = find_own_number(boxes)\n            if own_number == -1:\n                break\n\n            boxes[own_number] = own_number + 1\n\n        for i in range(N):\n            if boxes[i] == i + 1:\n                continue\n\n            if play_game(boxes) == i:\n                odds[i] = 1\n            else:\n                odds[i] = 0\n\n        return calculate_odds(boxes)\n\n    return str(main())\n"
    },
    {
        "number": 2731,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input array\n    array = stdin.strip()\n\n    # Initialize the modified array\n    modified_array = []\n\n    # Initialize the indentation level\n    indentation_level = 0\n\n    # Iterate over each character in the array\n    for char in array:\n        # If the character is a comma, add a new line after it\n        if char == ',':\n            modified_array.append('')\n            indentation_level += 2\n        # If the character is a curly brace, add a new line before it\n        elif char == '{':\n            modified_array.append('')\n            indentation_level += 2\n        # If the character is a closing curly brace, decrease the indentation level\n        elif char == '}':\n            indentation_level -= 2\n        # If the character is a space or a newline, add a new line after it\n        elif char.isspace() or char == '\\n':\n            modified_array[-1] += char\n        # If the character is not a comma, a curly brace, a closing curly brace, or a space, add it as is\n        else:\n            modified_array[-1] += char\n\n    # Join the modified array with newlines\n    modified_array = '\\n'.join(modified_array)\n\n    return modified_array"
    },
    {
        "number": 2732,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W = float(stdin.strip())\n    if W < 0 or W > 1000:\n        return \"Invalid input\"\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def euclidean_distance(x1, y1, x2, y2):\n        return distance(x1, y1, x2, y2)\n\n    def slide_speed(x, y):\n        if x == 1:\n            return 1\n        elif x == 2:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change(x, y):\n        if x == 1:\n            return 2\n        elif x == 2:\n            return 1\n        else:\n            return 1\n\n    def slide_speed_change_angle(x, y):\n        if x == 1:\n            return 1\n        elif x == 2:\n            return -1\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad(x, y):\n        if x == 1:\n            return 1\n        elif x == 2:\n            return -1\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg(x, y):\n        if x == 1:\n            return 180\n        elif x == 2:\n            return 0\n        else:\n            return 180\n\n    def slide_speed_change_angle_deg_to_rad(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_deg_to_rad_rad(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg_rad(x, y):\n        if x == 1:\n            return 180\n        elif x == 2:\n            return 0\n        else:\n            return 180\n\n    def slide_speed_change_angle_deg_to_rad_deg(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg_deg(x, y):\n        if x == 1:\n            return 180\n        elif x == 2:\n            return 0\n        else:\n            return 180\n\n    def slide_speed_change_angle_deg_to_rad_rad_deg(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg_rad_deg(x, y):\n        if x == 1:\n            return 180\n        elif x == 2:\n            return 0\n        else:\n            return 180\n\n    def slide_speed_change_angle_deg_to_rad_rad_rad(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg_rad_rad(x, y):\n        if x == 1:\n            return 180\n        elif x == 2:\n            return 0\n        else:\n            return 180\n\n    def slide_speed_change_angle_deg_to_rad_rad_rad_deg(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg_rad_rad_deg(x, y):\n        if x == 1:\n            return 180\n        elif x == 2:\n            return 0\n        else:\n            return 180\n\n    def slide_speed_change_angle_deg_to_rad_rad_rad_rad_deg(x, y):\n        if x == 180:\n            return 1\n        elif x == 0:\n            return 2\n        else:\n            return 1\n\n    def slide_speed_change_angle_rad_to_deg_rad_rad_rad_deg(x, y"
    },
    {
        "number": 2733,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    droplets = []\n    for _ in range(N):\n        x, y, v_x, v_y, r = map(int, stdin.readline().strip().split())\n        droplets.append((x, y, v_x, v_y, r))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def velocity_difference(p1, p2):\n        return (p1[2] - p2[2], p1[3] - p2[3])\n\n    def velocity_difference_magnitude(v):\n        return abs(v[0]) ** 2 + abs(v[1]) ** 2\n\n    def velocity_difference_angle(v1, v2):\n        return math.degrees(math.atan2(v2[1], v2[0])) - math.degrees(math.atan2(v1[1], v1[0]))\n\n    def velocity_difference_angle_magnitude(v1, v2):\n        return math.degrees(math.atan2(v2[1], v2[0])) - math.degrees(math.atan2(v1[1], v1[0]))\n\n    def velocity_difference_angle_difference(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_magnitude(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle_magnitude(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle_difference(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle_difference_magnitude(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle_difference_angle(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle_difference_angle_magnitude(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1[1], v2[0] - v1[0])) - math.degrees(math.atan2(v1[1] - v1[1], v1[0] - v1[0]))\n\n    def velocity_difference_angle_difference_angle_difference_angle_difference(v1, v2):\n        return math.degrees(math.atan2(v2[1] - v1["
    },
    {
        "number": 2734,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    M = N + k - 1\n    return str(M)"
    },
    {
        "number": 2735,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the starting sequence\n    starting_sequence = stdin.strip().split()\n\n    # Read the target sequence\n    target_sequence = stdin.strip().split()\n\n    # Initialize the result variable\n    result = 0\n\n    # Iterate through the starting sequence\n    for i in range(len(starting_sequence)):\n        # Check if the current icon is the same as the target icon\n        if starting_sequence[i] == target_sequence[i]:\n            # If the current icon is the same, increment the result\n            result += 1\n        else:\n            # If the current icon is different, check the effect of the current icon\n            if i == 0:\n                # If the current icon is the first icon, rotate the target sequence to the left\n                result += len(target_sequence) - 1\n            elif i == len(starting_sequence) - 1:\n                # If the current icon is the last icon, rotate the target sequence to the right\n                result += len(target_sequence) - 1\n            else:\n                # If the current icon is not the first or last icon, rotate the target sequence to the left and right\n                result += len(target_sequence) - 2\n\n    return str(result)"
    },
    {
        "number": 2736,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    heights = []\n    for _ in range(y):\n        heights.append(list(map(int, stdin.split())))\n\n    max_height = max(heights)\n    min_height = min(heights)\n\n    def can_grow_rice(x, y):\n        return (\n            (x, y) in [(0, 0), (x, y - 1), (x - 1, y), (x + 1, y)]\n            and heights[x][y] <= heights[x][y - 1]\n            and heights[x][y] <= heights[x - 1][y]\n            and heights[x][y] <= heights[x + 1][y]\n        )\n\n    def can_collect_water(x, y):\n        return (\n            (x, y) in [(0, 0), (x, y - 1), (x - 1, y), (x + 1, y)]\n            and heights[x][y] <= heights[x][y - 1]\n            and heights[x][y] <= heights[x - 1][y]\n            and heights[x][y] <= heights[x + 1][y]\n        )\n\n    def can_pool_water(x, y):\n        return (\n            (x, y) in [(0, 0), (x, y - 1), (x - 1, y), (x + 1, y)]\n            and heights[x][y] > heights[x][y - 1]\n            and heights[x][y] > heights[x - 1][y]\n            and heights[x][y] > heights[x + 1][y]\n        )\n\n    def can_grow_rice_on_land(x, y):\n        return can_grow_rice(x, y) and not can_collect_water(x, y) and not can_pool_water(x, y)\n\n    def count_land_area(x, y):\n        return (x + 1) * (y + 1)\n\n    def count_land_area_on_land(x, y):\n        return count_land_area(x, y) - count_land_area(x - 1, y) - count_land_area(x, y - 1) - count_land_area(x + 1, y)\n\n    def count_land_area_on_land_with_rice(x, y):\n        return count_land_area_on_land(x, y) + count_land_area(x, y)\n\n    def count_land_area_on_land_with_rice_on_land(x, y):\n        return count_land_area_on_land_with_rice(x, y) + count_land_area_on_land(x, y)\n\n    def count_land_area_on_land_with_rice_on_land_and_pool(x, y):\n        return count_land_area_on_land_with_rice_on_land(x, y) + count_land_area_on_land_with_rice(x, y)\n\n    def count_land_area_on_land_with_rice_on_land_and_pool_and_collect(x, y):\n        return count_land_area_on_land_with_rice_on_land_and_pool(x, y) + count_land_area_on_land_with_rice_on_land(x, y)\n\n    def count_land_area_on_land_with_rice_on_land_and_pool_and_collect_and_pool(x, y):\n        return count_land_area_on_land_with_rice_on_land_and_pool_and_collect(x, y) + count_land_area_on_land_with_rice_on_land_and_pool(x, y)\n\n    def count_land_area_on_land_with_rice_on_land_and_pool_and_collect_and_pool_and_collect(x, y):\n        return count_land_area_on_land_with_rice_on_land_and_pool_and_collect_and_pool(x, y) + count_land_area_on_land_with_rice_on_land_and_pool_and_collect(x, y)\n\n    def count_land_area_on"
    },
    {
        "number": 2737,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split())\n    roads = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        roads[u-1].append((v-1, w))\n        roads[v-1].append((u-1, w))\n    shelters = [[] for _ in range(s)]\n    for _ in range(s):\n        s_i, c_i = map(int, stdin.split())\n        shelters[s_i-1].append((c_i, 0))\n    min_time = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(m):\n                if roads[i][k][1] > roads[j][k][1]:\n                    roads[i], roads[j] = roads[j], roads[i]\n    for i in range(s):\n        for j in range(i+1, s):\n            if shelters[i][0] > shelters[j][0]:\n                shelters[i], shelters[j] = shelters[j], shelters[i]\n    for i in range(n):\n        for j in range(i+1, n):\n            if shelters[i][0] > shelters[j][0]:\n                min_time = min(min_time, shelters[i][1] + roads[i][j][1])\n    return str(min_time)"
    },
    {
        "number": 2738,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    gears = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.strip().split())\n        gears.append((x, y, r))\n\n    def is_connected(a, b):\n        return abs(gears[a][0] - gears[b][0]) <= 1 and abs(gears[a][1] - gears[b][1]) <= 1\n\n    def can_move(a, b):\n        return gears[a][2] > 0\n\n    def move_target(a, b):\n        gears[a][2] -= 1\n        gears[b][2] += 1\n\n    def turn_target(a, b, ratio):\n        gears[a][2] -= ratio\n        gears[b][2] += ratio\n\n    def get_ratio(a, b):\n        return abs(gears[a][2] - gears[b][2]) / gears[a][2]\n\n    def get_result(a, b):\n        if not can_move(a, b):\n            return -1\n\n        if is_connected(a, b):\n            return 0\n\n        ratio = get_ratio(a, b)\n        if ratio == 1:\n            return 0\n\n        if ratio > 1:\n            return -1\n\n        if ratio < -1:\n            return 1\n\n        if ratio == 0:\n            return 0\n\n        if ratio > 0:\n            return 1\n\n        return -1\n\n    result = []\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            a = i\n            b = j\n\n            result.append(get_result(a, b))\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2739,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    b = list(map(int, stdin.strip().split()))\n\n    if n == 1:\n        return str(b[0])\n\n    count = 0\n    for i in range(1, n):\n        count += b[i]\n\n    if count < 0:\n        return \"error\"\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 2740,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, w, h = map(int, stdin.split())\n    mountain_scenes = 0\n\n    for i in range(1, n + 1):\n        for j in range(1, w + 1):\n            mountain_scenes += 2 * (i - 1) * (j - 1)\n\n    return str(mountain_scenes % (10**9 + 7))"
    },
    {
        "number": 2741,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to an integer\n    num = int(stdin, 8)\n\n    # Convert the integer to hexadecimal\n    hex_num = bin(num)[2:]\n\n    # Remove any extra leading zeroes\n    hex_num = hex_num.lstrip('0')\n\n    # Convert the hexadecimal to decimal\n    decimal_num = int(hex_num, 16)\n\n    # Convert the decimal to hexadecimal\n    hex_decimal = hex(decimal_num)[2:]\n\n    # Remove any extra leading zeroes\n    hex_decimal = hex_decimal.lstrip('0')\n\n    return hex_decimal"
    },
    {
        "number": 2742,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [10, 1, 100, 1000]\n    min_coins = float('inf')\n    for coin in coins:\n        if coin <= n:\n            min_coins = min(min_coins, coin)\n    return str(min_coins)"
    },
    {
        "number": 2743,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    grid = []\n    for _ in range(h):\n        line = stdin.strip()\n        grid.append(line)\n\n    balanced = True\n    for i in range(w):\n        for j in range(h):\n            if grid[i][j] == '#':\n                balanced = False\n                break\n\n    if balanced:\n        return \"balanced\"\n    else:\n        return \"left\""
    },
    {
        "number": 2744,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    routes = []\n    for _ in range(m):\n        v, u, w = map(int, stdin.split())\n        routes.append((v, u, w))\n\n    a = list(map(int, stdin.split()))\n\n    def min_coins(v, u, w):\n        d = [float('inf')] * n\n        d[v] = 0\n        for i in range(1, n):\n            for j in range(i):\n                if routes[i][0] == routes[j][0]:\n                    d[i] = min(d[i], d[j] + 2)\n                elif routes[i][1] == routes[j][1]:\n                    d[i] = min(d[i], d[j] + 1)\n        return d[u]\n\n    min_coins_per_city = [float('inf')] * n\n    min_coins_per_city[0] = 0\n\n    for i in range(1, n):\n        min_coins_per_city[i] = float('inf')\n        for j in range(i):\n            if routes[i][0] == routes[j][0]:\n                min_coins_per_city[i] = min(min_coins_per_city[i], min_coins(routes[i][0], routes[j][0], routes[i][2]) + a[i])\n            elif routes[i][1] == routes[j][1]:\n                min_coins_per_city[i] = min(min_coins_per_city[i], min_coins(routes[i][1], routes[j][1], routes[i][2]) + a[i])\n\n    min_coins_per_city = [min_coins_per_city[i] for i in range(n)]\n\n    result = []\n    for i in range(n):\n        if min_coins_per_city[i] == float('inf'):\n            result.append(0)\n        else:\n            result.append(min_coins_per_city[i])\n\n    return''.join(map(str, result))\n"
    },
    {
        "number": 2745,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    words = stdin.split()\n    result = []\n\n    for i in range(len(s)):\n        for j in range(len(words)):\n            substring = s[i:i+words[j].length]\n            if substring in words and substring not in result:\n                result.append(substring)\n\n    return result"
    },
    {
        "number": 2746,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    version1, version2 = stdin.strip().split('.')\n    if version1 > version2:\n        return 1\n    elif version1 < version2:\n        return -1\n    else:\n        return 0"
    },
    {
        "number": 2747,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    nums = list(map(int, stdin.split()))\n    target = int(stdin.split()[1])\n    left, right = 0, len(nums) - 1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return str(mid) + \",\" + str(mid + 1)\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return \"-1,-1\""
    },
    {
        "number": 2748,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    mapping = {\n        2: \"abc\",\n        3: \"def\",\n        4: \"ghi\",\n        5: \"jkl\",\n        6: \"mno\",\n        7: \"pqrs\",\n        8: \"tuv\",\n        9: \"wxyz\"\n    }\n\n    def backtrack(start: int, path: str, result: list):\n        if start == len(stdin):\n            result.append(path)\n            return\n\n        for i in range(start, len(stdin)):\n            if i > start and stdin[i] == stdin[i - 1]:\n                continue\n\n            letter = mapping[stdin[i]]\n            backtrack(i + 1, path + letter, result)\n\n    result = []\n    backtrack(0, \"\", result)\n    return result"
    },
    {
        "number": 2749,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    N = H * W\n    a = list(map(int, stdin.split()))\n\n    def dfs(i, j, color):\n        if i < 1 or i > H or j < 1 or j > W:\n            return False\n\n        if color in [a[i - 1], a[i], a[i + 1]]:\n            return False\n\n        if color in [a[j - 1], a[j], a[j + 1]]:\n            return False\n\n        if i > 1 and a[i - 2] == color:\n            return False\n\n        if i < H - 1 and a[i + 2] == color:\n            return False\n\n        if j > 1 and a[j - 2] == color:\n            return False\n\n        if j < W - 1 and a[j + 2] == color:\n            return False\n\n        return True\n\n    def backtrack(i, j, color):\n        if i == H and j == W:\n            return\n\n        if dfs(i, j, color):\n            print(f\"{color} \", end=\"\")\n            backtrack(i + 1, j, color)\n            backtrack(i, j + 1, color)\n\n    backtrack(1, 1, 1)\n    return \"\""
    },
    {
        "number": 2750,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, B = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def subsequence_length(subsequence):\n        return len(subsequence)\n\n    def subsequence_median(subsequence):\n        subsequence.sort()\n        return subsequence[len(subsequence) // 2]\n\n    subsequences = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            subsequences.append((A[i], A[j]))\n\n    for subsequence in subsequences:\n        subsequence_length_median = subsequence_length(subsequence)\n        subsequence_median_B = subsequence_median(subsequence)\n        if subsequence_length_median % 2 == 1 and subsequence_median_B == B:\n            count = 1\n            for subsequence_B in subsequences:\n                if subsequence_length(subsequence_B) == subsequence_length(subsequence) and subsequence_B!= subsequence:\n                    count += 1\n            return str(count)\n\n    return \"0\""
    },
    {
        "number": 2751,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    sequence = list(map(int, stdin.strip().split()))\n\n    max_score = 0\n    min_operations = 0\n\n    for i in range(N):\n        if sequence[i] % sequence[i + 1] == 0:\n            max_score = max(max_score, sequence[i] // sequence[i + 1])\n        else:\n            min_operations += 1\n\n    return str(max_score) + \" \" + str(min_operations)\n"
    },
    {
        "number": 2752,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    happiness_units = []\n\n    for _ in range(n):\n        a, b = map(int, stdin.split())\n        happiness_units.append(a - b)\n\n    happiness_units.sort()\n    happiness_units.reverse()\n\n    return str(happiness_units[k - 1])\n"
    },
    {
        "number": 2753,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    timestamps = [line.strip() for line in stdin.splitlines()]\n\n    # Initialize variables\n    first_flash_time = None\n    second_flash_time = None\n    first_flash_interval = None\n    second_flash_interval = None\n\n    # Iterate over timestamps\n    for i in range(len(timestamps)):\n        # Extract timestamps\n        hour, minute = map(int, timestamps[i].split(':'))\n\n        # Update variables\n        if i == 0:\n            first_flash_time = datetime.datetime(2021, 1, 1, hour, minute)\n        elif i == 1:\n            second_flash_time = datetime.datetime(2021, 1, 1, hour, minute)\n        elif i > 1:\n            first_flash_interval = datetime.timedelta(hours=5, minutes=50)\n            second_flash_interval = datetime.timedelta(hours=1, minutes=0)\n\n    # Check if stars will never flash at the same minute\n    if first_flash_time == second_flash_time:\n        return \"Never\"\n\n    # Calculate the first same-minute flash\n    first_flash_timestamp = first_flash_time.strftime('%H:%M')\n    if first_flash_timestamp < '10':\n        first_flash_timestamp = '0' + first_flash_timestamp\n\n    # Calculate the second same-minute flash\n    second_flash_timestamp = second_flash_time.strftime('%H:%M')\n    if second_flash_timestamp < '10':\n        second_flash_timestamp = '0' + second_flash_timestamp\n\n    # Output\n    weekday = first_flash_time.strftime('%A')\n    first_flash_timestamp = first_flash_time.strftime('%H:%M')\n    second_flash_timestamp = second_flash_time.strftime('%H:%M')\n\n    return f\"{weekday}\\n{first_flash_timestamp}\\n{second_flash_timestamp}\""
    },
    {
        "number": 2754,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y_low, y_high = map(int, stdin.split())\n    k = 0\n    while True:\n        y = round(10 * (10 ** k) ** x)\n        if y >= y_low and y <= y_high:\n            break\n        k += 1\n    if k == 0:\n        return \"impossible\"\n    return str(k), str(k)"
    },
    {
        "number": 2755,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    paths = []\n    for _ in range(m):\n        u, v = map(int, stdin.split())\n        paths.append((u, v))\n\n    def dfs(u, visited):\n        if u in visited:\n            return False\n        visited.add(u)\n        for v in paths[u]:\n            if dfs(v, visited):\n                return True\n        return False\n\n    def find_hive(u, visited):\n        if dfs(u, visited):\n            return True\n        for v in paths[u]:\n            if find_hive(v, visited):\n                return True\n        return False\n\n    def count_beehives(visited):\n        count = 0\n        for u in range(n):\n            if find_hive(u, visited):\n                count += 1\n        return count\n\n    visited = set()\n    for u in range(n):\n        if find_hive(u, visited):\n            count_beehives(visited)\n            return \"impossible\"\n\n    return count_beehives(visited)\n"
    },
    {
        "number": 2756,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split())\n    dungeon = []\n    for _ in range(n):\n        dungeon.append(list(stdin.strip()))\n\n    player_pos = (0, 0)\n    creeper_pos = (0, 0)\n    exit_pos = (n - 1, m - 1)\n    obstacles = set()\n\n    for i in range(m):\n        for j in range(n):\n            if dungeon[i][j] == 'E':\n                obstacles.add((i, j))\n            elif dungeon[i][j] == 'P':\n                player_pos = (i, j)\n            elif dungeon[i][j] == 'C':\n                creeper_pos = (i, j)\n\n    def is_valid_move(player_pos, creeper_pos, exit_pos, obstacles):\n        if player_pos == exit_pos:\n            return True\n        if (player_pos[0] - creeper_pos[0]) ** 2 + (player_pos[1] - creeper_pos[1]) ** 2 <= e ** 2:\n            return True\n        if (exit_pos[0] - player_pos[0]) ** 2 + (exit_pos[1] - player_pos[1]) ** 2 <= e ** 2:\n            return True\n        for i in range(m):\n            for j in range(n):\n                if dungeon[i][j] == '.' and (i!= player_pos[0] or j!= player_pos[1]) and (i!= exit_pos[0] or j!= exit_pos[1]):\n                    if (i - player_pos[0]) ** 2 + (j - player_pos[1]) ** 2 <= e ** 2:\n                        return True\n                    if (i - exit_pos[0]) ** 2 + (j - exit_pos[1]) ** 2 <= e ** 2:\n                        return True\n        return False\n\n    def get_next_move(player_pos, creeper_pos, exit_pos, obstacles):\n        if is_valid_move(player_pos, creeper_pos, exit_pos, obstacles):\n            return player_pos\n        if (player_pos[0] - creeper_pos[0]) ** 2 + (player_pos[1] - creeper_pos[1]) ** 2 <= e ** 2:\n            return (player_pos[0] - creeper_pos[0], player_pos[1])\n        if (exit_pos[0] - player_pos[0]) ** 2 + (exit_pos[1] - player_pos[1]) ** 2 <= e ** 2:\n            return (exit_pos[0], exit_pos[1])\n        for i in range(m):\n            for j in range(n):\n                if dungeon[i][j] == '.' and (i!= player_pos[0] or j!= player_pos[1]) and (i!= exit_pos[0] or j!= exit_pos[1]):\n                    if (i - player_pos[0]) ** 2 + (j - player_pos[1]) ** 2 <= e ** 2:\n                        return (i - player_pos[0], j - player_pos[1])\n                    if (i - exit_pos[0]) ** 2 + (j - exit_pos[1]) ** 2 <= e ** 2:\n                        return (i - exit_pos[0], j - exit_pos[1])\n        return (player_pos[0], player_pos[1])\n\n    moves = 0\n    while True:\n        moves += 1\n        player_pos = get_next_move(player_pos, creeper_pos, exit_pos, obstacles)\n        if player_pos == exit_pos:\n            break\n        if player_pos in obstacles:\n            creeper_pos = get_next_move(player_pos, creeper_pos, exit_pos, obstacles)\n        else:\n            creeper_pos = get_next_move(player_pos, creeper_pos, exit_pos, obstacles)\n\n    if moves == 119:\n        return \"you're toast\"\n    else:\n        return str(moves)\n"
    },
    {
        "number": 2757,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    values = list(map(int, stdin.strip().split()))\n\n    def is_minimal(node: int) -> bool:\n        if node == 0:\n            return True\n        if node == 1:\n            return False\n        if node == 2:\n            return True\n        if node == 3:\n            return False\n        if node == 4:\n            return True\n        if node == 5:\n            return False\n        if node == 6:\n            return True\n        if node == 7:\n            return False\n        if node == 8:\n            return True\n        if node == 9:\n            return False\n        if node == 10:\n            return True\n        if node == 11:\n            return False\n        if node == 12:\n            return True\n        if node == 13:\n            return False\n        if node == 14:\n            return True\n        if node == 15:\n            return False\n        if node == 16:\n            return True\n        if node == 17:\n            return False\n        if node == 18:\n            return True\n        if node == 19:\n            return False\n        if node == 20:\n            return True\n        if node == 21:\n            return False\n        if node == 22:\n            return True\n        if node == 23:\n            return False\n        if node == 24:\n            return True\n        if node == 25:\n            return False\n        if node == 26:\n            return True\n        if node == 27:\n            return False\n        if node == 28:\n            return True\n        if node == 29:\n            return False\n        if node == 30:\n            return True\n        if node == 31:\n            return False\n        if node == 32:\n            return True\n        if node == 33:\n            return False\n        if node == 34:\n            return True\n        if node == 35:\n            return False\n        if node == 36:\n            return True\n        if node == 37:\n            return False\n        if node == 38:\n            return True\n        if node == 39:\n            return False\n        if node == 40:\n            return True\n        if node == 41:\n            return False\n        if node == 42:\n            return True\n        if node == 43:\n            return False\n        if node == 44:\n            return True\n        if node == 45:\n            return False\n        if node == 46:\n            return True\n        if node == 47:\n            return False\n        if node == 48:\n            return True\n        if node == 49:\n            return False\n        if node == 50:\n            return True\n        if node == 51:\n            return False\n        if node == 52:\n            return True\n        if node == 53:\n            return False\n        if node == 54:\n            return True\n        if node == 55:\n            return False\n        if node == 56:\n            return True\n        if node == 57:\n            return False\n        if node == 58:\n            return True\n        if node == 59:\n            return False\n        if node == 60:\n            return True\n        if node == 61:\n            return False\n        if node == 62:\n            return True\n        if node == 63:\n            return False\n        if node == 64:\n            return True\n        if node == 65:\n            return False\n        if node == 66:\n            return True\n        if node == 67:\n            return False\n        if node == 68:\n            return True\n        if node == 69:\n            return False\n        if node == 70:\n            return True\n        if node == 71:\n            return False\n        if node == 72:\n            return True\n        if node == 73:\n            return False\n        if node == 74:\n            return True\n        if node == 75:\n            return False\n        if node == 76:\n            return True\n        if node == 77:\n            return False\n        if node == 78:\n            return True\n        if node == 79:\n            return False\n        if node == 80:\n            return True\n        if node == 81:\n            return False\n        if node == 82:\n            return True\n        if node == 83:\n            return False\n        if node == 84:\n            return True\n        if node == 85:\n            return False\n        if node == 86:\n            return True\n        if node == 87:\n            return False\n        if node == 88:\n            return True\n        if node == 89:\n            return False\n        if node == 90"
    },
    {
        "number": 2758,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    cats = stdin.splitlines()\n    cats = [cat.strip() for cat in cats]\n    cats = [cat.split() for cat in cats]\n\n    female_cat = cats[0]\n    male_cat = cats[1]\n\n    # Determine the color of the offspring\n    offspring_colors = []\n    for gene in [\"B\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \"O\", \"O\", \"D\", \""
    },
    {
        "number": 2759,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    tanks = []\n    for _ in range(N):\n        row, col = map(int, stdin.strip().split())\n        tanks.append((row, col))\n\n    def is_valid(row, col):\n        for tank in tanks:\n            if tank[0] == row and tank[1] == col:\n                return False\n        return True\n\n    def is_guarding(row, col):\n        for tank in tanks:\n            if tank[0] == row and tank[1] == col:\n                return True\n        return False\n\n    def move(row, col, direction):\n        if direction == 'L':\n            row -= 1\n        elif direction == 'R':\n            row += 1\n        elif direction == 'U':\n            col -= 1\n        elif direction == 'D':\n            col += 1\n        return (row, col)\n\n    def move_tanks(row, col):\n        for direction in ['L', 'R', 'U', 'D']:\n            new_row, new_col = move(row, col, direction)\n            if is_valid(new_row, new_col) and not is_guarding(new_row, new_col):\n                tanks[row][col] = move_tanks(new_row, new_col)\n                return True\n        return False\n\n    move_tanks(0, 0)\n    moves = []\n    for tank in tanks:\n        moves.append(f\"{tank[0]} {tank[1]} {direction}\")\n    return '\\n'.join(moves)"
    },
    {
        "number": 2760,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    arr = list(map(int, stdin.readline().strip().split()))\n\n    swaps = [0] * N\n    swaps[0] = 1\n\n    for i in range(1, N):\n        if arr[i] > arr[i - 1]:\n            swaps[i] = swaps[i - 1] + 1\n        else:\n            swaps[i] = swaps[i - 1]\n\n    return '\\n'.join(map(str, swaps))\n"
    },
    {
        "number": 2761,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    lines = []\n    for _ in range(n):\n        line = list(map(int, stdin.readline().strip().split()))\n        lines.append(line)\n\n    def is_valid(line1, line2, line3):\n        return line1[0]!= line2[0] and line1[1]!= line2[1] and line2[0]!= line3[0] and line2[1]!= line3[1] and line3[0]!= line1[0] and line3[1]!= line1[1]\n\n    def is_parallel(line1, line2, line3):\n        return line1[0] == line2[0] and line1[1] == line2[1] or line1[0] == line3[0] and line1[1] == line3[1] or line2[0] == line3[0] and line2[1] == line3[1]\n\n    def is_triangle(line1, line2, line3):\n        return line1[0] * line2[1] - line1[1] * line2[0] == 0 and line2[0] * line3[1] - line2[1] * line3[0] == 0 and line3[0] * line1[1] - line3[1] * line1[0] == 0\n\n    max_perimeter = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if is_valid(lines[i], lines[j], lines[k]) and not is_parallel(lines[i], lines[j], lines[k]) and not is_parallel(lines[j], lines[i], lines[k]) and not is_parallel(lines[k], lines[i], lines[j]) and is_triangle(lines[i], lines[j], lines[k]):\n                    perimeter = abs(lines[i][0] * lines[j][1] - lines[i][1] * lines[j][0]) + abs(lines[j][0] * lines[k][1] - lines[j][1] * lines[k][0]) + abs(lines[k][0] * lines[i][1] - lines[k][1] * lines[i][0])\n                    if perimeter > max_perimeter:\n                        max_perimeter = perimeter\n\n    if max_perimeter == 0:\n        return \"no triangle\"\n    else:\n        return str(max_perimeter) + \".\""
    },
    {
        "number": 2762,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, G, k = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    # Calculate the number of jobs required for each segment\n    num_jobs = [0] * G\n    for i in range(1, N):\n        num_jobs[i // G] += 1\n\n    # Calculate the total number of jobs\n    total_jobs = sum(num_jobs)\n\n    # Calculate the minimum building cost required\n    min_cost = float('inf')\n    for i in range(1, N):\n        for j in range(i + 1, N + 1):\n            cost = min(num_jobs[i // G] * a[i - 1] + num_jobs[j // G] * a[j - 1], min_cost)\n            min_cost = min(min_cost, cost)\n\n    return str(min_cost)\n"
    },
    {
        "number": 2763,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    grille = stdin.split()[1:]\n    encrypted_message = stdin.split()[1:]\n\n    # Check if the grille is valid\n    for i in range(n):\n        for j in range(n):\n            if grille[i][j] == 'X':\n                return \"invalid grille\"\n\n    # Encrypt the message\n    encrypted_message = \"\"\n    for i in range(n):\n        for j in range(n):\n            if grille[i][j] == 'X':\n                encrypted_message += \"X\"\n            else:\n                encrypted_message += grille[i][j]\n\n    # Decrypt the message\n    decrypted_message = \"\"\n    for i in range(n):\n        for j in range(n):\n            if grille[i][j] == 'X':\n                decrypted_message += \"X\"\n            else:\n                decrypted_message += encrypted_message[i * n + j]\n\n    return decrypted_message"
    },
    {
        "number": 2764,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    board = stdin.splitlines()\n    program = board[8]\n    turtle_position = board[9]\n    diamond_position = board[10]\n\n    # Check if the program is valid\n    if len(program) > 60:\n        return \"Bug!\"\n\n    # Check if the turtle is on the diamond square\n    if turtle_position!= diamond_position:\n        return \"Bug!\"\n\n    # Execute the program\n    for instruction in program:\n        if instruction == \"F\":\n            turtle_position = move_forward(turtle_position)\n        elif instruction == \"R\":\n            turtle_position = rotate_right(turtle_position)\n        elif instruction == \"L\":\n            turtle_position = rotate_left(turtle_position)\n        elif instruction == \"X\":\n            fire_laser(turtle_position)\n\n    return \"Diamond!\"\n\n\ndef"
    },
    {
        "number": 2765,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    S = set(map(int, stdin.strip().split()))\n    if len(S)!= n:\n        return \"non-canonical\"\n\n    def greedy_algorithm(amount):\n        coins = [0] * n\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if amount >= coins[i] + coins[j]:\n                    coins[i], coins[j] = coins[j], coins[i]\n                    amount -= coins[i] + coins[j]\n                    if amount == 0:\n                        return i + 1\n        return n\n\n    def is_canonical(amount):\n        return greedy_algorithm(amount) == n\n\n    return \"canonical\" if is_canonical(83) else \"non-canonical\""
    },
    {
        "number": 2766,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    prob = float(p)\n    if prob < 0.1 or prob > 0.9:\n        return \"Invalid probability\"\n\n    def flip_coin():\n        return random.random() < prob\n\n    def lose_life():\n        return flip_coin() and k > 0\n\n    def win_life():\n        return not lose_life()\n\n    def get_win_count():\n        return sum(1 for _ in range(n) if win_life())\n\n    def get_total_money():\n        return sum(k for _ in range(n) if win_life())\n\n    def get_average_profit():\n        return get_total_money() / n\n\n    return str(get_average_profit())\n"
    },
    {
        "number": 2767,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    words = set(stdin.strip().split())\n    test_sentences = []\n\n    for word in words:\n        if len(word) == 26:\n            test_sentences.append(word)\n\n    return str(len(test_sentences))"
    },
    {
        "number": 2768,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cubes = []\n    for _ in range(M):\n        R, C = map(int, stdin.split())\n        cubes.append((R, C))\n\n    def dfs(r, c, visited):\n        if r == N - 1 and c == N - 1:\n            return 0\n        if r < 0 or r >= N or c < 0 or c >= N or visited[r][c]:\n            return 0\n        visited[r][c] = True\n        return 1 + dfs(r + 1, c, visited) + dfs(r - 1, c, visited) + dfs(r, c + 1, visited) + dfs(r, c - 1, visited)\n\n    visited = [[False] * N for _ in range(N)]\n    min_moves = dfs(0, 0, visited)\n    return str(min_moves)\n"
    },
    {
        "number": 2769,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    s = int(stdin.split()[2])\n\n    if n < min(p, q):\n        return \"-1\"\n\n    classical_problems = [int(x) for x in stdin.split()[3:]]\n    creative_problems = [int(x) for x in stdin.split()[4:]]\n\n    max_diff = max(abs(classical_problems[i] - creative_problems[i]) for i in range(n))\n\n    if max_diff > s:\n        return \"-1\"\n\n    return str(max_diff)\n"
    },
    {
        "number": 2770,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    x = list(map(int, stdin.split()))\n    mod = 10**9 + 7\n\n    for _ in range(q):\n        T, M = map(int, stdin.split())\n        x_T = (x[T - 1] + sum(a[i] * x[T - i - 1] for i in range(n))) % mod\n        print(x_T)\n\n    return \"\""
    },
    {
        "number": 2771,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    directions = stdin.strip().split()\n    directions = [direction.strip() for direction in directions]\n    directions = [direction for direction in directions if direction in ['L', 'R']]\n    directions.sort()\n    orders = []\n    for i in range(n - 1):\n        orders.append(i)\n    orders.append(n - 1)\n    for i in range(n - 2, -1, -1):\n        if directions[i] == 'L':\n            orders.append(i)\n        else:\n            orders.append(i + 1)\n    orders.sort()\n    return str(orders[0]) +'' + str(orders[-1])"
    },
    {
        "number": 2772,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, d = map(int, stdin.split())\n    segments = []\n    for _ in range(a):\n        h, t = map(int, stdin.split())\n        segments.append((h, t))\n    for _ in range(d):\n        h, t = map(int, stdin.split())\n        segments.append((h, t))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def earliest_time(segments):\n        earliest = float('inf')\n        for p in segments:\n            time = p[1]\n            if time < earliest:\n                earliest = time\n        return earliest\n\n    earliest_time_asc = earliest_time(segments[:a])\n    earliest_time_desc = earliest_time(segments[a:])\n\n    return f\"{earliest_time_asc:.5f}\""
    },
    {
        "number": 2773,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        a, b, d = map(int, stdin.split())\n        roads.append((a, b, d))\n\n    def dijkstra(start, visited, distances, prev):\n        visited[start] = True\n        distances[start] = 0\n        for neighbor, distance in roads[start]:\n            if not visited[neighbor]:\n                dijkstra(neighbor, visited, distances, prev)\n                distances[start] = min(distances[start], distances[neighbor])\n                distances[neighbor] = min(distances[neighbor], distances[start])\n                distances[start] += distance\n        prev[start] = start\n\n    def bfs(start, visited, distances, prev):\n        visited[start] = True\n        queue = [start]\n        while queue:\n            current = queue.pop(0)\n            for neighbor, distance in roads[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    distances[neighbor] = distances[current] + distance\n                    queue.append(neighbor)\n        prev[start] = None\n\n    def shortest_path(start, end, visited, distances, prev):\n        if start == end:\n            return distances[start]\n        path = []\n        while start!= end:\n            path.append(start)\n            start = prev[start]\n        path.append(end)\n        path.reverse()\n        return distances[end] + sum(distances[i] for i in path)\n\n    start = 0\n    end = 1\n    visited = [False] * n\n    distances = [float('inf')] * n\n    prev = [None] * n\n    dijkstra(start, visited, distances, prev)\n    if distances[end] == float('inf'):\n        return \"impossible\"\n\n    bfs(end, visited, distances, prev)\n    if distances[end] == float('inf'):\n        return \"impossible\"\n\n    shortest_path_length = len(prev) - 1\n    shortest_path_start = prev[end]\n    shortest_path_end = end\n    shortest_path_distances = [distances[end]]\n    for i in range(shortest_path_length - 1):\n        shortest_path_distances.append(shortest_path_distances[-1] + distances[prev[shortest_path_start]])\n        shortest_path_start = prev[shortest_path_start]\n\n    return \" \".join(map(str, shortest_path_distances))"
    },
    {
        "number": 2774,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    intersections = []\n    for _ in range(N - 1):\n        a, b, d = map(int, stdin.split())\n        intersections.append((a, b, d))\n\n    lamps = list(map(int, stdin.split()))\n    lamp_positions = set(lamps)\n\n    def find_route(start, end, visited):\n        if start == end:\n            return [start]\n        if start in visited:\n            return []\n        visited.add(start)\n        route = find_route(start + 1, end, visited)\n        if end in route:\n            return route\n        visited.remove(start)\n        return find_route(start, end - 1, visited)\n\n    def find_min_lamps(start, end, visited):\n        if start == end:\n            return 0\n        if start in visited:\n            return 0\n        visited.add(start)\n        lamps_needed = find_min_lamps(start + 1, end, visited)\n        visited.remove(start)\n        if end in lamp_positions:\n            return lamps_needed + 1\n        return lamps_needed\n\n    min_lamps = find_min_lamps(1, N, set())\n    return str(min_lamps)\n"
    },
    {
        "number": 2775,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    x_h, y_h, x_w, y_w = map(int, stdin.readline().strip().split())\n    errands = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        errands.append((x, y))\n    visited = set()\n    queue = [(0, 0)]\n    while queue:\n        x, y = queue.pop(0)\n        if (x, y) in visited:\n            continue\n        visited.add((x, y))\n        if x == x_h and y == y_h:\n            return str(len(errands))\n        for dx, dy in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < x_w and 0 <= ny < y_w and (nx, ny) not in visited:\n                queue.append((nx, ny))\n    return \"0\""
    },
    {
        "number": 2776,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    pizzas = set()\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        pizzas.add((a, b))\n    pizzas = sorted(pizzas)\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            if (i, j) not in pizzas:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2777,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    p = list(map(int, stdin.split()))\n\n    def xor_sequences(p):\n        xor_count = 0\n        for i in range(n):\n            xor_count += sum(p[i] ^ p[j] for j in range(i + 1, n))\n        return xor_count\n\n    def count_sequences(p):\n        xor_count = xor_sequences(p)\n        return (xor_count + m - 1) // m\n\n    return str(count_sequences(p))"
    },
    {
        "number": 2778,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, T = map(int, stdin.split())\n    MOD = 1000000009\n    \n    # Compute the number of ways to pick one card from each deck\n    ways = [0] * (N * K)\n    for i in range(N):\n        for j in range(K):\n            ways[i * K + j] = ways[i * K + j - 1] + 1\n    \n    # Compute the number of ways to pick one card from each deck that sums up to T\n    count = 0\n    for i in range(N):\n        for j in range(K):\n            if ways[i * K + j] == T:\n                count += 1\n                if count == 1:\n                    break\n    \n    return str(count % MOD)"
    },
    {
        "number": 2779,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, c = map(int, stdin.split())\n    map_ = []\n    for _ in range(m):\n        map_.append(list(stdin.strip()))\n\n    barricades = {}\n    for i in range(c):\n        barricades[i] = []\n\n    for i in range(m):\n        for j in range(n):\n            if map_[i][j] == 'B':\n                barricades[i].append((j, i))\n\n    min_cost = float('inf')\n    for i in range(c):\n        for j in range(m):\n            if map_[j][i] == 'B':\n                for k in range(4):\n                    x, y = j + dx[k], i + dy[k]\n                    if 0 <= x < m and 0 <= y < n and map_[x][y] == '.' and (x, y) not in barricades[i]:\n                        cost = 1 + min(barricades[i][0][0], barricades[i][0][1], barricades[i][1][0], barricades[i][1][1])\n                        min_cost = min(min_cost, cost)\n\n    return str(min_cost)\n\n\ndef"
    },
    {
        "number": 2780,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    prob = [0.46410, 0.26795, 0.26795]\n    return '\\n'.join(map(str, prob))"
    },
    {
        "number": 2781,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    grid = [[0] * c for _ in range(r)]\n    for _ in range(r):\n        grid_row = list(map(int, stdin.split()))\n        for i in range(c):\n            grid[i][i] = grid_row[i]\n\n    def dfs(x, y, depth):\n        if x < 0 or x >= r or y < 0 or y >= c or grid[x][y] == 0:\n            return depth\n\n        if grid[x][y] < depth:\n            return dfs(x - 1, y, depth)\n\n        if dfs(x + 1, y, depth) < dfs(x, y - 1, depth):\n            return dfs(x, y - 1, depth)\n\n        return dfs(x, y + 1, depth)\n\n    return str(dfs(0, 0, 1000000))\n"
    },
    {
        "number": 2782,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, c = map(int, stdin.split())\n    passengers = []\n    for _ in range(n):\n        a, b, s = map(int, stdin.split())\n        passengers.append((a, b, s))\n\n    def seat_assignment(seats):\n        max_distance = max(seats, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[1]))\n        max_distance = max(max_distance, key=lambda x: abs(x[0] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs(x[1] - x[2]))\n        max_distance = max(max_distance, key=lambda x: abs("
    },
    {
        "number": 2783,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    shady_spots = []\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        shady_spots.append((x, y))\n\n    dormitory = (0, 0)\n    classroom = (0, 0)\n\n    for _ in range(n):\n        x, y = map(int, stdin.strip().split())\n        if x < dormitory[0]:\n            dormitory = (x, y)\n        elif x > dormitory[0] and x < classroom[0]:\n            classroom = (x, y)\n        elif x > classroom[0]:\n            break\n\n    path = []\n    current_spot = dormitory\n    while current_spot!= classroom:\n        path.append(current_spot)\n        current_spot = shady_spots[current_spot[1]]\n\n    path.append(classroom)\n    path.reverse()\n    return''.join(map(str, path))\n"
    },
    {
        "number": 2784,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    stations = []\n    for _ in range(n):\n        name = input().strip()\n        stations.append(name)\n\n    start = input().strip()\n    end = input().strip()\n\n    visited = set()\n    queue = [(start, 0)]\n\n    while queue:\n        current, distance = queue.pop(0)\n        if current == end:\n            return''.join(current)\n        visited.add(current)\n\n        for neighbor in get_neighbors(current, stations):\n            if neighbor not in visited:\n                queue.append((neighbor, distance + 1))\n\n    return 'no route found'\n\ndef"
    },
    {
        "number": 2785,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, M = map(int, stdin.split())\n    investment_options = list(map(int, stdin.split()))\n    investment_costs = list(map(int, stdin.split()))\n    investment_profit = list(map(int, stdin.split()))\n    investment_profit_sum = sum(investment_profit)\n    investment_profit_sum_per_day = investment_profit_sum / n\n\n    days_needed = 0\n    for i in range(n):\n        days_needed += 1\n        if i == 0:\n            days_needed += 1\n        else:\n            days_needed += 2\n\n    days_needed += 1\n\n    return str(days_needed)"
    },
    {
        "number": 2786,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    string = stdin.strip()\n    count = 0\n    for i in range(n):\n        for j in range(len(string)):\n            if string[j] == '(':\n                count += 1\n                if j > 0 and string[j-1] == ')':\n                    count -= 1\n            elif string[j] == '[':\n                count += 1\n                if j > 0 and string[j-1] == ']':\n                    count -= 1\n            elif string[j] == '{':\n                count += 1\n                if j > 0 and string[j-1] == '}':\n                    count -= 1\n            elif string[j] == ')':\n                count -= 1\n            elif string[j] == ']':\n                count -= 1\n            elif string[j] == '}':\n                count -= 1\n    return str(count)"
    },
    {
        "number": 2787,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    airports = []\n    for _ in range(N):\n        airport_code, lat, lon = stdin.split()\n        airports.append((airport_code, (float(lat), float(lon))))\n\n    routes = []\n    for _ in range(M):\n        route_code, start_airport, end_airport = stdin.split()\n        routes.append((route_code, start_airport, end_airport))\n\n    min_shame = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                for l in range(k + 1, N):\n                    if i == j or i == k or i == l or j == k or j == l or k == l:\n                        continue\n\n                    start_airport, end_airport = airports[i]\n                    end_airport, start_airport = airports[j], airports[k]\n                    start_lat, start_lon = start_airport[1]\n                    end_lat, end_lon = end_airport[1]\n\n                    start_dist = distance(start_lat, start_lon, end_lat, end_lon)\n                    end_dist = distance(end_lat, end_lon, start_lat, start_lon)\n\n                    if start_dist == end_dist:\n                        continue\n\n                    start_airport, end_airport = airports[j]\n                    end_airport, start_airport = airports[k]\n                    start_lat, start_lon = start_airport[1]\n                    end_lat, end_lon = end_airport[1]\n\n                    end_dist = distance(end_lat, end_lon, start_lat, start_lon)\n\n                    shame = start_dist + 100 + end_dist - 1100\n\n                    if shame < min_shame:\n                        min_shame = shame\n\n    return str(min_shame)\n\n\ndef"
    },
    {
        "number": 2788,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x, a, b = map(int, stdin.split())\n    students = list(map(int, stdin.split()))\n\n    if n < 1 or n > 1000:\n        return \"impossible\"\n\n    if k < 0 or k > 100:\n        return \"impossible\"\n\n    if x < 0 or x > 100000:\n        return \"impossible\"\n\n    if a < 0 or a > b or b < 0 or b > 100000:\n        return \"impossible\"\n\n    if len(students) < a:\n        return \"impossible\"\n\n    if len(students) > b:\n        return \"impossible\"\n\n    if len(students) > k * x:\n        return \"impossible\"\n\n    return str(n * k * x)"
    },
    {
        "number": 2789,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    pebbles = [int(x) for x in input().split()]\n    pebbles.sort()\n    pebble_count = len(pebbles)\n    min_pebbles = 0\n\n    for i in range(pebble_count):\n        if i == 0:\n            min_pebbles = pebbles[i]\n        else:\n            min_pebbles = min(min_pebbles, pebbles[i])\n\n    return str(min_pebbles)"
    },
    {
        "number": 2790,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, t = map(int, stdin.split())\n    knapsacks = list(map(int, stdin.split()))\n\n    min_time = float('inf')\n    max_time = 0\n    total_time = 0\n\n    for i in range(s):\n        for j in range(i, s):\n            if i == j:\n                continue\n\n            time = (i + 1) % s\n            total_time += time\n\n            if time < min_time:\n                min_time = time\n\n            if time > max_time:\n                max_time = time\n\n    avg_time = total_time / s\n\n    return f\"{min_time} {max_time} {avg_time}\"\n"
    },
    {
        "number": 2791,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] // d == a[j] // d:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2792,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[1])\n    result = []\n    for _ in range(n):\n        query = stdin.split()[2]\n        if query == \"b\":\n            result.append(1)\n        elif query == \"a\":\n            result.append(n)\n        else:\n            result.append(0)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2793,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    def dfs(u, visited):\n        visited[u] = True\n        for v, w in graph[u]:\n            if not visited[v]:\n                dfs(v, visited)\n\n    dfs(s, [False] * n)\n    dfs(t, [False] * n)\n\n    def min_cut(u, visited):\n        if u == t:\n            return 0\n        if visited[u]:\n            return float('inf')\n        visited[u] = True\n        min_cut = float('inf')\n        for v, w in graph[u]:\n            if not visited[v]:\n                min_cut = min(min_cut, min_cut + dfs(v, visited))\n        return min_cut\n\n    min_cut_set = set()\n    for u in range(n):\n        if not visited[u]:\n            min_cut_set.add(u)\n\n    return str(len(min_cut_set)) + '\\n' + '\\n'.join(str(x) for x in min_cut_set)\n"
    },
    {
        "number": 2794,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, c = map(int, stdin.split())\n    a = [int(x) for x in stdin.split()]\n    d = [int(x) for x in stdin.split()]\n\n    def min_annoyance(a, d):\n        return min(a, d)\n\n    def max_annoyance(a, d):\n        return max(a, d)\n\n    def min_annoyance_strategy(a, d):\n        return min_annoyance(a, d)\n\n    def max_annoyance_strategy(a, d):\n        return max_annoyance(a, d)\n\n    def min_annoyance_strategy_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return min_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return min_annoyance_strategy_helper(a, d, min_annoyance_strategy)\n\n    def max_annoyance_strategy_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return max_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return max_annoyance_strategy_helper(a, d, max_annoyance_strategy)\n\n    def min_annoyance_strategy_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return min_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return min_annoyance_strategy_helper_helper(a, d, min_annoyance_strategy)\n\n    def max_annoyance_strategy_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return max_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return max_annoyance_strategy_helper_helper(a, d, max_annoyance_strategy)\n\n    def min_annoyance_strategy_helper_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return min_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return min_annoyance_strategy_helper_helper_helper(a, d, min_annoyance_strategy)\n\n    def max_annoyance_strategy_helper_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return max_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return max_annoyance_strategy_helper_helper_helper(a, d, max_annoyance_strategy)\n\n    def min_annoyance_strategy_helper_helper_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return min_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return min_annoyance_strategy_helper_helper_helper_helper(a, d, min_annoyance_strategy)\n\n    def max_annoyance_strategy_helper_helper_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return max_annoyance(a, d)\n        elif current_strategy == max_annoyance_strategy:\n            return max_annoyance(a, d)\n        else:\n            return max_annoyance_strategy_helper_helper_helper_helper(a, d, max_annoyance_strategy)\n\n    def min_annoyance_strategy_helper_helper_helper_helper_helper(a, d, current_strategy):\n        if current_strategy == min_annoyance_strategy:\n            return min_annoyance"
    },
    {
        "number": 2795,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e, p = map(int, stdin.split())\n    treehouses = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        treehouses.append((x, y))\n\n    cables = []\n    for _ in range(p):\n        a, b = map(int, stdin.split())\n        cables.append((a, b))\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def connect(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def connect_cables(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cables(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cables(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cables(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cables(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cable(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cable_length(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cable_length_cables(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cable_length_cable(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cable_length_cable_length(a, b):\n        if distance(treehouses[a], treehouses[b]) <= e:\n            return True\n        return False\n\n    def criss_cross_cable_length_cable_length_cable_length_cable_length_cable_length_cables(a, b):\n        if distance(treehouses[a], treehouses"
    },
    {
        "number": 2796,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    planets = []\n    for _ in range(n - 1):\n        a, b, z = map(int, stdin.readline().strip().split())\n        planets.append((a, b, z))\n\n    permutation = list(range(n))\n    for i in range(n - 1):\n        j = int(stdin.readline().strip())\n        permutation[i], permutation[j] = permutation[j], permutation[i]\n\n    boring_pairs = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if planets[i][2] == planets[j][2] and planets[i][0]!= planets[j][0] and planets[i][1]!= planets[j][1]:\n                xor_curiosity = 0\n                for path in planets[i][3:]:\n                    xor_curiosity ^= path\n                if xor_curiosity == 0:\n                    boring_pairs += 1\n\n    return str(boring_pairs)\n"
    },
    {
        "number": 2797,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if b % 2 == 0:\n        return \"0\"\n    else:\n        return str(1) + \"^\" + str(b) + \" + \" + str(2) + \"^\" + str(b) + \" + \" + str(a) + \"^\" + str(b) + \" = \" + str(a) + \"^\" + str(b) + \"~\" + str(a)"
    },
    {
        "number": 2798,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ruben = True\n    for line in stdin.splitlines():\n        if line.strip() == \"RUBEN\":\n            ruben = True\n        elif line.strip() == \"ALBERT\":\n            ruben = False\n    return \"RUBEN\" if ruben else \"ALBERT\""
    },
    {
        "number": 2799,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, G, B, Y, S = map(int, stdin.split())\n    if R + G + B + Y < 1 or S > 8:\n        return \"Error: Invalid input\"\n\n    def is_valid_move(color, fruit_basket, raven_step):\n        if color == fruit_basket:\n            return True\n        if raven_step == 1:\n            return True\n        return False\n\n    def get_probability(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit_and_fruit(color, fruit_basket, raven_step):\n        if is_valid_move(color, fruit_basket, raven_step):\n            return 1\n        return 0\n\n    def get_probability_with_raven_and_basket_and_fruit_and_basket_and_fruit_and_fruit_and_fruit_and_"
    },
    {
        "number": 2800,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, K = map(int, stdin.split())\n    N = int(stdin.split()[1])\n\n    # Create piles\n    piles = [[] for _ in range(P)]\n    for i in range(N):\n        pile = list(map(int, stdin.split()))\n        piles[pile[0]].append(pile[1:])\n\n    # Find the player with the highest score\n    max_score = 0\n    max_player = 0\n    for i in range(P):\n        if len(piles[i]) > max_score:\n            max_score = len(piles[i])\n            max_player = i\n\n    # Check if Alice can win\n    if max_player == 0:\n        return \"Alice can win.\"\n    else:\n        return \"Bob will win.\""
    },
    {
        "number": 2801,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    c = list(map(int, stdin.split()))\n    stalls = list(map(int, stdin.split()))\n    connections = list(map(int, stdin.split()))\n\n    def dfs(i, stalls, connections):\n        if i == n:\n            return 0\n\n        total_satisfaction = 0\n        for j in range(m):\n            if connections[j] == 1:\n                total_satisfaction += c[i] * stalls[j]\n\n        return max(total_satisfaction, dfs(i + 1, stalls, connections))\n\n    return str(dfs(0, stalls, connections))\n"
    },
    {
        "number": 2802,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t1, t2, t3, t4 = map(float, stdin.split())\n    t = float(stdin.split())\n    target_final_score = float(stdin.split())\n\n    if t1 + t2 + t3 + t4 <= 0:\n        return \"impossible\"\n\n    if t1 + t2 + t3 + t4 <= target_final_score:\n        return \"infinite\"\n\n    worst_time = max(t1, t2, t3, t4)\n    return f\"{worst_time:.2f}\""
    },
    {
        "number": 2803,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    animals = set(stdin.split())\n    used_animals = set()\n    for animal in animals:\n        if animal not in used_animals:\n            used_animals.add(animal)\n            if animal.startswith(animals[-1]):\n                return animal + \"!\"\n            else:\n                return animal\n    return \"?\""
    },
    {
        "number": 2804,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    words = set()\n    for _ in range(A):\n        word = input()\n        if len(word) < 1 or len(word) > 15:\n            continue\n        words.add(word)\n    for _ in range(B/2):\n        word = input()\n        if len(word) < 1 or len(word) > 15:\n            continue\n        words.add(word)\n    if len(words) < B:\n        return \"No\"\n    return \"Yes\""
    },
    {
        "number": 2805,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    counter = 0\n    for i in range(N - 1, 0, -1):\n        if N % i == 0:\n            counter += 1\n            if i == N // i:\n                break\n    return str(counter)"
    },
    {
        "number": 2806,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, t = map(int, stdin.split())\n    path = []\n    visited = set()\n\n    for _ in range(t):\n        a, b = map(int, stdin.split())\n        path.append((a, b))\n\n    def dfs(start, path):\n        if start in visited:\n            return\n\n        visited.add(start)\n        path.append(start)\n\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                dfs(neighbor, path)\n\n        path.pop()\n\n    graph = [[] for _ in range(c)]\n    for _ in range(t):\n        a, b = map(int, stdin.split())\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    dfs(1, path)\n\n    p = len(path)\n    s = 0\n    for i in range(p):\n        for j in range(i + 1, p):\n            if path[i] == path[j]:\n                s += 1\n\n    return f\"{p} {s}\""
    },
    {
        "number": 2807,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    A = stdin.strip()\n    B = stdin.strip()\n\n    # Initialize variables\n    valid_ways = 0\n    current_group = []\n    current_group_size = 0\n\n    # Iterate through each character in A\n    for i in range(len(A)):\n        # If the current character is a letter, add it to the current group\n        if A[i].isalpha():\n            current_group.append(A[i])\n            current_group_size += 1\n\n            # If the current group has the same size as the previous group,\n            # reverse the order of the current group\n            if current_group_size == len(current_group):\n                current_group.reverse()\n                valid_ways += 1\n\n            # If the current group has the same size as the previous group\n            # and the current character is the same as the previous group's last character,\n            # reverse the order of the current group\n            elif current_group_size == len(current_group) and A[i] == current_group[-1]:\n                current_group.reverse()\n                valid_ways += 1\n\n            # If the current group has the same size as the previous group\n            # and the current character is different from the previous group's last character,\n            # add the current character to the current group\n            else:\n                current_group.append(A[i])\n                current_group_size += 1\n\n    return str(valid_ways)"
    },
    {
        "number": 2808,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    carts = []\n    for _ in range(m):\n        l, r = map(int, stdin.split())\n        carts.append((l, r))\n\n    def is_happy(carts):\n        seen = set()\n        for i in range(n):\n            if i in seen:\n                continue\n            seen.add(i)\n            for j in range(m):\n                if carts[j][0] <= i <= carts[j][1]:\n                    if is_happy(carts[:j] + carts[j+1:]):\n                        return True\n        return False\n\n    if is_happy(carts):\n        return str(k)\n    else:\n        return \"0\""
    },
    {
        "number": 2809,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = input()\n    result = 0\n    for _ in range(k):\n        s = s + s\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] ^ s[j] == 0:\n                result += 1\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 2810,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    connections = []\n    for _ in range(n):\n        s, t = map(int, stdin.split())\n        connections.append((s, t))\n\n    def is_cycle(cycle):\n        for i in range(len(cycle) - 1):\n            if cycle[i] == cycle[i + 1]:\n                return True\n        return False\n\n    def is_cycle_simple(cycle):\n        return len(cycle) == 1\n\n    def count_simple_loops(cycle):\n        count = 0\n        for i in range(len(cycle) - 1):\n            if cycle[i] == cycle[i + 1]:\n                count += 1\n        return count\n\n    def count_unique_simple_loops(connections):\n        unique_loops = set()\n        for s, t in connections:\n            if is_cycle(connections[(s + 1) % m:t]) and is_cycle_simple(connections[(s + 1) % m:t]):\n                unique_loops.add(cycle_to_string(connections[(s + 1) % m:t]))\n        return len(unique_loops)\n\n    def cycle_to_string(cycle):\n        return str(cycle[0]) + \" -> \" + str(cycle[-1])\n\n    return str(count_unique_simple_loops(connections))\n"
    },
    {
        "number": 2811,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    red_nodes = list(map(int, stdin.split()))\n\n    def dfs(node, parent, red_nodes):\n        if node == 1:\n            return 1\n        if node in red_nodes:\n            return 0\n        if node == parent:\n            return 0\n        return dfs(node - 1, node, red_nodes) + dfs(node + 1, node, red_nodes)\n\n    def count_ways(node, parent, red_nodes, k):\n        if node == 1:\n            return 1\n        if node in red_nodes:\n            return 0\n        if node == parent:\n            return 0\n        return count_ways(node - 1, node, red_nodes, k) + count_ways(node + 1, node, red_nodes, k)\n\n    ways = []\n    for i in range(n - 1):\n        parent = red_nodes[i]\n        k = red_nodes[i + 1] - red_nodes[i]\n        ways.append(count_ways(i + 2, parent, red_nodes, k))\n\n    return str(sum(ways))"
    },
    {
        "number": 2812,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin.strip())\n    name = \"\"\n    for i in range(k):\n        name += chr(ord('a') + i)\n    return name"
    },
    {
        "number": 2813,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    syllables = list(map(int, stdin.split()))\n    poem = []\n    for line in stdin.split('\\n')[1:]:\n        words = line.split()\n        poem.append(words)\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range(len(poem[i])):\n            if syllables[i] == 0:\n                syllables[i] = 1\n            else:\n                syllables[i] -= 1\n\n    for i in range(len(poem)):\n        for j in range"
    },
    {
        "number": 2814,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    sigma_0 = list(map(int, stdin.readline().strip().split()))\n    sigma_1 = list(map(int, stdin.readline().strip().split()))\n\n    def is_similar(i, j):\n        return abs(i // 2 - j // 2) == abs(i // 2 - j // 2)\n\n    def get_winner(sigma_0, sigma_1):\n        for i in range(N):\n            if sigma_0[i] == sigma_1[i]:\n                return 0\n        return 1 if sigma_0[0] > sigma_0[1] else -1\n\n    return str(get_winner(sigma_0, sigma_1))"
    },
    {
        "number": 2815,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n):\n        num = i + 1\n        while num % 2 == 0:\n            num //= 2\n            count += 1\n        if num == 2 ** e:\n            count += 1\n    return str(count)"
    },
    {
        "number": 2816,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    grid = [['.' for _ in range(M)] for _ in range(N)]\n    visited = [[False for _ in range(M)] for _ in range(N)]\n    route = []\n    current_row = 0\n    current_col = 0\n    current_tree = None\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == '+':\n                current_tree = (i, j)\n                current_row = i\n                current_col = j\n\n    for _ in range(1000):\n        if current_tree is None:\n            break\n\n        if current_row == N - 1 and current_col == M - 1:\n            route.append((current_row, current_col))\n            break\n\n        if current_row == 0 and current_col == 0:\n            route.append((current_row, current_col))\n            break\n\n        if current_row == 0:\n            current_col -= 1\n        elif current_row == N - 1:\n            current_col += 1\n        elif current_col == 0:\n            current_row += 1\n        elif current_col == M - 1:\n            current_row -= 1\n\n        if grid[current_row][current_col] == '+':\n            if current_tree[0] == current_row and current_tree[1] == current_col:\n                current_tree = None\n            else:\n                current_tree = None\n\n        if current_tree is not None:\n            visited[current_row][current_col] = True\n            if current_row == N - 1 and current_col == M - 1:\n                route.append((current_row, current_col))\n                break\n            if current_row == 0 and current_col == 0:\n                route.append((current_row, current_col))\n                break\n            if current_row == 0:\n                current_col -= 1\n            elif current_row == N - 1:\n                current_col += 1\n            elif current_col == 0:\n                current_row += 1\n            elif current_col == M - 1:\n                current_row -= 1\n\n    return min(route)\n"
    },
    {
        "number": 2817,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    e, e_success, e_failure = map(int, stdin.split())\n    s = 2500\n    d = 0\n    while e > 0:\n        if s - d >= e:\n            d = s - e\n            break\n        else:\n            s -= e\n            e -= e_success\n            e -= e_failure\n    return str(d)"
    },
    {
        "number": 2818,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    H = list(map(int, stdin.readline().strip().split()))\n\n    popped_balloons = 0\n    for i in range(N):\n        if H[i] > 0:\n            popped_balloons += 1\n            H[i] -= 1\n            if H[i] == 0:\n                H.pop(i)\n                i -= 1\n\n    return str(popped_balloons)"
    },
    {
        "number": 2819,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    a_x, a_y = map(int, stdin.readline().strip().split())\n    b_x, b_y = map(int, stdin.readline().strip().split())\n\n    moves = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        moves.append((x, y))\n\n    def is_valid(x, y):\n        return -n < x < n and -n < y < n\n\n    def get_valid_moves(x, y):\n        valid_moves = []\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and moves[nx][ny] == 0:\n                valid_moves.append((nx, ny))\n        return valid_moves\n\n    def get_valid_captures(x, y):\n        valid_captures = []\n        for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and moves[nx][ny] == 0:\n                valid_captures.append((nx, ny))\n        return valid_captures\n\n    def get_valid_teleports(x, y):\n        valid_teleports = []\n        for dx, dy in [(1, 1), (1, -1), (-1, 1), (-1, -1)]:\n            nx, ny = x + dx, y + dy\n            if is_valid(nx, ny) and moves[nx][ny] == 0:\n                valid_teleports.append((nx, ny))\n        return valid_teleports\n\n    def get_valid_actions(x, y):\n        valid_actions = get_valid_captures(x, y) + get_valid_teleports(x, y)\n        valid_actions.extend(get_valid_moves(x, y))\n        return valid_actions\n\n    def get_valid_outcome(x, y):\n        valid_actions = get_valid_actions(x, y)\n        if len(valid_actions) == 1:\n            return \"Alice wins\"\n        elif len(valid_actions) == 2:\n            return \"tie\", a_x, a_y\n        else:\n            return \"Bob wins\"\n\n    for x, y in moves:\n        if get_valid_actions(x, y) == get_valid_captures(x, y):\n            return get_valid_outcome(x, y)\n\n    return \"Alice wins\""
    },
    {
        "number": 2820,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, V = map(int, stdin.split())\n    T = int(stdin.readline())\n    farms = []\n    for _ in range(T):\n        farm = list(map(int, stdin.readline().split()))\n        farms.append(farm)\n\n    def count_beans(farm):\n        beans = 0\n        for i in range(B):\n            beans += farm[i]\n        return beans\n\n    def count_beans_per_cow(farm):\n        beans_per_cow = 0\n        for i in range(B):\n            beans_per_cow += farm[i] // farms[i][0]\n        return beans_per_cow\n\n    def count_beans_per_farm(farm):\n        beans_per_farm = 0\n        for i in range(B):\n            beans_per_farm += sum(farms[j][i] for j in range(T))\n        return beans_per_farm\n\n    def count_beans_per_farm_per_cow(farm):\n        beans_per_farm_per_cow = 0\n        for i in range(B):\n            beans_per_farm_per_cow += sum(farms[j][i] for j in range(T)) // farms[i][0]\n        return beans_per_farm_per_cow\n\n    def count_beans_per_farm_per_cow_per_cow(farm):\n        beans_per_farm_per_cow_per_cow = 0\n        for i in range(B):\n            beans_per_farm_per_cow_per_cow += sum(farms[j][i] for j in range(T)) // farms[i][0] // farms[i][0]\n        return beans_per_farm_per_cow_per_cow\n\n    def count_beans_per_farm_per_cow_per_cow_per_cow(farm):\n        beans_per_farm_per_cow_per_cow_per_cow = 0\n        for i in range(B):\n            beans_per_farm_per_cow_per_cow_per_cow += sum(farms[j][i] for j in range(T)) // farms[i][0] // farms[i][0] // farms[i][0]\n        return beans_per_farm_per_cow_per_cow_per_cow\n\n    def count_beans_per_farm_per_cow_per_cow_per_cow_per_cow(farm):\n        beans_per_farm_per_cow_per_cow_per_cow_per_cow = 0\n        for i in range(B):\n            beans_per_farm_per_cow_per_cow_per_cow_per_cow += sum(farms[j][i] for j in range(T)) // farms[i][0] // farms[i][0] // farms[i][0] // farms[i][0]\n        return beans_per_farm_per_cow_per_cow_per_cow_per_cow\n\n    def count_beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow(farm):\n        beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow = 0\n        for i in range(B):\n            beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow += sum(farms[j][i] for j in range(T)) // farms[i][0] // farms[i][0] // farms[i][0] // farms[i][0] // farms[i][0]\n        return beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow\n\n    def count_beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow_per_cow(farm):\n        beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow_per_cow = 0\n        for i in range(B):\n            beans_per_farm_per_cow_per_cow_per_cow_per_cow_per_cow_per_cow += sum(farms[j][i] for j in range(T)) // farms[i][0] // farms[i][0]"
    },
    {
        "number": 2821,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q, M, S, L = map(int, stdin.split())\n\n    # Calculate the total number of time slots purchased\n    total_slots = S + L\n\n    # Calculate the number of time slots needed for each batch\n    batch_slots = [total_slots // M] * M\n\n    # Calculate the number of time slots needed for each machine\n    machine_slots = [batch_slots[i] // M for i in range(M)]\n\n    # Calculate the total number of time slots needed\n    total_slots_needed = sum(machine_slots)\n\n    # Calculate the smallest amount of time in which you can complete all of the purchased time slots\n    smallest_time = 0\n    for i in range(M):\n        for j in range(batch_slots[i]):\n            smallest_time += machine_slots[i]\n\n    return str(smallest_time)\n"
    },
    {
        "number": 2822,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_b, y_b = map(int, stdin.split())\n    x1, y1, x2, y2 = map(int, stdin.split())\n\n    if x_b == x1 and y_b == y1:\n        return \"No\"\n\n    if x_b == x2 and y_b == y2:\n        return \"No\"\n\n    if x_b == x1 and y_b == y2:\n        return \"No\"\n\n    if x_b == x2 and y_b == y1:\n        return \"No\"\n\n    return \"Yes\""
    },
    {
        "number": 2823,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    cost = list(map(int, stdin.split()))\n\n    # Initialize the swine gene with all characters from the set\n    swine_gene = 'ATCG'\n\n    # Initialize the apple DNA with the swine gene\n    apple_dna = swine_gene\n\n    # Iterate through the apple DNA and insert the swine gene\n    for i in range(N):\n        apple_dna = insert_swine_gene(apple_dna, swine_gene, cost[i])\n\n    # Calculate the total cost\n    total_cost = sum(cost)\n\n    return str(total_cost)\n\n\ndef"
    },
    {
        "number": 2824,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, t = map(int, stdin.split())\n    animals = list(map(int, stdin.split()))\n\n    # Sort the animals by weight\n    animals.sort(key=lambda x: x)\n\n    # Calculate the sum of weights of all animals\n    total_weight = sum(animals)\n\n    # Calculate the number of animals in each group\n    num_light = sum(1 for animal in animals if animal <= t)\n    num_heavy = total_weight - num_light\n\n    # Calculate the target weight\n    target_weight = t\n\n    # If there are an even number of such animals, divide them equally among the two groups\n    if num_heavy % 2 == 0:\n        target_weight = (num_light + num_heavy) // 2\n    else:\n        target_weight = num_light\n\n    return str(target_weight)\n"
    },
    {
        "number": 2825,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *times = map(int, stdin.split())\n    min_time = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            min_time = min(min_time, times[i] + times[j])\n    return str(min_time)"
    },
    {
        "number": 2826,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q, n, D = map(int, stdin.split())\n    focal_points = list(map(int, stdin.split()))\n    hamming_ellipse = set()\n\n    for i in range(q):\n        for j in range(n):\n            for k in range(q):\n                if i!= k and j!= k:\n                    hamming_distance = abs(focal_points[i] ^ focal_points[j])\n                    if hamming_distance <= D:\n                        hamming_ellipse.add((i, j))\n\n    return str(len(hamming_ellipse))"
    },
    {
        "number": 2827,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    links = []\n    for _ in range(M):\n        u, v = map(int, stdin.split())\n        links.append((u, v))\n\n    visited = set()\n    queue = [(0, 0)]\n\n    while queue:\n        dist, node = queue.pop(0)\n        if node in visited:\n            continue\n        visited.add(node)\n        if node == N - 1:\n            return str(dist)\n        for neighbor, weight in links[node]:\n            if neighbor not in visited:\n                queue.append((dist + 1, neighbor))\n\n    return \"0\""
    },
    {
        "number": 2828,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n\n    # Create a dictionary to store the frequency of each letter in the English alphabet\n    freq = {}\n    for i in range(26):\n        freq[chr(i + 97)] = 0\n\n    # Encrypt the words using the substitution cipher\n    encrypted_words = []\n    for i in range(N):\n        encrypted_word = \"\"\n        for j in range(len(A)):\n            if A[j] == i + 1:\n                encrypted_word += chr(ord('a') + j)\n            elif A[j] == i + 2:\n                encrypted_word += chr(ord('b') + j)\n            else:\n                encrypted_word += chr(ord('a') + j)\n        encrypted_words.append(encrypted_word)\n\n    # Sort the encrypted words lexicographically\n    encrypted_words.sort(key=lambda x: x, reverse=True)\n\n    # Create a dictionary to store the frequency of each letter in the key\n    key_freq = {}\n    for i in range(26):\n        key_freq[chr(i + 97)] = 0\n\n    # Choose a key\n    key = \"\"\n    for i in range(26):\n        key += chr(ord('a') + i)\n\n    # Replace the letters in the encrypted words with the key\n    for i in range(N):\n        encrypted_words[i] = encrypted_words[i].replace('a', key[0])\n        encrypted_words[i] = encrypted_words[i].replace('b', key[1])\n        encrypted_words[i] = encrypted_words[i].replace('c', key[2])\n        encrypted_words[i] = encrypted_words[i].replace('d', key[3])\n        encrypted_words[i] = encrypted_words[i].replace('e', key[4])\n        encrypted_words[i] = encrypted_words[i].replace('f', key[5])\n        encrypted_words[i] = encrypted_words[i].replace('g', key[6])\n        encrypted_words[i] = encrypted_words[i].replace('h', key[7])\n        encrypted_words[i] = encrypted_words[i].replace('i', key[8])\n        encrypted_words[i] = encrypted_words[i].replace('j', key[9])\n        encrypted_words[i] = encrypted_words[i].replace('k', key[10])\n        encrypted_words[i] = encrypted_words[i].replace('l', key[11])\n        encrypted_words[i] = encrypted_words[i].replace('m', key[12])\n        encrypted_words[i] = encrypted_words[i].replace('n', key[13])\n        encrypted_words[i] = encrypted_words[i].replace('o', key[14])\n        encrypted_words[i] = encrypted_words[i].replace('p', key[15])\n        encrypted_words[i] = encrypted_words[i].replace('q', key[16])\n        encrypted_words[i] = encrypted_words[i].replace('r', key[17])\n        encrypted_words[i] = encrypted_words[i].replace('s', key[18])\n        encrypted_words[i] = encrypted_words[i].replace('t', key[19])\n        encrypted_words[i] = encrypted_words[i].replace('u', key[20])\n        encrypted_words[i] = encrypted_words[i].replace('v', key[21])\n        encrypted_words[i] = encrypted_words[i].replace('w', key[22])\n        encrypted_words[i] = encrypted_words[i].replace('x', key[23])\n        encrypted_words[i] = encrypted_words[i].replace('y', key[24])\n        encrypted_words[i] = encrypted_words[i].replace('z', key[25])\n\n    # Create a dictionary to store the frequency of each letter in the encrypted words\n    encrypted_word_freq = {}\n    for i in range(len(encrypted_words)):\n        encrypted_word_freq[encrypted_words[i]] = encrypted_word_freq.get(encrypted_words[i], 0) + 1\n\n    # Find the word with the smallest frequency in the encrypted words\n    min_freq = min(encrypted_word_freq.values())\n    min_word = \"\"\n    for word in encrypted_word_freq:\n        if encrypted_word_freq["
    },
    {
        "number": 2829,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    morse_code = {\n        '.-': '---',\n        '-...': '-.-.',\n        '-.-.': '-..',\n        '-..-': '.--.',\n        '.-..': '--..',\n        '--. ': '.--',\n        '....': '..--',\n        '..---': '...-',\n        '...--': '....-',\n        '....-': '.....',\n        '.....': '-....',\n        '-....': '--...',\n        '--...': '---..',\n        '---..': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',\n        '-....': '..--.',\n        '--...': '---...',\n        '---...': '----.',\n        '----.': '-----',\n        '-----': '------',\n        '------': '-----',\n        '.----': '.-..-',\n        '..---': '-..--',\n        '...--': '-.--.',\n        '....-': '-....',\n        '.....': '.-..',"
    },
    {
        "number": 2830,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [list(map(int, input().split())) for _ in range(n)]\n\n    def dfs(x, y, k):\n        if x < 0 or x >= n or y < 0 or y >= m or grid[x][y]!= k:\n            return 0\n\n        if x == n - 1 and y == m - 1:\n            return 1\n\n        return 1 + dfs(x + 1, y, k) + dfs(x - 1, y, k) + dfs(x, y + 1, k) + dfs(x, y - 1, k)\n\n    return str(dfs(0, 0, 1))"
    },
    {
        "number": 2831,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    distances = []\n\n    for _ in range(n):\n        x1, v1 = map(int, stdin.strip().split())\n        x2, v2 = map(int, stdin.strip().split())\n\n        distance = abs(x1 - x2) + abs(v1 - v2)\n        distances.append(distance)\n\n    distances.sort()\n    return str(distances[0])"
    },
    {
        "number": 2832,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, k = map(int, stdin.split())\n    red_values = list(map(int, stdin.split()))\n    posterized_values = [0] * d\n\n    for i in range(d):\n        posterized_values[i] = min(posterized_values[i], red_values[i])\n\n    return str(sum(posterized_values))\n"
    },
    {
        "number": 2833,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    table = []\n    for _ in range(R):\n        row = stdin.strip().split()\n        table.append(row)\n\n    K = int(stdin.strip()) % 360\n\n    for i in range(R):\n        for j in range(C):\n            if i == 0 or j == 0 or i == R - 1 or j == C - 1:\n                table[i][j] = table[i][j].upper()\n            else:\n                table[i][j] = table[i][j].lower()\n\n    rotated_table = []\n    for i in range(R):\n        rotated_row = []\n        for j in range(C):\n            rotated_row.append(table[i][C - 1 - j])\n        rotated_table.append(rotated_row)\n\n    result = \"\"\n    for row in rotated_table:\n        result += \" \".join(row) + \"\\n\"\n\n    return result\n"
    },
    {
        "number": 2834,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K = int(stdin.strip())\n    lucky_numbers = [int(digit) for digit in str(K)]\n    lucky_numbers.sort()\n    lucky_numbers.reverse()\n    lucky_numbers = [lucky_number for lucky_number in lucky_numbers if str(lucky_number).isdigit()]\n    lucky_numbers.sort()\n    lucky_numbers.reverse()\n    return str(lucky_numbers[0])"
    },
    {
        "number": 2835,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.strip().split()\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n            if s[i:j] == t:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2836,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    P = list(map(int, stdin.split()))\n\n    def min_distance(x, p):\n        return abs(x - p)\n\n    def max_distance(x, p):\n        return min_distance(x, p) + 1\n\n    def max_distance_index(x, p):\n        return min(i for i, y in enumerate(p) if abs(x - y) == 1)\n\n    def max_distance_name(x, p):\n        return p[max_distance_index(x, p)]\n\n    def max_distance_names(x, p):\n        return [max_distance_name(x, p) for _ in range(N)]\n\n    def max_distance_names_set(x, p):\n        return set(max_distance_names(x, p))\n\n    def max_distance_names_set_min(x, p):\n        return min(max_distance_names_set(x, p))\n\n    def max_distance_names_set_max(x, p):\n        return max(max_distance_names_set(x, p))\n\n    def max_distance_names_set_min_max(x, p):\n        return max(max_distance_names_set_min(x, p), max_distance_names_set_max(x, p))\n\n    def max_distance_names_set_min_max_index(x, p):\n        return min(i for i, y in enumerate(p) if max_distance_names_set_min(x, p) <= max_distance_names_set_max(x, p))\n\n    def max_distance_names_set_min_max_name(x, p):\n        return p[max_distance_names_set_min_max_index(x, p)]\n\n    def max_distance_names_set_min_max_names(x, p):\n        return [max_distance_names_set_min_max_name(x, p) for _ in range(N)]\n\n    def max_distance_names_set_min_max_names_set(x, p):\n        return set(max_distance_names_set_min_max_names(x, p))\n\n    def max_distance_names_set_min_max_names_set_min(x, p):\n        return min(max_distance_names_set_min_max_names_set(x, p))\n\n    def max_distance_names_set_min_max_names_set_max(x, p):\n        return max(max_distance_names_set_min_max_names_set(x, p))\n\n    def max_distance_names_set_min_max_names_set_min_max(x, p):\n        return max(max_distance_names_set_min_max_names_set_min(x, p), max_distance_names_set_min_max_names_set_max(x, p))\n\n    def max_distance_names_set_min_max_names_set_min_max_index(x, p):\n        return min(i for i, y in enumerate(p) if max_distance_names_set_min_max_names_set_min(x, p) <= max_distance_names_set_min_max_names_set_max(x, p))\n\n    def max_distance_names_set_min_max_names_set_min_max_name(x, p):\n        return p[max_distance_names_set_min_max_names_set_min_max_index(x, p)]\n\n    def max_distance_names_set_min_max_names_set_min_max_names(x, p):\n        return [max_distance_names_set_min_max_names_set_min_max_name(x, p) for _ in range(N)]\n\n    def max_distance_names_set_min_max_names_set_min_max_names_set(x, p):\n        return set(max_distance_names_set_min_max_names_set_min_max_names(x, p))\n\n    def max_distance_names_set_min_max_names_set_min_max_names_set_min(x, p):\n        return min(max_distance_names_set_min_max_names_set_min_max_names_set(x, p))\n\n    def max_distance_names_set_min_max_names_"
    },
    {
        "number": 2837,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    R = list(map(float, stdin.strip().split()))\n    S = stdin.strip()\n\n    def is_valid_circuit(circuit):\n        stack = []\n        for char in circuit:\n            if char == 'R':\n                stack.append(char)\n            elif char == '1' or char == '2' or char == '3' or char == '4' or char == '5' or char == '6' or char == '7' or char == '8' or char == '9':\n                if len(stack) == 0 or stack[-1]!= '-':\n                    return False\n                stack.append(char)\n            elif char == '(':\n                stack.append(char)\n            elif char == ')':\n                if len(stack) == 0 or stack[-1]!= '-':\n                    return False\n                stack.pop()\n            elif char == '-':\n                if len(stack) == 0 or stack[-1]!= '|':\n                    return False\n                stack.append(char)\n            elif char == '|':\n                if len(stack) == 0 or stack[-1]!= '-':\n                    return False\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0\n\n    if not is_valid_circuit(S):\n        return \"Invalid circuit\"\n\n    R_eq = sum(R[:N])\n    R_eq_parallel = 1 / (1 / R[0] + 1 / R[1] + 1 / R[2] +... + 1 / R[N - 1])\n\n    return str(round(R_eq, 5)) + \" \" + str(round(R_eq_parallel, 5))"
    },
    {
        "number": 2838,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    expressions = stdin.split('\\n')\n    expressions = [expression.strip() for expression in expressions]\n    expressions = [expression for expression in expressions if '(' in expression and ')' in expression]\n    expressions = [expression for expression in expressions if '(' in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' in expression and '(' not in expression]\n    expressions = [expression for expression in expressions if '(' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if '(' not in expression and ')' in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and '(' in expression]\n    expressions = [expression for expression in expressions if ')' in expression and '(' not in expression]\n    expressions = [expression for expression in expressions if ')' in expression and '(' in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' in expression]\n    expressions = [expression for expression in expressions if ')' in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' in expression and ')' in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and ')' not in expression]\n    expressions = [expression for expression in expressions if ')' not in expression and"
    },
    {
        "number": 2839,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V, E = map(int, stdin.split())\n    edges = []\n    for _ in range(E):\n        u, v, w = map(int, stdin.split())\n        edges.append((u, v, w))\n\n    s, t = map(int, stdin.split())\n\n    def dfs(u, visited, path):\n        visited[u] = True\n        path.append(u)\n        for v, w in edges[u]:\n            if not visited[v]:\n                dfs(v, visited, path)\n        path.pop()\n\n    visited = [False] * V\n    path = [s]\n    dfs(s, visited, path)\n\n    def count_diff_paths(path1, path2):\n        count = 0\n        for i in range(len(path1)):\n            if path1[i]!= path2[i]:\n                count += 1\n        return count\n\n    diff_paths = [count_diff_paths(path1, path2) for path1, path2 in itertools.combinations(path, 2)]\n    return str(max(diff_paths))\n"
    },
    {
        "number": 2840,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    hand = []\n    for _ in range(n):\n        rank, suit = stdin.strip().split()\n        hand.append((rank, suit))\n\n    hand.sort(key=lambda x: (x[1], int(x[0])))\n\n    moves = 0\n    for i in range(len(hand) - 1):\n        if hand[i][1] == hand[i + 1][1]:\n            if hand[i][0] > hand[i + 1][0]:\n                moves += 1\n            else:\n                moves += 2\n        else:\n            moves += 1\n\n    return str(moves)"
    },
    {
        "number": 2841,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    S = list(stdin.strip())\n    draws = 0\n    for i in range(N):\n        if S[i] == 'Yellow':\n            draws += 1\n            if i == N - 1:\n                return str(draws)\n    return str(draws)"
    },
    {
        "number": 2842,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    ships = [list(map(int, stdin.split())) for _ in range(k)]\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < n and ships[x][y] == 0\n\n    def is_consistent(x, y):\n        for i in range(k):\n            if ships[x][y] == ships[i][y]:\n                return False\n        return True\n\n    def count_ways(x, y):\n        if is_valid(x, y):\n            if is_consistent(x, y):\n                return 1\n            else:\n                return 0\n        else:\n            return 0\n\n    ways = 0\n    for i in range(n):\n        for j in range(n):\n            ways += count_ways(i, j)\n\n    return str(ways)\n"
    },
    {
        "number": 2843,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    words = []\n    for _ in range(N):\n        word = input().strip()\n        if len(word) > 0:\n            words.append(word)\n\n    def is_swap_free(word1: str, word2: str) -> bool:\n        if len(word1)!= len(word2):\n            return False\n\n        for i in range(len(word1)):\n            if word1[i]!= word2[i]:\n                return False\n\n        return True\n\n    def largest_swap_free_set(words: List[str]) -> int:\n        max_size = 0\n        for i in range(len(words)):\n            for j in range(i + 1, len(words)):\n                if is_swap_free(words[i], words[j]):\n                    size = j - i + 1\n                    if size > max_size:\n                        max_size = size\n\n        return max_size\n\n    return str(largest_swap_free_set(words))\n"
    },
    {
        "number": 2844,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    map_str = stdin.strip()\n\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C and map_str[x][y]!= '.'\n\n    def is_valid_move(x, y, dx, dy):\n        return 0 <= x + dx < R and 0 <= y + dy < C and map_str[x + dx][y + dy]!= '.'\n\n    def is_valid_move_and_not_flooded(x, y, dx, dy):\n        if is_valid_move(x, y, dx, dy):\n            if map_str[x + dx][y + dy] == '*':\n                return False\n            if map_str[x + dx][y + dy] == 'D':\n                return False\n            if map_str[x + dx][y + dy] == 'S':\n                return False\n        return True\n\n    def is_valid_move_and_not_water(x, y, dx, dy):\n        if is_valid_move(x, y, dx, dy):\n            if map_str[x + dx][y + dy] == 'X':\n                return False\n        return True\n\n    def is_valid_move_and_not_den(x, y, dx, dy):\n        if is_valid_move(x, y, dx, dy):\n            if map_str[x + dx][y + dy] == 'D':\n                return False\n        return True\n\n    def is_valid_move_and_not_hedgehogs(x, y, dx, dy):\n        if is_valid_move(x, y, dx, dy):\n            if map_str[x + dx][y + dy] == 'S':\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus(x, y, dx, dy):\n        if is_valid_move(x, y, dx, dy):\n            if map_str[x + dx][y + dy] == 'S':\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus_and_not_hedgehogs(x, y, dx, dy):\n        if is_valid_move_and_not_cactus(x, y, dx, dy):\n            if is_valid_move_and_not_hedgehogs(x, y, dx, dy):\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus_and_not_den(x, y, dx, dy):\n        if is_valid_move_and_not_cactus(x, y, dx, dy):\n            if is_valid_move_and_not_den(x, y, dx, dy):\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus_and_not_den_and_not_hedgehogs(x, y, dx, dy):\n        if is_valid_move_and_not_cactus_and_not_den(x, y, dx, dy):\n            if is_valid_move_and_not_hedgehogs(x, y, dx, dy):\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus_and_not_den_and_not_hedgehogs_and_not_cactus(x, y, dx, dy):\n        if is_valid_move_and_not_cactus_and_not_den_and_not_hedgehogs(x, y, dx, dy):\n            if is_valid_move_and_not_cactus(x, y, dx, dy):\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus_and_not_den_and_not_hedgehogs_and_not_cactus_and_not_hedgehogs(x, y, dx, dy):\n        if is_valid_move_and_not_cactus_and_not_den_and_not_hedgehogs_and_not_cactus(x, y, dx, dy):\n            if is_valid_move_and_not_hedgehogs(x, y, dx, dy):\n                return False\n        return True\n\n    def is_valid_move_and_not_cactus_and_not_den_and_not_hedgehogs_and_not_cactus"
    },
    {
        "number": 2845,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, K = map(int, stdin.split())\n    house = [int(x) for x in stdin.split()]\n    house.sort()\n    house_length = house[-1]\n    perimeter = 0\n    for i in range(1, R):\n        perimeter += house_length\n    return str(perimeter)"
    },
    {
        "number": 2846,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    citations = list(map(int, stdin.readline().strip().split()))\n\n    h_index = 0\n    for i in range(n):\n        h_index = max(h_index, citations[i])\n\n    return str(h_index)"
    },
    {
        "number": 2847,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split())\n    songs = list(map(int, stdin.split()))\n\n    # Sort the songs\n    songs.sort()\n\n    # Find the length of the smallest possible set list\n    length = 1\n    for i in range(1, len(songs)):\n        if songs[i] - songs[i-1] > length:\n            length = songs[i] - songs[i-1]\n\n    # Find the set list\n    set_list = []\n    for i in range(M):\n        set_list.append(songs[i])\n\n    # Print the set list\n    print(length)\n    print(' '.join(map(str, set_list)))\n\n    return ''"
    },
    {
        "number": 2848,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, K, X_0, A, B = map(int, stdin.split())\n    X = [X_0]\n    for i in range(1, R):\n        X.append((A * X[i-1] + B) % N)\n    a = 0\n    for i in range(1, R):\n        a = (53 * a + X[i]) % 199933\n    return str(a)"
    },
    {
        "number": 2849,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n < 1:\n        return \"0\"\n\n    def is_ugly(x: int, y: int, z: int) -> bool:\n        return x % 2 == 0 or y % 2 == 0 or z % 2 == 0\n\n    def count_ugly_torches(x: int, y: int, z: int) -> int:\n        count = 0\n        for i in range(x, x + 3):\n            for j in range(y, y + 3):\n                for k in range(z, z + 3):\n                    if is_ugly(i, j, k):\n                        count += 1\n        return count\n\n    def count_ugly_torches_mod_1000000007(x: int, y: int, z: int) -> int:\n        count = 0\n        for i in range(x, x + 3):\n            for j in range(y, y + 3):\n                for k in range(z, z + 3):\n                    if is_ugly(i, j, k):\n                        count += 1\n        return count % (10**9 + 7)\n\n    count = 0\n    for i in range(1, n + 1):\n        count += count_ugly_torches(i, i, i)\n\n    return str(count)\n"
    },
    {
        "number": 2850,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    w = list(map(int, stdin.split()))\n\n    # Sort the items by their weight\n    items = sorted(enumerate(w), key=lambda x: x[1])\n\n    # Partition the items into groups of consecutive items\n    groups = [[] for _ in range(k)]\n    for i, (index, weight) in items:\n        groups[index % k].append(weight)\n\n    # Calculate the minimum possible weight of the heaviest box\n    max_weight = 0\n    for group in groups:\n        max_weight = max(max_weight, sum(group))\n\n    return str(max_weight)\n"
    },
    {
        "number": 2851,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, M = map(int, stdin.split())\n    B = A * M\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    result = gcd(A, B)\n    if len(str(result)) > 9:\n        result = result % 1000000000\n\n    return str(result)\n"
    },
    {
        "number": 2852,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    probabilities = list(map(int, stdin.strip().split()))\n\n    max_index = 0\n    max_value = 0\n\n    for i in range(n):\n        index = probabilities[i]\n        value = 1 / (1 + math.exp(-index))\n\n        if value > max_value:\n            max_value = value\n            max_index = i\n\n    return str(max_value)"
    },
    {
        "number": 2853,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    connected = set()\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        connected.add((a, b))\n    not_connected = [i for i in range(1, n+1) if i not in connected]\n    return''.join(map(str, not_connected))"
    },
    {
        "number": 2854,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    atoms = []\n    bonds = []\n    for _ in range(n):\n        x, y = map(int, stdin.split())\n        if x == -1 and y == -1:\n            atoms.append(None)\n        else:\n            atoms.append((x, y))\n    for _ in range(m):\n        a, b = map(int, stdin.split())\n        bonds.append((a - 1, b - 1))\n    for i in range(n):\n        for j in range(i + 1, n):\n            if atoms[i] is None or atoms[j] is None:\n                continue\n            for k in range(m):\n                if bonds[k][0] == i and bonds[k][1] == j:\n                    continue\n                if atoms[i][0] == atoms[j][0] and atoms[i][1] == atoms[j][1]:\n                    continue\n                if abs(atoms[i][0] - atoms[j][0]) + abs(atoms[i][1] - atoms[j][1]) <= 10**-3:\n                    atoms[i] = (atoms[i][0] + atoms[j][0], atoms[i][1] + atoms[j][1])\n                    break\n    return '\\n'.join(map(str, atoms))"
    },
    {
        "number": 2855,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    paths = []\n    for _ in range(M):\n        K, L = map(int, stdin.split())\n        paths.append((K, L))\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def get_path(p1, p2):\n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        steps = abs(dx) + abs(dy)\n        return steps\n\n    def get_path_length(p1, p2):\n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        return abs(dx) + abs(dy)\n\n    def get_path_cost(p1, p2):\n        dx, dy = p2[0] - p1[0], p2[1] - p1[1]\n        return abs(dx) + abs(dy)\n\n    def get_path_cost_with_distance(p1, p2):\n        return get_path_cost(p1, p2) + distance(p1, p2)\n\n    def get_path_cost_with_distance_and_steps(p1, p2):\n        return get_path_cost_with_distance(p1, p2) + get_path_length(p1, p2)\n\n    def get_path_cost_with_distance_and_steps_and_time(p1, p2):\n        return get_path_cost_with_distance_and_steps(p1, p2) + 1\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time(p1, p2) + distance(p1, p2)\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time_and_distance(p1, p2) + get_path_length(p1, p2)\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps(p1, p2) + 1\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time(p1, p2) + distance(p1, p2)\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance_and_steps(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance(p1, p2) + get_path_length(p1, p2)\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance_and_steps_and_time(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance_and_steps(p1, p2) + 1\n\n    def get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance(p1, p2):\n        return get_path_cost_with_distance_and_steps_and_time_and_distance_and_steps_and_time_and_distance_and_steps_and_time(p1, p2) + distance(p1, p2)\n\n    def get_path_cost_with_distance_and_steps_"
    },
    {
        "number": 2856,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    molecule = stdin.strip()\n    mutations = 0\n\n    for i in range(N):\n        if molecule[i] == 'A':\n            molecule = molecule[:i] + 'B' + molecule[i+1:]\n            mutations += 1\n        elif molecule[i] == 'B':\n            molecule = molecule[:i] + 'A' + molecule[i+1:]\n            mutations += 1\n\n    return str(mutations)"
    },
    {
        "number": 2857,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    triangles = 0\n\n    for i in range(N):\n        x1, y1 = map(int, stdin.strip().split())\n        x2, y2 = map(int, stdin.strip().split())\n        x3, y3 = map(int, stdin.strip().split())\n\n        if x1 == x2 and x2 == x3:\n            triangles += 1\n            continue\n\n        if x1 == y1 and x1 == y2 and x1 == y3:\n            triangles += 1\n            continue\n\n        if x2 == y2 and x2 == y3:\n            triangles += 1\n            continue\n\n        if x3 == y3:\n            triangles += 1\n            continue\n\n        if x1 == y2 or x1 == y3 or x2 == y3:\n            triangles += 1\n            continue\n\n        if x1 == y1 or x2 == y1 or x3 == y1:\n            triangles += 1\n            continue\n\n        if x1 == y2 or x2 == y3 or x3 == y2:\n            triangles += 1\n            continue\n\n        if x1 == y3 or x2 == y1 or x3 == y2:\n            triangles += 1\n            continue\n\n    return str(triangles)\n"
    },
    {
        "number": 2858,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    accused = set(map(int, stdin.split()))\n\n    def count_mobsters(player):\n        return sum(1 for accused_player in accused if accused_player == player)\n\n    max_mobsters = max(count_mobsters(player) for player in range(1, N+1))\n\n    return str(max_mobsters)"
    },
    {
        "number": 2859,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1 = map(int, stdin.split())\n    x2, y2 = map(int, stdin.split())\n    x3, y3 = map(int, stdin.split())\n    xv, yv = map(int, stdin.split())\n    r = int(stdin.split())\n\n    # Calculate the direction vector\n    dx = x2 - x1\n    dy = y2 - y1\n    direction = (dy, -dx)\n\n    # Calculate the distance between the centers of particles 2 and 3\n    distance = ((x2 - x3) ** 2 + (y2 - y3) ** 2) ** 0.5\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector and the x-axis\n    angle = math.degrees(math.atan2(dy, dx))\n\n    # Calculate the angle between the direction vector"
    },
    {
        "number": 2860,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, w = map(int, stdin.split())\n    lines = []\n    for _ in range(n):\n        line = input()\n        lines.append(line)\n    inscription = '\\n'.join(lines)\n    lines = inscription.split('\\n')\n    lines = [line.strip() for line in lines]\n    lines = [line.replace('.','') for line in lines]\n    lines = [line.replace(',','') for line in lines]\n    lines = [line.replace(':','') for line in lines]\n    lines = [line.replace(';','') for line in lines]\n    lines = [line.replace('!','') for line in lines]\n    lines = [line.replace('?','') for line in lines]\n    lines = [line.replace('(','') for line in lines]\n    lines = [line.replace(')','') for line in lines]\n    lines = [line.replace('[','') for line in lines]\n    lines = [line.replace(']','') for line in lines]\n    lines = [line.replace('{','') for line in lines]\n    lines = [line.replace('}','') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\",'') for line in lines]\n    lines = [line.replace('\"','') for line in lines]\n    lines = [line.replace(\"'\","
    },
    {
        "number": 2861,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R = int(stdin.strip())\n    quick_changes = 0\n    for _ in range(R):\n        routines = stdin.strip().split()\n        dancers = set()\n        for routine in routines:\n            for dancer in routine:\n                dancers.add(dancer)\n        if len(dancers) == 26:\n            quick_changes += 1\n    return str(quick_changes)"
    },
    {
        "number": 2862,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    materials = list(map(int, stdin.split()))\n    recipes = []\n    for _ in range(m):\n        u, v, w = map(int, stdin.split())\n        recipes.append((u, v, w))\n\n    def count_materials(materials, recipes):\n        count = [0] * 3\n        for u, v, w in recipes:\n            count[u] += w\n            count[v] += w\n        return count\n\n    def count_craftable_materials(materials, recipes):\n        count = [0] * 3\n        for u, v, w in recipes:\n            count[u] += w\n            count[v] += w\n        return count\n\n    def count_craftable_materials_helper(count, recipes):\n        if not recipes:\n            return count\n\n        u, v, w = recipes[0]\n        count[u] -= w\n        count[v] -= w\n\n        for i in range(1, len(recipes)):\n            u, v, w = recipes[i]\n            if count[u] >= w:\n                count[u] -= w\n                count[v] += w\n            else:\n                break\n\n        return count_craftable_materials_helper(count, recipes[1:])\n\n    count = count_materials(materials, recipes)\n    craftable_count = count_craftable_materials_helper(count, recipes)\n\n    return str(craftable_count[0]) +'' + str(craftable_count[1]) +'' + str(craftable_count[2]) +'' + str(craftable_count[3]) +'' + str(craftable_count[4])"
    },
    {
        "number": 2863,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    days = list(map(int, stdin.split()))\n\n    # Initialize a dictionary to store the preferences of each person\n    preferences = {}\n    for i in range(n):\n        preferences[i] = [0] * 1000000\n\n    # Initialize a list to store the days with the highest preference\n    max_days = []\n\n    # Iterate through the days and update the preferences\n    for day in days:\n        for i in range(n):\n            if preferences[i][day] == 0:\n                preferences[i][day] = 1\n                max_days.append(day)\n                break\n\n    # Calculate the maximal number of films they can watch\n    max_films = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if preferences[i][max_days[0]] == 0 and preferences[j][max_days[0]] == 0:\n                max_films += 1\n\n    return str(max_films)\n"
    },
    {
        "number": 2864,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    suggestions = []\n    for _ in range(n):\n        suggestion = input().strip()\n        suggestions.append(suggestion)\n\n    def get_card(card: str) -> int:\n        if card == '-':\n            return -1\n        elif card == '*':\n            return 1\n        else:\n            return int(card)\n\n    def get_player(player: int) -> int:\n        if player == 1:\n            return 4\n        else:\n            return player - 1\n\n    def get_evidence(player: int, suggestion: str) -> str:\n        if suggestion[player - 1] == '-':\n            return '-'\n        elif suggestion[player - 1] == '*':\n            return '*'\n        else:\n            return suggestion[player - 1]\n\n    def get_card_value(card: int) -> int:\n        if card == -1:\n            return 0\n        elif card == 1:\n            return 1\n        elif card == 2:\n            return 2\n        elif card == 3:\n            return 3\n        elif card == 4:\n            return 4\n        elif card == 5:\n            return 5\n        elif card == 6:\n            return 6\n        elif card == 7:\n            return 7\n        elif card == 8:\n            return 8\n        elif card == 9:\n            return 9\n        elif card == 10:\n            return 10\n        elif card == 11:\n            return 11\n        elif card == 12:\n            return 12\n        elif card == 13:\n            return 13\n        elif card == 14:\n            return 14\n        elif card == 15:\n            return 15\n        elif card == 16:\n            return 16\n        elif card == 17:\n            return 17\n        elif card == 18:\n            return 18\n        elif card == 19:\n            return 19\n        elif card == 20:\n            return 20\n        elif card == 21:\n            return 21\n        elif card == 22:\n            return 22\n        elif card == 23:\n            return 23\n        elif card == 24:\n            return 24\n        elif card == 25:\n            return 25\n        elif card == 26:\n            return 26\n        elif card == 27:\n            return 27\n        elif card == 28:\n            return 28\n        elif card == 29:\n            return 29\n        elif card == 30:\n            return 30\n        elif card == 31:\n            return 31\n        elif card == 32:\n            return 32\n        elif card == 33:\n            return 33\n        elif card == 34:\n            return 34\n        elif card == 35:\n            return 35\n        elif card == 36:\n            return 36\n        elif card == 37:\n            return 37\n        elif card == 38:\n            return 38\n        elif card == 39:\n            return 39\n        elif card == 40:\n            return 40\n        elif card == 41:\n            return 41\n        elif card == 42:\n            return 42\n        elif card == 43:\n            return 43\n        elif card == 44:\n            return 44\n        elif card == 45:\n            return 45\n        elif card == 46:\n            return 46\n        elif card == 47:\n            return 47\n        elif card == 48:\n            return 48\n        elif card == 49:\n            return 49\n        elif card == 50:\n            return 50\n\n    def get_card_name(card: int) -> str:\n        if card == -1:\n            return '?'\n        elif card == 1:\n            return 'A'\n        elif card == 2:\n            return 'B'\n        elif card == 3:\n            return 'C'\n        elif card == 4:\n            return 'D'\n        elif card == 5:\n            return 'E'\n        elif card == 6:\n            return 'F'\n        elif card == 7:\n            return 'G'\n        elif card == 8:\n            return 'H'\n        elif card == 9:\n            return 'I'\n        elif card == 10:\n            return 'J'\n        elif card == 11:\n            return 'K'\n        elif card == 12:\n            return 'L'\n        elif card == 13:\n            return 'M'\n        elif card == 14:\n            return '"
    },
    {
        "number": 2865,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    X1, X2 = map(int, stdin.split())\n    N1, T1 = map(int, stdin.split())\n    N2, T2 = map(int, stdin.split())\n\n    # Initialize the speeds\n    speeds = [0] * N1\n    speeds[0] = X1\n    speeds[1] = X2\n\n    # Initialize the collision times\n    collision_times = [0] * N1\n\n    # Initialize the collision flag\n    collision = False\n\n    # Loop through the speed changes\n    for i in range(1, N1):\n        # Check if the speed has changed\n        if speeds[i]!= speeds[i - 1]:\n            # Check if the speed has changed significantly\n            if abs(speeds[i] - speeds[i - 1]) > 1:\n                # Check if the speed has changed significantly in the positive direction\n                if abs(speeds[i] - speeds[i - 1]) > 1.5:\n                    # Check if the speed has changed significantly in the negative direction\n                    if abs(speeds[i] - speeds[i - 1]) > 1.5:\n                        # Check if the speed has changed significantly in the diagonal direction\n                        if abs(speeds[i] - speeds[i - 1]) > 2:\n                            # Check if the speed has changed significantly in the opposite direction\n                            if abs(speeds[i] - speeds[i - 1]) > 2:\n                                # Check if the speed has changed significantly in the opposite direction\n                                if abs(speeds[i] - speeds[i - 1]) > 2:\n                                    # Check if the speed has changed significantly in the opposite direction\n                                    if abs(speeds[i] - speeds[i - 1]) > 2:\n                                        # Check if the speed has changed significantly in the opposite direction\n                                        if abs(speeds[i] - speeds[i - 1]) > 2:\n                                            # Check if the speed has changed significantly in the opposite direction\n                                            if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                # Check if the speed has changed significantly in the opposite direction\n                                                if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                    # Check if the speed has changed significantly in the opposite direction\n                                                    if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                        # Check if the speed has changed significantly in the opposite direction\n                                                        if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                            # Check if the speed has changed significantly in the opposite direction\n                                                            if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                # Check if the speed has changed significantly in the opposite direction\n                                                                if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                    # Check if the speed has changed significantly in the opposite direction\n                                                                    if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                        # Check if the speed has changed significantly in the opposite direction\n                                                                        if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                            # Check if the speed has changed significantly in the opposite direction\n                                                                            if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                # Check if the speed has changed significantly in the opposite direction\n                                                                                if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                    # Check if the speed has changed significantly in the opposite direction\n                                                                                    if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                        # Check if the speed has changed significantly in the opposite direction\n                                                                                        if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                            # Check if the speed has changed significantly in the opposite direction\n                                                                                            if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                                # Check if the speed has changed significantly in the opposite direction\n                                                                                                if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                                    # Check if the speed has changed significantly in the opposite direction\n                                                                                                    if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                                        # Check if the speed has changed significantly in the opposite direction\n                                                                                                        if abs(speeds[i] - speeds[i - 1]) > 2:\n                                                                                                            # Check if the speed has changed significantly in the opposite direction\n                                                                                                            if abs("
    },
    {
        "number": 2866,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = list(map(int, stdin.split()))\n    n = len(digits)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if digits[i] + digits[j] not in digits:\n                return str(digits[i]) + str(digits[j])\n    return \"1\""
    },
    {
        "number": 2867,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *V, *C = map(int, stdin.split())\n    B = 0\n    for i in range(N):\n        if C[i] == 0:\n            continue\n        for j in range(i + 1, N + 1):\n            if C[j] == 0:\n                continue\n            if V[i] + V[j] <= 10**4:\n                B += V[i] + V[j]\n                break\n    return str(B)"
    },
    {
        "number": 2868,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, word = map(int, stdin.split())\n    original_word = word\n    for _ in range(X):\n        word = ''.join(sorted(word))\n        if word == original_word:\n            break\n    return word"
    },
    {
        "number": 2869,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    roman_numerals = {\n        'I': 1,\n        'II': 2,\n        'III': 3,\n        'IV': 4,\n        'V': 5,\n        'VI': 6,\n        'VII': 7,\n        'VIII': 8,\n        'IX': 9,\n        'X': 10,\n        'XX': 20,\n        'XXX': 30,\n        'XL': 40,\n        'L': 50,\n        'LX': 60,\n        'LXX': 70,\n        'LXXX': 80,\n        'XC': 90,\n    }\n\n    roman_numeral = ''\n    for char in stdin:\n        if char in roman_numerals:\n            roman_numeral += str(roman_numerals[char])\n        else:\n            roman_numeral += char\n\n    return roman_numeral"
    },
    {
        "number": 2870,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    happiness = 0\n    for i in range(p):\n        for j in range(q):\n            if i == 0 or j == 0 or i == p - 1 or j == q - 1:\n                happiness += 1\n    return str(happiness - 2)"
    },
    {
        "number": 2871,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    v = list(map(int, stdin.split()))\n\n    # Sort the players based on their skill\n    players = sorted(enumerate(v), key=lambda x: x[1])\n\n    # Calculate the number of minutes required to achieve the goal\n    minutes = 0\n    for i in range(K):\n        minutes += players[i][1]\n\n    return str(minutes)\n"
    },
    {
        "number": 2872,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, m = map(int, stdin.split())\n    day_of_week = m.upper()\n    if day_of_week == 'OCT':\n        if d == 10:\n            return ':)'\n        elif d == 2:\n            return ':('\n    elif day_of_week == 'JAN':\n        if d == 1:\n            return ':)'\n        elif d == 29:\n            return ':('\n    return ':('"
    },
    {
        "number": 2873,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    vowels = \"AEIOUaeiou\"\n    total_words = 0\n\n    for char in stdin:\n        if char == \"_\":\n            total_words += 1\n            for i in range(3):\n                if char in vowels:\n                    vowels.remove(char)\n                else:\n                    char = \"_\"\n                    break\n            if char in vowels:\n                vowels.remove(char)\n            else:\n                char = \"_\"\n                break\n\n    return str(total_words)\n"
    },
    {
        "number": 2874,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    people = list(map(int, stdin.split()))\n    trees = list(map(int, stdin.split()))\n\n    # Sort people and trees based on their positions\n    people.sort(key=lambda x: x)\n    trees.sort(key=lambda x: x)\n\n    # Initialize a dictionary to store the number of people who won't get a tree\n    won_trees = {}\n\n    # Iterate through the trees and count the number of people who won't get a tree\n    for i in range(m):\n        tree_pos = trees[i]\n        closest_people = [people[j] for j in range(n) if abs(people[j] - tree_pos) == 1]\n        won_trees[tree_pos] = len(closest_people)\n\n    # Return the number of people who won't get a tree\n    return str(won_trees.values().count(0))"
    },
    {
        "number": 2875,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    cards = list(map(int, stdin.readline().strip().split()))\n\n    # Sort the cards by their rarity\n    cards.sort(key=lambda x: (-x, x))\n\n    # Reverse the first batch of cards\n    cards[0] = cards[0][::-1]\n\n    # Check if the cards can be sorted by reversing exactly one contiguous subsequence\n    for i in range(1, n):\n        if cards[i]!= cards[i - 1][::-1]:\n            return \"impossible\"\n\n    # Find the start and end indices of the first batch of cards\n    start = 0\n    end = 0\n    for i in range(1, n):\n        if cards[i] == cards[i - 1][::-1]:\n            end += 1\n        else:\n            break\n\n    return f\"{start + 1} {end + 1}\""
    },
    {
        "number": 2876,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    x = list(map(int, stdin.readline().strip().split()))\n    z = float(stdin.readline().strip())\n\n    L = 10**-4\n    for i in range(N):\n        if abs(f(x[i]) - f(x[(i + 1) % N])) > L * abs(x[i] - x[(i + 1) % N]):\n            L = abs(f(x[i]) - f(x[(i + 1) % N]))\n\n    return str(L)\n\n\ndef"
    },
    {
        "number": 2877,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    word = stdin.strip()\n    if len(word) < 3 or len(word) > 50:\n        return \"Invalid input\"\n\n    # Split the word into three separate words\n    words = word.split()\n\n    # Reverse the order of the letters in each word\n    for i in range(len(words)):\n        words[i] = ''.join(reversed(words[i]))\n\n    # Combine the three words back together\n    result =''.join(words)\n\n    return result"
    },
    {
        "number": 2878,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    grid = []\n    for _ in range(n):\n        line = stdin.strip()\n        grid.append(line)\n\n    triplets = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if grid[i][j] == grid[i][k] == grid[j][k]:\n                    triplets += 1\n\n    return str(triplets)\n"
    },
    {
        "number": 2879,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split())\n    matrix = list(map(str, stdin.split()))\n\n    def is_valid(x, y):\n        return 0 <= x < h and 0 <= y < w and matrix[x][y] == '.'\n\n    def is_valid_power(x, y, k):\n        for i in range(k):\n            if not is_valid(x + i, y):\n                return False\n        return True\n\n    def is_valid_power_set(x, y, k):\n        for i in range(k):\n            for j in range(k):\n                if not is_valid(x + i, y + j):\n                    return False\n        return True\n\n    def solve(x, y, k):\n        if k == 1:\n            return [matrix[x][y]]\n        result = []\n        for i in range(k):\n            for j in range(k):\n                if is_valid_power(x + i, y + j, k):\n                    result.extend(solve(x + i, y + j, k - 1))\n        return result\n\n    if solve(0, 0, 2):\n        return '\\n'.join(map(str, solve(0, 0, 2)))\n    else:\n        return \"No solution\""
    },
    {
        "number": 2880,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    matrix = [list(input()) for _ in range(R)]\n\n    max_rows = 0\n    for i in range(R):\n        for j in range(C):\n            if matrix[i][j] == 'a':\n                max_rows = max(max_rows, i)\n\n    return str(max_rows)"
    },
    {
        "number": 2881,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = stdin.strip().split()\n    X = list(map(int, X))\n    Y = list(map(int, Y))\n\n    if len(X)!= len(Y):\n        return \"no\"\n\n    for i in range(len(X)):\n        if X[i]!= Y[i]:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 2882,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    result = []\n    for i in range(1, n+1):\n        for j in range(i):\n            left = j + 1\n            right = n - i + 1\n            if left > right:\n                continue\n            if left == right:\n                result.append(\"(\" + \")*\" + str(left) + \")\"\n            else:\n                result.append(\"(\" + \")*\" + str(left) + \")*\" + str(right) + \")\"\n    return \"\\n\".join(result)"
    },
    {
        "number": 2883,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.splitlines():\n        start, end = map(int, line.split())\n        intervals.append((start, end))\n    intervals.sort(key=lambda x: x[0])\n    result = []\n    for i in range(len(intervals)):\n        if i == 0 or intervals[i][0]!= intervals[i-1][1]:\n            result.append(intervals[i])\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 2884,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    candidates = list(map(int, stdin.split()))\n    target = int(stdin.split()[1])\n    result = []\n\n    def backtrack(start: int, path: List[int], current_sum: int) -> None:\n        if current_sum == target:\n            result.append(path[:])\n        elif current_sum < target:\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i - 1]:\n                    continue\n                path.append(candidates[i])\n                backtrack(i + 1, path, current_sum + candidates[i])\n                path.pop()\n\n    backtrack(0, [], 0)\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 2885,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    intervals = []\n    for line in stdin.splitlines():\n        start, end = map(int, line.split())\n        intervals.append([start, end])\n    new_interval = [int(x) for x in input().split()]\n    intervals = merge_intervals(intervals, new_interval)\n    return '\\n'.join(map(str, intervals))\n\ndef"
    },
    {
        "number": 2886,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    if len(s) < 2:\n        return \"-1 -1\"\n\n    unbalanced_substrings = []\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                unbalanced_substrings.append(s[i:j+1])\n\n    if len(unbalanced_substrings) == 0:\n        return \"-1 -1\"\n\n    max_length = max(len(s_substring) for s_substring in unbalanced_substrings)\n    max_count = max(1 for s_substring in unbalanced_substrings if len(s_substring) == max_length)\n\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            if s[i] == s[j]:\n                if len(s[i:j+1]) == max_length and len(set(s[i:j+1])) == max_count:\n                    return f\"{i} {j}\"\n\n    return \"-1 -1\""
    },
    {
        "number": 2887,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    volumes = list(map(int, stdin.strip().split()))\n    temperatures = list(map(int, stdin.strip().split()))\n\n    total_volume = 0\n    for i in range(n):\n        volume = volumes[i]\n        temperature = temperatures[i]\n        if temperature > 0:\n            total_volume += volume\n            if volume > 0:\n                volume -= temperature\n                if volume < 0:\n                    volume = 0\n            else:\n                volume = 0\n        else:\n            total_volume += volume\n\n    return str(total_volume)"
    },
    {
        "number": 2888,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Sin = map(int, stdin.split())\n    E = list(map(int, stdin.split()))\n\n    max_xv = 0\n    for i in range(1, N + 1):\n        strength = Sin * E[i - 1]\n        if i == 1:\n            max_xv = strength\n        else:\n            max_xv = max(max_xv, strength + (i - 1) * strength)\n\n    return str(max_xv)"
    },
    {
        "number": 2889,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    lawnmowers = []\n    for _ in range(m):\n        name, price, cutting_rate, cutting_time, recharge_time = map(int, stdin.split())\n        lawnmowers.append((name, price, cutting_rate, cutting_time, recharge_time))\n\n    def cutting_time(lawnmower):\n        return lawnmower[2] * lawnmower[3]\n\n    def recharge_time(lawnmower):\n        return lawnmower[3] * lawnmower[4]\n\n    def price(lawnmower):\n        return lawnmower[1]\n\n    def cutting_rate(lawnmower):\n        return lawnmower[2]\n\n    def cutting_time_average(lawnmowers):\n        return sum(cutting_time(lawnmower) for lawnmower in lawnmowers) / len(lawnmowers)\n\n    def recharge_time_average(lawnmowers):\n        return sum(recharge_time(lawnmower) for lawnmower in lawnmowers) / len(lawnmowers)\n\n    def price_average(lawnmowers):\n        return sum(price(lawnmower) for lawnmower in lawnmowers) / len(lawnmowers)\n\n    def cutting_time_average_per_week(lawnmowers):\n        return cutting_time_average(lawnmowers) / 10080\n\n    def recharge_time_average_per_week(lawnmowers):\n        return recharge_time_average(lawnmowers) / 10080\n\n    def price_average_per_week(lawnmowers):\n        return price_average(lawnmowers) / 10080\n\n    def cutting_time_average_per_week_per_mower(lawnmowers):\n        return [cutting_time_average_per_week(lawnmower) for lawnmower in lawnmowers]\n\n    def recharge_time_average_per_week_per_mower(lawnmowers):\n        return [recharge_time_average_per_week(lawnmower) for lawnmower in lawnmowers]\n\n    def price_average_per_week_per_mower(lawnmowers):\n        return [price_average_per_week(lawnmower) for lawnmower in lawnmowers]\n\n    def cutting_time_average_per_week_per_mower_average(lawnmowers):\n        return [cutting_time_average_per_week_per_mower(lawnmower) for lawnmower in lawnmowers]\n\n    def recharge_time_average_per_week_per_mower_average(lawnmowers):\n        return [recharge_time_average_per_week_per_mower(lawnmower) for lawnmower in lawnmowers]\n\n    def price_average_per_week_per_mower_average(lawnmowers):\n        return [price_average_per_week_per_mower(lawnmower) for lawnmower in lawnmowers]\n\n    def cheapest_lawnmower(lawnmowers):\n        cheapest_price = min(price(lawnmower) for lawnmower in lawnmowers)\n        cheapest_cutting_time = min(cutting_time(lawnmower) for lawnmower in lawnmowers)\n        cheapest_recharge_time = min(recharge_time(lawnmower) for lawnmower in lawnmowers)\n        cheapest_cutting_rate = min(cutting_rate(lawnmower) for lawnmower in lawnmowers)\n\n        for lawnmower in lawnmowers:\n            if price(lawnmower) == cheapest_price:\n                if cutting_time(lawnmower) == cheapest_cutting_time:\n                    if recharge_time(lawnmower) == cheapest_recharge_time:\n                        if cutting_rate(lawnmower) == cheapest_cutting_rate:\n                            return lawnmower[0]\n\n        return \"no such mower\"\n\n    cheapest_lawnmower_per_week = cutting_time_average_per_week_per_mower_average(lawnmowers)\n    cheapest_lawnmower_per_week_average = sum(cheapest_lawnmower_"
    },
    {
        "number": 2890,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, k_1, k_2 = map(int, stdin.split())\n    junctions = list(range(1, N+1))\n    red_tracks = [[] for _ in range(N)]\n    blue_tracks = [[] for _ in range(N)]\n    white_tracks = [[] for _ in range(N)]\n    for _ in range(M):\n        u, v, x, c = map(int, stdin.split())\n        if c == 0:\n            white_tracks[u-1].append((v-1, x))\n        elif c == 1:\n            red_tracks[u-1].append((v-1, x))\n        elif c == 2:\n            blue_tracks[u-1].append((v-1, x))\n    def min_time(start, end, red_tracks, blue_tracks, white_tracks):\n        if start == end:\n            return 0\n        if start in red_tracks[end-1]:\n            return min(min_time(start, end-1, red_tracks, blue_tracks, white_tracks), min_time(start+1, end, red_tracks, blue_tracks, white_tracks))\n        if start in blue_tracks[end-1]:\n            return min(min_time(start, end-1, red_tracks, blue_tracks, white_tracks), min_time(start+1, end, red_tracks, blue_tracks, white_tracks))\n        if start in white_tracks[end-1]:\n            return min(min_time(start, end-1, red_tracks, blue_tracks, white_tracks), min_time(start+1, end, red_tracks, blue_tracks, white_tracks))\n        return -1\n    start = junctions.index(S)\n    end = junctions.index(T)\n    if min_time(start, end, red_tracks, blue_tracks, white_tracks) == -1:\n        return -1\n    return min_time(start, end, red_tracks, blue_tracks, white_tracks)"
    },
    {
        "number": 2891,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *c = map(int, stdin.split())\n    b = 0\n    for i in range(n):\n        count = sum(c[i])\n        if count == 1:\n            b += 1\n        elif count == 2:\n            b += 0.5\n        else:\n            b += 0.25\n    return str(-math.log10(b))"
    },
    {
        "number": 2892,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    sizes = list(map(int, stdin.strip().split()))\n\n    # Check if the sizes are valid\n    for size in sizes:\n        if size < 1 or size > 500:\n            return \"impossible\"\n\n    # Reassemble the matryoshka sets\n    result = []\n    for i in range(n):\n        # Find the size of the current set\n        size = sizes[i]\n\n        # Reassemble the set\n        result.append(size)\n        for j in range(i + 1, n):\n            # Check if the current set can be combined with the next set\n            if j - i > 1 and sizes[j] - sizes[i] == 1:\n                # Combine the sets\n                result.append(sizes[i] + sizes[j])\n                result.append(sizes[i] + sizes[j] + sizes[i + 1])\n                result.append(sizes[i] + sizes[j] + sizes[i + 1] + sizes[j + 1])\n                break\n\n    # Check if reassembling is possible\n    if len(result) < n:\n        return \"impossible\"\n\n    # Calculate the minimum number of openings\n    min_openings = 0\n    for i in range(len(result) - 1):\n        if result[i] + result[i + 1] > result[i + 2]:\n            min_openings += 1\n\n    return str(min_openings)\n"
    },
    {
        "number": 2893,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    a = list(map(int, stdin.strip().split()))\n\n    def quicksort(arr, low, high):\n        if low < high:\n            pivot_index = partition(arr, low, high)\n            quicksort(arr, low, pivot_index - 1)\n            quicksort(arr, pivot_index + 1, high)\n\n    def partition(arr, low, high):\n        pivot = arr[high]\n        i = low - 1\n\n        for j in range(low, high):\n            if arr[j] <= pivot:\n                i += 1\n                arr[i], arr[j] = arr[j], arr[i]\n\n        arr[i + 1], arr[high] = arr[high], arr[i + 1]\n        return i + 1\n\n    quicksort(a, 0, n - 1)\n    op = n - 1\n\n    for i in range(n - 1):\n        if a[i] > a[i + 1]:\n            op -= 1\n\n    return str(op)\n"
    },
    {
        "number": 2894,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, K, T1, T2, H = map(float, stdin.split())\n    F1 = float('-inf')\n    F2 = float('-inf')\n\n    for i in range(T2):\n        if H > L:\n            F1 = min(F1, H - L)\n        else:\n            F2 = max(F2, H - L)\n\n        H += K\n\n    return f\"{F1:.6f} {F2:.6f}\""
    },
    {
        "number": 2895,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, x_f, y_f, n = map(float, stdin.split())\n    layers = []\n    for _ in range(n):\n        x, y = map(float, stdin.split())\n        layers.append((x, y))\n\n    speeds = []\n    for _ in range(n):\n        speed = map(float, stdin.split())\n        speeds.append(speed)\n\n    min_time = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            time = abs(layers[i][0] - layers[j][0]) + abs(layers[i][1] - layers[j][1])\n            min_time = min(min_time, time)\n\n    return str(min_time)\n"
    },
    {
        "number": 2896,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    before, after = stdin.strip().split()\n\n    # Convert DNA sequences to lists\n    before_list = list(before)\n    after_list = list(after)\n\n    # Initialize variables\n    min_length = float('inf')\n    current_length = 0\n\n    # Iterate through the sequences\n    for i in range(len(before_list)):\n        # Check if the current position is the same as the previous position\n        if before_list[i] == after_list[i]:\n            # If the current position is the same, check if the length of the current sequence is smaller than the previous one\n            current_length += 1\n            if current_length < min_length:\n                min_length = current_length\n        else:\n            # If the current position is different, reset the current length and start a new sequence\n            current_length = 1\n\n    # Return the minimum length\n    return str(min_length)\n"
    },
    {
        "number": 2897,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split())\n    map_data = []\n    for _ in range(r):\n        line = stdin.readline().strip()\n        map_data.append(line)\n\n    for _ in range(n):\n        query = map(int, stdin.readline().strip())\n        r1, c1, r2, c2 = query\n\n        if r1 == r2 and c1 == c2:\n            return \"neither\"\n        elif r1 == r2:\n            if c1 == c2:\n                return \"decimal\"\n            else:\n                return \"binary\"\n        else:\n            if c1 == c2:\n                return \"decimal\"\n            else:\n                return \"binary\""
    },
    {
        "number": 2898,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    extra_capacity = 0\n\n    for _ in range(n):\n        a, b = map(int, stdin.readline().split())\n        extra_capacity += a - b\n\n    return str(extra_capacity)\n"
    },
    {
        "number": 2899,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    frequencies = [int(stdin.readline().strip()) for _ in range(n)]\n\n    def dfs(node, frequencies, used_frequencies):\n        if node == n:\n            return used_frequencies\n\n        if node in used_frequencies:\n            return used_frequencies\n\n        used_frequencies.add(node)\n        frequencies[node] = min(frequencies[node], frequencies[used_frequencies.pop()])\n        return dfs(used_frequencies.pop(), frequencies, used_frequencies)\n\n    used_frequencies = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            frequencies[i] = min(frequencies[i], frequencies[j])\n            frequencies[j] = min(frequencies[j], frequencies[i])\n\n    return '\\n'.join(map(str, dfs(0, frequencies, used_frequencies)))"
    },
    {
        "number": 2900,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    count = [0] * (n - 1)\n    for i in range(n - 1):\n        if stdin[i] == 'B' and stdin[i + 1] == 'A':\n            count[i] += 1\n    for i in range(n - 2, -1, -1):\n        if stdin[i] == 'B' and stdin[i + 1] == 'A' and count[i] == 1:\n            count[i] += 1\n    for i in range(n - 2, -1, -1):\n        if stdin[i] == 'B' and stdin[i + 1] == 'A' and count[i] == 2:\n            count[i] += 1\n    for i in range(n - 2, -1, -1):\n        if stdin[i] == 'B' and stdin[i + 1] == 'A' and count[i] == 3:\n            count[i] += 1\n    return str(count[0]) + '\\n' + str(count[1]) + '\\n' + str(count[2]) + '\\n'"
    },
    {
        "number": 2901,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c = int(stdin.strip())\n    formation = []\n    for _ in range(c):\n        a, b = map(int, stdin.strip().split())\n        formation.append((a, b))\n\n    players = []\n    for _ in range(10):\n        player_name, nation, league, team = stdin.strip().split()\n        players.append((player_name, nation, league, team))\n\n    def is_perfect_team(formation):\n        for node in formation:\n            degree = sum(1 for link in formation if link[0] == node[0] or link[1] == node[0])\n            if degree < node[0]:\n                return False\n        return True\n\n    if is_perfect_team(formation):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 2902,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, N, M = map(int, stdin.split())\n    farms = [[] for _ in range(N)]\n    for i in range(N):\n        farms[i] = list(map(int, stdin.split()))\n\n    inspected_farms = 0\n    for i in range(M):\n        day = i + 1\n        for j in range(N):\n            if farms[j][i] > 0:\n                inspected_farms += 1\n                if inspected_farms > C:\n                    break\n                for k in range(i + 1, M):\n                    if farms[j][k] > 0:\n                        farms[j][k] -= 1\n                        break\n                if inspected_farms == C:\n                    break\n\n    return str(inspected_farms)"
    },
    {
        "number": 2903,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split())\n    a = [0] * N\n    for _ in range(Q):\n        op, delta = map(int, stdin.split())\n        if op == '+':\n            a[delta] += 1\n        elif op == '?':\n            a[0] += a[1] + a[2] + a[3] + a[4] + a[5] + a[6] + a[7] + a[8] + a[9] + a[10] + a[11] + a[12] + a[13] + a[14] + a[15] + a[16] + a[17] + a[18] + a[19] + a[20] + a[21] + a[22] + a[23] + a[24] + a[25] + a[26] + a[27] + a[28] + a[29] + a[30] + a[31] + a[32] + a[33] + a[34] + a[35] + a[36] + a[37] + a[38] + a[39] + a[40] + a[41] + a[42] + a[43] + a[44] + a[45] + a[46] + a[47] + a[48] + a[49] + a[50] + a[51] + a[52] + a[53] + a[54] + a[55] + a[56] + a[57] + a[58] + a[59] + a[60] + a[61] + a[62] + a[63] + a[64] + a[65] + a[66] + a[67] + a[68] + a[69] + a[70] + a[71] + a[72] + a[73] + a[74] + a[75] + a[76] + a[77] + a[78] + a[79] + a[80] + a[81] + a[82] + a[83] + a[84] + a[85] + a[86] + a[87] + a[88] + a[89] + a[90] + a[91] + a[92] + a[93] + a[94] + a[95] + a[96] + a[97] + a[98] + a[99] + a[100] + a[101] + a[102] + a[103] + a[104] + a[105] + a[106] + a[107] + a[108] + a[109] + a[110] + a[111] + a[112] + a[113] + a[114] + a[115] + a[116] + a[117] + a[118] + a[119] + a[120] + a[121] + a[122] + a[123] + a[124] + a[125] + a[126] + a[127] + a[128] + a[129] + a[130] + a[131] + a[132] + a[133] + a[134] + a[135] + a[136] + a[137] + a[138] + a[139] + a[140] + a[141] + a[142] + a[143] + a[144] + a[145] + a[146] + a[147] + a[148] + a[149] + a[150] + a[151] + a[152] +"
    },
    {
        "number": 2904,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    R, C = map(int, stdin.split())\n    grid = []\n    for _ in range(R):\n        grid.append(list(map(int, stdin.split())))\n\n    # Read regions\n    regions = []\n    for _ in range(int(stdin.split()[0])):\n        region = []\n        for _ in range(C):\n            region.append(tuple(map(int, stdin.split())))\n        regions.append(region)\n\n    # Solve puzzle\n    solution_grid = []\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == -1:\n                continue\n\n            # Check if cell is already filled\n            for k in range(i - 1, -1, -1):\n                for l in range(j - 1, -1, -1):\n                    if grid[k][l] == grid[i][j]:\n                        return \"No solution\"\n\n            # Check if cell is already filled in any region\n            for region in regions:\n                for cell in region:\n                    if grid[i][j] == cell[0] or grid[i][j] == cell[1] or grid[i][j] == cell[2]:\n                        return \"No solution\"\n\n            # Fill cell\n            solution_grid.append(grid[i][j])\n            for region in regions:\n                for cell in region:\n                    if grid[i][j] == cell[0] or grid[i][j] == cell[1] or grid[i][j] == cell[2]:\n                        grid[i][j] = -1\n                        break\n\n    # Print solution\n    for row in solution_grid:\n        print(\" \".join(map(str, row)))\n\n    return \"\\n\".join(map(str, solution_grid))"
    },
    {
        "number": 2905,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, B = map(int, stdin.split())\n    hotdog_packs = list(map(int, stdin.split()))\n    bun_packs = list(map(int, stdin.split()))\n\n    # Calculate the number of total packs needed\n    total_packs = H + B\n\n    # Calculate the number of hotdogs and buns needed\n    hotdogs = sum(hotdog_packs[:H])\n    buns = sum(bun_packs[:B])\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if hotdogs == buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_hotdogs = sum(hotdog_packs[:H])\n    total_buns = sum(bun_packs[:B])\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_hotdogs == total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate the number of total packs needed for hotdogs and buns\n    total_packs = total_hotdogs + total_buns\n\n    # Check if it's possible to purchase equal number of hotdogs and buns\n    if total_packs == total_hotdogs + total_buns:\n        return \"impossible\"\n\n    # Calculate"
    },
    {
        "number": 2906,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    targets = [0] * N\n    for _ in range(M):\n        A, B = map(int, stdin.split())\n        if A == B:\n            return \"Impossible\"\n        targets[A - 1] = B - 1\n    for i in range(N):\n        if targets[i] == 0:\n            return str(i + 1)\n    return \"Impossible\""
    },
    {
        "number": 2907,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    O, message, N = map(int, stdin.split())\n    vowels = 'aeiouy'\n    encoded_message = ''\n    for i in range(N):\n        encoded_message += message[i % len(message)]\n        if i % 2 == 0:\n            encoded_message = apply_rotation(encoded_message, O)\n    if len(vowels) > len(encoded_message) / 2:\n        return 'Colleague'\n    else:\n        return 'Boris'\n\ndef"
    },
    {
        "number": 2908,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    cards = []\n    for _ in range(n):\n        card = int(input())\n        cards.append(card)\n\n    def is_valid(card1, card2):\n        if card1 == card2:\n            return False\n        if card1 < card2:\n            card1, card2 = card2, card1\n        return card1 + card2 == s\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if is_valid(cards[i], cards[j]):\n                return \"YES\"\n\n    return \"NO\""
    },
    {
        "number": 2909,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    breads = list(map(int, stdin.strip().split()))\n    order = list(map(int, stdin.strip().split()))\n\n    # Sort the breads using the order prescribed by the boss\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            if breads[i] > breads[j]:\n                breads[i], breads[j] = breads[j], breads[i]\n\n    # Check if the breads can be sorted using the paddle trick\n    for i in range(n - 2):\n        if breads[i] == breads[i + 1] == breads[i + 2]:\n            return \"Possible\"\n\n    return \"Impossible\""
    },
    {
        "number": 2910,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    A = list(map(int, stdin.readline().strip().split()))\n    B = list(map(int, stdin.readline().strip().split()))\n\n    total_area = 0\n    for i in range(n):\n        for j in range(n):\n            if (i + j) % 3 == 0:\n                total_area += A[i] * B[j]\n\n    return str(total_area)"
    },
    {
        "number": 2911,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    p = 1 / (n * t)\n    p = (p + 1) // 2\n    return str(p * t ** n)"
    },
    {
        "number": 2912,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    operations = []\n    for _ in range(n - 1):\n        a, b = map(int, stdin.readline().split())\n        operations.append((a, b))\n\n    last_string = \"\"\n    for a, b in operations:\n        if b == \"\":\n            last_string = a\n        else:\n            last_string = a + b\n\n    return last_string"
    },
    {
        "number": 2913,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split())\n    grid = [[0] * n for _ in range(n)]\n    for _ in range(n):\n        grid[_][c] = 1\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n                grid[_][_], grid[c][_], grid[_][c] = grid[c][_], grid[_][c], grid[_][_]\n\n    for _ in range(n):\n        for _ in range(n):\n            if grid[_][_]:\n               "
    },
    {
        "number": 2914,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s, k = map(int, stdin.split())\n    if n < 1 or n > 10000 or k < 1 or k > s or s < 1 or s > 500:\n        return \"Invalid input\"\n\n    def roll_dice(n):\n        return [random.randint(1, s) for _ in range(n)]\n\n    def count_different_numbers(throws):\n        counts = Counter(roll_dice(throws))\n        return sum(counts.values()) >= k\n\n    def probability(throws, n):\n        return count_different_numbers(throws) / n\n\n    return str(probability(n, k))\n"
    },
    {
        "number": 2915,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    addresses = []\n    for _ in range(N):\n        x, t = map(int, stdin.split())\n        addresses.append((x, t))\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_distance(addresses):\n        distances = [distance(a, b) for a, b in zip(addresses, addresses[1:])]\n        return min(distances)\n\n    def min_total_distance(addresses):\n        total_distance = 0\n        for i in range(len(addresses)):\n            for j in range(i + 1, len(addresses)):\n                total_distance += min_distance((addresses[i], addresses[j]))\n        return total_distance\n\n    min_total_distance(addresses)\n    return str(min_total_distance(addresses))\n"
    },
    {
        "number": 2916,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    islands = []\n    for _ in range(N):\n        T, K = map(int, stdin.readline().strip().split())\n        islands.append((T, K))\n\n    def is_valid(i, j):\n        return 1 <= i <= N and 1 <= j <= N and i!= j\n\n    def is_valid_pair(i, j, s, v):\n        return 1 <= i <= N and 1 <= j <= N and s!= i and s!= j and v <= islands[s][0]\n\n    def count_islands(i, j):\n        count = 0\n        for s, v in islands:\n            if is_valid_pair(i, j, s, v):\n                count += 1\n        return count\n\n    def count_islands_surviving_collapses(i, j):\n        count = 0\n        for s, v in islands:\n            if is_valid_pair(i, j, s, v):\n                count += count_islands(s, j)\n        return count\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if count_islands_surviving_collapses(i, j) > 0:\n                return str(count_islands_surviving_collapses(i, j))\n\n    return \"0\""
    },
    {
        "number": 2917,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    return str(int(n * (n + 1) // 2))"
    },
    {
        "number": 2918,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    participants = list(map(int, stdin.strip().split()))\n    participants.sort()\n\n    # Check if there is a way to rig the game\n    for i in range(n):\n        for j in range(i+1, n):\n            if participants[i] == participants[j]:\n                return \"impossible\"\n\n    # Find the starting person\n    for i in range(n):\n        if participants[i] == 0:\n            starting_person = i\n            break\n\n    # Challenges the starting person\n    for i in range(n):\n        if participants[i] == 0:\n            participants[i] = starting_person\n            break\n\n    # Print the sequence\n    for i in range(n):\n        print(participants[i], end=\" \")"
    },
    {
        "number": 2919,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    output = \"\"\n    for instruction in stdin.splitlines():\n        if instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SSSTTSNTNST\"):\n            stack.append(int(instruction[1:]))\n        elif instruction.startswith(\"SS"
    },
    {
        "number": 2920,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    grid = []\n    for _ in range(n):\n        grid.append(list(stdin.strip()))\n\n    def dfs(x, y, visited, path):\n        if x == n - 1 and y == n - 1:\n            return True\n\n        if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] == '#' or visited[x][y]:\n            return False\n\n        visited[x][y] = True\n        path.append((x, y))\n\n        if dfs(x + 1, y, visited, path):\n            return True\n\n        if dfs(x - 1, y, visited, path):\n            return True\n\n        if dfs(x, y + 1, visited, path):\n            return True\n\n        if dfs(x, y - 1, visited, path):\n            return True\n\n        visited[x][y] = False\n        path.pop()\n        return False\n\n    def count_paths(s, t):\n        visited = [[False] * n for _ in range(n)]\n        path = []\n\n        if dfs(s[0], s[1], visited, path):\n            return 1\n\n        return 0\n\n    return str(count_paths(grid, (n - 1, n - 1)))"
    },
    {
        "number": 2921,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, u, d = map(float, stdin.split())\n    drinks = []\n    for _ in range(d):\n        name, strength, price, cost = map(str.lower, stdin.split())\n        strength = float(strength)\n        cost = float(cost)\n        drinks.append((name, strength, price, cost))\n\n    def calculate_total_cost(drinks):\n        total_cost = 0\n        for drink in drinks:\n            total_cost += drink[3]\n        return total_cost\n\n    def calculate_remaining_amount(total_cost, u):\n        remaining_amount = total_cost - u\n        return remaining_amount\n\n    def calculate_remaining_units(remaining_amount, strength):\n        remaining_units = remaining_amount / strength\n        return remaining_units\n\n    def calculate_remaining_drinks(remaining_units, d):\n        remaining_drinks = remaining_units / d\n        return remaining_drinks\n\n    def calculate_remaining_amount_for_drink(remaining_drinks, drink):\n        remaining_amount = remaining_drinks * drink[2]\n        return remaining_amount\n\n    def calculate_remaining_units_for_drink(remaining_amount, drink):\n        remaining_units = remaining_amount / drink[2]\n        return remaining_units\n\n    def calculate_remaining_drinks_for_drink(remaining_units, drink):\n        remaining_drinks = remaining_units / drink[2]\n        return remaining_drinks\n\n    def calculate_remaining_amount_for_drinks(remaining_drinks, drinks):\n        remaining_amount = 0\n        for drink in drinks:\n            remaining_amount += calculate_remaining_amount_for_drink(remaining_drinks, drink)\n        return remaining_amount\n\n    def calculate_remaining_units_for_drinks(remaining_amount, drinks):\n        remaining_units = 0\n        for drink in drinks:\n            remaining_units += calculate_remaining_units_for_drink(remaining_amount, drink)\n        return remaining_units\n\n    def calculate_remaining_drinks_for_drinks(remaining_units, drinks):\n        remaining_drinks = 0\n        for drink in drinks:\n            remaining_drinks += calculate_remaining_drinks_for_drink(remaining_units, drink)\n        return remaining_drinks\n\n    def calculate_remaining_amount_for_drinks_and_total(remaining_drinks, drinks):\n        remaining_amount = calculate_remaining_amount_for_drinks(remaining_drinks, drinks)\n        return remaining_amount\n\n    def calculate_remaining_units_for_drinks_and_total(remaining_amount, drinks):\n        remaining_units = calculate_remaining_units_for_drinks(remaining_amount, drinks)\n        return remaining_units\n\n    def calculate_remaining_drinks_for_drinks_and_total(remaining_units, drinks):\n        remaining_drinks = calculate_remaining_drinks_for_drinks(remaining_units, drinks)\n        return remaining_drinks\n\n    def calculate_remaining_amount_for_drinks_and_total_and_name(remaining_drinks, drinks):\n        remaining_amount = calculate_remaining_amount_for_drinks_and_total(remaining_drinks, drinks)\n        return remaining_amount\n\n    def calculate_remaining_units_for_drinks_and_total_and_name(remaining_amount, drinks):\n        remaining_units = calculate_remaining_units_for_drinks_and_total(remaining_amount, drinks)\n        return remaining_units\n\n    def calculate_remaining_drinks_for_drinks_and_total_and_name(remaining_units, drinks):\n        remaining_drinks = calculate_remaining_drinks_for_drinks_and_total(remaining_units, drinks)\n        return remaining_drinks\n\n    def calculate_remaining_amount_for_drinks_and_total_and_name_and_strength(remaining_drinks, drinks):\n        remaining_amount = calculate_remaining_amount_for_drinks_and_total_and_name(remaining_drinks, drinks)\n        return remaining_amount\n\n    def calculate_remaining_units_for_drinks_and_total_and_name_and_strength(remaining_amount, drinks):\n        remaining_units = calculate_remaining_units_for_drinks_and_total_and_name(remaining_amount, drinks)\n        return remaining_units\n\n    def calculate_remaining_drinks_for_drinks_and_total_and_name_and_strength(remaining_"
    },
    {
        "number": 2922,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    boxes = [int(stdin.readline().strip()) for _ in range(n)]\n\n    if sum(boxes) % 2 == 0:\n        return \"NO\"\n\n    for i in range(n):\n        if boxes[i] % 2 == 0:\n            return \"NO\"\n\n    return \"YES\""
    },
    {
        "number": 2923,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h = map(int, stdin.split())\n    king_a = [0] * w\n    king_b = [0] * w\n    for i in range(h):\n        line = stdin.split()\n        for j in range(w):\n            if line[j] == 'A':\n                king_a[j] = int(line[j + 1])\n            elif line[j] == 'B':\n                king_b[j] = int(line[j + 1])\n\n    def is_valid(x, y):\n        return 0 <= x < w and 0 <= y < h and king_a[x] == 0 and king_b[y] == 0\n\n    def dfs(x, y, steps):\n        if steps == 0:\n            return True\n        if is_valid(x, y):\n            king_a[x] += steps\n            king_b[y] += steps\n            if dfs(x + 1, y, steps - 1):\n                return True\n            if dfs(x - 1, y, steps - 1):\n                return True\n            if dfs(x, y + 1, steps - 1):\n                return True\n            if dfs(x, y - 1, steps - 1):\n                return True\n            king_a[x] -= steps\n            king_b[y] -= steps\n            return False\n        return False\n\n    steps = 0\n    while not dfs(0, 0, steps):\n        steps += 1\n\n    return steps"
    },
    {
        "number": 2924,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, P = map(int, stdin.split())\n    gears = [[] for _ in range(N)]\n    for i in range(N):\n        gears[i] = list(map(int, stdin.split()))\n\n    max_change = 0\n    for i in range(N):\n        for j in range(M):\n            if gears[i][j] > gears[i][j + 1]:\n                max_change = max(max_change, gears[i][j] - gears[i][j + 1])\n\n    if max_change <= P:\n        return \"Ride on!\"\n    else:\n        return \"Cannot change gears!\""
    },
    {
        "number": 2925,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    songs = []\n    for _ in range(n):\n        name, quality = stdin.strip().split()\n        songs.append((name, quality))\n\n    songs.sort(key=lambda x: (-float(x[1]), x[0]))\n    return '\\n'.join(songs[:m])"
    },
    {
        "number": 2926,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    categories = []\n    for _ in range(N):\n        category = input().strip()\n        categories.append(category)\n\n    statement = input().strip()\n    words = statement.split()\n\n    matches = {}\n    for category in categories:\n        category_words = set(words)\n        category_words.remove(category)\n        category_words = sorted(category_words)\n        matches[category] = len(category_words)\n\n    max_matches = max(matches.values())\n    max_category = max(matches, key=matches.get)\n\n    output = [max_category]\n    for category in categories:\n        if matches[category] == max_matches:\n            output.append(category)\n\n    return '\\n'.join(output)\n"
    },
    {
        "number": 2927,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    plays = []\n    for _ in range(N):\n        play = list(map(int, stdin.strip().split()))\n        plays.append(play)\n\n    touchdown = False\n    safety = False\n    for play in plays:\n        if play[0] > 0:\n            if play[0] >= 80:\n                touchdown = True\n            else:\n                safety = True\n        else:\n            if play[0] >= 20:\n                safety = True\n\n    if touchdown:\n        return \"Touchdown\"\n    elif safety:\n        return \"Safety\"\n    else:\n        return \"Nothing\""
    },
    {
        "number": 2928,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, P, F = map(int, stdin.split())\n    tax_bands = []\n    for i in range(B):\n        s, p = map(float, stdin.split())\n        tax_bands.append((s, p))\n\n    def tax_amount(income, tax_band):\n        lower_bound, upper_bound = tax_band\n        return (income - lower_bound) * (1 - p) + lower_bound\n\n    def calculate_tax(income, tax_bands):\n        total_income = sum(income)\n        tax_amounts = [tax_amount(income, tax_band) for tax_band in tax_bands]\n        return sum(tax_amounts)\n\n    def calculate_friend_amount(friend_amount, tax_amount):\n        return friend_amount + tax_amount\n\n    friends_amounts = []\n    for i in range(F):\n        e, m = map(float, stdin.split())\n        friends_amounts.append((e, m))\n\n    for i in range(F):\n        for j in range(i + 1, F):\n            tax_amount = calculate_tax(friends_amounts[i], tax_bands)\n            friend_amount = calculate_friend_amount(friends_amounts[j], tax_amount)\n            friends_amounts[j] = friend_amount\n\n    for i in range(F):\n        print(friends_amounts[i])"
    },
    {
        "number": 2929,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    cave = []\n    for _ in range(N):\n        row = list(map(int, stdin.readline().strip()))\n        cave.append(row)\n\n    def dfs(i, j, depth):\n        if i == N - 1 and j == N - 1:\n            return 0\n        if i < 0 or i >= N or j < 0 or j >= N or cave[i][j] < 1:\n            return 0\n        if cave[i][j] > depth:\n            return 0\n        if i == 0 and j == 0:\n            return 1\n        return dfs(i - 1, j, depth + 1) + dfs(i + 1, j, depth + 1) + dfs(i, j - 1, depth + 1) + dfs(i, j + 1, depth + 1)\n\n    return str(dfs(0, 0, 1))"
    },
    {
        "number": 2930,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    zigzag_sequences = []\n    for _ in range(n):\n        sequence = list(map(int, input().split()))\n        zigzag_sequences.append(sequence)\n\n    longest_sequence = max(zigzag_sequences, key=len)\n    return len(longest_sequence)"
    },
    {
        "number": 2931,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    scores = []\n    for _ in range(N):\n        a, b = map(int, stdin.strip().split())\n        scores.append((a, b))\n\n    scores.sort(key=lambda x: x[0] + x[1])\n    highest = scores[0][0]\n    lowest = scores[0][1]\n\n    for i in range(1, len(scores)):\n        if scores[i][0] + scores[i][1] > highest:\n            highest = scores[i][0] + scores[i][1]\n        if scores[i][0] + scores[i][1] < lowest:\n            lowest = scores[i][0] + scores[i][1]\n\n    return f\"{highest} {lowest}\""
    },
    {
        "number": 2932,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, k = stdin.strip().split()\n    s = list(s)\n    n = len(s)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if abs(i - j) >= k:\n                s[i], s[j] = s[j], s[i]\n    return 'Yes' if s == sorted(s) else 'No'"
    },
    {
        "number": 2933,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    plates = list(map(int, stdin.strip().split()))\n    plates.sort()\n    closest_weight = plates[0]\n    for i in range(1, n):\n        if plates[i] - closest_weight > 1000:\n            closest_weight = plates[i]\n    return str(closest_weight)"
    },
    {
        "number": 2934,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_tilings(n: int, m: int) -> int:\n        if n == 1 and m == 1:\n            return 1\n        if n == 1 and m == 2:\n            return 2\n        if n == 2 and m == 1:\n            return 2\n        if n == 2 and m == 2:\n            return 4\n\n        return count_tilings(n - 1, m) + count_tilings(n, m - 1)\n\n    return str(count_tilings(N, M))"
    },
    {
        "number": 2935,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, f, s, t = map(int, stdin.split())\n    roads = []\n    flights = []\n    for _ in range(m):\n        i, j, c = map(int, stdin.split())\n        roads.append((i, j, c))\n    for _ in range(f):\n        u, v = map(int, stdin.split())\n        flights.append((u, v))\n    min_cost = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_cost = min(min_cost, roads[i][2] + roads[j][2])\n    for u, v in flights:\n        min_cost = min(min_cost, roads[u][2] + roads[v][2])\n    return str(min_cost)"
    },
    {
        "number": 2936,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    A = list(map(int, stdin.split()))\n\n    def max_subarray_sum(A, start, end):\n        if start == end:\n            return A[start]\n\n        max_left = float('-inf')\n        max_right = float('-inf')\n\n        for i in range(start, end):\n            max_left = max(max_left, A[i])\n            max_right = max(max_right, A[i])\n\n        return max(max_left, max_right)\n\n    def max_subarray_sum_k(A, start, end, k):\n        if start == end:\n            return A[start]\n\n        max_left = float('-inf')\n        max_right = float('-inf')\n\n        for i in range(start, end):\n            max_left = max(max_left, A[i])\n            max_right = max(max_right, A[i])\n\n        return max(max_left, max_right)\n\n    max_sum = float('-inf')\n    for i in range(n):\n        for j in range(i, n):\n            if j - i + 1 >= k:\n                max_sum = max(max_sum, max_subarray_sum_k(A, i, j, k))\n\n    return str(max_sum)\n"
    },
    {
        "number": 2937,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, c = map(int, stdin.split())\n    kids = []\n    for _ in range(k):\n        name = input()\n        kids.append(name)\n\n    enemies = set()\n    for _ in range(k):\n        name1, name2 = input().split()\n        enemies.add(name1)\n        enemies.add(name2)\n\n    groups = []\n    for i in range(n):\n        group = []\n        for j in range(k):\n            if i < kids[j]:\n                group.append(kids[j])\n        groups.append(group)\n\n    min_groups = min(len(group) for group in groups)\n    for group in groups:\n        group.sort()\n        print(' '.join(group))\n\n    return str(min_groups)\n"
    },
    {
        "number": 2938,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    board = stdin.strip().split('\\n')\n    \n    # Initialize variables\n    king_count = 0\n    rook_count = 0\n    king_threatened = False\n    rook_threatened = False\n    \n    # Iterate through the board\n    for row in board:\n        for col in row:\n            # Check if the square is empty\n            if col == '.':\n                # Check if the king is threatened\n                if col == 'K':\n                    king_threatened = True\n                # Check if the rook is threatened\n                elif col == 'R':\n                    rook_threatened = True\n                # Check if the king is in check\n                elif col == 'k':\n                    king_count += 1\n                # Check if the rook is in check\n                elif col == 'r':\n                    rook_count += 1\n                \n    # Check if the king is threatened\n    if king_threatened:\n        return \"No\"\n    # Check if the rook is threatened\n    elif rook_threatened:\n        return \"No\"\n    # Check if the king is in check\n    elif king_count == 1:\n        return \"No\"\n    # Check if the rook is in check\n    elif rook_count == 1:\n        return \"No\"\n    # Check if the king is threatened and the rook is in check\n    elif king_threatened and rook_count == 1:\n        return \"No\"\n    # Check if the king is in check and the rook is threatened\n    elif king_count == 1 and rook_threatened:\n        return \"No\"\n    # Check if the king is threatened and the rook is threatened\n    elif king_threatened and rook_threatened:\n        return \"No\"\n    # Check if the king is in check and the rook is in check\n    elif king_count == 1 and rook_count == 1:\n        return \"No\"\n    # Check if the king is threatened and the rook is threatened and the rook is in check\n    elif king_threatened and rook_threatened and rook_count == 1:\n        return \"No\"\n    # Check if the king is in check and the rook is in check and the rook is threatened\n    elif king_count == 1 and rook_count == 1 and rook_threatened:\n        return \"No\"\n    # Check if the king is threatened and the rook is threatened and the rook is in check and the rook is threatened\n    elif king_threatened and rook_threatened and rook_count == 1 and rook_threatened:\n        return \"No\"\n    # Check if the king is in check and the rook is in check and the rook is threatened and the rook is threatened\n    elif king_count == 1 and rook_count == 1 and rook_threatened and rook_threatened:\n        return \"No\"\n    # Check if the king is threatened and the rook is threatened and the rook is in check and the rook is threatened and the rook is in check\n    elif king_threatened and rook_threatened and rook_count == 1 and rook_threatened and rook_count == 1:\n        return \"No\"\n    # Check if the king is in check and the rook is in check and the rook is threatened and the rook is threatened and the rook is in check and the rook is threatened\n    elif king_count == 1 and rook_count == 1 and rook_threatened and rook_threatened and rook_count == 1 and rook_threatened:\n        return \"No\"\n    # Check if the king is threatened and the rook is threatened and the rook is in check and the rook is threatened and the rook is in check and the rook is threatened\n    elif king_threatened and rook_threatened and rook_count == 1 and rook_threatened and rook_count == 1 and rook_threatened:\n        return \"No\"\n    # Check if the king is in check and the rook is in check and the rook is threatened and the rook is threatened and the rook is in check and the rook is threatened and the rook is in check\n    elif king_count == 1 and rook_count == 1 and rook_threatened and rook_threatened and rook_count == 1 and rook_threatened and rook_count == 1:\n        return \"No\"\n    # Check if the king is threatened and the rook is threatened and"
    },
    {
        "number": 2939,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    grid = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            grid[i][j] = int(stdin.readline().strip())\n\n    def dfs(i: int, j: int, d: int) -> int:\n        if i < 0 or i >= n or j < 0 or j >= n or grid[i][j] == 0:\n            return d\n\n        if i == 0 or j == 0 or i == n - 1 or j == n - 1:\n            return d\n\n        if i > 0 and grid[i - 1][j] == 3:\n            return dfs(i - 1, j, d + 1)\n\n        if j > 0 and grid[i][j - 1] == 3:\n            return dfs(i, j - 1, d + 1)\n\n        if i < n - 1 and grid[i + 1][j] == 3:\n            return dfs(i + 1, j, d + 1)\n\n        if j < n - 1 and grid[i][j + 1] == 3:\n            return dfs(i, j + 1, d + 1)\n\n        return d\n\n    d = dfs(0, 0, 0)\n    return str(d)"
    },
    {
        "number": 2940,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    recipes = []\n    for _ in range(N):\n        recipe = list(map(int, stdin.strip().split()))\n        recipes.append(recipe)\n\n    def is_concoctable(recipe):\n        ingredients = set(recipe[:recipe.index(1)])\n        for i in range(1, recipe.index(1) + 1):\n            if recipe[i] not in ingredients:\n                return False\n        return True\n\n    def concoct_potion(recipe):\n        ingredients = set(recipe[:recipe.index(1)])\n        for i in range(1, recipe.index(1) + 1):\n            recipe[i] = 0\n        recipe[recipe.index(1)] = 1\n        return recipe\n\n    def concoct_potions(recipes):\n        concocted_recipes = []\n        for recipe in recipes:\n            if is_concoctable(recipe):\n                concocted_recipes.append(concoct_potion(recipe))\n            else:\n                concocted_recipes.append(recipe)\n        return concocted_recipes\n\n    recipes = concoct_potions(recipes)\n    return str(len(recipes))"
    },
    {
        "number": 2941,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    clinic = []\n    for _ in range(n):\n        arrival_time, name, severity = map(int, stdin.split())\n        clinic.append((arrival_time, name, severity))\n\n    def process_arrival(arrival_time, name, severity):\n        priority_sum = sum(severity + k * waiting_time for waiting_time, _, _ in clinic if waiting_time <= arrival_time)\n        patient_with_highest_priority = max(clinic, key=lambda x: x[0])\n        return patient_with_highest_priority[1]\n\n    def process_notification(arrival_time, name, severity):\n        for patient, waiting_time, _ in clinic:\n            if waiting_time <= arrival_time:\n                return patient\n        return \"doctor takes a break\"\n\n    for _ in range(k):\n        T, M, S = map(int, stdin.split())\n        if T == 1:\n            patient_name = process_arrival(T, M, S)\n            print(patient_name)\n        elif T == 2:\n            process_notification(T, M, S)\n        else:\n            break\n\n    return \"doctor takes a break\""
    },
    {
        "number": 2942,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D = int(stdin.strip())\n    n = 0\n    while n < D:\n        n += 1\n    n_1 = n\n    while n < 2 * D:\n        n += 1\n    n_2 = n\n    while n < 3 * D:\n        n += 1\n    if n_2 ** 2 - n_1 ** 2 == D:\n        return f\"{n_1} {n_2}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2943,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    raindrops = list(stdin.strip())\n    raindrops = [int(x) for x in raindrops]\n\n    # Count the number of R and B drops in each section\n    red_count = [0] * n\n    blue_count = [0] * n\n    for i in range(n):\n        if raindrops[i] == 1:\n            red_count[i] += 1\n        else:\n            blue_count[i] += 1\n\n    # Find the subsequence with the least difference between R and B\n    subsequence = []\n    for i in range(n):\n        if red_count[i] > blue_count[i]:\n            subsequence.append(i)\n        elif red_count[i] < blue_count[i]:\n            subsequence.append(i + 1)\n\n    # Find the starting and ending positions of the part of Linearland that had the least purple rain\n    start = subsequence[0]\n    end = subsequence[-1]\n    for i in range(start, end):\n        if raindrops[i] == 1:\n            start = i\n            break\n    for i in range(end - 1, start - 1, -1):\n        if raindrops[i] == 1:\n            end = i\n            break\n\n    return f\"{start} {end}\""
    },
    {
        "number": 2944,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split())\n    people = set()\n    connections = set()\n    rumor = \"\"\n\n    for _ in range(n):\n        name, level = stdin.split()\n        people.add(name)\n        connections.add((name, level))\n\n    for _ in range(m):\n        u, v = stdin.split()\n        connections.add((u, v))\n\n    rumor = stdin.split()[0]\n\n    for _ in range(d):\n        for name in people:\n            if name!= rumor:\n                people.remove(name)\n\n    return len(people)"
    },
    {
        "number": 2945,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N, M = map(int, stdin.split())\n    time_first_type = [0] * N\n    time_second_type = [0] * M\n\n    for _ in range(T):\n        A_k, B_k = map(int, stdin.split())\n        time_first_type[0] += A_k\n        time_second_type[0] += B_k\n\n    for _ in range(N):\n        A_k, B_k = map(int, stdin.split())\n        time_first_type[0] += A_k\n        time_second_type[0] += B_k\n\n    for _ in range(M):\n        C_k, D_k = map(int, stdin.split())\n        time_first_type[0] += C_k\n        time_second_type[0] += D_k\n\n    for _ in range(N):\n        A_k, B_k = map(int, stdin.split())\n        time_first_type[0] += A_k\n        time_second_type[0] += B_k\n\n    for _ in range(M):\n        C_k, D_k = map(int, stdin.split())\n        time_first_type[0] += C_k\n        time_second_type[0] += D_k\n\n    return str(time_first_type[0] - time_second_type[0])\n"
    },
    {
        "number": 2946,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    prices = list(map(int, stdin.split()))\n\n    max_profit = 0\n    for i in range(N):\n        if i > 0:\n            max_profit = max(max_profit, prices[i] - prices[i-1])\n\n    if max_profit < 0:\n        return \"0\"\n\n    return str(max_profit)"
    },
    {
        "number": 2947,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    proofs = []\n\n    for _ in range(n - 1):\n        p, q, r = map(int, stdin.strip().split())\n        proofs.append((p, q, r))\n\n    for p, q, r in proofs:\n        if p == q or q == r or p == r:\n            return \"impossible\"\n\n    return \"\\n\".join(map(str, proofs))"
    },
    {
        "number": 2948,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    parties = ['A', 'B']\n    result = []\n\n    for _ in range(N):\n        P = int(stdin.strip())\n        pairs = []\n        for _ in range(P):\n            pair = list(map(int, stdin.strip().split()))\n            pairs.append(pair)\n\n        for pair in pairs:\n            if len(set(pair))!= 2:\n                continue\n            if pair[0] == pair[1]:\n                result.append(parties[pair[0]])\n                result.append(parties[pair[1]])\n                break\n\n    return ''.join(result)"
    },
    {
        "number": 2949,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    line_segments = []\n\n    for _ in range(n):\n        x1, y1, a1 = map(int, stdin.strip().split())\n        x2, y2, a2 = map(int, stdin.strip().split())\n\n        if a1 == 1:\n            line_segments.append((x1, y1, x2, y2))\n        elif a1 == 2:\n            line_segments.append((x1, y1, x2, y2))\n            line_segments.append((x2, y2, x1, y1))\n\n    max_line_segments = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if line_segments[i][0] == line_segments[j][0]:\n                if line_segments[i][1] == line_segments[j][1]:\n                    if line_segments[i][2] == line_segments[j][2]:\n                        if line_segments[i][3] == line_segments[j][3]:\n                            max_line_segments += 1\n\n    return str(max_line_segments)\n"
    },
    {
        "number": 2950,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    h = list(map(int, stdin.strip().split()))\n\n    # Calculate the number of charges needed to tear down all the blocks\n    charges = 0\n    for i in range(n):\n        charges += h[i]\n\n    return str(charges)"
    },
    {
        "number": 2951,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    matches = set()\n    for _ in range(N):\n        a, b = map(int, stdin.readline().strip().split())\n        matches.add((a, b))\n    return str(len(matches))"
    },
    {
        "number": 2952,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, a, b, c = map(int, stdin.split())\n    if a == 0 and b == 0 and c == 0:\n        return \"impossible\"\n    if a == 0 or b == 0 or c == 0:\n        return \"possible\"\n    return \"impossible\""
    },
    {
        "number": 2953,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    points = []\n    for _ in range(n):\n        x1, y1 = map(int, stdin.strip().split())\n        x2, y2 = map(int, stdin.strip().split())\n        points.append((x1, y1, x2, y2))\n\n    count = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dx = points[j][0] - points[i][0]\n            dy = points[j][1] - points[i][1]\n            if dx == 0 and dy == 0:\n                continue\n            if dx == 0:\n                dy = -dy\n            if dy == 0:\n                dx = -dx\n            if dx > 0 and dy > 0:\n                count += 1\n            elif dx < 0 and dy > 0:\n                count += 1\n            elif dx > 0 and dy < 0:\n                count += 1\n            elif dx < 0 and dy < 0:\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 2954,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, T = map(int, stdin.split())\n    roads = []\n    for _ in range(M):\n        u, v, d = map(int, stdin.split())\n        roads.append((u, v, d))\n\n    s, t = map(int, stdin.split())\n    spider_locations = []\n    for _ in range(K):\n        a = map(int, stdin.split())\n        spider_locations.append(a)\n\n    D = float('inf')\n    for u in range(N):\n        for v in range(u + 1, N):\n            if u == v:\n                continue\n            for road in roads:\n                if road[0] == u and road[1] == v:\n                    D = min(D, road[2])\n                    break\n\n    return str(D)\n"
    },
    {
        "number": 2955,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, b = map(int, stdin.split())\n    z = list(map(int, stdin.split()))\n\n    def count_bit_changes(bit_string):\n        count = 0\n        for i in range(len(bit_string)):\n            if bit_string[i] == '1':\n                count += 1\n            if i > 0 and bit_string[i] == bit_string[i - 1]:\n                count += 1\n            if i > 1 and bit_string[i] == bit_string[i - 2]:\n                count += 1\n        return count\n\n    def find_bit_pattern(bit_string):\n        for i in range(len(bit_string)):\n            for j in range(i + 1, len(bit_string)):\n                if bit_string[i] == bit_string[j]:\n                    return bit_string[i] * bit_string[j]\n        return None\n\n    bit_string = ''.join(['0' if i in z else '1' for i in range(n)])\n    bit_string = bit_string.zfill(n)\n\n    bit_changes = count_bit_changes(bit_string)\n    if bit_changes == c:\n        return bit_string\n\n    bit_pattern = find_bit_pattern(bit_string)\n    if bit_pattern is not None:\n        return bit_pattern\n\n    return 'No solution found'\n"
    },
    {
        "number": 2956,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    turn_sequence = stdin.strip()\n    count = 0\n    for i in range(len(turn_sequence)):\n        if turn_sequence[i] == '?':\n            count += 1\n            if i > 0 and turn_sequence[i - 1] == 'L':\n                count += 1\n            if i < len(turn_sequence) - 1 and turn_sequence[i + 1] == 'R':\n                count += 1\n            if i > 0 and i < len(turn_sequence) - 1 and turn_sequence[i - 1] == 'S':\n                count += 1\n            if i > 0 and i < len(turn_sequence) - 1 and turn_sequence[i + 1] == 'A':\n                count += 1\n    return str(count)"
    },
    {
        "number": 2957,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, K = map(int, stdin.split())\n    graph = [[0] * n for _ in range(n)]\n    for _ in range(n - 1):\n        a, b = map(int, stdin.split())\n        graph[a][b] = 1\n        graph[b][a] = 1\n\n    def dfs(node, parent, path):\n        if node == n - 1:\n            return path\n        if graph[node][node] == 0:\n            return dfs(node + 1, node, path + [node])\n        for neighbor in range(n):\n            if graph[node][neighbor] == 1 and neighbor!= node and neighbor!= parent:\n                return dfs(neighbor, node, path + [neighbor])\n        return dfs(node + 1, node, path + [node])\n\n    path = dfs(0, -1, [])\n    return str(min(path))\n"
    },
    {
        "number": 2958,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T, K = map(int, stdin.split())\n    cards = list(map(int, stdin.split()))\n\n    def max_profit(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_buy(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, min_price - price)\n\n        return max_profit\n\n    def max_profit_with_sell_buy(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_buy_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, min_price - price)\n\n        return max_profit\n\n    def max_profit_with_sell_buy_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_buy_sell_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, min_price - price)\n\n        return max_profit\n\n    def max_profit_with_buy_sell_buy_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_buy_sell_sell_buy_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_buy_sell_sell_sell_buy_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)\n\n        return max_profit\n\n    def max_profit_with_buy_sell_sell_sell_sell_buy_sell(prices: List[int]) -> int:\n        min_price = prices[0]\n        max_profit = 0\n\n        for price in prices:\n            if price < min_price:\n                min_price = price\n                max_profit = 0\n            else:\n                max_profit = max(max_profit, price - min_price)"
    },
    {
        "number": 2959,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    grid = [['.'] * m for _ in range(n)]\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == 'T':\n                for k in range(i-1, -1, -1):\n                    if grid[k][j] == 'T':\n                        grid[i][j] = str(k+1)\n                        break\n            elif grid[i][j] == '.':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n                grid[i][j] =''\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] =='':\n                grid[i][j] = '.'\n\n    for i in range(n):\n        for j in range(m):\n            if grid[i][j] == '.':\n               "
    },
    {
        "number": 2960,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    T_2 = 0\n    for k in range(1, n+1):\n        T_2 += binomial(n, k)\n    return str(T_2)\n\ndef"
    },
    {
        "number": 2961,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    rooms = list(map(int, stdin.strip().split()))\n\n    def dfs(room, path):\n        if room == n:\n            return True\n        if path[room] == 0:\n            return False\n        if dfs(path[room], path):\n            return True\n        return dfs(path[room], path)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if rooms[i] == rooms[j]:\n                return \"Impossible\"\n\n    for i in range(n):\n        path = [0] * n\n        path[i] = 1\n        if dfs(i, path):\n            return \"Yes\"\n\n    return \"No\""
    },
    {
        "number": 2962,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split())\n    people = []\n    for _ in range(N):\n        c, t = map(int, stdin.split())\n        people.append((c, t))\n\n    people.sort(key=lambda x: x[1])\n    total_cash = 0\n    for i in range(N):\n        total_cash += people[i][0]\n        if total_cash >= T:\n            break\n\n    return str(total_cash)\n"
    },
    {
        "number": 2963,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    x = 1\n    while x ** x!= n:\n        x += 1\n    return str(x)"
    },
    {
        "number": 2964,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C = int(stdin.strip())\n    arrows = []\n    for _ in range(C):\n        x, y = map(int, stdin.strip().split())\n        arrows.append((x, y))\n\n    max_distance = 0\n    for i in range(len(arrows)):\n        for j in range(i + 1, len(arrows)):\n            distance = abs(arrows[i][0] - arrows[j][0]) + abs(arrows[i][1] - arrows[j][1])\n            if distance > max_distance:\n                max_distance = distance\n\n    return str(max_distance)"
    },
    {
        "number": 2965,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, D, N = map(int, stdin.split())\n    pumpkins = []\n    for _ in range(P):\n        row, col = map(int, stdin.split())\n        pumpkins.append((row, col))\n\n    for _ in range(D):\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                if i < j:\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[j][0] - 1, pumpkins[j][1]) in pumpkins or (pumpkins[j][0] + 1, pumpkins[j][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0], pumpkins[i][1] - 1) in pumpkins or (pumpkins[i][0], pumpkins[i][1] + 1) in pumpkins:\n                        continue\n                    if (pumpkins[i][0], pumpkins[i][1] - 1) in pumpkins or (pumpkins[i][0], pumpkins[i][1] + 1) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0] + 1, pumpkins[i][1]) in pumpkins:\n                        continue\n                    if (pumpkins[i][0] - 1, pumpkins[i][1]) in pumpkins or (pumpkins[i][0]"
    },
    {
        "number": 2966,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    total_blocks = M * N\n    cut_blocks = 0\n\n    for i in range(M):\n        for j in range(N):\n            if i == 0 or i == M - 1 or j == 0 or j == N - 1:\n                cut_blocks += 1\n\n    return str(cut_blocks)"
    },
    {
        "number": 2967,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    workstations = [False] * n\n    unlockings = [0] * n\n\n    for i in range(n):\n        a, s = map(int, stdin.split())\n        workstations[i] = True\n        unlockings[i] = a + s\n\n    for i in range(n):\n        if workstations[i]:\n            for j in range(i + 1, n):\n                if not workstations[j]:\n                    workstations[j] = True\n                    unlockings[j] = unlockings[i] + m\n\n    max_unlockings = 0\n    for i in range(n):\n        if workstations[i]:\n            max_unlockings = max(max_unlockings, unlockings[i])\n\n    return str(max_unlockings)\n"
    },
    {
        "number": 2968,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, n, e = map(int, stdin.split())\n    s_b, s_n, s_e = map(int, stdin.split())\n    m = (b + n + e) // 2\n    c = list(map(int, stdin.split()))\n\n    max_speed = 0\n    for i in range(m):\n        speed = c[i] * (s_b + s_n + s_e)\n        max_speed = max(max_speed, speed)\n\n    return str(max_speed)\n"
    },
    {
        "number": 2969,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    piles = []\n    for _ in range(n):\n        card = input().split()\n        suit = card[0]\n        rank = int(card[1])\n        piles.append((suit, rank))\n\n    def compare_cards(card1, card2):\n        suit1, rank1 = card1\n        suit2, rank2 = card2\n        if suit1!= suit2:\n            return suit1 < suit2\n        if rank1!= rank2:\n            return rank1 < rank2\n        return suit1 == suit2 and rank1 == rank2\n\n    def reshuffle_piles(piles):\n        for i in range(len(piles)):\n            for j in range(i + 1, len(piles)):\n                if compare_cards(piles[i], piles[j]):\n                    piles[i], piles[j] = piles[j], piles[i]\n\n    def has_empty_pile(piles):\n        for pile in piles:\n            if len(pile) == 0:\n                return True\n        return False\n\n    def has_cards_remaining(piles):\n        for pile in piles:\n            if len(pile) > 0:\n                return True\n        return False\n\n    def has_won(piles):\n        for pile in piles:\n            if len(pile) > 0:\n                return False\n        return True\n\n    def has_tie(piles):\n        return has_empty_pile(piles) and has_empty_pile(piles)\n\n    reshuffle_piles(piles)\n\n    if has_won(piles):\n        return \"possible\"\n    elif has_tie(piles):\n        return \"impossible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2970,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    buildings = list(map(int, stdin.split()))\n    total_noise = 0\n\n    for i in range(N):\n        for j in range(M):\n            if buildings[j] == i + 1:\n                total_noise += 1\n\n    return str(total_noise)"
    },
    {
        "number": 2971,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    words = []\n    for _ in range(n):\n        word = input().strip()\n        words.append(word)\n\n    max_power = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            power = 0\n            for k in range(min(len(words[i]), len(words[j]))):\n                if words[i][k] == words[j][k]:\n                    power += 1\n            if power > max_power:\n                max_power = power\n\n    return str(max_power)\n"
    },
    {
        "number": 2972,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, k = map(int, stdin.split())\n    count = 0\n    for j in range(2, k+1):\n        for i in range(a, b+1):\n            if str(i) == str(i)[::-1]:\n                count += 1\n    return str(count)"
    },
    {
        "number": 2973,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    c = 0\n    for i in range(n):\n        d, s = map(int, stdin.split())\n        c += d * s\n    c /= t\n    return str(round(c, 6))"
    },
    {
        "number": 2974,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.readline().strip())\n    P = list(map(int, stdin.readline().strip().split()))\n    D = list(map(int, stdin.readline().strip().split()))\n\n    # Find the minimum number of events consistent with the prosecution's claim\n    p_min = min(len(P), len(D))\n    p_consistent = 0\n    for i in range(p_min):\n        if P[i]!= D[i]:\n            p_consistent += 1\n\n    # Find the minimum number of events consistent with the defense's claim\n    r_min = min(len(P), len(D))\n    r_consistent = 0\n    for i in range(r_min):\n        if P[i]!= D[i]:\n            r_consistent += 1\n\n    return str(p_consistent) + \" \" + str(r_consistent)\n"
    },
    {
        "number": 2975,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    ingredients = []\n    for _ in range(N):\n        X, Y, S_M, P_M, S_V, P_V = map(int, stdin.split())\n        ingredients.append((X, Y, S_M, P_M, S_V, P_V))\n\n    def max_servings(ingredients):\n        servings = 0\n        for i in range(len(ingredients)):\n            for j in range(i + 1, len(ingredients)):\n                if ingredients[i][0] + ingredients[j][0] <= ingredients[j][1]:\n                    servings += 1\n        return servings\n\n    max_servings_per_ingredient = max_servings(ingredients)\n    total_servings = sum(ingredients[i][0] * ingredients[i][2] for i in range(N))\n    total_cost = total_servings * max_servings_per_ingredient\n\n    if total_cost <= M:\n        return str(total_servings)\n    else:\n        return \"0\""
    },
    {
        "number": 2976,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    players = stdin.strip().split()\n    n = int(stdin.strip().split()[1])\n    matches = []\n\n    for _ in range(n):\n        sets = stdin.strip().split()\n        match = []\n\n        for set in sets:\n            a, b = set.split(':')\n            match.append(int(a))\n            match.append(int(b))\n\n        matches.append(match)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if matches[i][0] == matches[j][0] and matches[i][1] == matches[j][1]:\n                if matches[i][2] == matches[j][2]:\n                    return \"da\"\n                else:\n                    return \"ne\"\n\n    return \"ne\""
    },
    {
        "number": 2977,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read the question and the number of answer alternatives\n    question, num_alternatives = stdin.strip().split()\n    num_alternatives = int(num_alternatives)\n\n    # Read the answer alternatives\n    alternatives = []\n    for _ in range(num_alternatives):\n        line = stdin.strip().split()\n        parts = [part.strip() for part in line]\n        alternatives.append(parts)\n\n    # Define the incongruousity function\n    def incongruousity(a, b):\n        changes = 0\n        for i in range(len(a)):\n            if a[i]!= b[i]:\n                changes += 1\n        return changes\n\n    # Find the least incongruous alternative\n    min_incongruousity = float('inf')\n    for i in range(num_alternatives):\n        for j in range(i + 1, num_alternatives):\n            incongruousity_i = incongruousity(alternatives[i], alternatives[j])\n            incongruousity_j = incongruousity(alternatives[j], alternatives[i])\n            if incongruousity_i < min_incongruousity or (incongruousity_i == min_incongruousity and incongruousity_j < min_incongruousity):\n                min_incongruousity = incongruousity_i\n\n    # Find the alternative(s) with the smallest incongruousity\n    min_alternatives = []\n    for i in range(num_alternatives):\n        for j in range(i + 1, num_alternatives):\n            if incongruousity(alternatives[i], alternatives[j]) == min_incongruousity:\n                min_alternatives.append((alternatives[i], alternatives[j]))\n\n    # Output the alternative(s) with the smallest incongruousity\n    for alternative in min_alternatives:\n        print(*alternative, sep=' ')"
    },
    {
        "number": 2978,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T = map(int, stdin.split())\n    streets = []\n    for _ in range(S):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        streets.append((x1, y1, x2, y2))\n\n    for _ in range(T):\n        x3, y3, x4, y4 = map(int, stdin.split())\n        if (x3, y3) == (x4, y4):\n            return \"same\"\n        if (x3, y3)!= (x4, y4):\n            return \"different\"\n\n    return \"same\""
    },
    {
        "number": 2979,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split())\n    links = [[] for _ in range(n)]\n    infected = [False] * n\n    infected[s] = True\n\n    for i in range(m):\n        a, b = map(int, stdin.split())\n        links[a].append(b)\n        links[b].append(a)\n\n    for i in range(t):\n        for j in range(n):\n            if infected[j]:\n                infected[j] = False\n                for k in links[j]:\n                    if not infected[k]:\n                        infected[k] = True\n                        break\n\n    count = 0\n    for i in range(n):\n        if infected[i]:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 2980,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m = map(int, stdin.split())\n    S = set(map(int, stdin.split()))\n    positions = []\n\n    for _ in range(m):\n        l, *h = map(int, stdin.split())\n        positions.append((l, h))\n\n    xor_sum = 0\n    for i in range(n):\n        xor_sum ^= sum(h[i] for h in positions)\n\n    if xor_sum == 0:\n        return 'W'\n    else:\n        return 'L'"
    },
    {
        "number": 2981,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    slots = []\n    for _ in range(N):\n        x, y = map(float, stdin.strip().split())\n        slots.append((x, y))\n\n    min_slot_size = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if slots[i][0] * slots[j][1] * slots[k][0] * slots[k][1] > 0:\n                    min_slot_size = min(min_slot_size, slots[i][0] + slots[j][0] + slots[k][0])\n\n    return str(min_slot_size)\n"
    },
    {
        "number": 2982,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    hype_ratings = list(map(int, stdin.readline().strip().split()))\n\n    setlists = []\n    for i in range(n):\n        if hype_ratings[i] == 1:\n            setlists.append([i])\n        elif hype_ratings[i] == 2:\n            setlists.append([i, i + 1])\n        elif hype_ratings[i] == 3:\n            setlists.append([i, i + 1, i + 2])\n\n    setlists.sort(key=lambda x: hype_ratings[x[0]], reverse=True)\n    setlists = setlists[:n]\n\n    result = 1\n    for setlist in setlists:\n        result = (result * 1000000007) % 1000000007\n        result += len(setlist)\n\n    return str(result)"
    },
    {
        "number": 2983,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *sheets = map(int, stdin.split())\n    total_length = 0\n    for i in range(n):\n        total_length += sheets[i] * 2 ** (i + 1)\n    if total_length <= 10000:\n        return f\"{total_length:.5f}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 2984,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, P = map(int, stdin.split())\n    passengers = []\n    for _ in range(P):\n        x = int(stdin.readline())\n        passengers.append(x)\n\n    max_distance = 0\n    max_passengers = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            distance = abs(i - j)\n            if distance > max_distance:\n                max_distance = distance\n                max_passengers = 1\n            elif distance == max_distance:\n                max_passengers += 1\n\n    print(max_distance)\n    print(max_passengers)\n\n    return \"\""
    },
    {
        "number": 2985,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    ell, d, n = map(int, stdin.split())\n    max_additional_birds = 0\n\n    for i in range(n):\n        x1, y1, x2, y2 = map(int, stdin.split())\n        if x1 == x2 and y1 == y2:\n            continue\n        if abs(x1 - x2) > d or abs(y1 - y2) > d:\n            continue\n        if abs(x1 - x2) + abs(y1 - y2) > ell:\n            continue\n        max_additional_birds += 1\n\n    return str(max_additional_birds)"
    },
    {
        "number": 2986,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.strip())\n    for _ in range(T):\n        line = stdin.strip()\n        result = \"\"\n        for i in range(len(line)):\n            if line[i] == \"<\":\n                result += line[i]\n            elif line[i] == \"[\":\n                result += line[i]\n                result += line[i+1]\n            elif line[i] == \"]\":\n                result += line[i]\n                result += line[i-1]\n            else:\n                result += line[i]\n        print(result)"
    },
    {
        "number": 2987,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, W = map(int, stdin.split())\n    prices = list(map(int, stdin.split()))\n    s = list(map(int, stdin.split()))\n\n    max_revenue = 0\n    min_price = prices[0]\n    max_price = prices[0]\n\n    for i in range(1, W + 1):\n        min_price = min(min_price, prices[i])\n        max_price = max(max_price, prices[i])\n\n        if i < W:\n            max_revenue += s[i] * (prices[i] - min_price)\n        else:\n            max_revenue += s[i] * (max_price - prices[i - W])\n\n    return str(max_revenue) + '\\n' + str(max_price)"
    },
    {
        "number": 2988,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    radar = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, t = map(int, stdin.split())\n        radar[a - 1].append((b - 1, t))\n        radar[b - 1].append((a - 1, t))\n    visited = [False] * n\n    result = -1\n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            result = min(result, dfs(i, radar, visited))\n    return str(result)\n\ndef"
    },
    {
        "number": 2989,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, k = map(int, stdin.split())\n    pipes = []\n    for _ in range(p):\n        a, b, c = map(int, stdin.split())\n        pipes.append((a, b, c))\n\n    improvements = []\n    for _ in range(k):\n        a, b, c = map(int, stdin.split())\n        improvements.append((a, b, c))\n\n    max_water = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            for k in range(i + 1, n + 1):\n                for l in range(j + 1, n + 1):\n                    for m in range(k + 1, n + 1):\n                        for n in range(l + 1, n + 1):\n                            for o in range(m + 1, n + 1):\n                                for p in range(n + 1):\n                                    if pipes[i][0] == i and pipes[i][1] == j and pipes[i][2] == c:\n                                        if pipes[j][0] == j and pipes[j][1] == k and pipes[j][2] == c:\n                                            if pipes[k][0] == k and pipes[k][1] == l and pipes[k][2] == c:\n                                                if pipes[l][0] == l and pipes[l][1] == m and pipes[l][2] == c:\n                                                    if pipes[m][0] == m and pipes[m][1] == n and pipes[m][2] == c:\n                                                        if pipes[n][0] == n and pipes[n][1] == o and pipes[n][2] == c:\n                                                            if improvements[k][0] == i and improvements[k][1] == j and improvements[k][2] == c:\n                                                                if improvements[k][0] == j and improvements[k][1] == k and improvements[k][2] == c:\n                                                                    if improvements[k][0] == k and improvements[k][1] == l and improvements[k][2] == c:\n                                                                        if improvements[k][0] == l and improvements[k][1] == m and improvements[k][2] == c:\n                                                                            if improvements[k][0] == m and improvements[k][1] == n and improvements[k][2] == c:\n                                                                                if improvements[k][0] == n and improvements[k][1] == o and improvements[k][2] == c:\n                                                                                    if improvements[k][0] == i and improvements[k][1] == j and improvements[k][2] == c:\n                                                                                        if improvements[k][0] == j and improvements[k][1] == k and improvements[k][2] == c:\n                                                                                            if improvements[k][0] == k and improvements[k][1] == l and improvements[k][2] == c:\n                                                                                                if improvements[k][0] == l and improvements[k][1] == m and improvements[k][2] == c:\n                                                                                                    if improvements[k][0] == m and improvements[k][1] == n and improvements[k][2] == c:\n                                                                                                        if improvements[k][0] == n and improvements[k][1] == o and improvements[k][2] == c:\n                                                                                                            if improvements[k][0] == i and improvements[k][1] == j and improvements[k][2] == c:\n                                                                                                                if improvements[k][0] == j and improvements[k][1] == k and improvements[k][2] == c:\n                                                                                                                    if improvements[k][0] == k and improvements[k][1] == l and improvements[k][2] == c:\n                                                                                                                        if improvements[k][0] == l and improvements[k][1] == m and improvements[k][2] == c:\n                                                                                                                            if improvements[k][0] == m and improvements[k][1] == n and improvements[k][2] == c:\n                                                                                                                                if improvements[k][0] == n and improvements[k][1] == o and improvements[k][2] == c:\n                                                                                                                                    if improvements[k][0] == i and improvements[k][1] == j and improvements[k][2] == c:\n                                                                                                                                        if improvements[k][0] == j and improvements[k][1] == k and improvements[k][2] == c:\n                                                                                                                                            if improvements[k][0] == k and improvements[k][1] == l and improvements[k][2] == c:\n                                                                                                                                                if improvements"
    },
    {
        "number": 2990,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    players = []\n    for _ in range(k):\n        players.append(input())\n    p = int(input())\n    for _ in range(p):\n        name = input()\n        players.append(name)\n    players.sort()\n    selected_players = []\n    for i in range(n):\n        selected_players.append(players[i])\n        for j in range(i + 1, n):\n            if players[j] not in selected_players:\n                selected_players.append(players[j])\n                break\n    return '\\n'.join(selected_players)"
    },
    {
        "number": 2991,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    gnomes = list(map(int, stdin.split()))\n\n    # Remove the gnomes from the lineup\n    for i in range(m):\n        gnomes.remove(i + 1)\n\n    # Find the first permutation that contains the remaining gnomes\n    for i in range(n):\n        if gnomes == sorted(gnomes):\n            return str(i + 1)\n\n    # If no permutation is found, return an empty string\n    return \"\""
    },
    {
        "number": 2992,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    roads = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split())\n        roads.append((a - 1, b - 1, c))\n\n    def bfs(start, visited, queue):\n        visited[start] = True\n        queue.append(start)\n        while queue:\n            current = queue.pop(0)\n            for neighbor, distance in roads[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    def dfs(start, visited, queue):\n        visited[start] = True\n        queue.append(start)\n        while queue:\n            current = queue.pop(0)\n            for neighbor, distance in roads[current]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n                    if neighbor == start:\n                        return True\n\n    def min_range(start, visited, queue):\n        if dfs(start, visited, queue):\n            return 0\n        else:\n            return float('inf')\n\n    visited = [False] * n\n    queue = []\n    bfs(0, visited, queue)\n    min_range_sum = 0\n    for i in range(n):\n        if not visited[i]:\n            min_range_sum += min_range(i, visited, queue)\n    if min_range_sum == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return str(min_range_sum)\n"
    },
    {
        "number": 2993,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D = map(int, stdin.split())\n    encoded_message = stdin[3:]\n    message = \"\"\n    for i in range(N):\n        p_A = D / 8\n        p_B = 1 - p_A\n        a = 0\n        b = 1\n        while b <= encoded_message[i]:\n            if encoded_message[i] == 'A':\n                message += str(a) + \" \"\n                a += p_A * (b - a)\n            else:\n                message += str(b) + \" \"\n                b += p_B * (b - a)\n            b += 1\n    return message"
    },
    {
        "number": 2994,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    board = [['.' for _ in range(C)] for _ in range(R)]\n\n    for _ in range(R):\n        line = stdin.readline().strip()\n        for i, cell in enumerate(line):\n            board[i][C - 1 - i] = cell\n\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == 'a':\n                board[i][j] = '.'\n                for k in range(i - 1, -1, -1):\n                    if board[k][j] == 'a':\n                        board[k][j] = '.'\n                        break\n                for k in range(i + 1, R):\n                    if board[k][j] == 'a':\n                        board[k][j] = '.'\n                        break\n                for k in range(j - 1, -1, -1):\n                    if board[i][k] == 'a':\n                        board[i][k] = '.'\n                        break\n                for k in range(j + 1, C):\n                    if board[i][k] == 'a':\n                        board[i][k] = '.'\n                        break\n\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == '.':\n                board[i][j] = 'a'\n\n    return '\\n'.join(board)"
    },
    {
        "number": 2995,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    items = set()\n    for _ in range(N):\n        item = input()\n        items.add(item)\n\n    suspicious_pairs = set()\n    for _ in range(M):\n        name1, name2 = input().split()\n        if name1 in items and name2 in items:\n            suspicious_pairs.add((name1, name2))\n\n    if len(suspicious_pairs) == 0:\n        return \"impossible\"\n\n    items_to_buy = set(suspicious_pairs)\n    items_to_buy.difference_update(items)\n\n    return \" \".join(items_to_buy)\n"
    },
    {
        "number": 2996,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    requests = []\n    for _ in range(n):\n        requests.append(list(map(int, stdin.split())))\n\n    requests.sort(key=lambda x: x[0])\n\n    total_cost = 0\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            total_cost += requests[i][j]\n\n    return str(total_cost)\n"
    },
    {
        "number": 2997,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    edges = []\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        edges.append((a, b))\n\n    def dfs(node, color):\n        if node == N:\n            return 0\n\n        if color == edges[node - 1][1]:\n            return 0\n\n        if color == edges[node - 1][0]:\n            return 1\n\n        return max(dfs(node + 1, color), dfs(node + 1, edges[node - 1][1]))\n\n    return str(dfs(1, 0))"
    },
    {
        "number": 2998,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_str = stdin.strip()\n    words = input_str.split()\n    umm_message = \"\"\n\n    # Iterate through words\n    for word in words:\n        # Check if word contains only lowercase u and m\n        if not any(char.islower() and char in \"um\" for char in word):\n            # If not, add it to the umm-coded message\n            umm_message += word + \" \"\n\n    # Remove last space\n    umm_message = umm_message[:-1]\n\n    # Decode umm-coded message\n    decoded_message = \"\"\n    for i in range(0, len(umm_message), 7):\n        # Extract 7-bit binary ASCII code\n        binary_code = umm_message[i:i+7]\n        # Extract umm code\n        umm_code = binary_code[0]\n        # Extract message\n        message = binary_code[1:]\n        # Decode message\n        decoded_message += chr(int(umm_code, 2) + ord('a')) + message\n\n    return decoded_message"
    },
    {
        "number": 2999,
        "checkpoint": "1B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    participants = []\n    for _ in range(n):\n        name, amount = stdin.split()\n        participants.append((name, int(amount)))\n\n    participants.sort(key=lambda x: x[1])\n    winners = []\n    for i in range(n):\n        if i == 0 or participants[i][1] > participants[i-1][1]:\n            winners.append(participants[i][0])\n\n    return '\\n'.join(winners)"
    }
]