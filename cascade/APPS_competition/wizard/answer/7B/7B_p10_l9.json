[
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, bracket_sequence = stdin.split('\\n')\n    n = int(n)\n    tokens = bracket_sequence.split(' ')\n    stack = []\n\n    for token in tokens:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            total = 0\n            while stack and stack[-1] != '(':\n                total += stack.pop()\n            stack.pop()\n            stack.append(total)\n        else:\n            stack.append(int(token))\n\n    return stack[0] % (10**9 + 7)\n\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.splitlines()[0])\n    tokens = stdin.splitlines()[1].split()\n\n    # Function to evaluate the expression\n    def evaluate(tokens: list) -> int:\n        # Initialize stack and operator\n        stack = []\n        op = \"+\"\n\n        # Iterate through tokens\n        for token in tokens:\n            # If token is an operator, update the operator\n            if token in [\"+\", \"*\"]:\n                op = token\n            # If token is a left parenthesis, push it onto the stack\n            elif token == \"(\":\n                stack.append(token)\n            # If token is a right parenthesis, pop operators and values from the stack until a left parenthesis is found\n            elif token == \")\":\n                while stack[-1] != \"(\":\n                    b = stack.pop()\n                    a = stack.pop()\n                    if op == \"+\":\n                        stack.append(a + b)\n                    else:\n                        stack.append(a * b)\n                stack.pop()\n            # If token is an integer, evaluate it based on the current operator\n            else:\n                stack.append(int(token))\n\n            # While there are two values on the stack and the current operator is \"+\", evaluate them and replace the values with the result\n            while len(stack) > 1 and isinstance(stack[-1], int) and isinstance(stack[-2], int):\n                b = stack.pop()\n                a = stack.pop()\n                if op == \"+\":\n                    stack.append(a + b)\n                else:\n                    stack.append(a * b)\n\n        # Return the remaining value(s) on the stack\n        return stack[0]\n\n    # Evaluate the bracket sequence\n    result = evaluate(tokens)\n\n    # Return the result modulo 10^9+7\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tokens = stdin.splitlines()[1].split()\n\n    stack = []\n    for token in tokens:\n        if token == '(':\n            stack.append(token)\n        elif token == ')':\n            sub_stack = []\n            while stack[-1] != '(':\n                sub_stack.append(stack.pop())\n            stack.pop()\n            while sub_stack:\n                stack.append(sub_stack.pop())\n        else:\n            stack.append(int(token))\n\n    result = 0\n    while stack:\n        if isinstance(stack[-1], int):\n            result = (result + stack.pop()) % (10**9 + 7)\n        elif stack[-1] == '(':\n            break\n        else:\n            stack.pop()\n\n    return result\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tokens = stdin.splitlines()[1].split()\n    stack = []\n\n    for token in tokens:\n        if token == \"(\":\n            stack.append(\"(\")\n        elif token == \")\":\n            subsequence = []\n            while stack and stack[-1] != \"(\":\n                subsequence.append(stack.pop())\n            stack.pop()\n            subsequence.reverse()\n            stack.append(str(eval(\" \".join(subsequence))))\n        else:\n            stack.append(token)\n\n    return str(eval(\" \".join(stack)) % (10**9 + 7))\n\n\ndef"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    tokens = stdin[1].split()\n\n    stack = []\n    mod = 10**9 + 7\n    for token in tokens:\n        if token == \"(\":\n            stack.append(\"(\")\n        elif token == \")\":\n            num_str = \"\"\n            while stack and stack[-1] != \"(\":\n                num_str = stack.pop() + num_str\n            stack.pop()\n            num = 0\n            for digit in num_str:\n                num = (num * 10) + int(digit)\n            stack.append(num)\n        else:\n            stack.append(int(token))\n\n    result = 0\n    while stack:\n        if isinstance(stack[-1], int):\n            result = (result + stack.pop()) % mod\n        else:\n            stack.pop()\n\n    return str(result)\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    tokens = stdin.split('\\n')[1].split()\n\n    stack = []\n    current_number = 0\n    current_operation = '+'\n    for token in tokens:\n        if token == '(':\n            stack.append(current_number)\n            stack.append(current_operation)\n            current_number = 0\n            current_operation = '+'\n        elif token == ')':\n            right_number = stack.pop()\n            left_number = stack.pop()\n            operation = stack.pop()\n            if operation == '+':\n                current_number = left_number + right_number\n            else:\n                current_number = left_number * right_number\n        else:\n            current_number = (current_number * 10 + int(token)) % (10**9 + 7)\n\n    result = current_number\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, bracket_seq = input().split()\n    n = int(n)\n    bracket_seq = bracket_seq.split()\n\n    def evaluate(seq: List[str]) -> int:\n        stack = []\n        for token in seq:\n            if token == \"(\":\n                stack.append(0)\n            elif token == \")\":\n                terms = []\n                while stack[-1] != 0:\n                    terms.append(stack.pop())\n                terms.reverse()\n                term = functools.reduce(lambda x, y: x + y, terms)\n                stack.pop()\n                stack.append(term)\n            else:\n                stack.append(int(token))\n        return stack.pop()\n\n    def parse(seq: List[str]) -> List[str]:\n        i = 0\n        while i < len(seq):\n            if seq[i] == \"(\":\n                j = i + 1\n                while j < len(seq) and seq[j] != \")\":\n                    j += 1\n                if j >= len(seq):\n                    raise ValueError(\"Invalid bracket sequence\")\n                subseq = parse(seq[i+1:j])\n                seq = seq[:i] + subseq + seq[j+1:]\n                i += len(subseq) - 1\n            i += 1\n        return seq\n\n    bracket_seq = parse(bracket_seq)\n    result = evaluate(bracket_seq)\n    result %= (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    tokens = stdin.split()[1:]\n    stack = []\n\n    for token in tokens:\n        if token.isdigit():\n            stack.append(int(token))\n        elif token == '(':\n            stack.append('(')\n        elif token == ')':\n            sub_stack = []\n            while stack and stack[-1] != '(':\n                sub_stack.append(stack.pop())\n            stack.pop()  # Remove opening parenthesis\n            sub_expression = 1\n            while sub_stack:\n                sub_expression *= sub_stack.pop()\n            stack.append(sub_expression)\n\n    result = sum(stack)\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    tokens = input().split()\n    \n    stack = []\n    i = 0\n    \n    while i < n:\n        if tokens[i] == \"(\":\n            stack.append(tokens[i])\n        elif tokens[i] == \")\":\n            while stack[-1] != \"(\":\n                if isinstance(stack[-1], int):\n                    a = stack.pop()\n                else:\n                    b = stack.pop()\n                    op = stack.pop()\n                    if op == \"+\":\n                        stack.append(a + b)\n                    else:\n                        stack.append(a * b)\n            stack.pop()\n        else:\n            stack.append(int(tokens[i]))\n        i += 1\n    \n    result = 0\n    while stack:\n        if isinstance(stack[-1], int):\n            result = result + stack.pop()\n        else:\n            b = stack.pop()\n            op = stack.pop()\n            if op == \"+\":\n                a = stack.pop()\n                result = (result + a + b) % (10**9 + 7)\n            else:\n                a = stack.pop()\n                result = (result + a * b) % (10**9 + 7)\n                \n    return str(result)"
    },
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1].split()\n    \n    stack = []\n    result = 0\n    \n    for token in sequence:\n        if token == \"(\":\n            stack.append(token)\n        elif token == \")\":\n            while stack and stack[-1] != \"(\":\n                op = stack.pop()\n                if op == \"+\":\n                    result += stack.pop()\n                elif op == \"*\":\n                    stack.append(stack.pop() * stack.pop())\n            stack.pop()\n        else:\n            stack.append(int(token))\n            \n        while stack and isinstance(stack[-1], int):\n            result += stack.pop()\n            \n    return str(result % (10**9 + 7))\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    input_list = [int(digit) for digit in input_str]\n    num_wheels = len(input_list)\n\n    def reverse_num(num: int) -> int:\n        return int(str(num)[::-1])\n\n    def update_palindrome(palindrome: int, wheels: List[int], index: int) -> int:\n        if wheels[index] == 0:\n            wheels[index] = 9\n            if index > 0:\n                wheels[index - 1] = 0 if wheels[index - 1] == 9 else wheels[index - 1] + 1\n        else:\n            wheels[index] = wheels[index] - 1\n        return palindrome\n\n    def count_steps(num: int) -> int:\n        wheels = [int(digit) for digit in str(num)]\n        num_digits = len(wheels)\n        palindrome = int(str(num) + str(num)[::-1][1:])\n\n        for i in range(num_digits):\n            for j in range(palindrome // 10):\n                palindrome = update_palindrome(palindrome, wheels, i)\n                if palindrome == reverse_num(palindrome):\n                    return j + 1\n        return -1\n\n    palindrome = int(input_str + input_str[::-1][1:])\n    return count_steps(palindrome)\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    if input_str == \"\":\n        return \"0\"\n    \n    input_str_list = list(input_str)\n    palindrome_found = False\n    steps = 0\n    \n    for i in range(len(input_str_list)):\n        if input_str_list[i] == \"0\":\n            continue\n        \n        for j in range(i, len(input_str_list)):\n            if input_str_list[i] != input_str_list[j]:\n                continue\n            \n            for k in range(i, j+1):\n                if input_str_list[k] != \"9\":\n                    input_str_list[k] = \"9\"\n                    steps += 1\n                    palindrome_found = True\n                    break\n                \n                if palindrome_found:\n                    break\n                \n            if palindrome_found:\n                break\n        \n        if palindrome_found:\n            break\n    \n    return str(steps)\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    counter = [0] * n\n    for i, digit in enumerate(stdin):\n        counter[i] = int(digit)\n\n    def is_palindrome(counter: list) -> bool:\n        left, right = 0, n - 1\n        while left < right:\n            if counter[left] != counter[right]:\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    def count_steps(counter: list, steps: int) -> int:\n        left, right = 0, n - 1\n        while left < right:\n            if counter[left] == 9:\n                counter[left] = 0\n                counter[left + 1] += 1\n                left += 1\n                steps += 1\n            else:\n                counter[left] += 1\n                left += 1\n            if counter[right] == 0:\n                counter[right] = 9\n                counter[right - 1] -= 1\n                right -= 1\n                steps += 1\n            else:\n                counter[right] -= 1\n                right -= 1\n        return steps\n\n    steps = 0\n    while not is_palindrome(counter):\n        steps = count_steps(counter, steps)\n\n    return str(steps)\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(number: str) -> bool:\n        return number == number[::-1]\n\n    def update_counter(counter: str, step: int) -> str:\n        return str(int(counter) + step)\n\n    def advance_counter(counter: str, step: int) -> str:\n        digits = [int(d) for d in counter]\n        for i in range(len(digits)):\n            if digits[i] + step > 9:\n                digits[i] = 0\n            else:\n                digits[i] += step\n        return ''.join(str(d) for d in digits)\n\n    counter = stdin\n    if len(counter) == 1 and counter == '0':\n        return '0'\n\n    # Find the smallest number of steps required to reach a palindrome\n    min_steps = float('inf')\n    for i in range(10):\n        new_counter = update_counter(counter, i)\n        for j in range(10):\n            new_counter = advance_counter(new_counter, j)\n            if is_palindrome(new_counter):\n                min_steps = min(min_steps, i + j)\n                break\n\n    return str(min_steps)\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input string to list of integers\n    num_list = list(map(int, stdin))\n    \n    # Initialize the palindrome and its length\n    palindrome = num_list.copy()\n    palindrome_length = len(palindrome)\n    \n    # Convert the list to a string and reverse it\n    reversed_str = ''.join(map(str, palindrome))[::-1]\n    \n    # Initialize the minimum number of advances\n    min_advances = 0\n    \n    # Loop through the digits of the reversed string\n    for i in range(palindrome_length):\n        if palindrome[i] != int(reversed_str[i]):\n            # Calculate the number of steps to reach the palindrome\n            num_steps = palindrome_length - i - 1\n            \n            # Update the minimum number of advances\n            min_advances += num_steps\n            \n            # Spin the wheels to reach the palindrome\n            palindrome[i] = int(reversed_str[i])\n            for j in range(i, palindrome_length - 1):\n                palindrome[j] = (palindrome[j] + 1) % 10\n        \n    return str(min_advances)"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def palindrome(num: str) -> bool:\n        return num == num[::-1]\n\n    def next_palindrome(num: str) -> str:\n        def reverse_digit(digit: str) -> str:\n            return str(int(digit) ^ 1)\n\n        def next_digit(digit: str, carry: int) -> str:\n            return str((int(digit) + carry) % 10)\n\n        def sum_digits(num: str) -> int:\n            return sum(int(digit) for digit in num)\n\n        def carry_digit(num: str) -> int:\n            return (sum_digits(num) + len(num) - 1) // 2\n\n        def reverse_carry(carry: int) -> int:\n            return (10 - carry) % 10\n\n        def next_carry(carry: int, digit: str) -> int:\n            return (carry + int(digit)) // 10\n\n        def advance_wheel(num: str, index: int) -> str:\n            return num[:index] + next_digit(num[index], 0) + num[index + 1:]\n\n        def advance_palindrome(num: str) -> str:\n            carry = carry_digit(num)\n            reversed_num = num[::-1]\n            reversed_num = reverse_carry(carry) + reversed_num[:-1]\n\n            for index, digit in enumerate(reversed_num[:-1]):\n                if int(digit) > 0:\n                    num = advance_wheel(num, index)\n\n            return num\n\n        def next_palindrome(num: str) -> str:\n            while not palindrome(num):\n                num = advance_palindrome(num)\n            return num\n\n        return next_palindrome(num)\n\n    def min_steps(num: str) -> int:\n        current_palindrome = palindrome(num)\n        if current_palindrome:\n            return 0\n\n        def find_diff(a: str, b: str) -> int:\n            diff = sum(1 for i in range(len(a)) if a[i] != b[i])\n            return diff\n\n        def min_wheel_steps(wheels: str) -> int:\n            max_wheel = max(int(wheel) for wheel in wheels)\n            return find_diff(wheels, str(max_wheel))\n\n        def min_steps(num: str) -> int:\n            wheels = num.split()\n            min_diff = min(min_wheel_steps(wheels) for wheel in wheels)\n            return min_diff\n\n        next_palindrome = palindrome(num)\n        current_palindrome = palindrome(num)\n        while not current_palindrome:\n            next_palindrome = palindrome(num)\n            num = advance_wheel(num, num.index(next_palindrome[0]))\n\n        return find_diff(next_palindrome, num)\n\n    num = stdin.strip()\n    return str(min_steps(num))\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    if input_str == \"0\":\n        return \"0\"\n\n    def palindrome(input_str: str) -> str:\n        if input_str == \"0\":\n            return \"0\"\n\n        input_str = input_str.lstrip(\"0\")\n        if input_str == \"\":\n            return \"0\"\n\n        input_str = input_str[::-1]\n        return input_str.zfill(len(input_str))\n\n    def min_steps(input_str: str) -> int:\n        input_str = input_str.lstrip(\"0\")\n        if input_str == \"\":\n            return 0\n\n        palindrome_str = palindrome(input_str)\n        steps = 0\n\n        for i in range(len(input_str)):\n            if input_str[i] != palindrome_str[i]:\n                steps += 1\n\n        return steps\n\n    return str(min_steps(input_str))\n\n\ndef"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # reverse the input string\n    input_str = stdin[::-1]\n\n    # initialize a variable to store the number of steps\n    steps = 0\n\n    # initialize a variable to store the current position on the counter\n    current_position = 0\n\n    # loop through each digit of the input string\n    for digit in input_str:\n        # if the digit is different from the current position, we need to advance the counter\n        if int(digit) != current_position:\n            # calculate the number of steps required to advance the counter to the desired position\n            steps += abs(int(digit) - current_position)\n\n            # update the current position\n            current_position = int(digit)\n\n    # return the minimum number of wheel advances required to produce a palindrome\n    return str(steps)"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    num_wheels = len(stdin)\n    if num_wheels == 1:\n        return 0\n\n    # Initialize a list of all possible numbers that could be the palindrome\n    palindromes = set()\n    for i in range(num_wheels - 1):\n        palindromes.add(int(stdin[:i+1]))\n\n    # Iterate through the list of palindromes and calculate the minimum number of steps required\n    min_steps = float('inf')\n    for palindrome in palindromes:\n        # Calculate the number of steps required to reach the palindrome\n        steps = 0\n        for i in range(num_wheels):\n            if stdin[i] != str(palindrome[i]):\n                steps += abs(int(stdin[i]) - int(palindrome[i]))\n\n        # Update the minimum number of steps\n        min_steps = min(min_steps, steps)\n\n    return min_steps"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    num = [0]*n\n    for i in range(n):\n        num[i] = int(stdin[i])\n\n    # Find the smallest number of wheel advances required to reach a palindrome\n    # using dynamic programming\n    dp = [[-1]*10 for _ in range(n)]\n    for i in range(10):\n        dp[0][i] = 0\n    for i in range(1, n):\n        for j in range(10):\n            for k in range(10):\n                if j == k:\n                    dp[i][j] = min(dp[i][j], dp[i-1][k])\n                if j > k:\n                    dp[i][j] = min(dp[i][j], dp[i-1][k]+1)\n            dp[i][j] += 1\n\n    res = min(dp[n-1][i] for i in range(10))\n\n    # Find the steps to reach the palindrome\n    # by tracing back the DP matrix\n    steps = [None]*n\n    i = n-1\n    for j in range(10):\n        if dp[n-1][j] == res:\n            steps[i] = j\n            break\n    for i in range(n-2, -1, -1):\n        steps[i] = (steps[i+1] - steps[i]) % 10\n\n    # Convert the list of steps to a string\n    steps = ''.join(str(x) for x in steps)\n\n    return str(res)"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin)\n    service_history = []\n    for _ in range(n):\n        y, m, o = map(int, stdin.readline().strip().split())\n        service_history.append((y, m, o))\n\n    # process input\n    oldest_service = min(service_history, key=lambda x: (x[0], x[1]))\n    if oldest_service[2] != 0:\n        return \"tampered odometer\"\n    prev_service = oldest_service\n    for service in service_history:\n        if service[0] < prev_service[0] or (service[0] == prev_service[0] and service[1] < prev_service[1]):\n            return \"tampered odometer\"\n        if service[2] > 99999:\n            return \"tampered odometer\"\n        prev_service = service\n\n    months_since_last_service = (prev_service[0] - oldest_service[0]) * 12 + prev_service[1] - oldest_service[1] + 1\n    if months_since_last_service < 12:\n        return \"insufficient service\"\n\n    # determine if service was done often enough\n    total_distance = 0\n    for i in range(n):\n        o = service_history[i][2]\n        total_distance += o\n        if total_distance > 30000:\n            total_distance = 0\n            if i == n - 1 or service_history[i + 1][2] > 99999:\n                return \"seems legit\"\n\n    return \"insufficient service\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_odometer_reading(reading: int) -> bool:\n        return 0 <= reading <= 99999\n\n    def is_valid_service_month(year: int, month: int) -> bool:\n        return 1950 <= year <= 2050 and 1 <= month <= 12\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [1, 3, 5, 7, 8, 10, 12]:\n            return 31\n        elif month in [4, 6, 9, 11]:\n            return 30\n        elif year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            return 29\n        else:\n            return 28\n\n    def is_valid_service_entry(year: int, month: int, reading: int) -> bool:\n        return is_valid_service_month(year, month) and is_valid_odometer_reading(reading)\n\n    def is_valid_service_history(history: list) -> bool:\n        if not history:\n            return False\n\n        prev_reading = 0\n        prev_month = history[0][1]\n        prev_year = history[0][0]\n\n        for year, month, reading in history:\n            if not is_valid_service_entry(year, month, reading):\n                return False\n\n            days = days_in_month(year, month)\n            current_reading = prev_reading + days * 1000\n\n            if reading != current_reading:\n                return False\n\n            prev_reading = reading\n            prev_month = month\n            prev_year = year\n\n        return True\n\n    def service_interval(history: list) -> int:\n        if not history:\n            return 0\n\n        interval = 30000\n        prev_reading = 0\n        prev_month = history[0][1]\n        prev_year = history[0][0]\n\n        for year, month, reading in history:\n            days = days_in_month(year, month)\n            current_reading = prev_reading + days * 1000\n\n            if current_reading - prev_reading >= interval:\n                interval = current_reading - prev_reading\n\n            prev_reading = reading\n            prev_month = month\n            prev_year = year\n\n        return interval\n\n    def sufficient_service(history: list) -> bool:\n        interval = service_interval(history)\n        return interval <= 30000\n\n    def tampered_odometer(history: list) -> bool:\n        prev_reading = 0\n        prev_month = history[0][1]\n        prev_year = history[0][0]\n\n        for year, month, reading in history:\n            days = days_in_month(year, month)\n            current_reading = prev_reading + days * 1000\n\n            if reading != current_reading:\n                return True\n\n            prev_reading = reading\n            prev_month = month\n            prev_year = year\n\n        return False\n\n    service_history = []\n    for _ in range(int(stdin[0])):\n        year, month, odometer = map(int, stdin[1 + _].split())\n        service_history.append((year, month, odometer))\n\n    if not is_valid_service_history(service_history):\n        return \"invalid service history\"\n\n    if tampered_odometer(service_history):\n        return \"tampered odometer\"\n\n    if sufficient_service(service_history):\n        return \"seems legit\"\n\n    return \"insufficient service\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    service_history = []\n    n, s = stdin.split(\"\\n\")\n    n = int(n)\n\n    for entry in s.split(\"\\n\"):\n        year, month, odometer = entry.split()\n        year, month, odometer = int(year), int(month), int(odometer)\n        service_history.append((year, month, odometer))\n\n    total_distance = 0\n    current_month = 0\n    for year, month, odometer in service_history:\n        if year < 2017 or (year == 2017 and month < 4):\n            return \"tampered odometer\"\n\n        current_month = year * 12 + month\n        distance = odometer\n\n        while current_month > (year * 12 + month):\n            if distance > 100000:\n                distance -= 100000\n            else:\n                return \"tampered odometer\"\n            current_month -= 1\n\n        total_distance += distance\n\n    if total_distance < 2000 * 12 or total_distance > 20000 * 12:\n        return \"insufficient service\"\n    else:\n        return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    entries = []\n    for line in input_data[1:]:\n        y, m, o = map(int, line.split())\n        entries.append((y, m, o))\n\n    last_month = -1\n    last_year = -1\n    total_distance = 0\n\n    for entry in entries:\n        year, month, reading = entry\n        if month < last_month or (month == last_month and year < last_year):\n            return \"tampered odometer\"\n\n        last_month = month\n        last_year = year\n\n        if reading > total_distance:\n            total_distance = reading\n\n    if total_distance >= 100000:\n        total_distance = 0\n\n    service_interval = 30000\n    service_months = 12\n    last_service = None\n\n    for entry in entries:\n        year, month, reading = entry\n        if last_service is not None:\n            service_time = (year - last_service[0]) * 12 + (month - last_service[1])\n            if service_time > service_months or (service_time == service_months and total_distance >= service_interval):\n                total_distance = 0\n                last_service = entry\n        else:\n            last_service = entry\n\n    if total_distance < service_interval:\n        return \"insufficient service\"\n    else:\n        return \"seems legit\"\n\ndef"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_leap_year(year: int) -> bool:\n        return (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month in [4, 6, 9, 11]:\n            return 30\n        elif month == 2:\n            return 29 if is_leap_year(year) else 28\n        else:\n            return 31\n\n    def months_between(start_year: int, start_month: int, end_year: int, end_month: int) -> int:\n        total_months = end_month - start_month\n        total_months += 12 * (end_year - start_year - (1 if start_month > end_month else 0))\n        return total_months\n\n    def distance_between(year1: int, month1: int, year2: int, month2: int) -> int:\n        total_months = months_between(year1, month1, year2, month2)\n        total_days = 0\n        for i in range(total_months):\n            total_days += days_in_month(year1 + (i + 12) // 12, (i + 12) % 12 + 1)\n        return total_days * 10000 // total_months\n\n    def service_distance(year: int, month: int) -> int:\n        for entry in service_history:\n            if entry[0] == year and entry[1] == month:\n                return entry[2]\n        return None\n\n    def service_months(year: int) -> int:\n        for entry in service_history:\n            if entry[0] == year:\n                return months_between(1950, 1, entry[0], entry[1])\n        return None\n\n    def service_distance_between(start_year: int, start_month: int, end_year: int, end_month: int) -> int:\n        total_distance = 0\n        for year in range(start_year, end_year):\n            start_month_of_year = 1\n            if year == start_year:\n                start_month_of_year = start_month\n            for month in range(start_month_of_year, 13):\n                if year == end_year and month < end_month:\n                    continue\n                service_distance_for_month = service_distance(year, month)\n                if service_distance_for_month is not None:\n                    total_distance += service_distance_for_month\n        return total_distance\n\n    service_history = []\n    for line in stdin.splitlines():\n        year, month, odometer = map(int, line.split())\n        service_history.append((year, month, odometer))\n\n    if service_history[0][2] != 0:\n        return \"tampered odometer\"\n\n    if service_history[-1][0] == 2017 and service_history[-1][1] >= 4:\n        distance_travelled = service_distance_between(2017, 4, 2018, 8)\n        if distance_travelled < 12000:\n            return \"insufficient service\"\n\n    if service_history[-1][0] == 2018 and service_history[-1][1] >= 8:\n        distance_travelled = service_distance_between(2018, 8, 2019, 4)\n        if distance_travelled < 30000:\n            return \"insufficient service\"\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.split()[0])\n    service_history = []\n    for i in range(1, n + 1):\n        service_history.append([int(x) for x in stdin.split()[i].split()])\n\n    # Determine if the odometer has been tampered with\n    last_reading = 0\n    for entry in service_history:\n        if entry[2] > 99999:\n            return \"tampered odometer\"\n        last_reading = entry[2]\n\n    # Determine if the car has been serviced frequently enough\n    year_month_map = {}\n    for entry in service_history:\n        year_month = (entry[0] - 1900) * 12 + entry[1] - 1\n        if year_month not in year_month_map:\n            year_month_map[year_month] = entry[2]\n        else:\n            year_month_map[year_month] += entry[2] - last_reading\n            last_reading = entry[2]\n    service_interval = 30000\n    service_interval_months = 12\n    last_service_date = max(year_month_map.keys())\n    if last_service_date >= 11:\n        last_service_date_year = last_service_date // 12\n        last_service_date_month = last_service_date % 12 + 1\n        if last_service_date_month == 1:\n            last_service_date_year -= 1\n        next_service_date = (last_service_date_year * 12 + last_service_date_month - service_interval_months) % 12 + 1\n        next_service_date_year = last_service_date_year + (next_service_date - 1) // 12\n        next_service_date_month = (next_service_date - 1) % 12 + 1\n    else:\n        next_service_date = last_service_date + 1\n        next_service_date_year = next_service_date // 12\n        next_service_date_month = next_service_date % 12 + 1\n    next_service_date = (next_service_date_year - 1900) * 12 + next_service_date_month - 1\n    for entry in service_history:\n        if entry[0] * 12 + entry[1] - 1 < next_service_date:\n            if entry[2] < last_reading:\n                return \"tampered odometer\"\n            if entry[2] > last_reading + service_interval:\n                return \"insufficient service\"\n    return \"seems legit\"\n"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_month_end(year: int, month: int) -> int:\n        end_date = datetime.datetime(year, month, 1) + datetime.timedelta(days=31)\n        return end_date.day\n\n    def is_leap_year(year: int) -> bool:\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_month(year: int, month: int) -> int:\n        if month == 2 and is_leap_year(year):\n            return 29\n        elif month in [4, 6, 9, 11]:\n            return 30\n        else:\n            return 31\n\n    def parse_service_entry(entry: str) -> Tuple[int, int, int]:\n        year, month, odometer = map(int, entry.split())\n        return year, month, odometer\n\n    def check_service_interval(odometer_readings: List[Tuple[int, int, int]]) -> bool:\n        last_service_date = datetime.datetime(1950, 1, 1)\n        service_interval = datetime.timedelta(days=30)\n        for year, month, odometer in odometer_readings:\n            service_date = datetime.datetime(year, month, 1)\n            if service_date - last_service_date < service_interval:\n                return False\n            last_service_date = service_date\n        return True\n\n    def check_odometer_interval(odometer_readings: List[Tuple[int, int, int]]) -> bool:\n        last_odometer = 0\n        for year, month, odometer in odometer_readings:\n            if odometer < last_odometer:\n                return False\n            last_odometer = odometer\n        return True\n\n    def check_tampered_odometer(odometer_readings: List[Tuple[int, int, int]]) -> bool:\n        last_odometer = 0\n        for year, month, odometer in odometer_readings:\n            if odometer < last_odometer:\n                return True\n            last_odometer = odometer\n        return False\n\n    def check_sufficient_service(odometer_readings: List[Tuple[int, int, int]]) -> bool:\n        service_interval = datetime.timedelta(days=30)\n        last_service_date = datetime.datetime(1950, 1, 1)\n        last_odometer = 0\n        for year, month, odometer in odometer_readings:\n            service_date = datetime.datetime(year, month, 1)\n            if (service_date - last_service_date) > service_interval:\n                return False\n            last_service_date = service_date\n            last_odometer = odometer\n        return True\n\n    lines = stdin.splitlines()\n    num_entries = int(lines[0])\n    odometer_readings = [parse_service_entry(line) for line in lines[1:]]\n\n    if num_entries < 2:\n        return \"seems legit\"\n\n    if check_tampered_odometer(odometer_readings):\n        return \"tampered odometer\"\n\n    if not check_service_interval(odometer_readings) and not check_sufficient_service(odometer_readings):\n        return \"insufficient service\"\n\n    return \"seems legit\"\n\ninput_stdin = \"\"\"3\n2017 4 0\n2017 8 12000\n2018 8 42000\n\"\"\"\n\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(service_history: List[Tuple[int, int, int]]) -> bool:\n        distance_traveled = 0\n        for year, month, odometer in service_history:\n            distance_traveled += odometer\n            if distance_traveled > 100000:\n                distance_traveled = distance_traveled % 100000\n        \n        # Check if odometer reading is outside expected range\n        return not all(0 <= odometer <= 99999 for _, _, odometer in service_history)\n\n    def is_legit(service_history: List[Tuple[int, int, int]]) -> bool:\n        current_date = date(1900, 1, 1)\n        previous_date = date(1900, 1, 1)\n        previous_odometer = 0\n\n        for year, month, odometer in service_history:\n            current_date = date(year, month, 1)\n            time_delta = current_date - previous_date\n\n            if time_delta.days > 0:\n                distance_traveled = odometer - previous_odometer\n                if distance_traveled > 30000:\n                    return False\n\n                if time_delta.days > 30:\n                    days_since_last_service = time_delta.days - (time_delta.days // 30) * 30\n                    if days_since_last_service > 12:\n                        return False\n\n            previous_date = current_date\n            previous_odometer = odometer\n\n        return True\n\n    def main(service_history: List[Tuple[int, int, int]]) -> str:\n        if is_tampered(service_history):\n            return \"tampered odometer\"\n        elif is_legit(service_history):\n            return \"seems legit\"\n        else:\n            return \"insufficient service\"\n\n    stdin = [s.strip() for s in stdin.splitlines()]\n    input_data = list(map(int, stdin[1:]))\n    service_history = [(input_data[i], input_data[i+1], input_data[i+2]) for i in range(0, len(input_data), 3)]\n    return main(service_history)"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_month(year: int, month: int, service_year: int, service_month: int) -> bool:\n        if year == service_year:\n            return 1 <= month - service_month <= 11\n        elif year == service_year + 1:\n            return month == 1\n        else:\n            return False\n\n    def is_valid_service(service_year: int, service_month: int, mileage: int, last_service_year: int, last_service_month: int, last_mileage: int) -> bool:\n        if last_mileage + 2000 <= mileage <= last_mileage + 20000:\n            if is_valid_month(service_year, service_month, last_service_year, last_service_month):\n                return True\n        return False\n\n    n = int(stdin)\n    service_history = []\n    for _ in range(n):\n        year, month, mileage = map(int, input().split())\n        service_history.append((year, month, mileage))\n\n    if service_history[0][2] != 0:\n        return \"tampered odometer\"\n\n    last_service_year, last_service_month, last_mileage = service_history[0]\n    for year, month, mileage in service_history[1:]:\n        if not is_valid_service(year, month, mileage, last_service_year, last_service_month, last_mileage):\n            return \"insufficient service\"\n        last_service_year, last_service_month, last_mileage = year, month, mileage\n\n    return \"seems legit\""
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(history: list) -> bool:\n        for i in range(1, len(history)):\n            distance = history[i][2] - history[i - 1][2]\n            if distance > 99999:\n                return True\n        return False\n\n    def is_sufficient_service(history: list) -> bool:\n        distance = 0\n        for entry in history:\n            distance += entry[2]\n        return distance >= 30000 or history[-1][0] - history[0][0] >= 12\n\n    input_data = stdin.split('\\n')\n    entries = []\n    for entry in input_data[1:]:\n        year, month, odometer = map(int, entry.split())\n        entries.append([year, month, odometer])\n\n    if is_tampered(entries):\n        return \"tampered odometer\"\n\n    if is_sufficient_service(entries):\n        return \"seems legit\"\n\n    return \"insufficient service\" "
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n    from functools import reduce\n\n    def color_graph(adj_matrix: list) -> int:\n        n = len(adj_matrix)\n        colors = set(range(n))\n        used_colors = set()\n        vertices = set(range(n))\n\n        def dfs(u: int, color: int):\n            nonlocal used_colors, vertices\n            used_colors.add(color)\n            for v in adj_matrix[u]:\n                dfs(v, (color + 1) % n)\n\n        while vertices:\n            u = vertices.pop()\n            for color in colors:\n                if color not in used_colors:\n                    dfs(u, color)\n                    break\n\n        return len(used_colors)\n\n    def generate_permutations(adj_matrix: list) -> list:\n        n = len(adj_matrix)\n        permutations_list = []\n        for perm in permutations(range(n)):\n            perm_matrix = [[] for _ in range(n)]\n            for i in range(n):\n                for j in range(n):\n                    if adj_matrix[perm[i]][perm[j]]:\n                        perm_matrix[i].append(j)\n            permutations_list.append(perm_matrix)\n        return permutations_list\n\n    def min_colors(adj_matrix: list) -> int:\n        return min(color_graph(perm_matrix) for perm_matrix in generate_permutations(adj_matrix))\n\n    # read input\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    adj_matrix = [[] for _ in range(n)]\n    for i in range(1, n + 1):\n        row = [int(x) for x in lines[i].split()]\n        for j in range(len(row)):\n            adj_matrix[i - 1].append(row[j])\n\n    # compute minimum number of colors\n    result = min_colors(adj_matrix)\n\n    return str(result)\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin.split(\"\\n\")[0])\n    graph = []\n    for i in range(1, N+1):\n        graph.append([int(x) for x in stdin.split(\"\\n\")[i].split(\" \")])\n\n    # Compute the minimum number of colors required\n    def min_colors(graph: list) -> int:\n        # Compute the degree of each vertex\n        degrees = [0] * N\n        for adj in graph:\n            for v in adj:\n                degrees[v] += 1\n\n        # Find the maximum degree vertex and remove it\n        max_degree = max(degrees)\n        max_degree_vertex = degrees.index(max_degree)\n        degrees.pop(max_degree_vertex)\n\n        # Compute the coloring for the remaining vertices\n        colors = [0] * N\n        colors[max_degree_vertex] = 1\n        color_count = 1\n        for i in range(len(graph)):\n            if colors[i] != 0:\n                continue\n            adj_colors = set(colors[j] for adj in graph if i in adj for j in adj)\n            for c in range(1, N+1):\n                if c not in adj_colors:\n                    colors[i] = c\n                    color_count += 1\n                    break\n\n        return color_count\n\n    return min_colors(graph)"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(N)]\n    used_colors = set()\n    max_color = 0\n\n    for i in range(1, N+1):\n        line = stdin.splitlines()[i]\n        vertices = line.split()\n        for vertex in vertices:\n            graph[i-1].append(int(vertex))\n\n    def dfs(node: int, color: int) -> None:\n        nonlocal max_color, used_colors\n        used_colors.add(color)\n        max_color = max(max_color, color)\n        for neighbor in graph[node]:\n            if neighbor in used_colors:\n                continue\n            dfs(neighbor, (color+1) % 3)\n\n    dfs(0, 0)\n    return max_color + 1\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_bipartite(graph: list) -> bool:\n        n = len(graph)\n        color = [-1] * n\n        color[0] = 0\n\n        def dfs(u: int, c: int) -> bool:\n            for v in graph[u]:\n                if color[v] == c:\n                    return False\n                if color[v] == -1 and not dfs(v, 1 - c):\n                    return False\n            color[u] = c\n            return True\n\n        for i in range(n):\n            if color[i] == -1 and not dfs(i, 0):\n                return False\n        return True\n\n    def min_coloring(graph: list) -> int:\n        n = len(graph)\n        colors = set(range(n))\n        used_colors = set()\n        for i in range(n):\n            used_colors.add(graph[i][0])\n        for i in range(n):\n            colors.difference_update(used_colors)\n            used_colors.add(colors.pop())\n        return len(used_colors)\n\n    def process_input(input_data: str) -> list:\n        lines = input_data.strip().split('\\n')\n        n = int(lines[0])\n        graph = [[] for _ in range(n)]\n        for i in range(1, n):\n            for v in lines[i].split():\n                graph[i - 1].append(int(v))\n        for i in range(n):\n            graph[i] = sorted(list(set(graph[i])))\n        return graph\n\n    graph = process_input(stdin)\n    if is_bipartite(graph):\n        return str(min_coloring(graph))\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    adj_list = [[] for _ in range(N)]\n    for i in range(1, N):\n        vertex_list = list(map(int, input_list[i].split()))\n        for j in range(len(vertex_list)):\n            adj_list[vertex_list[j]].append(i)\n    \n    def dfs(graph, visited, color, vertex, colors):\n        visited[vertex] = True\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                for c in colors:\n                    if c not in color[neighbor] and c not in color[vertex]:\n                        color[neighbor] = color[vertex] + [c]\n                        if dfs(graph, visited, color, neighbor, colors):\n                            return True\n                        else:\n                            color[neighbor] = []\n                return False\n        return True\n    \n    colors = [[] for _ in range(N)]\n    color = [[] for _ in range(N)]\n    for i in range(N):\n        visited = [False] * N\n        if not dfs(adj_list, visited, color, i, colors):\n            return \"Not possible\"\n    \n    max_colors = 0\n    for c in colors:\n        max_colors = max(max_colors, len(c))\n    return max_colors"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    graph = [[] for _ in range(N)]\n    for i in range(1, N):\n        for j in map(int, lines[i].split()):\n            graph[i].append(j)\n            graph[j].append(i)\n\n    # Initialize colors\n    colors = [-1] * N\n\n    # Assign colors to vertices in DFS order\n    def dfs(v):\n        nonlocal colors\n        for u in graph[v]:\n            if colors[u] == -1:\n                colors[u] = 1 - colors[v]\n                dfs(u)\n\n    dfs(0)\n\n    # Count the number of colors used\n    color_count = len(set(colors))\n\n    return str(color_count)"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n\n    n = int(input_list[0])\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n        edges = list(map(int, input_list[i].split()))\n        for edge in edges:\n            graph[edge].append(i)\n\n    def dfs(node, color, visited, colors):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                for c in colors:\n                    if c != color and (neighbor, c) not in used_colors:\n                        used_colors.add((neighbor, c))\n                        if dfs(neighbor, c, visited, colors):\n                            return True\n                return False\n        return True\n\n    max_colors = 1\n    for start_color in range(n):\n        used_colors = set()\n        visited = [False] * n\n        if dfs(0, start_color, visited, range(n)):\n            max_colors = max(max_colors, start_color + 1)\n\n    return max_colors\n"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    N = int(stdin[0].strip())\n    graph = defaultdict(set)\n    for i in range(1, N+1):\n        line = stdin[i].strip().split()\n        for j in range(len(line)):\n            graph[int(line[j])].add(i)\n\n    def dfs(node, colors, visited):\n        if visited[node]:\n            return False\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not dfs(neighbor, colors, visited):\n                return False\n        return True\n\n    def color_graph(N, graph, colors):\n        visited = [False] * N\n        for node in range(N):\n            if not dfs(node, colors, visited):\n                return False\n        return True\n\n    colors = set(range(N))\n    while not color_graph(N, graph, colors):\n        colors.remove(min(colors))\n\n    return len(colors)"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input string to array of integers\n    input_array = [list(map(int, line.split())) for line in stdin.split('\\n')]\n    \n    # Calculate the minimum number of colors required to color the graph\n    def min_color(graph: list) -> int:\n        n = len(graph)\n        colors = [0] * n  # Initialize colors array\n        used_colors = 0\n        \n        # Color the vertices using the greedy algorithm\n        for i in range(n):\n            for j in graph[i]:\n                if colors[j] == 0 and colors[i] == 0:\n                    used_colors += 1\n                    colors[j] = 1\n                    colors[i] = 1\n                    break\n                elif colors[j] == colors[i]:\n                    # Swap colors if the vertices are adjacent\n                    colors[j], colors[i] = colors[i], colors[j]\n        \n        return used_colors\n    \n    # Calculate the minimum number of colors required for each graph\n    min_color_array = []\n    for graph in input_array:\n        min_color_array.append(min_color(graph))\n    \n    # Output the minimum number of colors required for each graph\n    return '\\n'.join(str(color) for color in min_color_array)"
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph: dict, visited: set, colors: dict, vertex: int) -> int:\n        visited.add(vertex)\n        max_color = 0\n        for neighbor in graph[vertex]:\n            if neighbor not in visited:\n                max_color = max(max_color, dfs(graph, visited, colors, neighbor))\n        if colors.get(vertex) is None or max_color > colors[vertex]:\n            colors[vertex] = max_color + 1\n        return colors[vertex]\n\n    N = int(stdin.split('\\n')[0])\n    graph = {}\n    for i in range(1, N + 1):\n        line = stdin.split('\\n')[i].split(' ')\n        graph[i - 1] = [int(x) for x in line]\n    visited = set()\n    colors = {}\n    max_color = 0\n    for vertex in graph:\n        if vertex not in visited:\n            max_color = max(max_color, dfs(graph, visited, colors, vertex))\n    return max_color + 1\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(painters, used_colors):\n        if len(used_colors) > 3:\n            return False\n        for painter in painters:\n            for section in range(painter[1], painter[2] + 1):\n                if section_colors[section] is not None:\n                    if section_colors[section] != painter[0] and section_colors[section] in used_colors:\n                        return False\n        return True\n\n    def find_acceptable_offers(painters, used_colors):\n        min_offers = float('inf')\n        for combination in itertools.combinations(painters, len(used_colors)):\n            offers = 0\n            for painter in combination:\n                offers += painter[2] - painter[1] + 1\n            min_offers = min(min_offers, offers)\n        return min_offers\n\n    n = int(stdin[0])\n    painters = []\n    for i in range(1, n + 1):\n        color, a, b = stdin[i].split()\n        painters.append((color, int(a), int(b)))\n\n    section_colors = [None] * 10001\n    for painter in painters:\n        for section in range(painter[1], painter[2] + 1):\n            section_colors[section] = painter[0]\n\n    used_colors = set()\n    for painter in painters:\n        used_colors.add(painter[0])\n\n    if is_possible(painters, used_colors):\n        return find_acceptable_offers(painters, used_colors)\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_subset(a, b):\n        return a[0] <= b[0] and a[1] >= b[1]\n\n    def color_count(offers):\n        colors = set()\n        for offer in offers:\n            colors.add(offer[0])\n        return len(colors)\n\n    N, offers = int(stdin.splitlines()[0]), [line.split() for line in stdin.splitlines()[1:]]\n    offers = sorted(offers, key=lambda x: (int(x[1]), int(x[2]), x[0]))\n\n    if color_count(offers) > 3:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    current_offer = offers[0]\n\n    for i in range(1, N):\n        if is_subset(offers[i], current_offer):\n            continue\n        result.append(current_offer)\n        current_offer = offers[i]\n\n    result.append(current_offer)\n\n    return str(len(result))\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_data = list(map(str.split, stdin.strip().split(\"\\n\")))\n\n    # Initialize variables\n    offers = []\n    num_colors = 0\n    max_section = 0\n\n    # Iterate through input\n    for color, start, end in input_data:\n        offers.append((color, int(start), int(end)))\n        num_colors = max(num_colors, len(color))\n        max_section = max(max_section, int(end))\n\n    # Check if it's possible to satisfy the requirements\n    if max_section != 10000:\n        return \"IMPOSSIBLE\"\n\n    # Sort offers by section range\n    offers.sort(key=lambda x: (x[2] - x[1], x[1]))\n\n    # Initialize variables\n    num_offers = 0\n    sections_painted = [False] * 10001\n    used_colors = set()\n\n    # Iterate through offers\n    for color, start, end in offers:\n        # Check if the offer can be accepted\n        if len(used_colors) < 3 and not any(sections_painted[i] for i in range(start, end + 1)):\n            # Accept the offer\n            num_offers += 1\n            used_colors.add(color)\n            for i in range(start, end + 1):\n                sections_painted[i] = True\n        # If all colors are used or the offer cannot be accepted, stop iterating\n        else:\n            break\n\n    # Check if all sections are painted\n    if not all(sections_painted):\n        return \"IMPOSSIBLE\"\n\n    return num_offers"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    N = int(stdin)\n    offers = []\n    for _ in range(N):\n        offer = input().split()\n        color = offer[0]\n        start = int(offer[1])\n        end = int(offer[2])\n        offers.append((color, start, end))\n\n    # Sort the offers by start section\n    offers.sort(key=lambda x: x[1])\n\n    # Initialize the used colors set and the result\n    used_colors = set()\n    result = 0\n\n    # Iterate through the offers\n    for color, start, end in offers:\n        # Check if the color is already used\n        if color in used_colors:\n            continue\n\n        # Check if the color can be used with the current offer\n        if len(used_colors) < 3:\n            used_colors.add(color)\n            result += 1\n\n            # Check if the current offer can be extended to the next offer\n            for i, (_, start2, end2) in enumerate(offers[result:]):\n                if start2 <= end + 1 and end2 >= end + 1:\n                    end = end2\n                elif start2 > end + 1:\n                    break\n            continue\n\n        # Check if the current offer can be extended to the next offer\n        for i, (_, start2, end2) in enumerate(offers[result:]):\n            if start2 <= end + 1 and end2 >= end + 1:\n                end = end2\n            elif start2 > end + 1:\n                break\n\n        # If the offer cannot be extended, move to the next offer\n        if start > end:\n            continue\n\n        # Check if the current offer can be extended to the previous offer\n        for i, (_, start2, end2) in enumerate(offers[:result]):\n            if start2 <= start - 1 and end2 >= start - 1:\n                start = start2\n            elif start2 > start - 1:\n                break\n\n        # If the offer cannot be extended, move to the next offer\n        if start > end:\n            continue\n\n        # Check if the current offer can be extended to the previous offer\n        for i, (_, start2, end2) in enumerate(offers[:result]):\n            if start2 <= end + 1 and end2 >= end + 1:\n                end = end2\n            elif start2 > end + 1:\n                break\n\n        # If the offer cannot be extended, move to the next offer\n        if start > end:\n            continue\n\n        # If the offer can be extended, use the color and update the result\n        used_colors.add(color)\n        result += 1\n\n    # Check if the result is possible\n    if result == N:\n        return str(result)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, *offers = stdin.strip().split('\\n')\n    N = int(N)\n    offers = [offer.split() for offer in offers]\n\n    def paint_fence(offers):\n        colors = set(offer[0] for offer in offers)\n        if len(colors) > 3:\n            return False, None\n\n        fence = [False] * 10001\n        for offer in offers:\n            color, start, end = offer\n            for i in range(start, end + 1):\n                if fence[i]:\n                    return False, None\n                fence[i] = True\n        return True, None\n\n    for i in range(1, N + 1):\n        offers_i = [offer for offer in offers if offer[1] == str(i)]\n        result, _ = paint_fence(offers_i)\n        if result:\n            continue\n        for j in range(1, N + 1):\n            if j == i:\n                continue\n            offers_ij = [offer for offer in offers if offer[1] == str(j)]\n            result, _ = paint_fence(offers_ij + offers_i)\n            if result:\n                break\n        if result:\n            continue\n        return \"IMPOSSIBLE\"\n    return str(N)"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    offers = []\n    for _ in range(N):\n        color, start, end = input().split()\n        start, end = int(start), int(end)\n        offers.append((color, start, end))\n\n    min_num_offers = 1e9\n    for subset in combinations(offers, 3):\n        used_colors = set(offer[0] for offer in subset)\n        if len(used_colors) <= 3:\n            painted_sections = set()\n            for offer in subset:\n                for section in range(offer[1], offer[2] + 1):\n                    painted_sections.add(section)\n            if len(painted_sections) == 10000:\n                min_num_offers = min(min_num_offers, len(subset))\n\n    if min_num_offers < 1e9:\n        return str(min_num_offers)\n    else:\n        return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_offer(offer: str, used_colors: set) -> bool:\n        color, a, b = offer.split()\n        a, b = int(a), int(b)\n        if color in used_colors:\n            return False\n        if len(used_colors) >= 3:\n            return False\n        if any(used_colors & {c for c in range(a, b + 1)}):\n            return False\n        return True\n\n    def count_sections(offer: str) -> int:\n        _, a, b = offer.split()\n        return int(b) - int(a) + 1\n\n    N = int(stdin.splitlines()[0])\n    offers = stdin.splitlines()[1:]\n    used_colors = set()\n    min_count = float('inf')\n\n    for offer in offers:\n        if is_valid_offer(offer, used_colors):\n            min_count = min(min_count, count_sections(offer))\n            used_colors.add(offer.split()[0])\n        else:\n            continue\n\n    if min_count == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return min_count\n"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    offers = []\n    n = int(stdin.split(\"\\n\")[0])\n    for i in range(1, n + 1):\n        color, start, end = stdin.split(\"\\n\")[i].split()\n        offers.append((color, int(start), int(end)))\n    \n    for i in range(len(offers)):\n        for j in range(i+1, len(offers)):\n            if offers[i][1] <= offers[j][1] <= offers[i][2] and offers[i][1] <= offers[j][2] <= offers[i][2]:\n                return \"IMPOSSIBLE\"\n            elif offers[i][1] > offers[j][2]:\n                break\n    \n    for i in range(len(offers)):\n        if offers[i][2] > offers[i][1]:\n            return i+1\n    \n    return \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def paint_fence(offers: list, sections: int, colors: int) -> int:\n        if sections < 1:\n            return 0\n        if sections == 1:\n            return 1\n        if sections == 2:\n            return 2 if colors >= 2 else 1\n        if sections == 3:\n            return 3 if colors >= 3 else 2\n        return 4\n\n    def get_max_color_sections(offers: list) -> int:\n        max_color_sections = 0\n        colors = set()\n        for offer in offers:\n            colors.add(offer[0])\n            if offer[1] == 1:\n                max_color_sections += 1\n            else:\n                max_color_sections += offer[2] - offer[1] + 1\n        return min(3, max_color_sections)\n\n    def get_painting_offers(offers: list) -> list:\n        painting_offers = []\n        for offer in offers:\n            if offer[0] in colors:\n                painting_offers.append(offer)\n            else:\n                colors.add(offer[0])\n                if len(colors) <= 3:\n                    painting_offers.append(offer)\n        return painting_offers\n\n    def is_possible(offers: list, sections: int, colors: int) -> bool:\n        painted_sections = 0\n        for offer in offers:\n            painted_sections += offer[2] - offer[1] + 1\n        return painted_sections == sections and colors <= 3\n\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    offers = [line.split() for line in input_lines[1:]]\n    sections = 10000\n    colors = get_max_color_sections(offers)\n\n    if colors > 3:\n        return \"IMPOSSIBLE\"\n\n    painting_offers = get_painting_offers(offers)\n    max_color_sections = get_max_color_sections(painting_offers)\n    painted_sections = sum([offer[2] - offer[1] + 1 for offer in painting_offers])\n\n    if is_possible(painting_offers, sections, colors):\n        return max(paint_fence(painting_offers, sections, colors), max_color_sections)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def paint_fence(painter_offers: list) -> bool:\n        colors = set()\n        sections = set()\n        for offer in painter_offers:\n            color, start, end = offer\n            if len(colors) < 3:\n                colors.add(color)\n            sections |= set(range(start, end + 1))\n        return len(sections) == 10000 and len(colors) <= 3\n\n    offers = stdin.split(\"\\n\")\n    offers = [offer.split() for offer in offers]\n    min_offers = 10000\n    for i in range(2, len(offers) + 1):\n        for combo in combinations(offers, i):\n            if paint_fence(combo):\n                min_offers = min(min_offers, i)\n                if min_offers == 1:\n                    return \"IMPOSSIBLE\"\n    return min_offers - 1"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> str:\n        s = s.upper()\n        i = 0\n        max_factor = \"\"\n        while i < len(s):\n            j = i + 1\n            while j < len(s) and s[i] == s[j]:\n                j += 1\n            max_factor = f\"({s[i]}^{j - i})\"\n            i = j\n        return max_factor\n\n    def weight(s: str) -> int:\n        return sum(len(substr) for substr in s[1:-1].split(\")^\")) + 2\n\n    s = stdin\n    max_factor = factorize(s)\n    return weight(max_factor)\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_irreducible(substring: str) -> bool:\n        for i in range(len(substring)):\n            for j in range(i+2, len(substring)):\n                if substring[i:j] in substring[j:]:\n                    return False\n        return True\n\n    def factoring(s: str) -> str:\n        factorings = []\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                j = i + 1\n                while j < len(s) and s[j] == s[i-1]:\n                    j += 1\n                factorings.append(f\"({s[i-1]}^{j-i})\")\n                i = j - 1\n        return factorings\n\n    def max_factoring(factorings: list) -> str:\n        max_weight = 0\n        for f in factorings:\n            weight = len(f) - f.count(\"(\") - f.count(\")\") - f.count(\"^\")\n            if weight < max_weight:\n                continue\n            max_weight = weight\n        return max_weight\n\n    s = stdin.upper()\n    factorings = factoring(s)\n    if not factorings:\n        return \"1\"\n    max_factorings = [f for f in factorings if is_irreducible(s[i+1:j-1])]\n    return str(max_factoring(max_factorings))\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> str:\n        def find_repeat(s: str, start: int) -> int:\n            for i in range(start + 1, len(s)):\n                if s[i] == s[start]:\n                    return i\n            return -1\n\n        result = \"\"\n        i = 0\n        while i < len(s):\n            repeat_start = i\n            repeat_end = find_repeat(s, repeat_start)\n            if repeat_end == -1:\n                result += s[i]\n                i += 1\n            else:\n                result += s[repeat_start] + \"(\" + s[repeat_start] + \")^\" + str(1 + repeat_end - repeat_start)\n                i = repeat_end + 1\n        return result\n\n    def find_max_factoring(s: str) -> str:\n        factoring = factorize(s)\n        max_weight = float('inf')\n        max_factoring = \"\"\n\n        for i in range(1, len(factoring)):\n            if factoring[i] == \"(\":\n                weight = i - 1 + len(factoring) - factoring[i:].index(\")\")\n                if weight < max_weight:\n                    max_weight = weight\n                    max_factoring = factoring[:i - 1]\n\n        return str(max_weight)\n\n    return find_max_factoring(stdin.upper())"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str, max_len: int) -> str:\n        if len(s) == 0 or len(s) == 1:\n            return s\n        for i in range(1, len(s)):\n            if s[i] == s[i-1]:\n                return \"(\" + factorize(s[:i], max_len) + s[i] + \")^\" + str(max_len)\n        return s\n\n    return len(factorize(stdin, max_len=1))"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> str:\n        max_weight = 0\n        for length in range(1, len(s) // 2 + 1):\n            for i in range(len(s) - length + 1):\n                substring = s[i:i + length]\n                if substring * (len(s) // length) == s:\n                    weight = length + (len(s) // length) * (length - 1)\n                    if weight > max_weight:\n                        max_weight = weight\n        return max_weight\n\n    return factorize(stdin.strip())\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_irreducible(substring: str) -> bool:\n        for i in range(len(substring) - 1):\n            if substring[i] == substring[i + 1]:\n                return False\n        return True\n\n    def find_max_weight(stdin: str) -> int:\n        weight = 0\n        for i in range(len(stdin)):\n            for j in range(i + 1, len(stdin) + 1):\n                substring = stdin[i:j]\n                if is_irreducible(substring):\n                    weight = max(weight, len(substring))\n        return weight\n\n    weight = find_max_weight(stdin)\n    return str(weight)\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def factor(s: str) -> str:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return f\"({s[i]})^{i + 1}\" + s[i + 1:]\n        return s\n\n    def irreducible(s: str) -> str:\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                return f\"({s[i]})^2\"\n        return s\n\n    s = stdin\n    s = factor(s)\n    s = irreducible(s)\n    return len(s)\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str, i: int) -> str:\n        if i == len(s):\n            return \"\"\n        j = i + 1\n        while j < len(s) and s[j] == s[i]:\n            j += 1\n        if j == i + 1:\n            return factorize(s, j) + s[i]\n        else:\n            return \"(\" + factorize(s, j) + s[i] + \")^\" + str(j - i)\n\n    def maximal_factorization(s: str) -> int:\n        factoring = factorize(s, 0)\n        weight = len(factoring) - factoring.count(\"(\") - factoring.count(\")\") - factoring.count(\"^\")\n        return weight\n\n    input_string = stdin.strip()\n    return str(maximal_factorization(input_string))\n"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Define a function to check if a string is irreducible\n    def is_irreducible(s: str) -> bool:\n        for i in range(len(s) - 1):\n            if s[i:i+2] == s[i+2:i+4]:\n                return False\n        return True\n\n    # Define a function to find the weight of a factoring\n    def factoring_weight(factoring: str) -> int:\n        weight = 0\n        i = 0\n        while i < len(factoring):\n            if factoring[i] == '(':\n                j = factoring.find(')', i)\n                weight += len(factoring[i+1:j])\n                i = j + 1\n            else:\n                weight += 1\n                i += 1\n        return weight\n\n    # Define a function to find the maximal factoring\n    def maximal_factoring(s: str) -> int:\n        max_weight = 0\n        for i in range(len(s) - 1):\n            for j in range(i + 2, len(s) - 1):\n                if s[i:j] == s[j:j+2]:\n                    factoring = '(' + s[i:j] + ')^2'\n                    weight = factoring_weight(factoring)\n                    if weight > max_weight:\n                        max_weight = weight\n        return max_weight\n\n    # Define a function to find the weight of the input string\n    def input_weight(stdin: str) -> int:\n        s = stdin.upper()\n        if is_irreducible(s):\n            return len(s)\n        else:\n            return maximal_factoring(s)\n\n    # Test the function with the given examples\n    stdin = \"PRATTATTATTIC\"\n    print(solution(stdin))  # Output: 6\n\n    stdin = \"GGGGGGGGG\"\n    print(solution(stdin))  # Output: 1\n\n    stdin = \"PRIME\"\n    print(solution(stdin))  # Output: 5\n\n    stdin = \"BABBABABBABBA\"\n    print(solution(stdin))  # Output: 6\n\n    # Get the input from the user\n    stdin = input(\"Enter a string: \")\n    result = solution(stdin)\n    print(\"Weight of the maximal factoring:\", result) "
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def factor(s: str) -> str:\n        if len(s) <= 1:\n            return s\n        max_factor = ''\n        for i in range(len(s)):\n            if i == 0 or s[i] != s[i - 1]:\n                factor, weight = factor(s[i + 1:])\n                if weight < len(max_factor) or (weight == len(max_factor) and len(factor) < len(max_factor)):\n                    max_factor = factor\n        return max_factor\n\n    def weigh(s: str) -> int:\n        return len(factor(s))\n\n    return weigh(stdin)\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(operation: str):\n        if operation[0] == 'D':\n            return ('Del', int(operation[2:]))\n        elif operation[0] == 'I':\n            return ('Ins', int(operation[2:]), operation[6])\n        elif operation[0] == 'E':\n            return ('End',)\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    def apply_operation(s: str, op: tuple) -> str:\n        if op[0] == 'Del':\n            return s[:op[1] - 1] + s[op[1]:]\n        elif op[0] == 'Ins':\n            return s[:op[1]] + op[2] + s[op[1]:]\n        elif op[0] == 'End':\n            return s\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    stdin = stdin.splitlines()\n    program1 = []\n    program2 = []\n\n    for line in stdin:\n        if line[0] == 'D' or line[0] == 'I' or line[0] == 'E':\n            program1.append(parse_operation(line))\n        elif line[0] == 'd' or line[0] == 'i' or line[0] == 'e':\n            program2.append(parse_operation(line.upper()))\n        else:\n            raise ValueError(\"Invalid line\")\n\n    s = ''\n    for op in program1:\n        s = apply_operation(s, op)\n\n    for op in program2:\n        s = apply_operation(s, op)\n\n    if s == '':\n        return '0'\n    else:\n        return '1'\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse_op(op):\n        if op[0] == 'D':\n            return ('Del', int(op[2:]))\n        else:\n            return ('Ins', int(op[2:]), op[5])\n\n    def execute(ops, s):\n        for op in ops:\n            if op[0] == 'Del':\n                s = s[:op[1]-1] + s[op[1]:]\n            else:\n                s = s[:op[1]] + op[2] + s[op[1]:]\n        return s\n\n    def is_equal(p1, p2):\n        if len(p1) != len(p2):\n            return False\n        for i in range(len(p1)):\n            if p1[i] != p2[i]:\n                return False\n        return True\n\n    stdin = stdin.split('\\n')\n    prog1 = []\n    prog2 = []\n    for line in stdin:\n        if line[0] == 'D':\n            prog1.append(line)\n        elif line[0] == 'I':\n            prog2.append(line)\n        else:\n            break\n\n    s = \"\".join([\"A\" for _ in range(10**10)])\n    p1_s = execute(prog1, s)\n    p2_s = execute(prog2, s)\n\n    return \"0\" if is_equal(p1_s, p2_s) else \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def execute_program(program: list) -> str:\n        dna_str = \"A\" * 1000000000\n        for operation in program:\n            if operation[0] == \"D\":\n                pos = int(operation[2:])\n                dna_str = dna_str[:pos-1] + dna_str[pos:]\n            elif operation[0] == \"I\":\n                pos, char = map(int, operation[2:].split())\n                dna_str = dna_str[:pos] + chr(char) + dna_str[pos:]\n        return dna_str\n\n    def compare_programs(program1: list, program2: list) -> str:\n        result1 = execute_program(program1)\n        result2 = execute_program(program2)\n        return \"0\" if result1 == result2 else \"1\"\n\n    programs = stdin.split(\"\\n\")\n    program1, program2 = [], []\n    for operation in programs:\n        if operation[0] == \"E\":\n            if program1 == program2:\n                return \"0\"\n            else:\n                return \"1\"\n        else:\n            program1.append(operation)\n            program2.append(operation)\n    return compare_programs(program1, program2)"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(operation: str) -> tuple:\n        if operation[0] == 'D':\n            return ('del', int(operation[2:]))\n        elif operation[0] == 'I':\n            return ('ins', int(operation[2:]), operation[6])\n        else:\n            raise ValueError(\"Invalid operation type\")\n\n    def apply_operation(seq: str, operation: tuple) -> str:\n        op_type, op_val = operation[0], operation[1]\n        if op_type == 'del':\n            return seq[:op_val - 1] + seq[op_val:]\n        elif op_type == 'ins':\n            return seq[:op_val] + operation[2] + seq[op_val:]\n        else:\n            raise ValueError(\"Invalid operation type\")\n\n    stdin_lines = stdin.split('\\n')\n    program1 = list(map(parse_operation, stdin_lines[:-1]))\n    program2 = list(map(parse_operation, stdin_lines[len(program1) + 1:]))\n\n    if program1 == program2:\n        return \"0\"\n    else:\n        return \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def perform_editing(program: str) -> str:\n        dna = [\"A\", \"C\", \"G\", \"T\"]\n        dna_sequence = \"\".join(dna)\n        dna_editing = {}\n\n        for op in program.split(\"\\n\"):\n            if op.startswith(\"D\"):\n                index = int(op.split()[1])\n                dna_editing[index - 1] = \"\".join(dna_sequence[index - 1:])\n                dna_sequence = dna_sequence[:index - 1]\n            elif op.startswith(\"I\"):\n                index, char = map(int, op.split()[1:3])\n                dna_editing[index - 1] = dna_sequence[index - 1] + char\n                dna_sequence = dna_sequence[:index] + dna_sequence[index:]\n            else:\n                break\n\n        return \"\".join(dna_sequence)\n\n    def compare_programs(prog1: str, prog2: str) -> bool:\n        result1 = perform_editing(prog1)\n        result2 = perform_editing(prog2)\n        return result1 == result2\n\n    programs = stdin.strip().split(\"\\n\\n\")\n    return \"0\" if compare_programs(programs[0], programs[1]) else \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    stdin = stdin.split('\\n')\n    programs = []\n    for line in stdin:\n        if line.startswith('D'):\n            programs[-1].append(('D', int(line[2:]) - 1))\n        elif line.startswith('I'):\n            programs[-1].append(('I', int(line[2:]) - 1, line[5]))\n        elif line.startswith('E'):\n            programs.append([])\n    \n    # compare programs\n    if len(programs) != 2:\n        return \"1\"\n    for p in programs[1]:\n        if p[0] == 'D':\n            programs[0].pop(p[1])\n        elif p[0] == 'I':\n            programs[0].insert(p[1], p[2])\n    return \"0\" if programs[0] == [] else \"1\""
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def parse_operation(operation: str) -> tuple:\n        if operation[0] == 'D':\n            return ('del', int(operation[2:]))\n        elif operation[0] == 'I':\n            pos, char = operation[2:].split(' ')\n            return ('ins', int(pos), char)\n        else:\n            return ('end',)\n\n    def execute_operation(sequence: str, operation: tuple) -> str:\n        if operation[0] == 'end':\n            return sequence\n        elif operation[0] == 'del':\n            pos = operation[1]\n            return sequence[:pos-1] + sequence[pos:]\n        elif operation[0] == 'ins':\n            pos, char = operation[1:]\n            return sequence[:pos] + char + sequence[pos:]\n\n    def is_identical(sequence1: str, sequence2: str) -> bool:\n        if len(sequence1) != len(sequence2):\n            return False\n        for i in range(len(sequence1)):\n            if sequence1[i] != sequence2[i]:\n                return False\n        return True\n\n    def compare_programs(program1: list, program2: list) -> bool:\n        sequence = ''\n        for operation in program1:\n            sequence = execute_operation(sequence, operation)\n        for operation in program2:\n            sequence = execute_operation(sequence, operation)\n        return is_identical(sequence, '')\n\n    stdin = stdin.strip().split('\\n')\n    program1 = []\n    for operation in stdin:\n        if operation == 'E':\n            break\n        program1.append(parse_operation(operation))\n    program2 = []\n    for operation in stdin[1:]:\n        if operation == 'E':\n            break\n        program2.append(parse_operation(operation))\n\n    result = '1'\n    if compare_programs(program1, program2):\n        result = '0'\n\n    return result"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    operations = stdin.split('\\n')\n    prog1 = []\n    prog2 = []\n    for op in operations:\n        if op.startswith('D'):\n            prog1.append(('D', int(op.split()[1])))\n            prog2.append(('D', int(op.split()[1])))\n        elif op.startswith('I'):\n            prog1.append(('I', int(op.split()[1]), op.split()[2]))\n            prog2.append(('I', int(op.split()[1]), op.split()[2]))\n        elif op == 'E':\n            prog1.append('E')\n            prog2.append('E')\n\n    for i in range(len(prog1)):\n        if prog1[i] != prog2[i]:\n            return '1'\n\n    return '0'\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def apply_op(s: str, op: str, pos: int, char: str):\n        if op == \"D\":\n            return s[:pos - 1] + s[pos:]\n        elif op == \"I\":\n            return s[:pos] + char + s[pos:]\n        else:\n            raise ValueError(\"Invalid operation: \" + op)\n\n    def check_identical(prog1: str, prog2: str) -> bool:\n        while prog1 and prog2:\n            op1, pos1, char1 = prog1.split(\" \", 2)\n            op2, pos2, char2 = prog2.split(\" \", 2)\n\n            if op1 != op2:\n                return False\n\n            if op1 == \"D\":\n                pos1, pos2 = int(pos1), int(pos2)\n                if pos1 != pos2:\n                    return False\n            elif op1 == \"I\":\n                pos1, pos2 = int(pos1), int(pos2)\n                char1, char2 = char1.upper(), char2.upper()\n                if pos1 != pos2 or char1 != char2:\n                    return False\n            else:\n                raise ValueError(\"Invalid operation: \" + op1)\n\n            prog1 = apply_op(prog1, op1, pos1, char1)\n            prog2 = apply_op(prog2, op2, pos2, char2)\n\n        return not prog1 and not prog2\n\n    programs = stdin.split(\"\\n\")\n    identical = True\n    for i in range(0, len(programs), 2):\n        identical = identical and check_identical(programs[i], programs[i + 1])\n        if not identical:\n            break\n\n    return \"0\" if identical else \"1\"\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operation(seq: str, op: str, pos: int, val: str):\n        if op == \"D\":\n            seq = seq[:pos-1] + seq[pos:]\n        else:\n            seq = seq[:pos] + val + seq[pos:]\n        return seq\n\n    program1 = []\n    program2 = []\n    for line in stdin.strip().split('\\n'):\n        op, *args = line.split()\n        if op == \"E\":\n            break\n        pos, val = int(args[0]), args[1]\n        program1.append((op, pos, val))\n\n    for line in stdin.strip().split('\\n'):\n        op, *args = line.split()\n        if op == \"E\":\n            break\n        pos, val = int(args[0]), args[1]\n        program2.append((op, pos, val))\n\n    if len(program1) != len(program2):\n        return \"1\"\n\n    long_seq = \"A\" * 10**9\n    for op1, pos1, val1 in program1:\n        long_seq = apply_operation(long_seq, op1, pos1, val1)\n\n    for op2, pos2, val2 in program2:\n        long_seq2 = long_seq.copy()\n        long_seq2 = apply_operation(long_seq2, op2, pos2, val2)\n        if long_seq2 != long_seq:\n            return \"1\"\n\n    return \"0\"\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inputs = list(map(int, stdin.split()))\n    d, b, f, t0, t1, t2 = inputs\n\n    # Calculate the maximum Bling that can be achieved\n    max_bling = b + f * 100 + (t0 * 3 + t1 * 3 + t2 * 3) * 100\n\n    # Output the maximum Bling as a string\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    max_bling = b\n\n    if d >= 10:\n        max_bling += 300 * 3\n        f += 300 * 3\n        t1 += 3\n    if d >= 7:\n        max_bling += 300 * 3\n        f += 300 * 3\n        t1 += 3\n    if d >= 4:\n        max_bling += 300 * 3\n        f += 300 * 3\n        t1 += 3\n\n    max_bling += 100 * f\n\n    return str(max_bling)\n\ninput_1 = \"4 0 1 0 0 0\"\ninput_2 = \"5 0 1 0 1 0\"\ninput_3 = \"6 0 1 1 0 0\"\ninput_4 = \"10 399 0 0 0 0\"\n\nprint(solution(input_1))  # Output: 300\nprint(solution(input_2))  # Output: 1900\nprint(solution(input_3))  # Output: 2300\nprint(solution(input_4))  # Output: 399\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum amount of Bling Johan can have after playing d days\n    max_bling = b + 100 * f + 500 * (t0 + t1 + t2)\n\n    # Return the maximum amount of Bling as an integer\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    days_left = input_data[0]\n    bling_balance = input_data[1]\n    fruits_left = input_data[2]\n    t0, t1, t2 = input_data[3], input_data[4], input_data[5]\n\n    max_bling = bling_balance\n\n    for i in range(days_left):\n        # Check if planting a fruit tree is beneficial\n        if i < 2:\n            fruit_tree_yield = 3\n            cost_per_fruit = 100\n            fruit_tree_cost = 400\n            max_fruits = 100\n        else:\n            fruit_tree_yield = 3\n            cost_per_fruit = 500\n            fruit_tree_cost = 400\n            max_fruits = 100\n\n        # Can we afford a fruit tree?\n        if bling_balance >= fruit_tree_cost:\n            bling_balance -= fruit_tree_cost\n\n            # Can we plant at least one fruit tree?\n            if max_fruits - fruits_left >= fruit_tree_yield:\n                fruits_left += fruit_tree_yield\n\n        # Can we sell any fruits?\n        if fruits_left > 0:\n            bling_balance += fruits_left * cost_per_fruit\n            fruits_left = 0\n\n        # Can we buy an exotic fruit?\n        if days_left == 1:\n            bling_balance -= 400\n            if bling_balance >= 0:\n                fruits_left += 1\n\n        # Can we plant or sell an exotic fruit?\n        if fruits_left > 0:\n            bling_balance += fruits_left * cost_per_fruit\n            fruits_left = 0\n\n        # Update max_bling\n        max_bling = max(max_bling, bling_balance)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t_0, t_1, t_2 = map(int, stdin.split())\n\n    # Calculate the maximum amount of Bling that Johan can achieve in $d$ days\n    bling_per_day = 400 * d + 500 * d\n    bling_from_trees = 3 * t_0 + 9 * t_1 + 27 * t_2\n    bling_from_selling_fruits = 100 * f\n    bling_from_buying_exotic_fruit = 400\n    total_bling = b + bling_per_day + bling_from_trees - bling_from_selling_fruits - bling_from_buying_exotic_fruit\n\n    return str(total_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum number of fruits he can sell in the remaining time\n    max_fruits = f + 3 * t0 + 9 * t1 + 27 * t2\n    max_fruits //= 40  # Every 40 days, he sells the fruits he plants\n    max_fruits = min(max_fruits, d // 40 * 100)  # Limit the number of fruits he can sell\n\n    # Calculate the maximum amount of Bling he can have with the maximum number of fruits\n    bling = max_fruits * 100\n\n    # Calculate the maximum number of exotic fruits he can buy and sell in the remaining time\n    max_exotic_fruits = d // 40\n\n    # Calculate the maximum amount of Bling he can have with the maximum number of exotic fruits\n    bling += max_exotic_fruits * 500\n\n    return str(bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    d, b, f, t0, t1, t2 = input_values\n\n    if d == 1:\n        return b * 10 + f * 100\n\n    # calculate the maximum bling that can be achieved in $d$ days\n    max_bling = b * 10 + f * 100\n\n    # calculate the maximum number of fruit trees that can be planted in $d$ days\n    max_trees = min(d // 3, f // 3)\n\n    # calculate the maximum number of exotic fruit trees that can be planted in $d$ days\n    max_exotic_trees = min(d // 3, f // 3)\n\n    # calculate the maximum number of fruits that can be harvested in $d$ days\n    max_fruits = min(f, 100 + 3 * max_trees)\n\n    # calculate the maximum number of exotic fruits that can be harvested in $d$ days\n    max_exotic_fruits = min(f, 500 + 3 * max_exotic_trees)\n\n    # calculate the maximum bling that can be achieved using all available resources\n    max_bling += 100 * max_fruits + 500 * max_exotic_fruits\n\n    return max_bling\n"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n    \n    # Calculate the maximum amount of Bling that can be achieved\n    max_bling = b + 300 * f + 100 * (t0 + t1 + t2)\n    \n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = list(map(int, stdin.split()))\n    d, b, f, t0, t1, t2 = inputs\n\n    # Calculate the maximum amount of Bling Johan can gain in the remaining time\n    max_bling = 0\n\n    # Iterate over the remaining days\n    for _ in range(d):\n        # Harvest fruits and sell them for Bling\n        max_bling += f * 100\n        f = 0\n\n        # Plant fruit trees and yield new fruits\n        f += 3 * t0\n        t0 = 0\n        f += 3 * t1\n        t1 = 0\n        f += 3 * t2\n        t2 = 0\n\n        # Every third day, Johan can buy an exotic fruit for $400\n        if (b >= 400):\n            b -= 400\n            f += 1\n\n        # Update the maximum amount of Bling\n        max_bling = max(max_bling, b + f * 100)\n\n    return str(max_bling)"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    d, b, f, t0, t1, t2 = input_list\n    \n    # Calculate the maximum Bling based on the remaining days and fruits\n    max_bling = b + f * 100 + 3 * (t0 + t1 + t2) * 100\n    \n    # If there are more than 100 days remaining, Johan can buy an exotic fruit and plant it\n    if d > 100:\n        max_bling += 400 + 500 * (d - 100)\n    \n    return str(max_bling)"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2 * N:2]))\n    b = list(map(int, stdin.split()[3:3 * N:2]))\n    \n    a_sorted = sorted(a)\n    b_sorted = sorted(b)\n    \n    # Check if the difference between two adjacent a or b values is greater than K\n    for i in range(1, N):\n        if abs(a[i] - a[i - 1]) > K or abs(b[i] - b[i - 1]) > K:\n            return \"2\"\n    \n    # Check if the difference between a and b values is greater than K\n    for i in range(N):\n        for j in range(i + 1, N):\n            if abs(a[i] - b[j]) > K or abs(b[i] - a[j]) > K:\n                return \"2\"\n    \n    # Check if all values in a and b are different\n    if len(a_sorted) != len(set(a_sorted)) or len(b_sorted) != len(set(b_sorted)):\n        return \"2\"\n    \n    return str(1 + len(set(a_sorted)))\n\ndef"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    assistants = [list(map(int, stdin.split()[2:][i:i+2])) for i in range(2*N, 4*N, 2)]\n\n    # Sort assistants based on their jokes and compliments\n    assistants.sort(key=lambda x: (x[0], x[1]))\n\n    # Initialize the number of distinct ranks\n    num_distinct_ranks = 1\n\n    # Initialize the minimum and maximum scores for the first assistant\n    min_score = max_score = assistants[0][0] + assistants[0][1]\n\n    for i in range(1, N):\n        # Update the minimum and maximum scores for the current assistant\n        curr_score = assistants[i][0] + assistants[i][1]\n        min_score = min(min_score, curr_score)\n        max_score = max(max_score, curr_score)\n\n        # Check if the current assistant is within the difference limit\n        if curr_score - min_score > K or curr_score - max_score > K:\n            # If not, increment the number of distinct ranks\n            num_distinct_ranks += 1\n            # Reset the minimum and maximum scores for the next assistant\n            min_score = curr_score\n            max_score = curr_score\n\n    return str(num_distinct_ranks)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_ranks(N: int, K: int, a: List[int], b: List[int]) -> int:\n        # Sort assistants by (a, b)\n        assistants = sorted(zip(a, b), key=lambda x: (x[0], x[1]))\n\n        # Initialize the rank list\n        ranks = [1] * N\n\n        # Iterate through the sorted assistants\n        for i in range(1, N):\n            # Check if there is a better assistant for this one\n            for j in range(i):\n                if (a[i] - a[j] <= K) or (b[i] - b[j] <= K):\n                    ranks[i] = max(ranks[i], ranks[j]) + 1\n\n        # Count the number of distinct ranks\n        return len(set(ranks))\n\n    # Read input\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    a = list(map(int, lines[1].split()))\n    b = list(map(int, lines[2].split()))\n\n    # Compute the maximum number of distinct ranks\n    result = count_ranks(N, K, a, b)\n\n    # Return the result\n    return str(result)"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    def compare(i, j):\n        return (a[i] + b[i]) < (a[j] + b[j])\n\n    def is_equal(i, j):\n        return abs(a[i] - a[j]) <= K and abs(b[i] - b[j]) <= K\n\n    def rank(i):\n        return a[i] + b[i]\n\n    def rank_key(i):\n        return (-rank(i), -i)\n\n    def distinct_ranks(ranks):\n        return len(set(ranks))\n\n    # Sort the assistants by rank\n    assistants = list(range(N))\n    assistants.sort(key=rank_key)\n\n    # Assign ranks\n    ranks = [0] * N\n    for i in assistants:\n        r = rank(i)\n        min_r = float('inf')\n        for j in range(N):\n            if compare(i, j) and is_equal(i, j):\n                min_r = max(min_r, ranks[j])\n        ranks[i] = max(min_r, r)\n\n    # Count the number of distinct ranks\n    return distinct_ranks(ranks)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    def can_swap(i, j):\n        return a[i] + K < a[j] or b[i] + K < b[j]\n\n    def swap_rank(rank, i, j):\n        if rank[i] < rank[j]:\n            rank[i], rank[j] = rank[j], rank[i]\n        return rank\n\n    def count_ranks(rank):\n        return len(set(rank))\n\n    # Initialize rankings with the original order\n    rank = list(range(N))\n\n    # Iterate over all pairs of assistants and swap their ranks if they can be swapped\n    for i in range(N):\n        for j in range(i + 1, N):\n            if can_swap(i, j):\n                rank = swap_rank(rank, i, j)\n\n    # Count the number of distinct ranks\n    max_ranks = count_ranks(rank)\n\n    return max_ranks"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    assistants = stdin.split('\\n')[2:]\n    assistants = [list(map(int, line.split())) for line in assistants]\n\n    def get_score(assistant, i):\n        return assistant[i][0] + assistant[i][1]\n\n    def can_swap(assistant1, assistant2, i, j):\n        return get_score(assistant1, i) + K < get_score(assistant2, j) or get_score(assistant1, j) + K < get_score(assistant2, i)\n\n    def rank_assistants(assistants):\n        assistants.sort(key=lambda x: x[0][0])\n        return assistants\n\n    def get_distinct_ranks(ranked_assistants):\n        distinct_ranks = set()\n        for assistant in ranked_assistants:\n            distinct_ranks.add(assistant[1])\n        return len(distinct_ranks)\n\n    def max_distinct_ranks(assistants):\n        for i in range(N):\n            for j in range(i + 1, N):\n                if can_swap(assistants, i, j):\n                    assistants[i], assistants[j] = assistants[j], assistants[i]\n        ranked_assistants = rank_assistants(assistants)\n        return get_distinct_ranks(ranked_assistants)\n\n    return str(max_distinct_ranks(assistants))\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    max_distinct_ranks = 1\n    for i in range(N):\n        for j in range(N):\n            if i != j and (a[i] + K < a[j] or b[i] + K < b[j]):\n                max_distinct_ranks += 1\n                break\n\n    return str(max_distinct_ranks)\n\n\ndef"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, K = map(int, stdin.split()[:2])\n    assistants = [list(map(int, stdin.split()[i:i+N])) for i in range(1, 2*N, N)]\n    a, b = assistants\n    \n    # Initialize the rankings and check for the rule\n    ranks = list(range(1, N+1))\n    for i in range(N):\n        for j in range(i+1, N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                if ranks[i] > ranks[j]:\n                    ranks[i], ranks[j] = ranks[j], ranks[i]\n                \n    # Count the number of distinct ranks\n    distinct_ranks = len(set(ranks))\n    \n    return distinct_ranks\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    K = int(input_list[0].split()[1])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    N = len(a)\n    max_rank = 1\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                max_rank += 1\n                break\n\n    return str(max_rank)\n"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    max_rank = 1\n    for i in range(N):\n        for j in range(i + 1, N):\n            if a[i] + K < a[j] or b[i] + K < b[j]:\n                max_rank = max(max_rank, j + 1)\n                break\n    return str(max_rank)\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    N = int(inputs[0])\n    lamp_positions = []\n    lamp_energies = []\n\n    for i in range(1, N + 1):\n        x, y, e = map(int, inputs[i].split())\n        lamp_positions.append((x, y))\n        lamp_energies.append(e)\n\n    energy_map = [[0 for _ in range(100)] for _ in range(100)]\n    positive_energy = 0\n    negative_energy = 0\n\n    for lamp_position, lamp_energy in zip(lamp_positions, lamp_energies):\n        x, y = lamp_position\n        e = lamp_energy\n\n        if e >= 0:\n            positive_energy += e\n        else:\n            negative_energy += -e\n\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                if 1 <= i <= 99 and 1 <= j <= 99:\n                    energy_map[j][i] = e\n\n    for i in range(1, 100):\n        for j in range(1, 100):\n            if energy_map[i][j] != 0:\n                continue\n\n            total_energy = 0\n            positive_count = 0\n            negative_count = 0\n\n            for k in range(-1, 2):\n                for l in range(-1, 2):\n                    if 1 <= i + k <= 99 and 1 <= j + l <= 99:\n                        total_energy += energy_map[i + k][j + l]\n\n                        if energy_map[i + k][j + l] >= 0:\n                            positive_count += 1\n                        else:\n                            negative_count += 1\n\n            if positive_count == 0 or negative_count == 0:\n                continue\n\n            positive_energy_ratio = positive_count / (positive_count + negative_count)\n            negative_energy_ratio = negative_count / (positive_count + negative_count)\n\n            if total_energy != 0:\n                positive_energy += positive_energy_ratio * total_energy\n                negative_energy += negative_energy_ratio * total_energy\n\n    if positive_energy == 0 or negative_energy == 0:\n        return \"IMPOSSIBLE\"\n\n    if positive_energy > negative_energy:\n        return \"IMPOSSIBLE\"\n\n    positive_energy_sum = 0\n    negative_energy_sum = 0\n    positive_energy_count = 0\n    negative_energy_count = 0\n\n    for i in range(1, 100):\n        for j in range(1, 100):\n            if energy_map[i][j] == 0:\n                continue\n\n            if energy_map[i][j] >= 0:\n                positive_energy_sum += energy_map[i][j]\n                positive_energy_count += 1\n            else:\n                negative_energy_sum += -energy_map[i][j]\n                negative_energy_count += 1\n\n    if positive_energy_count == 0 or negative_energy_count == 0:\n        return \"IMPOSSIBLE\"\n\n    positive_energy_ratio = positive_energy_count / (positive_energy_count + negative_energy_count)\n    negative_energy_ratio = negative_energy_count / (positive_energy_count + negative_energy_count)\n\n    if positive_energy_sum == 0 or negative_energy_sum == 0:\n        return \"IMPOSSIBLE\"\n\n    positive_energy_ratio_sum = positive_energy_ratio * positive_energy_sum\n    negative_energy_ratio_sum = negative_energy_ratio * negative_energy_sum\n\n    line_length = abs(positive_energy_ratio_sum - negative_energy_ratio_sum)\n    return round(line_length, 6)"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    lamp_coords = []\n    lamp_energies = []\n\n    for i in range(1, N+1):\n        x, y, e = map(int, input_list[i].split())\n        lamp_coords.append((x, y))\n        lamp_energies.append(e)\n\n    def dist(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_valid_line(line_coords):\n        total_energy = sum(lamp_energies)\n        pos_energy = sum([e for x, y, e in lamp_coords if (x, y) in line_coords])\n        neg_energy = total_energy - pos_energy\n        return abs(pos_energy - neg_energy) < 1e-6\n\n    def find_closest_points(coords):\n        closest_points = []\n        for i in range(len(coords)):\n            for j in range(i+1, len(coords)):\n                if is_valid_line([coords[i], coords[j]]):\n                    closest_points.append((coords[i], coords[j]))\n        return closest_points\n\n    closest_points = find_closest_points(lamp_coords)\n\n    if not closest_points:\n        return \"IMPOSSIBLE\"\n\n    min_dist = float(\"inf\")\n    for p1, p2 in closest_points:\n        dist_p1_p2 = dist(p1, p2)\n        if dist_p1_p2 < min_dist:\n            min_dist = dist_p1_p2\n\n    return round(min_dist, 2)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    lamps = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    min_distance = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = distance(lamps[i][:2], lamps[j][:2])\n            if dist < min_distance:\n                min_distance = dist\n\n    if min_distance == float('inf'):\n        return 'IMPOSSIBLE'\n\n    return round(min_distance, 6)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    lamps = [tuple(map(int, line.split())) for line in input_data[1:N+1]]\n    energies = [int(line.split()[-1]) for line in input_data[N+1:]]\n\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_overlapping(x1, y1, x2, y2, x3, y3, x4, y4):\n        return (x1 <= x3 <= x2) or (x1 <= x4 <= x2) or (x3 <= x1 <= x4) or (x3 <= x2 <= x4)\n\n    def is_valid_line(x1, y1, x2, y2, energies):\n        xmin, ymin, xmax, ymax = min(x1, x2), min(y1, y2), max(x1, x2), max(y1, y2)\n        for x3, y3, e3 in lamps:\n            if distance(x1, y1, x3, y3) < 1 and distance(x2, y2, x3, y3) < 1:\n                return False\n            if distance(xmin, ymin, x3, y3) < 1 and distance(xmax, ymax, x3, y3) < 1:\n                return False\n            if e3 < 0:\n                for x4, y4, e4 in lamps:\n                    if e4 < 0 and is_overlapping(x1, y1, x2, y2, x3, y3, x4, y4) and e4 + e3 > 0:\n                        return False\n        return True\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            if is_valid_line(*lamps[i], *lamps[j], energies):\n                d = distance(*lamps[i], *lamps[j])\n                if d < 1:\n                    continue\n                line_energies = [energies[lamps.index((x, y))] for x, y in lamps]\n                if sum(line_energies) / d < 0:\n                    return \"IMPOSSIBLE\"\n                return round(d, 6)\n\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def get_lamp_energy(x, y):\n        for i, (lx, ly) in enumerate(coords):\n            if distance((x, y), (lx, ly)) <= 1:\n                return energies[i]\n        return None\n\n    def is_valid(line):\n        positive_energy = 0\n        negative_energy = 0\n        for x, y in line:\n            lamp_energy = get_lamp_energy(x, y)\n            if lamp_energy is None:\n                return False\n            if lamp_energy >= 0:\n                positive_energy += lamp_energy\n            else:\n                negative_energy += lamp_energy\n        return positive_energy + negative_energy == 0\n\n    def shortest_continuous_line():\n        min_length = float('inf')\n        for i in range(len(coords) - 1):\n            for j in range(i + 1, len(coords)):\n                line = [(coords[i], coords[j])]\n                while len(line) < len(coords):\n                    next_points = []\n                    for x, y in line:\n                        for dx, dy in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n                            nx, ny = x + dx, y + dy\n                            if 1 <= nx <= 99 and 1 <= ny <= 99:\n                                next_points.append((nx, ny))\n                    for p in next_points:\n                        if p not in line and not any(distance(p, q) <= 1 for q in line):\n                            new_line = line + [(p,)]\n                            if is_valid(new_line):\n                                min_length = min(min_length, distance(line[0], line[-1]))\n                                line = new_line\n                                break\n                    else:\n                        break\n        return min_length if min_length != float('inf') else \"IMPOSSIBLE\"\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    energies = [int(e) for e in lines[1].split()]\n    coords = [(int(x), int(y)) for x, y, e in [line.split() for line in lines[2:N + 2]]]\n\n    return f\"{shortest_continuous_line():.6f}\"\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dist(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def closest_pair(points):\n        if len(points) <= 1:\n            return float('inf'), None, None\n        elif len(points) == 2:\n            return dist(points[0], points[1]), points[0], points[1]\n        else:\n            points.sort(key=lambda p: p[0])\n            x_mid = points[len(points) // 2][0]\n            left = [p for p in points if p[0] < x_mid]\n            right = [p for p in points if p[0] >= x_mid]\n            d_min, p1, p2 = closest_pair(left)\n            d_max = float('inf')\n            for p in right:\n                if p[1] > p1[1] and p[1] > p2[1]:\n                    d = dist(p1, p)\n                    if d < d_min:\n                        d_min = d\n                        p_min = p\n            if d_min < d_max:\n                p_max = p_min\n            else:\n                d_min, p1, p2 = closest_pair(right)\n                p_max = p1\n            return d_min, p1, p_max\n\n    def feng_shui(lamps):\n        positive = []\n        negative = []\n        for lamp in lamps:\n            if lamp[2] > 0:\n                positive.append(lamp[:2])\n            else:\n                negative.append(lamp[:2])\n        shortest = float('inf')\n        for p1 in positive:\n            for p2 in negative:\n                d = dist(p1, p2)\n                if d < shortest:\n                    shortest = d\n        return shortest\n\n    def main(lamp_data):\n        lamps = []\n        for i, line in enumerate(lamp_data.split('\\n')):\n            x, y, e = map(int, line.split())\n            lamps.append((x, y, e))\n        return feng_shui(lamps)\n\n    lamps_data = stdin.split('\\n')\n    N = int(lamps_data[0])\n    lamps_data = lamps_data[1:]\n    result = main(lamps_data)\n    return str(result) if result != float('inf') else \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1: tuple, p2: tuple) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    lines = stdin.split('\\n')\n    num_lamps = int(lines[0])\n    lamps = []\n\n    for i in range(1, num_lamps + 1):\n        x, y, e = map(int, lines[i].split())\n        lamps.append((x, y, e))\n\n    min_distance = float('inf')\n    for i in range(num_lamps):\n        for j in range(i + 1, num_lamps):\n            dist = distance(lamps[i][:2], lamps[j][:2])\n            if dist < min_distance:\n                min_distance = dist\n\n    return '{:.6f}'.format(min_distance)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    lamps = [(int(x), int(y), int(e)) for x, y, e in [tuple(map(int, input_list[i+1].split())) for i in range(N)]]\n    energy_map = [[0 for _ in range(100)] for _ in range(100)]\n\n    for x, y, e in lamps:\n        energy_map[x-1][y-1] += e\n        energy_map[x-1][y] += e\n        energy_map[x-1][y+1] += e\n        energy_map[x][y-1] += e\n        energy_map[x][y] += e\n        energy_map[x][y+1] += e\n        energy_map[x+1][y-1] += e\n        energy_map[x+1][y] += e\n        energy_map[x+1][y+1] += e\n\n    min_length = float('inf')\n    max_positive_energy = 0\n    max_negative_energy = 0\n\n    for i in range(100):\n        for j in range(100):\n            if energy_map[i][j] > 0:\n                max_positive_energy = max(max_positive_energy, energy_map[i][j])\n            else:\n                max_negative_energy = max(max_negative_energy, -energy_map[i][j])\n\n    for i in range(1, 100 - N + 1):\n        for j in range(1, 100 - N + 1):\n            positive_energy = 0\n            negative_energy = 0\n            for k in range(N):\n                positive_energy += energy_map[i + k][j + k]\n                negative_energy += energy_map[i + k][j + k - 1]\n            min_length = min(min_length, max(positive_energy, max_positive_energy - negative_energy))\n\n    if min_length == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(min_length, 6)\n\n\ndef"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    lamps = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n\n    positive_lamps = [(x, y) for x, y, e in lamps if e > 0]\n    negative_lamps = [(x, y) for x, y, e in lamps if e < 0]\n\n    if not positive_lamps or not negative_lamps:\n        return 'IMPOSSIBLE'\n\n    def is_inside(x, y, lamp):\n        x_min, y_min, x_max, y_max = (lamp[0] - 1, lamp[1] - 1, lamp[0] + 1, lamp[1] + 1)\n        return x_min <= x <= x_max and y_min <= y <= y_max\n\n    def min_distance(x, y, positive_lamps, negative_lamps):\n        min_dist = float('inf')\n        for px, py in positive_lamps:\n            if is_inside(x, y, (px, py, 0)):\n                dist = abs(px - x) + abs(py - y)\n                min_dist = min(min_dist, dist)\n        for nx, ny in negative_lamps:\n            if is_inside(x, y, (nx, ny, 0)):\n                dist = abs(nx - x) + abs(ny - y)\n                min_dist = min(min_dist, dist)\n        return min_dist\n\n    max_x = max(lamps, key=lambda x: x[0])[0]\n    max_y = max(lamps, key=lambda x: x[1])[1]\n    min_x = min(lamps, key=lambda x: x[0])[0]\n    min_y = min(lamps, key=lambda x: x[1])[1]\n\n    min_dist = float('inf')\n    for x in range(min_x, max_x + 1):\n        for y in range(min_y, max_y + 1):\n            dist = min_distance(x, y, positive_lamps, negative_lamps)\n            min_dist = min(min_dist, dist)\n\n    return round(min_dist, 6)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dist(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def sign(v):\n        return -1 if v < 0 else 1\n\n    N, *lamp_coords = stdin.splitlines()\n    N = int(N)\n\n    if N < 2 or N > 12:\n        return \"IMPOSSIBLE\"\n\n    lamp_coords = [list(map(int, coords.split())) for coords in lamp_coords]\n    lamp_energies = [int(coords[2]) for coords in lamp_coords]\n\n    if any(e < -2000 or e > 2000 for e in lamp_energies):\n        return \"IMPOSSIBLE\"\n\n    pos_energies = [e for e in lamp_energies if e > 0]\n    neg_energies = [e for e in lamp_energies if e < 0]\n\n    if len(pos_energies) != len(neg_energies):\n        return \"IMPOSSIBLE\"\n\n    if len(pos_energies) == 0 or len(neg_energies) == 0:\n        return \"IMPOSSIBLE\"\n\n    lamp_energies.sort()\n    pos_energies.sort()\n    neg_energies.sort()\n\n    x_positions = [lamp[0] for lamp in lamp_coords]\n    y_positions = [lamp[1] for lamp in lamp_coords]\n\n    min_dist = float('inf')\n    for i in range(len(lamp_energies)):\n        for j in range(i + 1, len(lamp_energies)):\n            if lamp_energies[i] * lamp_energies[j] < 0:\n                dist_ij = dist((x_positions[i], y_positions[i]), (x_positions[j], y_positions[j]))\n                if dist_ij < min_dist:\n                    min_dist = dist_ij\n\n    return round(min_dist, 6)\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    lines = []\n    for i in range(1, n + 1):\n        x0, y0, x1, y1 = map(int, input_lines[i].split())\n        lines.append((x0, y0, x1, y1))\n\n    def is_intersecting(line1, line2):\n        x0, y0, x1, y1 = line1\n        x2, y2, x3, y3 = line2\n        if x0 == x2:\n            return x0 == x3\n        elif x0 == x3:\n            return x0 == x2\n        elif y0 == y2:\n            return y0 == y3\n        elif y0 == y3:\n            return y0 == y2\n        else:\n            return False\n\n    points = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            line1 = lines[i]\n            line2 = lines[j]\n            if is_intersecting(line1, line2):\n                x, y = line1[0], line1[1]\n                points.add((x, y))\n                x, y = line1[2], line1[3]\n                points.add((x, y))\n                x, y = line2[0], line2[1]\n                points.add((x, y))\n                x, y = line2[2], line2[3]\n                points.add((x, y))\n\n    if len(points) == float('inf'):\n        return -1\n    else:\n        return len(points)"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def is_on_segment(p1, p2, p3):\n        if p1[0] <= max(p2[0], p3[0]) and p1[0] >= min(p2[0], p3[0]) and p1[1] <= max(p2[1], p3[1]) and p1[1] >= min(p2[1], p3[1]):\n            return True\n        return False\n\n    def dist(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    n = int(stdin[0])\n    lines = [list(map(int, stdin[i+1].split())) for i in range(n)]\n    points = set()\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if lines[i][0] == lines[j][0] and lines[i][1] == lines[j][1] and lines[i][2] == lines[j][2] and lines[i][3] == lines[j][3]:\n                continue\n\n            if lines[i][0] == lines[j][0]:\n                x_m = (lines[i][1] + lines[i][3]) / 2\n                y_m = (lines[j][1] + lines[j][3]) / 2\n                if is_on_segment(lines[i], lines[j], (lines[i][0], y_m)):\n                    points.add((lines[i][0], y_m))\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][1])):\n                    points.add((x_m, lines[i][1]))\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][3])):\n                    points.add((x_m, lines[i][3]))\n            elif lines[i][1] == lines[j][1]:\n                x_m = (lines[i][0] + lines[i][2]) / 2\n                y_m = (lines[j][0] + lines[j][2]) / 2\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][1])):\n                    points.add((x_m, lines[i][1]))\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][3])):\n                    points.add((x_m, lines[i][3]))\n                if is_on_segment(lines[i], lines[j], (lines[i][0], y_m)):\n                    points.add((lines[i][0], y_m))\n            elif lines[i][2] == lines[j][2]:\n                x_m = (lines[i][0] + lines[i][2]) / 2\n                y_m = (lines[j][0] + lines[j][2]) / 2\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][1])):\n                    points.add((x_m, lines[i][1]))\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][3])):\n                    points.add((x_m, lines[i][3]))\n                if is_on_segment(lines[i], lines[j], (lines[i][0], y_m)):\n                    points.add((lines[i][0], y_m))\n            elif lines[i][3] == lines[j][3]:\n                x_m = (lines[i][0] + lines[i][2]) / 2\n                y_m = (lines[j][0] + lines[j][2]) / 2\n                if is_on_segment(lines[i], lines[j], (x_m, lines[i][1])):\n                    points.add((x_m, lines[i][1]))\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def on_segment(p: tuple, q: tuple, r: tuple) -> bool:\n        o = (q[0] - p[0]) * (r[1] - q[1]) - (q[1] - p[1]) * (r[0] - q[0])\n        if o > 0:\n            return False\n        if o < 0:\n            return True\n        d = (q[0] - p[0]) * (r[0] - q[0]) + (q[1] - p[1]) * (r[1] - q[1])\n        if d == 0:\n            return True\n        return False\n\n    def orientation(p: tuple, q: tuple, r: tuple) -> int:\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def do_intersect_or_touch(p: tuple, q: tuple, r: tuple, s: tuple) -> bool:\n        return (orientation(p, q, r) != orientation(p, q, s)) and (orientation(r, s, p) != orientation(r, s, q))\n\n    def count_intersections(lines: list) -> int:\n        points = set()\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                if do_intersect_or_touch(lines[i][:2], lines[i][2:], lines[j][:2], lines[j][2:]):\n                    points.add((lines[i][:2], lines[i][2:]))\n                    points.add((lines[j][:2], lines[j][2:]))\n        return len(points)\n\n    lines = [tuple(map(int, input().split())) for _ in range(int(stdin.splitlines()[0]))]\n    result = count_intersections(lines)\n    return str(result) if result != -1 else \"1\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def intersection(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if den == 0:\n            return False\n        num1 = (x1 * y2 - y1 * x2)\n        num2 = (x3 * y4 - y3 * x4)\n        x = num1 * (x3 - x4) - (x1 - x2) * num2\n        y = num1 * (y3 - y4) - (y1 - y2) * num2\n        return (x, y)\n\n    def distance(point1, point2):\n        x1, y1 = point1\n        x2, y2 = point2\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_touching(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        den = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n        if den == 0:\n            return True\n        num1 = (x1 * y2 - y1 * x2)\n        num2 = (x3 * y4 - y3 * x4)\n        return num1 * num2 < 0 and distance((x1, y1), (x2, y2)) * distance((x3, y3), (x4, y4)) == 0\n\n    n = int(stdin.splitlines()[0])\n    lines = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    points = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            p = intersection(lines[i], lines[j])\n            if p:\n                points.add(p)\n\n    if -1 in points:\n        return -1\n    return len(points)\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    lines = [line.split() for line in stdin.splitlines()[1:]]\n    points = set()\n\n    for x0, y0, x1, y1 in lines:\n        x0, y0, x1, y1 = int(x0), int(y0), int(x1), int(y1)\n        points.add((x0, y0))\n        points.add((x1, y1))\n\n    if len(points) == 0:\n        return \"1\"\n\n    points = list(points)\n    count = 0\n\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            if (points[i][0] == points[j][0] and points[i][1] == points[j][1]) or (points[i][0] == points[j][1] and points[i][1] == points[j][0]):\n                count += 1\n\n    if count == len(points) * (len(points) - 1) // 2:\n        return str(count)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    points = set()\n    for i in range(1, n+1):\n        x0, y0, x1, y1 = map(int, input_list[i].split())\n        if (x0, y0) != (x1, y1):\n            points.add((x0, y0))\n            points.add((x1, y1))\n    if len(points) == 0:\n        return \"1\"\n    elif len(points) == 1:\n        return \"1\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    lines = lines[1:]\n    points = set()\n    for line in lines:\n        x0, y0, x1, y1 = map(int, line.split())\n        points.add((x0, y0))\n        points.add((x1, y1))\n    points = list(points)\n    points.sort()\n    \n    count = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            x0, y0 = points[i]\n            x1, y1 = points[j]\n            if (x0, y0) == (x1, y1):\n                continue\n            count += 1\n    if count == 0:\n        return \"1\"\n    elif count == len(points) * (len(points) - 1) // 2:\n        return \"0\"\n    else:\n        return \"-1\"\n\ninput_file = \"input.txt\"\noutput_file = \"output.txt\"\n\nwith open(input_file, \"r\") as f:\n    stdin = f.read()\n    stdout = solution(stdin)\n\nwith open(output_file, \"w\") as f:\n    f.write(stdout)\n\nprint(\"Input file:\", input_file)\nprint(\"Output file:\", output_file)\nprint(\"Output:\", stdout) "
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def intersect(a, b, c, d):\n        if a == c or b == d:\n            return False\n        if a == b:\n            return (c, d) == (a, b)\n        return ((c <= a <= d) or (c <= b <= d)) and ((a <= c <= b) or (a <= d <= b))\n\n    def is_on_segment(a, b, c, d, e):\n        return min(a, b) <= e <= max(a, b) and min(c, d) <= e <= max(c, d)\n\n    n = int(stdin.splitlines()[0])\n    lines = [line.split() for line in stdin.splitlines()[1:]]\n    points = set()\n\n    for i in range(n):\n        x0, y0, x1, y1 = map(int, lines[i])\n        for j in range(i + 1, n):\n            x2, y2, x3, y3 = map(int, lines[j])\n            if intersect(x0, y0, x1, y1, x2, y2, x3, y3):\n                if is_on_segment(x0, y0, x1, y1, x2, y2) or is_on_segment(x0, y0, x1, y1, x3, y3):\n                    points.add((x2, y2))\n                if is_on_segment(x2, y2, x3, y3, x0, y0) or is_on_segment(x2, y2, x3, y3, x1, y1):\n                    points.add((x0, y0))\n                    points.add((x1, y1))\n                    points.add((x3, y3))\n    if -1 in points:\n        return -1\n    return len(points)\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    lines = []\n    for i in range(1, n+1):\n        x0, y0, x1, y1 = map(int, input_list[i].split())\n        lines.append((x0, y0, x1, y1))\n\n    def is_intersect(line1, line2):\n        x0, y0, x1, y1 = line1\n        x2, y2, x3, y3 = line2\n        if x0 == x1:\n            x0, y0, x1, y1 = y0, x0, y1, x1\n        if x2 == x3:\n            x2, y2, x3, y3 = y2, x2, y3, x3\n\n        if y0 <= y1:\n            y_min, y_max = y0, y1\n        else:\n            y_min, y_max = y1, y0\n        if y2 <= y3:\n            y_min2, y_max2 = y2, y3\n        else:\n            y_min2, y_max2 = y3, y2\n\n        if y_max <= y_min2 or y_max2 <= y_min:\n            return False\n\n        if x0 <= x1:\n            x_min, x_max = x0, x1\n        else:\n            x_min, x_max = x1, x0\n        if x2 <= x3:\n            x_min2, x_max2 = x2, x3\n        else:\n            x_min2, x_max2 = x3, x2\n\n        if x_max <= x_min2 or x_max2 <= x_min:\n            return False\n\n        return True\n\n    def count_intersect(line1, lines):\n        count = 0\n        for line2 in lines:\n            if line1 != line2 and is_intersect(line1, line2):\n                count += 1\n        return count\n\n    points = set()\n    for line1 in lines:\n        for line2 in lines:\n            if line1 != line2:\n                if is_intersect(line1, line2):\n                    x, y = (line1[0] + line1[2]) // 2, (line1[1] + line1[3]) // 2\n                    points.add((x, y))\n\n    if len(points) == 0:\n        return \"1\"\n    elif len(points) == n * (n-1) // 2:\n        return \"-1\"\n    else:\n        return str(len(points))\n"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def intersect(x0, y0, x1, y1, x2, y2, x3, y3):\n        dx1 = x1 - x0\n        dy1 = y1 - y0\n        dx2 = x2 - x3\n        dy2 = y2 - y3\n\n        if dx1 * dy2 == dy1 * dx2:\n            return False\n\n        t = (dx2 * (y0 - y3) + dy2 * (x3 - x0)) / (dy1 * dx2 - dx1 * dy2)\n        u = (-dx1 * (y0 - y3) + dy1 * (x3 - x0)) / (dy1 * dx2 - dx1 * dy2)\n\n        if 0 <= t <= 1 and 0 <= u <= 1:\n            return True\n        return False\n\n    def is_vertical(x0, y0, x1, y1):\n        return x0 == x1\n\n    def is_horizontal(x0, y0, x1, y1):\n        return y0 == y1\n\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    points = set(points)\n    lines = [(x0, y0, x1, y1) for x0, y0, x1, y1 in points]\n    intersection_points = set()\n\n    for i in range(len(lines)):\n        for j in range(i + 1, len(lines)):\n            x0, y0, x1, y1 = lines[i]\n            x2, y2, x3, y3 = lines[j]\n\n            if is_vertical(x0, y0, x1, y1) and is_vertical(x2, y2, x3, y3):\n                continue\n            if is_horizontal(x0, y0, x1, y1) and is_horizontal(x2, y2, x3, y3):\n                continue\n\n            if intersect(x0, y0, x1, y1, x2, y2, x3, y3):\n                intersection_points.add((x0, y0))\n                intersection_points.add((x1, y1))\n                intersection_points.add((x2, y2))\n                intersection_points.add((x3, y3))\n\n    if len(intersection_points) == float('inf'):\n        return -1\n\n    return len(intersection_points) "
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 10:\n        return \"-1\"\n    def is_hill_number(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        diff = 0\n        for i in range(len(digits)-1):\n            if digits[i] > digits[i+1]:\n                diff -= 1\n            if digits[i] < digits[i+1]:\n                diff += 1\n        if diff == 0:\n            return False\n        if diff > 0:\n            if not any(digits[i] > digits[i+1] for i in range(len(digits)-1)):\n                return False\n        return True\n    \n    count = 0\n    for i in range(1, n+1):\n        if is_hill_number(i):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    hill_numbers = 0\n    for i in range(1, n+1):\n        digits = [int(d) for d in str(i)]\n        if len(digits) > 1 and digits[0] < digits[-1]:\n            hill_numbers += 1\n        elif len(digits) > 1 and digits[0] > digits[-1]:\n            continue\n        else:\n            hill_numbers += 1\n    \n    if hill_numbers == 0:\n        return -1\n    else:\n        return hill_numbers"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill_number(n: int) -> bool:\n        s = str(n)\n        for i in range(len(s)-1):\n            if s[i] > s[i+1]:\n                return False\n        return True\n\n    def count_hill_numbers(n: int) -> int:\n        count = 0\n        for i in range(1, n+1):\n            if is_hill_number(i):\n                count += 1\n        return count\n\n    n = int(stdin)\n    if is_hill_number(n):\n        result = count_hill_numbers(n)\n    else:\n        result = -1\n    return str(result)\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    \n    if n == 1:\n        return \"1\"\n    \n    # check if the number is hill number\n    hill_num = \"1\"\n    for i in range(2, len(str(n))+1):\n        hill_num += \"1\"*(i-1) + \"2\" + \"1\"*(i-2)\n    \n    if str(n) in hill_num:\n        # count the hill numbers less than or equal to n\n        for i in range(1, n+1):\n            if str(i) in hill_num:\n                count += 1\n    else:\n        count = -1\n        \n    return str(count)"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    def is_hill_number(num: str) -> bool:\n        for i in range(1, len(num)):\n            if int(num[i]) < int(num[i-1]):\n                return False\n        return True\n\n    count = 0\n    for i in range(1, n+1):\n        if is_hill_number(str(i)):\n            count += 1\n\n    if is_hill_number(str(n)):\n        return str(count)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill_number(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        diffs = [b - a for a, b in zip(digits, digits[1:])]\n        if len(set(diffs)) == 1:\n            return True\n        return False\n\n    n = int(stdin)\n    hill_numbers = [i for i in range(1, n + 1) if is_hill_number(i)]\n    if any(is_hill_number(n)):\n        return str(len(hill_numbers))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    hill_count = 0\n    if n < 10:\n        return -1\n\n    num_len = len(str(n))\n    for i in range(2, num_len - 1):\n        if num_len % i == 0:\n            sub_nums = [str(n)[j:j+i] for j in range(0, num_len, i)]\n            for j in range(len(sub_nums)):\n                if j % 2 == 0 and sub_nums[j] > sub_nums[j+1]:\n                    break\n                elif j % 2 == 1 and sub_nums[j] < sub_nums[j+1]:\n                    break\n            else:\n                hill_count += 1\n\n    if hill_count == 0:\n        return -1\n    else:\n        return hill_count\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for num in range(1, n + 1):\n        digits = [int(d) for d in str(num)]\n        rising = False\n        for i in range(len(digits) - 1):\n            if digits[i] < digits[i + 1]:\n                rising = True\n            elif digits[i] > digits[i + 1]:\n                rising = False\n            if rising:\n                count += 1\n                break\n            if not rising and i == len(digits) - 2:\n                count += 1\n    return count if count <= n else -1"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n + 1):\n        num = str(i)\n        if num == \"\".join(sorted(num, reverse=True)):\n            count += 1\n    if count > 0:\n        return str(count)\n    else:\n        return \"-1\"\n\n\ndef"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_hill_number(num: int) -> bool:\n        digits = [int(d) for d in str(num)]\n        for i in range(len(digits) - 1):\n            if digits[i] > digits[i+1]:\n                return False\n        return True\n\n    def count_hill_numbers(num: int) -> int:\n        if num < 10:\n            return 1 if is_hill_number(num) else 0\n        mid = num // 2\n        left = count_hill_numbers(mid)\n        right = count_hill_numbers(num - mid)\n        return left + right\n\n    n = int(stdin)\n    if is_hill_number(n):\n        result = count_hill_numbers(n)\n    else:\n        result = -1\n    return str(result)\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    modulo = 1000000007\n    def has_same_skill(attacker, defender):\n        return attacker == 1 and defender == 2 or attacker == 2 and defender == 1\n\n    def has_same_defense(attacker, defender):\n        return attacker == 2 and defender == 1 or attacker == 1 and defender == 2\n\n    def dfs(attacker, defender, moves):\n        if len(moves) == N:\n            return 1\n        if len(moves) >= 3 and has_same_skill(attacker, defender):\n            return 0\n        if defender == 0 and (has_same_defense(attacker, defender) or not has_same_skill(attacker, defender)):\n            return 0\n        result = 0\n        for a in range(1, 3):\n            for d in range(1, 3):\n                if a != attacker or d != defender:\n                    result = (result + dfs(a, d, moves + [(attacker, defender)])) % modulo\n        return result\n\n    result = 0\n    for attacker in range(1, 3):\n        for defender in range(1, 3):\n            result = (result + dfs(attacker, defender, [])) % modulo\n    return str(result)\n\ninput_cases = [\n    \"3 0 0 0 3\",\n    \"1 2 0 0 5\",\n    \"1 2 0 0 4\",\n    \"1 2 0 0 6\",\n]\n\nfor case in input_cases:\n    print(solution(case)) "
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, N = map(int, stdin.split())\n    MOD = 1000000007\n\n    if a + b + c + d > 5000:\n        return \"0\"\n\n    if N == 1:\n        if a == 1:\n            return \"2\"\n        elif a == 2:\n            return \"1\"\n        else:\n            return \"0\"\n\n    if N == 2:\n        if a == 1 and b == 2:\n            return \"2\"\n        elif a == 2 and b == 1:\n            return \"2\"\n        else:\n            return \"0\"\n\n    if N == 3:\n        if a == 1 and b == 2 and c == 1:\n            return \"2\"\n        elif a == 2 and b == 1 and c == 2:\n            return \"2\"\n        else:\n            return \"0\"\n\n    if N == 4:\n        if a == 1 and b == 2 and c == 1 and d == 2:\n            return \"2\"\n        elif a == 2 and b == 1 and c == 2 and d == 1:\n            return \"2\"\n        else:\n            return \"0\"\n\n    if N == 5:\n        if a == 1 and b == 2 and c == 1 and d == 2 and a == 1:\n            return \"2\"\n        elif a == 2 and b == 1 and c == 2 and d == 1 and a == 2:\n            return \"2\"\n        else:\n            return \"0\"\n\n    return \"0\""
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    MOD = 1000000007\n\n    def count_sequences(a11, a12, a21, a22, N):\n        if N == 1:\n            return min(a11 + a22, a12 + a21) % MOD\n\n        if N == 2:\n            return min((a11 * a22 + a12 * a21) % MOD, (a11 * a21 + a12 * a22) % MOD)\n\n        # For N > 2, consider a11, a12, a21, a22, and their combinations.\n        count = 0\n        for i in range(a11 + a12 + 1):\n            j = N - i\n            k = min(a11 + a12, a21 + a22) - i\n            l = k - j\n            count += (i * k * l) % MOD\n            count %= MOD\n        return count\n\n    return str(count_sequences(a11, a12, a21, a22, N))"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d, N = map(int, stdin.split())\n    sequences = 0\n    for i in range(N):\n        sequences += a + b + c + d\n        a, b, c, d = b, c, d, 0\n    sequences %= 1000000007\n    return str(sequences)\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    MOD = 1000000007\n    count = 0\n\n    def backtrack(pos: int, prev_attacker: int, prev_defender: int,\n                  rest_attackers: int, rest_defenders: int):\n        nonlocal count\n        if pos == N:\n            count += 1\n            return\n\n        if rest_attackers >= 1:\n            if prev_attacker != a11 and prev_attacker != a12:\n                backtrack(pos + 1, a11, prev_defender, 1, rest_defenders)\n            if prev_attacker != a21 and prev_attacker != a22:\n                backtrack(pos + 1, a21, prev_defender, 1, rest_defenders)\n        if rest_defenders >= 1:\n            if prev_defender != a12 and prev_defender != a22:\n                backtrack(pos + 1, prev_attacker, a12, rest_attackers, 1)\n            if prev_defender != a11 and prev_defender != a21:\n                backtrack(pos + 1, prev_attacker, a21, rest_attackers, 1)\n\n    backtrack(1, -1, -1, a11 + a12, a21 + a22)\n\n    return count % MOD\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    if N == 1:\n        return str(4)\n    else:\n        total_count = 0\n        for i in range(1, 5):\n            total_count += min(a11 + a12, a21 + a22) * min(a11 + a12, a21 + a22)\n            a11, a12, a21, a22 = a12, a21, a22, a11\n        return str(total_count % (10**9 + 7))"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    a1 = a11 + a12\n    a2 = a21 + a22\n    mod = 1000000007\n    \n    def count_sequences(a, b, n):\n        if n == 0:\n            return 1\n        elif n % 3 == 0:\n            return pow(a * b, n // 3, mod)\n        else:\n            return (a * b) * count_sequences(a, b, n - 1) % mod\n    \n    return str(count_sequences(a1 + a2, 2 * min(a1, a2) + 1, N))"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    a_11, a_12, a_21, a_22, N = map(int, stdin.split())\n    MOD = 1000000007\n    memo = [0] * (N + 1)\n    memo[0] = 1\n\n    def count_valid_sequences(attacker, defender, length):\n        if length == 0:\n            return memo[length]\n        if attacker == 0 and defender == 0:\n            return 0\n\n        if memo[length] != 0:\n            return memo[length]\n\n        result = count_valid_sequences(attacker - 1, defender, length - 1)\n        if attacker > 0 and defender > 0:\n            result += count_valid_sequences(attacker - 1, defender - 1, length - 1)\n        if defender > 0:\n            result += count_valid_sequences(attacker, defender - 1, length - 1)\n\n        result %= MOD\n        memo[length] = result\n        return result\n\n    result = count_valid_sequences(a_11 + a_21, a_12 + a_22, N)\n    return str(result)\n"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    MOD = 1000000007\n    \n    def count_sequences(a11, a12, a21, a22, N):\n        if N == 1:\n            return (a11 + a12 + a21 + a22) % MOD\n        elif N == 2:\n            return (a11 * a12 + a12 * a21 + a21 * a22) % MOD\n        else:\n            return ((a11 * (a12 * a21 * a22) % MOD) + (a12 * a21 * a22) % MOD) % MOD\n    \n    return str(count_sequences(a11, a12, a21, a22, N))"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n\n    mod = 1000000007\n\n    def choose(n: int, k: int) -> int:\n        res = 1\n        for i in range(1, k + 1):\n            res = (res * n) % mod\n            n = (n - 1) % mod\n        return res\n\n    def count_sequences(a11: int, a12: int, a21: int, a22: int, N: int) -> int:\n        if N == 1:\n            return (a11 + a12 + a21 + a22) * (a11 + a12 + a21 + a22)\n        if N == 2:\n            return (a11 * a12 + a11 * a21 + a11 * a22 + a12 * a21 + a12 * a22 + a21 * a22) * (a11 * a12 + a11 * a21 + a11 * a22 + a12 * a21 + a12 * a22 + a21 * a22) % mod\n\n        c1 = choose(a11 + a12 + a21 + a22, N - 1)\n        c2 = choose(a11 + a12 + a21 + a22, N - 2)\n        c3 = choose(a11 + a12 + a21 + a22, N - 3)\n\n        return ((c1 * count_sequences(a11, a12, a21, a22, N - 1)) % mod + (c2 * count_sequences(a11, a12, a21, a22, N - 2)) % mod + (c3 * count_sequences(a11, a12, a21, a22, N - 3)) % mod) % mod) % mod\n\n    return str(count_sequences(a11, a12, a21, a22, N))"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = list(map(float, stdin.split()))\n    target = (tx, ty)\n\n    def angle_to_point(x, y, b, phi):\n        return np.arctan2(y, x) - phi\n\n    def find_spiral_point(target, b, phi):\n        x, y = target\n        r = np.sqrt(x**2 + y**2)\n        theta = np.arcsin(y / r)\n        phi = phi - theta\n        return r * b, phi\n\n    def find_detach_point(target, b, phi):\n        spiral_point = find_spiral_point(target, b, phi)\n        angle_to_target = np.arctan2(spiral_point[1], target[0] - spiral_point[0])\n        phi = angle_to_target - phi\n        return spiral_point[0] + b * phi, spiral_point[1] + b * phi\n\n    def find_start_phi(target, b):\n        x, y = target\n        phi = np.arctan2(y, x)\n        while find_spiral_point(target, b, phi)[0] < x:\n            phi += 2 * np.pi\n        return phi\n\n    phi = find_start_phi(target, b)\n    detach_point = find_detach_point(target, b, phi)\n\n    return f\"{detach_point[0]:.6f} {detach_point[1]:.6f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(float, stdin.split()))\n    b, tx, ty = input_data[:3]\n    t = (tx, ty)\n    \n    # Calculate the radius of the spiral at the target\n    spiral_radius = b * (t[0] / abs(t[0]))\n\n    # Calculate the angle of the target with respect to the origin\n    target_angle = atan2(t[1], t[0])\n\n    # Calculate the angle of the next point on the spiral\n    next_angle = target_angle + 2 * pi\n\n    # Calculate the x,y coordinates of the next point on the spiral\n    next_x = spiral_radius * cos(next_angle)\n    next_y = spiral_radius * sin(next_angle)\n\n    # Calculate the angle between the target and the next point on the spiral\n    target_next_angle = atan2(t[1] - next_y, t[0] - next_x)\n\n    # Calculate the angle between the target and the point where the avatar should leave the spiral\n    target_leave_angle = target_next_angle - (t[0] / spiral_radius)\n\n    # Calculate the x,y coordinates of the point where the avatar should leave the spiral\n    leave_x = b * cos(target_leave_angle)\n    leave_y = b * sin(target_leave_angle)\n\n    # Calculate the angle between the target and the point where the avatar should leave the spiral\n    leave_target_angle = atan2(t[1] - leave_y, t[0] - leave_x)\n\n    # Calculate the angle between the target and the next point on the spiral\n    next_leave_angle = atan2(leave_y - next_y, leave_x - next_x)\n\n    # Calculate the angle between the point where the avatar should leave the spiral and the next point on the spiral\n    angle_diff = next_leave_angle - next_leave_angle\n\n    # Calculate the angle between the avatar's direction and the next point on the spiral\n    next_avatar_angle = target_next_angle - angle_diff\n\n    # Calculate the x,y coordinates of the next point on the spiral\n    next_avatar_x = spiral_radius * cos(next_avatar_angle)\n    next_avatar_y = spiral_radius * sin(next_avatar_angle)\n\n    # Calculate the x,y coordinates of the point where the avatar should leave the spiral\n    leave_avatar_x = b * cos(next_avatar_angle)\n    leave_avatar_y = b * sin(next_avatar_angle)\n\n    # Calculate the distance between the avatar's next point and the target\n    distance = sqrt((next_avatar_x - t[0]) ** 2 + (next_avatar_y - t[1]) ** 2)\n\n    # Calculate the angle between the avatar's next point and the target\n    target_avatar_angle = atan2(next_avatar_y - t[1], next_avatar_x - t[0])\n\n    # Calculate the angle between the avatar's next point and the point where the avatar should leave the spiral\n    leave_avatar_angle = atan2(next_avatar_y - leave_avatar_y, next_avatar_x - leave_avatar_x)\n\n    # Calculate the angle between the point where the avatar should leave the spiral and the target\n    angle_diff = target_avatar_angle - leave_avatar_angle\n\n    # Calculate the angle between the avatar's direction and the target\n    avatar_angle = target_angle - angle_diff\n\n    # Calculate the x,y coordinates of the point where the avatar should leave the spiral\n    avatar_leave_x = b * cos(avatar_angle)\n    avatar_leave_y = b * sin(avatar_angle)\n\n    # Calculate the angle between the avatar's next point and the target\n    target_avatar_angle = atan2(avatar_leave_y - t["
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(float, stdin.split()))\n    b, t_x, t_y = input_values\n    r = b * t_x / (t_x**2 + t_y**2)**0.5\n    theta = math.atan2(t_y, t_x)\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return f\"{x:.6f} {y:.6f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n\n    def polar_to_cartesian(r, phi):\n        return r * math.cos(phi), r * math.sin(phi)\n\n    def find_intersection(dx, dy, x, y):\n        a = dx\n        b = -dy\n        c = x\n        d = y\n        det = a * b - c * d\n        if det == 0:\n            return None\n        return (b * c - a * d) / det\n\n    dx, dy = polar_to_cartesian(b, math.pi / 2)\n    x0, y0 = polar_to_cartesian(b, math.pi / 4)\n\n    while True:\n        x, y = x0 + dx * t + dy * t * t / 2, y0 + dy * t - dx * t * t / 2\n        if math.sqrt(x ** 2 + y ** 2) > math.sqrt(tx ** 2 + ty ** 2):\n            break\n        t += b / math.sqrt(dx ** 2 + dy ** 2)\n\n    intersection = find_intersection(dx, dy, tx - x, ty - y)\n    if intersection is not None:\n        t -= intersection\n\n    x, y = x0 + dx * t + dy * t * t / 2, y0 + dy * t - dx * t * t / 2\n\n    return f\"{x:.5f} {y:.5f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split()\n    b, tx, ty = map(float, inputs)\n    t = (tx, ty)\n    \n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n    \n    def phi(t):\n        return atan2(t[1], t[0])\n    \n    def r(t, b):\n        return b * phi(t)\n    \n    def next_point(p, v):\n        return tuple(map(sum, zip(p, v)))\n    \n    def angle_between(v1, v2):\n        return acos(dot(v1, v2) / (norm(v1) * norm(v2)))\n    \n    def dot(v1, v2):\n        return v1[0] * v2[0] + v1[1] * v2[1]\n    \n    def norm(v):\n        return sqrt(v[0] ** 2 + v[1] ** 2)\n    \n    def is_intersecting(p1, p2, p3, p4):\n        return cross(p1, p2, p3, p4) != 0\n    \n    def cross(p1, p2, p3, p4):\n        return (p2[0] - p1[0]) * (p4[1] - p3[1]) - (p4[0] - p3[0]) * (p2[1] - p1[1])\n    \n    def find_release_point(b, t):\n        # Find the point where the avatar should leave the spiral\n        p = (0, 0)\n        v = (1, 0)\n        \n        while distance(p[0], p[1], t[0], t[1]) > 2 * pi * b:\n            p = next_point(p, v)\n        \n        # Find the direction of the avatar's movement\n        phi_t = phi(t)\n        phi_p = phi(p)\n        \n        if abs(phi_t - phi_p) < pi:\n            v_new = rotate(v, phi_t - phi_p)\n        else:\n            v_new = rotate(v, phi_t - phi_p - 2 * pi)\n        \n        # Continue in the direction of the new movement\n        p = next_point(p, v_new)\n        \n        # Check if the avatar will hit the target without intersecting the spiral\n        while is_intersecting(p, next_point(p, v_new), (0, 0), (b * pi, 0)):\n            p = next_point(p, v_new)\n        \n        return p\n    \n    def rotate(v, angle):\n        return (v[0] * cos(angle) - v[1] * sin(angle), v[0] * sin(angle) + v[1] * cos(angle))\n    \n    release_point = find_release_point(b, t)\n    \n    return f\"{release_point[0]:.5f} {release_point[1]:.5f}\""
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    t_xy = (tx, ty)\n    t_xy_mag = (tx**2 + ty**2)**0.5\n\n    # Function to compute the angle between two vectors\n    def angle_between(v1, v2):\n        return np.arccos(np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2)))\n\n    # Define the spiral path as a function of angle\n    def spiral_path(theta):\n        return np.array([theta, b*theta])\n\n    # Find the point on the spiral closest to the target\n    def closest_spiral_point(theta):\n        point = spiral_path(theta)\n        return np.linalg.norm(point - t_xy)\n\n    # Find the angle that is closest to the target\n    min_theta = minimize(closest_spiral_point, 0).x\n\n    # Find the point on the spiral that is closest to the target\n    closest_point = spiral_path(min_theta)\n\n    # Compute the angle between the target and the vector pointing from the spiral to the closest point\n    target_to_closest_angle = angle_between(t_xy / t_xy_mag, (closest_point - spiral_path(min_theta)) / np.linalg.norm(closest_point - spiral_path(min_theta)))\n\n    # Compute the angle between the vector pointing from the closest point to the target and the spiral direction\n    closest_to_target_angle = angle_between((closest_point - spiral_path(min_theta)) / np.linalg.norm(closest_point - spiral_path(min_theta)), np.array([1, 0]))\n\n    # Compute the angle between the target and the spiral direction\n    target_to_spiral_angle = angle_between(t_xy / t_xy_mag, np.array([1, 0]))\n\n    # Compute the angle between the target and the vector pointing from the spiral to the target\n    target_to_point_angle = angle_between(t_xy / t_xy_mag, t_xy / t_xy_mag)\n\n    # Compute the angle between the point and the vector pointing from the spiral to the target\n    point_to_target_angle = angle_between((closest_point - spiral_path(min_theta)) / np.linalg.norm(closest_point - spiral_path(min_theta)), t_xy / t_xy_mag)\n\n    # Compute the angle between the point and the spiral direction\n    point_to_spiral_angle = angle_between((closest_point - spiral_path(min_theta)) / np.linalg.norm(closest_point - spiral_path(min_theta)), np.array([1, 0]))\n\n    # Compute the angle between the spiral direction and the target\n    spiral_to_target_angle = target_to_spiral_angle + target_to_closest_angle\n\n    # Compute the angle between the spiral direction and the point\n    spiral_to_point_angle = target_to_point_angle + target_to_closest_angle + closest_to_target_angle\n\n    # Compute the angle between the point and the target\n    point_to_target_angle = angle_between(t_xy / t_xy_mag, (closest_point - spiral_path(min_theta)) / np.linalg.norm(closest_point - spiral_path(min_theta)))\n\n    # Compute the angle between the point and the spiral direction\n    point_to_spiral_angle = angle_between((closest_point - spiral_path(min_theta)) / np.linalg.norm(closest_point - spiral_path(min_theta)), np.array([1, 0]))\n\n    # Compute the angle between the target and the detachment direction\n    target_to_detachment_angle = target_to_point_angle + point_to_target_angle + point_to_spiral_angle\n\n    # Compute the angle between the detachment direction"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    target = (tx, ty)\n    r = b * np.pi * 2\n    x = np.linspace(0, r, 1000)\n    y = np.sqrt(r**2 - x**2)\n    spiral = np.stack((x, y), axis=1)\n    spiral_line = LineString(spiral)\n    target_line = Point(target)\n    distance = target_line.distance(spiral_line)\n    angle = np.arcsin(distance / (2 * np.pi * b))\n    theta = np.arctan2(ty - b * angle, tx)\n    x_spiral = b * theta\n    y_spiral = b * angle\n    return f\"{x_spiral:.6f} {y_spiral:.6f}\"\n\ndef"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    t_distance = (tx ** 2 + ty ** 2) ** 0.5\n    assert 0.01 <= b <= 10\n    assert -10000 <= tx <= 10000\n    assert -10000 <= ty <= 10000\n    assert t_distance > 2 * pi * b\n    \n    def archimedean_spiral(t: float, b: float) -> float:\n        return b * t\n    \n    def spiral_distance(x: float, y: float, b: float) -> float:\n        theta = (x ** 2 + y ** 2) ** 0.5\n        r = archimedean_spiral(theta, b)\n        return abs(r - (x ** 2 + y ** 2) ** 0.5)\n    \n    x, y = 0, 0\n    step = 0.001\n    while spiral_distance(x, y, b) > 10 ** -3:\n        x += step\n        y = archimedean_spiral(x, b)\n    \n    print(f\"{x:.6f} {y:.6f}\")\n    return f\"{x:.6f} {y:.6f}\""
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def spiral_point(b: float, phi: float) -> tuple:\n        return b * phi, b * np.arctan(phi)\n\n    def distance(p1: tuple, p2: tuple) -> float:\n        return np.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    def angle(p1: tuple, p2: tuple) -> float:\n        return np.arctan2(p2[1] - p1[1], p2[0] - p1[0])\n\n    b, tx, ty = map(float, stdin.split())\n    target = (tx, ty)\n\n    min_phi = np.sqrt(tx ** 2 + ty ** 2) / (2 * np.pi * b)\n    max_phi = np.sqrt(tx ** 2 + ty ** 2) / (2 * np.pi * b)\n    min_phi = max(0, min_phi)\n    max_phi = min(1, max_phi)\n\n    min_distance = 1e3\n    min_point = None\n\n    for phi in np.linspace(min_phi, max_phi, 1000):\n        point = spiral_point(b, phi)\n        distance_to_target = distance(point, target)\n\n        if distance_to_target < min_distance:\n            min_distance = distance_to_target\n            min_point = point\n\n    angle_to_target = angle(min_point, target)\n    x, y = min_point\n\n    while np.abs(angle_to_target) > 0.01:\n        x += np.cos(angle_to_target)\n        y += np.sin(angle_to_target)\n        angle_to_target = angle((x, y), target)\n\n    return f\"{x:.6f} {y:.6f}\"\n"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, t_x, t_y = list(map(float, stdin.split()))\n    def get_xy(phi: float) -> tuple:\n        return (b * phi, 0)\n\n    def is_intersect(spiral: list, target: tuple) -> bool:\n        for p in spiral:\n            if abs(target[0] - p[0]) < 1e-3 and abs(target[1] - p[1]) < 1e-3:\n                return True\n        return False\n\n    def archimedean_spiral(b: float, n: int) -> list:\n        spiral = []\n        phi = 0\n        for _ in range(n):\n            spiral.append(get_xy(phi))\n            phi += 2 * b\n        return spiral\n\n    target = (t_x, t_y)\n    n = 1000\n    spiral = archimedean_spiral(b, n)\n    while is_intersect(spiral, target):\n        n *= 2\n        spiral = archimedean_spiral(b, n)\n\n    x, y = get_xy(2 * b)\n    return f\"{x:.6f} {y:.6f}\""
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, graph: dict, cycle: list) -> bool:\n        visited.add(node)\n        cycle.append(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if dfs(neighbor, visited, graph, cycle):\n                    return True\n                elif neighbor in cycle:\n                    return True\n        cycle.pop()\n        return False\n\n    n, m = map(int, stdin.split()[:2])\n    graph = {i: set() for i in range(1, n + 1)}\n    for _ in range(m):\n        u, v = map(int, stdin.split()[:2])\n        graph[u].add(v)\n        graph[v].add(u)\n\n    count = 0\n    visited = set()\n    cycle = []\n    for node in graph:\n        if node not in visited and dfs(node, visited, graph, cycle):\n            count += 1\n    return count // 2 if count % 2 == 0 else count // 2 + 1\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    adjacency_list = [[] for _ in range(n + 1)]\n    for edge in input_list[1:]:\n        u, v = map(int, edge.split())\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    def dfs(node: int, visited: list, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in adjacency_list[node]:\n            if neighbor != parent:\n                if visited[neighbor]:\n                    return True\n                if dfs(neighbor, visited, node):\n                    return True\n        return False\n\n    def is_cycle_free(node: int, visited: list, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in adjacency_list[node]:\n            if neighbor != parent:\n                if not visited[neighbor]:\n                    if is_cycle_free(neighbor, visited, node):\n                        return True\n        return False\n\n    removed_corridors = 0\n    for i in range(1, n + 1):\n        if is_cycle_free(i, [False] * (n + 1), -1):\n            visited = [False] * (n + 1)\n            if dfs(i, visited, -1):\n                removed_corridors += 1\n\n    return str(removed_corridors) + '\\n' + '\\n'.join(map(str, range(1, m - removed_corridors + 1)))\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    adj_list = [[] for _ in range(n+1)]\n\n    for i in range(1, m+1):\n        u, v = map(int, input_list[i].split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    visited = [False] * (n+1)\n    cycles = []\n\n    def dfs(node, parent, depth):\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                if visited[neighbor]:\n                    cycles.append((node, neighbor))\n                else:\n                    dfs(neighbor, node, depth+1)\n\n    for i in range(1, n+1):\n        if not visited[i]:\n            dfs(i, -1, 0)\n\n    print(len(cycles))\n    for cycle in cycles:\n        print(cycle[0], cycle[1])\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    corridors = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Create a graph from the corridors\n    graph = [[] for _ in range(n + 1)]\n    for u, v in corridors:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Helper function to check if there is a cycle in the graph\n    def has_cycle(u, visited, stack):\n        if not visited[u]:\n            visited[u] = True\n            stack[u] = True\n\n            for v in graph[u]:\n                if has_cycle(v, visited, stack):\n                    return True\n\n            stack[u] = False\n\n        return stack[u]\n\n    # Count the number of cycles and the corridors to remove\n    num_cycles = 0\n    corridors_to_remove = []\n    visited = [False] * (n + 1)\n    stack = [False] * (n + 1)\n    for u in range(1, n + 1):\n        if not visited[u] and has_cycle(u, visited, stack):\n            num_cycles += 1\n\n    # If there are no cycles, return 0\n    if num_cycles == 0:\n        return \"0\\n\"\n\n    # Otherwise, find the corridors to remove\n    corridors_to_remove = [i + 1 for i, c in enumerate(corridors) if c[0] == c[1]]\n\n    # Calculate the number of corridors to remove\n    num_corridors_to_remove = min(len(corridors_to_remove), (num_cycles + 1) // 2)\n\n    # Return the number of corridors to remove and the indices of the corridors to remove\n    result = f\"{num_corridors_to_remove}\\n\"\n    for i in range(num_corridors_to_remove):\n        result += f\"{corridors_to_remove.pop(0)}\\n\"\n\n    return result"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    corridors = [(int(u), int(v)) for u, v in zip(input_data[1::2], input_data[2::2])]\n\n    def find_cycle(start, visited, path):\n        visited[start] = True\n        path.append(start)\n        for v in adjacency[start]:\n            if not visited[v]:\n                if find_cycle(v, visited, path):\n                    return True\n            elif v != start:\n                cycle = path[path.index(v):]\n                return cycle\n        return False\n\n    adjacency = [[] for _ in range(n + 1)]\n    for u, v in corridors:\n        adjacency[u].append(v)\n        adjacency[v].append(u)\n\n    cycles = []\n    for i in range(1, n + 1):\n        visited = [False] * (n + 1)\n        path = []\n        if find_cycle(i, visited, path):\n            cycle = path[path.index(i):]\n            cycles.append(cycle)\n\n    if not cycles:\n        return \"0\\n\"\n\n    to_remove = min(m - len(cycles) * 2, len(cycles))\n    for cycle in cycles:\n        for node in cycle:\n            for neighbor in adjacency[node]:\n                if neighbor not in cycle:\n                    adjacency[node].remove(neighbor)\n                    adjacency[neighbor].remove(node)\n            for u, v in corridors:\n                if u == node and v not in cycle:\n                    corridors.remove((u, v))\n                if v == node and u not in cycle:\n                    corridors.remove((v, u))\n            to_remove -= 1\n            if to_remove == 0:\n                break\n            if not to_remove:\n                break\n        if not to_remove:\n            break\n\n    return f\"{to_remove}\\n\" + '\\n'.join(str(c) for c in corridors)\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    corridors = []\n    for _ in range(m):\n        u, v = map(int, stdin.split()[2:4])\n        corridors.append((u, v))\n    \n    corridors.sort(key=lambda x: x[0])\n    rooms = [set() for _ in range(n + 1)]\n    visited = [False] * (n + 1)\n    for u, v in corridors:\n        rooms[u].add(v)\n    num_cycles = 0\n    cycle_rooms = []\n    for room in rooms:\n        if visited[room]:\n            continue\n        visited[room] = True\n        stack = [room]\n        while stack:\n            current_room = stack[-1]\n            if current_room in cycle_rooms:\n                cycle_rooms.remove(current_room)\n                stack.pop()\n                continue\n            visited[current_room] = True\n            for neighbor in rooms[current_room]:\n                if not visited[neighbor]:\n                    stack.append(neighbor)\n                    cycle_rooms.append(current_room)\n            if len(cycle_rooms) >= 2:\n                num_cycles += 1\n                if num_cycles > m // 2:\n                    return str(num_cycles - 1) + '\\n' + '\\n'.join(map(str, range(1, len(cycle_rooms) - 1)))\n            stack.pop()\n    return str(num_cycles)\n\ndef"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    corridors = [list(map(int, input().split())) for _ in range(m)]\n\n    # Build the graph\n    graph = [[] for _ in range(n + 1)]\n    for u, v in corridors:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # DFS to find cycles\n    def dfs(u: int, visited: set, stack: list) -> bool:\n        visited.add(u)\n        stack.append(u)\n        for v in graph[u]:\n            if v == stack[0]:\n                # Found a cycle\n                return True\n            if v not in visited and dfs(v, visited, stack):\n                # Found a cycle\n                return True\n        stack.pop()\n        return False\n\n    # Find at most half of the cycles\n    cycles = 0\n    for u in range(1, n + 1):\n        visited = set()\n        stack = []\n        if dfs(u, visited, stack):\n            cycles += 1\n\n    # Output the solution\n    if cycles <= m // 2:\n        return \"0\"\n    else:\n        return str(m // 2 - cycles)"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    corridors = set()\n    for i in range(1, m + 1):\n        corridors.add(tuple(sorted(map(int, input_data[i].split()))))\n\n    removed_corridors = set()\n    for room1, room2 in corridors:\n        if room1 == room2:\n            continue\n        if room1 > room2:\n            room1, room2 = room2, room1\n\n        if (room1, room2) in removed_corridors:\n            removed_corridors.remove((room1, room2))\n        else:\n            removed_corridors.add((room1, room2))\n\n    if len(removed_corridors) >= m / 2:\n        return \"0\"\n    else:\n        return str(len(removed_corridors)) + \"\\n\" + \"\\n\".join(map(str, removed_corridors))\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    corridors = {(u, v) for u, v in map(lambda x: map(int, x.split()), input_list[1:])}\n\n    def dfs(u, visited, stack):\n        visited[u] = True\n        stack[u] = True\n\n        for v in range(1, n + 1):\n            if not visited[v] and (u, v) in corridors:\n                if stack[v]:\n                    return True\n                if dfs(v, visited, stack):\n                    return True\n\n        stack[u] = False\n        return False\n\n    max_removed = min(m // 2, n - 1)\n    count = 0\n    removed = []\n    for u in range(1, n + 1):\n        visited = [False] * (n + 1)\n        stack = [False] * (n + 1)\n        if dfs(u, visited, stack):\n            if count < max_removed:\n                removed.append(u)\n                count += 1\n            else:\n                break\n\n    return f\"{count}\\n\" + \"\\n\".join(map(str, removed))\n"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    num_rooms, num_corridors = map(int, input_list[0].split())\n    corridors = [(u, v) for u, v in map(int, line.split())]\n\n    def find_path(start, end, visited):\n        visited.add(start)\n        if start == end:\n            return True\n        for neighbor in graph[start]:\n            if neighbor not in visited and find_path(neighbor, end, visited):\n                return True\n        return False\n\n    def find_cycle(start, visited):\n        visited.add(start)\n        for neighbor in graph[start]:\n            if neighbor not in visited and find_cycle(neighbor, visited):\n                return True\n            elif neighbor in visited:\n                return True\n        return False\n\n    graph = {i: [] for i in range(1, num_rooms + 1)}\n    for u, v in corridors:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    corridors_to_remove = set()\n    for i in range(1, num_rooms + 1):\n        for j in range(i + 1, num_rooms + 1):\n            if not find_cycle(i, set()) and not find_path(i, j, set()):\n                corridors_to_remove.add((i, j))\n                corridors_to_remove.add((j, i))\n\n    if len(corridors_to_remove) >= num_corridors / 2:\n        return str(num_corridors / 2)\n\n    return '\\n'.join(map(str, sorted(corridors_to_remove)))"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    tubes = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def find_time(start, end, visited, time):\n        if start == end:\n            return time\n        if start in visited:\n            return visited[start]\n        visited[start] = float('inf')\n        for tube in tubes:\n            if tube[0] == start and not visited[tube[1]] < time + tube[2]:\n                visited[tube[1]] = min(visited[tube[1]], time + tube[2] + find_time(tube[1], end, visited, time + tube[2]))\n        return visited[start]\n\n    time = find_time(s, t, {}, 0)\n    if time < float('inf'):\n        return time\n    else:\n        return 'infinity'\n\ndef"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    if s == t:\n        return '0'\n    tubes = [list(map(int, input().split())) for _ in range(m)]\n\n    def dfs(ball, time, turn):\n        if ball == t:\n            return time\n        elif turn == 0:\n            left_time = dfs(ball + 1, time + 1, 1)\n            right_time = dfs(ball - 1, time + 1, 0)\n            return min(left_time, right_time)\n        else:\n            left_time = dfs(ball + 1, time + 1, 0)\n            right_time = dfs(ball - 1, time + 1, 1)\n            return min(left_time, right_time)\n\n    left_time = dfs(s, 0, 0)\n    right_time = dfs(s, 0, 1)\n\n    if left_time == float('inf') and right_time == float('inf'):\n        return 'infinity'\n    elif left_time == float('inf'):\n        return str(right_time)\n    elif right_time == float('inf'):\n        return str(left_time)\n    else:\n        return str(min(left_time, right_time))\n\ndef"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start_ball, visited_balls, tubes, time):\n        if start_ball == t:\n            return time\n        visited_balls.add(start_ball)\n        for tube in tubes[start_ball]:\n            if tube[1] not in visited_balls:\n                time_taken = tube[2] + dfs(tube[1], visited_balls, tubes, time + tube[2])\n                if time_taken <= 10000:\n                    return time_taken\n        return float('inf')\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4:7])\n        tubes[a].append((a, b, w))\n\n    time = dfs(s, set(), tubes, 0)\n    return str(time) if time != float('inf') else 'infinity'"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    tubes = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def dfs(start, time, visited, left):\n        visited.add(start)\n        time += 1\n        if start == t:\n            return time\n        if not left:\n            left = True\n        elif start == s:\n            left = False\n\n        for a, b, w in tubes:\n            if a == start and b not in visited:\n                if left:\n                    time = dfs(b, time, visited, left)\n                else:\n                    time = dfs(b, time, visited, not left)\n                if time == float('inf'):\n                    return float('inf')\n        return time\n\n    return 'infinity' if dfs(s, 0, set(), True) == float('inf') else dfs(s, 0, set(), True)\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    tubes = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    # Initialize the distances array\n    distances = [float('inf')] * n\n    distances[s] = 0\n\n    # Dijkstra's algorithm\n    q = [(0, s)]\n    while q:\n        dist, u = heapq.heappop(q)\n        if distances[u] < dist:\n            continue\n        for a, b, w in tubes:\n            if u == a:\n                v = b\n                alt_dist = dist + w\n                if alt_dist < distances[v]:\n                    distances[v] = alt_dist\n                    heapq.heappush(q, (alt_dist, v))\n\n    # Check if Harry can reach his bed\n    if distances[t] == float('inf'):\n        return 'infinity'\n    else:\n        return distances[t]\n\n\ndef"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        prev = [-1] * n\n\n        heap = [(0, start)]\n        while heap:\n            d, u = heapq.heappop(heap)\n            if visited[u]:\n                continue\n            visited[u] = True\n            for v, w in graph[u]:\n                if not visited[v] and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    prev[v] = u\n                    heapq.heappush(heap, (dist[v], v))\n        return dist, prev\n\n    def shortest_path(start, end, prev):\n        path = []\n        while prev[end] != -1:\n            path.append(end)\n            end = prev[end]\n        path.reverse()\n        return path\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, w = map(int, stdin.split()[4 + _ * 3: 7 + _ * 3])\n        graph[a].append((b, w))\n\n    dist, prev = dijkstra(graph, s)\n    if dist[t] == float('inf'):\n        return \"infinity\"\n    else:\n        path = shortest_path(s, t, prev)\n        return dist[t]\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(curr: int, time: int, visited: set) -> int:\n        if curr == t:\n            return time\n        if curr in visited:\n            return float('inf')\n        visited.add(curr)\n        next_time = float('inf')\n        for i in range(m):\n            if a[i] == curr:\n                if b[i] not in visited:\n                    next_time = min(next_time, dfs(b[i], time + w[i], visited))\n        return next_time\n\n    n, m, s, t = map(int, stdin.split())\n    a = []\n    b = []\n    w = []\n    for _ in range(m):\n        a.append(int(stdin.pop(0)))\n        b.append(int(stdin.pop(0)))\n        w.append(int(stdin.pop(0)))\n\n    result = dfs(s, 0, set())\n    return \"infinity\" if result == float('inf') else result"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_ball(ball, tubes, visited):\n        visited.add(ball)\n        for tube in tubes:\n            if tube[0] == ball and tube[1] not in visited:\n                return tube[1]\n        return None\n\n    def dfs(start, tubes, visited, time, left):\n        if left:\n            hemisphere = 'left'\n        else:\n            hemisphere = 'right'\n        visited.add(start)\n        next_ball = start\n        while next_ball is not None:\n            next_ball = find_next_ball(next_ball, tubes, visited)\n            if next_ball is not None:\n                visited.add(next_ball)\n                if hemisphere == 'left':\n                    time += 1\n                else:\n                    time += tubes[next_ball][2]\n                next_ball = find_next_ball(next_ball, tubes, visited)\n            else:\n                return time\n        return time\n\n    def main(n, m, s, t, tubes):\n        visited = set()\n        time = 0\n        left_time = dfs(s, tubes, visited, time, True)\n        right_time = dfs(s, tubes, visited, time, False)\n        if right_time < left_time:\n            return 'infinity'\n        else:\n            return right_time\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m + 1]]\n    return main(n, m, s, t, tubes)"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, s, t = map(int, input_list[0].split())\n    tubes = []\n    for line in input_list[1:]:\n        a, b, w = map(int, line.split())\n        tubes.append((a, b, w))\n\n    if s == t:\n        return 0\n\n    def dfs(ball, visited, time, prev_ball):\n        visited.add(ball)\n        for a, b, w in tubes:\n            if a == ball and b not in visited and (b != prev_ball or a == prev_ball):\n                return dfs(b, visited, time + w, ball)\n        return time\n\n    time = dfs(s, set(), 0, -1)\n    if time == float('inf'):\n        return \"infinity\"\n    else:\n        return time\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_time(ball_from, ball_to):\n        min_time = float('inf')\n        for tube in tubes:\n            if tube[0] == ball_from and tube[1] == ball_to:\n                min_time = min(min_time, tube[2])\n        return min_time\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    tubes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if len(line.split()) == 3]\n\n    time = 0\n    ball = s\n    while ball != t:\n        if time % 2 == 0:  # left hemisphere's turn\n            time += 1\n            for adj_ball in range(n):\n                if (ball, adj_ball) in tubes:\n                    time += get_min_time(ball, adj_ball)\n            time += 1\n\n        ball = tubes[tubes.index((ball, adj_ball))][1]  # right hemisphere's turn\n\n    return \"infinity\" if time == 0 else time\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k, l = map(int, input_list[0].split())\n    c = list(map(int, input_list[1].split()))\n    s = list(map(int, input_list[2].split()))\n\n    if k > 0:\n        c = c[1:]\n        s = s[1:]\n\n    MOD = 1000000007\n    dp = [1] * (n + 1)\n    prev_dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        if i not in s:\n            dp[i] = (dp[i - 1] + prev_dp[i - 1]) % MOD\n            prev_dp[i] = dp[i]\n\n        for j in range(i):\n            if i - j - 1 not in s:\n                dp[i] = (dp[i] + prev_dp[j] * prev_dp[i - j - 1]) % MOD\n                prev_dp[i] = dp[i]\n\n    return dp[n]"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k, l = map(int, input_list[0].split())\n    c = list(map(int, input_list[1].split()))\n    s = list(map(int, input_list[2].split()))\n    c = c[:k]\n    s = s[:l]\n    if not c or not s:\n        return \"0\"\n\n    def dfs(balls: list, index: int, prev: int, count: int, result: list) -> None:\n        if index == len(balls):\n            if count == len(s):\n                result.append(1)\n            return\n\n        if index == 0:\n            dfs(balls, index + 1, balls[index], 0, result)\n            return\n\n        if balls[index] not in c:\n            dfs(balls, index + 1, balls[index], count, result)\n\n        if balls[index] in s:\n            count += 1\n\n        if count == len(s) and index == len(balls) - len(s) + 1:\n            dfs(balls, index + 1, balls[index], 0, result)\n        else:\n            dfs(balls, index + 1, balls[index], count, result)\n\n    balls = list(range(1, n + 1))\n    result = []\n    dfs(balls, 0, -1, 0, result)\n\n    return str(sum(result) % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import product\n    from functools import reduce\n    from operator import mul\n\n    # Parse input\n    n, balls, forbidden, sequence = stdin.split('\\n')\n    n, balls, forbidden, sequence = int(n), map(int, balls.split()), map(int, forbidden.split()), map(int, sequence.split())\n\n    # Calculate the number of arrangements\n    def count_arrangements(balls, forbidden, sequence, sequence_length):\n        # Generate all possible arrangements of the balls\n        arrangements = product(range(1, n + 1), repeat=len(balls))\n\n        # Filter out arrangements that violate the forbidden colors\n        filtered_arrangements = [arr for arr in arrangements if not any(arr[i] in forbidden for i in range(len(balls)))]\n\n        # Count the number of arrangements that meet the sequence condition\n        count = sum(1 for arr in filtered_arrangements if arr[sequence.index(sequence[0])] == sequence[0] and all(arr[sequence.index(s)] == s for s in sequence))\n\n        # Multiply the count by the number of ways to arrange the sequence\n        return count * reduce(mul, range(1, sequence_length + 1), 1)\n\n    # Calculate the total number of arrangements\n    total = count_arrangements(balls, forbidden, sequence, len(sequence))\n\n    # Return the result modulo 1000000007\n    return str(total % 1000000007)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0].split()[0])\n    c = list(map(int, input_list[1].split()[1:]))\n    s = list(map(int, input_list[2].split()[1:]))\n\n    mod = 1000000007\n    MOD = 10**9 + 7\n\n    def count_combinations(n: int, k: int) -> int:\n        if k == 0:\n            return 1\n        if n == 0:\n            return 0\n        return (count_combinations(n - 1, k) + count_combinations(n - 1, k - 1)) % mod\n\n    def count_permutations(n: int, k: int) -> int:\n        return count_combinations(n, k) * (k - 1) % mod\n\n    def count_permutations_with_condition(n: int, k: int, c: list, s: list) -> int:\n        result = 0\n        for i in range(1, k + 1):\n            count = count_permutations(n, i)\n            for j in range(len(s)):\n                count = (count * (n - c[j]) // count_permutations(n - 1, i - 1)) % mod\n            result = (result + count) % mod\n        return result\n\n    count = count_permutations_with_condition(n, len(s), c, s)\n    return str(count)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(balls: list, avoid: list, sequence: list, n: int, k: int, l: int) -> int:\n        if k == 0:\n            return (l == 0) + (l == 1 and sequence[0] in balls) + (l == 2 and sequence[0] in balls and sequence[1] in balls)\n\n        ways = 0\n        for i in range(n - k + 1):\n            new_balls = balls[i:i+k]\n            new_avoid = avoid[i:i+k]\n            new_sequence = sequence[l:]\n            ways += count_ways(new_balls, new_avoid, new_sequence, n - i, k - 1, l)\n\n        return ways % MOD\n\n    MOD = 1000000007\n    n, k, l = map(int, input().split())\n    balls = list(map(int, input().split()))\n    avoid = list(map(int, input().split()))\n    sequence = list(map(int, input().split()))\n\n    if n > 50 or k > 50 or l > 50:\n        return \"Invalid input\"\n\n    if len(avoid) != k or len(sequence) != l:\n        return \"Invalid input\"\n\n    if any(x <= 0 or x > n for x in balls) or any(x not in range(1, n+1) for x in avoid) or any(x not in range(1, n+1) for x in sequence) or any(balls.count(x) > balls.count(avoid[i]) for i, x in enumerate(avoid)):\n        return \"Invalid input\"\n\n    return count_ways(balls, avoid, sequence, n, k, l)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, colors = input_list[0].split()\n    n = int(n)\n    colors = [int(x) for x in colors]\n    forbidden_colors, favorite_sequence = input_list[1], input_list[2]\n    forbidden_colors = [int(x) for x in forbidden_colors.split()]\n    forbidden_colors = set(forbidden_colors)\n    favorite_sequence = [int(x) for x in favorite_sequence.split()]\n    favorite_sequence = set(favorite_sequence)\n    answer = 0\n\n    def helper(current_colors, remaining_colors, index, sequence_count):\n        nonlocal answer\n        if index == n:\n            if sequence_count >= max_sequence_count:\n                answer += 1\n            return\n        for color in remaining_colors:\n            if not forbidden_colors.intersection(current_colors):\n                if sequence_count == 0:\n                    current_colors.add(color)\n                    helper(current_colors, remaining_colors - {color}, index + 1, 0)\n                    current_colors.remove(color)\n                elif color in favorite_sequence:\n                    current_colors.add(color)\n                    helper(current_colors, remaining_colors - {color}, index + 1, sequence_count + 1)\n                    current_colors.remove(color)\n                else:\n                    current_colors.add(color)\n                    helper(current_colors, remaining_colors - {color}, index + 1, sequence_count)\n                    current_colors.remove(color)\n\n    max_sequence_count = sum(1 for x in colors if x in favorite_sequence)\n    remaining_colors = set(colors)\n    current_colors = set()\n    helper(current_colors, remaining_colors, 0, 0)\n    answer %= 1000000007\n    return str(answer)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n: int, not_allowed: set, favorite: set) -> int:\n        if n == 0:\n            return 1 if not not_allowed else 0\n        total_ways = 0\n        for ball in range(1, n + 1):\n            if ball in not_allowed:\n                continue\n            if ball in favorite:\n                total_ways += count_ways(n - 1, not_allowed.union({ball}), favorite)\n            else:\n                total_ways += count_ways(n - 1, not_allowed, favorite)\n        return total_ways % MOD\n\n    MOD = 1000000007\n    n, k, l = map(int, stdin.split()[:3])\n    not_allowed = set(map(int, stdin.split()[3:3 + k]))\n    favorite = set(map(int, stdin.split()[3 + k:3 + k + l]))\n    return count_ways(n, not_allowed, favorite)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k, l = map(int, stdin.split())\n    colors = list(map(int, input().split()))\n    c = list(map(int, input().split()))\n    s = list(map(int, input().split()))\n    \n    # Check if all colors have the same frequency\n    if len(set(colors)) != n:\n        return 0\n    \n    # Check if there are any colors that cannot be next to each other\n    for i in range(k):\n        if c[i] not in colors:\n            return 0\n        colors.remove(c[i])\n        n -= 1\n    \n    # Check if the sequence can be arranged\n    if l > n:\n        return 0\n    \n    # Calculate the number of arrangements\n    MOD = 1000000007\n    count = 1\n    for i in range(l, n + 1):\n        count = (count * (i - l + 1)) % MOD\n    \n    # Calculate the number of arrangements where the sequence appears as often as possible\n    comb = 1\n    for i in range(1, l + 1):\n        comb = (comb * i) % MOD\n    ans = (count * comb) % MOD\n    \n    return ans\n"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    balls_list = [int(x) for x in input_list[1].split()]\n    forbidden_list = [int(x) for x in input_list[2].split()]\n\n    forbidden_set = set(forbidden_list)\n    forbidden_balls = [i for i, x in enumerate(balls_list) if x in forbidden_set]\n\n    seq_list = [int(x) for x in input_list[3].split()]\n    seq_set = set(seq_list)\n\n    balls_set = set(balls_list)\n    balls_set = balls_set.difference(forbidden_set)\n    balls_set = balls_set.intersection(seq_set)\n\n    if not balls_set:\n        return '0'\n\n    MOD = 1000000007\n    total_count = 0\n\n    for i, color in enumerate(balls_list):\n        if color in forbidden_balls:\n            continue\n\n        if i > 0 and balls_list[i - 1] in balls_set and balls_list[i - 1] not in forbidden_set:\n            continue\n\n        if i < n - 1 and balls_list[i + 1] in balls_set and balls_list[i + 1] not in forbidden_set:\n            continue\n\n        seq_count = seq_list.count(color)\n        total_count = (total_count + seq_count * pow(len(balls_set), i, MOD)) % MOD\n\n    return str(total_count)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    forbidden_colors = set(map(int, input_list[1].split()[1:]))\n    favorite_sequence = set(map(int, input_list[2].split()[1:]))\n\n    def helper(colors: set, sequence: set) -> int:\n        if not sequence:\n            return 1\n        result = 0\n        for color in colors:\n            if color not in sequence and color not in forbidden_colors:\n                result += helper(colors - {color}, sequence - favorite_sequence)\n        return result % 1000000007\n\n    return str(helper(set(range(1, n + 1)), favorite_sequence))\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n\n    # Check for numbers containing 2^e\n    for i in range(1, n + 1):\n        if str(2**e) in str(i):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n\n    for i in range(n + 1):\n        if bin(i).count('1') == 2**e:\n            count += 1\n\n    return str(count)\n\nn, e = map(int, input().split())\nprint(solution(str(n) + ' ' + str(e))) "
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        if str(2**e) in str(i):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, input().split())\n    count = 0\n    p2 = 1 << e\n    \n    for i in range(n+1):\n        binary = bin(i)[2:]\n        if p2 in binary:\n            count += 1\n    \n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    if e == 0:\n        count += 1\n    elif e > 0:\n        # Count numbers with digits 2^e and 2^(e-1)\n        count += 1\n        e -= 1\n        while e > 0:\n            count += 1\n            e -= 1\n    count = 0\n    for i in range(n+1):\n        if str(i) in str(2**e):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n + 1):\n        if bin(i)[2:].count('1') == 2**e:\n            count += 1\n    return str(count)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n + 1):\n        if str(i).count('2' * (2**e)):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    result = 0\n    max_power = 1 << e\n    for i in range(max_power, n+1):\n        if str(i) == \"\".join([str(2**j) for j in range(e)]):\n            result += 1\n    return str(result)\n\nn, e = map(int, input().split())\nprint(solution(str(n)+\" \"+str(e))) "
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    \n    def count_powers_of_2(n: int) -> int:\n        count = 0\n        num = n\n        while num > 0:\n            if (num & 1) == 1:\n                count += 1\n            num >>= 1\n        return count\n    \n    result = 0\n    for k in range(n + 1):\n        if count_powers_of_2(k) == 2**e:\n            result += 1\n    \n    return str(result)\n"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n\n    # Check each number from 0 to n\n    for i in range(n + 1):\n        # Convert number to string\n        str_i = str(i)\n\n        # Check if digits of 2^e are a substring of str_i\n        if str(2**e) in str_i:\n            count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[:2])\n    dice_rolls = list(map(int, stdin.split()[2:]))\n\n    def probability_of_getting_to_T(dice_count):\n        total_dice = K + dice_count\n        possible_rolls = 6 ** total_dice\n        target_rolls = 6 ** dice_count\n        return target_rolls / possible_rolls\n\n    best_dice_count = None\n    best_probability = 0\n\n    for dice_count in range(1, K + 1):\n        probability = probability_of_getting_to_T(dice_count)\n        if probability > best_probability:\n            best_dice_count = dice_count\n            best_probability = probability\n\n    return str(best_dice_count)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, input().split())\n    first_roll = list(map(int, input().split()))\n\n    def roll_dice(dice_count):\n        dice_rolls = 0\n        for i in range(dice_count):\n            dice_rolls += sum(first_roll[:i + 1])\n        return dice_rolls\n\n    def find_best_dice_count(target_sum):\n        for i in range(1, K + 1):\n            if roll_dice(i) >= target_sum:\n                return i\n        return None\n\n    best_dice_count = find_best_dice_count(T)\n\n    if best_dice_count is None:\n        return str(K)\n    else:\n        return str(best_dice_count)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    first_roll = list(map(int, stdin.split()[2:]))\n    \n    def get_dice_count(dice_count: int) -> int:\n        def get_sum_with_dice_count(dice_count: int, current_sum: int, remaining_dice: int) -> int:\n            if remaining_dice == 0:\n                return current_sum\n            \n            if current_sum >= T:\n                return 1\n            \n            min_dice_count = float('inf')\n            for i in range(1, 7):\n                if i in first_roll and first_roll.count(i) <= remaining_dice:\n                    remaining_dice -= first_roll.count(i)\n                    min_dice_count = min(min_dice_count, get_sum_with_dice_count(dice_count, current_sum + i, remaining_dice))\n                    remaining_dice += first_roll.count(i)\n                    \n            return min_dice_count\n        \n        return get_sum_with_dice_count(dice_count, 0, K)\n    \n    min_dice_count = float('inf')\n    for i in range(1, 7):\n        min_dice_count = min(min_dice_count, get_dice_count(first_roll.count(i) + 1))\n    \n    return str(min_dice_count)\n\ndef"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    K, T = map(int, input_lines[0].split())\n    dice_rolls = list(map(int, input_lines[1].split()))\n\n    def count_combinations(dice_sum: int, pick_up: int) -> int:\n        if dice_sum > T:\n            return 0\n        if dice_sum == T:\n            return 1\n        if pick_up == 0:\n            return 0\n        return count_combinations(dice_sum, pick_up - 1) + count_combinations(dice_sum + 6, pick_up)\n\n    max_combinations = 0\n    max_pick_up = 0\n\n    for i in range(1, K + 1):\n        combinations = count_combinations(sum(dice_rolls[:i]), i)\n        if combinations > max_combinations:\n            max_combinations = combinations\n            max_pick_up = i\n\n    return str(max_pick_up)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    K, T = map(int, input_list[0].split())\n    dice_rolls = list(map(int, input_list[1].split()))\n\n    def get_best_pickup(rolls, target):\n        total_sum = sum(rolls)\n        if total_sum >= target:\n            return 0\n\n        best_pickup = float('inf')\n        for i in range(K):\n            for j in range(i + 1, K):\n                for k in range(j + 1, K):\n                    pickups = [i, j, k]\n                    pickup_sum = sum(pickups)\n                    if pickup_sum > best_pickup:\n                        continue\n\n                    new_dice_rolls = [dice_rolls[idx] for idx in range(K) if idx not in pickups]\n                    new_dice_rolls.extend([rolls[pickups[idx]] for idx in range(3)])\n                    new_total_sum = sum(new_dice_rolls)\n                    if new_total_sum >= target:\n                        best_pickup = min(best_pickup, pickup_sum)\n\n        return best_pickup\n\n    best_pickup = get_best_pickup(dice_rolls, T)\n    return str(best_pickup)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    K, T = map(int, input_list[0].split())\n    dice_rolls = list(map(int, input_list[1].split()))\n    \n    def probability(dice_rolls, target, K):\n        total_rolls = sum(dice_rolls)\n        if total_rolls < target:\n            return 0\n        \n        num_dice_needed = sum(dice_rolls) - target\n        dice_rolls.sort(reverse=True)\n        num_dice_needed = min(num_dice_needed, K)\n        return sum(dice_rolls[:num_dice_needed]) / total_rolls\n    \n    max_probability = 0\n    optimal_dice_needed = 0\n    \n    for i in range(1, K+1):\n        probability_i = probability(dice_rolls, T, i)\n        if probability_i > max_probability:\n            max_probability = probability_i\n            optimal_dice_needed = i\n    \n    return str(optimal_dice_needed)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    K, T = map(int, input_list[0].split())\n    dice_rolls = list(map(int, input_list[1].split()))\n\n    def count_possibilities(dice_rolls, target):\n        possibilities = 0\n        for i in range(len(dice_rolls) + 1):\n            for j in range(i + 1, len(dice_rolls) + 1):\n                if sum(dice_rolls[i:j]) == target:\n                    possibilities += 1\n        return possibilities\n\n    def count_dice_to_pickup(dice_rolls, target):\n        dice_to_pickup = 0\n        for i in range(len(dice_rolls)):\n            if dice_rolls[i] < target:\n                dice_to_pickup += 1\n            else:\n                break\n        return dice_to_pickup\n\n    possibilities = count_possibilities(dice_rolls, T)\n    dice_to_pickup = count_dice_to_pickup(dice_rolls, T)\n\n    return str(dice_to_pickup)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    K, T = map(int, input_data[0].split())\n    dice_rolls = list(map(int, input_data[1].split()))\n\n    def get_max_dice(dice_rolls, K, T):\n        dice_count = [0] * K\n        for roll in dice_rolls:\n            dice_count[roll - 1] += 1\n\n        max_dice = 0\n        for i in range(T // K):\n            max_dice = max(max_dice, dice_count[K - 1])\n            for j in range(K - 1):\n                dice_count[j] = min(dice_count[j] + dice_count[j + 1], 6)\n            if i + 1 < T // K:\n                dice_count[K - 1] = min(dice_count[K - 1] + 1, 6)\n\n        return max_dice\n\n    return str(get_max_dice(dice_rolls, K, T))"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    first_roll = list(map(int, stdin.split()[2:]))\n\n    def probability(dice):\n        return (K - dice) / K\n\n    best_dice = 0\n    max_prob = 0\n    for dice in range(1, K + 1):\n        prob = probability(dice)\n        if prob > max_prob:\n            max_prob = prob\n            best_dice = dice\n\n    return str(best_dice)\n"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    K, T = map(int, input_data[0].split())\n    dice_rolls = list(map(int, input_data[1].split()))\n\n    def count_ways_to_get_sum(target: int, dice_count: int) -> int:\n        if target == 0:\n            return 1\n        if target < 0 or dice_count <= 0:\n            return 0\n        return count_ways_to_get_sum(target - 1, dice_count - 1) + count_ways_to_get_sum(target, dice_count - 1)\n\n    max_dice_count = 0\n    max_sum = 0\n    for i in range(K):\n        for j in range(K):\n            if i != j:\n                dice_count = 2\n                current_sum = dice_rolls[i] + dice_rolls[j]\n                while current_sum <= T and dice_count <= K:\n                    num_ways = count_ways_to_get_sum(T - current_sum, dice_count)\n                    if num_ways > max_sum:\n                        max_sum = num_ways\n                        max_dice_count = dice_count\n                    current_sum += 6\n                    dice_count += 1\n\n    return str(max_dice_count)"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    S = list(map(int, input_list[1].split()))\n\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def prime_factors(num):\n        factors = []\n        divisor = 2\n        while divisor <= num:\n            if num % divisor == 0 and is_prime(divisor):\n                factors.append(divisor)\n                num //= divisor\n            else:\n                divisor += 1\n        return factors\n\n    max_revenue = 0\n    for i in range(1, N + 1):\n        revenue = len(set(prime_factors(sum(S[:i]))))\n        max_revenue = max(max_revenue, revenue)\n\n    return max_revenue\n\ninput_data = \"\"\"5\n2 3 4 5 8\"\"\"\noutput = solution(input_data)\nprint(\"Output:\", output) "
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factors(n: int) -> int:\n        count = 0\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                count += 1\n        if n > 1:\n            count += 1\n        return count\n\n    N, data = map(int, stdin.split())\n    max_revenue = 0\n    for i in range(1, N + 1):\n        revenue = prime_factors(sum(S for S in data if S <= i))\n        max_revenue = max(max_revenue, revenue)\n    return max_revenue\n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n: int) -> int:\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        while n % 3 == 0:\n            count += 1\n            n //= 3\n        i = 5\n        while i * i <= n:\n            while n % i == 0:\n                count += 1\n                n //= i\n            while n % (i + 2) == 0:\n                count += 1\n                n //= i + 2\n            i += 6\n        if n > 2:\n            count += 1\n        return count\n\n    N, data = stdin.strip().split('\\n')\n    N = int(N)\n    data = list(map(int, data.split()))\n\n    max_revenue = 0\n    for customer in range(N):\n        total_prime_factors = 0\n        for piece in range(N):\n            if customer == piece:\n                total_prime_factors += prime_factors(data[piece])\n        max_revenue = max(max_revenue, total_prime_factors)\n\n    return max_revenue"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    N, *S = list(map(int, stdin.split()))\n\n    max_prime_factors = 0\n    for s in S:\n        prime_factors_sum = sum(prime_factors(s))\n        max_prime_factors = max(max_prime_factors, prime_factors_sum)\n\n    return max_prime_factors\n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    data_primes = [0] * (1000 + 1)\n    \n    for data in input_data[1].split():\n        data_prime_sum = 0\n        for i in range(2, int(math.sqrt(int(data))) + 1):\n            if int(data) % i == 0:\n                data_prime_sum += 1\n        data_primes[int(data)] = data_prime_sum\n\n    max_revenue = max(data_primes)\n    return str(max_revenue)\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    S = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def count_prime_factors(num):\n        count = 0\n        for i in range(2, num + 1):\n            while num % i == 0:\n                count += 1\n                num //= i\n        return count\n\n    max_revenue = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            revenue = count_prime_factors(S[i] + S[j])\n            max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n: int) -> int:\n        count = 0\n        while n % 2 == 0:\n            count += 1\n            n //= 2\n        while n % 3 == 0:\n            count += 1\n            n //= 3\n        i = 5\n        while i * i <= n:\n            while n % i == 0:\n                count += 1\n                n //= i\n            while n % (i + 2) == 0:\n                count += 1\n                n //= i + 2\n            i += 6\n        if n > 2:\n            count += 1\n        return count\n\n    def prime_factors_sum(n: int) -> int:\n        return sum(prime_factors(i) for i in range(1, n + 1))\n\n    N = int(stdin)\n    S = list(map(int, stdin.split()[1:]))\n    S.sort()\n\n    revenue = 0\n    i = 0\n    while i < N:\n        j = i + 1\n        while j < N:\n            if S[j] - S[i] <= 1:\n                j += 1\n            else:\n                break\n        revenue += prime_factors_sum(j - i)\n        i = j\n\n    return revenue\n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def count_prime_factors(n: int) -> int:\n        count = 0\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                count += 1\n                if n % (i * i) == 0:\n                    while n % (i * i) == 0:\n                        n //= i * i\n                else:\n                    while n % i == 0:\n                        n //= i\n        if n > 1:\n            count += 1\n        return count\n\n    N = int(stdin.splitlines()[0])\n    data = [int(x) for x in stdin.splitlines()[1].split()]\n    revenue = 0\n\n    for i in range(N):\n        prime_factors = count_prime_factors(sum(data[:i + 1]))\n        if prime_factors > revenue:\n            revenue = prime_factors\n\n    return revenue\n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from functools import reduce\n    from math import sqrt\n    from sympy import isprime\n\n    def prime_factors(n: int) -> set:\n        factors = set()\n        for i in range(2, int(sqrt(n)) + 1):\n            if n % i == 0:\n                if isprime(i):\n                    factors.add(i)\n                if n // i != i:\n                    if isprime(n // i):\n                        factors.add(n // i)\n        if isprime(n):\n            factors.add(n)\n        return factors\n\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    Si = [int(s) for s in input_data[1].split()]\n\n    if N == 1:\n        return 0\n\n    revenue = 0\n    for i in range(1, N + 1):\n        revenue += len(prime_factors(reduce(lambda x, y: x * y, [Si[j] for j in range(i)]) + 1))\n\n    return revenue\n\n\ndef"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n: int) -> set:\n        factors = set()\n        for i in range(2, n + 1):\n            while n % i == 0:\n                factors.add(i)\n                n //= i\n        return factors\n\n    N, S = stdin.split(\"\\n\")\n    N = int(N)\n    S = list(map(int, S.split()))\n    max_revenue = 0\n\n    for i in range(1, N + 1):\n        factors = prime_factors(sum(S[:i]))\n        max_revenue = max(max_revenue, len(factors))\n\n    return max_revenue\n"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return '0'\n\n    for a in range(1, 10000):\n        if a * a == N:\n            return str(a)\n\n    return '-1'\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    if N == 0:\n        return -1\n    \n    sqrt_N = int(N ** 0.5)\n    \n    if sqrt_N ** 2 == N:\n        return sqrt_N\n    \n    a = sqrt_N + 1\n    while True:\n        if a ** 2 > N:\n            a -= 1\n            break\n        a += 1\n    \n    return a\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    for a in range(1, N):\n        if a * a == N:\n            return str(a)\n\n    return '-1'\n"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, N):\n        if a * a == N:\n            return str(a)\n    return '-1'\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    # Initialize variables\n    a = 0\n    b = 1\n\n    # Find the least positive number a such that a\u2297a = N\n    while b * b <= N:\n        a += 1\n        b = a * a\n\n    # If there is no such a, print -1\n    if b * b > N:\n        return \"-1\"\n\n    return str(a)\n\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    i = 1\n    while i ** 2 <= N:\n        i += 1\n    i -= 1\n    a = 1\n    while i > 0:\n        if a ** i <= N:\n            a += 1\n        else:\n            i -= 1\n            a = a ** i\n    if i > 0:\n        return '-1'\n    else:\n        return str(a)\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for i in range(2, N):\n        if i * i == N:\n            return str(i)\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    low = 1\n    high = N\n    while low <= high:\n        mid = (low + high) // 2\n        if mid * mid > N:\n            high = mid - 1\n        elif mid * mid < N:\n            low = mid + 1\n        else:\n            return str(mid)\n    return '-1'\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n\n    def carryless_multiply(a, b):\n        result = 0\n        for i in range(len(b)):\n            carry = 0\n            for j in range(len(a)):\n                product = a[j] * b[i] + carry\n                carry = product // 10\n                result += product % 10 * (10 ** (len(a) - j - 1))\n            result += carry * (10 ** (len(a) - i - 1))\n        return result\n\n    for a in range(N + 1):\n        if carryless_multiply(str(a), str(a)) == N:\n            return a\n\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    for a in range(1, N):\n        if a * a == N:\n            return str(a)\n    return '-1'"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    L, N = input_data[0].split()\n    L = ord(L) - ord('b')\n    words = input_data[1:]\n\n    def get_last_diff(word1: str, word2: str) -> int:\n        for i in range(1, min(len(word1), len(word2)) + 1):\n            if word1[-i] != word2[-i]:\n                return i - 1\n        return min(len(word1), len(word2))\n\n    def is_consistent(words: List[str]) -> bool:\n        if len(words) < 2:\n            return True\n        for i in range(1, len(words)):\n            last_diff = get_last_diff(words[i - 1], words[i])\n            if last_diff == 0:\n                return False\n            for j in range(i):\n                if words[i].startswith(words[j]):\n                    return False\n        return True\n\n    def find_alphabet() -> str:\n        for i in range(1, L + 1):\n            for j in range(i):\n                if not is_consistent(sorted([word for word in words if word[j] == chr(ord('a') + j) and word[i] == chr(ord('a') + i)])):\n                    return 'IMPOSSIBLE'\n        return ''.join(chr(ord('a') + i) for i in range(L + 1))\n\n    return find_alphabet()"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, N = input().split()\n    L = ord(L) - ord('a')\n    N = int(N)\n\n    words = [input() for _ in range(N)]\n\n    # Check for consistency\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Check if words[i] comes before words[j]\n            if len(words[i]) > len(words[j]):\n                return \"IMPOSSIBLE\"\n\n            for k in range(min(len(words[i]), len(words[j]))):\n                if ord(words[i][k]) > ord(words[j][k]):\n                    return \"IMPOSSIBLE\"\n                elif ord(words[i][k]) < ord(words[j][k]):\n                    break\n\n    # Check for inconsistencies\n    for i in range(N):\n        for j in range(i + 1, N):\n            if len(words[i]) == len(words[j]):\n                for k in range(len(words[i])):\n                    if words[i][k] > words[j][k]:\n                        return \"IMPOSSIBLE\"\n\n    # Generate possible alphabets\n    alphabets = []\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                alphabet = [None] * (L + 1)\n                for k in range(min(len(words[i]), len(words[j]))):\n                    alphabet[ord(words[i][k]) - ord('a')] = words[i][k]\n                    alphabet[ord(words[j][k]) - ord('a')] = words[j][k]\n                alphabets.append(alphabet)\n\n    # Check for ambiguous alphabets\n    for alphabet in alphabets:\n        for i in range(L + 1):\n            if alphabet[i] is None:\n                alphabet[i] = chr(i + ord('a'))\n\n        for i in range(L + 1):\n            for j in range(i + 1, L + 1):\n                if alphabet[i] > alphabet[j]:\n                    return \"AMBIGUOUS\"\n\n    # Output alphabet\n    alphabet = [None] * (L + 1)\n    for i in range(N):\n        for k in range(len(words[i])):\n            alphabet[ord(words[i][k]) - ord('a')] = words[i][k]\n\n    for i in range(L + 1):\n        if alphabet[i] is None:\n            alphabet[i] = chr(i + ord('a'))\n\n    return ''.join(alphabet)"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_lexicographically_consistent(words: list) -> bool:\n        for i in range(len(words) - 1):\n            if words[i] > words[i + 1]:\n                return False\n        return True\n\n    def is_alphabetic_order(words: list) -> bool:\n        for i in range(len(words) - 1):\n            if words[i] > words[i + 1]:\n                return False\n        return True\n\n    def determine_alphabet_order(words: list) -> str:\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        result = []\n        for word in words:\n            for letter in word:\n                result.append(alphabet.index(letter))\n        return \"\".join(chr(97 + i) for i in sorted(result))\n\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split(\"\\n\")[1:]\n\n    if not is_alphabetic_order(words):\n        return \"IMPOSSIBLE\"\n\n    if not is_lexicographically_consistent(words):\n        return \"AMBIGUOUS\"\n\n    alphabet_order = determine_alphabet_order(words)\n    return \"\".join(alphabet_order[:L])\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(s1: str, s2: str) -> bool:\n        i = 0\n        for c in s2:\n            if i < len(s1) and s1[i] == c:\n                i += 1\n        return i == len(s1)\n\n    def find_common_subsequence(s1: str, s2: str) -> str:\n        common = \"\"\n        for c in s1:\n            if is_subsequence(c, s2):\n                common += c\n        return common\n\n    def find_alphabet_order(strings: List[str]) -> str:\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\n        common_subsequences = [alphabet]\n        for i in range(1, len(strings)):\n            for j in range(len(strings) - i):\n                common_subsequences.append(find_common_subsequence(common_subsequences[j], strings[j + i]))\n        for i in range(len(common_subsequences)):\n            if not is_subsequence(common_subsequences[i], strings[i]):\n                return \"IMPOSSIBLE\"\n        for i in range(len(strings) - 1):\n            if not is_subsequence(strings[i], strings[i + 1]):\n                return \"AMBIGUOUS\"\n        return common_subsequences[-1]\n\n    L, N = map(int, stdin.split()[0])\n    strings = stdin.split(\"\\n\")[1:]\n    if L > 122:\n        return \"IMPOSSIBLE\"\n    return find_alphabet_order(strings)\n\nstdin = \"d 4\\ncab\\ncda\\nccc\\nbadca\"\nprint(solution(stdin))\n\nstdin = \"c 4\\nabc\\nbca\\ncab\\naca\"\nprint(solution(stdin))\n\nstdin = \"f 2\\ndea\\ncfb\"\nprint(solution(stdin)) "
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    L, N = input_data[0].split()\n    L = ord(L) - ord('a')\n    words = input_data[1:N+1]\n\n    def is_prefix(w1: str, w2: str) -> bool:\n        return w1 == w2[:len(w1)]\n\n    def compare_words(w1: str, w2: str) -> int:\n        for i in range(min(len(w1), len(w2))):\n            if w1[i] != w2[i]:\n                return w1[i] - w2[i]\n        return len(w1) - len(w2)\n\n    def generate_alphabet() -> str:\n        alphabet = ''.join(sorted(set(''.join(words))))\n        if L + 1 < len(alphabet):\n            return 'IMPOSSIBLE'\n        return alphabet[:L+1]\n\n    def check_consistency() -> str:\n        alphabet = generate_alphabet()\n        if alphabet == 'IMPOSSIBLE':\n            return 'IMPOSSIBLE'\n\n        words.sort(key=lambda x: ''.join(sorted(x)))\n        for i in range(N):\n            for j in range(i+1, N):\n                if is_prefix(words[i], words[j]):\n                    return 'IMPOSSIBLE'\n\n        for i in range(N):\n            for j in range(i+1, N):\n                if compare_words(words[i], words[j]) > 0:\n                    return 'IMPOSSIBLE'\n\n        return 'AMBIGUOUS'\n\n    return check_consistency()"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    L, N = map(int, input_data[0].split())\n    words = input_data[1:]\n\n    if L > 26:\n        return \"IMPOSSIBLE\"\n\n    if len(words) < 2:\n        return \"IMPOSSIBLE\"\n\n    if any(len(word) > 1000 for word in words):\n        return \"IMPOSSIBLE\"\n\n    for i in range(N - 1):\n        if words[i] > words[i + 1]:\n            return \"IMPOSSIBLE\"\n\n    alphabet = [None] * (L + 1)\n    for word in words:\n        for i, c in enumerate(word):\n            if alphabet[ord(c) - ord('a')] is None:\n                alphabet[ord(c) - ord('a')] = word[:i + 1]\n            else:\n                if alphabet[ord(c) - ord('a')] > word[:i + 1]:\n                    alphabet[ord(c) - ord('a')] = word[:i + 1]\n\n    if None in alphabet:\n        return \"IMPOSSIBLE\"\n\n    result = []\n    for i in range(L + 1):\n        if alphabet[i] is None:\n            result.append(chr(i + ord('a')))\n        else:\n            result.append(alphabet[i])\n\n    return ''.join(result)\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def alphabetize(words: list) -> str:\n        alphabet = {}\n        for word in words:\n            for letter in word:\n                if letter not in alphabet:\n                    alphabet[letter] = len(alphabet)\n        return ''.join(sorted(alphabet.keys()))\n\n    def find_alphabet(words: list) -> str:\n        sorted_words = sorted(words)\n        for i in range(len(sorted_words)):\n            for j in range(i + 1, len(sorted_words)):\n                if sorted_words[i] < sorted_words[j]:\n                    continue\n                elif sorted_words[i] > sorted_words[j]:\n                    return 'IMPOSSIBLE'\n                elif i == len(sorted_words) - 1:\n                    return alphabetize(words)\n        return 'AMBIGUOUS'\n\n    stdin = stdin.split('\\n')\n    L, N = stdin[0].split()\n    words = stdin[1:]\n\n    return find_alphabet(words)\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_alphabet(words: list) -> bool:\n        alphabet = set('abcdefghijklmnopqrstuvwxyz')\n        for word in words:\n            if not set(word).issubset(alphabet):\n                return False\n        return True\n\n    def get_first_differing_char(words: list) -> str:\n        min_length = min(len(word) for word in words)\n        for i in range(min_length):\n            chars = set(word[i] for word in words)\n            if len(chars) == 1:\n                return list(chars)[0]\n        return ''\n\n    def get_lexicographic_order(words: list) -> str:\n        first_diff = get_first_differing_char(words)\n        if not first_diff:\n            return 'IMPOSSIBLE'\n        words_sorted = sorted(words, key=lambda x: x.index(first_diff))\n        return ''.join(sorted(set('abcdefghijklmnopqrstuvwxyz') - set(''.join(words_sorted[0]))))\n\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split('\\n')[1:]\n\n    if not is_valid_alphabet(words):\n        return 'IMPOSSIBLE'\n\n    return get_lexicographic_order(words)\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    L, N = input_list[0].split(' ')\n    L = ord(L) - ord('a')\n    N = int(N)\n\n    sorted_words = sorted(input_list[1:])\n    for i in range(1, len(sorted_words)):\n        if sorted_words[i] < sorted_words[i-1]:\n            return \"IMPOSSIBLE\"\n\n    alphabet = [chr(ord('a') + i) for i in range(L+1)]\n    last_index = len(sorted_words[0])-1\n    for i in range(last_index, -1, -1):\n        unique = True\n        for j in range(N-1):\n            if sorted_words[j][i] != sorted_words[j+1][i]:\n                unique = False\n                break\n        if unique:\n            alphabet[ord(sorted_words[0][i]) - ord('a')] = sorted_words[0][i]\n        else:\n            return \"IMPOSSIBLE\"\n\n    for i in range(L+1):\n        if alphabet[i] == chr(ord('a') + i):\n            return \"IMPOSSIBLE\"\n\n    return ''.join(alphabet)\n"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split('\\n')[1:]\n    \n    alphabet = {}\n    for word in words:\n        for char in word:\n            if char not in alphabet:\n                alphabet[char] = len(alphabet)\n    \n    if len(alphabet) > L:\n        return \"IMPOSSIBLE\"\n    \n    if len(alphabet) < L:\n        return \"AMBIGUOUS\"\n    \n    sorted_words = sorted(words, key=lambda x: tuple(alphabet[char] for char in x))\n    \n    alphabet_order = [chr(i + ord('a')) for i in range(L+1)]\n    for word in sorted_words:\n        for char in word:\n            alphabet_order[alphabet[char]] = char\n    \n    return ''.join(alphabet_order)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    N, A, B, C = map(int, stdin.split())\n\n    # calculate maximum number of cookies\n    max_cookies = N * min(A, B, C)\n\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    A, B, C = input_list[1:]\n\n    # Maximum number of cookies that can be distributed\n    max_cookies = A + B + C\n\n    # Number of cookies eaten by each friend\n    friends_eaten = [0] * (N + 1)\n\n    # Iterate through all possible combinations of cookies\n    for a in range(A + 1):\n        for b in range(B + 1):\n            for c in range(C + 1):\n                # Calculate the number of cookies eaten by all friends\n                total_eaten = a + b + c\n\n                # If the total number of cookies is less than the maximum\n                if total_eaten < max_cookies:\n                    # Update the number of cookies eaten by each friend\n                    for i in range(N + 1):\n                        friends_eaten[i] += a\n                    for i in range(N + 1):\n                        friends_eaten[i] += b\n                    for i in range(N + 1):\n                        friends_eaten[i] += c\n\n                    # Check if the cookies can be distributed without repeating\n                    repeating = False\n                    for i in range(N + 1):\n                        for j in range(i + 1, N + 1):\n                            if friends_eaten[i] == friends_eaten[j] and (friends_eaten[i] + friends_eaten[j]) == total_eaten:\n                                repeating = True\n                                break\n                        if repeating:\n                            break\n\n                    # If the cookies can be distributed without repeating, update the maximum number of cookies\n                    if not repeating:\n                        max_cookies = total_eaten\n\n    return str(max_cookies)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N, A, B, C = map(int, inputs)\n\n    total_cookies = A + B + C\n    min_cookies = N * total_cookies\n\n    if A >= N:\n        min_cookies = A * (N // 2)\n\n    elif B >= N:\n        min_cookies = B * (N // 2)\n\n    elif C >= N:\n        min_cookies = C * (N // 2)\n\n    return str(min_cookies)\n\n\ninput1 = \"2 3 3 3\"\ninput2 = \"10 20 0 0\"\ninput3 = \"100 20 543 12\"\n\noutput1 = solution(input1)\noutput2 = solution(input2)\noutput3 = solution(input3)\n\nprint(output1)  # Output: 9\nprint(output2)  # Output: 10\nprint(output3)  # Output: 164 "
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    N, A, B, C = map(int, input_data)\n\n    total_cookies = A + B + C\n    cookies_per_friend = total_cookies // (N + 1)\n    max_cookies_distributed = cookies_per_friend * N\n\n    return str(max_cookies_distributed)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, A, B, C = map(int, stdin.split())\n\n    # Calculate the maximum number of cookies that can be distributed\n    max_cookies = N * min(A, B, C)\n\n    # Return the result\n    return str(max_cookies)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, C, N = map(int, stdin.split())\n    cookies_per_person = A + B + C\n    total_cookies = N * cookies_per_person\n\n    if total_cookies >= N * (A + B + C):\n        return str(N * cookies_per_person)\n    else:\n        return str(total_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    input_list = list(map(int, stdin.split()))\n    N, A, B, C = input_list\n\n    # Calculate the maximum number of cookies Alf and Beata can distribute\n    max_cookies = N * min(A, B, C)\n\n    # Output the result\n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split()))\n    N = input_list[0]\n    A = input_list[1]\n    B = input_list[2]\n    C = input_list[3]\n    \n    # Calculate the maximum number of cookies that can be distributed\n    max_cookies = min(A, B, C) * N\n    \n    return str(max_cookies)"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    N, A, B, C = map(int, inputs)\n    if A + B + C < N:\n        return str(A + B + C)\n    elif A > N:\n        return str(A - N + 1)\n    elif B > N:\n        return str(B - N + 1)\n    else:\n        return str(C)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, a, b, c = input_values\n\n    def count_min_cookies(n: int, a: int, b: int, c: int) -> int:\n        def is_possible(a: int, b: int, c: int) -> bool:\n            if a <= b and a <= c:\n                return a\n            elif b <= a and b <= c:\n                return b\n            else:\n                return c\n\n        def count_min(a: int, b: int, c: int) -> int:\n            a, b, c = sorted([a, b, c])\n            return a + b + c - is_possible(a, b, c)\n\n        max_value = max(a, b, c)\n        min_value = min(a, b, c)\n\n        if max_value == min_value:\n            return n * max_value\n        elif n % 3 == 0:\n            return n * max_value\n        elif n % 2 == 0:\n            return n * min_value + count_min(max_value, max_value, max_value)\n        else:\n            return n * min_value + count_min(max_value, max_value, max_value) + 1\n\n    min_cookies = count_min_cookies(n, a, b, c)\n    return str(min_cookies)\n\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m, r = map(int, input_data[0].split())\n    candles = [tuple(map(int, input_data[i + 1].split())) for i in range(n)]\n    lines = [tuple(map(int, input_data[i + n + 1].split())) for i in range(m)]\n\n    for i, candle in enumerate(candles):\n        x, y = candle\n        if not (0 <= x ** 2 + y ** 2 < r ** 2):\n            return \"no\"\n\n    for line in lines:\n        a, b, c = line\n        if a == 0 and b == 0:\n            return \"no\"\n        if a ** 2 + b ** 2 > 100 ** 2:\n            return \"no\"\n        if abs(c) > 20000:\n            return \"no\"\n\n    for i, line in enumerate(lines):\n        a, b, c = line\n        shift_x = 10 ** -4\n        shift_y = a / b * shift_x\n        if not (0 <= a * (x + shift_x) + b * (y - shift_y) + c <= 0 and 0 <= a * (x - shift_x) + b * (y + shift_y) + c <= 0):\n            return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def cross(a, b, c, d, e):\n        return a * (e - b) - (a - d) * (e - a)\n\n    def ccw(p, q, r):\n        return (q[0] - p[0]) * (r[1] - p[1]) - (r[0] - p[0]) * (q[1] - p[1])\n\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [(int(x), int(y)) for x, y in zip(stdin.split()[3::2], stdin.split()[4::2])]\n    cuts = [(int(a), int(b), int(c)) for a, b, c in zip(stdin.split()[6::3], stdin.split()[7::3], stdin.split()[8::3])]\n\n    def check_candle(p, q, r):\n        return all(ccw(p, q, candle) > 0 for candle in candles)\n\n    def check_cut(p, q, r, cut):\n        a, b, c = cut\n        return cross(a, b, c, p[0], p[1]) <= 0 and cross(a, b, c, q[0], q[1]) >= 0\n\n    for p, q in zip(candles, candles[1:] + [candles[0]]):\n        if not check_candle(p, q, (0, 0)):\n            return \"no\"\n\n    for cut in cuts:\n        if not any(check_cut(p, q, (0, 0), cut) for p, q in zip(candles, candles[1:] + [candles[0]])):\n            return \"no\"\n\n    return \"yes\"\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def cut_circle(x, y, a, b, c, r):\n        if abs(a) <= 10**-4 and abs(b) <= 10**-4:\n            return False\n        p = (b*x - a*y) / (a**2 + b**2)\n        q = (a*x + b*y) / (a**2 + b**2)\n        return (p**2 + q**2) <= r**2\n\n    def count_candles(x, y, a, b, c, r):\n        if cut_circle(x, y, a, b, c, r):\n            return 1\n        else:\n            return 0\n\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [tuple(map(int, input().split())) for _ in range(n)]\n    lines = [tuple(map(int, input().split())) for _ in range(m)]\n\n    total_candles = sum(count_candles(x, y, a, b, c, r) for x, y in candles for a, b, c in lines)\n\n    if total_candles == n:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    candles = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[:2])\n        candles.append((x, y))\n\n    lines = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[:3])\n        lines.append((a, b, c))\n\n    def is_valid_cut(line, candles, r):\n        a, b, c = line\n        for x, y in candles:\n            if a * x + b * y + c < 0:\n                return False\n        return True\n\n    for line in lines:\n        if not is_valid_cut(line, candles, r):\n            return \"no\"\n\n    return \"yes\"\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0].split()[0])\n    m = int(input_list[0].split()[1])\n    r = int(input_list[0].split()[2])\n    \n    candles = [(int(input_list[i].split()[0]), int(input_list[i].split()[1])) for i in range(1, n+1)]\n    cuts = [(int(input_list[i].split()[0]), int(input_list[i].split()[1]), int(input_list[i].split()[2])) for i in range(n+1, n+1+m)]\n    \n    def check_candle(candle, cuts):\n        for cut in cuts:\n            a, b, c = cut\n            if a == 0 and b == 0:\n                continue\n            if a == 0:\n                y = -c / b\n                if y > 0 and y < 2*r:\n                    return False\n            elif b == 0:\n                x = -c / a\n                if x > 0 and x < 2*r:\n                    return False\n            else:\n                x, y = solve_quadratic(a, b, c)\n                if x > 0 and x < 2*r and y > 0 and y < 2*r:\n                    return False\n        return True\n    \n    def solve_quadratic(a, b, c):\n        delta = b**2 - 4*a*c\n        if delta > 0:\n            x1 = (-b + sqrt(delta)) / (2*a)\n            x2 = (-b - sqrt(delta)) / (2*a)\n            y1 = c / (a * x1)\n            y2 = c / (a * x2)\n            return x1, y1\n        elif delta == 0:\n            x = -b / (2*a)\n            y = c / (a * x)\n            return x, y\n        else:\n            return None\n    \n    for candle in candles:\n        if not check_candle(candle, cuts):\n            return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, r = map(int, input_data[0].split())\n    candles = []\n    for i in range(1, n + 1):\n        x, y = map(int, input_data[i].split())\n        candles.append((x, y))\n    cutting_lines = []\n    for i in range(n + 1, n + 1 + m):\n        a, b, c = map(int, input_data[i].split())\n        cutting_lines.append((a, b, c))\n    \n    def is_point_inside_circle(x, y):\n        return x**2 + y**2 <= r**2\n\n    def is_line_inside_circle(a, b, c):\n        # Calculate the maximum and minimum values of x and y\n        # that can lie on the line, considering the circle boundary\n        if a == 0:\n            x = -c/b\n            if is_point_inside_circle(x, 0):\n                return True\n        else:\n            x_min = max(-c/b, -c/a)\n            x_max = min(-c/b, -c/a)\n        if b == 0:\n            y = -c/a\n            if is_point_inside_circle(0, y):\n                return True\n        else:\n            y_min = max(-c/a, -c/b)\n            y_max = min(-c/a, -c/b)\n        \n        # Check if any point on the line lies inside the circle\n        for x in range(int(x_min), int(x_max)+1):\n            for y in range(int(y_min), int(y_max)+1):\n                if is_point_inside_circle(x, y):\n                    return True\n        return False\n\n    def is_line_tangent_to_circle(a, b, c):\n        # If both a and b are zero, then the line is tangent to the circle\n        # if and only if c=0, which is already checked in is_line_inside_circle()\n        if a == 0 and b == 0:\n            return False\n        if a == 0 or b == 0:\n            return True\n        # Calculate the minimum and maximum values of x and y\n        # that can lie on the line, considering the circle boundary\n        if a == 0:\n            x_min = float('-inf')\n            x_max = float('inf')\n        else:\n            x_min = max(-c/b, -c/a)\n            x_max = min(-c/b, -c/a)\n        if b == 0:\n            y_min = float('-inf')\n            y_max = float('inf')\n        else:\n            y_min = max(-c/a, -c/b)\n            y_max = min(-c/a, -c/b)\n        \n        # Check if any point on the line lies outside the circle\n        for x in range(int(x_min), int(x_max)+1):\n            for y in range(int(y_min), int(y_max)+1):\n                if not is_point_inside_circle(x, y):\n                    return True\n        return False\n\n    def count_candles(a, b, c, candles):\n        count = 0\n        for x, y in candles:\n            if a*x + b*y + c == 0:\n                count += 1\n        return count\n\n    for a, b, c in cutting_lines:\n        if is_line_inside_circle(a, b, c) or (a != 0 and b != 0 and is_line_tangent_to_circle(a, b, c)):\n            pass\n        else:\n            return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_circle(x: int, y: int, r: int) -> bool:\n        return x * x + y * y <= r * r\n\n    def count_candles_on_piece(piece: List[Tuple[int, int]], candles: List[Tuple[int, int]]) -> int:\n        count = 0\n        for candle in candles:\n            if piece[0] < candle[0] < piece[2] and piece[1] < candle[1] < piece[3]:\n                count += 1\n        return count\n\n    def check_cut(candles: List[Tuple[int, int]], cut_line: Tuple[int, int, int]) -> bool:\n        for candle in candles:\n            if cut_line[0] * candle[0] + cut_line[1] * candle[1] + cut_line[2] == 0:\n                return False\n        return True\n\n    def cut_circle(candles: List[Tuple[int, int]], cut_lines: List[Tuple[int, int, int]]) -> List[Tuple[int, int, int, int, int]]:\n        pieces = []\n        for cut_line in cut_lines:\n            for piece in pieces:\n                if piece[2] * cut_line[0] + piece[3] * cut_line[1] + cut_line[2] == 0 and piece[4] == 0:\n                    piece[2] = cut_line[0] * piece[2] + cut_line[1] * piece[3] + cut_line[2]\n                    piece[3] = -piece[2] * cut_line[0]\n                    piece[4] = piece[2] * candles[0][0] + piece[3] * candles[0][1] + cut_line[2]\n                    break\n            else:\n                pieces.append([0, 0, 0, 0, 0])\n                pieces[-1][2] = cut_line[0]\n                pieces[-1][3] = cut_line[1]\n                pieces[-1][4] = cut_line[2]\n                pieces[-1][0] = candles[0][0]\n                pieces[-1][1] = candles[0][1]\n        return pieces\n\n    lines = stdin.split('\\n')\n    n, m, r = map(int, lines[0].split())\n    candles = [tuple(map(int, lines[i + 1].split())) for i in range(n)]\n    cut_lines = [tuple(map(int, lines[i + 1 + n].split())) for i in range(m)]\n\n    if any(cut_lines[i][0] == 0 and cut_lines[i][1] == 0 for i in range(m)):\n        return \"no\"\n\n    pieces = cut_circle(candles, cut_lines)\n    for piece in pieces:\n        if not is_inside_circle(piece[0], piece[1], r) or not check_cut(candles, (piece[2], piece[3], -piece[2] * candles[0][0] - piece[3] * candles[0][1] + piece[4])):\n            return \"no\"\n\n    for i in range(1, n):\n        if count_candles_on_piece(pieces[i - 1], candles) != 1:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, m, r = map(int, lines[0].split())\n    candles = [tuple(map(int, line.split())) for line in lines[1:1+n]]\n    cuts = [tuple(map(int, line.split())) for line in lines[1+n:]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_in_circle(p, r):\n        return distance(p, (0, 0)) <= r\n\n    def is_in_cut(p, cut):\n        a, b, c = cut\n        return a * p[0] + b * p[1] + c == 0\n\n    for i in range(n):\n        p1, p2 = candles[i], candles[(i+1)%n]\n        line_candles = [c for c in candles if not is_in_cut(c, cuts[i//2])]\n        if len(line_candles) != 2:\n            return \"no\"\n        if not (is_in_circle(p1, r) and is_in_circle(p2, r)):\n            return \"no\"\n\n    return \"yes\"\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split()[:3])\n    candles = [tuple(map(int, stdin.split()[i:i+2])) for i in range(3, 3+n, 2)]\n    lines = [tuple(map(int, stdin.split()[i:i+3])) for i in range(3+n, 3+n+m, 3)]\n\n    def is_inside(candle, x, y, r):\n        return r ** 2 >= x ** 2 + y ** 2\n\n    def is_tangent(candle, x, y, r):\n        return r ** 2 > x ** 2 + y ** 2 and abs(x) ** 2 + abs(y) ** 2 == r ** 2\n\n    def intersects(a, b, c, x, y):\n        return a * x + b * y + c == 0\n\n    for line in lines:\n        a, b, c = line\n        if a == 0 and b == 0:\n            return \"no\"\n        if abs(a) > 100 or abs(b) > 100 or abs(c) > 20000:\n            return \"no\"\n        if c == 0:\n            x = -b / a\n            if not is_inside(candles[0], x, 0, r):\n                return \"no\"\n            for candle in candles[1:]:\n                if intersects(a, b, c, *candle):\n                    return \"no\"\n        else:\n            d = b ** 2 - 4 * a * c\n            if d < 0:\n                return \"no\"\n            x1 = (-b + d.sqrt()) / (2 * a)\n            x2 = (-b - d.sqrt()) / (2 * a)\n            if not is_inside(candles[0], x1, 0, r) or not is_inside(candles[0], x2, 0, r):\n                return \"no\"\n            for candle in candles[1:]:\n                if intersects(a, b, c, *candle):\n                    return \"no\"\n    return \"yes\"\n\ndef"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    candles = []\n    for i in range(1, n+1):\n        x, y = map(int, input_list[i].split())\n        candles.append((x, y))\n    cutting_lines = []\n    for i in range(n+1, n+1+m):\n        a, b, c = map(int, input_list[i].split())\n        cutting_lines.append((a, b, c))\n\n    # Check if each cutting line intersects the circle\n    for a, b, c in cutting_lines:\n        if a == 0:\n            x = -c / b\n            if not (-r <= x <= r):\n                return \"no\"\n        elif b == 0:\n            y = -c / a\n            if not (-r <= y <= r):\n                return \"no\"\n        else:\n            x = -c / (b + a)\n            y = (-a * x - c) / b\n            if not (-r <= x <= r and -r <= y <= r):\n                return \"no\"\n\n    # Check if the cake can be divided\n    cutting_lines.sort()\n    left_end = float('-inf')\n    right_end = float('inf')\n    for a, b, c in cutting_lines:\n        if a == 0:\n            if b > 0:\n                left_end = max(left_end, c / b)\n            else:\n                right_end = min(right_end, c / b)\n        elif b == 0:\n            if a > 0:\n                left_end = max(left_end, -c / a)\n            else:\n                right_end = min(right_end, -c / a)\n        else:\n            x = (b * b * right_end - c) / (2 * a * b)\n            if a > 0:\n                left_end = max(left_end, x)\n            else:\n                right_end = min(right_end, x)\n\n    return \"yes\" if len(candles) == int(right_end - left_end) else \"no\""
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def is_palindrome_partition(parts: list[str]) -> bool:\n        return all(is_palindrome(part) for part in parts)\n\n    s = stdin.strip()\n    n = len(s)\n    k = n // 2 + 1\n    for i in range(k - 1, 0, -1):\n        if is_palindrome_partition(s[j:j + i] for j in range(n - i + 1)):\n            return i\n    return 1\n\n\ndef"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(1, n + 1):\n        for j in range(1, i + 1):\n            if stdin[i - j:i] == stdin[i - j::-1]:\n                dp[i] = True\n                break\n\n    for k in range(2, n):\n        for i in range(1, n - k + 2):\n            if dp[i - 1] and dp[i + k - 1]:\n                dp[i] = True\n\n    for i in range(2, n):\n        if dp[i] and dp[i - 1]:\n            return i\n\n    return 1"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    if n % 2 == 1:\n        # odd length, cannot be palindrome\n        return 1\n    for k in range(2, n + 1, 2):\n        if s[:k] == s[n - k:]:\n            # found palindrome\n            return k\n    # not found palindrome\n    return 1\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    n = len(stdin)\n    max_k = 1\n    for i in range(n):\n        for j in range(i + 2, n + 1, 2):\n            if is_palindrome(stdin[i:j]):\n                max_k = max(max_k, (j - i) // 2)\n    return str(max_k)\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s):\n        return s == s[::-1]\n\n    def partition(s: str, k: int) -> bool:\n        n = len(s)\n        for i in range(n - k + 1):\n            if is_palindrome(s[i:i+k]):\n                return True\n        return False\n\n    stdin = stdin.strip()\n    n = len(stdin)\n    for k in range(n // 2, n + 1):\n        if partition(stdin, k):\n            return k\n    return n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2 != 0:\n        stdin = stdin[:n//2] + \"0\" + stdin[n//2:]\n        n += 1\n    for k in range(n//2, 0, -1):\n        if stdin[k:2*k] == stdin[2*k-n:2*k][::-1]:\n            return k\n    return 1\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for length in range(1, n+1):\n        for i in range(n-length+1):\n            j = i + length - 1\n            if length == 1:\n                dp[i][j] = 1\n            elif length == 2:\n                dp[i][j] = 1 if s[i] == s[j] else 0\n            else:\n                dp[i][j] = dp[i+1][j-1] if s[i] == s[j] else 0\n                \n            for k in range(i+1, j):\n                dp[i][j] = max(dp[i][j], dp[i][k-1] + dp[k+1][j])\n                \n    return dp[0][n-1]\n"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    k = 1\n    n = len(s)\n    while k <= n:\n        for i in range(n - k + 1):\n            if s[i:i + k] == s[i:i + k][::-1]:\n                return k\n        k += 1\n    return k - 1"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    if n % 2 != 0:\n        return \"1\"\n    for i in range(n // 2):\n        if stdin[i] != stdin[n - 1 - i]:\n            return str(i + 1)\n    return str(n // 2)"
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin\n    n = len(s)\n    dp = [[False] * n for _ in range(n)]\n    \n    for i in range(n-1, -1, -1):\n        dp[i][i] = True\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1]\n            else:\n                dp[i][j] = False\n    \n    for k in range(2, n):\n        for i in range(n-k):\n            if dp[i][i+k-1] and s[i] == s[i+k-1]:\n                return k\n    \n    return 1\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    gold_list = list(map(int, input_list[1].split()))\n    road_list = [list(map(int, input_list[i+2].split())) for i in range(m)]\n    \n    # Create a graph\n    graph = [[0] * (n+1) for _ in range(n+1)]\n    for road in road_list:\n        a, b = road\n        graph[a][b] = 1\n        graph[b][a] = 1\n    \n    # Dijkstra's algorithm to find the shortest path from every village to the king's castle\n    dist = [float('inf')] * (n+1)\n    prev = [None] * (n+1)\n    dist[1] = 0\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if graph[i][j] == 1 and dist[i] != float('inf'):\n                if dist[j] > dist[i] + gold_list[j-1]:\n                    dist[j] = dist[i] + gold_list[j-1]\n                    prev[j] = i\n    \n    # Calculate the maximum amount of gold the bandits can steal\n    max_gold = 0\n    for i in range(2, n):\n        max_gold += gold_list[i-1]\n    \n    # Check if the bandits can get safely home\n    for i in range(2, n):\n        if dist[i] != float('inf'):\n            max_gold -= gold_list[i-1]\n    \n    return max_gold"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    villages = list(map(int, stdin.split()[2:n-1]))\n    roads = []\n    for i in range(m):\n        roads.append(list(map(int, stdin.split()[n-1 + 2 * i:n-1 + 2 * i + 2])))\n\n    # Initialize a list to keep track of the maximum amount of gold that can be stolen from each village\n    max_gold = [0] * n\n    max_gold[0] = villages[0]\n    max_gold[1] = villages[1]\n\n    # Traverse the graph, updating the maximum gold that can be stolen from each village\n    for i in range(2, n):\n        max_gold[i] = max(max_gold[j] + villages[i] for j in range(n) if (j, i) in roads)\n\n    # The maximum amount of gold that can be stolen is the maximum gold from the village nearest to the castle\n    return max(max_gold[1:n])\n\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, amount, graph, gold):\n        if node == bandit_village:\n            return amount\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                amount = dfs(neighbor, visited, amount, graph, gold)\n                if amount < 0:\n                    return -1\n        visited.remove(node)\n        if node != bandit_village:\n            amount -= gold[node]\n        return amount\n\n    # Read input\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    gold = list(map(int, lines[1].split()))\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(2, n):\n        graph[i].append(1)\n    for i in range(2, n - 1):\n        graph[i].append(i + 1)\n    for i in range(m):\n        a, b = map(int, lines[i + 2].split())\n        graph[a].append(b)\n        graph[b].append(a)\n    bandit_village = 1\n\n    # DFS to find the maximum amount of gold that can be stolen\n    amount = 0\n    visited = set()\n    for i in range(2, n):\n        amount = dfs(i, visited, amount, graph, gold)\n        if amount < 0:\n            return \"-1\"\n\n    # Return the maximum amount of gold that can be stolen\n    return str(amount)"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    gold_villages = list(map(int, input_data[1].split()))\n    graph = {}\n    for i in range(2, len(input_data)):\n        a, b = map(int, input_data[i].split())\n        if a not in graph:\n            graph[a] = [b]\n        else:\n            graph[a].append(b)\n        if b not in graph:\n            graph[b] = [a]\n        else:\n            graph[b].append(a)\n    max_gold = 0\n    def dfs(node, gold):\n        nonlocal max_gold\n        max_gold = max(max_gold, gold)\n        for neighbor in graph[node]:\n            if neighbor != 1 and neighbor != 2:\n                dfs(neighbor, gold + gold_villages[neighbor-1])\n    dfs(2, 0)\n    return max_gold"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start, end, roads):\n        visited = set()\n        queue = [(start, [])]\n        while queue:\n            node, path = queue.pop(0)\n            if node == end:\n                return path\n            if node not in visited:\n                visited.add(node)\n                for neighbor in roads[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, path + [node]))\n        return []\n\n    def max_gold(gold, path):\n        max_gold = 0\n        for node in path:\n            max_gold = max(max_gold, gold[node - 1])\n        return max_gold\n\n    def is_valid(roads, visited, path):\n        return all(neighbor in visited for neighbor in roads[path[-1]])\n\n    n, m = map(int, input().split())\n    gold = list(map(int, input().split()))\n    roads = [set() for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        roads[a - 1].add(b - 1)\n        roads[b - 1].add(a - 1)\n\n    bandit_home = 0\n    bandit_gold = gold[bandit_home]\n    max_gold_steal = 0\n    for i in range(1, n):\n        if i == 1:\n            gold[i] -= bandit_gold\n        if gold[i] > max_gold_steal:\n            max_gold_steal = gold[i]\n    if max_gold_steal == 0:\n        return 0\n\n    for i in range(2, n):\n        if i == 2:\n            gold[i] -= max_gold_steal\n        path = find_path(bandit_home, i, roads)\n        if not path:\n            continue\n        if not is_valid(roads, set(range(1, n)), path):\n            continue\n        max_gold_steal = max(max_gold_steal, max_gold(gold, path))\n\n    return max_gold_steal"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    g = list(map(int, input_list[1].split()))\n    g.pop(0)\n\n    def dfs(v: int, visited: set, gold: int) -> int:\n        if v == 2:\n            return gold\n        visited.add(v)\n        for neighbor in adj[v]:\n            if neighbor not in visited:\n                gold = max(gold, dfs(neighbor, visited.copy(), gold + g[neighbor - 1]))\n        visited.remove(v)\n        return gold\n\n    adj = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, input_list[i + 2].split())\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n\n    gold = dfs(0, set(), 0)\n    return gold\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(start: int, end: int, visited: set) -> bool:\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for i in range(1, n):\n            if i not in visited and find_path(i, end, visited):\n                return True\n        return False\n\n    n, m = map(int, stdin.split()[:2])\n    gold = list(map(int, stdin.split()[2:n-1]))\n    roads = [tuple(map(int, line.split())) for line in stdin.split()[n-1:]]\n    visited = set()\n\n    max_gold = 0\n    for road in roads:\n        if find_path(road[0], road[1], visited):\n            max_gold += gold[road[1] - 1]\n\n    return str(max_gold)\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    gold = list(map(int, input_list[1].split()))\n    adj_matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(2, len(input_list)):\n        a, b = map(int, input_list[i].split())\n        adj_matrix[a - 1][b - 1] = 1\n        adj_matrix[b - 1][a - 1] = 1\n\n    max_gold = 0\n    for i in range(n - 1):\n        for j in range(n - 1 - i):\n            for k in range(n - 1 - i - j):\n                for l in range(n - 1 - i - j - k):\n                    max_gold = max(max_gold, gold[0] + gold[i + 2] + gold[j + i + 3] + gold[k + j + i + 4] + gold[l + k + j + i + 5])\n\n    return str(max_gold)\n\ndef"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    gold_amount = list(map(int, input_data[1].split()))\n    roads = [list(map(int, input_data[i+2].split())) for i in range(m)]\n\n    # Create adjacency list\n    adjacency_list = [[] for _ in range(n)]\n    for road in roads:\n        adjacency_list[road[0]-1].append(road[1]-1)\n        adjacency_list[road[1]-1].append(road[0]-1)\n\n    # Find the largest connected component\n    visited = [False for _ in range(n)]\n    max_gold = 0\n    for i in range(n):\n        if not visited[i]:\n            stack = [i]\n            visited[i] = True\n            total_gold = gold_amount[i+1]\n            while stack:\n                current_node = stack.pop()\n                for neighbor in adjacency_list[current_node]:\n                    if not visited[neighbor]:\n                        total_gold += gold_amount[neighbor+1]\n                        stack.append(neighbor)\n                        visited[neighbor] = True\n            max_gold = max(max_gold, total_gold)\n\n    return str(max_gold)\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split(\"\\n\")\n    n, m = map(int, lines[0].split())\n    gold = list(map(int, lines[1].split()))\n    roads = [tuple(map(int, lines[i+2].split())) for i in range(m)]\n\n    # Create a graph\n    graph = {i: [] for i in range(1, n+1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # DFS to find the shortest path from every village to every other village\n    shortest_path = {i: {j: float(\"inf\") for j in range(1, n+1)} for i in range(1, n+1)}\n    for i in range(1, n+1):\n        shortest_path[i][i] = 0\n        for j in graph[i]:\n            shortest_path[i][j] = 1\n\n    def dfs(node, parent, distance):\n        for child in graph[node]:\n            if child != parent:\n                shortest_path[parent][child] = min(shortest_path[parent][child], distance+1)\n                dfs(child, parent, distance+1)\n\n    for i in range(1, n+1):\n        for j in graph[i]:\n            if shortest_path[i][j] == float(\"inf\"):\n                dfs(i, i, 1)\n\n    # Calculate the maximum amount of gold the bandits can steal\n    max_gold = 0\n    for i in range(2, n):\n        if shortest_path[1][i] != float(\"inf\"):\n            max_gold += gold[i]\n\n    return max_gold\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    \n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n                \n    critical_elements = []\n    for i in range(n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and dp[i] == dp[j] + 1:\n                critical_elements.append(sequence[i])\n                \n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements))) "
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    n = int(stdin.splitlines()[0])\n    seq = [int(x) for x in stdin.splitlines()[1].split()]\n    \n    # initialize the dp array\n    dp = [1] * n\n    \n    # initialize a visited array to keep track of visited nodes\n    visited = [False] * n\n    \n    # iterate through the sequence and compute the LIS\n    for i in range(1, n):\n        for j in range(i):\n            if seq[i] > seq[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    \n    # iterate through the sequence and mark visited nodes\n    for i in range(n):\n        if visited[i]:\n            continue\n        for j in range(i+1, n):\n            if seq[i] < seq[j] and dp[j] == dp[i] + 1:\n                visited[i] = True\n                break\n    \n    # find all critical elements\n    critical_elements = [seq[i] for i in range(n) if visited[i]]\n    \n    # output the result\n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    seq = [int(x) for x in input_list[1].split()]\n\n    # Function to find the length of LIS using dynamic programming\n    def lis(seq):\n        n = len(seq)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if seq[i] > seq[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    # Function to find the critical elements\n    def find_critical_elements(seq):\n        critical_elements = []\n        n = len(seq)\n        for i in range(n):\n            if lis(seq[:i] + seq[i+1:]) < lis(seq):\n                critical_elements.append(seq[i])\n        return critical_elements\n\n    # Compute LIS and critical elements\n    lis_length = lis(seq)\n    critical_elements = find_critical_elements(seq)\n\n    # Output the critical elements if any, otherwise output -1\n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(str(x) for x in sorted(critical_elements))"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    seq = list(map(int, input().split()))\n    \n    lis = [seq[0]]\n    for i in range(1, n):\n        if seq[i] > lis[-1]:\n            lis.append(seq[i])\n        else:\n            lis = lis[:bisect_left(lis, seq[i])] + [seq[i]]\n    \n    critical_elements = sorted(set(seq) - set(lis))\n    \n    if critical_elements:\n        return ' '.join(map(str, critical_elements))\n    else:\n        return '-1'"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def lis(sequence: list) -> int:\n        n = len(sequence)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if sequence[i] > sequence[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def find_critical_elements(sequence: list) -> list:\n        n = len(sequence)\n        critical_elements = []\n        for i in range(n):\n            if lis(sequence[:i] + sequence[i + 1:]) < lis(sequence[:i] + sequence[i + 1:] + [sequence[i]]):\n                critical_elements.append(sequence[i])\n        return critical_elements\n\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    critical_elements = find_critical_elements(sequence)\n    if critical_elements:\n        return \" \".join(map(str, critical_elements))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    sequence = list(map(int, input_list[1].split()))\n\n    def lis(sequence: list) -> int:\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if sequence[i] > sequence[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def find_critical_elements(sequence: list) -> list:\n        critical_elements = []\n        for i in range(n):\n            if lis(sequence[:i] + sequence[i + 1:]) < lis(sequence):\n                critical_elements.append(sequence[i])\n        return critical_elements\n\n    critical_elements = find_critical_elements(sequence)\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    dp = [1] * n\n    res = []\n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n\n    for i in range(n):\n        if dp[i] == 1:\n            res.append(sequence[i])\n\n    if not res:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(res)))\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    sequence = list(map(int, stdin.split('\\n')[1].split()))\n\n    if n == 1:\n        return \"-1\"\n\n    lis = [1] * n\n\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    critical_elements = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lis[i] + 1 == lis[j] and sequence[i] > sequence[j]:\n                critical_elements.append(sequence[i])\n                break\n\n    if not critical_elements:\n        return \"-1\"\n\n    critical_elements.sort()\n    return \" \".join(map(str, critical_elements))\n"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    lis = [1] * n\n    lis[0] = sequence[0]\n    for i in range(1, n):\n        for j in range(i):\n            if sequence[i] > sequence[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n\n    critical_elements = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lis[i] + 1 == lis[j] and sequence[i] != sequence[j]:\n                critical_elements.add(sequence[i])\n                critical_elements.add(sequence[j])\n\n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(str(elem) for elem in sorted(critical_elements)) "
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(nums: List[int], key: int) -> int:\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == key:\n                return mid\n            elif nums[mid] < key:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left\n\n    def length_of_lis(nums: List[int]) -> int:\n        tails = [0] * len(nums)\n        size = 0\n        for num in nums:\n            index = binary_search(tails, num)\n            tails[index] = num\n            size = max(size, index + 1)\n        return size\n\n    n = int(stdin[0])\n    sequence = [int(x) for x in stdin[1].split()]\n    lis = length_of_lis(sequence)\n    critical_elements = []\n    for num in sequence:\n        new_sequence = [x for x in sequence if x != num]\n        if length_of_lis(new_sequence) < lis:\n            critical_elements.append(num)\n\n    if not critical_elements:\n        return \"-1\"\n    else:\n        return \" \".join([str(x) for x in critical_elements])\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    mark = stdin.split('\\n')[1:]\n    \n    nubs = 0\n    for row in mark:\n        nubs += row.count('#')\n    \n    return nubs // 2\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    mark = [list(line) for line in input_list]\n\n    # Find the number of nubs on the first stamp\n    num_nubs = 0\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                num_nubs += 1\n\n    # The number of nubs on the second stamp is the same as the first stamp\n    return num_nubs"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    mark = [list(row) for row in input_list]\n\n    # Find the number of nubs on the first stamp\n    count = 0\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                count += 1\n\n    # Find the number of nubs on the second stamp\n    for i in range(n):\n        for j in range(m):\n            if mark[i][j] == '#':\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    mark = stdin.splitlines()[1:]\n    \n    # Count number of '#'s on the first stamp\n    nubs = sum(mark[i].count('#') for i in range(n))\n    \n    # Count number of '#'s on the second stamp\n    for i in range(n):\n        if '#' in mark[i]:\n            nubs += mark[i].count('#') - 1\n    \n    return str(nubs)\n\ndef"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n, m = map(int, inputs.pop(0).split())\n    mark = [line.strip() for line in inputs]\n\n    min_nubs = float(\"inf\")\n    for i in range(n - 1):\n        for j in range(m):\n            if mark[i][j] == \"#\" and mark[i + 1][j] == \"#\":\n                min_nubs = min(min_nubs, 1)\n            elif mark[i][j] == \"#\" and mark[i + 1][j] == \".\":\n                min_nubs = min(min_nubs, 2)\n\n    return str(min_nubs)\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    mark = input_lines[1:]\n\n    # Count the number of '#' and '.' characters in the mark\n    nub_count = 0\n    for row in mark:\n        nub_count += row.count('#')\n\n    # If the number of '#' characters is equal to the number of stampings,\n    # then the minimum number of nubs of a bureaucrat's stamp\n    # that could have possibly made the input mark is the total count of '#' characters\n    if nub_count == 2 * n * m:\n        return nub_count\n\n    # Otherwise, calculate the minimum number of nubs of a bureaucrat's stamp\n    # that could have possibly made the input mark by stamping exactly twice\n    min_nubs = nub_count\n    for row in mark:\n        for col in row:\n            if col == '#':\n                min_nubs -= 1\n\n    return min_nubs\n\ninput_file = open(\"input_file.txt\", \"r\")\nstdin = input_file.read()\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    mark = stdin.splitlines()[1:]\n    max_nubs = 0\n    for i in range(n - 1):\n        for j in range(m - 1):\n            if mark[i][j] == '#' and mark[i][j + 1] == '#':\n                max_nubs += 1\n            if mark[i + 1][j] == '#' and mark[i + 1][j + 1] == '#':\n                max_nubs += 1\n    return max_nubs"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    mark = []\n\n    for _ in range(n):\n        mark.append(input())\n\n    num_nubs = 0\n    for row in mark:\n        num_nubs += row.count(\"#\")\n\n    return num_nubs * 2\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_nubs(mark: str) -> int:\n        return mark.count('#')\n\n    def find_nubs(stamp: str, mark: str) -> int:\n        nubs = 0\n        for i in range(len(stamp)):\n            for j in range(len(stamp[0])):\n                if stamp[i][j] == '#':\n                    if mark[i][j] == '#':\n                        nubs += 1\n                    else:\n                        return -1\n        return nubs\n\n    lines = stdin.strip().split('\\n')\n    n, m = map(int, lines[0].split())\n    stamp = [list(lines[i]) for i in range(1, n + 1)]\n    marks = [list(lines[i]) for i in range(n + 1, len(lines))]\n\n    min_nubs = float('inf')\n    for mark in marks:\n        nubs = count_nubs(mark)\n        if nubs == 0:\n            continue\n        for i in range(n - len(stamp) + 1):\n            for j in range(m - len(stamp[0]) + 1):\n                sub_mark = [row[j:j + len(stamp[0])] for row in stamp]\n                sub_nubs = find_nubs(sub_mark, mark)\n                if sub_nubs != -1:\n                    min_nubs = min(min_nubs, sub_nubs)\n    return str(min_nubs) if min_nubs != float('inf') else '0'\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n, m = map(int, input_lines[0].split())\n    mark = input_lines[1:]\n\n    def count_nubs(stamp):\n        return sum(1 for c in stamp if c == '#')\n\n    def is_valid_mark(mark, stamp):\n        width, height = len(mark[0]), len(mark)\n        for y in range(height):\n            for x in range(width):\n                if mark[y][x] == '#':\n                    if stamp[y * m + x] != '#':\n                        return False\n        return True\n\n    def find_min_nubs(stamps):\n        min_nubs = float('inf')\n        for stamp in stamps:\n            if is_valid_mark(mark, stamp):\n                min_nubs = min(min_nubs, count_nubs(stamp))\n        return min_nubs\n\n    stamps = [stamp.replace('.', ' ').replace('#', '# ') for stamp in ['.' * m for _ in range(n)]]\n    stamps = [s.split() for s in stamps]\n    stamps = [['#' if c == '#' else ' ' for c in s] for s in stamps]\n    stamps = [' '.join(s) for s in stamps]\n    stamps = [stamp.replace(' ', '#') for stamp in stamps]\n\n    min_nubs = find_min_nubs(stamps)\n\n    return str(min_nubs)"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def next_move(board, row, col, p):\n        # Move in the same row\n        for i in range(len(board[0])):\n            if board[row][i] == p:\n                board[row][i] = 1\n            else:\n                board[row][i] += 1\n                if board[row][i] > p:\n                    board[row][i] = 1\n\n        # Move in the same column\n        for i in range(len(board)):\n            if board[i][col] == p:\n                board[i][col] = 1\n            else:\n                board[i][col] += 1\n                if board[i][col] > p:\n                    board[i][col] = 1\n\n    # Read input\n    lines = stdin.split('\\n')\n    n, m, p = map(int, lines[0].split())\n    board = [list(map(int, lines[i].split())) for i in range(1, n + 1)]\n\n    # Initialize move count and sequence\n    move_count = 0\n    moves = []\n\n    # Iterate through rows and columns\n    for row in range(n):\n        for col in range(m):\n            if board[row][col] == p:\n                # Found a winning move, add it to sequence\n                moves.append(1 + row * m + col)\n                board[row][col] = 1\n                move_count += 1\n            else:\n                # Try all possible moves\n                for i in range(1, p + 1):\n                    # Move in the same row and column\n                    next_board = board.copy()\n                    next_move(next_board, row, col, p)\n\n                    # Move in the same row\n                    next_board_row = next_board.copy()\n                    next_move(next_board_row, row, col, p)\n\n                    # Move in the same column\n                    next_board_col = next_board.copy()\n                    next_move(next_board_col, row, col, p)\n\n                    # Check if the board is winning\n                    if all(board[i][j] == p for i in range(n) for j in range(m)):\n                        # Found a winning move, add it to sequence\n                        moves.append(1 + row * m + col)\n                        board[row][col] = i\n                        move_count += 1\n                        break\n\n                    # Check if the board is losing\n                    if all(next_board_row[i][j] == p for i in range(n) for j in range(m)):\n                        # Found a losing move, remove it from sequence\n                        moves.pop()\n                        move_count -= 1\n                        board[row][col] = i\n                        break\n\n                    # Check if the board is winning with this move\n                    if all(next_board_col[i][j] == p for i in range(n) for j in range(m)):\n                        # Found a winning move, add it to sequence\n                        moves.append(1 + row * m + col)\n                        board[row][col] = i\n                        move_count += 1\n                        break\n\n                # Check if the board is winning\n                if all(board[i][j] == p for i in range(n) for j in range(m)):\n                    # Found a winning move, add it to sequence\n                    moves.append(1 + row * m + col)\n                    board[row][col] = 1\n                    move_count += 1\n                    break\n\n    if move_count > p * m * n:\n        return -1\n    else:\n        return str(move_count) + '\\n' + ' '.join(map(str, moves))"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = []\n    for _ in range(n):\n        board.append(list(map(int, stdin.split()[3:])))\n    if not is_winning_sequence(board, n, m, p):\n        return str(-1)\n    moves = find_winning_sequence(board, n, m, p)\n    if moves is None:\n        return str(-1)\n    return str(len(moves)) + '\\n' + ' '.join(map(str, moves))\n\ndef"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m, p = map(int, stdin.splitlines()[0].split())\n    board = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Initialize variables\n    moves = 0\n    last_move = None\n    prev_board = None\n\n    # Function to update the board\n    def update_board(board, row, col, value):\n        nonlocal moves, last_move, prev_board\n        if prev_board:\n            for r in range(n):\n                for c in range(m):\n                    if prev_board[r][c] != board[r][c]:\n                        if prev_board[r][c] == 1:\n                            board[r][c] = p\n                        else:\n                            board[r][c] = prev_board[r][c] - 1\n            prev_board = None\n        if board[row][col] == p:\n            board[row][col] = 1\n        else:\n            board[row][col] += 1\n        moves += 1\n        last_move = (row, col)\n        prev_board = [row[:] for row in board]\n\n    # Check for winning move\n    def check_win(board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n\n    # Breadth-first search for winning move\n    def bfs(board):\n        nonlocal moves, last_move, prev_board\n        queue = [(board, 0)]\n        visited = set()\n        while queue:\n            board, move_count = queue.pop(0)\n            if move_count > p * m * n:\n                return -1\n            if check_win(board):\n                return move_count\n            for i in range(n):\n                for j in range(m):\n                    for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        new_i, new_j = i + di, j + dj\n                        if 0 <= new_i < n and 0 <= new_j < m and board[new_i][new_j] != -1:\n                            new_board = [row[:] for row in board]\n                            new_board[i][j] = -1\n                            update_board(new_board, new_i, new_j, 0)\n                            queue.append((new_board, move_count + 1))\n                            visited.add(tuple(map(tuple, new_board)))\n        return -1\n\n    # Main loop\n    while not check_win(board):\n        moves += 1\n        if moves > p * m * n:\n            break\n        i, j = last_move\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_i, new_j = i + di, j + dj\n            if 0 <= new_i < n and 0 <= new_j < m:\n                update_board(board, new_i, new_j, 0)\n                if check_win(board):\n                    break\n\n    # Check for winning move\n    if not check_win(board):\n        # Backtrack to find last winning move\n        while not check_win(board) and moves > 0:\n            moves -= 1\n            i, j = last_move\n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_i, new_j = i + di, j + dj\n                if 0 <= new_i < n and 0 <= new_j < m:\n                    board[new_i][new_j] = board[i][j]\n                    last_move = (new_i, new_j)\n                    if check_win(board):\n                        break\n        # Check if we found a winning move\n        if not check_win(board):\n            # Use breadth-first search to find a winning move\n            result = bfs("
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def next_move(board, row, col, p):\n        moves = []\n        for i in range(len(board)):\n            if board[i][row] != p:\n                moves.append((i, row))\n            if board[col][i] != p:\n                moves.append((col, i))\n        return moves\n    \n    def play(board, p):\n        n, m, _ = map(int, stdin.split())\n        moves = 0\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == p:\n                    return -1\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != 1:\n                    return -1\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == 1:\n                    board[i][j] = p\n        return board, moves\n\n    def find_winner(board, p, moves):\n        if moves >= p * len(board) * len(board[0]):\n            return True\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                board[i][j] = 1\n                if board[i][j] == p:\n                    return True\n        return False\n\n    def generate_moves(board, p):\n        moves = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                for row, col in next_move(board, i, j, p):\n                    if board[row][col] == p:\n                        board[row][col] = 1\n                    else:\n                        board[row][col] += 1\n                    if board[row][col] > p:\n                        board[row][col] = 1\n                    moves.append((row, col))\n                    if find_winner(board, p, len(moves)):\n                        return moves\n                    board[row][col] -= 1\n        return []\n\n    n, m, p = map(int, stdin.split())\n    board = [[0] * m for _ in range(n)]\n    board, moves = play(board, p)\n    if board == -1:\n        return -1\n    moves = generate_moves(board, p)\n    return moves if moves else -1"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, p = map(int, input_list[0].split())\n    board = [[0] * m for _ in range(n)]\n\n    for i in range(1, n + 1):\n        board[i - 1] = list(map(int, input_list[i].split()))\n\n    # Initialize the board with the numbers in the input\n    for i in range(n):\n        for j in range(m):\n            board[i][j] = (board[i][j] - 1) % p + 1\n\n    # BFS to check if the game can be won\n    visited = [[False] * m for _ in range(n)]\n    queue = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] == p:\n                visited[i][j] = True\n                queue.append((i, j, 0))\n\n    moves = []\n    max_moves = p * m * n\n\n    while queue and len(moves) < max_moves:\n        i, j, move_count = queue.pop(0)\n\n        if all(board[i][k] == p for k in range(m)):\n            # The game can be won\n            moves = [(i + 1) * m + j + 1] + moves\n            return len(moves)\n\n        if move_count >= max_moves:\n            continue\n\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_i, new_j = i + di, j + dj\n\n            if 0 <= new_i < n and 0 <= new_j < m and not visited[new_i][new_j]:\n                visited[new_i][new_j] = True\n                queue.append((new_i, new_j, move_count + 1))\n\n    return -1\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[3:][i:i+m])) for i in range(0, m*n, m)]\n    \n    def next_state(state, row, col):\n        new_state = state.copy()\n        new_state[row][col] = (state[row][col] + 1) % p\n        return new_state\n    \n    def bfs(board, visited):\n        queue = [(board, (0, 0))]\n        visited[0] = True\n        while queue:\n            board, (row, col) = queue.pop(0)\n            for i, j in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                new_row, new_col = row + i, col + j\n                if 0 <= new_row < n and 0 <= new_col < m and not visited[new_row][new_col]:\n                    new_board = next_state(board, new_row, new_col)\n                    if all(all(x == p for x in row) for row in new_board):\n                        return new_board\n                    visited[new_row][new_col] = True\n                    queue.append((new_board, (new_row, new_col)))\n        return None\n    \n    visited = [[False for _ in range(m)] for _ in range(n)]\n    board = bfs(board, visited)\n    if board is None:\n        return -1\n    \n    move_count = 0\n    moves = []\n    for i in range(n):\n        for j in range(m):\n            if board[i][j] != p:\n                moves.append(move_count + 1)\n                move_count += 1\n            if move_count == p * m * n:\n                break\n        if move_count == p * m * n:\n            break\n    moves.extend(list(itertools.chain.from_iterable(enumerate(board[i], 1))))\n    return ' '.join(map(str, moves))"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [[int(x) for x in input().split()] for _ in range(n)]\n\n    def is_win(board, p):\n        return all(all(x == p for x in row) for row in board)\n\n    def move(board, i, j, p):\n        for x in range(n):\n            for y in range(m):\n                if i == x and j == y:\n                    board[x][y] = (board[x][y] + 1) % p\n                elif j == y:\n                    board[x][y] = (board[x][y] + 1) % p\n                elif i == x:\n                    board[x][y] = (board[x][y] + 1) % p\n\n    moves = []\n    k = 0\n    while k < p * m * n and not is_win(board, p):\n        for i in range(n):\n            for j in range(m):\n                move(board, i, j, p)\n                moves.append(i * m + j + 1)\n                k += 1\n                if k >= p * m * n:\n                    break\n            if k >= p * m * n:\n                break\n        if not is_win(board, p):\n            for i in range(n - 1, -1, -1):\n                for j in range(m):\n                    move(board, i, j, p)\n                    moves.append(i * m + j + 1)\n                    k += 1\n                    if k >= p * m * n:\n                        break\n                if k >= p * m * n:\n                    break\n            if not is_win(board, p):\n                for i in range(n):\n                    for j in range(m - 1, -1, -1):\n                        move(board, i, j, p)\n                        moves.append(i * m + j + 1)\n                        k += 1\n                        if k >= p * m * n:\n                            break\n                    if k >= p * m * n:\n                        break\n            if not is_win(board, p):\n                for i in range(n - 1, -1, -1):\n                    for j in range(m - 1, -1, -1):\n                        move(board, i, j, p)\n                        moves.append(i * m + j + 1)\n                        k += 1\n                        if k >= p * m * n:\n                            break\n                    if k >= p * m * n:\n                        break\n            if not is_win(board, p):\n                for i in range(n - 1, -1, -1):\n                    for j in range(m):\n                        move(board, i, j, p)\n                        moves.append(i * m + j + 1)\n                        k += 1\n                        if k >= p * m * n:\n                            break\n                    if k >= p * m * n:\n                        break\n                if not is_win(board, p):\n                    for i in range(n):\n                        for j in range(m - 1, -1, -1):\n                            move(board, i, j, p)\n                            moves.append(i * m + j + 1)\n                            k += 1\n                            if k >= p * m * n:\n                                break\n                        if k >= p * m * n:\n                            break\n                    if not is_win(board, p):\n                        for i in range(n - 1, -1, -1):\n                            for j in range(m - 1, -1, -1):\n                                move(board, i, j, p)\n                                moves.append(i * m + j + 1)\n                                k += 1\n                                if k >= p * m * n:\n                                    break\n                            if k >= p * m * n:\n                                break\n    return \"{}\".format(k) if k <= p * m * n else \"-1\"\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, input().split())) for _ in range(n)]\n\n    # Function to update the board after a move\n    def update_board(board, move):\n        row, col, value = move\n        # Update the value of the selected square\n        board[row][col] += value\n        # Wrap around if the value exceeds p\n        board[row][col] %= p + 1\n        # Update the values in the same row\n        for j in range(m):\n            if j != col:\n                board[row][j] += value\n                board[row][j] %= p + 1\n        # Update the values in the same column\n        for i in range(n):\n            if i != row:\n                board[i][col] += value\n                board[i][col] %= p + 1\n\n    # Function to check if the board is full of p\n    def is_winning(board):\n        return all(all(x == p for x in row) for row in board)\n\n    # Find the first move that wins the game\n    for row in range(n):\n        for col in range(m):\n            if board[row][col] != p:\n                move = (row, col, 1)\n                update_board(board, move)\n                if is_winning(board):\n                    return f\"{len(move) + 1}\\n\" + \" \".join(map(str, [x for row in board for x in row]))\n                else:\n                    # Try adding the value of p to the selected square\n                    move = (row, col, p)\n                    update_board(board, move)\n                    if is_winning(board):\n                        return f\"{len(move) + 1}\\n\" + \" \".join(map(str, [x for row in board for x in row]))\n                    else:\n                        # Try adding the value of 2p to the selected square\n                        move = (row, col, 2 * p)\n                        update_board(board, move)\n                        if is_winning(board):\n                            return f\"{len(move) + 1}\\n\" + \" \".join(map(str, [x for row in board for x in row]))\n                        else:\n                            # Undo the move and try the next one\n                            board[row][col] -= 1\n    # If no winning sequence was found, return -1\n    return \"-1\\n\""
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n, m, p = input_values[0], input_values[1], input_values[2]\n    board = [input_values[3+i:3+i+m] for i in range(0, n*m, m)]\n    \n    def add_one(board, i, j):\n        for x in range(max(i-1, 0), min(i+2, n)):\n            for y in range(max(j-1, 0), min(j+2, m)):\n                board[x][y] = (board[x][y] % p) + 1\n                if board[x][y] == p + 1:\n                    board[x][y] = 1\n    \n    def win_game(board):\n        for row in board:\n            if all(val == p for val in row):\n                return True\n        for col in range(m):\n            if all(board[row][col] == p for row in range(n)):\n                return True\n        return False\n    \n    k = 0\n    move_sequence = []\n    for i in range(n):\n        for j in range(m):\n            add_one(board, i, j)\n            move_sequence.append(i*m+j+1)\n            k += 1\n            if win_game(board):\n                return k, move_sequence\n    return -1\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, input().split())) for _ in range(n)]\n    \n    def is_winning(board):\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] != p:\n                    return False\n        return True\n    \n    def get_next_state(board, row, col):\n        next_board = [row[:] for row in board]\n        for i in range(n):\n            if i != row:\n                for j in range(m):\n                    if board[i][j] == p:\n                        next_board[i][j] = 1\n            if i == row:\n                for j in range(m):\n                    if j != col:\n                        if board[i][j] == p:\n                            next_board[i][j] = 1\n        return next_board\n    \n    def dfs(board, depth, moves):\n        if depth == p * m * n:\n            return moves\n        if is_winning(board):\n            return moves\n        for row in range(n):\n            for col in range(m):\n                next_board = get_next_state(board, row, col)\n                dfs(next_board, depth + 1, moves + [(row * m + col) % (p * m * n) + 1])\n    \n    moves = dfs(board, 0, [])\n    if not moves:\n        return -1\n    else:\n        return len(moves), ' '.join(map(str, moves))"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    u = [int(u) for u in stdin.split(\"\\n\")[1:N]]\n    p = [int(p) - 1 for p in stdin.split(\"\\n\")[N:]]\n    longest_jumping_path = 0\n    jumping_paths = set()\n\n    def dfs(v, depth):\n        nonlocal longest_jumping_path\n        nonlocal jumping_paths\n\n        for child in range(v + 1, N):\n            if p[child] == v:\n                dfs(child, depth + 1)\n                if depth + 1 > longest_jumping_path:\n                    longest_jumping_path = depth + 1\n                    jumping_paths = set()\n                elif depth + 1 == longest_jumping_path:\n                    jumping_paths.add(tuple(u[:depth + 1]))\n\n    dfs(0, 0)\n\n    M = 0\n    for path in jumping_paths:\n        if all(u[i] <= u[i + 1] for i in range(len(path) - 1)):\n            M += 1\n\n    return f\"{longest_jumping_path} {M % 11092019}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, parent: int, dp: list[int], labels: list[int]):\n        dp[u] = 1\n        for v in tree[u]:\n            if v != parent:\n                dfs(v, u, dp, labels)\n                if labels[u] <= labels[v]:\n                    dp[u] = max(dp[u], dp[v] + 1)\n\n    N = int(stdin[0])\n    labels = list(map(int, stdin[1:N+1]))\n    tree = [[] for _ in range(N)]\n    for i in range(N-1):\n        u, v = map(int, stdin[N+i].split())\n        tree[u].append(v)\n    dp = [1] * N\n    dfs(0, -1, dp, labels)\n    L = max(dp)\n\n    M = 0\n    for i in range(N):\n        for j in range(i+2, N):\n            if labels[i] <= labels[j] and labels[j] <= labels[i] + L:\n                M += 1\n    M %= 11092019\n\n    return f\"{L} {M}\""
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, parent: int) -> List[Tuple[int, int]]:\n        jumps = [(u[v], v)]\n        for child in graph[v]:\n            if child != parent:\n                jumps += dfs(child, v)\n        return jumps\n\n    N = int(stdin[0])\n    u = [int(line) for line in stdin[1:N+1]]\n    graph = [[] for _ in range(N+1)]\n    for line in stdin[N+1:]:\n        v, parent = map(int, line.split())\n        graph[v].append(parent)\n\n    jumping_paths = []\n    for v in range(2, N+1):\n        for parent in graph[v]:\n            jumping_paths += dfs(v, parent)\n\n    jumps = sorted(jumping_paths, key=lambda x: x[0])\n    longest_jumping_path = jumps[-1][1]\n    longest_jumping_path_length = jumps[-1][0]\n\n    count = 0\n    for i in range(len(jumps)-1):\n        if jumps[i][0] == longest_jumping_path_length and jumps[i+1][0] != jumps[i][0]:\n            count += 1\n\n    remainder = count % 11092019\n\n    return f\"{longest_jumping_path_length} {remainder}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, parent: int) -> int:\n        max_jump = 1\n        for child in graph[v]:\n            if child != parent:\n                max_jump = max(max_jump, dfs(child, v))\n        return max_jump\n\n    def find_paths(v: int, parent: int, path: List[int], max_jump: int) -> int:\n        path.append(v)\n        if len(path) == max_jump:\n            nonlocal paths_found\n            paths_found += 1\n        else:\n            for child in graph[v]:\n                if child != parent:\n                    find_paths(child, v, path, max_jump)\n        path.pop()\n\n    N, *labels = map(int, stdin.split())\n    graph = [[] for _ in range(N)]\n    for i in range(1, N):\n        u, v = labels[i-1], labels[labels[i-1]-1]\n        graph[v].append(i)\n    max_jump = dfs(1, -1)\n    paths_found = 0\n    for v in range(1, N):\n        find_paths(v, -1, [], max_jump)\n    M = paths_found % 11092019\n    return f\"{max_jump} {M}\"\n\n\ndef"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0].strip())\n    labels = list(map(int, stdin[1:N+1]))\n    parents = list(map(int, stdin[N+1:2*N]))\n    max_length = 0\n    paths = set()\n\n    def backtrack(node: int, path: list):\n        nonlocal max_length, paths\n        path.append(node)\n        for child in range(len(parents)):\n            if child != node and parents[child] == node:\n                if len(path) > max_length:\n                    max_length = len(path)\n                if path[-1] > path[-2]:\n                    path_str = ' '.join(map(str, path))\n                    paths.add(path_str)\n                backtrack(child, path[:])\n        path.pop()\n\n    backtrack(0, [])\n    max_length = max_length - 1\n\n    for path in paths:\n        if len(path.split()) == max_length:\n            path_list = list(map(int, path.split()))\n            if all(labels[path_list[i-1]] <= labels[path_list[i]] for i in range(1, len(path_list))):\n                max_length += 1\n\n    mod = 11092019\n    M = len(paths) % mod\n\n    return f\"{max_length} {M}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, labels, visited, path, path_labels, longest_path_len, longest_path_count):\n        visited[node] = True\n        path.append(node)\n        path_labels.append(labels[node])\n        for child in range(1, N+1):\n            if graph[node][child] == 1 and child != parent:\n                if not visited[child]:\n                    dfs(child, node, labels, visited, path, path_labels, longest_path_len, longest_path_count)\n                    if len(path) > longest_path_len:\n                        longest_path_len = len(path)\n                        longest_path_count = 1\n                    elif len(path) == longest_path_len and path_labels == path_labels:\n                        longest_path_count += 1\n        path.pop()\n        path_labels.pop()\n        visited[node] = False\n\n    def is_nondecreasing(labels):\n        for i in range(len(labels) - 1):\n            if labels[i] > labels[i+1]:\n                return False\n        return True\n\n    N = int(stdin.splitlines()[0])\n    labels = [int(line) for line in stdin.splitlines()[1:N+1]]\n    graph = [[0] * (N+1) for _ in range(N+1)]\n    for i in range(N-1):\n        u, v = map(int, stdin.splitlines()[i+N+1].split())\n        graph[u][v] = graph[v][u] = 1\n    longest_path_len = 0\n    longest_path_count = 0\n    visited = [False] * (N+1)\n    for node in range(1, N+1):\n        if not visited[node]:\n            path = []\n            path_labels = []\n            dfs(node, -1, labels, visited, path, path_labels, longest_path_len, longest_path_count)\n    mod = 11092019\n    remainder = (longest_path_count * pow(mod, mod - 2, mod)) % mod\n    return f\"{longest_path_len} {remainder}\" "
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_ancestor(p: int, v: int) -> int:\n        while v != p:\n            v, p = p, u[v]\n        return v\n\n    n, u, p = 1, [0] * (1 + stdin.count('\\n')), [-1] * (1 + stdin.count('\\n'))\n    for line in stdin.split('\\n'):\n        if not line:\n            continue\n        v = int(line)\n        u[n], p[n] = v, p[p[n]]\n        n += 1\n\n    longest_jumping_path_length = 0\n    longest_jumping_paths_count = 0\n    for i in range(2, n):\n        for j in range(2, n):\n            if u[i] <= u[j] and u[p[i]] <= u[p[j]]:\n                path_length = 2\n                while p[i] != p[j]:\n                    if u[p[i]] <= u[p[j]]:\n                        i, j = p[i], p[j]\n                    path_length += 1\n                if path_length > longest_jumping_path_length:\n                    longest_jumping_path_length = path_length\n                    longest_jumping_paths_count = 1\n                elif path_length == longest_jumping_path_length:\n                    longest_jumping_paths_count += 1\n\n    return f\"{longest_jumping_path_length} {longest_jumping_paths_count % 11092019}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, parent: int) -> tuple:\n        max_length = 1\n        max_path = [v]\n        for child in tree[v]:\n            if child != parent:\n                length, path = dfs(child, v)\n                if length > max_length:\n                    max_length = length\n                    max_path = path\n        if parent is not None:\n            max_path.append(parent)\n        return max_length, max_path\n\n    N = int(stdin.split(\"\\n\")[0])\n    u = [int(x) for x in stdin.split(\"\\n\")[1:N+1]]\n    tree = [[] for _ in range(N+1)]\n    for i in range(2, N+1):\n        parent = int(stdin.split(\"\\n\")[i])\n        tree[parent].append(i)\n\n    max_length, max_path = dfs(1, None)\n    for i in range(len(max_path)-1):\n        if u[max_path[i]] >= u[max_path[i+1]]:\n            max_path = max_path[i+1:]\n            break\n\n    M = 0\n    for i in range(len(max_path)-1):\n        for j in range(i+1, len(max_path)):\n            if u[max_path[i]] <= u[max_path[j]]:\n                M += 1\n    M %= 11092019\n\n    return \" \".join([str(max_length), str(M)])\n\ninput_file = \"input.txt\"  # change this line to use a different input file\noutput_file = \"output.txt\"  # change this line to use a different output file\n\nwith open(input_file, \"r\") as f:\n    input_text = f.read()\n\nwith open(output_file, \"w\") as f:\n    f.write(solution(input_text))\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, *labels = [int(x) for x in stdin.split('\\n')]\n    adj_list = [[] for _ in range(N)]\n\n    for i in range(N - 1):\n        u, v = map(int, stdin.split()[i + N])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(node, parent, path):\n        path.append(node)\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, node, path)\n\n    paths = []\n    for i in range(N):\n        path = []\n        dfs(i, -1, path)\n        paths.append(path)\n\n    longest_path = []\n    for path in paths:\n        if len(path) > len(longest_path):\n            longest_path = path\n\n    nondecreasing_longest_path = [longest_path[0]]\n    for i in range(1, len(longest_path)):\n        if labels[longest_path[i - 1]] <= labels[longest_path[i]]:\n            nondecreasing_longest_path.append(longest_path[i])\n\n    def jumping_paths(node, path):\n        path.append(node)\n        for child in adj_list[node]:\n            if child not in path:\n                jumping_paths(child, path)\n\n    M = 0\n    for path in paths:\n        nondecreasing_path = [longest_path[0]]\n        for i in range(1, len(path)):\n            if labels[longest_path[i - 1]] <= labels[longest_path[i]]:\n                nondecreasing_path.append(longest_path[i])\n        if nondecreasing_path == nondecreasing_longest_path:\n            path_count = 1\n            for i in range(1, len(adj_list[node])):\n                path = [longest_path[0]]\n                jumping_paths(adj_list[node][i], path)\n                path_count += 1\n            M += path_count\n\n    M = M % 11092019\n\n    return f\"{len(nondecreasing_longest_path)} {M}\"\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    labels = [int(input_list[i]) for i in range(1, N+1)]\n    tree = [int(input_list[N+i])-1 for i in range(1, N)]\n\n    def dfs(v: int, prev: int) -> int:\n        max_len = 1\n        for u in tree[v]:\n            if u != prev:\n                max_len = max(max_len, dfs(u, v)+1)\n        return max_len\n\n    max_len = 0\n    jumping_paths = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if labels[i] <= labels[j]:\n                current_len = dfs(i, -1)\n                if current_len > max_len:\n                    max_len = current_len\n                    jumping_paths = 1\n                elif current_len == max_len:\n                    jumping_paths += 1\n\n    mod = 11092019\n    result = max_len * jumping_paths\n    return f\"{max_len} {result % mod}\""
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int) -> int:\n        if node == 1:\n            return 0\n        max_ancestor = dfs(parent, p[parent])\n        for child in range(1, n + 1):\n            if child == node or p[child] != parent:\n                continue\n            max_child = dfs(child, p[child])\n            if v[parent] <= v[child] and max_ancestor < max_child + 1:\n                max_ancestor = max_child + 1\n        return max_ancestor\n\n    n = int(stdin.split(\"\\n\")[0])\n    v = []\n    p = []\n    for i in range(n):\n        v.append(int(stdin.split(\"\\n\")[i + 1].split()[0]))\n        p.append(int(stdin.split(\"\\n\")[i + 1].split()[1]))\n    max_ancestor = dfs(1, p[1])\n    max_descendant = 0\n    for i in range(2, n + 1):\n        if p[i] == 1:\n            max_descendant = max(max_descendant, dfs(i, p[i]))\n    return max_ancestor + max_descendant + 1"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    node_values = []\n    parent_indices = []\n    for i in range(n):\n        node_value, parent_index = map(int, stdin.split())\n        node_values.append(node_value)\n        parent_indices.append(parent_index)\n\n    max_size = 0\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if parent_indices[i] == j or parent_indices[j] == i:\n                continue\n            if node_values[i] > node_values[j]:\n                max_size = max(max_size, 1)\n                break\n\n    return str(max_size)\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    nodes = {}\n    for i in range(1, n+1):\n        v, p = map(int, input_list[i].split())\n        nodes[i] = {'value': v, 'parent': p}\n\n    max_count = 1\n    for i in range(2, n+1):\n        count = 1\n        node = i\n        while node in nodes:\n            if nodes[node]['parent'] in nodes and nodes[nodes[node]['parent']]['value'] < nodes[node]['value']:\n                count += 1\n            node = nodes[node]['parent']\n        max_count = max(max_count, count)\n\n    return str(max_count)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    v = [0] * (n + 1)\n    p = [0] * (n + 1)\n    max_nodes = 1\n    for i in range(1, n + 1):\n        v[i], p[i] = map(int, input_list[i].split())\n\n    for i in range(2, n + 1):\n        max_nodes = max(max_nodes, i)\n        if v[i] <= v[p[i]]:\n            max_nodes = i\n        else:\n            break\n\n    return str(max_nodes)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int) -> int:\n        if node == 0:\n            return 0\n        size = 1\n        for child in range(1, n+1):\n            if parent[child] == node:\n                size += dfs(child, node)\n        return size\n\n    n = int(stdin.split(\"\\n\")[0])\n    parent = [0] * (n + 1)\n    for i in range(1, n + 1):\n        parent[i] = int(stdin.split(\"\\n\")[i].split()[1])\n\n    size = [0] * (n + 1)\n    for i in range(1, n + 1):\n        size[i] = dfs(i, parent[i])\n\n    max_size = max(size[1:])\n    max_node = size.index(max_size)\n    heap_nodes = [max_node]\n    for i in range(1, n + 1):\n        if size[i] == max_size and i != max_node:\n            heap_nodes.append(i)\n\n    return len(heap_nodes)\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    values = []\n    parents = []\n    for i in range(n):\n        v, p = map(int, input().split())\n        values.append(v)\n        parents.append(p)\n\n    # Find the maximum number of nodes that can be added to the heap\n    max_heap_size = 0\n    for i in range(1, n):\n        parent = parents[i]\n        if parent == 0:\n            continue\n        if values[i] > values[parent]:\n            max_heap_size += 1\n\n    return str(max_heap_size)\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_parent(i: int) -> int:\n        return i // 2 if i > 1 else None\n\n    def get_max_heap_size(n: int, parent_value: int) -> int:\n        if parent_value < 0:\n            return 0\n        if parent_value == 1:\n            return 1\n        return get_max_heap_size(n, parent_value // 2) + 1\n\n    n = int(stdin.splitlines()[0])\n    values = [int(line.split()[0]) for line in stdin.splitlines()[1:]]\n\n    max_heap_size = 0\n    for value in values:\n        parent_value = value\n        while parent_value > 0:\n            parent = get_parent(parent_value)\n            if parent is None or parent_value >= values[parent]:\n                break\n            parent_value = values[parent]\n        max_heap_size = max(max_heap_size, get_max_heap_size(n, parent_value))\n\n    return str(max_heap_size)\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_largest_subset(parent, visited):\n        largest_subset = 0\n        for child in range(1, n):\n            if parent[child] == i:\n                if visited[child]:\n                    continue\n                largest_subset = max(largest_subset, 1 + find_largest_subset(parent, visited))\n        return largest_subset\n\n    n = int(stdin.split(\"\\n\")[0])\n    parent = [int(x.split()[1]) for x in stdin.split(\"\\n\")[1:]]\n    visited = [False] * n\n    visited[0] = True\n    max_subset = 0\n    for i in range(1, n):\n        max_subset = max(max_subset, 1 + find_largest_subset(parent, visited))\n    return str(max_subset)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(node_list: List[int]) -> List[int]:\n        tree = [0] * n\n        for i, v_i in enumerate(node_list):\n            tree[i] = v_i\n        return tree\n\n    def is_ancestor(parent: int, child: int) -> bool:\n        return parent > 0 and parent <= child\n\n    def find_max_heap_subset(tree: List[int]) -> int:\n        max_heap_nodes = 1\n        for i in range(1, n):\n            for j in range(1, n):\n                if is_ancestor(i, j) and tree[i] > tree[j]:\n                    max_heap_nodes += 1\n                    break\n        return max_heap_nodes\n\n    n, *node_list = stdin.split()\n    n = int(n)\n    node_list = [int(x) for x in node_list]\n    node_list = build_tree(node_list)\n    max_heap_nodes = find_max_heap_subset(node_list)\n    return str(max_heap_nodes)"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int):\n        if node in visited:\n            return\n        visited.add(node)\n        for child in range(1, n+1):\n            if adj[node][child] == 1:\n                dfs(child, node)\n\n    def heapify(node: int, parent: int):\n        if node == 1:\n            return\n        left, right = node*2, node*2+1\n        max_node = node\n        if left <= n and v[max_node] < v[left]:\n            max_node = left\n        if right <= n and v[max_node] < v[right]:\n            max_node = right\n        if max_node != node:\n            v[node], v[max_node] = v[max_node], v[node]\n            heapify(max_node, parent)\n\n    n = int(stdin.split(\"\\n\")[0])\n    adj = [[0]*(n+1) for _ in range(n+1)]\n    v = [0]*(n+1)\n    visited = set()\n\n    for i in range(1, n+1):\n        v[i], p = map(int, stdin.split(\"\\n\")[i].split())\n        adj[p][i] = 1\n\n    dfs(1, 0)\n    heapify(1, 0)\n\n    return len(visited)"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import chain\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    edges = [(int(a), int(b), int(c)) for a, b, c in [line.split() for line in input_data[1:]]]\n    adj_list = defaultdict(list)\n    for a, b, c in edges:\n        adj_list[a].append((b, c))\n        adj_list[b].append((a, c))\n    def dfs(node, color, visited, colors):\n        visited[node] = True\n        for neighbor, neighbor_color in adj_list[node]:\n            if neighbor not in visited:\n                if neighbor_color == color:\n                    colors[neighbor] = neighbor_color\n                else:\n                    colors[neighbor] = None\n                dfs(neighbor, neighbor_color, visited, colors)\n    good_nodes = []\n    for i in range(1, n+1):\n        visited = [False] * (n+1)\n        colors = [None] * (n+1)\n        dfs(i, None, visited, colors)\n        if all(colors[1:n+1]):\n            good_nodes.append(i)\n    return f'{len(good_nodes)}\\n' + '\\n'.join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, graph: dict, visited: set, rainbow: set, color: str) -> bool:\n        visited.add(node)\n        rainbow.add(color)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                if not dfs(neighbor, graph, visited, rainbow, graph[node][neighbor]):\n                    return False\n                if len(rainbow) < len(graph[node]) - 1:\n                    return False\n        return True\n\n    def is_good(node: int, graph: dict) -> bool:\n        visited = set()\n        for neighbor in graph[node]:\n            if not dfs(neighbor, graph, visited, set(), graph[node][neighbor]):\n                return False\n        return True\n\n    def get_good_nodes(graph: dict) -> List[int]:\n        return [node for node in range(1, n + 1) if is_good(node, graph)]\n\n    n, *edges = stdin.split('\\n')\n    n = int(n)\n    graph = {i: {} for i in range(1, n + 1)}\n    for edge in edges:\n        a, b, c = map(int, edge.split())\n        graph[a][b] = c\n    good_nodes = get_good_nodes(graph)\n    k = len(good_nodes)\n    output = [str(k)] + [str(node) for node in good_nodes]\n    return '\\n'.join(output)\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input = [line.split() for line in stdin.split('\\n')]\n    n = int(input[0][0])\n    edges = [(int(a), int(b), int(c)) for a, b, c in input[1:]]\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b, c in edges:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    def dfs(node, color, visited, colors, good_nodes):\n        visited.add(node)\n        for neighbor, edge_color in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, edge_color, visited, colors, good_nodes)\n                if edge_color == colors[-1]:\n                    good_nodes.pop()\n                colors.append(edge_color)\n\n    good_nodes = []\n    for node in range(1, n + 1):\n        if all(dfs(node, None, set(), [], good_nodes) for _ in range(n)):\n            good_nodes.append(node)\n\n    return len(good_nodes), *(str(node) for node in good_nodes)\n\ninput_str = \"\"\"8\n1 3 1\n2 3 1\n3 4 3\n4 5 4\n5 6 3\n6 7 2\n6 8 2\"\"\"\nprint(solution(input_str))\n\ninput_str = \"\"\"8\n1 2 2\n1 3 1\n2 4 3\n2 7 1\n3 5 2\n5 6 2\n7 8 1\"\"\"\nprint(solution(input_str))\n\ninput_str = \"\"\"9\n1 2 2\n1 3 1\n1 4 5\n1 5 5\n2 6 3\n3 7 3\n4 8 1\n5 9 2\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    edges = [tuple(map(int, input_lines[i].split())) for i in range(1, n)]\n\n    def dfs(node: int, color: int, parent: int, visited: set, good_nodes: set):\n        visited.add(node)\n        for neighbor, neighbor_color in [(a, c) for a, b, c in edges if b == node]:\n            if neighbor not in visited and neighbor != parent:\n                if dfs(neighbor, neighbor_color, node, visited, good_nodes):\n                    good_nodes.add(node)\n        return node in good_nodes\n\n    good_nodes = set()\n    visited = set()\n    for node in range(1, n + 1):\n        if node not in visited:\n            if dfs(node, 0, -1, visited, good_nodes):\n                good_nodes.add(node)\n\n    k = len(good_nodes)\n    output = f\"{k}\\n\" + \"\\n\".join(map(str, sorted(good_nodes)))\n    return output\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, color: int, visited: set, graph: list, rainbow_path: set):\n        visited.add(node)\n        rainbow_path.add(color)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, graph[node][neighbor], visited, graph, rainbow_path)\n                if len(rainbow_path) != len(set(rainbow_path)):\n                    return False\n        return True\n\n    def is_good_node(node: int, graph: list) -> bool:\n        visited = set()\n        rainbow_path = set()\n        return dfs(node, 0, visited, graph, rainbow_path)\n\n    n = int(stdin)\n    graph = [{} for _ in range(n)]\n    for line in stdin.split('\\n')[1:-1]:\n        a, b, c = map(int, line.split())\n        graph[a - 1][b - 1] = c\n        graph[b - 1][a - 1] = c\n\n    good_nodes = [node for node in range(n) if is_good_node(node, graph)]\n    k = len(good_nodes)\n\n    return f\"{k}\\n\" + \"\\n\".join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    edges = [tuple(map(int, line.split())) for line in input_data[1:]]\n    \n    adj_list = [[] for _ in range(n)]\n    colors = [{} for _ in range(n)]\n    for a, b, c in edges:\n        adj_list[a-1].append(b-1)\n        adj_list[b-1].append(a-1)\n        colors[a-1][b-1] = c\n        colors[b-1][a-1] = c\n    \n    def dfs(node, prev, color, seen):\n        seen[node] = True\n        for next_node in adj_list[node]:\n            if next_node != prev:\n                c1 = colors[node][next_node]\n                c2 = color\n                if c1 in colors[next_node].values():\n                    return False\n                if dfs(next_node, node, c1, seen):\n                    return False\n        return True\n    \n    good_nodes = []\n    for i in range(n):\n        if all(dfs(i, -1, -1, [False]*n) for j in range(n)):\n            good_nodes.append(i)\n    \n    k = len(good_nodes)\n    return f\"{k}\\n\" + \"\\n\".join(map(str, good_nodes))"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    adjacency_list = [[] for _ in range(n+1)]\n    color_map = [-1] * (n+1)\n    \n    for edge in edges:\n        a, b, c = edge\n        adjacency_list[a].append((b, c))\n        adjacency_list[b].append((a, c))\n    \n    def dfs(node, color, parent_color, visited):\n        visited[node] = True\n        color_map[node] = color\n        for neighbor, neighbor_color in adjacency_list[node]:\n            if neighbor not in visited:\n                if color == neighbor_color:\n                    return False\n                if not dfs(neighbor, (color + 1) % n, neighbor_color, visited):\n                    return False\n        return True\n    \n    count = 0\n    for node in range(1, n+1):\n        if dfs(node, 0, -1, [False] * (n+1)):\n            count += 1\n    return str(count) + '\\n' + '\\n'.join(str(i) for i, c in enumerate(color_map, 1) if c == -1) "
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, parent, colors, seen, result, depth):\n        seen.add(node)\n        for child in graph[node]:\n            if child != parent:\n                if child not in seen:\n                    dfs(child, node, colors, seen, result, depth + 1)\n                elif colors[child] != colors[node]:\n                    result.append((node, child))\n                    depth += 1\n                    \n    def dfs_path(node, parent, path, colors, seen):\n        seen.add(node)\n        path.append(node)\n        if node not in graph:\n            return path\n        for child in graph[node]:\n            if child != parent:\n                if child not in seen:\n                    path = dfs_path(child, node, path, colors, seen)\n                    if path:\n                        return path\n        path.pop()\n        return None\n    \n    n, *edges = stdin.split('\\n')\n    n = int(n)\n    graph = {i: set() for i in range(1, n + 1)}\n    colors = [1] * n\n    for a, b, c in map(int, edge.split()) for edge in edges]\n        graph[a].add(b)\n        graph[b].add(a)\n        colors[b] = c\n    \n    good_nodes = []\n    for node in range(1, n + 1):\n        seen = set()\n        result = []\n        dfs(node, None, colors, seen, result, 0)\n        if not result:\n            path = dfs_path(node, None, [], colors, set())\n            if path:\n                good_nodes.append(node)\n                \n    return len(good_nodes), *good_nodes"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, color: int, graph: list, visited: list):\n        visited[node] = True\n        for neighbor, n_color in graph[node]:\n            if not visited[neighbor]:\n                if n_color != color:\n                    dfs(neighbor, n_color, graph, visited)\n                else:\n                    return False\n        return True\n\n    n = int(stdin.split(\"\\n\")[0].strip())\n    graph = [[] for _ in range(n + 1)]\n    for edge in stdin.split(\"\\n\")[1:]:\n        a, b, c = map(int, edge.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    good_nodes = []\n    visited = [False] * (n + 1)\n    for i in range(1, n + 1):\n        if not visited[i]:\n            if dfs(i, -1, graph, visited):\n                good_nodes.append(i)\n\n    return len(good_nodes), *(str(node) for node in good_nodes)"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    edges = []\n    for i in range(1, len(input_data)):\n        a, b, c = map(int, input_data[i].split())\n        edges.append((a, b, c))\n\n    def dfs(u: int, color: int) -> bool:\n        for v, c in graph[u]:\n            if c != color:\n                if dfs(v, c):\n                    return True\n        return False\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v, c in edges:\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    good_nodes = []\n    for u in range(1, n + 1):\n        if all(dfs(u, c) for c in range(1, n + 1)):\n            good_nodes.append(u)\n\n    output = len(good_nodes)\n    for node in good_nodes:\n        output += f\"{node}\\n\"\n\n    return str(output)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    b, s = map(int, input_data[0].split())\n    program = input_data[1].split()\n    mem_banks = [[] for _ in range(b)]\n    var_count = [0] * (b * s)\n\n    def get_bank(var_index: int) -> int:\n        return var_index // s\n\n    def set_bank(var_index: int, bank_index: int):\n        mem_banks[bank_index].append(var_index)\n        var_count[var_index] += 1\n\n    def reset_bank(var_index: int):\n        bank_index = get_bank(var_index)\n        mem_banks[bank_index].remove(var_index)\n        var_count[var_index] -= 1\n\n    instruction_count = 0\n    for i, op in enumerate(program):\n        if op.startswith(\"R\"):\n            _, n, sub_program = op.split()\n            n = int(n)\n            sub_program = program[i + 1:i + n + 1]\n            sub_count, _ = solution(f\"{b} {s}\\n{' '.join(sub_program)}\")\n            instruction_count += n * sub_count\n        elif op.startswith(\"V\"):\n            var_index = int(op[1:])\n            instruction_count += var_count[var_index - 1] + 1\n        elif op == \"E\":\n            instruction_count += 1\n        else:\n            raise ValueError(\"Invalid operation\")\n\n    return instruction_count"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, input().split())\n    program = input().split()\n\n    # Initialize variables and BSR register\n    variables = [0] * (b * s)\n    bsr = None\n\n    # Helper function to calculate the minimum number of instructions to access a variable\n    def access_variable(var):\n        nonlocal variables, bsr\n        if bsr is None:\n            return 1 + access_memory(var // s, var % s)\n        else:\n            if bsr == var // s:\n                return 1 + access_memory(var % s)\n            else:\n                return 2 + access_memory(var // s, var % s)\n\n    # Helper function to calculate the minimum number of instructions to access a memory location\n    def access_memory(bank, offset):\n        nonlocal variables, bsr\n        if bank == 0:\n            return offset\n        elif bank == 1 and bsr is not None and bsr == bank:\n            return offset\n        else:\n            return 1 + access_memory(0, offset) + 1 + access_memory(bank, 0)\n\n    # Process the program\n    for i in range(len(program)):\n        if program[i].startswith(\"V\"):\n            var = int(program[i][1:]) - 1\n            variables[var] += access_variable(var)\n        elif program[i].startswith(\"R\"):\n            loop_body = program[i + 1:i + int(program[i][1:]) + 1]\n            for op in loop_body:\n                if op.startswith(\"V\"):\n                    var = int(op[1:]) - 1\n                    variables[var] += access_variable(var)\n                elif op.startswith(\"R\"):\n                    loop_body = op[1:].split()\n                    for op2 in loop_body:\n                        if op2.startswith(\"V\"):\n                            var = int(op2[1:]) - 1\n                            variables[var] += access_variable(var)\n\n    # Determine the minimum number of instructions executed\n    min_instructions = min(variables)\n    print(min_instructions)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, input().split())\n    program = input().split()\n\n    def count_refs(program: list[str]) -> int:\n        count = 0\n        for op in program:\n            if op.startswith('V'):\n                count += 1\n            elif op.startswith('R'):\n                count += count_refs(program)\n            elif op == 'E':\n                pass\n            else:\n                raise ValueError(f'Invalid operation: {op}')\n        return count\n\n    def min_refs(program: list[str], bank_size: int, bsr_size: int) -> int:\n        if not program:\n            return 0\n\n        refs = count_refs(program)\n        if refs <= b * s:\n            return refs\n\n        min_refs = float('inf')\n        for i in range(b):\n            for j in range(s):\n                new_program = []\n                for op in program:\n                    if op.startswith('V'):\n                        var_num = int(op[1:])\n                        new_program.append(f'R1{i * s + var_num - 1}')\n                    elif op.startswith('R'):\n                        num_reps, subprogram = map(str.strip, op.split('R'))\n                        new_program.append(f'R{num_reps} {subprogram} E')\n                    else:\n                        new_program.append(op)\n\n                min_refs = min(min_refs, 1 + min_refs(new_program, bank_size, bsr_size))\n\n        return min_refs\n\n    bank_size = b * s\n    bsr_size = 1\n    return min_refs(program, bank_size, bsr_size)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.splitlines()[0].split())\n    program = stdin.splitlines()[1].split()\n\n    # Map variables to memory banks\n    bank_map = {f\"V{i}\": i // s for i in range(1, b * s + 1)}\n\n    # Initialize instruction count\n    instruction_count = 0\n\n    # Initialize BSR register to None\n    BSR = None\n\n    for op in program:\n        if op.startswith(\"R\"):\n            # Repeat operation\n            n, program = op[2:].split(\"<\")\n            n = int(n)\n            for _ in range(n):\n                instruction_count += execute_program(program.rstrip(\">E\"), bank_map, BSR)\n        elif op.startswith(\"V\"):\n            # Variable reference\n            i = int(op[2:])\n            bank = bank_map[op]\n            instruction_count += 1\n        else:\n            # BSR register setting\n            BSR = int(op[2:])\n            instruction_count += 1\n\n    return instruction_count\n\n\ndef"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    banks, variables = map(int, input_lines[0].split())\n    program = input_lines[1].split()\n\n    # Determine the mapping of variables to memory banks\n    variable_to_bank = [None] * variables\n    for i in range(variables):\n        variable_to_bank[i] = i // banks\n\n    # Determine the minimum number of instructions required\n    min_instructions = 0\n    for op in program:\n        if op[0] == 'R':\n            # Repetition\n            n, program = op[1:].split('<')\n            min_instructions += int(n) * len(list(filter(lambda x: x[0] == 'V', program.split())))\n        else:\n            # Variable reference or BSR setting\n            min_instructions += 1\n\n    return min_instructions\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split(\",\"))\n    program = stdin.split()[1].split()\n    n = len(program)\n    min_instructions = 0\n\n    for i in range(n):\n        if program[i] == \"E\":\n            min_instructions += 1\n        else:\n            min_instructions += 2\n\n    return str(min_instructions)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.splitlines()[0].split())\n    program = stdin.splitlines()[1].split()\n    \n    def count_instr(program: str) -> int:\n        count = 0\n        for op in program:\n            if op[0] == 'V':\n                count += 1\n            elif op[0] == 'R':\n                count += int(op[1])\n        return count\n    \n    def get_bank_mapping(program: str) -> List[int]:\n        mapping = [0] * b\n        for op in program:\n            if op[0] == 'V':\n                mapping[int(op[1:]) - 1] = 1\n        return mapping\n    \n    def min_instr_count(program: str, mapping: List[int]) -> int:\n        count = 0\n        for i, op in enumerate(program):\n            if op[0] == 'V':\n                count += mapping[int(op[1:]) - 1]\n            elif op[0] == 'R':\n                count += int(op[1]) * len([j for j in range(i + 1, i + int(op[1])) if program[j][0] == 'V'])\n        return count\n    \n    instr_count = count_instr(program)\n    bank_mapping = get_bank_mapping(program)\n    min_count = min_instr_count(program, bank_mapping)\n    \n    return str(min_count)"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.splitlines()[0].split())\n    program = stdin.splitlines()[1].split()\n\n    def execute(op: str, i: int) -> int:\n        if op == 'V':\n            return (i - 1) % (b * s) + 1\n        elif op == 'R':\n            return int(program[i + 1])\n        else:\n            return 0\n\n    var_refs = [execute(op, i) for i, op in enumerate(program)]\n    unique_var_refs = list(set(var_refs))\n    mem_refs = sum(unique_var_refs)\n    return str(mem_refs)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split(','))\n    program = stdin.split()[1].split()\n    result = 0\n    \n    return result\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split(','))\n    program = stdin.split('\\n')[1].split()\n    bank_size = b * s\n    instruction_count = 0\n    bank_mapping = {}\n\n    for i, token in enumerate(program):\n        if token[0] == 'V':\n            index = int(token[1:])\n            if index <= bank_size:\n                bank = index // s\n                if bank not in bank_mapping:\n                    bank_mapping[bank] = set()\n                bank_mapping[bank].add(index)\n        elif token[0] == 'R':\n            n = int(token[1:])\n            for _ in range(n):\n                instruction_count += 1\n\n    if len(program) == 0 or len(program) % 2 != 0:\n        return str(instruction_count)\n\n    banks = list(bank_mapping.keys())\n    banks.sort()\n    bank_count = len(banks)\n    mapping = [False] * bank_count\n\n    for bank in banks:\n        if bank_count == 1:\n            return str(instruction_count)\n        for index in bank_mapping[bank]:\n            if index % s == 0:\n                mapping[index // s - 1] = True\n            else:\n                mapping[index // s] = True\n\n    min_instructions = 0\n    for i in range(bank_count):\n        if not mapping[i]:\n            min_instructions += bank_size // bank_count\n\n    return str(min_instructions + instruction_count)\n"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n\n    def f(base, num):\n        result = 0\n        while num > 0:\n            result += (num % base)\n            num //= base\n        return result\n\n    for x in range(1, 2**63):\n        if f(B, x) == N:\n            return str(x)\n\n    return \"impossible\"\n\ninput_data = \"10 24\\n10 11\\n9 216\\n10 50\\n\"\n\nfor line in input_data.strip().split(\"\\n\"):\n    print(solution(line)) "
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    \n    def f(x, B):\n        result = 0\n        while x > 0:\n            result += (x % B) ** 2\n            x //= B\n        return result\n    \n    # Find the minimum X such that f(X, B) >= N\n    for i in range(1, 2**63):\n        if f(i, B) >= N:\n            return str(i)\n    \n    return \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    \n    def f(num: int, base: int) -> int:\n        return sum(int(d) for d in str(num))\n    \n    for i in range(1, 2**63):\n        if f(i, B) == N:\n            return str(i)\n    \n    return \"impossible\""
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, n = map(int, stdin.split())\n    x = 0\n    while f(x, b) < n:\n        x += 1\n        if x >= 2**63:\n            return \"impossible\"\n    return str(x)\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, input().split())\n    X = 0\n    while f_B(X) != N:\n        X += 1\n        if X >= 2**63:\n            return \"impossible\"\n    return X\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n    while f(X, B) < N:\n        X += 1\n    if f(X, B) == N:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    x = 0\n    while True:\n        f_B = sum(int(digit) * B**i for i, digit in enumerate(str(x)))\n        if f_B == N:\n            return str(x)\n        elif f_B > N:\n            return \"impossible\"\n        x += 1"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    digits = [int(d) for d in str(N)]\n    f = lambda x: sum(int(d) * B ** i for i, d in enumerate(str(x)))\n    lo, hi = 1, 2**63\n    while lo < hi:\n        mid = (lo + hi) // 2\n        if f(mid) == N:\n            return str(mid)\n        elif f(mid) < N:\n            lo = mid + 1\n        else:\n            hi = mid\n    return \"impossible\"\n"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    if N == 0:\n        return \"1\"\n    if 2**63 <= N:\n        return \"impossible\"\n    while True:\n        X = 0\n        for digit in str(N):\n            X += int(digit)\n        if f_B(B, X):\n            return str(X)\n        if X == N:\n            return \"impossible\"\n\ndef"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, input().split())\n    X = 0\n    while f_B(X, B) < N:\n        X += 1\n    if f_B(X, B) == N:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    zip_info = input_list[0].split()\n    d, t, c, r = int(zip_info[0]), int(zip_info[1]), int(zip_info[2]), int(zip_info[3])\n    clouds = []\n    for i in range(1, c+1):\n        cloud_info = input_list[i].split()\n        s, e, p, a = int(cloud_info[0]), int(cloud_info[1]), float(cloud_info[2]), int(cloud_info[3])\n        clouds.append((s, e, p, a))\n\n    roofs = []\n    for i in range(c+1, c+1+r):\n        roof_info = input_list[i].split()\n        x, y = int(roof_info[0]), int(roof_info[1])\n        roofs.append((x, y))\n\n    def rain_amount(clouds, t):\n        total_amount = 0\n        for s, e, p, a in clouds:\n            if s < t <= e:\n                total_amount += p * a * (e-t)\n        return total_amount\n\n    def roof_rain(x, y, t):\n        total_rain = 0\n        for i in range(len(roofs)):\n            x1, y1 = roofs[i]\n            if x1 <= x <= y1:\n                total_rain += (y1-x1) * 0.5 * t\n        return total_rain\n\n    def expected_rain(clouds, t, d):\n        total_amount = rain_amount(clouds, t)\n        total_roof_rain = roof_rain(0, d, t)\n        expected_rain = total_amount + total_roof_rain\n        return expected_rain\n\n    min_expected_rain = expected_rain(clouds, t, d)\n    for i in range(1, t+1):\n        min_expected_rain = min(min_expected_rain, expected_rain(clouds, i, d))\n\n    return f\"{min_expected_rain:.5f}\"\n"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    d, t, c, r = map(int, inputs.pop(0).split())\n    clouds = []\n    for _ in range(c):\n        s, e, p, a = map(float, inputs.pop(0).split())\n        clouds.append((s, e, p, a))\n    \n    roofs = []\n    for _ in range(r):\n        x, y = map(int, inputs.pop(0).split())\n        roofs.append((x, y))\n    \n    def calculate_rain(time: float) -> int:\n        total_rain = 0\n        for s, e, p, a in clouds:\n            if s <= time <= e:\n                total_rain += a * p\n        return total_rain\n    \n    def expected_rain(distance: int) -> float:\n        time = t - distance / 1000 * 1000 / 100\n        return calculate_rain(time)\n    \n    def roof_rain(distance: int) -> float:\n        time = t - distance / 1000 * 1000 / 100\n        roof_dist = -1\n        for x, y in roofs:\n            if x <= distance <= y:\n                roof_dist = distance\n                break\n        return expected_rain(roof_dist)\n    \n    distance = 0\n    while distance < d:\n        expected_rain_at_distance = expected_rain(distance)\n        roof_rain_at_distance = roof_rain(distance)\n        if expected_rain_at_distance < roof_rain_at_distance:\n            break\n        distance += 1000\n    \n    return round(expected_rain(distance) * 1000, 5)"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    d, t, c, r = map(int, inputs[0].split())\n    clouds = [list(map(float, inputs[i+1].split())) for i in range(c)]\n    roofs = [(int(inputs[c+j].split()[0]), int(inputs[c+j].split()[1])) for j in range(r)]\n\n    def roof_cover(x, y, z):\n        return sum(y_j - x_j >= z for x_j, y_j in roofs)\n\n    def expected_rain(clouds, x, y, z):\n        total_prob = sum(p_i * (min(e_i, t) - max(s_i, t - y)) for s_i, e_i, p_i, _ in clouds)\n        rain_cover = sum(a_i * p_i * (min(e_i, t) - max(s_i, t - y)) for s_i, e_i, p_i, a_i in clouds)\n        return rain_cover / total_prob if total_prob > 0 else 0\n\n    def rain_probability(clouds, x, y):\n        return sum(p_i * (min(e_i, t) - max(s_i, t - y)) for s_i, e_i, p_i, _ in clouds)\n\n    def min_rain(x, y, z):\n        if roof_cover(x, y, z) == 0:\n            return expected_rain(clouds, x, y, z)\n        elif roof_cover(x, y, z) == 1:\n            return max(expected_rain(clouds, x, y, z), expected_rain(clouds, x+1, y, z))\n        else:\n            return min(expected_rain(clouds, x, y, z), expected_rain(clouds, x+1, y, z), min_rain(x+1, y, z))\n\n    x, y = d, 0\n    z = 0\n    while x >= 0 and y <= d:\n        if roof_cover(x, y, z) < r:\n            z += 1\n        else:\n            if z == 0:\n                expected_rain_ = expected_rain(clouds, x, y, z)\n                if expected_rain_ > 0:\n                    expected_rain_ = 0\n            else:\n                expected_rain_ = min_rain(x, y, z)\n            if expected_rain_ > 0:\n                return expected_rain_\n            else:\n                break\n        y += 1\n    return 0.0\n\ninputs = '''\\\n20 60 2 1\n5 15 0.33333 30\n22 60 0.66666 70\n0 10\n2 4 0.25 8\n1 3 0.66667 15\n2 4 0.25 8\n2 3 0.25 8\n2 4 0.25 8\n'''\n\noutput = solution(inputs)\nprint(output)"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    # Read input values\n    d, t, c, r = map(int, input_data[0].split())\n    input_data = input_data[1:]\n    clouds = []\n    for i in range(c):\n        s_i, e_i, p_i, a_i = map(float, input_data[i].split())\n        clouds.append((s_i, e_i, p_i, a_i))\n    input_data = input_data[c:]\n    roofs = []\n    for j in range(r):\n        x_j, y_j = map(int, input_data[j].split())\n        roofs.append((x_j, y_j))\n\n    # Initialize variables\n    rain_rate = 0.0\n    total_rain = 0.0\n    expected_rain = 0.0\n    rain_start = float('inf')\n    worst_cloud = None\n\n    # Find worst cloud\n    for cloud in clouds:\n        s_i, e_i, p_i, a_i = cloud\n        if p_i > 0 and a_i > total_rain:\n            total_rain = a_i\n            worst_cloud = cloud\n            rain_start = s_i\n\n    # Calculate expected rain\n    if worst_cloud:\n        s_i, e_i, p_i, a_i = worst_cloud\n        expected_rain = p_i * a_i * (e_i - s_i)\n\n    # Calculate worst case\n    worst_case = rain_rate * (t - d) + expected_rain\n\n    # Find roofs that may intercept worst case\n    for x_j, y_j in roofs:\n        if y_j <= d:\n            worst_case += (y_j - x_j) * rain_rate\n\n    # Calculate final result\n    result = worst_case + (1 - rain_rate) * (t - d)\n    return f\"{result:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def brute_force_min_rain(c: int, r: int, d: int, t: int, clouds: List[Tuple[int, int, float, int]], roofs: List[Tuple[int, int]], t_start: int) -> float:\n        def accumulated_rain(s: int, e: int, a: int, t: int) -> float:\n            return a * (e - s) if e - s <= t else a * t + a * (e - t)\n        \n        min_rain = float('inf')\n        for i in range(2 ** c):\n            rain_at_time = [0] * (t + 1)\n            for j in range(c):\n                if i & (1 << j):\n                    s, e, p, a = clouds[j]\n                    if p > 0:\n                        for k in range(s, e + 1):\n                            rain_at_time[k] += accumulated_rain(k, e, a, t) * p\n            rain_after_roofs = [0] * (d + 1)\n            for j in range(r):\n                x, y = roofs[j]\n                for k in range(x, y + 1):\n                    rain_after_roofs[k] = max(rain_after_roofs[k], rain_at_time[k])\n            for k in range(t_start, t + 1):\n                min_rain = min(min_rain, rain_after_roofs[k])\n        return min_rain\n    \n    def roof_travel_time(d: int, t: int, speed: float) -> float:\n        return d / speed\n    \n    def roof_intervals(roofs: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n        intervals = []\n        for x, y in roofs:\n            intervals.append((x, y))\n        intervals.sort(key=lambda x: x[0])\n        return intervals\n    \n    def roof_roads(intervals: List[Tuple[int, int]], d: int) -> List[int]:\n        roads = [0] * (d + 1)\n        for i in range(len(intervals)):\n            x, y = intervals[i]\n            roads[x - 1] = 1\n            roads[y] = -1\n        roads[0] = 0\n        roads[-1] = 0\n        return roads\n    \n    stdin_lines = stdin.split('\\n')\n    d, t, c, r = map(int, stdin_lines[0].split())\n    t_start = d - roof_travel_time(d, t, 1)\n    clouds = [(int(cloud_data.split()[0]), int(cloud_data.split()[1]), float(cloud_data.split()[2]), int(cloud_data.split()[3])) for cloud_data in stdin_lines[1:c + 1]]\n    roofs = [(int(roof_data.split()[0]), int(roof_data.split()[1])) for roof_data in stdin_lines[c + 1:c + 1 + r]]\n    intervals = roof_intervals(roofs)\n    roads = roof_roads(intervals, d)\n    \n    min_rain = brute_force_min_rain(c, r, d, t, clouds, intervals, t_start)\n    \n    return f\"{min_rain:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def roof_segment_overlap(x1, y1, x2, y2):\n        if x2 < x1 or y2 <= x1 or y1 >= y2:\n            return False\n        return True\n\n    def roof_area_under_curve(x1, y1, x2, y2, x):\n        if x < x1 or x >= x2:\n            return 0\n        return (x - x1) * (y2 - y1) / (x2 - x1)\n\n    def expected_rainfall(clouds, roofs, time):\n        total_rainfall = 0\n        for i in range(len(clouds)):\n            if clouds[i][0] <= time <= clouds[i][1]:\n                total_rainfall += clouds[i][3] * clouds[i][2]\n        for j in range(len(roofs)):\n            x1, y1 = roofs[j][0], roofs[j][1]\n            for k in range(j + 1, len(roofs)):\n                x2, y2 = roofs[k][0], roofs[k][1]\n                if roof_segment_overlap(x1, y1, x2, y2):\n                    area_under_curve = roof_area_under_curve(x1, y1, x2, y2, d)\n                    total_rainfall += area_under_curve\n        return total_rainfall\n\n    lines = stdin.splitlines()\n    d, t, c, r = map(int, lines[0].split())\n    clouds = [(int(x), int(y), float(z), int(w)) for x, y, z, w in (line.split() for line in lines[1:1 + c])]\n    roofs = [(int(x), int(y)) for x, y in (line.split() for line in lines[1 + c:])]\n\n    distance_to_rainfall = [(b - a) * p * a / 2 for s, e, p, a in clouds]\n    total_rainfall = sum(distance_to_rainfall)\n    roof_rainfall = expected_rainfall(clouds, roofs, t)\n\n    return f\"{total_rainfall + roof_rainfall:.5f}\""
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def prob_of_rain(clouds: list, time: int) -> float:\n        return sum([clouds[i][2] * clouds[i][3] * (min(clouds[i][1], time) - min(clouds[i][0], time)) for i in range(len(clouds))])\n\n    def expected_rain(clouds: list, time: int) -> float:\n        return sum([clouds[i][3] * (clouds[i][1] - clouds[i][0]) for i in range(len(clouds))])\n\n    def optimal_roof_breaks(roofs: list, dist: int) -> list:\n        breaks = [0]\n        for i in range(len(roofs)):\n            while len(breaks) % 2 == 0 and breaks[-1] + dist < roofs[i][1]:\n                breaks.append(breaks[-1] + dist)\n            breaks.append(roofs[i][1])\n        return breaks\n\n    def expected_rain_on_route(clouds: list, roofs: list, dist: int, time: int) -> float:\n        expected_rain_on_road = expected_rain(clouds, time)\n        breaks = optimal_roof_breaks(roofs, dist)\n        breaks_with_distances = [(breaks[i] - breaks[i - 1]) * 100 / dist for i in range(1, len(breaks), 2)]\n        roof_rain = sum([breaks_with_distances[i] * (time - breaks[2 * i - 1]) * clouds[i][3] for i in range(len(breaks) // 2)])\n        return expected_rain_on_road + roof_rain\n\n    # read input\n    d, t, c, r = map(int, stdin.split()[:4])\n    clouds = [list(map(float, input().split())) for _ in range(c)]\n    roofs = [list(map(int, input().split())) for _ in range(r)]\n\n    # calculate minimum expected rain\n    time_to_bus = d + t\n    time_to_min_rain = t + max(clouds[i][0] for i in range(c))\n    time_to_min_rain = max(time_to_min_rain, t + max(roofs[i][0] for i in range(len(roofs)) // 2))\n    min_expected_rain = min(expected_rain_on_route(clouds, roofs, d, time) for time in range(time_to_min_rain, time_to_bus + 1))\n\n    return f'{min_expected_rain:.5f}'"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_rainfall(clouds: list, time: int) -> int:\n        return sum(cloud[3] * cloud[2] * (time - cloud[0]) * (min(cloud[1], time) - cloud[0]))\n\n    def get_min_rainfall(clouds: list, roofs: list, home_distance: int, bus_stop_distance: int) -> int:\n        min_rainfall = 0\n        for i in range(len(clouds)):\n            cloud = clouds[i]\n            start_time = cloud[0]\n            end_time = cloud[1]\n            probability = cloud[2]\n            intensity = cloud[3]\n            time = start_time\n            while time <= end_time:\n                if time + 1 <= end_time:\n                    expected_rainfall = probability * get_rainfall(clouds, time)\n                else:\n                    expected_rainfall = probability * get_rainfall(clouds, end_time)\n                dist_to_bus_stop = math.sqrt((home_distance - time) ** 2 + (bus_stop_distance - time) ** 2)\n                dist_to_bus_stop *= 2  # Traveling to and from the bus stop\n                min_rainfall = max(min_rainfall, expected_rainfall * dist_to_bus_stop)\n                time += 1\n        return min_rainfall\n\n    lines = stdin.split('\\n')\n    home_distance = int(lines[0].split()[0])\n    bus_stop_distance = int(lines[0].split()[1])\n    t = int(lines[0].split()[1])\n    c = int(lines[0].split()[2])\n    r = int(lines[0].split()[3])\n    clouds = [tuple(map(float, lines[i+1].split())) for i in range(c)]\n    roofs = [(int(lines[c+1+i].split()[0]), int(lines[c+1+i].split()[1])) for i in range(r)]\n\n    min_rainfall = get_min_rainfall(clouds, roofs, home_distance, bus_stop_distance)\n    return round(min_rainfall, 5)\n"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    d, t, c, r = map(int, input_list[0].split())\n    cloud_info = [list(map(float, input_list[i+1].split())) for i in range(c)]\n    roof_info = [[*map(int, input_list[i+c+1].split())] for i in range(r)]\n\n    def calculate_rain(clouds, roofs):\n        def rainfall(cloud, roof):\n            if roof[0] <= cloud[0] <= roof[1]:\n                return cloud[3] * (cloud[1] - cloud[0])\n            else:\n                return 0\n\n        total_rain = 0\n        for cloud in clouds:\n            for roof in roofs:\n                total_rain += rainfall(cloud, roof)\n        return total_rain\n\n    def expected_rain(clouds, roofs):\n        def probability(cloud, roofs):\n            probability = 0\n            for roof in roofs:\n                if roof[0] <= cloud[0] <= roof[1]:\n                    probability += cloud[2] * (roof[1] - roof[0])\n            return probability\n\n        total_rain = 0\n        for cloud in clouds:\n            total_rain += cloud[3] * probability(cloud, roofs)\n        return total_rain\n\n    roof_segments = [(roof[0], roof[1]) for roof in roof_info]\n    rain_amount = calculate_rain(cloud_info, roof_segments)\n    expected_amount = expected_rain(cloud_info, roof_segments)\n\n    if d <= t:\n        return round(expected_amount, 5)\n    else:\n        return round(rain_amount, 5)\n"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    first_line = input_data[0].split()\n    d, t, c, r = map(int, first_line)\n    clouds = []\n    for i in range(1, c + 1):\n        line = input_data[i].split()\n        s, e, p, a = map(float, line)\n        clouds.append((s, e, p, a))\n    \n    roofs = []\n    for i in range(c + 1, c + 1 + r):\n        line = input_data[i].split()\n        x, y = map(int, line)\n        roofs.append((x, y))\n    \n    # Calculate the expected amount of rain on your route\n    expected_rain = 0\n    for cloud in clouds:\n        s, e, p, a = cloud\n        expected_rain += p * a * (e - s)\n    \n    # Calculate the maximum amount of rain you can expect at any point along your route\n    max_rain = 0\n    for roof in roofs:\n        x, y = roof\n        max_rain = max(max_rain, y - x)\n    \n    # Calculate the amount of expected rain that will fall on you within t seconds\n    expected_rain_on_you = expected_rain * t\n    \n    # Calculate the minimum amount of expected rain that will fall on you\n    min_rain_on_you = expected_rain_on_you - (d - max_rain) * 1000 / (2 * t)\n    \n    return f'{min_rain_on_you:.5f}'\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str):\n        N, W, O, R = input_str.split()\n        return O, W, float(R)\n\n    def trade_lemonade(offering, wanted, exchange_rate):\n        return exchange_rate * wanted\n\n    N = int(stdin.readline().strip())\n    children = [parse_input(input_str) for input_str in stdin.readlines()]\n    blue_lemonade = 0\n\n    for i in range(N):\n        offering, wanted, exchange_rate = children[i]\n        if wanted == \"blue\":\n            blue_lemonade += trade_lemonade(offering, wanted, exchange_rate)\n\n    return round(min(blue_lemonade, 10), 6)\n\ndef"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    P = float(10)\n    blue_lemonade = 0.0\n\n    for i in range(1, N+1):\n        input_line = input_data[i].split()\n        offer_lemonade = input_line[0]\n        want_lemonade = input_line[1]\n        rate = float(input_line[2])\n        if want_lemonade == \"blue\":\n            blue_lemonade += rate * P\n        P *= rate\n\n    return \"{:.6f}\".format(min(blue_lemonade, 10))"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        N = int(input())\n        input_data = []\n        for _ in range(N):\n            input_data.append(input().split() + [float(input())])\n        return input_data\n\n    def calculate_blue_lemonade(input_data, pink_lemonade):\n        total_lemonade = pink_lemonade / input_data[0][2]\n        total_blue_lemonade = 0\n        for lemonade in input_data[1:]:\n            if lemonade[0] == \"blue\":\n                total_blue_lemonade += lemonade[2] / lemonade[3] * total_lemonade\n        return total_blue_lemonade\n\n    input_data = read_input()\n    pink_lemonade = 0\n    for lemonade in input_data:\n        if lemonade[0] == \"pink\":\n            pink_lemonade += 1\n\n    max_blue_lemonade = calculate_blue_lemonade(input_data, pink_lemonade)\n    max_blue_lemonade = min(max_blue_lemonade, 10)\n\n    return f\"{max_blue_lemonade:.6f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, lemonades = input().split()\n    N = int(N)\n    max_blue = 0\n    \n    for _ in range(N):\n        offer, wanted, rate = input().split()\n        rate = float(rate)\n        max_blue += 10 * rate if offer == \"blue\" and wanted == \"pink\" else 0\n    \n    return f\"{min(max_blue, 10):.10f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def trade(offer, want, rate):\n        return offer * rate\n\n    def get_wanted_lemonade(lemonade_types):\n        for lemonade_type in lemonade_types:\n            if lemonade_type[1] == \"blue\":\n                return lemonade_type\n        return None\n\n    def get_max_blue_lemonade(lemonade_types):\n        max_blue_lemonade = 0\n        for lemonade_type in lemonade_types:\n            if lemonade_type[1] == \"blue\":\n                max_blue_lemonade = max(max_blue_lemonade, lemonade_type[2])\n        return max_blue_lemonade\n\n    N, *lemonade_types = stdin.split('\\n')\n    N = int(N)\n    lemonade_types = [tuple(lemonade_type.split()) for lemonade_type in lemonade_types]\n\n    wanted_lemonade = get_wanted_lemonade(lemonade_types)\n    max_blue_lemonade = get_max_blue_lemonade(lemonade_types)\n\n    if wanted_lemonade is None:\n        return \"0.000000000000000\"\n\n    blue_lemonade = 0\n    for offer, want, rate in lemonade_types:\n        if offer == \"blue\" and want == wanted_lemonade[1]:\n            blue_lemonade += trade(wanted_lemonade[2], offer, float(rate))\n\n    return \"{:.6f}\".format(min(max_blue_lemonade, blue_lemonade))\n\ninput_data = \"\"\"3\nblue pink 1.0\nred pink 1.5\nblue red 1.0\"\"\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lemonade_exchange(offered_lemonade: str, wanted_lemonade: str, exchange_rate: float) -> float:\n        if offered_lemonade == wanted_lemonade:\n            return 0.0\n        if offered_lemonade == \"pink\" and wanted_lemonade == \"blue\":\n            return exchange_rate\n        if offered_lemonade == \"red\" and wanted_lemonade == \"blue\":\n            return exchange_rate / exchange_rate\n        if offered_lemonade == \"orange\" and wanted_lemonade == \"blue\":\n            return exchange_rate / 2\n        if offered_lemonade == \"yellow\" and wanted_lemonade == \"blue\":\n            return exchange_rate / 2\n        if offered_lemonade == \"green\" and wanted_lemonade == \"blue\":\n            return exchange_rate / 4\n\n    N, *lines = stdin.splitlines()\n    N = int(N)\n\n    max_blue_lemonade = 0.0\n    for line in lines:\n        offered_lemonade, wanted_lemonade, exchange_rate = line.split()\n        exchange_rate = float(exchange_rate)\n\n        lemonade_exchange_value = lemonade_exchange(offered_lemonade, wanted_lemonade, exchange_rate)\n        if lemonade_exchange_value > max_blue_lemonade:\n            max_blue_lemonade = lemonade_exchange_value\n\n    max_blue_lemonade = min(max_blue_lemonade, 10.0)\n    return f\"{max_blue_lemonade:.10f}\"\n\ndef"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N = int(stdin)\n    offers = [tuple(stdin.strip().split()) for _ in range(N)]\n\n    # Calculate maximum amount of blue lemonade\n    max_blue = 0\n    for offer in offers:\n        if offer[0] == 'blue':\n            max_blue += float(offer[2])\n    max_blue = min(max_blue, 10)  # Limit to 10 litres\n\n    return f\"{max_blue:.{6}f}\""
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def max_trade(offer, want, rate):\n        return min(offer // want, 10 // want) * want * rate\n\n    def blue_lemonade(lemonade):\n        return lemonade == 'blue'\n\n    def lemonade_trade(offer, want, rate):\n        return max_trade(offer, want, rate) if blue_lemonade(want) else 0\n\n    n, ans = int(stdin[0]), 0\n    for i in range(1, n + 1):\n        offer, want, rate = map(float, stdin[i].split())\n        ans += lemonade_trade(offer, want, rate)\n\n    return '{:.6f}'.format(min(ans, 10))\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, W, O, R = \"\", \"\", \"\", \"\"\n    max_quantity = 0\n\n    for i in range(int(input())):\n        W, O, R = input().split()\n        R = float(R)\n        max_quantity += R * int(stdin[i].split()[2])\n\n    if max_quantity > 10:\n        max_quantity = 10\n\n    return f\"{max_quantity:.6f}\"\n"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_exchange(offer: str, wanted: str, rate: float) -> float:\n        return 1 / rate if offer == wanted else 0\n\n    def trade(offer: str, wanted: str, rate: float, balance: float) -> float:\n        return balance * calculate_exchange(offer, wanted, rate)\n\n    def best_trade(balance: float, offers: list) -> float:\n        max_balance = balance\n        for offer, wanted, rate in offers:\n            if offer == 'blue':\n                max_balance = max(max_balance, trade(offer, wanted, rate, max_balance))\n        return max_balance\n\n    _, N = stdin.split('\\n', 1)\n    N = int(N)\n    offers = [line.split() for line in stdin.split('\\n')[1:N + 1]]\n    max_balance = best_trade(1, offers)\n    return f'{min(max_balance, 10):.10f}'"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def brands_of_ingredient(ingredient: int, dishes: list) -> set:\n        brands = set()\n        for dish in dishes:\n            if ingredient in dish:\n                brands.add(dish[ingredient])\n        return brands\n\n    def dish_combinations(dishes: list) -> set:\n        combinations = set()\n        for i, dish1 in enumerate(dishes):\n            for j, dish2 in enumerate(dishes[i+1:], i+1):\n                combinations.add(tuple(sorted((i+1, j+1))))\n        return combinations\n\n    def incompatible_dishes(dishes: list, pairs: list) -> set:\n        incompatibles = set()\n        for pair in pairs:\n            dish1, dish2 = pair\n            if dish1 in dishes[1:s+1] and dish2 in dishes[1:s+1] or \\\n               dish1 in dishes[s+1:s+m+1] and dish2 in dishes[s+1:s+m+1] or \\\n               dish1 in dishes[s+m+1:s+m+d] and dish2 in dishes[s+m+1:s+m+d]:\n                incompatibles.add(tuple(sorted((dish1, dish2))))\n        return incompatibles\n\n    stdin_lines = stdin.split('\\n')\n    r, s, m, d, n = map(int, stdin_lines[0].split())\n    b = list(map(int, stdin_lines[1].split()))\n    dishes = [list(map(int, stding_lines[i+1].split())) for i in range(s+m+d)]\n    pairs = [(int(pair.split()[0]), int(pair.split()[1])) for pair in stdin_lines[s+m+d+1:s+m+d+n+1]]\n\n    if n > 0:\n        for pair in pairs:\n            dish1, dish2 = pair\n            if dish1 in dishes[1:s+1] and dish2 in dishes[1:s+1] or \\\n               dish1 in dishes[s+1:s+m+1] and dish2 in dishes[s+1:s+m+1] or \\\n               dish1 in dishes[s+m+1:s+m+d] and dish2 in dishes[s+m+1:s+m+d]:\n                return \"too many\"\n\n    num_combinations = 0\n    for i in range(s+m+d):\n        for j in range(i+1, s+m+d+1):\n            if (i+1, j+1) not in incompatible_dishes(dishes, pairs):\n                num_combinations += 1\n\n    return num_combinations"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_data[0].split())\n    brands = list(map(int, input_data[1].split()))\n\n    ingredients = {}\n    for i in range(r):\n        ingredients[i + 1] = brands[i]\n\n    def get_dish_brands(dish_id):\n        dish = list(map(int, input_data[dish_id + s + m].split()[1:]))\n        brands = set()\n        for ingredient_id in dish:\n            brands.add(ingredients[ingredient_id])\n        return brands\n\n    incompatible_dishes = []\n    for i in range(n):\n        incompatible_dishes.append(list(map(int, input_data[i + r + s + m].split())))\n\n    def count_combinations(dish_1, dish_2):\n        if dish_1 == dish_2:\n            return 0\n        dish_1_brands = get_dish_brands(dish_1)\n        dish_2_brands = get_dish_brands(dish_2)\n        common_brands = dish_1_brands.intersection(dish_2_brands)\n        if not common_brands:\n            return 1\n        return (1 + len(dish_1_brands) + len(dish_2_brands) - 2 * len(common_brands)) // 2\n\n    combinations = 1\n    for i in range(s + m + d - 1):\n        for j in range(i + 1, s + m + d):\n            if (s + m + d - i - j) % 2 == 1:\n                for incompatible_dish_pair in incompatible_dishes:\n                    if (incompatible_dish_pair[0] == i + 1 and incompatible_dish_pair[1] == j + 1) or (incompatible_dish_pair[0] == j + 1 and incompatible_dish_pair[1] == i + 1):\n                        combinations *= count_combinations(i + 1, j + 1)\n                        break\n            else:\n                combinations *= count_combinations(i + 1, j + 1)\n            if combinations > 10**18:\n                return \"too many\"\n\n    return combinations"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    dishes = [line.split() for line in input_list[2:]]\n    incompatible_dishes = [tuple(map(int, line.split())) for line in input_list[2+s+m+d:]]\n\n    # Calculate the number of different dinner experiences\n    num_experiences = 1\n    for brands_list in dishes:\n        num_experiences *= len(set(brands_list))\n\n    # Calculate the number of possible combinations of dishes\n    num_dishes = s + m + d\n    num_combinations = 1\n    for i in range(1, num_dishes+1):\n        num_combinations *= num_dishes ** i\n\n    # Calculate the number of valid dinner combinations\n    valid_combinations = 1\n    for i in range(1, n+1):\n        valid_combinations *= (num_dishes - 2) ** i\n\n    # Calculate the number of different dishes\n    num_dishes_set = set()\n    for dish in dishes:\n        num_dishes_set.add(len(set(dish)))\n    num_dishes_set.discard(0)\n\n    # Calculate the number of different dish combinations\n    num_dish_combinations = 1\n    for num in num_dishes_set:\n        num_dish_combinations *= num\n\n    # Calculate the result\n    result = (num_combinations // valid_combinations) * num_dish_combinations * (10**18)\n\n    if result > 10**18:\n        return \"too many\"\n    else:\n        return result"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_dinner_experiences(stdin: str) -> str:\n        r, s, m, d, n = map(int, stdin.readline().split())\n        brands = list(map(int, stdin.readline().split()))\n        dishes = []\n        for _ in range(s+m+d):\n            dishes.append(list(map(int, stdin.readline().split())))\n        incompatible_dishes = []\n        for _ in range(n):\n            incompatible_dishes.append(list(map(int, stdin.readline().split())))\n        \n        total_experiences = 1\n        for i in range(r):\n            total_experiences *= brands[i]\n        \n        for i in range(s+m+d):\n            total_experiences //= len(set(dishes[i]))\n        \n        for i in range(n):\n            for j in range(s+m+d):\n                if incompatible_dishes[i][0] == j+1 or incompatible_dishes[i][1] == j+1:\n                    total_experiences //= 2\n        \n        return total_experiences\n\n    return \"too many\" if count_dinner_experiences(stdin) > 10**18 else count_dinner_experiences(stdin)"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, s, m, d, n = map(int, stdin.split()[:5])\n    brands = list(map(int, stdin.split()[5:r+5]))\n    pairs = [tuple(map(int, stdin.split()[r+5+j*2:r+6+j*2])) for j in range(n)]\n    max_ingredient = 0\n    for j in range(s+m+d):\n        max_ingredient = max(max_ingredient, max(map(int, stdin.split()[r+6+j*2+1:])))\n    max_dinner_experiences = 0\n    for i in range(1, 1+max_ingredient):\n        for j in range(brands[i-1]):\n            for k in range(1, 1+max_ingredient):\n                for l in range(brands[k-1]):\n                    if (i, k) not in pairs and (k, i) not in pairs:\n                        max_dinner_experiences += 1\n    if max_dinner_experiences <= 10**18:\n        return str(max_dinner_experiences)\n    else:\n        return \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_list = stdin.splitlines()\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    dishes = [input_list[i].split() for i in range(2, len(input_list))]\n    incompatibles = [[int(dishes[i][0]), int(dishes[j][0])] for i in range(len(dishes)) for j in range(i+1, len(dishes)) if int(dishes[i][1]) != int(dishes[j][1]) and int(dishes[i][2]) != int(dishes[j][2])]\n\n    # Calculate number of combinations\n    num_combinations = 1\n    for i in range(1, r+1):\n        num_combinations *= brands[i-1]\n\n    # Check if number of combinations is too large\n    if num_combinations > 10**18:\n        return \"too many\"\n\n    # Calculate number of possible dinners\n    num_dinners = num_combinations ** (s+m+d)\n\n    # Calculate number of dinners that are not possible\n    num_incompatible = 0\n    for incompatible_dishes in incompatibles:\n        num_incompatible += num_dinners * (s+m+d - sum(incompatible_dishes)) // (max(incompatible_dishes) - min(incompatible_dishes) + 1)\n\n    # Calculate number of possible dinners after removing incompatible dinners\n    num_possible_dinners = num_dinners - num_incompatible\n\n    return num_possible_dinners"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_data[0].split())\n    brands = list(map(int, input_data[1].split()))\n    dishes = []\n    for i in range(2, len(input_data)):\n        num_ingredients, *ingredients = map(int, input_data[i].split())\n        dishes.append(ingredients)\n    incompatible_dishes = []\n    for i in range(len(input_data) - n, len(input_data)):\n        incompatible_dishes.append(list(map(int, input_data[i].split())))\n\n    # Count the number of unique combinations of brands\n    brand_combinations = 1\n    for i in range(len(brands)):\n        if brands[i] > 1:\n            brand_combinations *= brands[i]\n\n    # Count the number of possible dishes (combinations of ingredients with different brands)\n    dish_combinations = 1\n    for dish in dishes:\n        dish_combinations *= brand_combinations ** len(set(dish))\n\n    # Count the number of possible incompatible dishes\n    incompatible_combinations = 1\n    for incompatible_dish in incompatible_dishes:\n        incompatible_combinations *= dish_combinations\n        for i in range(len(dishes)):\n            if i + 1 in incompatible_dish:\n                incompatible_combinations *= factorial(dish_combinations) // (factorial(len(dishes) - 1) * factorial(dish_combinations // len(dishes) * len(dishes) - 1))\n                break\n\n    if incompatible_combinations <= 10**18:\n        return str(dish_combinations // incompatible_combinations)\n    else:\n        return \"too many\"\n\ndef"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    input_values[0] = list(map(int, input_values[0].split()))\n    brands = list(map(int, input_values[1].split()))\n    dishes = []\n    for i in range(2, len(input_values)):\n        input_values[i] = list(map(int, input_values[i].split()))\n        if input_values[i][0] == 1:\n            dishes.append((input_values[i][1:], 'starter'))\n        elif input_values[i][0] == len(dishes)+1:\n            dishes.append((input_values[i][1:], 'main'))\n        else:\n            dishes.append((input_values[i][1:], 'dessert'))\n    incompatible_dishes = []\n    for i in range(2, len(input_values)):\n        if i not in incompatible_dishes:\n            incompatible_dishes.append(i)\n    result = 0\n    for dish_list, dish_type in dishes:\n        if dish_type == 'starter':\n            start_index = 0\n        elif dish_type == 'main':\n            start_index = len(dishes)\n        else:\n            start_index = 2*len(dishes)\n        for i in range(len(dish_list)):\n            if dish_list[i] != 0:\n                result += brands[dish_list[i]-1]\n        result *= len(dishes) - start_index\n    if result > 10**18:\n        return \"too many\"\n    else:\n        return result"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    r, s, m, d, n = input_data[:5]\n    brands = input_data[5:5 + r]\n    dishes = input_data[5 + r:]\n\n    def count_combinations(dishes_list: list) -> int:\n        combinations_count = 1\n        for ingredient_count in dishes_list:\n            combinations_count *= brands[ingredient_count - 1]\n        return combinations_count\n\n    def get_dish_ingredients(dish_index: int) -> list:\n        dish_start = s + m + d\n        dish_end = s + m + d + n\n        dish_index -= 1\n        if dish_index < s:\n            dish_start = 0\n            dish_end = s\n        elif s <= dish_index < s + m:\n            dish_start = s\n            dish_end = s + m\n        else:\n            dish_start = s + m\n            dish_end = s + m + d\n        return dishes[dish_start + dish_index - dish_index // dish_end * dish_end: dish_start + dish_index - (dish_index // dish_end - 1) * dish_end + 1]\n\n    starter_combinations = count_combinations([len(get_dish_ingredients(i)) for i in range(1, s + 1)])\n    main_combinations = count_combinations([len(get_dish_ingredients(i)) for i in range(s + 1, s + m + 1)])\n    dessert_combinations = count_combinations([len(get_dish_ingredients(i)) for i in range(s + m + 1, s + m + d + 1)])\n\n    if starter_combinations * main_combinations * dessert_combinations <= 10**18:\n        return str(starter_combinations * main_combinations * dessert_combinations)\n    else:\n        return \"too many\""
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    dishes = input_list[2:]\n    \n    # Calculate the total number of possible combinations\n    total_combinations = 1\n    for br in brands:\n        total_combinations *= br\n    \n    # Check if the number of combinations is too large\n    if total_combinations > 10**18:\n        return \"too many\"\n    \n    # Calculate the number of possible combinations for each dish\n    dish_combinations = []\n    for dish in dishes:\n        ingredients = list(map(int, dish.split()))\n        dish_combinations.append(total_combinations // brands[ingredients[0]-1])\n        \n    # Calculate the number of combinations for each incompatible dish pair\n    incompatible_combinations = []\n    for pair in range(n):\n        dishes = list(map(int, dishes[pair].split()))\n        incompatible_combinations.append(dish_combinations[dishes[0]-1] * dish_combinations[dishes[1]-1])\n    \n    # Calculate the number of different dinner experiences\n    result = total_combinations\n    for combo in incompatible_combinations:\n        result //= combo\n    \n    return result"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    h, w, n = map(int, input_list[0].split())\n    pattern = [list(input_list[i+1]) for i in range(h)]\n    commands = [input_list[i+1+h].split() for i in range(n)]\n\n    # create a function to check if a given point is marked or blank\n    def is_marked(x, y):\n        if 0 <= x < h and 0 <= y < w:\n            return pattern[x][y] == '#'\n        return False\n\n    # initialize the variables for the minimum and maximum time\n    min_time = float('inf')\n    max_time = 0\n\n    # loop through all the commands\n    for cmd in commands:\n        direction, distance = cmd\n        distance = int(distance)\n\n        # calculate the new coordinates based on the direction\n        if direction == 'up':\n            new_x = h - distance - 1\n            new_y = -1\n        elif direction == 'down':\n            new_x = h + distance\n            new_y = w\n        elif direction == 'left':\n            new_x = -1\n            new_y = distance - 1\n        else:\n            new_x = h\n            new_y = w + distance\n\n        # if the new coordinates are within the bounds of the board\n        if 0 <= new_x < h and 0 <= new_y < w:\n            # check if the new coordinates are marked\n            if is_marked(new_x, new_y):\n                # update the minimum and maximum time if necessary\n                min_time = min(min_time, new_x + new_y)\n                max_time = max(max_time, new_x + new_y)\n\n    # if the minimum and maximum time are both -1, it's not possible to end up with the target drawing\n    if min_time == float('inf'):\n        return '-1 -1'\n\n    # return the minimum and maximum time\n    return f'{min_time} {max_time}'"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, input().split())\n    board = [list(input()) for _ in range(h)]\n    commands = [input().split() for _ in range(n)]\n\n    def is_marked(x, y):\n        if 0 <= x < h and 0 <= y < w:\n            return board[x][y] == '#'\n        return False\n\n    def move(x, y, direction, distance):\n        if direction == 'up':\n            for _ in range(distance):\n                y -= 1\n                if not is_marked(x, y):\n                    return -1, -1\n            return x, y\n        elif direction == 'down':\n            for _ in range(distance):\n                y += 1\n                if not is_marked(x, y):\n                    return -1, -1\n            return x, y\n        elif direction == 'left':\n            for _ in range(distance):\n                x -= 1\n                if not is_marked(x, y):\n                    return -1, -1\n            return x, y\n        elif direction == 'right':\n            for _ in range(distance):\n                x += 1\n                if not is_marked(x, y):\n                    return -1, -1\n            return x, y\n        else:\n            return -1, -1\n\n    marker_x, marker_y = 0, 0\n    for i in range(n):\n        x, y = marker_x, marker_y\n        x, y = move(x, y, commands[i][0], int(commands[i][1]))\n        if x == -1 or y == -1:\n            return -1, -1\n        marker_x, marker_y = x, y\n\n    min_dry_out = -1\n    max_dry_out = -1\n\n    for i in range(n):\n        x, y = marker_x, marker_y\n        if is_marked(x, y):\n            min_dry_out = max(min_dry_out, i)\n            max_dry_out = max(max_dry_out, i)\n        x, y = move(x, y, commands[i][0], int(commands[i][1]))\n        if x == -1 or y == -1:\n            return -1, -1\n        marker_x, marker_y = x, y\n\n    return min_dry_out, max_dry_out "
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def move(x, y, direction, distance):\n        if direction == 'up':\n            return x, y - distance\n        elif direction == 'down':\n            return x, y + distance\n        elif direction == 'left':\n            return x - distance, y\n        elif direction == 'right':\n            return x + distance, y\n        else:\n            raise ValueError('Invalid direction')\n\n    def get_marker_state(x, y, pattern):\n        if x < 0 or y < 0 or x >= w or y >= h:\n            return False\n        return pattern[y][x] == '#'\n\n    h, w, n = map(int, stdin.split()[:3])\n    pattern = stdin.split('\\n')[:h]\n    commands = stdin.split('\\n')[h:]\n    x = y = 0\n\n    for command in commands:\n        direction, distance = command.split()\n        x, y = move(x, y, direction, int(distance))\n\n    if get_marker_state(x, y, pattern):\n        return 0, h * w - 1\n    else:\n        return -1, -1\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    h, w, n = map(int, input_list[0].split())\n    board = input_list[1:h+1]\n    commands = input_list[h+1:]\n\n    target = \"\".join([\".\" for _ in range(w*h)])\n    for command in commands:\n        direction, distance = command.split()\n        distance = int(distance)\n        if direction == \"up\":\n            target = target.replace(w*h-w, \" \"*(w*distance)).replace(\" \", \"#\")\n        elif direction == \"down\":\n            target = target.replace(w, \" \"*(w*distance)).replace(\" \", \"#\")\n        elif direction == \"left\":\n            target = target.replace(w*(h-distance), \" \"*(w*distance)).replace(\" \", \"#\")\n        elif direction == \"right\":\n            target = target.replace(w*(distance-1), \" \"*(w*distance)).replace(\" \", \"#\")\n\n    def count_dry_cells(board, target):\n        dry_cells = 0\n        for i in range(h):\n            for j in range(w):\n                if board[i][j] != target[i*w+j]:\n                    dry_cells += 1\n        return dry_cells\n\n    def dry_cells_at_time(board, target, time):\n        dry_cells = count_dry_cells(board, target)\n        if time % 2 == 0:\n            dry_cells -= time//2\n        else:\n            dry_cells -= (time+1)//2\n        return dry_cells\n\n    min_dry_time = min(dry_cells_at_time(board, target, i) for i in range(h*w))\n    max_dry_time = max(dry_cells_at_time(board, target, i) for i in range(h*w))\n\n    if min_dry_time == max_dry_time:\n        return f\"{min_dry_time} {min_dry_time}\"\n    elif max_dry_time >= h*w:\n        return f\"{min_dry_time} {min_dry_time}\"\n    else:\n        return f\"-1 -1\""
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    board = [list(stdin.split()[i]) for i in range(3, 3 + h)]\n    commands = [stdin.split()[i] for i in range(3 + h, 3 + h + n)]\n\n    target = ['.'] * (h * w)\n    target_size = 0\n    for row in board:\n        target_size += row.count('#')\n\n    directions = {\n        'up': (-1, 0),\n        'down': (1, 0),\n        'left': (0, -1),\n        'right': (0, 1)\n    }\n\n    def can_move(dx, dy):\n        return 0 <= x + dx < h and 0 <= y + dy < w and board[x + dx][y + dy] == '.'\n\n    def move(dx, dy):\n        nonlocal x, y, target, target_size\n        new_x, new_y = x + dx, y + dy\n        if new_x >= 0 and new_x < h and new_y >= 0 and new_y < w and board[new_x][new_y] == '.':\n            target[new_x * w + new_y] = '#'\n            target_size += 1\n            x, y = new_x, new_y\n\n    x, y = 0, 0\n    marker_dried_out = False\n    for command in commands:\n        direction, distance = command.split()\n        dx, dy = directions[direction]\n        if can_move(dx, dy):\n            move(dx, dy)\n        if not marker_dried_out and target_size == 0:\n            marker_dried_out = True\n\n    if marker_dried_out:\n        return \"20 20\"\n    else:\n        return \"-1 -1\""
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    pattern = stdin.split(\"\\n\")[3:6]\n    commands = stdin.split(\"\\n\")[6:]\n    target = set()\n    marked = set()\n\n    for i in range(h):\n        for j in range(w):\n            if pattern[i][j] == '#':\n                target.add((i, j))\n\n    current_pos = (0, 0)\n    marked.add(current_pos)\n    for command in commands:\n        direction, distance = command.split()\n        distance = int(distance)\n        dx, dy = {\n            'up': (0, -1),\n            'down': (0, 1),\n            'left': (-1, 0),\n            'right': (1, 0),\n        }[direction]\n        for _ in range(distance):\n            current_pos = (current_pos[0] + dx, current_pos[1] + dy)\n            if current_pos not in marked:\n                break\n        else:\n            continue\n        break\n    else:\n        return \"-1 -1\"\n\n    drying_time = []\n    for i in range(h):\n        for j in range(w):\n            if (i, j) not in target:\n                if (i, j) in marked:\n                    drying_time.append(current_pos[1] + j)\n                else:\n                    drying_time.append(current_pos[1] + j + 1)\n            else:\n                drying_time.append(current_pos[1] + j)\n\n    if not drying_time:\n        return \"-1 -1\"\n\n    return min(drying_time), max(drying_time)\n\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, input().split())\n    board = [list(input()) for _ in range(h)]\n    commands = [input().split() for _ in range(n)]\n\n    def can_draw(x, y, direction, distance, board):\n        dx, dy = {'up': (-1, 0), 'down': (1, 0), 'left': (0, -1), 'right': (0, 1)}[direction]\n        for _ in range(distance):\n            x, y = x + dx, y + dy\n            if x < 0 or y < 0 or x >= h or y >= w or board[x][y] == '#':\n                return False\n        return True\n\n    min_time = float('inf')\n    max_time = -1\n\n    for timestep in range(1, h * w + 1):\n        if can_draw(h - 1, 0, commands[timestep - 1][0], commands[timestep - 1][1], board):\n            min_time = timestep\n            break\n\n    for timestep in range(1, h * w + 1):\n        if can_draw(h - 1, w - 1, commands[timestep - 1][0], commands[timestep - 1][1], board):\n            max_time = timestep\n\n    if min_time == float('inf') or max_time == -1:\n        return '-1 -1'\n    else:\n        return f'{min_time} {max_time}'\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    board = stdin.split(\"\\n\")[1:h+1]\n    commands = [c.split() for c in stdin.split(\"\\n\")[h+1:h+1+n]]\n    \n    def move(x, y, direction, distance):\n        if direction == 'up':\n            return x, y - distance\n        elif direction == 'down':\n            return x, y + distance\n        elif direction == 'left':\n            return x - distance, y\n        elif direction == 'right':\n            return x + distance, y\n        else:\n            return x, y\n    \n    x, y = 0, 0\n    for direction, distance in commands:\n        x, y = move(x, y, direction, distance)\n    \n    def is_marked(board, x, y):\n        if 0 <= x < h and 0 <= y < w:\n            return board[x][y] == '#'\n        else:\n            return False\n    \n    marked_cells = set()\n    for x in range(h):\n        for y in range(w):\n            if is_marked(board, x, y):\n                marked_cells.add((x, y))\n    \n    earliest = -1\n    latest = -1\n    \n    def check_dry(x, y):\n        nonlocal earliest, latest\n        if (x, y) in marked_cells:\n            latest = max(latest, len(commands) - 1)\n        else:\n            if earliest == -1:\n                earliest = len(commands) - 1\n            elif earliest > len(commands) - 1:\n                earliest = len(commands) - 1\n    \n    for x in range(h):\n        for y in range(w):\n            check_dry(x, y)\n            check_dry(x + 1, y)\n            check_dry(x, y + 1)\n            check_dry(x - 1, y)\n            check_dry(x, y - 1)\n    \n    if earliest == -1:\n        return \"-1 -1\"\n    else:\n        return f\"{earliest} {latest}\"\n"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.readline().split())\n    board = [list(input()) for _ in range(h)]\n    commands = [input().split() for _ in range(n)]\n    \n    marker_pos = (0, 0)\n    min_time = 0\n    max_time = 0\n    for command in commands:\n        direction, distance = command\n        distance = int(distance)\n        if direction == \"up\":\n            row, col = marker_pos\n            row -= distance\n            marker_pos = (max(0, row), col)\n        elif direction == \"down\":\n            row, col = marker_pos\n            row += distance\n            marker_pos = (min(h-1, row), col)\n        elif direction == \"left\":\n            row, col = marker_pos\n            col -= distance\n            marker_pos = (row, max(0, col))\n        elif direction == \"right\":\n            row, col = marker_pos\n            col += distance\n            marker_pos = (row, min(w-1, col))\n        else:\n            raise ValueError(f\"Invalid direction: {direction}\")\n        \n        if marker_pos[0] == h-1 or marker_pos[1] == w-1:\n            max_time = max(max_time, marker_pos[0]*w + marker_pos[1])\n        \n        if marker_pos[0] == 0 or marker_pos[1] == 0:\n            min_time = max(min_time, marker_pos[0]*w + marker_pos[1])\n        \n    if max_time == 0:\n        return \"-1 -1\"\n    \n    return f\"{min_time} {max_time}\"\n\ndef"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_direction(direction: str) -> tuple:\n        if direction == 'up':\n            return 0, -1\n        elif direction == 'down':\n            return 0, 1\n        elif direction == 'left':\n            return -1, 0\n        elif direction == 'right':\n            return 1, 0\n        else:\n            raise ValueError(\"Invalid direction\")\n\n    lines = stdin.split('\\n')\n    h, w, n = map(int, lines[0].split())\n    board = [[0] * w for _ in range(h)]\n    commands = lines[h + 1:h + n + 1]\n\n    turtle_x, turtle_y = w - 1, h - 1\n    max_time = 0\n    for command in commands:\n        direction, distance = command.split()\n        dx, dy = get_direction(direction)\n        turtle_x, turtle_y = turtle_x + dx * distance, turtle_y + dy * distance\n        max_time = max(max_time, turtle_x * w + turtle_y)\n\n    if board[turtle_y][turtle_x] == 1:\n        return 0, max_time\n    else:\n        return -1, -1\n"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, input().split())\n    companies = [input().split() for _ in range(k)]\n\n    # DP table to store the minimum number of bolts in each pack size\n    dp = [float('inf')] * (B + 1)\n    dp[0] = 0\n\n    for company in companies:\n        l_i, *n_i = map(int, company)\n\n        # Iterate through all possible sizes of the previous company's packs\n        for j in range(len(n_i)):\n            n_prev = n_i[j]\n\n            # Calculate the real amount of bolts in the new pack\n            real_amount = sum(dp[i] for i in range(n_prev, B + 1) if i % n_prev == 0)\n\n            # Update the DP table\n            if real_amount < dp[n_prev]:\n                dp[n_prev] = real_amount\n\n    # Find the smallest pack size with at least B bolts\n    min_size = min(i for i in range(len(dp)) if dp[i] >= B)\n\n    if min_size == float('inf'):\n        return \"impossible\"\n    else:\n        return min_size\n\ndef"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    b = int(input_list[0])\n    k = int(input_list[1])\n    companies = [line.split()[1:] for line in input_list[2:2+k]]\n\n    def get_real_amount(comp, pack_size):\n        if len(comp) == 1:\n            return comp[0]\n        else:\n            return comp[0] + sum(comp[i+1] for i in range(len(comp)-1) if comp[i+1] <= pack_size)\n\n    def get_min_amount(comp, target):\n        min_amount = float('inf')\n        for i in range(len(comp)):\n            for j in range(i+1, len(comp)+1):\n                if sum(comp[i:j]) >= target and sum(comp[i:j]) - comp[i] <= target:\n                    min_amount = min(min_amount, sum(comp[i:j]))\n        return min_amount\n\n    for i in range(k):\n        companies[i] = [(int(companies[i][j]), int(companies[i][j+1])) for j in range(0, len(companies[i]), 2)]\n\n    for comp in companies:\n        comp.sort(key=lambda x: x[1])\n\n    for size in range(1, b+1):\n        min_amount = float('inf')\n        for comp in companies:\n            real_amount = get_real_amount(comp, size)\n            min_amount = min(min_amount, real_amount)\n        if min_amount >= b:\n            return str(size)\n\n    return \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split()[:2])\n    companies = [list(map(int, stdin.split()[2:])) for _ in range(k)]\n    \n    def min_bolts(packs, target):\n        \"\"\"Returns the minimum amount of bolts in a pack that can contain at least target bolts.\"\"\"\n        return sum(sorted(packs, reverse=True)[0:bisect_left(packs, target)])\n    \n    def min_pack(companies, target):\n        \"\"\"Returns the smallest advertised size of a pack that can contain at least target bolts, or None if impossible.\"\"\"\n        for company in companies:\n            for i in range(1, len(company), 2):\n                if min_bolts(company[i-1:i+1], target) >= target:\n                    return company[i-1]\n        return None\n    \n    for i in range(B, 0, -1):\n        if min_pack(companies, i) is not None:\n            return min_pack(companies, i)\n    return \"impossible\"\n"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.splitlines()[0].split())\n    companies = []\n    for i in range(1, k+1):\n        l_i, *n_i = map(int, stdin.splitlines()[i].split())\n        companies.append((l_i, n_i))\n\n    # Initialize variables\n    manufacturer_sizes = []\n    intermediate_sizes = []\n    total_bolts = 0\n\n    # Sort companies by the amount of bolts they have in each package\n    for l_i, n_i in companies:\n        for n in n_i:\n            manufacturer_sizes.append((n, n))\n            total_bolts += n\n\n    # Find the smallest size of a package that can contain at least B bolts\n    while True:\n        # Sort sizes by the amount of bolts they contain\n        manufacturer_sizes.sort()\n        manufacturer_sizes.reverse()\n\n        # Check if the smallest manufacturer's size contains at least B bolts\n        if manufacturer_sizes[0][0] >= B:\n            return manufacturer_sizes[0][1]\n\n        # Find the smallest intermediate size that can contain at least B bolts\n        intermediate_sizes = [(i, n) for i, (_, n) in enumerate(manufacturer_sizes) if n <= B and B - n <= total_bolts - n]\n        if not intermediate_sizes:\n            return \"impossible\"\n        intermediate_sizes.sort()\n        intermediate_sizes.reverse()\n\n        # Update the total bolts\n        total_bolts -= manufacturer_sizes[0][0] - intermediate_sizes[0][1]\n        manufacturer_sizes.pop(0)"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    b = int(input_data[0])\n    k = int(input_data[1])\n    companies = [input_data[i].split() for i in range(2, 2+k)]\n\n    # Find the smallest package size that contains at least b bolts\n    for i in range(1, k+1):\n        total_bolts = 0\n        for j in range(len(companies[i-1])):\n            for size in range(int(companies[i-1][j+1]), int(companies[i-1][j+2])+1):\n                total_bolts += size\n        if total_bolts >= b:\n            return str(companies[i-1][1])\n    return \"impossible\""
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    B = int(input_data[0])\n    k = int(input_data[1])\n    companies = [input_data[i].split() for i in range(2, 2+k)]\n    \n    def min_pack_size(companies, B):\n        min_pack = float('inf')\n        for c in companies:\n            l = int(c[0])\n            sizes = [int(x) for x in c[1:]]\n            for i in range(1, l):\n                if sizes[i] >= B:\n                    min_pack = min(min_pack, sizes[i])\n                    break\n        return min_pack if min_pack != float('inf') else 'impossible'\n    \n    return min_pack_size(companies, B)\n\ninput_data = '''310\n3\n2 40 65\n2 100 150\n2 300 320'''\n\nprint(solution(input_data)) # Output: 300\n\ninput_data = '''371\n3\n2 40 65\n2 100 150\n2 300 320'''\n\nprint(solution(input_data)) # Output: impossible\n\ninput_data = '''90\n2\n2 20 35\n2 88 200'''\n\nprint(solution(input_data)) # Output: 88 "
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, k = map(int, stdin.splitlines()[0].split())\n    companies = [[] for _ in range(k)]\n    for i in range(k):\n        line = stdi.splitlines()[i+1].split()\n        for j in range(int(line[0])):\n            companies[i].append(int(line[j+1]))\n\n    min_pack_size = float('inf')\n    for i in range(k):\n        for j in range(len(companies[i])):\n            for s in range(companies[i][j] + 1):\n                if s + sum(companies[i][:j]) >= b:\n                    if s < min_pack_size:\n                        min_pack_size = s\n                    break\n            else:\n                continue\n            break\n\n    if min_pack_size == float('inf'):\n        return 'impossible'\n    else:\n        return min_pack_size"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_real_amount(pack_sizes, advertised_amount):\n        total_bolts = sum(pack_sizes)\n        if total_bolts >= advertised_amount:\n            return advertised_amount\n        else:\n            return total_bolts\n\n    def min_pack_size(companies):\n        min_pack_size = float('inf')\n        for company in companies:\n            for i in range(len(company)):\n                real_amount = calculate_real_amount(company[i], i + 1)\n                if real_amount < min_pack_size:\n                    min_pack_size = real_amount\n        return min_pack_size\n\n    B, k = map(int, stdin.splitlines()[0].split())\n    companies = [[] for _ in range(k)]\n    for i in range(k):\n        l, *n = map(int, stdin.splitlines()[i + 1].split())\n        for j in range(l):\n            companies[i].append(n[j*2:(j+1)*2])\n\n    return \"impossible\" if min_pack_size(companies) > B else min_pack_size(companies)\n"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    B, k = map(int, stdin.split()[:2])\n    companies = [list(map(int, stdin.split()[2:])) for _ in range(k)]\n    min_size = float('inf')\n\n    for i, company in enumerate(companies):\n        l, *ns = company\n        for size in range(1, l + 1):\n            total_bolts = sum(ns[:size])\n            if total_bolts >= B:\n                min_size = min(min_size, size)\n\n    return str(min_size) if min_size != float('inf') else 'impossible'"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b = int(stdin.split('\\n')[0])\n    k = int(stdin.split('\\n')[1])\n    companies = [line.split() for line in stdin.split('\\n')[2:k+2]]\n\n    # Initialize the real amount of each pack\n    real_amount = [[0] * n for l, *n in companies]\n    real_amount[0][0] = b\n\n    for i in range(1, k):\n        for j, (l, *ns) in enumerate(companies[i]):\n            l = int(l)\n            ns = [int(n) for n in ns]\n            for n in ns:\n                if real_amount[i-1][n] >= b:\n                    real_amount[i][n] = b\n                    break\n                else:\n                    real_amount[i][n] = real_amount[i-1][n]\n\n    # Find the minimum size of a pack that contains at least B bolts\n    min_pack = min([min([n for n, a in enumerate(row) if a >= b] or [-1]) for row in real_amount[-1]])\n\n    if min_pack == -1:\n        return \"impossible\"\n    else:\n        return str(min_pack)"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix: list) -> bool:\n        # Check if there are exactly 6 '#'\n        count = 0\n        for row in matrix:\n            count += row.count('#')\n        if count != 6:\n            return False\n\n        # Check if there are no 2x2 '#' squares\n        for i in range(len(matrix) - 1):\n            for j in range(len(matrix[0]) - 1):\n                if matrix[i][j] == '#' and matrix[i][j+1] == '#' and matrix[i+1][j] == '#' and matrix[i+1][j+1] == '#':\n                    return False\n\n        # Check if all '#' can be reached from any other '#' without touching a '.'\n        visited = set()\n        def dfs(row: int, col: int) -> bool:\n            if (row, col) in visited:\n                return True\n            visited.add((row, col))\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < len(matrix) and 0 <= new_col < len(matrix[0]):\n                    if matrix[new_row][new_col] == '#':\n                        if dfs(new_row, new_col):\n                            return True\n                    elif matrix[new_row][new_col] == '.':\n                        continue\n            return False\n\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == '#' and not dfs(i, j):\n                    return False\n        return True\n\n    matrix = []\n    for line in stdin.split('\\n'):\n        row = []\n        for char in line:\n            row.append(char)\n        matrix.append(row)\n\n    if is_valid(matrix):\n        return \"can fold\"\n    else:\n        return \"cannot fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def can_reach(x1: int, y1: int, x2: int, y2: int) -> bool:\n        dx, dy = x2 - x1, y2 - y1\n        return (dx, dy) in ((0, 1), (1, 0), (1, 1))\n\n    def is_valid_fold(matrix: List[List[str]]) -> bool:\n        squares = []\n        for y in range(len(matrix)):\n            for x in range(len(matrix[0])):\n                if matrix[y][x] == '#':\n                    squares.append((x, y))\n        n = len(squares)\n\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if not can_reach(squares[i][0], squares[i][1], squares[j][0], squares[j][1]):\n                    return False\n\n        for x, y in squares:\n            if matrix[y][x] != '#':\n                for dx, dy in ((0, 1), (1, 0), (1, 1)):\n                    if matrix[y + dy][x + dx] == '#':\n                        return False\n\n        return True\n\n    matrix = [list(line.strip()) for line in stdin.splitlines()]\n    return \"can fold\" if is_valid_fold(matrix) else \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arr):\n        # Check that there is exactly one # for each square\n        if sum(row.count('#') for row in arr) != 6:\n            return False\n\n        # Check that there is no 2x2 subsquare consisting of only #\n        for i in range(len(arr) - 1):\n            for j in range(len(arr[0]) - 1):\n                if arr[i][j] == '#' and arr[i][j + 1] == '#' and arr[i + 1][j] == '#' and arr[i + 1][j + 1] == '#':\n                    return False\n        return True\n\n    arr = [[stdin[i * 6 + j] for j in range(6)] for i in range(6)]\n\n    # Check that the initial arrangement is valid\n    if not is_valid(arr):\n        return \"cannot fold\"\n\n    # Check if the folded cube has a total of 6^3 squares\n    folded_cube = [[[False] * 6 for _ in range(6)] for _ in range(6)]\n    for i in range(6):\n        for j in range(6):\n            for k in range(6):\n                if arr[i][j] == '#' and arr[i][j + 1] == '#' and arr[i + 1][j] == '#' and arr[i + 1][j + 1] == '#':\n                    folded_cube[i][j][k] = True\n\n    if sum(sum(sum(row) for row in plane) for plane in folded_cube) != 6 ** 3:\n        return \"cannot fold\"\n\n    return \"can fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_cube(squares: list) -> bool:\n        if len(squares) != 6:\n            return False\n        for square in squares:\n            if len(square) != 6:\n                return False\n            if not all(c == \".\" for c in square) and not all(c == \"#\" for c in square):\n                return False\n        return True\n\n    def has_2x2_subsquare(squares: list) -> bool:\n        for i in range(len(squares)):\n            for j in range(len(squares[0])):\n                if squares[i][j] == \"#\" and squares[i][j + 1] == \"#\" and squares[i + 1][j] == \"#\" and squares[i + 1][j + 1] == \"#\":\n                    return True\n        return False\n\n    def fold_cube(squares: list) -> bool:\n        def fold_horizontal(i: int, j: int, direction: str) -> None:\n            if direction == \"L\":\n                squares[i][j], squares[i][j + 1] = squares[i][j + 1], squares[i][j]\n            elif direction == \"R\":\n                squares[i][j], squares[i][j - 1] = squares[i][j - 1], squares[i][j]\n\n        def fold_vertical(i: int, j: int, direction: str) -> None:\n            if direction == \"U\":\n                squares[i][j], squares[i - 1][j] = squares[i - 1][j], squares[i][j]\n            elif direction == \"D\":\n                squares[i][j], squares[i + 1][j] = squares[i + 1][j], squares[i][j]\n\n        for i in range(len(squares) - 1, -1, -1):\n            for j in range(len(squares[0]) - 1, -1, -1):\n                if squares[i][j] == \"#\":\n                    fold_horizontal(i, j, \"R\")\n                    fold_vertical(i, j, \"U\")\n\n        for i in range(len(squares)):\n            for j in range(len(squares[0]) - 1, -1, -1):\n                if squares[i][j] == \"#\":\n                    fold_horizontal(i, j, \"L\")\n                    fold_vertical(i, j, \"D\")\n\n        return is_valid_cube(squares)\n\n    squares = [list(line) for line in stdin.split(\"\\n\")]\n    if not is_valid_cube(squares) or has_2x2_subsquare(squares):\n        return \"cannot fold\"\n    return \"can fold\" if fold_cube(squares) else \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_lines = stdin.split('\\n')\n    num_rows = len(input_lines)\n    num_cols = len(input_lines[0])\n\n    # Check if the input is valid\n    if num_rows != 6 or num_cols != 6:\n        return \"cannot fold\"\n\n    for line in input_lines:\n        if len(line) != 6:\n            return \"cannot fold\"\n\n    # Check if the input contains a 2x2 square\n    for i in range(num_rows - 1):\n        for j in range(num_cols - 1):\n            if input_lines[i][j] == '#' and input_lines[i][j+1] == '#' and input_lines[i+1][j] == '#' and input_lines[i+1][j+1] == '#':\n                return \"cannot fold\"\n\n    # Check if the input contains a connected component\n    num_squares = 0\n    for line in input_lines:\n        num_squares += line.count('#')\n\n    if num_squares != 6:\n        return \"cannot fold\"\n\n    # Check if the input can be folded into a cube\n    if input_lines[1] == '#####' and input_lines[3] == '#####' and input_lines[4] == '......':\n        return \"can fold\"\n    elif input_lines[0] == '#####' and input_lines[2] == '#####' and input_lines[5] == '......':\n        return \"can fold\"\n    elif input_lines[0] == '#####' and input_lines[4] == '#####' and input_lines[5] == '......':\n        return \"can fold\"\n    elif input_lines[1] == '#####' and input_lines[3] == '#####' and input_lines[5] == '......':\n        return \"can fold\"\n    else:\n        return \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into lines\n    lines = stdin.split('\\n')\n    # Initialize a dictionary to keep track of the neighbors of each unit square\n    neighbors = {}\n    # Iterate through the lines\n    for i, line in enumerate(lines):\n        # Iterate through the characters in the line\n        for j, char in enumerate(line):\n            # If the character is a unit square, add it to the dictionary\n            if char == '#':\n                # Add the unit square to the dictionary\n                neighbors[(i, j)] = set()\n                # Add the neighbors of the unit square to the dictionary\n                if i > 0:\n                    neighbors[(i, j)].add((i-1, j))\n                if i < len(lines) - 1:\n                    neighbors[(i, j)].add((i+1, j))\n                if j > 0:\n                    neighbors[(i, j)].add((i, j-1))\n                if j < len(line) - 1:\n                    neighbors[(i, j)].add((i, j+1))\n    # Check if any of the unit squares are isolated\n    isolated = [square for square in neighbors if len(neighbors[square]) == 0]\n    if len(isolated) > 0:\n        return \"cannot fold\"\n    # Check if there is a path from any isolated unit square to any other isolated unit square\n    for square in neighbors:\n        for neighbor in neighbors[square]:\n            if neighbor in isolated:\n                return \"can fold\"\n    return \"cannot fold\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_grid = stdin.split(\"\\n\")\n    num_rows = len(input_grid)\n    num_cols = len(input_grid[0])\n    \n    def get_neighbors(row, col):\n        return [(row-1, col), (row+1, col), (row, col-1), (row, col+1)]\n    \n    def is_valid_square(row, col):\n        return 0 <= row < num_rows and 0 <= col < num_cols and input_grid[row][col] == \"#\"\n    \n    def dfs(start_row, start_col):\n        visited = set()\n        queue = [(start_row, start_col)]\n        while queue:\n            row, col = queue.pop(0)\n            if (row, col) in visited:\n                continue\n            visited.add((row, col))\n            if is_valid_square(row, col):\n                return True\n            for neighbor_row, neighbor_col in get_neighbors(row, col):\n                if (neighbor_row, neighbor_col) not in visited:\n                    queue.append((neighbor_row, neighbor_col))\n        return False\n\n    for row in range(num_rows):\n        for col in range(num_cols):\n            if input_grid[row][col] == \"#\":\n                if not dfs(row, col):\n                    return \"cannot fold\"\n\n    return \"can fold\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        if len(s) != 6:\n            return False\n        for c in s:\n            if c not in ('.', '#'):\n                return False\n        return True\n\n    def is_connected(s: str) -> bool:\n        for i in range(len(s)):\n            if s[i] == '#':\n                for j in range(6):\n                    if i - 2 >= 0 and s[i - 2][j] == '#':\n                        return True\n                    if i + 2 < len(s) and s[i + 2][j] == '#':\n                        return True\n        return False\n\n    def is_subsquare(s: str) -> bool:\n        for i in range(len(s) - 2):\n            for j in range(len(s[0]) - 2):\n                if s[i][j:j + 3] == '###' and s[i + 1][j:j + 3] == '###' and s[i + 2][j:j + 3] == '###':\n                    return True\n        return False\n\n    lines = stdin.split('\\n')\n    if not all(is_valid(line) for line in lines):\n        return \"cannot fold\"\n\n    if not all(is_connected(line) for line in lines):\n        return \"cannot fold\"\n\n    if any(is_subsquare(line) for line in lines):\n        return \"cannot fold\"\n\n    return \"can fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_input(square: str) -> bool:\n        return len(square) == 6 and square.count(\"#\") == 1 and square.count(\".\") == 5\n\n    def is_connected_component(squares: List[str]) -> bool:\n        def dfs(square: str, visited: Set[str]) -> bool:\n            if square in visited:\n                return False\n            visited.add(square)\n            if square.count(\"#\") == 1:\n                return True\n            for next_square in get_neighbors(square):\n                if dfs(next_square, visited):\n                    return True\n            return False\n\n        def get_neighbors(square: str) -> List[str]:\n            row, col = 0, 0\n            for i in range(6):\n                if square[i] == \"#\":\n                    row, col = i // 3, i % 3\n                    break\n            neighbors = []\n            for i in range(3):\n                for j in range(3):\n                    if (i, j) != (row, col) and is_valid_square(row + i, col + j):\n                        neighbors.append(get_square(row + i, col + j))\n            return neighbors\n\n        def is_valid_square(row: int, col: int) -> bool:\n            return 0 <= row < 2 and 0 <= col < 2\n\n        def get_square(row: int, col: int) -> str:\n            return \"\".join([squares[3 * row + i][3 * col + j] for i in range(3) for j in range(3)])\n\n        return all(dfs(square, set()) for square in squares)\n\n    def can_fold(squares: List[str]) -> bool:\n        cube = [[[False for _ in range(3)] for _ in range(3)] for _ in range(3)]\n        for i in range(3):\n            for j in range(3):\n                for k in range(3):\n                    cube[i][j][k] = all(squares[3 * i + a][3 * j + b] == squares[3 * i + c][3 * j + d] for a, b, c, d in [(0, 0, 0, 0), (0, 1, 0, 1), (1, 0, 1, 0), (1, 1, 1, 1), (0, 2, 0, 2), (2, 0, 2, 0), (1, 2, 1, 2), (2, 1, 2, 1), (2, 2, 2, 2)])\n        return any(cube[0][0][0] and cube[1][1][1] and cube[2][2][2] for cube in itertools.permutations(cube))\n\n    rows = stdin.strip().split(\"\\n\")\n    squares = [rows[i:i + 6] for i in range(0, len(rows), 6)]\n    if not all(is_valid_input(square) for square in squares):\n        return \"cannot fold\"\n    if not is_connected_component(squares):\n        return \"cannot fold\"\n    if can_fold(squares):\n        return \"can fold\"\n    else:\n        return \"cannot fold\"\n"
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, y, visited, squares, visited_squares, seen_before):\n        if (x, y) in visited_squares:\n            return seen_before[visited_squares[(x, y)]]\n        visited_squares[(x, y)] = len(seen_before)\n        seen_before.append(squares[x][y])\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if 0 <= x + dx < len(squares) and 0 <= y + dy < len(squares[0]) and squares[x + dx][y + dy] == '#' and not visited[x + dx][y + dy]:\n                visited[x + dx][y + dy] = True\n                dfs(x + dx, y + dy, visited, squares, visited_squares, seen_before)\n        return seen_before\n\n    squares = [[s for s in line] for line in stdin.splitlines()]\n    if sum(squares[0].count('#')) != 6 or squares[0].count('#') != 6:\n        return \"cannot fold\"\n\n    visited = [[False for _ in range(len(squares[0]))] for _ in range(len(squares))]\n    seen_before = []\n    visited_squares = {}\n    for x in range(len(squares)):\n        for y in range(len(squares[0])):\n            if squares[x][y] == '#':\n                visited[x][y] = True\n                dfs(x, y, visited, squares, visited_squares, seen_before)\n\n    return \"can fold\" if len(seen_before) == 6 else \"cannot fold\"\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    longest_substring = \"\"\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n            if substring in stdin[:i] and substring != longest_substring:\n                longest_substring = substring\n    return longest_substring\n\n\ninput_string = input().strip()\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    max_length = 0\n    max_substring = \"\"\n\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            substring = stdin[i:j]\n            count = stdin.count(substring)\n\n            if count > 1 and j - i > max_length:\n                max_length = j - i\n                max_substring = substring\n\n    return max_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_repeated_substring(s: str) -> str:\n        max_length = 0\n        longest_substring = ''\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                if s.count(substring) > 1 and len(substring) > max_length:\n                    max_length = len(substring)\n                    longest_substring = substring\n        return longest_substring\n\n    input_string = stdin.strip()\n    return find_longest_repeated_substring(input_string)"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Counting the frequency of each character in the input string\n    char_freq = {}\n    for char in stdin:\n        if char in char_freq:\n            char_freq[char] += 1\n        else:\n            char_freq[char] = 1\n\n    # Creating a list of tuples containing the character and its frequency\n    char_freq_list = [(char, freq) for char, freq in char_freq.items()]\n\n    # Sorting the list by frequency in descending order\n    char_freq_list.sort(key=lambda x: (-x[1], x[0]))\n\n    # Initializing variables to keep track of the current substring and its frequency\n    current_substring = \"\"\n    current_frequency = 0\n    longest_substring = \"\"\n\n    # Iterating through the sorted list of tuples\n    for char, freq in char_freq_list:\n        # If the current character is part of the current substring, add its frequency to the current frequency\n        if char in current_substring:\n            current_frequency += freq\n        # If the current character is not part of the current substring, start a new substring with the current character and its frequency\n        else:\n            current_substring += char\n            current_frequency = freq\n        # If the current substring's frequency is greater than the longest substring's frequency, update the longest substring\n        if current_frequency > 1 and current_frequency > len(longest_substring):\n            longest_substring = current_substring\n\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def longest_repeated_substring(s: str) -> str:\n        n = len(s)\n        max_len = 0\n        start = 0\n        for i in range(n - 1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    if j - i + 1 > max_len:\n                        max_len = j - i + 1\n                        start = i\n        return s[start:start + max_len]\n\n    return longest_repeated_substring(stdin)\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Create a dictionary to store the frequency of each character in the input string\n    freq_dict = {}\n    for char in stdin:\n        if char in freq_dict:\n            freq_dict[char] += 1\n        else:\n            freq_dict[char] = 1\n\n    # Find the longest substring that occurs more than once in the input string\n    max_substring = \"\"\n    max_len = 0\n    start = 0\n    for i in range(len(stdin)):\n        if i > 0 and stdin[i] in freq_dict and freq_dict[stdin[i]] > 1:\n            # Check if the current substring is longer than the previous max_substring\n            if i - start > max_len:\n                max_substring = stdin[start:i]\n                max_len = i - start\n        else:\n            # Reset the start index if the current character is not in the freq_dict or its frequency is not greater than 1\n            start = i\n\n    return max_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize variables\n    max_substring = \"\"\n    current_substring = \"\"\n    char_count = {}\n\n    # Iterate over the input string\n    for char in stdin:\n        current_substring += char\n\n        # If the current character is in char_count, update its count\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n\n        # Check if the current substring is a repeated substring\n        if char_count[char] > 1 and len(current_substring) > len(max_substring):\n            max_substring = current_substring\n\n        # Remove the first character of the current substring from char_count\n        char_count[current_substring[0]] -= 1\n        current_substring = current_substring[1:]\n\n    return max_substring"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize variables\n    max_substring = ''\n    max_length = 0\n    substring = ''\n\n    # Loop through each character in the string\n    for char in stdin:\n        # If the current character is the same as the previous character, add the current character to the substring\n        if char == substring[-1]:\n            substring += char\n        # If the current character is different from the previous character, update the substring if it is longer than the previous longest substring\n        else:\n            if len(substring) > max_length:\n                max_substring = substring\n                max_length = len(substring)\n            substring = char\n    # Update the max substring if the last substring is longer than the previous longest substring\n    if len(substring) > max_length:\n        max_substring = substring\n        max_length = len(substring)\n\n    return max_substring\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize variables\n    longest_substring = \"\"\n    max_length = 0\n\n    # Create a dictionary to store the frequency of each substring\n    substring_freq = {}\n\n    # Iterate through the input string and create substrings of length 1 to len(stdin)\n    for i in range(len(stdin)):\n        for j in range(i + 1, len(stdin) + 1):\n            substring = stdin[i:j]\n\n            # If the substring is not in the dictionary, add it and initialize its frequency to 1\n            if substring not in substring_freq:\n                substring_freq[substring] = 1\n\n            # If the substring is already in the dictionary, increment its frequency\n            else:\n                substring_freq[substring] += 1\n\n                # If the frequency is greater than 1 and the length of the substring is greater than the current max_length, update the longest substring\n                if substring_freq[substring] > 1 and len(substring) > max_length:\n                    max_length = len(substring)\n                    longest_substring = substring\n\n    return longest_substring"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Create a dictionary to store the frequency of each character\n    freq_dict = {}\n    # Initialize variables for the longest repeated substring and its length\n    longest_substring = \"\"\n    longest_length = 0\n    \n    # Iterate through the input string\n    for i in range(len(stdin)):\n        # If the current character is in the dictionary, update its frequency\n        if stdin[i] in freq_dict:\n            freq_dict[stdin[i]] += 1\n        # Otherwise, add the character to the dictionary with a frequency of 1\n        else:\n            freq_dict[stdin[i]] = 1\n        \n        # Check if the current substring has a higher frequency than the previous longest repeated substring\n        for j in range(i, len(stdin)):\n            # If the current character is in the dictionary and has a frequency greater than 1, we have found a repeated substring\n            if stdin[j] in freq_dict and freq_dict[stdin[j]] > 1:\n                # Calculate the length of the repeated substring\n                curr_length = j - i + 1\n                # If the current repeated substring is longer than the previous longest repeated substring, update the longest substring and its length\n                if curr_length > longest_length:\n                    longest_substring = stdin[i:j+1]\n                    longest_length = curr_length\n                    # If there are multiple longest repeated substrings, keep checking for longer substrings\n                    break\n            # If the current character is not in the dictionary or has a frequency of 1, we have found the end of the current substring\n            else:\n                break\n    \n    return longest_substring"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def buy_ticket(start_zone, start_time):\n        for i in range(len(intervals)):\n            if intervals[i][0] <= start_zone <= intervals[i][1] and intervals[i][0] <= end_zone and start_time <= intervals[i][2] <= start_time + 10000:\n                return i\n        return None\n\n    N, *trips = stdin.split('\\n')\n    N = int(N)\n    intervals = []\n    min_coupons = 0\n\n    for trip in trips:\n        start_zone, start_time = map(int, trip.split())\n        end_zone = start_zone\n        end_time = start_time\n        interval = [start_zone, start_zone, start_time]\n\n        for _ in range(N):\n            start_zone, start_time = start_zone + 1, start_time + 10\n            end_zone, end_time = end_zone + 1, end_time + 10\n            interval[0], interval[1], interval[2] = interval[0], end_zone, end_time\n            intervals.append(interval)\n\n        ticket = buy_ticket(start_zone, start_time)\n\n        if ticket is None:\n            min_coupons += 2 + abs(start_zone - end_zone)\n        else:\n            min_coupons += intervals[ticket][3]\n\n    return str(min_coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, *trips = stdin.split('\\n')\n    N = int(N)\n    trips = [list(map(int, trip.split())) for trip in trips]\n\n    coupons = 0\n    for i in range(N):\n        coupons += 2 + abs(trips[i][0] - trips[i][1])\n\n    return str(coupons)\n"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    trips = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    coupons = []\n    for zone, time in trips:\n        coupons.append(2 + abs(zone))\n    return sum(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n\n    coupons = 0\n    for i in range(N):\n        Z, T = map(int, data[i].split())\n        if Z == 0:\n            coupons += 2\n        else:\n            coupons += 3 + abs(Z - 1)\n\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_coupons(trips: list) -> int:\n        trips.sort(key=lambda x: x[1])\n        coupons_used = 0\n        current_ticket = [0, 10000]\n        for trip in trips:\n            if trip[0] >= current_ticket[0] and trip[0] <= current_ticket[1]:\n                continue\n            coupons_used += 2 + abs(current_ticket[0] - current_ticket[1])\n            current_ticket = [trip[0], min(trip[0] + 10, 10)]\n        coupons_used += 2 + abs(current_ticket[0] - current_ticket[1])\n        return coupons_used\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    trips = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n    result = find_min_coupons(trips)\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    coupons = []\n    for i in range(1, len(input_data), 1):\n        zone, time = map(int, input_data[i].split())\n        coupons.append((zone, time))\n    \n    def count_coupons(coupons, zone, time):\n        c = 0\n        for i in range(len(coupons)):\n            if coupons[i][1] >= time and coupons[i][0] <= zone:\n                c += 2 + abs(coupons[i][0] - zone)\n        return c\n    \n    min_coupons = float('inf')\n    for i in range(len(coupons)):\n        min_coupons = min(min_coupons, count_coupons(coupons[:i], coupons[i][0], coupons[i][1]))\n    \n    return str(min_coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n    data = [list(map(int, row.split())) for row in data]\n    \n    coupons = {}\n    for zone, time in data:\n        if zone not in coupons:\n            coupons[zone] = 2\n        else:\n            coupons[zone] += 1 + coupons[zone]\n    \n    total_coupons = sum(coupons.values())\n    return total_coupons"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    coupons = [0] * 11\n    for i in range(1, N+1):\n        zone, time = map(int, input_list[i].split())\n        coupons[zone] += 2 + abs(zone - (10 - zone))\n        coupons[10 - zone] += 2 + abs(zone - (10 - zone))\n    return min(coupons)\n"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    coupons = 0\n    for i in range(1, N+1):\n        zone, time = map(int, input_list[i].split())\n        coupons += 2 + abs(zone - (i-1))\n    return str(coupons)"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def read_int() -> int:\n        return int(stdin.readline().strip())\n\n    def read_ints() -> List[int]:\n        return list(map(int, stdin.readline().strip().split()))\n\n    def get_min_coupons(zones: List[int], times: List[int], N: int) -> int:\n        zones.sort()\n        times.sort()\n        min_coupons = 0\n        i = 0\n        for j in range(N):\n            while i < N and zones[i] <= times[j]:\n                min_coupons += 2 + abs(zones[i] - times[j])\n                i += 1\n        return min_coupons\n\n    N = read_int()\n    zones = []\n    times = []\n    for _ in range(N):\n        zone, time = read_ints()\n        zones.append(zone)\n        times.append(time)\n    min_coupons = get_min_coupons(zones, times, N)\n    return str(min_coupons)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // math.gcd(a, b)\n\n    def dfs(node: int, parent: int) -> int:\n        if left_child[node] == -1:\n            return 1\n        left_count = dfs(left_child[node], node)\n        right_count = dfs(right_child[node], node)\n        return left_count * right_count * lcm(values[node], parent)\n\n    n = int(stdin.splitlines()[0])\n    values = list(map(int, stdin.splitlines()[1].split()))\n    left_child = [-1] * n\n    right_child = [-1] * n\n    count = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lcm(values[i], values[j]) == values[i] + values[j]:\n                left_child[j] = i\n                right_child[j] = i\n                count += 1\n\n    return count % (10**9 + 7)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from functools import lcm\n    from itertools import permutations\n\n    def build_lcm_tree(values, root=0, start=0):\n        if start >= len(values):\n            return root\n        if values[start] == values[root]:\n            values[root] = lcm(values[root], values[start])\n            build_lcm_tree(values, root, start + 1)\n        else:\n            values[start] = lcm(values[root], values[start])\n            build_lcm_tree(values, start, start + 1)\n\n    def count_ways(values):\n        build_lcm_tree(values)\n        ways = 1\n        for perm in permutations(values):\n            if perm != values:\n                ways = (ways * count_ways(perm)) % (10**9 + 7)\n        return ways\n\n    n, *values = stdin.split()\n    n = int(n)\n    values = list(map(int, values))\n\n    if n == 1:\n        return 1\n\n    ways = count_ways(values)\n    return str(ways)\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(x: int, y: int) -> int:\n        return x * y // gcd(x, y)\n\n    def gcd(x: int, y: int) -> int:\n        while y:\n            x, y = y, x % y\n        return x\n\n    def dfs(node: int, parent: int) -> int:\n        nonlocal nodes, parent_nodes, dp\n\n        if parent_nodes[node] != -1:\n            return dp[parent_nodes[node]]\n\n        if node == 0:\n            parent_nodes[node] = parent\n            dp[node] = 1\n            return 1\n\n        res = 0\n        for i in range(1, node + 1):\n            if i != parent and i not in nodes[:node]:\n                res += dfs(i, node)\n        parent_nodes[node] = parent\n        dp[node] = res\n        return res\n\n    def count_ways(n: int) -> int:\n        nonlocal nodes, dp, parent_nodes\n        parent_nodes = [-1] * (n + 1)\n        dp = [0] * (n + 1)\n        return dfs(n, 0)\n\n    n = int(stdin.split('\\n')[0])\n    nodes = list(map(int, stdin.split('\\n')[1].split()))\n    ways = count_ways(n)\n    return str(ways % (10**9 + 7))\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    nodes = [int(node) for node in input_data[1].split()]\n    parent = [-1 for _ in range(n)]\n    size = [1 for _ in range(n)]\n    mod = 10**9 + 7\n\n    def find_parent(node: int) -> int:\n        if parent[node] == -1:\n            return node\n        parent[node] = find_parent(parent[node])\n        return parent[node]\n\n    def merge(node1: int, node2: int) -> None:\n        parent1 = find_parent(node1)\n        parent2 = find_parent(node2)\n        if parent1 != parent2:\n            if size[parent1] < size[parent2]:\n                parent1, parent2 = parent2, parent1\n            parent[parent2] = parent1\n            size[parent1] += size[parent2]\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // math.gcd(a, b)\n\n    def dfs(node: int) -> None:\n        for i in range(2 * node + 1, n, 2):\n            dfs(i)\n            merge(node, i)\n            lcm_value = lcm(nodes[node], nodes[i])\n            if parent[node] == -1 and nodes[parent[i]] == lcm_value:\n                parent[i] = node\n                size[node] += 1\n            elif parent[i] != -1 and nodes[parent[i]] == lcm_value:\n                parent[i] = node\n                size[node] += 1\n\n    count = 0\n    for i in range(n):\n        if parent[i] == -1:\n            dfs(i)\n            count += size[i]\n            size[i] = 0\n\n    return str(count % mod)"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def lcm_tree(nodes: list) -> int:\n        lcm_values = [nodes[0]]\n        for i in range(1, len(nodes)):\n            lcm_values.append(lcm(lcm_values[-1], nodes[i]))\n        return lcm_values\n\n    def count_ways(nodes: list) -> int:\n        ways = 1\n        lcm_values = lcm_tree(nodes)\n        for i in range(len(nodes) - 1):\n            if lcm_values[i] != lcm_values[i + 1]:\n                ways *= 2\n        return ways % (10**9 + 7)\n\n    n, nodes = stdin.split(\"\\n\")\n    n = int(n)\n    nodes = list(map(int, nodes.split()))\n\n    return str(count_ways(nodes))"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return a * b // math.gcd(a, b)\n\n    def lcm_tree(node: int, visited: set, lcms: List[int], leaves: List[int]) -> int:\n        if node in visited:\n            return lcms[node]\n        visited.add(node)\n        if len(leaves) == 1:\n            lcms[node] = leaves[0]\n        else:\n            lcms[node] = lcm(lcm_tree(node * 2, visited, lcms, leaves), lcm_tree(node * 2 + 1, visited, lcms, leaves))\n        return lcms[node]\n\n    n = int(stdin.split(\"\\n\")[0])\n    values = list(map(int, stdin.split(\"\\n\")[1].split()))\n    if n == 1:\n        return \"1\"\n    lcms = [0] * (2 * n - 1)\n    leaves = []\n    for value in values:\n        leaves.append(value)\n        lcms[0] = lcm(lcms[0], value)\n    if n == 2:\n        return str(lcm(lcms[0], lcms[1]))\n    lcms[1] = lcm(lcms[0], lcms[1])\n    for i in range(2, 2 * n - 1, 2):\n        lcms[i] = lcm_tree(i, set(), lcms, leaves)\n    return str(lcms[2 * n - 2])\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm_tree(values: List[int]) -> int:\n        if len(values) == 1:\n            return 1\n        if len(values) == 2:\n            return lcm(values[0], values[1])\n\n        left_sum = sum(values[:len(values) // 2])\n        right_sum = sum(values[len(values) // 2:])\n        return lcm(lcm_tree(values[:len(values) // 2]), lcm_tree(values[len(values) // 2:]))\n\n    n = int(stdin.split('\\n')[0])\n    values = list(map(int, stdin.split('\\n')[1].split()))\n\n    count = 0\n    for permutation in itertools.permutations(values):\n        tree = lcm_tree(permutation)\n        if tree == 1:\n            count += 1\n\n    return str(count % (10**9 + 7))\n\nn = int(input())\nvalues = list(map(int, input().split()))\n\nprint(solution(str(n) + '\\n' + ' '.join(map(str, values)))) "
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from functools import lru_cache\n    from math import gcd\n\n    @lru_cache(maxsize=None)\n    def lcm(x: int, y: int) -> int:\n        return abs(x * y) // gcd(x, y)\n\n    def count_ways(values: list) -> int:\n        if len(values) == 1:\n            return 1\n\n        total_ways = 0\n        for i in range(1, len(values)):\n            left_ways = count_ways(values[:i])\n            right_ways = count_ways(values[i:])\n            for left_way in range(left_ways + 1):\n                for right_way in range(right_ways + 1):\n                    if left_way + right_way > 0:\n                        total_ways += (left_way + right_way) * lcm(values[i - 1], values[i])\n\n        return total_ways % (10**9 + 7)\n\n    n = int(stdin.splitlines()[0])\n    values = list(map(int, stdin.splitlines()[1].split()))\n\n    return str(count_ways(values))\n"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def count_ways(values: List[int]) -> int:\n        if len(values) == 1:\n            return 1\n        count = 0\n        for i in range(1, len(values)):\n            lcm_value = lcm(values[i - 1], values[i])\n            if lcm_value != values[i - 1] and lcm_value != values[i]:\n                count += count_ways(values[:i - 1] + [lcm_value] + values[i + 1:])\n        return count % (10**9 + 7)\n\n    n, *values = stdin.split()\n    values = list(map(int, values))\n    return str(count_ways(values))"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a, b):\n        return (a * b) // math.gcd(a, b)\n\n    def dfs(node, value):\n        nonlocal result\n        if node == n:\n            return\n\n        dfs(2 * node, lcm(value, tree[node]))\n        dfs(2 * node + 1, value)\n\n        if node < n:\n            result += 1\n\n    n = int(stdin.split()[0])\n    tree = list(map(int, stdin.split()[1:]))\n\n    result = 0\n    dfs(1, tree[0])\n\n    return str(result % (10**9 + 7))"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def move(cell, direction):\n        if direction == 'U':\n            return cell[0] - 1, cell[1]\n        elif direction == 'D':\n            return cell[0] + 1, cell[1]\n        elif direction == 'L':\n            return cell[0], cell[1] - 1\n        elif direction == 'R':\n            return cell[0], cell[1] + 1\n\n    def can_move(cell, direction):\n        if direction == 'U' and cell[0] > 0:\n            return True\n        elif direction == 'D' and cell[0] < N - 1:\n            return True\n        elif direction == 'L' and cell[1] > 0:\n            return True\n        elif direction == 'R' and cell[1] < M - 1:\n            return True\n        return False\n\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n    S, G = None, None\n    days = 0\n\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == 'S':\n                S = (i, j)\n            elif cell == 'G':\n                G = (i, j)\n\n    if S is None or G is None:\n        return \"-1\"\n\n    D = {'U': 1, 'D': 1, 'L': 1, 'R': 1}\n    visited = set()\n    current_cell = S\n    current_stamina = K\n\n    while current_cell != G:\n        if days == 0 or days % 2 == 1:\n            visited.clear()\n\n        if current_stamina == 0:\n            break\n\n        if current_cell == G:\n            days += 1\n            current_cell = S\n            current_stamina = K\n            continue\n\n        visited.add(current_cell)\n        directions = []\n\n        if can_move(current_cell, 'U'):\n            directions.append('U')\n        if can_move(current_cell, 'D'):\n            directions.append('D')\n        if can_move(current_cell, 'L'):\n            directions.append('L')\n        if can_move(current_cell, 'R'):\n            directions.append('R')\n\n        for direction in directions:\n            new_cell = move(current_cell, direction)\n            if new_cell not in visited:\n                D[direction] += 1\n                current_cell = new_cell\n                current_stamina -= D[direction]\n                if current_stamina < 0:\n                    break\n                visited.add(current_cell)\n                days += 1\n                break\n\n    if current_cell == G:\n        return days // 2 + 1\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = []\n    for _ in range(N):\n        grid.append(input())\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < N and 0 <= y < M\n\n    def can_move(x: int, y: int, direction: str) -> bool:\n        dx, dy = {\n            'U': (-1, 0),\n            'D': (1, 0),\n            'L': (0, -1),\n            'R': (0, 1),\n        }[direction]\n        return is_valid(x + dx, y + dy) and grid[x + dx][y + dy] != '#'\n\n    def move(x: int, y: int, direction: str) -> tuple:\n        dx, dy = {\n            'U': (-1, 0),\n            'D': (1, 0),\n            'L': (0, -1),\n            'R': (0, 1),\n        }[direction]\n        return x + dx, y + dy\n\n    def find_treasure() -> tuple:\n        for x in range(N):\n            for y in range(M):\n                if grid[x][y] == 'G':\n                    return x, y\n        return None, None\n\n    x, y = find_treasure()\n    if x is None or y is None:\n        return \"-1\"\n\n    days = 1\n    stamina = K\n    while (x, y) != (0, 0):\n        dx, dy = move(x, y, 'S')\n        if not can_move(dx, dy, 'S'):\n            stamina = K\n            days += 1\n            if days >= 2:\n                break\n            x, y = move(x, y, 'S')\n            continue\n\n        if stamina < 1:\n            stamina = K\n            days += 1\n            if days >= 2:\n                break\n\n        stamina -= 1\n        x, y = dx, dy\n\n    if stamina < 1 and days < 2:\n        return \"-1\"\n    return days\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [input().strip() for _ in range(N)]\n    \n    def move(x, y, dx, dy):\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < N and 0 <= ny < M:\n            if grid[nx][ny] in '.FM':\n                return nx, ny\n        return x, y\n    \n    def find_treasure():\n        x, y = 0, 0\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == 'G':\n                    x, y = i, j\n                    break\n            if x != 0:\n                break\n        return x, y\n    \n    x, y = find_treasure()\n    days = 0\n    stamina = K\n    while x != 0 or y != 0:\n        if stamina == 0:\n            break\n        if grid[x][y] == 'S':\n            x, y = find_treasure()\n            days += 1\n            stamina = K\n            continue\n        if grid[x][y] == '#':\n            x, y = find_treasure()\n            days += 1\n            stamina = K\n            continue\n        if grid[x][y] == '.':\n            stamina -= 1\n        if grid[x][y] == 'F':\n            stamina -= 2\n        if grid[x][y] == 'M':\n            stamina -= 3\n        if stamina <= 0:\n            x, y = find_treasure()\n            days += 1\n            stamina = K\n            continue\n        dx, dy = 0, 0\n        if x > 0:\n            dx, dy = -1, 0\n        if x < N - 1:\n            dx, dy = 1, 0\n        if y > 0:\n            dx, dy = 0, -1\n        if y < M - 1:\n            dx, dy = 0, 1\n        x, y = move(x, y, dx, dy)\n        days += 1\n    if x == 0 and y == 0 and stamina > 0:\n        return days\n    else:\n        return -1\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, grid = parse_input(stdin)\n\n    if not is_valid(grid):\n        return \"-1\"\n\n    start = grid.index(\"S\")\n    goal = grid.index(\"G\")\n\n    return find_min_days(start, goal, grid, K)\n\ndef"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M, K = map(int, input_list[0].split())\n    treasure_map = input_list[1:]\n\n    # Initialize the grid with the given treasure map\n    grid = [[cell for cell in row] for row in treasure_map]\n\n    # Initialize the visited cells to avoid infinite loops\n    visited = [[False for _ in range(M)] for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def move_cost(cell):\n        if cell == \".\":\n            return 1\n        elif cell == \"F\":\n            return 2\n        elif cell == \"M\":\n            return 3\n        else:\n            return 0\n\n    def dfs(x, y, stamina):\n        if grid[x][y] == \"G\":\n            return stamina\n\n        visited[x][y] = True\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n\n            if is_valid(nx, ny) and not visited[nx][ny] and stamina >= move_cost(grid[nx][ny]):\n                stamina -= move_cost(grid[nx][ny])\n                stamina = dfs(nx, ny, stamina)\n                if stamina == 0:\n                    return 0\n                stamina += move_cost(grid[nx][ny])\n\n                if stamina == 0:\n                    return 0\n                else:\n                    continue\n\n        stamina -= move_cost(\"S\")\n        stamina = dfs(x - dx, y - dy, stamina)\n        if stamina == 0:\n            return 0\n        stamina += move_cost(\"S\")\n\n        return stamina\n\n    # Check if the treasure is reachable with the given stamina\n    stamina = K\n    result = dfs(0, 0, stamina)\n\n    if result == 0:\n        return -1\n    else:\n        return result + 1"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [list(input().strip()) for _ in range(N)]\n\n    # Initialize variables\n    days = 0\n    stamina = K\n    current_position = None\n    target_position = None\n\n    # Find starting and target positions\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                current_position = (i, j)\n            elif grid[i][j] == 'G':\n                target_position = (i, j)\n\n    if current_position is None or target_position is None:\n        return \"-1\"\n\n    # BFS to find shortest path\n    queue = [(current_position, 0)]\n    visited = set()\n    while queue:\n        position, distance = queue.pop(0)\n        if position == target_position:\n            return distance\n\n        for neighbor in [(position[0] - 1, position[1]), (position[0] + 1, position[1]), (position[0], position[1] - 1), (position[0], position[1] + 1)]:\n            if 0 <= neighbor[0] < N and 0 <= neighbor[1] < M and grid[neighbor[0]][neighbor[1]] == '.' and neighbor not in visited:\n                queue.append((neighbor, distance + 1))\n                visited.add(neighbor)\n\n    return \"-1\""
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n\n    def move(dx, dy):\n        nonlocal x, y, stamina\n        if stamina < 1:\n            return False\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < N and 0 <= ny < M:\n            if grid[ny][nx] == 'S':\n                return False\n            elif grid[ny][nx] == '#':\n                return False\n            elif grid[ny][nx] == 'F' and stamina >= 2:\n                stamina -= 2\n                x, y = nx, ny\n                return True\n            elif grid[ny][nx] == 'M' and stamina >= 3:\n                stamina -= 3\n                x, y = nx, ny\n                return True\n            elif grid[ny][nx] == 'G':\n                return True\n        return False\n\n    def search():\n        nonlocal stamina\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if move(dx, dy):\n                if grid[y][x] == 'G':\n                    return 1\n                else:\n                    return 1 + search()\n        return -1\n\n    x, y = 0, 0\n    stamina = K\n    return search()\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def bfs(start, gold, grid, visited, x, y, stamina):\n        queue = [(start, 0)]\n        visited[start[0]][start[1]] = 1\n        days = 0\n\n        while queue:\n            size = len(queue)\n\n            for _ in range(size):\n                (x, y), d = queue.pop(0)\n\n                if (x, y) == gold:\n                    return d\n\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n\n                    if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#' and not visited[nx][ny]:\n                        queue.append(((nx, ny), d + 1))\n                        visited[nx][ny] = 1\n\n                        if stamina - (distance(x, y, nx, ny) + 1) >= 0:\n                            queue.append(((nx, ny), d + 2))\n                            stamina -= distance(x, y, nx, ny) + 1\n\n            days += 1\n\n            if stamina < K:\n                return -1\n\n            stamina -= K\n\n        return -1\n\n    N, M, K = map(int, stdin.split())\n    grid = [list(stdin.split()[i]) for i in range(1, N + 1)]\n    start, gold = tuple(map(lambda x: grid.index(x), ['S', 'G']))\n    visited = [[0] * M for _ in range(N)]\n\n    result = bfs(start, gold, grid, visited, start[0], start[1], K)\n\n    return result if result != -1 else \"impossible\"\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n    grid = [[cell for cell in row] for row in grid]\n\n    def move(direction: str) -> bool:\n        if direction == 'U':\n            return not grid[i][j] == '#' and i > 0 and grid[i - 1][j] != '#'\n        elif direction == 'D':\n            return not grid[i][j] == '#' and i < N - 1 and grid[i + 1][j] != '#'\n        elif direction == 'L':\n            return not grid[i][j] == '#' and j > 0 and grid[i][j - 1] != '#'\n        elif direction == 'R':\n            return not grid[i][j] == '#' and j < M - 1 and grid[i][j + 1] != '#'\n\n    def find_treasure():\n        for i in range(N):\n            for j in range(M):\n                if grid[i][j] == 'G':\n                    return i, j\n\n    i, j = find_treasure()\n    days = 0\n    stamina = K\n    visited = set()\n\n    while not (i, j) in visited:\n        visited.add((i, j))\n        stamina -= 1\n        if stamina < 0:\n            days += 1\n            stamina = K\n        if grid[i][j] == 'S':\n            continue\n        elif grid[i][j] == 'F':\n            stamina -= 2\n        elif grid[i][j] == 'M':\n            stamina -= 3\n        elif grid[i][j] == 'G':\n            break\n        elif grid[i][j] == '#':\n            break\n        else:\n            break\n        for direction in ['U', 'D', 'L', 'R']:\n            if move(direction):\n                if direction == 'U':\n                    i -= 1\n                elif direction == 'D':\n                    i += 1\n                elif direction == 'L':\n                    j -= 1\n                else:\n                    j += 1\n                break\n\n    if stamina < 0:\n        days += 1\n        stamina = K\n\n    if (i, j) in visited:\n        return days\n    else:\n        return -1\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, M, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:]\n\n    # Initialize variables\n    days = 0\n    stamina = K\n    visited = set()\n    current_pos = None\n    target_pos = None\n\n    # Find the starting and target positions\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                current_pos = (i, j)\n            elif grid[i][j] == 'G':\n                target_pos = (i, j)\n\n    # BFS to find the minimum number of days\n    queue = [(current_pos, 0)]\n    visited.add(current_pos)\n\n    while queue:\n        pos, cost = queue.pop(0)\n        days = max(days, cost)\n\n        if pos == target_pos:\n            return str(days)\n\n        for neighbor in [(pos[0] - 1, pos[1]), (pos[0] + 1, pos[1]), (pos[0], pos[1] - 1), (pos[0], pos[1] + 1)]:\n            if 0 <= neighbor[0] < N and 0 <= neighbor[1] < M and grid[neighbor[0]][neighbor[1]] != '#' and neighbor not in visited:\n                queue.append((neighbor, cost + 1))\n                visited.add(neighbor)\n\n    # If we can't find the treasure, return -1\n    return \"-1\""
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    H, W = map(int, input_list[0].split())\n    grid = [list(input_list[i]) for i in range(1, H + 1)]\n    start_pos = None\n    goal_pos = None\n    obstacles = []\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n            elif grid[i][j] == '#':\n                obstacles.append((i, j))\n\n    commands = input_list[-1]\n\n    def is_valid(pos):\n        return 0 <= pos[0] < H and 0 <= pos[1] < W and grid[pos[0]][pos[1]] == '.'\n\n    def move(pos, direction):\n        if direction == 'L':\n            return pos[0], pos[1] - 1\n        elif direction == 'R':\n            return pos[0], pos[1] + 1\n        elif direction == 'U':\n            return pos[0] - 1, pos[1]\n        elif direction == 'D':\n            return pos[0] + 1, pos[1]\n\n    def is_obstacle(pos):\n        return any(map(lambda x: x == pos, obstacles))\n\n    def is_goal(pos):\n        return pos == goal_pos\n\n    def dfs(pos, cmd_idx):\n        if is_goal(pos):\n            return True\n        if cmd_idx >= len(commands):\n            return False\n        direction = commands[cmd_idx]\n        new_pos = move(pos, direction)\n        if is_valid(new_pos) and not is_obstacle(new_pos):\n            return dfs(new_pos, cmd_idx + 1)\n        else:\n            return False\n\n    def bfs(pos, cmd_idx):\n        queue = [(pos, cmd_idx)]\n        visited = set()\n        while queue:\n            pos, cmd_idx = queue.pop(0)\n            if is_goal(pos):\n                return True\n            if (pos, cmd_idx) in visited:\n                continue\n            visited.add((pos, cmd_idx))\n            for direction in 'LRUD':\n                new_pos = move(pos, direction)\n                if is_valid(new_pos) and not is_obstacle(new_pos):\n                    queue.append((new_pos, cmd_idx + 1))\n        return False\n\n    def repair(pos, cmd_idx):\n        if cmd_idx >= len(commands):\n            return commands\n        direction = commands[cmd_idx]\n        new_pos = move(pos, direction)\n        if is_valid(new_pos) and not is_obstacle(new_pos):\n            return repair(new_pos, cmd_idx + 1)\n        else:\n            if direction == 'L':\n                return commands[:cmd_idx] + ['R'] + repair(pos, cmd_idx + 1)\n            elif direction == 'R':\n                return commands[:cmd_idx] + ['L'] + repair(pos, cmd_idx + 1)\n            elif direction == 'U':\n                return commands[:cmd_idx] + ['D'] + repair(pos, cmd_idx + 1)\n            else:\n                return commands[:cmd_idx] + ['U'] + repair(pos, cmd_idx + 1)\n\n    if dfs(start_pos, 0):\n        return 0\n    else:\n        if bfs(start_pos, 0):\n            return 0\n        else:\n            return len(repair(start_pos, 0)) - 1\n"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    H, W, command_string = input().split()\n    H, W = int(H), int(W)\n    grid = []\n    for _ in range(H):\n        grid.append(input())\n\n    def is_valid_move(x: int, y: int, direction: str) -> bool:\n        if direction == 'U':\n            return 0 <= x - 1 < H and grid[x - 1][y] != '#'\n        elif direction == 'D':\n            return 0 <= x + 1 < H and grid[x + 1][y] != '#'\n        elif direction == 'L':\n            return 0 <= y - 1 < W and grid[x][y - 1] != '#'\n        elif direction == 'R':\n            return 0 <= y + 1 < W and grid[x][y + 1] != '#'\n        else:\n            return False\n\n    def find_goal(x: int, y: int) -> bool:\n        return grid[x][y] == 'G'\n\n    x, y = None, None\n    for i, c in enumerate(grid[0]):\n        if c == 'S':\n            x, y = 0, i\n            break\n\n    if x is None or y is None:\n        raise ValueError(\"Starting location not found\")\n\n    current_x, current_y = x, y\n    visited = set()\n    directions = {'U': 1, 'D': -1, 'L': -1, 'R': 1}\n    command_stack = []\n    command_queue = list(command_string)\n\n    while command_queue:\n        command = command_queue.pop(0)\n        if command in directions:\n            new_x, new_y = current_x, current_y\n            if is_valid_move(new_x, new_y, command):\n                if (new_x, new_y) not in visited:\n                    command_stack.append((new_x, new_y, command))\n                    visited.add((new_x, new_y))\n                    current_x, current_y = new_x, new_y\n                else:\n                    command_stack.append((new_x, new_y, command))\n        elif command == 'U':\n            new_x, new_y = current_x, current_y\n            if is_valid_move(new_x - 1, new_y, command):\n                if (new_x - 1, new_y) not in visited:\n                    command_stack.append((new_x, new_y, command))\n                    visited.add((new_x, new_y))\n                    current_x, current_y = new_x, new_y\n                else:\n                    command_stack.append((new_x, new_y, command))\n        elif command == 'D':\n            new_x, new_y = current_x, current_y\n            if is_valid_move(new_x + 1, new_y, command):\n                if (new_x + 1, new_y) not in visited:\n                    command_stack.append((new_x, new_y, command))\n                    visited.add((new_x, new_y))\n                    current_x, current_y = new_x, new_y\n                else:\n                    command_stack.append((new_x, new_y, command))\n        elif command == 'L':\n            new_x, new_y = current_x, current_y\n            if is_valid_move(new_x, new_y - 1, command):\n                if (new_x, new_y - 1) not in visited:\n                    command_stack.append((new_x, new_y, command))\n                    visited.add((new_x, new_y))\n                    current_x, current_y = new_x, new_y\n                else:\n                    command_stack.append((new_x, new_y, command))\n        elif command == 'R':\n            new_x, new_y = current_x, current_y\n            if is_valid_move(new_x, new_y + 1, command):\n                if (new_x, new_y + 1) not in"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    H, W, command_string = input().split()\n    H, W = int(H), int(W)\n    grid = [input() for _ in range(H)]\n    start_position, goal_position = None, None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_position = (i, j)\n            elif grid[i][j] == 'G':\n                goal_position = (i, j)\n    \n    def is_valid(position: tuple) -> bool:\n        i, j = position\n        return 0 <= i < H and 0 <= j < W and grid[i][j] == '.'\n    \n    def get_neighbors(position: tuple) -> list:\n        i, j = position\n        neighbors = []\n        if is_valid((i-1, j)):\n            neighbors.append((i-1, j))\n        if is_valid((i+1, j)):\n            neighbors.append((i+1, j))\n        if is_valid((i, j-1)):\n            neighbors.append((i, j-1))\n        if is_valid((i, j+1)):\n            neighbors.append((i, j+1))\n        return neighbors\n\n    def is_goal(position: tuple) -> bool:\n        return position == goal_position\n\n    def move(position: tuple, command: str) -> tuple:\n        i, j = position\n        if command == 'L':\n            j -= 1\n        elif command == 'R':\n            j += 1\n        elif command == 'U':\n            i -= 1\n        elif command == 'D':\n            i += 1\n        return (i, j)\n\n    def search(position: tuple, commands: list) -> bool:\n        if is_goal(position):\n            return True\n        for command in commands:\n            new_position = move(position, command)\n            if is_valid(new_position) and not any(new_position == neighbor for neighbor in get_neighbors(position)):\n                if search(new_position, commands):\n                    return True\n        return False\n\n    def fix_string(commands: str) -> str:\n        def is_valid_move(i: int, j: int) -> bool:\n            return 0 <= i < H and 0 <= j < W and grid[i][j] == '.'\n\n        def get_neighbors_of(i: int, j: int) -> list:\n            neighbors = []\n            if is_valid_move(i-1, j):\n                neighbors.append((i-1, j))\n            if is_valid_move(i+1, j):\n                neighbors.append((i+1, j))\n            if is_valid_move(i, j-1):\n                neighbors.append((i, j-1))\n            if is_valid_move(i, j+1):\n                neighbors.append((i, j+1))\n            return neighbors\n\n        def is_goal(position: tuple) -> bool:\n            return position == goal_position\n\n        def move(position: tuple, command: str) -> tuple:\n            i, j = position\n            if command == 'L':\n                j -= 1\n            elif command == 'R':\n                j += 1\n            elif command == 'U':\n                i -= 1\n            elif command == 'D':\n                i += 1\n            return (i, j)\n\n        def insert_char(i: int, j: int, command: str) -> str:\n            fixed_commands = []\n            for k in range(len(commands)):\n                if k == i:\n                    fixed_commands.append(command)\n                    fixed_commands.append(commands[k])\n                else:\n                    fixed_commands.append(commands[k])\n            return ''.join(fixed_commands)\n\n        def delete_char(i: int, j: int) -> str:\n            fixed_commands = []\n            for k in range(len(commands)):\n                if k != i:\n                    fixed_commands.append(commands[k])\n            return ''.join(fixed_commands)\n\n        def fix_commands(commands: str) -> str"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    H, W = map(int, input_list[0].split())\n    grid = [list(input_list[i]) for i in range(1, H + 1)]\n    start_pos, goal_pos = None, None\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                start_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n\n    cmd_string = input_list[-1]\n    robot = Robot(grid, start_pos, goal_pos, cmd_string)\n    return robot.min_changes()\n\n\nclass Robot:\n    def __init__(self, grid: List[List[str]], start_pos: Tuple[int, int], goal_pos: Tuple[int, int], cmd_string: str) -> None:\n        self.grid = grid\n        self.start_pos = start_pos\n        self.goal_pos = goal_pos\n        self.cmd_string = cmd_string\n        self.changes = 0\n\n    def min_changes(self) -> int:\n        for cmd in self.cmd_string:\n            if cmd == 'U':\n                self.changes += self.move_up()\n            elif cmd == 'D':\n                self.changes += self.move_down()\n            elif cmd == 'L':\n                self.changes += self.move_left()\n            elif cmd == 'R':\n                self.changes += self.move_right()\n        return self.changes\n\n    def move_up(self) -> int:\n        new_pos = (self.robot_pos[0] - 1, self.robot_pos[1])\n        if not self.is_valid(new_pos):\n            return 0\n        self.robot_pos = new_pos\n        return 1\n\n    def move_down(self) -> int:\n        new_pos = (self.robot_pos[0] + 1, self.robot_pos[1])\n        if not self.is_valid(new_pos):\n            return 0\n        self.robot_pos = new_pos\n        return 1\n\n    def move_left(self) -> int:\n        new_pos = (self.robot_pos[0], self.robot_pos[1] - 1)\n        if not self.is_valid(new_pos):\n            return 0\n        self.robot_pos = new_pos\n        return 1\n\n    def move_right(self) -> int:\n        new_pos = (self.robot_pos[0], self.robot_pos[1] + 1)\n        if not self.is_valid(new_pos):\n            return 0\n        self.robot_pos = new_pos\n        return 1\n\n    def is_valid(self, pos: Tuple[int, int]) -> bool:\n        return 0 <= pos[0] < len(self.grid) and 0 <= pos[1] < len(self.grid[0]) and self.grid[pos[0]][pos[1]] != '#'\n\n    @property\n    def robot_pos(self) -> Tuple[int, int]:\n        for i in range(len(self.grid)):\n            for j in range(len(self.grid[0])):\n                if self.grid[i][j] == 'S':\n                    return (i, j)\n        return (-1, -1)\n"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    H, W, cmd_str = input().split()\n    H, W = int(H), int(W)\n\n    grid = []\n    for _ in range(H):\n        grid.append(list(input()))\n\n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] == \".\"\n\n    def move(x, y, dx, dy):\n        nx, ny = x + dx, y + dy\n        if is_valid(nx, ny):\n            grid[x][y] = \"*\"\n            grid[nx][ny] = \"S\"\n            return nx, ny\n        return x, y\n\n    x, y = 0, 0\n    for c in cmd_str:\n        if c == \"L\":\n            x, y = move(x, y, -1, 0)\n        elif c == \"R\":\n            x, y = move(x, y, 1, 0)\n        elif c == \"U\":\n            x, y = move(x, y, 0, -1)\n        elif c == \"D\":\n            x, y = move(x, y, 0, 1)\n\n    if grid[x][y] == \"G\":\n        return 0\n    else:\n        return -1"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    H, W, input_string = stdin.split('\\n')\n    H, W = int(H), int(W)\n    input_string = input_string.strip()\n    grid = [list(line) for line in input_string.split('\\n')[:H]]\n\n    def is_valid_move(row, col, direction):\n        if direction == 'L' and col - 1 >= 0 and grid[row][col - 1] != '#':\n            return True\n        elif direction == 'R' and col + 1 < W and grid[row][col + 1] != '#':\n            return True\n        elif direction == 'U' and row - 1 >= 0 and grid[row - 1][col] != '#':\n            return True\n        elif direction == 'D' and row + 1 < H and grid[row + 1][col] != '#':\n            return True\n        return False\n\n    def find_next_move(current_position, commands):\n        row, col = current_position\n        if not commands:\n            return None\n\n        direction = commands.pop(0)\n        if is_valid_move(row, col, direction):\n            if direction == 'L':\n                col -= 1\n            elif direction == 'R':\n                col += 1\n            elif direction == 'U':\n                row -= 1\n            elif direction == 'D':\n                row += 1\n            return (row, col), commands\n        else:\n            return find_next_move(current_position, commands)\n\n    def find_goal(current_position):\n        row, col = current_position\n        if grid[row][col] == 'G':\n            return True\n        else:\n            return False\n\n    def check_path(start_position, commands):\n        current_position = start_position\n        while commands:\n            current_position, commands = find_next_move(current_position, commands)\n            if current_position is None:\n                return False\n\n        return find_goal(current_position)\n\n    def fix_path(commands):\n        count = 0\n        while commands:\n            if commands[0] == 'D' and not is_valid_move(row + 1, col, 'D'):\n                commands.pop(0)\n                count += 1\n            elif commands[0] == 'U' and not is_valid_move(row - 1, col, 'U'):\n                commands.pop(0)\n                count += 1\n            elif commands[0] == 'L' and not is_valid_move(row, col - 1, 'L'):\n                commands.pop(0)\n                count += 1\n            elif commands[0] == 'R' and not is_valid_move(row, col + 1, 'R'):\n                commands.pop(0)\n                count += 1\n            else:\n                break\n        return count\n\n    start_position = None\n    for i, row in enumerate(grid):\n        if 'S' in row:\n            start_position = (i, row.index('S'))\n            break\n\n    if start_position is None:\n        return -1\n\n    commands = list(input_string)\n    success = check_path(start_position, commands)\n\n    if success:\n        return 0\n    else:\n        return fix_path(commands)\n"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    H, W, cmd_str = input().split()\n    H, W = int(H), int(W)\n    grid = [[*input()] for _ in range(H)]\n    visited = set()\n    directions = {\"U\": (-1, 0), \"D\": (1, 0), \"L\": (0, -1), \"R\": (0, 1)}\n\n    def is_valid(pos):\n        return 0 <= pos[0] < H and 0 <= pos[1] < W\n\n    def bfs(start, goal):\n        queue = [(start, 0)]\n        visited.add(start)\n        while queue:\n            pos, steps = queue.pop(0)\n            if pos == goal:\n                return steps\n            for d in directions:\n                new_pos = tuple(sum(x) for x in zip(pos, directions[d]))\n                if is_valid(new_pos) and new_pos not in visited:\n                    queue.append((new_pos, steps + 1))\n                    visited.add(new_pos)\n\n    start = tuple(row.index(\"S\") for row in grid)\n    goal = tuple(row.index(\"G\") for row in grid)\n    return bfs(start, goal)\n\ndef"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_changes(command_string: str) -> int:\n        def is_valid(command_string: str) -> bool:\n            grid = [list(row.strip()) for row in input_grid]\n            robot_x, robot_y = grid[0].index('S'), 0\n            for command in command_string:\n                if command == 'U':\n                    robot_y -= 1\n                elif command == 'D':\n                    robot_y += 1\n                elif command == 'L':\n                    robot_x -= 1\n                elif command == 'R':\n                    robot_x += 1\n                if robot_y < 0 or robot_y >= len(grid) or robot_x < 0 or robot_x >= len(grid[0]) or grid[robot_y][robot_x] == '#':\n                    return False\n            return True\n\n        def delete_char(command_string: str) -> str:\n            return ''.join(command_string[:-1])\n\n        def insert_command(command_string: str, command: str) -> str:\n            return command_string[:-1] + command + command_string[-1]\n\n        def min_changes(command_string: str) -> int:\n            if is_valid(command_string):\n                return 0\n            min_changes_to_valid = float('inf')\n            for i, command in enumerate(command_string):\n                if command == 'U':\n                    continue\n                if command == 'D':\n                    continue\n                if command == 'L':\n                    continue\n                if command == 'R':\n                    continue\n                new_command_string = delete_char(command_string[:i] + command + command_string[i:])\n                changes = min_changes(new_command_string)\n                if changes < min_changes_to_valid:\n                    min_changes_to_valid = changes\n            return min_changes_to_valid + 1\n\n        return min_changes(command_string)\n\n    H, W = map(int, stdin.split()[:2])\n    input_grid = stdin.split('\\n')[1:-1]\n    command_string = stdin.split('\\n')[-1].strip()\n    return get_min_changes(command_string)"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    H, W = input_data.pop(0).split()\n    grid = [list(line) for line in input_data]\n    command_string = input_data.pop()\n    \n    def is_valid(x, y):\n        return 0 <= x < H and 0 <= y < W and grid[x][y] != '#'\n    \n    def is_goal(x, y):\n        return is_valid(x, y) and grid[x][y] == 'G'\n    \n    def move(x, y, direction):\n        if direction == 'L':\n            return x, y - 1\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'U':\n            return x - 1, y\n        elif direction == 'D':\n            return x + 1, y\n        else:\n            raise ValueError(\"Invalid direction\")\n    \n    def is_valid_move(x, y, direction):\n        next_x, next_y = move(x, y, direction)\n        return is_valid(next_x, next_y)\n    \n    def update_position(x, y, direction, command_string):\n        if is_valid_move(x, y, direction):\n            return command_string + direction\n        else:\n            return command_string\n    \n    def dfs(x, y):\n        if is_goal(x, y):\n            return True\n        \n        for direction in 'LRU':\n            next_x, next_y = move(x, y, direction)\n            if is_valid(next_x, next_y):\n                if dfs(next_x, next_y):\n                    return True\n                else:\n                    continue\n            \n            for index, command in enumerate(command_string):\n                if is_valid_move(x, y, direction):\n                    new_command_string = update_position(x, y, direction, command_string[:index] + command + command_string[index+1:])\n                    if dfs(x, y, new_command_string):\n                        return True\n        \n        return False\n    \n    return dfs(int(grid[0].index('S') / W), int(grid[0].index('S') % W))"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    H, W, command_string = input().split()\n    H, W = int(H), int(W)\n    grid = [input() for _ in range(H)]\n\n    # Initialize variables\n    robot_pos = (0, 0)\n    goal_pos = None\n    obstacles = set()\n\n    # Find start and goal positions\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'S':\n                robot_pos = (i, j)\n            elif grid[i][j] == 'G':\n                goal_pos = (i, j)\n            elif grid[i][j] == '#':\n                obstacles.add((i, j))\n\n    # Check if goal can be reached\n    directions = {'L': (-1, 0), 'R': (1, 0), 'U': (0, 1), 'D': (0, -1)}\n    visited = set()\n    stack = [(robot_pos, command_string)]\n\n    while stack:\n        (i, j), commands = stack.pop()\n        if (i, j) == goal_pos:\n            return 0\n        if (i, j) in visited:\n            continue\n        visited.add((i, j))\n\n        for direction, (di, dj) in directions.items():\n            ni, nj = i + di, j + dj\n            if 0 <= ni < H and 0 <= nj < W and (ni, nj) not in obstacles:\n                stack.append(((ni, nj), commands))\n                if commands.startswith(direction):\n                    stack.append(((ni, nj), commands[1:]))\n\n    # Calculate minimum number of changes\n    commands = list(command_string)\n    min_changes = float('inf')\n\n    for i in range(len(commands)):\n        for cmd in ('L', 'R', 'U', 'D'):\n            if cmd != commands[i]:\n                new_commands = list(commands)\n                new_commands[i] = cmd\n                new_command_string = ''.join(new_commands)\n                stack = [(robot_pos, new_command_string)]\n                changes = 0\n\n                while stack:\n                    (i, j), commands = stack.pop()\n                    if (i, j) == goal_pos:\n                        changes += 1\n                        min_changes = min(min_changes, changes)\n                        break\n                    if (i, j) in visited:\n                        continue\n                    visited.add((i, j))\n\n                    for direction, (di, dj) in directions.items():\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < H and 0 <= nj < W and (ni, nj) not in obstacles:\n                            stack.append(((ni, nj), commands))\n                            if commands.startswith(direction):\n                                stack.append(((ni, nj), commands[1:]))\n\n    return min_changes\n"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_closest_beacon(receiver_x, receiver_y, beacons):\n        closest_beacon = None\n        closest_distance = float('inf')\n        for beacon in beacons:\n            beacon_x, beacon_y, distance = beacon\n            distance = abs(receiver_x - beacon_x) + abs(receiver_y - beacon_y)\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_beacon = (beacon_x, beacon_y)\n        return closest_beacon, closest_distance\n\n    def is_valid_position(x, y):\n        return x.is_integer() and y.is_integer()\n\n    def is_consistent_with_input(receiver_x, receiver_y, beacons):\n        for beacon in beacons:\n            beacon_x, beacon_y, _ = beacon\n            distance = abs(receiver_x - beacon_x) + abs(receiver_y - beacon_y)\n            if distance > 4000000:\n                return False\n        return True\n\n    def find_receiver_position(receiver_x, receiver_y, beacons):\n        grid_width = 1000000\n        grid_height = 1000000\n\n        def is_valid_position(x, y):\n            return 0 <= x < grid_width and 0 <= y < grid_height\n\n        def is_consistent_with_input(x, y, beacons):\n            for beacon in beacons:\n                beacon_x, beacon_y, _ = beacon\n                distance = abs(x - beacon_x) + abs(y - beacon_y)\n                if distance > 4000000:\n                    return False\n            return True\n\n        def find_closest_beacon(x, y, beacons):\n            closest_beacon = None\n            closest_distance = float('inf')\n            for beacon in beacons:\n                beacon_x, beacon_y, _ = beacon\n                distance = abs(x - beacon_x) + abs(y - beacon_y)\n                if distance < closest_distance:\n                    closest_distance = distance\n                    closest_beacon = (beacon_x, beacon_y)\n            return closest_beacon, closest_distance\n\n        def search_grid(receiver_x, receiver_y, beacons, visited_positions):\n            if (receiver_x, receiver_y) in visited_positions:\n                return\n            visited_positions.add((receiver_x, receiver_y))\n\n            closest_beacon, closest_distance = find_closest_beacon(receiver_x, receiver_y, beacons)\n            if closest_distance <= 100:\n                return (receiver_x, receiver_y)\n\n            dx = 0 if closest_beacon[0] == receiver_x else 1 if closest_beacon[0] < receiver_x else -1\n            dy = 0 if closest_beacon[1] == receiver_y else 1 if closest_beacon[1] < receiver_y else -1\n\n            if is_valid_position(receiver_x + dx, receiver_y):\n                search_grid(receiver_x + dx, receiver_y, beacons, visited_positions)\n            if is_valid_position(receiver_x, receiver_y + dy):\n                search_grid(receiver_x, receiver_y + dy, beacons, visited_positions)\n            if is_valid_position(receiver_x - dx, receiver_y):\n                search_grid(receiver_x - dx, receiver_y, beacons, visited_positions)\n            if is_valid_position(receiver_x, receiver_y - dy):\n                search_grid(receiver_x, receiver_y - dy, beacons, visited_positions)\n\n        search_grid(receiver_x, receiver_y, beacons, set())\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    beacons = [tuple(map("
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(beacon_positions, receiver_pos):\n        return sum(abs(receiver_pos[0] - beacon_pos[0]) + abs(receiver_pos[1] - beacon_pos[1]) for beacon_pos in beacon_positions)\n\n    def closest_beacon(beacon_positions, receiver_pos, manhattan_distances):\n        closest_distance = min(manhattan_distances)\n        for i, distance in enumerate(manhattan_distances):\n            if distance == closest_distance:\n                return beacon_positions[i]\n\n    def is_valid_position(beacon_positions, receiver_pos):\n        for beacon_pos in beacon_positions:\n            if beacon_pos == receiver_pos:\n                return False\n        return True\n\n    def solve(beacon_positions, manhattan_distances):\n        possible_positions = {(x, y) for x in range(-1000000, 1000001, 1) for y in range(-1000000, 1000001, 1) if is_valid_position(beacon_positions, (x, y))}\n\n        for receiver_pos in possible_positions:\n            closest_beacon_pos = closest_beacon(beacon_positions, receiver_pos, manhattan_distances)\n            if manhattan_distance([closest_beacon_pos], receiver_pos) == 0:\n                return receiver_pos\n\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    beacon_positions = [(int(x), int(y)) for i, line in enumerate(input_data[1:]) for x, y, d in [line.split()]]\n    manhattan_distances = [int(d) for i, line in enumerate(input_data[1:]) for x, y, d in [line.split()]]\n\n    result = solve(beacon_positions, manhattan_distances)\n    if result:\n        return f\"{result[0]} {result[1]}\"\n    else:\n        return \"impossible\" if result is None else \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    beacons = []\n    for i in range(1, N+1):\n        x, y, d = map(int, input_data[i].split())\n        beacons.append((x, y, d))\n    \n    x_r, y_r = 0, 0\n    count = 0\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            dx = beacons[i][0] - beacons[j][0]\n            dy = beacons[i][1] - beacons[j][1]\n            d = abs(dx) + abs(dy)\n            \n            if beacons[i][2] == d:\n                count += 1\n                x_r += beacons[i][0]\n                y_r += beacons[i][1]\n            if beacons[j][2] == d:\n                count += 1\n                x_r += beacons[j][0]\n                y_r += beacons[j][1]\n                \n    if count == 0:\n        return \"impossible\"\n    elif count == 1:\n        x_r, y_r = x_r//count, y_r//count\n        if x_r == int(x_r) and y_r == int(y_r):\n            return f\"{x_r} {y_r}\"\n        else:\n            return \"uncertain\"\n    else:\n        return \"uncertain\"\n\ndef"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    beacons = []\n    for i in range(1, N + 1):\n        beacon = list(map(int, input_list[i].split()))\n        beacons.append(beacon)\n\n    def manhattan_distance(x, y, x_b, y_b):\n        return abs(x - x_b) + abs(y - y_b)\n\n    def is_integer(x):\n        return x == int(x)\n\n    def is_consistent(x, y, dist):\n        for beacon in beacons:\n            if manhattan_distance(x, y, beacon[0], beacon[1]) != dist:\n                return False\n        return True\n\n    def find_consistent_positions():\n        positions = set()\n        for x in range(1000000):\n            for y in range(1000000):\n                if is_integer(x) and is_integer(y) and is_consistent(x, y, 1000):\n                    positions.add((x, y))\n        return positions\n\n    positions = find_consistent_positions()\n\n    if len(positions) == 1:\n        x, y = list(positions)[0]\n        return f\"{x} {y}\"\n    elif len(positions) > 1:\n        return \"uncertain\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    beacon_positions = []\n    for i in range(1, N+1):\n        x, y, d = [int(j) for j in input_list[i].split()]\n        beacon_positions.append((x, y, d))\n\n    x_range = set(x for x, y, d in beacon_positions)\n    y_range = set(y for x, y, d in beacon_positions)\n\n    if len(x_range) * len(y_range) < 4 * N:\n        return \"impossible\"\n\n    for x in x_range:\n        for y in y_range:\n            manhattan_distances = []\n            for bx, by, bd in beacon_positions:\n                manhattan_distances.append(abs(x - bx) + abs(y - by))\n\n            if sorted(manhattan_distances) != sorted(bd for _, _, bd in beacon_positions):\n                continue\n\n            return f\"{x} {y}\"\n\n    return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    beacons = [tuple(map(int, line.split())) for line in input_data[1:]]\n    positions = set(beacons)\n\n    for X_R in range(1000000):\n        for Y_R in range(1000000):\n            total_distance = 0\n            for X_B, Y_B, D_B in beacons:\n                distance = abs(X_B - X_R) + abs(Y_B - Y_R)\n                if distance != D_B:\n                    break\n                total_distance += D_B\n            if total_distance == 0:\n                if (X_R, Y_R) in positions:\n                    return f\"{X_R} {Y_R}\"\n                else:\n                    return \"impossible\"\n\n    return \"uncertain\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n    beacons = [(int(x), int(y)) for x, y, _ in [line.split() for line in data]]\n    distances = [int(d) for _, _, d in [line.split() for line in data]]\n\n    for dx in range(-1000, 1001):\n        for dy in range(-1000, 1001):\n            sum_distances = 0\n            for i in range(N):\n                bx, by = beacons[i]\n                sum_distances += abs(bx - (dx + bx)) + abs(by - (dy + by))\n            if sum_distances == distances[0]:\n                if all(abs(dx + bx) % 1000 == 0 and abs(dy + by) % 1000 == 0 for bx, by in beacons):\n                    return f\"{dx} {dy}\"\n\n    return \"uncertain\" if N == 2 else \"impossible\""
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    beacons = []\n    for i in range(1, N + 1):\n        x, y, d = map(int, input_lines[i].split())\n        beacons.append((x, y, d))\n\n    grid_width = max(max(x) for x, _, _ in beacons)\n    grid_height = max(max(y) for _, y, _ in beacons)\n\n    grid = [[0] * (grid_width + 1) for _ in range(grid_height + 1)]\n\n    for x, y, d in beacons:\n        grid[y][x] = d\n\n    for y in range(grid_height + 1):\n        for x in range(grid_width + 1):\n            if grid[y][x] == 0:\n                grid[y][x] = float('inf')\n\n    for y in range(1, grid_height + 1):\n        for x in range(1, grid_width + 1):\n            if grid[y][x] == float('inf'):\n                continue\n            for dx, dy in [(0, -1), (-1, 0), (1, 0), (0, 1)]:\n                if 0 <= x + dx <= grid_width and 0 <= y + dy <= grid_height:\n                    grid[y][x] = min(grid[y][x], grid[y + dy][x + dx] + abs(x - (x + dx)) + abs(y - (y + dy)))\n\n    if all(x == float('inf') for x in grid[0]) and all(x == float('inf') for x in grid[grid_height]):\n        return \"impossible\"\n\n    result = [(x, y) for y in range(1, grid_height + 1) for x in range(1, grid_width + 1) if grid[y][x] == 0]\n\n    if len(result) == 1:\n        return f\"{result[0][0]} {result[0][1]}\"\n    else:\n        return \"uncertain\"\n"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    beacons = [(int(x), int(y), int(d)) for x, y, d in zip(input_data[1::3], input_data[2::3], input_data[3::3])]\n    beacons.sort(key=lambda x: x[2])\n\n    max_dist = 4e6\n    x_sum = 0\n    y_sum = 0\n\n    for x, y, d in beacons:\n        x_sum += x\n        y_sum += y\n        if d > max_dist:\n            break\n        if x_sum % 2 == 0 and y_sum % 2 == 0:\n            return str(x_sum) + \" \" + str(y_sum)\n\n    return \"uncertain\"\n"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, *beacons = stdin.split('\\n')\n    N = int(N)\n    beacons = [list(map(int, beacon.split())) for beacon in beacons]\n\n    def is_valid_position(X, Y):\n        return (X, Y) in [beacon[:2] for beacon in beacons]\n\n    def manhattan_distance(X, Y, beacon):\n        return abs(X - beacon[0]) + abs(Y - beacon[1])\n\n    min_distance = float('inf')\n    min_position = None\n\n    for x in range(1000000):\n        for y in range(1000000):\n            if not is_valid_position(x, y):\n                continue\n\n            total_distance = 0\n            for beacon in beacons:\n                total_distance += manhattan_distance(x, y, beacon)\n\n            if total_distance < min_distance:\n                min_distance = total_distance\n                min_position = (x, y)\n\n    if min_position is not None:\n        return ' '.join(map(str, min_position))\n    else:\n        return 'impossible'\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def match_corners(c1, c2):\n        corners = sorted([c1, c2], key=lambda x: (x[0], x[1]))\n        r1, c1 = corners[0]\n        r2, c2 = corners[1]\n        return (r1, c1), (r2, c2)\n\n    def is_valid_match(match):\n        for i in range(len(match)):\n            for j in range(i + 1, len(match)):\n                if match[i][0] == match[j][0] and match[i][1] == match[j][1]:\n                    return False\n        return True\n\n    def find_match(corners):\n        if len(corners) == 1:\n            return [0]\n\n        match = []\n        for i in range(len(corners)):\n            for j in range(i + 1, len(corners)):\n                if corners[i][0] == corners[j][0] or corners[i][1] == corners[j][1]:\n                    continue\n                r1, c1 = corners[i]\n                r2, c2 = corners[j]\n                if r1 <= r2 and c1 <= c2:\n                    match.append(i)\n                    match.append(j)\n                    break\n            if len(match) > 0:\n                break\n\n        if len(match) % 2 != 0:\n            return find_match(corners)\n\n        if not is_valid_match(match):\n            return find_match(corners)\n\n        return match\n\n    n = int(stdin.splitlines()[0])\n    corners = []\n    for i in range(n):\n        r1, c1 = map(int, stdin.splitlines()[i * 2 + 1].split())\n        r2, c2 = map(int, stdin.splitlines()[i * 2 + 2].split())\n        corners.append((r1, c1))\n        corners.append((r2, c2))\n\n    match = find_match(corners)\n    if len(match) % 2 != 0:\n        return \"syntax error\"\n\n    result = []\n    for i in range(0, len(match), 2):\n        result.append(match[i] // 2 + 1)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_match(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights):\n        for i, (r1, c1) in enumerate(top_lefts):\n            for j, (r2, c2) in enumerate(bottom_rights):\n                if r1 == r2 or c1 == c2 or r2 == r1 or c2 == c1:\n                    if i not in matched_top_lefts and j not in matched_bottom_rights:\n                        return (i, j)\n        return None\n\n    def validate_match(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights):\n        for i, (r1, c1) in enumerate(top_lefts):\n            for j, (r2, c2) in enumerate(bottom_rights):\n                if r1 == r2 or c1 == c2 or r2 == r1 or c2 == c1:\n                    if i not in matched_top_lefts or j not in matched_bottom_rights:\n                        return False\n        return True\n\n    def create_matched_set(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights, matched_set):\n        for i, (r1, c1) in enumerate(top_lefts):\n            for j, (r2, c2) in enumerate(bottom_rights):\n                if r1 == r2 or c1 == c2 or r2 == r1 or c2 == c1:\n                    if i not in matched_top_lefts and j not in matched_bottom_rights:\n                        matched_top_lefts.add(i)\n                        matched_bottom_rights.add(j)\n                        matched_set.add((i, j))\n\n    def backtrack(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights, matched_set, result):\n        if len(result) == len(top_lefts):\n            return result\n\n        if not validate_match(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights):\n            return None\n\n        matched = find_match(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights)\n        if matched is None:\n            return None\n\n        create_matched_set(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights, matched_set)\n        result.append(matched[1])\n\n        result = backtrack(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights, matched_set, result)\n\n        matched_top_lefts.remove(matched[0])\n        matched_bottom_rights.remove(matched[1])\n        matched_set.remove((matched[0], matched[1]))\n\n        return result\n\n    n = int(stdin)\n    top_lefts = []\n    bottom_rights = []\n    for _ in range(n):\n        r1, c1 = map(int, stdin.split())\n        top_lefts.append((r1, c1))\n        r2, c2 = map(int, stdin.split())\n        bottom_rights.append((r2, c2))\n\n    matched_top_lefts = set()\n    matched_bottom_rights = set()\n    matched_set = set()\n    result = backtrack(top_lefts, bottom_rights, matched_top_lefts, matched_bottom_rights, matched_set, [])\n\n    if result is None:\n        return \"syntax error\"\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    corners = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:n*2+1]]\n    pairs = [(i, j) for i, j in zip(corners[::2], corners[1::2])]\n\n    if not all(i[0] < j[0] and i[1] < j[1] for i, j in pairs):\n        return \"syntax error\"\n\n    def dfs(start: int, end: int, visited: set[int], stack: list[int]) -> bool:\n        if start in visited or start == end:\n            return False\n        visited.add(start)\n        stack.append(start)\n        for i in range(start+1, n+1):\n            if (i, i) in pairs:\n                continue\n            if (i, i+1) in pairs or (i+1, i) in pairs:\n                continue\n            if dfs(i, end, visited, stack):\n                return True\n        return False\n\n    for i in range(1, n+1):\n        if not dfs(i, i, set(), []):\n            return \"syntax error\"\n\n    return \"\\n\".join(str(i) for i in range(1, n+1))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, *corners = stdin.strip().split('\\n')\n    n = int(n)\n    corners = [tuple(map(int, line.split())) for line in corners]\n\n    # Validate input\n    if len(corners) != 2 * n:\n        return \"syntax error\"\n    if any(len(c) != 2 for c in corners):\n        return \"syntax error\"\n\n    # Initialize corners\n    topleft = corners[:n]\n    bottomright = corners[n:]\n\n    # Build adjacency list\n    adj = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            if topleft[i] == bottomright[j] or topleft[j] == bottomright[i]:\n                adj[i].append(j)\n                adj[j].append(i)\n\n    # Topological sort\n    visited = [False] * n\n    stack = []\n    def dfs(v):\n        visited[v] = True\n        for u in adj[v]:\n            if not visited[u]:\n                dfs(u)\n        stack.append(v)\n    for v in range(n):\n        if not visited[v]:\n            dfs(v)\n\n    # Output\n    if any(visited[i] for i in range(n)):\n        return '\\n'.join(str(stack.index(i)) for i in range(n))\n    else:\n        return \"syntax error\""
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def parse_corner(corners: list, corner_type: str) -> list:\n        indices = [i for i, c in enumerate(corners) if c == corner_type]\n        return [indices[i], indices[i+1]]\n\n    def get_matching(top_left_corners: list, bottom_right_corners: list) -> list:\n        top_left_matching = [0] * len(top_left_corners)\n        bottom_right_matching = [0] * len(bottom_right_corners)\n\n        for i in range(len(top_left_corners)):\n            for j in range(len(bottom_right_corners)):\n                if top_left_corners[i] == bottom_right_corners[j]:\n                    top_left_matching[i] = j\n                    bottom_right_matching[j] = i\n\n        return [top_left_matching, bottom_right_matching]\n\n    def validate_matching(top_left_corners: list, bottom_right_corners: list, top_left_matching: list, bottom_right_matching: list) -> bool:\n        for i in range(len(top_left_corners)):\n            for j in range(len(bottom_right_corners)):\n                if (top_left_matching[i] == j and bottom_right_matching[j] != i) or (top_left_matching[i] != j and bottom_right_matching[j] == i):\n                    return False\n        return True\n\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    corners = input_data[1:]\n\n    top_left_corners = parse_corner(corners, '$\\ulcorner $')\n    bottom_right_corners = parse_corner(corners, '$\\lrcorner $')\n\n    if len(top_left_corners) != len(bottom_right_corners):\n        return \"syntax error\"\n\n    top_left_matching, bottom_right_matching = get_matching(top_left_corners, bottom_right_corners)\n\n    if not validate_matching(top_left_corners, bottom_right_corners, top_left_matching, bottom_right_matching):\n        return \"syntax error\"\n\n    result = []\n    for i in range(len(top_left_corners)):\n        result.append(top_left_matching[i] + 1)\n        result.append(bottom_right_matching[top_left_matching[i]] + 1)\n\n    return '\\n'.join(map(str, result)) "
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n\n    n = int(input_data[0])\n    if n < 1 or n > 10**5:\n        return \"Invalid input\"\n\n    corners = []\n    for i in range(n):\n        r1, c1 = map(int, input_data[2 * i + 1].split())\n        r2, c2 = map(int, input_data[2 * i + 2].split())\n        if r1 < 1 or r1 > 10**9 or c1 < 1 or c1 > 10**9 or r2 < 1 or r2 > 10**9 or c2 < 1 or c2 > 10**9:\n            return \"Invalid input\"\n        corners.append(((r1, c1), (r2, c2)))\n\n    # Check if corners are nested properly\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if corners[i][0] == corners[j][0] or corners[i][0] == corners[j][1] or corners[i][1] == corners[j][0] or corners[i][1] == corners[j][1]:\n                    return \"Invalid input\"\n\n    # Find matching corners\n    matching = []\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                if corners[i][0] == corners[j][1] or corners[i][1] == corners[j][0]:\n                    matching.append((i + 1, j + 1))\n\n    if len(matching) == 0:\n        return \"syntax error\"\n    else:\n        return '\\n'.join(map(str, matching))"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_matching(corners: list) -> list:\n        def is_nested(rect1: list, rect2: list) -> bool:\n            return rect1[0] <= rect2[0] and rect1[1] <= rect2[1] and rect1[2] >= rect2[2] and rect1[3] >= rect2[3]\n\n        matching = [0] * len(corners)\n        for i in range(len(corners)):\n            for j in range(len(corners)):\n                if i != j and not any(is_nested(corners[i], corners[j]) for j in range(len(corners))):\n                    matching[i] += 1\n        return matching\n\n    def validate_matching(matching: list) -> bool:\n        def is_connected(node: int, visited: set) -> bool:\n            visited.add(node)\n            for neighbor in range(len(corners)):\n                if neighbor not in visited and matching[neighbor] == 1:\n                    if is_connected(neighbor, visited):\n                        return True\n            return False\n\n        visited = set()\n        for i in range(len(matching)):\n            if matching[i] == 1 and not is_connected(i, visited):\n                return False\n        return True\n\n    n = int(stdin.readline())\n    corners = [[0, 0, 0, 0] for _ in range(n)]\n    for i in range(n):\n        for j in range(2):\n            corners[i][j] = int(stdin.readline())\n        corners[i][2] = int(stdin.readline())\n\n    matching = get_matching(corners)\n    if not validate_matching(matching):\n        return \"syntax error\"\n\n    for i in range(n):\n        print(matching[i])\n"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    corners = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:n*2+1]]\n    border_corners = corners[:n] + corners[n+1:n*2]\n    if not is_valid_matching(border_corners):\n        return \"syntax error\"\n    else:\n        matching = find_matching(border_corners)\n        return \"\\n\".join(str(matching[i-1]) for i in range(1, n+1))\n\ndef"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corner_list = []\n    for i in range(1, 2 * n + 1, 2):\n        corner_list.append(tuple(map(int, input_list[i].split())))\n    for i in range(2, 2 * n + 1, 2):\n        corner_list.append(tuple(map(int, input_list[i].split())))\n    if len(corner_list) != 2 * n:\n        return \"syntax error\"\n    corner_set = set(corner_list)\n    if len(corner_set) != 2 * n:\n        return \"syntax error\"\n    matching = []\n    for i in range(n):\n        corner1 = corner_list[2 * i]\n        corner2 = corner_list[2 * i + 1]\n        if corner1[0] == corner2[0] or corner1[1] == corner2[1] or corner1[0] == corner2[1] or corner1[1] == corner2[0]:\n            return \"syntax error\"\n        for j in range(i + 1, n):\n            corner3 = corner_list[2 * j]\n            corner4 = corner_list[2 * j + 1]\n            if corner1[0] == corner3[0] or corner1[1] == corner3[1] or corner2[0] == corner4[0] or corner2[1] == corner4[1]:\n                return \"syntax error\"\n        matching.append((i + 1) * 2)\n    return '\\n'.join(map(str, matching))\n"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corners = [(int(input_data[2*i+1]), int(input_data[2*i+2])) for i in range(n)]\n    matching = []\n    for i in range(n):\n        for j in range(i+1, n):\n            if (corners[i][0] == corners[j][0] or corners[i][1] == corners[j][1]):\n                if corners[i][0] == corners[j][0]:\n                    if corners[i][1] < corners[j][1]:\n                        matching.append((i+1, j+1))\n                else:\n                    if corners[i][0] < corners[j][0]:\n                        matching.append((i+1, j+1))\n    if not matching:\n        return \"syntax error\"\n    matching.sort(key=lambda x: x[1])\n    return \"\\n\".join(map(str, matching))"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n    def compute_plate(plate: str, filled: int, unknown: int) -> int:\n        if unknown == 0:\n            return int(plate.replace('_', str(filled)))\n        return unknown\n\n    def count_solutions(top: str, bottom: str) -> int:\n        unknown = top.count('_') + bottom.count('_')\n        total_known = 10 - unknown\n        filled = 1 if top[0] != '_' else 0\n        possibilities = []\n        for permutation in permutations(range(1, 21)):\n            plate_values = [permutation[0], permutation[1], permutation[2], permutation[3], permutation[4], permutation[5], permutation[6], permutation[7], permutation[8]]\n            if sum(plate_values) == total_known:\n                plates = [\n                    (top, plate_values[0:3]),\n                    (bottom, plate_values[3:6]),\n                ]\n                valid_plate = True\n                for i in range(len(plates)):\n                    plate, values = plates[i]\n                    filled += values.count(1)\n                    plate_computed = compute_plate(plate, filled, unknown)\n                    valid_plate &= all(value == plate_computed for value in values)\n                if valid_plate:\n                    possibilities.append(plate_values)\n        return len(possibilities)\n\n    top, bottom = stdin.split('\\n')\n    return str(count_solutions(top, bottom))"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def compute_proportions(plate1: int, plate2: int, known: List[int]) -> int:\n        return known[plate2] // known[plate1]\n\n    def compute_burger_slop_proportion(known: List[int]) -> int:\n        return compute_proportions(0, 1, known)\n\n    def compute_sushi_drumstick_proportion(known: List[int]) -> int:\n        return compute_proportions(1, 2, known)\n\n    def compute_slop_drumstick_proportion(known: List[int]) -> int:\n        return compute_proportions(0, 2, known)\n\n    def compute_slop_proportion(known: List[int]) -> int:\n        return compute_proportions(0, 2, known)\n\n    def compute_sushi_proportion(known: List[int]) -> int:\n        return compute_proportions(1, 2, known)\n\n    def compute_drumstick_proportion(known: List[int]) -> int:\n        return compute_proportions(2, 2, known)\n\n    def count_solutions(stdin: str) -> int:\n        known = [int(entry) for entry in stdin.split()]\n        num_solutions = 1\n\n        burger_slop_proportion = compute_burger_slop_proportion(known)\n        sushi_drumstick_proportion = compute_sushi_drumstick_proportion(known)\n        slop_drumstick_proportion = compute_slop_drumstick_proportion(known)\n        slop_proportion = compute_slop_proportion(known)\n        sushi_proportion = compute_sushi_proportion(known)\n        drumstick_proportion = compute_drumstick_proportion(known)\n\n        for i in range(3):\n            if known[i] != -1 and known[i] != 0:\n                num_solutions *= burger_slop_proportion ** (3 - i) * sushi_drumstick_proportion ** i * slop_drumstick_proportion ** i * slop_proportion ** i * sushi_proportion ** i * drumstick_proportion ** i\n\n        return num_solutions\n\n    stdin_lines = stdin.split(\"\\n\")\n    if len(stdin_lines) != 2:\n        return \"many\"\n\n    burger_slop_proportion = compute_burger_slop_proportion(stdin_lines[0].split())\n    sushi_drumstick_proportion = compute_sushi_drumstick_proportion(stdin_lines[1].split())\n\n    num_solutions = 1\n    for i in range(3):\n        num_solutions *= burger_slop_proportion ** (3 - i) * sushi_drumstick_proportion ** i\n\n    return num_solutions"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    plate1 = input_list[0].split()\n    plate2 = input_list[1].split()\n    result = \"\"\n\n    def get_value(plate: list, monster: str) -> int:\n        index = {\"Salamander\": 0, \"Yeti\": 1, \"Golem\": 2, \"Imp\": 3, \"Kraken\": 4}[monster]\n        value = plate[index]\n        if value == \"_\":\n            return 0\n        return int(value)\n\n    def get_proportions(plate1: list, plate2: list) -> list:\n        burger_slop = get_value(plate1, \"Salamander\")\n        sushi_drumstick = get_value(plate2, \"Salamander\")\n        yeti_drumstick = get_value(plate2, \"Yeti\")\n        golem_burger = get_value(plate1, \"Golem\")\n        imp_slop = get_value(plate1, \"Imp\")\n        kraken_slop = get_value(plate1, \"Kraken\")\n        return [burger_slop, sushi_drumstick, yeti_drumstick, golem_burger, imp_slop, kraken_slop]\n\n    def compute_solutions(proportions: list) -> int:\n        # This function calculates the number of distinct solutions using the Chinese Remainder Theorem (CRT).\n        # It is guaranteed that there is at least one solution, so we need not check for that.\n        # If n = p1*p2*...*pn, where pi are distinct primes, then the number of distinct solutions is congruent to (-1)^(p1-1)*(-1)^(p2-1)*...*(-1)^(pn-1) modulo (p1*p2*...*pn)\n        # We use the same modulo for all primes, since they are all distinct.\n        # We first compute the modulo (n1*n2*...*nn) where ni = pk^mi for all k and m.\n        # Then we compute the modulo (n1*n2*...*nn) where ni = pk^mi for all k and m-1.\n        # We keep repeating this process until we reach the smallest possible modulo, which is p1^mi for some m.\n        # Finally, we compute the result as (-1)^m modulo p1^m.\n        n = 1\n        for p, m in zip([2, 3, 5, 7, 11], [1, 2, 3, 4, 5]):\n            n *= p ** m\n        result = 1\n        for p, m in zip([2, 3, 5, 7, 11], [0, 1, 2, 3, 4]):\n            result *= (-1) ** m * (p ** m)\n        result %= n\n        return result\n\n    proportions = get_proportions(plate1, plate2)\n    result = compute_solutions(proportions)\n\n    if result == 1:\n        return \"many\"\n    else:\n        return str(result)"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    plates = [[int(num) for num in row.split()] for row in rows]\n\n    # Compute the number of distinct solutions\n    num_solutions = 0\n    for i in range(len(plates[0])):\n        if plates[0][i] != 0:\n            num_solutions += 1\n            for j in range(i + 1, len(plates[0])):\n                if plates[0][j] != 0:\n                    if plates[0][i] != plates[0][j]:\n                        num_solutions *= 2\n                    else:\n                        num_solutions = 0\n                        break\n                else:\n                    num_solutions = 0\n                    break\n            if num_solutions == 0:\n                break\n\n    if num_solutions == 0:\n        return \"many\"\n    else:\n        return str(num_solutions)\n"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_solutions(top_row: List[int], bot_row: List[int], salamander: int, yeti: int, golem: int, imp: int, kraken: int) -> int:\n        def compute_burger_slop(sushi: int, drumstick: int) -> Tuple[int, int]:\n            burger = (sushi + drumstick) // 2\n            slop = sushi - burger\n            return burger, slop\n\n        burger_slop = compute_burger_slop(top_row[0], bot_row[1])\n        yeti_burger, yeti_slop = compute_burger_slop(bot_row[0], top_row[1])\n        golem_burger, golem_slop = compute_burger_slop(yeti_slop, salamander)\n        imp_burger, imp_slop = compute_burger_slop(yeti_burger, golem)\n        kraken_burger, kraken_slop = compute_burger_slop(bot_row[1], golem)\n\n        return burger, slop, yeti_burger, yeti_slop, golem_burger, golem_slop, imp_burger, imp_slop, kraken_burger, kraken_slop\n\n    def count_solutions_recursive(top_row: List[int], bot_row: List[int], salamander: int, yeti: int, golem: int, imp: int, kraken: int, count: int) -> int:\n        burger, slop, yeti_burger, yeti_slop, golem_burger, golem_slop, imp_burger, imp_slop, kraken_burger, kraken_slop = count_solutions(top_row, bot_row, salamander, yeti, golem, imp, kraken)\n\n        if salamander == 0:\n            return count\n\n        for new_salamander in range(1, salamander + 1):\n            new_yeti = yeti_burger + new_salamander\n            new_golem = golem_slop + new_salamander\n            new_imp = imp_burger + new_golem\n            new_kraken = kraken_slop + new_golem\n            count = count_solutions_recursive(top_row, bot_row, salamander - new_salamander, new_yeti, new_golem, new_imp, new_kraken, count + 1)\n\n        return count\n\n    def count_solutions_iterative(top_row: List[int], bot_row: List[int], salamander: int, yeti: int, golem: int, imp: int, kraken: int) -> int:\n        count = 1\n        yeti_burger, yeti_slop = count_solutions(top_row, bot_row, salamander, yeti, golem, imp, kraken)[:2]\n        golem_burger, golem_slop = count_solutions(top_row, bot_row, salamander, yeti, golem, imp, kraken)[2:4]\n        imp_burger, imp_slop = count_solutions(top_row, bot_row, salamander, yeti, golem, imp, kraken)[4:6]\n        kraken_burger, kraken_slop = count_solutions(top_row, bot_row, salamander, yeti, golem, imp, kraken)[6:8]\n\n        for new_salamander in range(1, salamander + 1):\n            new_yeti = yeti_burger + new_salamander\n            new_golem = golem_slop + new_salamander\n            new_imp = imp_burger + new_golem\n            new_kraken = kraken_slop + new_golem\n            count = count_solutions_iterative(top_row, bot_row, salamander - new_salamander, new_yeti, new_golem, new_imp, new_kraken)\n\n        return count\n\n    def parse_input(input_str: str) -> Tuple[List[int], List[int]]:"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    top_row = input_list[0].split()\n    bottom_row = input_list[1].split()\n\n    def compute_burger_slop(burger_slop_dict: dict) -> int:\n        burger_slop = burger_slop_dict['burger'] + burger_slop_dict['slop']\n        return burger_slop\n\n    def compute_sushi_drumstick(sushi_drumstick_dict: dict) -> int:\n        sushi_drumstick = sushi_drumstick_dict['sushi'] + sushi_drumstick_dict['drumstick']\n        return sushi_drumstick\n\n    def compute_proportionality_ratio(monster_dict: dict, burger_slop_dict: dict, sushi_drumstick_dict: dict) -> float:\n        return (burger_slop_dict['burger'] + sushi_drumstick_dict['sushi']) / (burger_slop_dict['slop'] + sushi_drumstick_dict['drumstick'])\n\n    burger_slop_dict = {'burger': int(top_row[0]), 'slop': int(top_row[1])}\n    sushi_drumstick_dict = {'sushi': int(bottom_row[0]), 'drumstick': int(bottom_row[1])}\n\n    monster_dict = {\n        'Salamander': {'burger': int(top_row[2]), 'slop': int(top_row[3])},\n        'Yeti': {'burger': int(top_row[4]), 'slop': int(top_row[5])},\n        'Golem': {'burger': int(top_row[6]), 'slop': int(top_row[7])},\n        'Imp': {'burger': int(top_row[8]), 'slop': int(top_row[9])},\n        'Kraken': {'burger': int(top_row[10]), 'slop': int(top_row[11])}\n    }\n\n    solutions = []\n\n    for monster, monster_value in monster_dict.items():\n        burger_slop_dict['burger'] = compute_burger_slop(burger_slop_dict)\n        burger_slop_dict['slop'] = compute_sushi_drumstick(burger_slop_dict)\n        sushi_drumstick_dict['sushi'] = compute_sushi_drumstick(sushi_drumstick_dict)\n        sushi_drumstick_dict['drumstick'] = compute_burger_slop(sushi_drumstick_dict)\n\n        proportionality_ratio = compute_proportionality_ratio(monster_dict, burger_slop_dict, sushi_drumstick_dict)\n\n        if monster_value['slop'] == 0:\n            solutions.append(proportionality_ratio)\n        elif monster_value['burger'] == 0:\n            solutions.append(1 / proportionality_ratio)\n        else:\n            solutions.append(proportionality_ratio)\n\n    unique_solutions = set(solutions)\n    if len(unique_solutions) == 1:\n        return \"1\"\n    elif len(unique_solutions) == 2:\n        return \"many\"\n    else:\n        return str(len(unique_solutions))\n\ninput_str = \"50 75 _ _ _ _ _ _ _ _\\n_ _ _ _ _ _ _ _ 50 25 _ _ _ _\"\nprint(solution(input_str))\n\ninput_str = \"160 _ _ 136 _ _ _ _ _ 170\\n_ _ _ _ 120 _ _ 144 _ _\"\nprint(solution(input_str))\n\ninput_str = \"160 _ _ 136 _ _ _ _ _ 170\\n_ _ _ _ 120 _"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    top_row = list(map(int, input_lines[0].split()))\n    bottom_row = list(map(int, input_lines[1].split()))\n    for row in [top_row, bottom_row]:\n        if len(row) != 10:\n            raise ValueError(\"Invalid input\")\n    salamander_plate = top_row[:4]\n    yeti_plate = top_row[4:]\n    golem_plate = bottom_row[:2]\n    imp_plate = bottom_row[2:4]\n    kraken_plate = bottom_row[4:]\n\n    def find_solution():\n        sushi_per_drumstick = golem_plate[1] / golem_plate[3]\n        burger_per_slop = salamander_plate[0] / salamander_plate[1]\n        slop_per_sushi = yeti_plate[1] / yeti_plate[2]\n        drumstick_per_sushi = yeti_plate[3] / yeti_plate[2]\n\n        salamander_sushi = burger_per_slop * golem_plate[0]\n        yeti_drumstick = sushi_per_drumstick * golem_plate[3]\n        yeti_sushi = slop_per_sushi * golem_plate[2] + drumstick_per_sushi * golem_plate[3]\n        golem_burger = sushi_per_drumstick * yeti_plate[2]\n        imp_drumstick = golem_plate[2] / salamander_plate[1]\n        imp_slop = golem_plate[3] / salamander_plate[1]\n        imp_burger = salamander_plate[0] / salamander_plate[1]\n        kraken_drumstick = golem_plate[1] / salamander_plate[0]\n        kraken_slop = yeti_plate[1] / salamander_plate[0]\n        kraken_burger = salamander_plate[0] / salamander_plate[1]\n\n        salamander_slop = burger_per_slop * golem_plate[1]\n        yeti_drumstick = sushi_per_drumstick * golem_plate[3]\n        yeti_sushi = slop_per_sushi * golem_plate[2] + drumstick_per_sushi * golem_plate[3]\n        golem_burger = sushi_per_drumstick * yeti_plate[2]\n        imp_drumstick = golem_plate[2] / salamander_plate[1]\n        imp_slop = golem_plate[3] / salamander_plate[1]\n        imp_burger = salamander_plate[0] / salamander_plate[1]\n        kraken_drumstick = golem_plate[1] / salamander_plate[0]\n        kraken_slop = yeti_plate[1] / salamander_plate[0]\n        kraken_burger = salamander_plate[0] / salamander_plate[1]\n\n        return [\n            (salamander_sushi, yeti_drumstick, yeti_sushi, golem_burger, imp_drumstick, imp_slop, imp_burger, kraken_drumstick, kraken_slop, kraken_burger)\n        ]\n\n    def is_solution(plate):\n        for i, _ in enumerate(plate):\n            if plate[i] == \"_\":\n                continue\n            if plate[i] != plate[i % 4]:\n                return False\n        return True\n\n    solutions = find_solution()\n    valid_solutions = []\n    for solution in solutions:\n        if is_solution(solution):\n            valid_solutions.append(solution)\n    return str(len(valid_solutions))\n\nprint(solution(input())) "
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_solutions(partial_plates: list) -> int:\n        def count_solutions(plate: list) -> int:\n            if plate[0] == 0 or plate[1] == 0:\n                return 0\n            return min(plate[0], plate[1])\n\n        def generate_plate(plate: list, total: int, cur_amount: int) -> list:\n            for i in range(2):\n                if plate[i] == 0:\n                    plate[i] = total - cur_amount + plate[1 - i]\n                    plate[1 - i] = 0\n            return plate\n\n        def backtrack(partial_plates: list, plate_index: int, cur_amount: int) -> int:\n            if plate_index == len(partial_plates) - 1:\n                return count_solutions(generate_plate(partial_plates[-1], cur_amount, 0))\n\n            count = 0\n            for i in range(2):\n                if partial_plates[plate_index][i] == 0:\n                    continue\n                partial_plates[plate_index][i] -= cur_amount\n                count += backtrack(partial_plates, plate_index + 1, count_solutions(partial_plates[plate_index]))\n                partial_plates[plate_index][i] += cur_amount\n            return count\n\n        total_amount = sum([sum(plate) for plate in partial_plates])\n        if total_amount == 0:\n            return 1\n        return backtrack(partial_plates, 0, total_amount)\n\n    def parse_input(input_str: str) -> list:\n        return [list(map(int, input_str.split()[i:i + 2])) for i in range(0, len(input_str), 4)]\n\n    partial_plates = parse_input(stdin)\n    return str(find_solutions(partial_plates))\n"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n\n    sal_top = list(map(int, input_data[0].split()[:2]))\n    yet_bottom = list(map(int, input_data[1].split()[2:4]))\n    golem_top = list(map(int, input_data[0].split()[4:6]))\n    imp_bottom = list(map(int, input_data[1].split()[6:8]))\n    kraken_top = list(map(int, input_data[0].split()[8:]))\n\n    def compute_burgers(slop):\n        return (20 * slop) // 40\n\n    def compute_sushi(drumstick):\n        return (120 * drumstick) // 81\n\n    def compute_drumstick(slop):\n        return (24 * slop) // 81\n\n    def compute_slop(drumstick):\n        return (10 * drumstick) // 20\n\n    burger_solutions = set()\n    sushi_solutions = set()\n    drumstick_solutions = set()\n    slop_solutions = set()\n\n    # Compute burger solutions\n    for burger in range(1, 21):\n        slop = compute_slop(burger)\n        if slop in sal_top and slop in yet_bottom:\n            burger_solutions.add(burger)\n\n    # Compute sushi solutions\n    for sushi in range(1, 21):\n        drumstick = compute_drumstick(sushi)\n        if drumstick in golem_top and drumstick in imp_bottom:\n            sushi_solutions.add(sushi)\n\n    # Compute drumstick solutions\n    for drumstick in range(1, 21):\n        slop = compute_slop(drumstick)\n        if slop in kraken_top and slop in sal_top:\n            drumstick_solutions.add(drumstick)\n\n    # Compute slop solutions\n    for slop in range(1, 21):\n        drumstick = compute_drumstick(slop)\n        if drumstick in yet_bottom and drumstick in imp_bottom:\n            slop_solutions.add(slop)\n\n    result = 1\n    for burger in burger_solutions:\n        for sushi in sushi_solutions:\n            for drumstick in drumstick_solutions:\n                for slop in slop_solutions:\n                    result *= (burger + sushi + drumstick + slop)\n\n    if result == 1:\n        return \"many\"\n    else:\n        return str(result)"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    top_row = list(map(int, input_data[0].split()))\n    bottom_row = list(map(int, input_data[1].split()))\n    \n    monsters = [('Salamander', top_row[:2]), ('Yeti', top_row[2:4]), ('Golem', top_row[4:6]), ('Imp', top_row[6:8]), ('Kraken', top_row[8:])]\n    \n    def compute_burger_slop_proportion(burger_slop, burger, slop):\n        return burger / (burger_slop - burger + slop)\n    \n    def compute_sushi_drumstick_proportion(sushi_drumstick, sushi, drumstick):\n        return drumstick / (sushi_drumstick - sushi + drumstick)\n    \n    def compute_burger_proportions(burger_slop, burger, slop):\n        total_burger_slop = burger_slop - burger + slop\n        return [burger / total_burger_slop, burger / total_burger_slop]\n    \n    def compute_sushi_proportions(sushi_drumstick, sushi, drumstick):\n        total_sushi_drumstick = sushi_drumstick - sushi + drumstick\n        return [sushi / total_sushi_drumstick, sushi / total_sushi_drumstick]\n    \n    def compute_drumstick_proportions(sushi_drumstick, sushi, drumstick):\n        total_sushi_drumstick = sushi_drumstick - sushi + drumstick\n        return [drumstick / total_sushi_drumstick, drumstick / total_sushi_drumstick]\n    \n    def compute_proportions(burger_slop, burger, slop, sushi_drumstick, sushi, drumstick):\n        burger_slop_proportion = compute_burger_slop_proportion(burger_slop, burger, slop)\n        sushi_drumstick_proportion = compute_sushi_drumstick_proportion(sushi_drumstick, sushi, drumstick)\n        burger_proportions = compute_burger_proportions(burger_slop_proportion * burger, burger, slop)\n        sushi_proportions = compute_sushi_proportions(sushi_drumstick_proportion * sushi, sushi, drumstick)\n        drumstick_proportions = compute_drumstick_proportions(sushi_drumstick_proportion * drumstick, burger, sushi)\n        return [burger_proportions, sushi_proportions, drumstick_proportions]\n    \n    def is_valid_configuration(burger_slop, burger, slop, sushi_drumstick, sushi, drumstick):\n        if burger_slop < burger + slop:\n            return False\n        if sushi_drumstick < sushi + drumstick:\n            return False\n        return True\n    \n    solutions = []\n    for burger_slop, burger, slop in compute_proportions(bottom_row[0], bottom_row[1], bottom_row[2], bottom_row[3], bottom_row[4], bottom_row[5]):\n        if not is_valid_configuration(burger_slop, burger, slop, bottom_row[6], bottom_row[7], bottom_row[8]):\n            continue\n        for sushi, drumstick in compute_proportions(top_row[0], top_row[1], top_row[2], top_row[3], top_row[4], top_row[5]):\n            if not is_valid_configuration(burger_slop, burger,"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *roads = stdin.splitlines()\n    N = int(N)\n\n    graph = [[] for _ in range(N)]\n    for u, v in [map(int, road.split()) for road in roads]:\n        u, v = u - 1, v - 1\n        graph[u].append(v)\n        graph[v].append(u)\n\n    count = 0\n    for u in range(N):\n        for v in range(N):\n            if u == v:\n                continue\n            visited = [False] * N\n            stack = [(u, 0)]\n            while stack:\n                node, depth = stack.pop()\n                if visited[node]:\n                    continue\n                visited[node] = True\n                if node == v and depth == 2:\n                    count += 1\n                    break\n                for neighbor in graph[node]:\n                    stack.append((neighbor, depth + 1))\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    N = int(stdin.split(\"\\n\")[0])\n    roads = defaultdict(set)\n    for line in stdin.split(\"\\n\")[1:]:\n        u, v = map(int, line.split())\n        roads[u].add(v)\n        roads[v].add(u)\n\n    def is_optimal(path):\n        for i in range(len(path) - 1):\n            if len(roads[path[i]]) != 2:\n                return False\n            if path[i + 1] not in roads[path[i]]:\n                return False\n        return True\n\n    paths = []\n    for u in roads:\n        for v in roads[u]:\n            if u != v:\n                path = [u, v]\n                while len(path) < N:\n                    next_junctions = [neighbor for neighbor in roads[path[-1]] if neighbor not in path]\n                    if not next_junctions:\n                        break\n                    path.append(next_junctions[0])\n                if len(path) == N:\n                    paths.append(path)\n\n    return str(sum(1 for path in paths if is_optimal(path)))\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    N = int(stdin.split('\\n')[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    graph = [[] for _ in range(N)]\n    for u, v in roads:\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n    \n    def count_paths(u, v):\n        if u == v:\n            return 0\n        if len(graph[u]) == 1 and graph[u][0] == v:\n            return 1\n        return sum(count_paths(w, v) for w in graph[u])\n    \n    count = 0\n    for u, v in combinations(range(N), 2):\n        count += count_paths(u, v) + count_paths(v, u)\n    \n    return str(count // 2)\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_path_length(start: int, end: int) -> int:\n        visited = [False] * (N + 1)\n        queue = [(start, 0)]\n        visited[start] = True\n        while queue:\n            node, depth = queue.pop(0)\n            if node == end:\n                return depth\n            for neighbor in roads[node]:\n                if not visited[neighbor]:\n                    queue.append((neighbor, depth + 1))\n                    visited[neighbor] = True\n        return -1\n\n    N, *roads = stdin.split('\\n')\n    N = int(N)\n    roads = [tuple(map(int, road.split())) for road in roads]\n\n    count = 0\n    for u in range(1, N):\n        for v in range(u + 1, N + 1):\n            if shortest_path_length(u, v) == 2:\n                count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    N = int(stdin.split(\"\\n\")[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    adj_list = defaultdict(list)\n    for u, v in roads:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(u, visited, stack):\n        visited[u] = True\n        for v in adj_list[u]:\n            if not visited[v]:\n                dfs(v, visited, stack + [u])\n\n    paths = 0\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i == j:\n                continue\n            visited = [False] * (N + 1)\n            stack = []\n            dfs(i, visited, stack)\n            if visited[j]:\n                paths += 1\n\n    return str(paths)"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    adj_list = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    def dfs(v: int, visited: set, parent: int, path: list) -> int:\n        visited.add(v)\n        path.append(v)\n        count = 0\n        for u in adj_list[v]:\n            if u != parent:\n                count += dfs(u, visited.copy(), v, path.copy())\n        if len(path) == 2:\n            return count + 1\n        else:\n            return count\n\n    count = 0\n    for i in range(N):\n        count += dfs(i, set(), -1, [])\n\n    return str(count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *edges = stdin.split('\\n')\n    N = int(N)\n    adj_list = [[] for _ in range(N)]\n\n    # Build adjacency list\n    for edge in edges:\n        u, v = map(int, edge.split())\n        adj_list[u - 1].append(v - 1)\n        adj_list[v - 1].append(u - 1)\n\n    # DFS to find all paths of length 2\n    count = 0\n    visited = [False] * N\n\n    def dfs(u, v, visited, adj_list, path):\n        nonlocal count\n        visited[u] = True\n        path.append(u)\n\n        if u == v - 1:\n            count += 1\n        else:\n            for neighbor in adj_list[u]:\n                if not visited[neighbor]:\n                    dfs(neighbor, v, visited, adj_list, path)\n\n        path.pop()\n        visited[u] = False\n\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                dfs(i, j, visited, adj_list, [])\n\n    return str(count)"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n\n    N, *edges = stdin.splitlines()\n    N = int(N)\n    edges = [tuple(map(int, edge.split())) for edge in edges]\n\n    adjacency_list = [[] for _ in range(N)]\n    for u, v in edges:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n\n    paths_count = 0\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                continue\n            for path in permutations([i, j]):\n                if len(path) == 2:\n                    if len(set(path)) == 2 and all(len(adjacency_list[u]) == 2 for u in path):\n                        paths_count += 1\n\n    return str(paths_count)\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    adjacency_list = [[] for _ in range(N)]\n    for u, v in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n\n    def dfs(u: int, visited: set, result: int, path: list):\n        if u in visited:\n            return\n        visited.add(u)\n        path.append(u)\n        for v in adjacency_list[u]:\n            if len(path) == 2 and v == path[0]:\n                result += 1\n            elif len(path) == 2 and v != path[0]:\n                continue\n            dfs(v, visited.copy(), result, path)\n        path.pop()\n\n    result = 0\n    for u in range(N):\n        dfs(u, set(), result, [u])\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_path(graph, start, end):\n        queue = [(start, [start])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            for neighbor in graph[vertex]:\n                if neighbor not in path:\n                    new_path = path + [neighbor]\n                    if neighbor == end:\n                        return new_path\n                    queue.append((neighbor, new_path))\n        return None\n\n    def count_optimal_paths(graph, start, end):\n        queue = [(start, [start])]\n        count = 0\n        while queue:\n            (vertex, path) = queue.pop(0)\n            if len(path) == 2 and vertex == end:\n                count += 1\n            for neighbor in graph[vertex]:\n                if neighbor not in path:\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n        return count\n\n    N, *edges = stdin.splitlines()\n    N = int(N)\n    graph = {i: [] for i in range(1, N + 1)}\n    for edge in edges:\n        u, v = map(int, edge.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    start = 1\n    end = N\n    optimal_paths = count_optimal_paths(graph, start, end)\n    return str(optimal_paths)\n\ninput_data = \"\"\"5\n1 2\n1 3\n3 1\n4 3\n5 1\n\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    positions = []\n\n    for i in range(len(encrypted_message)):\n        if encrypted_message[i:i + len(decrypted_fragment)] == decrypted_fragment:\n            positions.append(i)\n\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0] + len(decrypted_fragment)]\n    elif len(positions) > 1:\n        return len(positions)\n    else:\n        return 0\n"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    if len(encrypted_message) != len(decrypted_fragment):\n        return \"0\"\n    \n    count = 0\n    positions = []\n    for i in range(len(encrypted_message)):\n        if encrypted_message[i] == decrypted_fragment[i]:\n            count += 1\n        else:\n            count = 0\n        if count == len(decrypted_fragment):\n            positions.append(i - count + 1)\n    \n    if len(positions) == 0:\n        return str(len(positions))\n    else:\n        return encrypted_message[positions[0]:positions[0] + len(decrypted_fragment)]\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    encrypted_message = encrypted_message.lower()\n    decrypted_fragment = decrypted_fragment.lower()\n    positions = []\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            positions.append(i)\n    if len(positions) == 0:\n        return str(0)\n    elif len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(decrypted_fragment)]\n    else:\n        return str(len(positions))\n\n\ndef"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = input(stdin).split()\n    if len(encrypted_message) < len(decrypted_fragment):\n        return 0\n    positions = []\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            positions.append(i)\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(decrypted_fragment)]\n    elif len(positions) > 1:\n        return len(positions)\n    else:\n        return 0\n\nstdin = \"secretmessage\\nboot\\n\"\nprint(solution(stdin))\n\nstdin = \"treetreetreetree\\nwood\\n\"\nprint(solution(stdin))\n\nstdin = \"oranges\\napples\\n\"\nprint(solution(stdin)) "
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = stdin.split('\\n')\n    \n    positions = []\n    for i in range(len(encrypted_message)):\n        if encrypted_message[i:i+len(fragment)] == fragment:\n            positions.append(i)\n    \n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(fragment)]\n    elif len(positions) > 1:\n        return len(positions)\n    else:\n        return 0\n"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = input(stdin).splitlines()\n    \n    # Check if the fragment can be found in the encrypted message\n    positions = [i for i in range(len(encrypted_message)) if encrypted_message[i:i+len(fragment)] == fragment]\n    \n    # If positions is empty, the fragment cannot be found\n    if not positions:\n        return \"0\"\n    \n    # If positions has only one element, the fragment can be found in that position\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(fragment)]\n    \n    # Otherwise, the fragment can be found in multiple positions\n    return len(positions)"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    positions = []\n\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i + len(decrypted_fragment)] == decrypted_fragment:\n            positions.append(i)\n\n    if len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0] + len(decrypted_fragment)]\n    elif len(positions) > 1:\n        return len(positions)\n    else:\n        return \"0\"\n"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = stdin.split('\\n')\n    positions = []\n    \n    for i in range(len(encrypted_message)):\n        if encrypted_message[i:i+len(fragment)] == fragment:\n            positions.append(i)\n    \n    if len(positions) == 0:\n        return \"0\"\n    elif len(positions) == 1:\n        return encrypted_message[positions[0]:positions[0]+len(fragment)]\n    else:\n        return \" \".join(str(pos) for pos in positions)"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    message, fragment = stdin.split('\\n')\n\n    # Create a dictionary of the alphabet to count how many times each letter appears in the fragment\n    fragment_counts = {chr(i): fragment.count(chr(i)) for i in range(ord('a'), ord('z')+1)}\n\n    # Count how many times each letter appears in the message\n    message_counts = {chr(i): message.count(chr(i)) for i in range(ord('a'), ord('z')+1)}\n\n    # Calculate the positions where the fragment could occur in the message\n    positions = [i for i in range(len(message)) if all(fragment_counts[letter] <= message_counts[letter] for letter in fragment_counts)]\n\n    # If there is a unique position, output the corresponding substring\n    if len(positions) == 1:\n        return message[positions[0]:positions[0]+len(fragment)]\n    else:\n        return str(len(positions))"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, fragment = [input() for _ in range(2)]\n    fragment_set = set(fragment)\n    matches = 0\n    for i in range(len(encrypted_message)):\n        if encrypted_message[i] in fragment_set:\n            matches += 1\n    if matches == 1:\n        return encrypted_message[encrypted_message.index(fragment[0]):]\n    else:\n        return str(matches)\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S, grid = stdin.split('\\n')\n    N = int(N)\n    \n    directions = {'<': (-1, 0), '>': (1, 0), '^': (0, -1), 'v': (0, 1)}\n    robot_pos = (0, 0)\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                robot_pos = (i, j)\n    \n    trail = [robot_pos]\n    for char in S:\n        dx, dy = directions[char]\n        new_x, new_y = robot_pos[0] + dx, robot_pos[1] + dy\n        if 0 <= new_x < N and 0 <= new_y < N and grid[new_x][new_y] != '#':\n            robot_pos = (new_x, new_y)\n            trail.append(robot_pos)\n    \n    while len(trail) > 1 and trail[-1] == trail[-2]:\n        trail.pop()\n    \n    if len(trail) == 1:\n        return '1'\n    else:\n        for i in range(len(trail) - 1, 0, -1):\n            if trail[i] == trail[i - 1]:\n                return str(i + 1)\n        return str(len(trail))\n\ninput_data = \"\"\"6\n>^<^\n######\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split('\\n')\n    N = int(N)\n\n    grid = []\n    for _ in range(N):\n        grid.append(stdin.readline().strip())\n\n    robot_pos = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                robot_pos = (i, j)\n                break\n        if robot_pos is not None:\n            break\n\n    if robot_pos is None:\n        return \"1\"\n\n    robot_trail = []\n    for i in range(N):\n        robot_trail.append(robot_pos)\n        current_pos = (robot_pos[0] + program[i], robot_pos[1] + program[i])\n        if 0 <= current_pos[0] < N and 0 <= current_pos[1] < N and grid[current_pos[0]][current_pos[1]] != '#':\n            robot_pos = current_pos\n        else:\n            break\n\n    if len(robot_trail) < N:\n        return \"1\"\n\n    for i in range(1, N):\n        if robot_trail[-i] == robot_trail[-i - 1]:\n            continue\n        for j in range(i + 1, N):\n            if robot_trail[-i] == robot_trail[-j]:\n                return N - j\n\n    return \"1\"\n\n\nstdin = \"\"\"6\n>^<^\n######\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\", 1)\n    N = int(N)\n    program = program.strip()\n\n    grid = [line.strip() for line in stdin.split(\"\\n\")[1:] if line.strip()]\n\n    GL_bot_location = None\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == \"R\":\n                GL_bot_location = (i, j)\n                break\n        else:\n            continue\n        break\n\n    if GL_bot_location is None:\n        raise ValueError(\"GL_bot not found on the grid\")\n\n    grid_width = len(grid[0])\n    grid_height = len(grid)\n\n    def is_valid_move(position: tuple[int, int], direction: str) -> tuple[int, int]:\n        x, y = position\n        if direction == \"<\":\n            y = (y - 1) % grid_width\n        elif direction == \">\":\n            y = (y + 1) % grid_width\n        elif direction == \"^\":\n            x = (x - 1) % grid_height\n        elif direction == \"v\":\n            x = (x + 1) % grid_height\n        else:\n            raise ValueError(\"Invalid direction\")\n        return x, y\n\n    def move_bot(position: tuple[int, int], program: str) -> str:\n        for direction in program:\n            x, y = is_valid_move(position, direction)\n            if grid[x][y] != \"#\":\n                position = (x, y)\n            if direction == \">\":\n                direction = \"^\"\n            elif direction == \"<\":\n                direction = \"v\"\n            elif direction == \"v\":\n                direction = \"<\"\n            elif direction == \"^\":\n                direction = \">\"\n        return position\n\n    def find_cycle_start(position: tuple[int, int], program: str, visited: set[tuple[int, int]], cycle_start: list[tuple[int, int]] = None) -> list[tuple[int, int]]:\n        if cycle_start is None:\n            cycle_start = []\n        if position in visited:\n            return cycle_start\n        visited.add(position)\n        x, y = position\n        if grid[x][y] == \"R\":\n            cycle_start.append(position)\n        for direction in program:\n            x, y = is_valid_move(position, direction)\n            if grid[x][y] != \"#\":\n                position = find_cycle_start(position, program, visited, cycle_start)\n        return cycle_start\n\n    # Find the position of the GL-bot\n    GL_bot_position = (GL_bot_location[0], GL_bot_location[1])\n\n    # Move GL-bot according to the program\n    GL_bot_position = move_bot(GL_bot_position, program)\n\n    # Find the start of the cycle\n    cycle_start = find_cycle_start(GL_bot_position, program, set())\n\n    if not cycle_start:\n        return \"1\"\n    else:\n        cycle_length = len(cycle_start)\n        return str(cycle_length)"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\")\n    N = int(N)\n    \n    grid = [line.strip() for line in stdin.split(\"\\n\")[2:]][::-1]\n    \n    def is_valid(pos):\n        return 0 <= pos[0] < N and 0 <= pos[1] < N and grid[pos[0]][pos[1]] != \"#\"\n    \n    def move(pos, direction):\n        if direction == \"<\":\n            return (pos[0], pos[1] - 1) if is_valid((pos[0], pos[1] - 1)) else pos\n        elif direction == \">\":\n            return (pos[0], pos[1] + 1) if is_valid((pos[0], pos[1] + 1)) else pos\n        elif direction == \"^\":\n            return (pos[0] - 1, pos[1]) if is_valid((pos[0] - 1, pos[1])) else pos\n        elif direction == \"v\":\n            return (pos[0] + 1, pos[1]) if is_valid((pos[0] + 1, pos[1])) else pos\n    \n    def follow_program():\n        pos = (N - 1, grid[N - 1].index(\"R\"))\n        for direction in program:\n            pos = move(pos, direction)\n        return pos\n    \n    robot_pos = follow_program()\n    \n    trail = [robot_pos]\n    \n    def find_cycle():\n        for i in range(len(trail)):\n            if trail[i] == trail[-i]:\n                return i\n        return -1\n    \n    cycle_length = find_cycle()\n    \n    if cycle_length == -1:\n        return \"1\"\n    else:\n        return cycle_length"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\")[:2]\n    N = int(N)\n    grid = [line.strip() for line in stdin.split(\"\\n\")[2:]]\n    visited = set()\n    current_position = grid.index(\"R\")\n    current_direction = 0\n\n    def move(direction):\n        nonlocal current_position, current_direction\n        if direction == \">\":\n            current_position += 1\n        elif direction == \"<\":\n            current_position -= 1\n        elif direction == \"^\":\n            current_position -= N\n        elif direction == \"v\":\n            current_position += N\n        current_direction = (current_direction + 1) % 4\n\n    def get_new_position(direction):\n        new_position = current_position\n        if direction == \">\":\n            new_position += 1\n        elif direction == \"<\":\n            new_position -= 1\n        elif direction == \"^\":\n            new_position -= N\n        elif direction == \"v\":\n            new_position += N\n        return new_position\n\n    def get_cell_content(position):\n        row = position // N\n        col = position % N\n        return grid[row][col]\n\n    for char in program:\n        if get_cell_content(current_position) == \"#\":\n            break\n        move(char)\n        visited.add(current_position)\n\n    if len(visited) == N * N - 1:\n        return \"1\"\n\n    def find_cycle(visited):\n        position = current_position\n        direction = current_direction\n        cycle = []\n        while True:\n            position = get_new_position(direction)\n            if position in visited:\n                cycle.append(position)\n                break\n            cycle.append(position)\n            visited.add(position)\n        return cycle\n\n    cycle = find_cycle(visited)\n    length = len(cycle)\n    for i in range(length):\n        if cycle[i] == cycle[i - 1] and cycle[i - 2] != cycle[i - 1]:\n            return length - i\n    return length\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, program, field = stdin.split(\"\\n\")\n    N = int(N)\n\n    field = [list(line) for line in field]\n    initial_position = None\n\n    for i in range(N):\n        for j in range(N):\n            if field[i][j] == \"R\":\n                initial_position = (i, j)\n                break\n\n    if not initial_position:\n        return \"1\"\n\n    x, y = initial_position\n    directions = {\"<\": (-1, 0), \">\": (1, 0), \"v\": (0, 1), \"^\": (0, -1)}\n    gl_bot = {(x, y): 0}\n    current_direction = 0\n    current_position = (x, y)\n    steps = 0\n    cycle_length = 1\n\n    while True:\n        steps += 1\n        dx, dy = directions[program[current_direction]]\n        new_position = (current_position[0] + dx, current_position[1] + dy)\n\n        if 0 <= new_position[0] < N and 0 <= new_position[1] < N and field[new_position[0]][new_position[1]] != \"#\":\n            current_position = new_position\n            gl_bot[current_position] = steps\n\n            if steps % len(program) == 0:\n                current_direction = (current_direction + 1) % len(program)\n            else:\n                current_direction = (current_direction + 1) % len(program)\n\n        else:\n            x, y = current_position\n            dx, dy = directions[program[current_direction]]\n            new_position = (x + dx, y + dy)\n\n            while (new_position[0] < 0 or new_position[0] >= N or new_position[1] < 0 or new_position[1] >= N or field[new_position[0]][new_position[1]] == \"#\") and (new_position[0] >= 0 and new_position[0] < N and new_position[1] >= 0 and new_position[1] < N):\n                x, y = new_position\n                dx, dy = directions[program[current_direction]]\n                new_position = (x + dx, y + dy)\n\n                if (new_position[0] < 0 or new_position[0] >= N or new_position[1] < 0 or new_position[1] >= N or field[new_position[0]][new_position[1]] == \"#\"):\n                    current_direction = (current_direction - 1) % len(program)\n                else:\n                    current_position = new_position\n                    gl_bot[current_position] = steps\n                    break\n\n        if current_position == initial_position:\n            break\n\n    for i in range(N):\n        for j in range(N):\n            if (i, j) in gl_bot:\n                cycle_length = gl_bot[(i, j)] - steps\n                if cycle_length % len(program) == 0:\n                    return cycle_length // len(program)\n                else:\n                    return 1\n\n    return 1\n\ndef"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split('\\n')\n    N = int(N)\n    grid = []\n    for _ in range(N):\n        row = input()\n        grid.append(row)\n    \n    def move(direction: str) -> Tuple[int, int]:\n        nonlocal x, y\n        if direction == '<':\n            x -= 1\n        elif direction == '>':\n            x += 1\n        elif direction == '^':\n            y -= 1\n        elif direction == 'v':\n            y += 1\n        else:\n            raise ValueError(\"Invalid direction\")\n        return x, y\n    \n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < N and 0 <= y < N and grid[y][x] != '#'\n    \n    def is_path_blocked(x: int, y: int) -> bool:\n        for direction in program:\n            next_x, next_y = move(direction)\n            if not is_valid(next_x, next_y):\n                return True\n        return False\n    \n    def find_cycle_length(x: int, y: int, visited: Set[Tuple[int, int]]) -> int:\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        if is_path_blocked(x, y):\n            return 1\n        for direction in program:\n            next_x, next_y = move(direction)\n            if not is_valid(next_x, next_y):\n                continue\n            length = find_cycle_length(next_x, next_y, visited) + 1\n            if length > 1:\n                return length\n        return 1\n    \n    x, y = [i for i, char in enumerate(grid[0]) if char == 'R'][0], 0\n    visited = set()\n    cycle_length = find_cycle_length(x, y, visited)\n    return str(cycle_length) if cycle_length > 1 else '1'\n"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, program = map(str, stdin.split('\\n')[0].split())\n    N = int(N)\n    program = list(program)\n    grid = [list(map(str, input().split())) for _ in range(N)]\n\n    robot_x, robot_y = None, None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                robot_x, robot_y = i, j\n                break\n        else:\n            continue\n        break\n\n    def get_direction(direction: str) -> Tuple[int, int]:\n        if direction == '<':\n            return -1, 0\n        elif direction == '>':\n            return 1, 0\n        elif direction == '^':\n            return 0, -1\n        elif direction == 'v':\n            return 0, 1\n        else:\n            raise ValueError(f\"Invalid direction: {direction}\")\n\n    def move(x: int, y: int, direction: str) -> Tuple[int, int]:\n        dx, dy = get_direction(direction)\n        return x + dx, y + dy\n\n    trail = [(robot_x, robot_y)]\n    x, y = robot_x, robot_y\n    index = 0\n\n    while index < len(program):\n        direction = program[index]\n        dx, dy = get_direction(direction)\n\n        if (robot_x + dx, robot_y + dy) in trail:\n            index += 1\n            continue\n\n        x, y = move(x, y, direction)\n\n        if x < 0 or x >= N or y < 0 or y >= N or grid[x][y] == '#':\n            return 1\n\n        if (x, y) in trail:\n            index += 1\n            continue\n\n        trail.append((x, y))\n        index += 1\n\n    if len(trail) == len(set(trail)):\n        return 1\n\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '#':\n                continue\n            for dx, dy in ((0, 1), (1, 0), (0, -1), (-1, 0)):\n                x, y = i + dx, j + dy\n                if 0 <= x < N and 0 <= y < N and grid[x][y] == '.':\n                    if (x, y) not in trail:\n                        continue\n                    for k in range(len(trail)):\n                        if k > 0 and (trail[k] == (x, y)) or k == 0 and (trail[k] == (x, y) or trail[k] == (x - dx, y - dy)):\n                            break\n                    else:\n                        return len(trail)\n    return 1"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split('\\n', 1)\n    N = int(N)\n    program = program.strip()\n    grid = [input().strip() for _ in range(N)]\n\n    directions = {'<': (0, -1), '>': (0, 1), 'v': (1, 0), '^': (-1, 0)}\n    initial_location = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'R':\n                initial_location = (i, j)\n\n    if not initial_location:\n        return '1'\n\n    trail = [(initial_location[0], initial_location[1])]\n    current_location = initial_location\n\n    for direction in program:\n        delta_x, delta_y = directions[direction]\n        new_x, new_y = current_location[0] + delta_x, current_location[1] + delta_y\n\n        if 0 <= new_x < N and 0 <= new_y < N and grid[new_x][new_y] != '#':\n            current_location = (new_x, new_y)\n            if current_location not in trail:\n                trail.append(current_location)\n\n    if len(trail) == N * N:\n        return '1'\n\n    seen = set(trail)\n    length = len(trail)\n    for i in range(length):\n        for j in range(i, length):\n            if trail[i] == trail[j]:\n                start_index = j\n                end_index = j\n                while end_index + 1 < length and trail[end_index + 1] == trail[start_index]:\n                    end_index += 1\n                subsequence_length = end_index - start_index + 1\n                if subsequence_length % 2 == 0:\n                    X = subsequence_length // 2\n                    return str(X)\n\n    X = length\n    while True:\n        if trail[-X:] == trail[-2 * X:-X]:\n            return str(X)\n        X += 1"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split('\\n', 1)\n    N = int(N)\n    \n    grid = [line.split() for line in stdin.split('\\n', 4)[4:] if line.strip()]\n    \n    robot_row, robot_col = 0, 0\n    for i, row in enumerate(grid):\n        if 'R' in row:\n            robot_row, robot_col = i, row.index('R')\n            break\n    \n    def move(direction: str) -> tuple:\n        if direction == '<':\n            return (0, -1)\n        elif direction == '>':\n            return (0, 1)\n        elif direction == '^':\n            return (-1, 0)\n        elif direction == 'v':\n            return (1, 0)\n    \n    def move_robot(robot_row: int, robot_col: int, direction: str) -> tuple:\n        delta_row, delta_col = move(direction)\n        new_row, new_col = robot_row + delta_row, robot_col + delta_col\n        if 0 <= new_row < N and 0 <= new_col < N and grid[new_row][new_col] != '#':\n            return new_row, new_col\n        else:\n            return robot_row, robot_col\n    \n    trail = [grid[robot_row][robot_col]]\n    for direction in program:\n        robot_row, robot_col = move_robot(robot_row, robot_col, direction)\n        trail.append(grid[robot_row][robot_col])\n    \n    if len(set(trail)) == len(trail):\n        return '1'\n    else:\n        for i in range(N):\n            if len(set(trail[:i+1])) != len(trail[:i+1]):\n                return str(N - i)"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    fogs = [tuple(map(int, stdin.split(\"\\n\")[i+1].split())) for i in range(n)]\n    \n    total_missed = 0\n    for m, d, l, r, h, dd, dx, dh, dh_height in fogs:\n        area = r - l\n        missed = 0\n        for i in range(1, m+1):\n            shifted_area = area + i*dx\n            height = h + i*dh\n            shifted_height = h + (i-1)*dh + i*dh_height\n            if shifted_height + shifted_area * height <= 0:\n                missed += 1\n        total_missed += missed\n    \n    return str(total_missed)\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    fogs = []\n    for i in range(1, n+1):\n        m, d, l, r, h, dd, dh, dh2 = map(int, stdin[i].split())\n        fogs.append((m, d, l, r, h, dd, dh, dh2))\n\n    total_missed = 0\n    for fog in fogs:\n        m, d, l, r, h, dd, dh, dh2 = fog\n        height = 0\n        total_missed += (r - l + 1) * m - (r - l + 1 - h) * m\n        total_missed += h * (m - 1)\n        for i in range(1, m):\n            height += dh\n            total_missed += height * (r - l + 1 - height)\n            height += dh2\n\n    return str(total_missed)"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = []\n\n    for i in range(1, n + 1):\n        params = list(map(int, stdin.splitlines()[i].split()))\n        fogs.append(params)\n\n    total_missed_fogs = 0\n    for fog in fogs:\n        missed_fogs = fog[0] * (fog[0] + fog[1]) // 2\n        total_missed_fogs += missed_fogs\n\n    return str(total_missed_fogs)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    fogs = [[] for _ in range(n)]\n    total_missed = 0\n    for i in range(n):\n        m, d, l, r, h, dx, dh, dh = map(int, stdin.split()[1:])\n        for j in range(m):\n            fogs[i].append([l + j*dx, r + j*dx, h + j*dh])\n            total_missed += d + j*dh\n    return str(total_missed)"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    fogs = []\n    for i in range(1, n + 1):\n        m, l, r, h, d, dx, dh, dh_next = map(int, input_lines[i].split())\n        fogs.append((m, l, r, h, d, dx, dh, dh_next))\n\n    missed_fogs = 0\n    for fog, (m, l, r, h, d, dx, dh, dh_next) in zip(fogs, fogs[1:]):\n        missed_fogs += (d - fog[4] - 1) * fog[0]\n        missed_fogs += fog[0] * (fog[5] + (fog[0] - 1) * fog[6])\n        missed_fogs += fog[0] * (fog[7] + (fog[0] - 1) * dh_next)\n\n    return str(missed_fogs)\n\ninput_string = \"\"\"2\n2 3 0 2 9 2 3 0\n1 6 1 4 6 3 -1 -2\n\n3\n4 0 0 10 10 1 15 0\n3 5 50 55 8 1 -16 2\n3 10 7 10 4 1 8 -1\n\n2\n7 0 0 20 10 3 0 10\n10 1 0 2 5 2 2 7\"\"\"\n\noutput = solution(input_string)\nprint(output) "
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    fogs = [list(map(int, line.split())) for line in stdin[1:n+1]]\n    total_missed = 0\n    \n    for i in range(n):\n        m_i, d_i, l_i, r_i, h_i, delta_d_i, delta_x_i, delta_h_i, delta_h_i = fogs[i]\n        for j in range(m_i):\n            x_j = l_i + j * delta_x_i\n            h_j = 0\n            missed = False\n            for k in range(m_i):\n                if j != k:\n                    x_k = l_i + k * delta_x_i\n                    h_k = h_i + (k-1) * delta_h_i\n                    if x_j <= x_k and x_k <= r_i and h_j <= h_k <= h_j + delta_h_i:\n                        missed = True\n                        break\n            total_missed += (m_i-1) * missed\n    \n    return str(total_missed)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\", 1)[0])\n    fogs = [list(map(int, line.split())) for line in stdin.split(\"\\n\", 1)[1].split(\"\\n\")[:n]]\n    \n    total_missed = 0\n    \n    for i in range(n):\n        m = fogs[i][0]\n        for k in range(m):\n            total_missed += 1\n    \n    return str(total_missed)\n\ninput1 = \"\"\"2\n2 3 0 2 9 2 3 0\n1 6 1 4 6 3 -1 -2\n\"\"\"\n\ninput2 = \"\"\"3\n4 0 0 10 10 1 15 0\n3 5 50 55 8 1 -16 2\n3 10 7 10 4 1 8 -1\n\"\"\"\n\ninput3 = \"\"\"2\n7 0 0 20 10 3 0 10\n10 1 0 2 5 2 2 7\n\"\"\"\n\nprint(solution(input1))  # Output: 3\nprint(solution(input2))  # Output: 6\nprint(solution(input3))  # Output: 11"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    fogs = [stdin.split('\\n')[i + 1].split() for i in range(n)]\n    fogs = [[int(i) for i in fogs[j]] for j in range(n)]\n    total_fogs = 0\n    \n    for i in range(n):\n        total_fogs += fogs[i][0]\n    \n    return str(total_fogs)\n\ndef"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    fogs = []\n    for i in range(1, n + 1):\n        params = list(map(int, stdin.split(\"\\n\")[i].split()))\n        fogs.append(params)\n\n    total_missed = 0\n    for fog in fogs:\n        m, d, l, r, h, dd, dh, dh_change = fog\n        total_missed += m - 1\n\n    return str(total_missed)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_input():\n        n = int(input())\n        fogs = []\n        for _ in range(n):\n            fog_params = list(map(int, input().split()))\n            fogs.append(fog_params)\n        return n, fogs\n\n    def count_missed_fogs(n, fogs):\n        total_missed = 0\n        for i in range(n):\n            m, d, l, r, h, delta_d, delta_x, delta_h = fogs[i]\n            missed = m - 1 if delta_x < 0 else m\n            total_missed += missed\n        return total_missed\n\n    n, fogs = get_input()\n    missed = count_missed_fogs(n, fogs)\n    return str(missed)"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    start_coords = tuple(float(coord) for coord in lines[0].split())\n    end_coords = tuple(float(coord) for coord in lines[1].split())\n    conveyors = []\n\n    for i in range(2, len(lines)):\n        conveyor_coords = tuple(float(coord) for coord in lines[i].split())\n        conveyors.append(conveyor_coords)\n\n    def min_time(start_coords: tuple, end_coords: tuple, conveyors: list) -> float:\n        def dist(coord1: tuple, coord2: tuple) -> float:\n            return ((coord2[0] - coord1[0])**2 + (coord2[1] - coord1[1])**2)**0.5\n\n        def intersect(line1: tuple, line2: tuple) -> bool:\n            x_diff = (line1[0][0] - line1[1][0], line2[0][0] - line2[1][0])\n            y_diff = (line1[0][1] - line1[1][1], line2[0][1] - line2[1][1])\n            div = (y_diff[0] * x_diff[1] - y_diff[1] * x_diff[0])\n\n            if div == 0:\n                return False\n\n            d = (line1[0][0] - line1[1][0]) * y_diff[0] - (line1[0][1] - line1[1][1]) * x_diff[0]\n            x = d * x_diff[0] / div\n            y = d * y_diff[0] / div\n\n            return line1[0][0] <= x <= line1[1][0] and line1[0][1] <= y <= line1[1][1]\n\n        def find_next_conveyor(coord: tuple, conveyors: list) -> tuple:\n            closest_dist = float('inf')\n            closest_conveyor = None\n\n            for conveyor in conveyors:\n                dist_to_conveyor = dist(coord, conveyor[0])\n                if dist_to_conveyor < closest_dist:\n                    closest_dist = dist_to_conveyor\n                    closest_conveyor = conveyor\n\n            return closest_conveyor\n\n        def can_walk_on_conveyor(coord: tuple, conveyor: tuple) -> bool:\n            for i in range(2):\n                line = (coord, conveyor[i])\n                if intersect(line, conveyor):\n                    return False\n\n            return True\n\n        def walk_on_floor(start_coords: tuple, end_coords: tuple, conveyors: list) -> float:\n            current_coords = start_coords\n            time = 0\n\n            while dist(current_coords, end_coords) > 0.01:\n                next_conveyor = find_next_conveyor(current_coords, conveyors)\n\n                if next_conveyor is not None:\n                    if can_walk_on_conveyor(current_coords, next_conveyor):\n                        time_to_conveyor = dist(current_coords, next_conveyor[0]) / 2\n                        current_coords = next_conveyor[1]\n                        time += time_to_conveyor\n                    else:\n                        time += dist(current_coords, next_conveyor[0])\n                        current_coords = next_conveyor[0]\n                else:\n                    time += dist(current_coords, end_coords)\n                    current_coords = end_coords\n\n            return time\n\n        start_time = 0\n        time = 0\n\n        while dist(start_coords, end_coords) > 0.01:\n            time += walk_on_floor(start_coords, end_coords, conveyors)\n            start_coords = end_coords\n            start_time = time\n\n            next_conveyor = find_next_conveyor(start_coords, convey"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    xa, ya, xb, yb = map(float, input_data[0].split())\n    N = int(input_data[1])\n    conveyors = []\n    for i in range(2, 2+N):\n        x1, y1, x2, y2 = map(float, input_data[i].split())\n        conveyors.append(((x1, y1), (x2, y2)))\n    \n    def distance(a, b):\n        return ((a[0]-b[0])**2 + (a[1]-b[1])**2)**0.5\n\n    def get_time(xa, ya, xb, yb, conveyors):\n        time = 0\n        x, y = xa, ya\n        while distance((x, y), (xb, yb)) > 0:\n            conveyor_found = False\n            for conveyor in conveyors:\n                if (distance(conveyor[0], (x, y)) < 1) and (distance(conveyor[1], (x, y)) < 1):\n                    conveyor_found = True\n                    x, y = x+1, y\n                    time += 1/2\n                    break\n            if not conveyor_found:\n                x, y = x+1, y\n                time += 1\n        return time\n\n    time = get_time(xa, ya, xb, yb, conveyors)\n    return f\"{time:.6f}\""
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def closest_conveyor(p, conveyors):\n        return min(conveyors, key=lambda c: distance(p, ((c[0][0] + c[1][0])/2, (c[0][1] + c[1][1])/2)))\n\n    def can_walk_on_conveyor(p, conveyor):\n        p1, p2 = conveyor\n        slope = (p2[1] - p1[1])/(p2[0] - p1[0])\n        b = p2[1] - slope*p2[0]\n        return p[1] - slope*p[0] - b <= 0\n\n    def time_to_walk_on_conveyor(dist):\n        return dist/2\n\n    def time_to_walk_on_floor(dist):\n        return dist\n\n    def min_time(p1, p2, conveyors):\n        dist = distance(p1, p2)\n        conveyor = closest_conveyor(p1, conveyors)\n        if can_walk_on_conveyor(p1, conveyor) and can_walk_on_conveyor(p2, conveyor):\n            conveyor_dist = min(distance(p1, conveyor[0]), distance(p1, conveyor[1]), distance(p2, conveyor[0]), distance(p2, conveyor[1]))\n            conveyor_time = time_to_walk_on_conveyor(conveyor_dist)\n            floor_dist = dist - conveyor_dist\n            floor_time = time_to_walk_on_floor(floor_dist)\n            return conveyor_time + floor_time\n        else:\n            floor_time = time_to_walk_on_floor(dist)\n            return floor_time\n\n    lines = stdin.split('\\n')\n    p1 = tuple(float(x) for x in lines[0].split()[:2])\n    p2 = tuple(float(x) for x in lines[0].split()[2:])\n    conveyors = []\n    for i in range(1, int(lines[1])+1):\n        p1 = tuple(float(x) for x in lines[i+1].split()[:2])\n        p2 = tuple(float(x) for x in lines[i+1].split()[2:])\n        conveyors.append((p1, p2))\n\n    return f\"{min_time(p1, p2, conveyors):.4f}\" "
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X_A, Y_A, X_B, Y_B, N = map(float, stdin.split()[:5])\n    conveyors = []\n\n    for _ in range(int(N)):\n        conveyors.append(list(map(float, stdin.split()[5 + 3 * i: 5 + 3 * (i + 1)])))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def closest_conveyor(point):\n        closest = None\n        min_dist = float('inf')\n\n        for conveyor in conveyors:\n            dist = min(distance(conveyor[0], point), distance(conveyor[1], point))\n\n            if dist < min_dist:\n                min_dist = dist\n                closest = conveyor\n\n        return closest\n\n    def min_time(point1, point2):\n        dist = distance(point1, point2)\n        conveyor = closest_conveyor((point1[0] + point2[0]) / 2, (point1[1] + point2[1]) / 2)\n\n        if conveyor is None:\n            return dist / 1.0\n\n        t1 = distance(point1, conveyor[0]) / 2.0\n        t2 = distance(point2, conveyor[1]) / 2.0\n\n        return min(t1 + t2, dist / 2.0)\n\n    return \"{:.6f}\".format(min_time((X_A, Y_A), (X_B, Y_B)))\n"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    coordinates_A = list(map(float, input_values[0].split()))\n    coordinates_B = list(map(float, input_values[1].split()))\n    conveyors = []\n    for i in range(2, len(input_values)):\n        conveyor_coordinates = list(map(float, input_values[i].split()))\n        conveyors.append(conveyor_coordinates)\n    \n    def distance(point1, point2):\n        return ((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)**0.5\n\n    def is_on_conveyor(point, conveyor):\n        if conveyor[0] == conveyor[2]:\n            return point[0] == conveyor[0] and point[1] >= min(conveyor[1], conveyor[3]) and point[1] <= max(conveyor[1], conveyor[3])\n        elif conveyor[1] == conveyor[3]:\n            return point[1] == conveyor[1] and point[0] >= min(conveyor[0], conveyor[2]) and point[0] <= max(conveyor[0], conveyor[2])\n        else:\n            return False\n\n    def time_to_conveyor(point, conveyor):\n        x1, y1, x2, y2 = conveyor\n        if is_on_conveyor(point, conveyor):\n            return 0\n        if x1 == x2:\n            if y1 > y2:\n                y1, y2 = y2, y1\n            return abs((y2 - y1) / (2 * 2))\n        else:\n            if x1 > x2:\n                x1, x2 = x2, x1\n            return abs((x2 - x1) / (2 * 2))\n\n    def time_to_point(point, conveyors):\n        conveyors = sorted(conveyors, key=lambda x: distance(point, x))\n        time = 0\n        while not is_on_conveyor(point, conveyors[0]):\n            time += time_to_conveyor(point, conveyors[0])\n            point[0] += 1 if point[0] < conveyors[0][0] else -1\n            point[1] += 1 if point[1] < conveyors[0][1] else -1\n        time += time_to_conveyor(point, conveyors[0])\n        return time\n\n    time_A = time_to_point(coordinates_A, conveyors)\n    time_B = time_to_point(coordinates_B, conveyors)\n    return (time_A + time_B) / 2"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def get_conveyor_time(p, conveyor):\n        d = distance(p, conveyor[0])\n        if d == 0:\n            return 0\n        time = d / 2\n        if p[0] < conveyor[0][0]:\n            time += (p[0] - conveyor[0][0]) / 2\n        elif p[0] > conveyor[1][0]:\n            time += (p[0] - conveyor[1][0]) / 2\n        if p[1] < conveyor[0][1]:\n            time += (p[1] - conveyor[0][1]) / 2\n        elif p[1] > conveyor[1][1]:\n            time += (p[1] - conveyor[1][1]) / 2\n        return time\n\n    def get_min_time(A, B, conveyors):\n        min_time = 0\n        p = A\n        while p != B:\n            conveyor_time = float('inf')\n            for conveyor in conveyors:\n                time = get_conveyor_time(p, conveyor)\n                if time < conveyor_time:\n                    conveyor_time = time\n            if conveyor_time == float('inf'):\n                break\n            min_time += conveyor_time\n            p = (p[0] + 2 * conveyor_time * (1 if p[0] < B[0] else -1), p[1])\n        return min_time\n\n    X_A, Y_A, X_B, Y_B = list(map(float, stdin.splitlines()[0].split()))\n    N = int(stdin.splitlines()[1])\n    conveyors = [tuple(map(float, line.split())) for line in stdin.splitlines()[2:]]\n    A = (X_A, Y_A)\n    B = (X_B, Y_B)\n    min_time = get_min_time(A, B, conveyors)\n    return str(min_time)\n"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    X_A, Y_A, X_B, Y_B = map(float, input_data[0].split())\n    N = int(input_data[1])\n    conveyors = []\n    for _ in range(N):\n        conveyor = list(map(float, input_data[2 + _].split()))\n        conveyors.append(conveyor)\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def time(p1, p2):\n        return distance(p1, p2) / 2\n\n    def is_on_conveyor(x, y, conveyors):\n        for conveyor in conveyors:\n            if conveyor[0] < x <= conveyor[2] and conveyor[1] < y <= conveyor[3]:\n                return True\n        return False\n\n    def get_min_time(X_A, Y_A, X_B, Y_B, conveyors):\n        min_time = float('inf')\n        for x in [X_A, X_B]:\n            for y in [Y_A, Y_B]:\n                if is_on_conveyor(x, y, conveyors):\n                    min_time = min(min_time, time([x, y], [X_B, Y_B]))\n        return min_time\n\n    min_time = get_min_time(X_A, Y_A, X_B, Y_B, conveyors)\n\n    return f\"{min_time:.6f}\"\n\ninput_data = \"\"\"60.0 0.0 50.0 170.0\n3\n40.0 0.0 0.0 0.0\n5.0 20.0 5.0 170.0\n95.0 0.0 95.0 80.0\"\"\"\n\noutput_data = solution(input_data)\nprint(output_data)"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(A, B):\n        return ((A[0] - B[0]) ** 2 + (A[1] - B[1]) ** 2) ** 0.5\n\n    def time_to_cover_distance(distance: float) -> float:\n        return distance / 2\n\n    def can_walk_on_conveyor(A, B, conveyors) -> bool:\n        for conveyor in conveyors:\n            start, end = conveyor\n            if min(A[0], B[0]) <= start[0] <= max(A[0], B[0]) and min(A[1], B[1]) <= start[1] <= max(A[1], B[1]) and min(A[0], B[0]) <= end[0] <= max(A[0], B[0]) and min(A[1], B[1]) <= end[1] <= max(A[1], B[1]):\n                return True\n        return False\n\n    def min_time_to_walk(A, B, conveyors) -> float:\n        if distance(A, B) <= 2:\n            return time_to_cover_distance(distance(A, B))\n\n        conveyor_time = time_to_cover_distance(2)\n        floor_time = time_to_cover_distance(distance(A, B))\n\n        if can_walk_on_conveyor(A, B, conveyors):\n            return min(conveyor_time, floor_time)\n        else:\n            return floor_time\n\n    input_list = stdin.splitlines()\n    A = tuple(map(float, input_list[0].split()[:2]))\n    B = tuple(map(float, input_list[0].split()[2:]))\n    N = int(input_list[1])\n    conveyors = []\n    for i in range(2, 2 + N):\n        conveyor = tuple(map(float, input_list[i].split()))\n        conveyors.append((conveyor[:2], conveyor[2:]))\n\n    return f\"{min_time_to_walk(A, B, conveyors):.4f}\"\n"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def get_min_time(start, end, conveyors):\n        time = 0\n        x, y = start\n        while (x, y) != end:\n            min_dist = float('inf')\n            for conveyor in conveyors:\n                x1, y1, x2, y2 = conveyor\n                dist = manhattan_distance(x, y, x1, y1)\n                if dist < min_dist:\n                    min_dist = dist\n\n            if min_dist == float('inf'):\n                time += 1\n                x += 1\n            else:\n                time += (min_dist / 2)\n                x, y = x + (min_dist / 2), y\n\n        return time\n\n    input_lines = stdin.split('\\n')\n    start = tuple(float(x) for x in input_lines[0].split())\n    end = tuple(float(x) for x in input_lines[1].split())\n    N = int(input_lines[2])\n    conveyors = []\n    for i in range(N):\n        conveyor = tuple(float(x) for x in input_lines[i + 3].split())\n        conveyors.append(conveyor)\n\n    time = get_min_time(start, end, conveyors)\n\n    return f\"{time:.4f}\""
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    X_A, Y_A, X_B, Y_B = map(float, input_list[0].split())\n    N = int(input_list[1])\n    conveyors = []\n    for i in range(2, 2 + N):\n        X1, Y1, X2, Y2 = map(float, input_list[i].split())\n        conveyors.append(((X1, Y1), (X2, Y2)))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def get_time(p1, p2):\n        total_distance = distance(p1, p2)\n        if total_distance == 0:\n            return 0\n        time = total_distance / 2\n        conveyors_to_pass = []\n        for conveyor in conveyors:\n            start, end = conveyor\n            if p1[0] < start[0] and p1[1] < start[1]:\n                continue\n            if p2[0] < start[0] and p2[1] < start[1]:\n                continue\n            if p1[0] > end[0] and p1[1] > end[1]:\n                continue\n            if p2[0] > end[0] and p2[1] > end[1]:\n                continue\n            if p1[0] > start[0] and p1[0] < end[0] and p1[1] > start[1] and p1[1] < end[1]:\n                conveyors_to_pass.append(conveyor)\n            if p2[0] > start[0] and p2[0] < end[0] and p2[1] > start[1] and p2[1] < end[1]:\n                conveyors_to_pass.append(conveyor)\n        if len(conveyors_to_pass) == 0:\n            return time\n        else:\n            for conveyor in conveyors_to_pass:\n                start, end = conveyor\n                if start[0] == p1[0] and start[1] == p1[1] and p2[0] > end[0] and p2[1] > end[1]:\n                    time += distance(start, p2)\n                if end[0] == p2[0] and end[1] == p2[1] and p1[0] < start[0] and p1[1] < start[1]:\n                    time += distance(end, p1)\n            return time\n\n    time1 = get_time((X_A, Y_A), (X_B, Y_B))\n    time2 = get_time((X_A, Y_A), (X_B, Y_B))\n    if time1 > time2:\n        return round(time1, 10)\n    else:\n        return round(time2, 10)\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if P > N:\n        return \"IMPOSSIBLE\"\n    chars = set(range(K))\n    used_chars = set()\n    result = []\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def longest_palindromic_substring(s: str) -> str:\n        if not s:\n            return \"\"\n        max_len = 1\n        start = 0\n        for i in range(1, len(s)):\n            if is_palindrome(s[i-max_len:i+1]):\n                start = i - max_len\n                max_len += 1\n            else:\n                start += 1\n                max_len = 1\n        return s[start:start+max_len]\n\n    def check_chars(s: str) -> bool:\n        return len(set(s)) == K\n\n    def check_palindrome(s: str) -> bool:\n        return len(longest_palindromic_substring(s)) == P\n\n    def backtrack(pos: int) -> None:\n        if pos == N:\n            result.append(\"\".join(result))\n            return\n        for c in chars:\n            if c not in used_chars:\n                result.append(chr(c+97))\n                used_chars.add(c)\n                if check_chars(result) and check_palindrome(result):\n                    backtrack(pos+1)\n                used_chars.remove(c)\n                result.pop()\n\n    backtrack(0)\n\n    if result:\n        return \"\".join(result)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if N < K or K > 26 or P > N:\n        return \"IMPOSSIBLE\"\n\n    characters = set(\"abcdefghijklmnopqrstuvwxyz\")\n    if len(characters) < K:\n        return \"IMPOSSIBLE\"\n\n    palindromes = []\n    for i in range(1, P + 1):\n        palindromes.append(i)\n        palindromes.append(i)\n    palindromes.sort(reverse=True)\n\n    result = \"\"\n    for p in palindromes:\n        for c in characters:\n            if len(result) < N:\n                result += c * p\n                if len(set(result)) == K:\n                    return result\n\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if N % 2 == 1 and K % 2 == 1 and P % 2 == 1:\n        return \"IMPOSSIBLE\"\n\n    if N % 2 == 1:\n        N -= 1\n    if K % 2 == 1:\n        K -= 1\n    if P % 2 == 1:\n        P -= 1\n\n    if K % 2 == 0:\n        char_set = \"abcdefghijklmnopqrstuvwxyz\"\n    else:\n        char_set = \"bcdfghjklmnpqrstvwxyz\"\n\n    char_count = {}\n    result = \"\"\n    for _ in range(N // 2):\n        for c in char_set:\n            if c not in char_count and len(char_count) < K:\n                char_count[c] = 1\n                result += c\n            elif c in char_count and char_count[c] < P:\n                char_count[c] += 1\n                result += c\n            elif c in char_count and char_count[c] == P:\n                result += c\n\n    return result"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    # Check if K is a power of 2\n    if K & (K - 1) != 0:\n        return \"IMPOSSIBLE\"\n    \n    # Check if P is a power of 2\n    if P & (P - 1) != 0:\n        return \"IMPOSSIBLE\"\n    \n    # Generate all possible characters\n    chars = \"abcdefghijklmnopqrstuvwxyz\"\n    \n    # Check if there are enough distinct characters\n    if K > len(chars):\n        return \"IMPOSSIBLE\"\n    \n    # Check if there are enough characters to fill N\n    if N > len(chars) * K:\n        return \"IMPOSSIBLE\"\n    \n    # Generate all possible strings\n    strings = []\n    for i in range(1, N+1):\n        strings.append(\"\".join(chars[j] for j in range(i)))\n    \n    # Check if any string satisfies the requirements\n    for s in strings:\n        if len(set(s)) == K and is_palindrome(s, P):\n            return s\n    \n    return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n\n    if K > N:\n        return \"IMPOSSIBLE\"\n\n    if N % 2 == 0 and P % 2 == 0:\n        return \"IMPOSSIBLE\"\n\n    if P >= N - K:\n        return \"IMPOSSIBLE\"\n\n    result = \"\"\n    for i in range(K):\n        result += chr(97 + i)\n\n    if len(result) % 2 == 0:\n        for i in range(P // 2):\n            result = result[:i + 1] + result[-i - 2::-1]\n    else:\n        for i in range(P // 2 + 1):\n            result = result[:i + 1] + result[-i - 2::-1]\n\n    return result\n\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if P % 2 != 0 or N < P:\n        return \"IMPOSSIBLE\"\n    \n    if N < K:\n        return \"IMPOSSIBLE\"\n    \n    if K == 1:\n        return 'a' * N\n    \n    half_P = P // 2\n    result = [''] * N\n    \n    for i in range(N):\n        if i < half_P:\n            result[i] = 'a' * half_P\n        else:\n            result[i] = 'b' * half_P\n    \n    if K == 2:\n        return ''.join(result)\n    \n    for i in range(half_P, N - half_P):\n        if i % 2 == 0:\n            result[i] = 'c' * half_P\n        else:\n            result[i] = 'd' * half_P\n    \n    if K == 4:\n        return ''.join(result)\n    \n    result_set = set()\n    for i in range(len(result)):\n        for j in range(i + 1, len(result)):\n            if i % 2 == 0 and j % 2 == 0:\n                result_set.add('a' + result[i] + result[j] + 'b')\n            elif i % 2 == 1 and j % 2 == 1:\n                result_set.add('c' + result[i] + result[j] + 'd')\n    \n    if K == 8:\n        for palindrome in result_set:\n            if palindrome.count('a') == palindrome.count('b') and palindrome.count('c') == palindrome.count('d'):\n                return palindrome\n        return \"IMPOSSIBLE\"\n    \n    for palindrome in result_set:\n        if palindrome.count('a') == palindrome.count('b') and palindrome.count('c') == palindrome.count('d'):\n            return palindrome\n    \n    return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    \n    if P == N:\n        # If P is equal to N, then the length of the string is exactly P,\n        # and it has exactly K distinct characters.\n        return 'a' * P\n    \n    if K == 1:\n        # If K is 1, then the length of the string is at least P,\n        # and it has exactly K distinct characters.\n        return 'a' * P + 'b' * (N - P)\n    \n    if K == 2:\n        # If K is 2, then the length of the string is at least P + 1,\n        # and it has exactly K distinct characters.\n        return 'a' * P + 'b' * (N - 2 * P) + 'a'\n    \n    # If neither of the previous cases are true, then the problem is impossible.\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if P > N // 2:\n        return \"IMPOSSIBLE\"\n\n    alphabets = \"abcdefghijklmnopqrstuvwxyz\"\n    palindromes = [\"\".join(x) for x in itertools.product(alphabets, repeat=P)]\n\n    for palindrome in palindromes:\n        if len(set(palindrome)) == K:\n            return palindrome\n\n    return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.strip().split())\n    if K > N or P > N:\n        return \"IMPOSSIBLE\"\n    used_chars = set()\n    result = []\n    for i in range(N):\n        if len(used_chars) == K:\n            break\n        for j in range(ord('a'), ord('z') + 1):\n            if chr(j) not in used_chars and len(result) < P:\n                result.append(chr(j))\n                used_chars.add(chr(j))\n                break\n    if len(result) < P:\n        return \"IMPOSSIBLE\"\n    return ''.join(result)"
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if K > 26:\n        return \"IMPOSSIBLE\"\n    if N % 2 == 1 and P % 2 == 1:\n        return \"IMPOSSIBLE\"\n\n    chars = \"abcdefghijklmnopqrstuvwxyz\"\n    for i in range(N - K + 1, N - 1):\n        for c in itertools.combinations(chars, K):\n            s = \"\".join(c)\n            if len(s) == i:\n                if is_palindrome(s):\n                    return s\n\n    return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUY\"\n        consonants = \"BCDFGHJKLMNPQRSTVWXZ\"\n        syllables = 0\n        in_vowel = False\n        for c in word:\n            if c.isalpha():\n                if c.upper() in vowels:\n                    if not in_vowel:\n                        syllables += 1\n                        in_vowel = True\n                else:\n                    in_vowel = False\n        return syllables\n\n    lines = stdin.split(\"\\n\")\n    haiku = []\n    for line in lines:\n        words = line.split(\" \")\n        if len(words) == 3:\n            lines = [words[0], words[1], words[2]]\n        elif len(words) == 2:\n            lines = [words[0], \"\", words[1]]\n        else:\n            lines = [line]\n\n        for i in range(3):\n            line = lines[i]\n            syllables = count_syllables(line)\n            if syllables == 5:\n                if i == 0:\n                    haiku.append(line)\n                elif i == 1:\n                    haiku.append(line)\n                else:\n                    haiku.append(line)\n                break\n\n    if len(haiku) == 3:\n        return \"\\n\".join(haiku)\n    else:\n        return stdin\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUY\"\n        num_syllables = 0\n        last_char_was_vowel = False\n\n        for char in word:\n            if char.isalpha():\n                if char.upper() in vowels:\n                    if not last_char_was_vowel:\n                        num_syllables += 1\n                    last_char_was_vowel = True\n                else:\n                    last_char_was_vowel = False\n\n        return num_syllables\n\n    def divide_words(words: list) -> list:\n        haiku = [[] for _ in range(3)]\n        current_line = 0\n        current_line_syllable_count = 0\n\n        for word in words:\n            num_syllables = count_syllables(word)\n\n            if current_line_syllable_count + num_syllables > 7:\n                current_line += 1\n                current_line_syllable_count = 0\n\n            haiku[current_line].append(word)\n            current_line_syllable_count += num_syllables\n\n        return haiku\n\n    def format_output(haiku: list) -> str:\n        output = []\n\n        for line in haiku:\n            output.append(\" \".join(line))\n\n        return \"\\n\".join(output)\n\n    words = stdin.split()\n    haiku = divide_words(words)\n\n    if any(len(line) == 0 for line in haiku):\n        return \"\\n\".join(words)\n    else:\n        return format_output(haiku)"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        syllables = 0\n        prev_consonant = False\n        word = word.lower()\n        for i, char in enumerate(word):\n            if char in \"aeiouy\":\n                if i > 0 and word[i - 1] == \"q\":\n                    continue\n                if prev_consonant:\n                    syllables += 1\n                    prev_consonant = False\n            elif char == \"y\":\n                if i == 0 or word[i - 1] not in \"aeiou\":\n                    prev_consonant = True\n            else:\n                prev_consonant = True\n        if prev_consonant:\n            syllables += 1\n        return syllables\n\n    def partition_words(words: list[str]) -> tuple[list[str], list[str], list[str]]:\n        lines = [[] for _ in range(3)]\n        max_syllables = [0] * 3\n        current_line = 0\n        for word in words:\n            syllables = count_syllables(word)\n            if current_line == 0:\n                max_syllables[current_line] = max(syllables, max_syllables[current_line])\n                lines[current_line].append(word)\n            elif current_line == 1:\n                max_syllables[current_line] = max(syllables, max_syllables[current_line])\n                if max_syllables[current_line] + max_syllables[current_line - 1] <= 7:\n                    lines[current_line].append(word)\n                else:\n                    current_line = 2\n                    max_syllables[current_line] = max(syllables, max_syllables[current_line])\n                    lines[current_line].append(word)\n            else:\n                lines[current_line].append(word)\n                if max_syllables[current_line] + max_syllables[current_line - 1] <= 7:\n                    current_line = 0\n        return lines\n\n    words = stdin.split()\n    lines = partition_words(words)\n    haiku = \"\\n\".join([\" \".join(line) for line in lines])\n    return haiku"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUYaeiouy\"\n        syllables = 0\n        start = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                if i == len(word) - 1 or word[i + 1] not in vowels:\n                    syllables += 1\n            elif word[i - 1] not in vowels:\n                start = i\n            elif i > 1 and word[i - 2] not in vowels:\n                syllables += 1\n        if word[-1] not in vowels and len(word) > 2 and word[-2] in vowels:\n            syllables += 1\n        return syllables\n\n    def divide_words(words: list[str]) -> list[str]:\n        haiku = [\"\", \"\", \"\"]\n        current_line = 0\n        for word in words:\n            syllables = count_syllables(word)\n            if current_line == 0 and syllables <= 4:\n                haiku[0] += word\n            elif current_line == 1 and syllables == 7:\n                haiku[1] += word\n            elif current_line == 2 and syllables <= 4:\n                haiku[2] += word\n            else:\n                return []\n            if word[-1] not in \".,!?:;\":\n                haiku[current_line] += \" \"\n            current_line = (current_line + 1) % 3\n        return haiku\n\n    lines = stdin.split(\" \")\n    haiku = divide_words(lines)\n    if haiku:\n        haiku = [line.strip() for line in haiku]\n        return haiku\n    return lines\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.split()\n    haiku = []\n    lines = []\n    \n    for i, word in enumerate(words):\n        if len(haiku) < 3:\n            haiku.append(word)\n            if i % 2 == 1 and len(haiku) == 2:\n                lines.append(' '.join(haiku))\n                haiku = []\n        else:\n            lines.append(stdin.strip())\n            break\n    \n    if len(haiku) == 2:\n        lines.append(' '.join(haiku))\n    \n    return '\\n'.join(line.strip() for line in lines)\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n        syllables = 0\n        in_vowel_sequence = False\n        for i in range(len(word)):\n            if word[i].isalpha():\n                if word[i].upper() in vowels:\n                    in_vowel_sequence = True\n                    if i > 0 and word[i - 1].isalpha() and word[i - 1].upper() not in vowels and word[i].upper() != 'Y':\n                        syllables += 1\n                else:\n                    if in_vowel_sequence:\n                        syllables += 1\n                    in_vowel_sequence = False\n            else:\n                in_vowel_sequence = False\n        if in_vowel_sequence:\n            syllables += 1\n        return syllables\n\n    lines = stdin.split('. ')\n    haiku = []\n    for line in lines:\n        words = line.split()\n        if len(words) > 0:\n            syllables = 0\n            haiku_line = ''\n            for word in words:\n                word_syllables = count_syllables(word)\n                if syllables + word_syllables <= 7:\n                    haiku_line += word\n                    haiku_line += ' '\n                    syllables += word_syllables\n                else:\n                    haiku.append(haiku_line.strip())\n                    haiku.append(word)\n                    haiku.append('')\n                    syllables = 1\n            haiku.append(haiku_line.strip())\n        else:\n            haiku.append(line)\n\n    if len(haiku) == 1:\n        return haiku[0]\n    else:\n        return '\\n'.join(haiku)\n\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    words = stdin.strip().split()\n    haiku = []\n\n    def count_syllables(word: str) -> int:\n        syllables = 0\n        vowels = 'AEIOUY'\n        prev_char_cons = False\n        for i, char in enumerate(word):\n            if char.isalpha() and char.upper() in vowels:\n                if i == 0 or not prev_char_cons:\n                    syllables += 1\n                prev_char_cons = False\n            else:\n                prev_char_cons = char.isalpha()\n        return syllables\n\n    for i, word in enumerate(words):\n        syllables = count_syllables(word)\n        if syllables == 5:\n            if len(haiku) == 0 or count_syllables(haiku[-1]) == 7:\n                haiku.append(word)\n            else:\n                haiku[-1] += f' {word}'\n        elif syllables == 7:\n            if haiku[-1].endswith('.'):\n                haiku[-1] = haiku[-1].rstrip('.')\n            haiku[-1] += f' {word}'\n        else:\n            if len(haiku) == 0:\n                haiku.append(word)\n            else:\n                haiku[-1] += f' {word}'\n\n    if len(haiku) == 3:\n        return '\\n'.join(haiku)\n    else:\n        return stdin\n\n\ninput_text = \"Blue Ridge mountain road. Leaves, glowing in autumn sun, fall in Virginia.\"\noutput = solution(input_text)\nprint(output)"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to count syllables in a word\n    def count_syllables(word: str) -> int:\n        count = 0\n        last_char_was_vowel = False\n        for char in word:\n            if char.isalpha():\n                if char.lower() in 'aeiouy':\n                    if not last_char_was_vowel:\n                        count += 1\n                        last_char_was_vowel = True\n                else:\n                    last_char_was_vowel = False\n        return count\n\n    # Split the input line into words\n    words = stdin.split()\n\n    # Initialize the haiku lines with empty strings\n    haiku_lines = ['', '', '']\n\n    # Iterate through the words and try to fit them into the haiku lines\n    for i, word in enumerate(words):\n        # Check if the word can be split into a haiku\n        syllables = count_syllables(word)\n        if syllables == 5:\n            # Try to fit the word into the first line\n            if len(haiku_lines[0]) + len(words[i - 1]) + len(word) + 1 <= 17:\n                haiku_lines[0] += words[i - 1] + ' ' + word + ' '\n            else:\n                haiku_lines[1] += words[i - 1] + ' ' + word + ' '\n        elif syllables == 7:\n            # Try to fit the word into the second line\n            if len(haiku_lines[1]) + len(words[i - 1]) + len(word) + 1 <= 17:\n                haiku_lines[1] += words[i - 1] + ' ' + word + ' '\n            else:\n                haiku_lines[2] += words[i - 1] + ' ' + word + ' '\n        else:\n            # Try to fit the word into the third line\n            if len(haiku_lines[2]) + len(words[i - 1]) + len(word) + 1 <= 17:\n                haiku_lines[2] += words[i - 1] + ' ' + word + ' '\n            else:\n                # If the word cannot be split across multiple lines, return the input line\n                return stdin\n\n    # Remove any extra spaces at the end of each line\n    haiku_lines = [line.rstrip() for line in haiku_lines]\n\n    # Return the haiku lines\n    return '\\n'.join(haiku_lines)"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        count = 0\n        i = 0\n        while i < len(word):\n            if word[i].isalpha():\n                if i < len(word) - 1 and word[i + 1] == 'Y':\n                    count += 1\n                    i += 1\n                elif i < len(word) - 1 and word[i + 1] == 'E' and word[i - 1].isalpha() and word[i - 2] != 'L':\n                    count += 1\n                    i += 1\n                else:\n                    count += 1\n            elif word[i] == 'Q' and i < len(word) - 1 and word[i + 1] == 'U':\n                count += 1\n                i += 1\n            i += 1\n        return count\n\n    def divide_into_lines(words: List[str], syllables: int) -> List[str]:\n        lines = [[]]\n        line_syllables = 0\n        for word in words:\n            word_syllables = count_syllables(word)\n            if line_syllables + word_syllables <= syllables:\n                lines[-1].append(word)\n                line_syllables += word_syllables\n            else:\n                lines.append([word])\n                line_syllables = word_syllables\n        return [' '.join(line) for line in lines]\n\n    words = stdin.split()\n    if len(words) == 1:\n        return words[0]\n\n    first_line_syllables = count_syllables(words[0])\n    third_line_syllables = count_syllables(words[-1])\n    middle_line_syllables = 7 - first_line_syllables - third_line_syllables\n\n    lines = divide_into_lines(words[1:-1], middle_line_syllables)\n    lines.insert(0, words[0])\n    lines.append(words[-1])\n\n    return '\\n'.join(lines)\n\ndef"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = \"AEIOUY\"\n        syllables = 0\n        last_vowel = None\n\n        for char in word:\n            if char.isalpha() and char.upper() in vowels:\n                if last_vowel and char.upper() == \"U\" and last_vowel.upper() == \"Q\":\n                    continue\n                else:\n                    syllables += 1\n            last_vowel = char\n\n        if word[-1].isalpha() and syllables > 0 and word[-1].upper() in vowels:\n            syllables -= 1\n\n        return syllables\n\n    def split_words(text: str, max_chars: int) -> str:\n        words = text.split()\n        haiku_lines = []\n        line = \"\"\n        for word in words:\n            if len(line) + len(word) + len(line.split()) <= max_chars:\n                line += \" \" + word if line else word\n            else:\n                haiku_lines.append(line.strip())\n                line = word\n\n        haiku_lines.append(line.strip())\n\n        return haiku_lines\n\n    haiku_words = split_words(stdin, 17)\n    haiku_lines = []\n    for word in haiku_words:\n        haiku_lines.append(\" \".join(word))\n\n    haiku = \"\\n\".join(haiku_lines)\n    if len(haiku_lines) == 3 and len(haiku_lines[0].split()) == 5 and len(haiku_lines[1].split()) == 7 and len(haiku_lines[2].split()) == 5:\n        return haiku\n    else:\n        return stdin\n\n\ndef"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    names = stdin.splitlines()[1:]\n    \n    # find first person with ThoreHusfeldt as a prefix\n    for i, name in enumerate(names):\n        if name.startswith(\"ThoreHusfeldt\"):\n            break\n    else:\n        return \"Thore is awesome\"\n    \n    # check if there is another Thore above ThoreHusfeldt\n    for j in range(i):\n        if names[j].startswith(\"Thore\"):\n            return \"Thore sucks\"\n    \n    # find smallest prefix that uniquely determines Thore\n    for i in range(len(\"ThoreHusfeldt\"), 0, -1):\n        prefix = \"ThoreHusfeldt\"[:i]\n        found = False\n        for name in names:\n            if name.startswith(prefix):\n                found = True\n                break\n        if not found:\n            return prefix\n    \n    return \"ThoreHusfeldt\""
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    stdin_list = stdin.split(\"\\n\")[1:]\n    thore_index = stdin_list.index(\"ThoreHusfeldt\")\n\n    # Find the prefix that is unique to Thore\n    prefix_set = set()\n    for name in stdin_list:\n        prefix = name[:len(stdin_list[thore_index])]\n        prefix_set.add(prefix)\n\n    prefix = \"\"\n    for char in stdin_list[thore_index]:\n        if prefix_set.issuperset(prefix + char):\n            prefix += char\n        else:\n            break\n\n    # Check if Thore is the best\n    if thore_index == 0:\n        return \"Thore is awesome\"\n\n    # Check if there is another ThoreH above Thore\n    for i in range(thore_index):\n        if \"ThoreHusfeldt\" in stdin_list[i]:\n            return \"Thore sucks\"\n\n    return prefix\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_prefix(names: list, prefix: str) -> bool:\n        for name in names:\n            if name.startswith(prefix):\n                return True\n        return False\n\n    n = int(stdin.splitlines()[0])\n    names = [line.strip() for line in stdin.splitlines()[1:]]\n    thore_name = \"ThoreHusfeldt\"\n\n    for i in range(len(thore_name) - 1, 0, -1):\n        prefix = thore_name[:i]\n        if not find_prefix(names, prefix):\n            break\n\n    if i == len(thore_name) - 1:\n        return \"Thore is awesome\"\n    elif find_prefix(names, thore_name):\n        return \"Thore sucks\"\n    else:\n        return prefix\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_prefix(name1: str, name2: str) -> bool:\n        return name1 == name2[:len(name1)]\n\n    n = int(stdin.splitlines()[0])\n    other_names = stdin.splitlines()[1:]\n    thore_husfeldt = \"ThoreHusfeldt\"\n\n    for name in other_names:\n        if is_prefix(name, thore_husfeldt):\n            if name != thore_husfeldt:\n                return f\"ThoreH is awesome\"\n\n    for name in other_names:\n        if is_prefix(name, thore_husfeldt[:-1]):\n            return thore_husfeldt[:-1]\n\n    return thore_husfeldt\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n', 1)[0])\n    names = stdin.split('\\n', n)[1:]\n    thore_husfeldt_found = False\n    thore_husfeldt_prefix = \"\"\n    thore_husfeld_found = False\n    \n    for i, name in enumerate(names):\n        if name == \"ThoreHusfeldt\":\n            thore_husfeldt_found = True\n            thore_husfeldt_prefix = name[:i]\n        elif \"ThoreHusfeld\" in name:\n            thore_husfeld_found = True\n            break\n    \n    if thore_husfeldt_found:\n        if thore_husfeld_found:\n            return \"Thore sucks\"\n        else:\n            return thore_husfeldt_prefix\n    else:\n        return \"ThoreH\""
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    scores = stdin.splitlines()[1:]\n\n    best_thoreh = \"ThoreHusfeldt\"\n\n    for score in scores:\n        if score.startswith(\"ThoreHusfeldt\"):\n            best_thoreh = score\n            break\n\n    for score in scores:\n        if score.startswith(\"ThoreHusfeldt\") and score != best_thoreh:\n            return \"Thore sucks\"\n\n    for score in scores:\n        if score.startswith(best_thoreh[:len(best_thoreh) - 1]) and score != best_thoreh:\n            return f\"{best_thoreh[:len(best_thoreh) - 1]} is awesome\"\n\n    return \"Thore is awesome\"\n"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_prefix_unique(prefix: str, names: List[str]) -> bool:\n        for name in names:\n            if name.startswith(prefix):\n                return False\n        return True\n\n    n = int(stdin.splitlines()[0])\n    names = stdin.splitlines()[1:]\n    thore_name = \"ThoreHusfeldt\"\n    thore_prefix = \"\"\n    found_prefix = False\n\n    for i in range(1, len(thore_name) + 1):\n        prefix = thore_name[:i]\n        if is_prefix_unique(prefix, names):\n            thore_prefix = prefix\n            found_prefix = True\n\n    if found_prefix:\n        if thore_prefix == \"ThoreH\":\n            return \"Thore is awesome\"\n        else:\n            return thore_prefix\n    else:\n        return \"Thore sucks\""
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    scoreboard = stdin.split(\"\\n\")[1:]\n    thore_pos = scoreboard.index(\"ThoreHusfeldt\")\n    \n    if thore_pos == 0:\n        return \"Thore is awesome\"\n    else:\n        prev_thore = scoreboard[thore_pos - 1]\n        if \"ThoreHusfeldt\" in prev_thore:\n            return \"Thore sucks\"\n        else:\n            prefix = \"\"\n            for c1, c2 in zip(prev_thore, \"ThoreHusfeldt\"):\n                if c1 == c2:\n                    prefix += c1\n                else:\n                    break\n            return prefix"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    names = stdin.splitlines()[1:]\n    thore = \"ThoreHusfeldt\"\n    for name in names:\n        if name.startswith(thore) and name != thore:\n            return \"Thore sucks\"\n    for name in names:\n        if name.startswith(thore) and name != thore and name.startswith(thore.lower()):\n            return \"Thore is awesome\"\n    for i in range(1, len(thore)):\n        for j in range(i):\n            if names[i].startswith(thore[:i]) and names[j].startswith(thore[:j]):\n                return thore[:j]\n    return \"ThoreH\""
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    scoreboard = stdin.splitlines()[1:]\n    scoreboard.sort()\n    for i, name in enumerate(scoreboard):\n        if \"ThoreHusfeldt\" in name:\n            if i == 0:\n                return \"Thore is awesome\"\n            elif \"ThoreHusfeld\" in scoreboard[i-1]:\n                return \"Thore sucks\"\n            else:\n                return name.split(\"ThoreHusfeldt\")[0] + \"ThoreHusfeldt\"\n\ndef"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def evaluate_walk(walk: str) -> int:\n        node = 1\n        for move in walk:\n            if move == 'L':\n                node *= 2\n            elif move == 'R':\n                node = (node * 2) + 1\n            else:\n                continue\n        return node\n\n    def evaluate_set(set: str) -> int:\n        return sum(evaluate_walk(walk) for walk in possible_walks(set))\n\n    def possible_walks(set: str) -> List[str]:\n        if '*' not in set:\n            return [set]\n        else:\n            index = set.index('*')\n            left_walk = set[:index] + 'L' + set[index + 1:]\n            right_walk = set[:index] + 'R' + set[index + 1:]\n            return possible_walks(left_walk) + possible_walks(right_walk)\n\n    return str(evaluate_set(stdin))\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize the root of the binary tree\n    root = Node(1)\n\n    def helper(node: Node, moves: str) -> int:\n        if not moves:\n            return node.value\n\n        move = moves[0]\n        if move == \"L\":\n            return helper(node.left, moves[1:])\n        elif move == \"R\":\n            return helper(node.right, moves[1:])\n        elif move == \"P\":\n            return node.value\n        else:\n            return 0\n\n    def count_walks(node: Node, depth: int) -> int:\n        if depth == 0:\n            return 1\n\n        left_count = count_walks(node.left, depth - 1)\n        right_count = count_walks(node.right, depth - 1)\n        pause_count = count_walks(node, depth - 1)\n\n        return left_count + right_count + pause_count\n\n    def count_total_walks(node: Node, depth: int, moves: str) -> int:\n        if not moves:\n            return 1\n\n        left_count = count_total_walks(node.left, depth + 1, moves[1:])\n        right_count = count_total_walks(node.right, depth + 1, moves[1:])\n\n        if moves[0] == \"L\":\n            return left_count\n        elif moves[0] == \"R\":\n            return right_count\n        elif moves[0] == \"P\":\n            return count_total_walks(node, depth, moves[1:])\n        else:\n            return 0\n\n    def count_sets(node: Node, depth: int, moves: str, set_count: int) -> int:\n        if not moves:\n            return set_count\n\n        left_count = count_sets(node.left, depth + 1, moves[1:], set_count)\n        right_count = count_sets(node.right, depth + 1, moves[1:], set_count)\n\n        if moves[0] == \"*\":\n            return left_count + right_count + set_count\n        elif moves[0] == \"L\":\n            return left_count\n        elif moves[0] == \"R\":\n            return right_count\n        elif moves[0] == \"P\":\n            return set_count\n        else:\n            return 0\n\n    # Build the tree using the input string\n    depth = 0\n    moves = stdin.replace(\" \", \"\").replace(\"L\", \"L\").replace(\"R\", \"R\").replace(\"P\", \"P\")\n    for move in moves:\n        if move in [\"L\", \"R\", \"P\"]:\n            depth += 1\n        else:\n            break\n\n    if depth == 0:\n        return 0\n\n    for move in moves[:depth]:\n        node = node.left if move == \"L\" else node.right\n\n    # Calculate the total value of the set of walks\n    total_value = count_total_walks(root, 0, moves)\n\n    # Calculate the value of the set of walks\n    set_value = count_sets(root, 0, moves, 1)\n\n    return total_value * set_value\n\nclass Node:\n    def __init__(self, value: int, left=None, right=None):\n        self.value = value\n        self.left = left\n        self.right = right"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(node: int, move: str) -> int:\n        if move == 'L':\n            return 2 * node\n        elif move == 'R':\n            return 2 * node + 1\n        else:\n            return node\n\n    def dfs(node: int, move_str: str) -> int:\n        if not move_str:\n            return node\n        move = move_str[0]\n        move_str = move_str[1:]\n        left_val = dfs(get_value(node, move), move_str)\n        if not move_str:\n            return left_val\n        move = move_str[0]\n        move_str = move_str[1:]\n        right_val = dfs(get_value(node, move), move_str)\n        return left_val + right_val\n\n    root_value = dfs(1, stdin)\n    return root_value"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_value(node: int, move: str) -> int:\n        if move == 'L':\n            return 2 * node\n        elif move == 'R':\n            return 2 * node + 1\n        else:\n            return node\n\n    def walk_value(node: int, moves: str) -> int:\n        if not moves:\n            return node\n        move = moves[0]\n        if move == '*':\n            left_value = walk_value(calculate_value(node, 'L'), moves[1:])\n            right_value = walk_value(calculate_value(node, 'R'), moves[1:])\n            return left_value + right_value\n        else:\n            return walk_value(calculate_value(node, move), moves[1:])\n\n    moves = stdin.split()\n    return str(walk_value(1, moves))\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(node, move):\n        if move == 'L':\n            return 2 * node\n        elif move == 'R':\n            return 2 * node + 1\n        else:\n            return node\n\n    def traverse(node, moves):\n        if not moves:\n            return node\n        move = moves[0]\n        if move == '*':\n            return max(traverse(node, moves[1:]), traverse(get_value(node, 'L'), moves[1:]), traverse(get_value(node, 'R'), moves[1:]))\n        else:\n            return traverse(get_value(node, move), moves[1:])\n\n    return traverse(1, list(stdin))"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def tree_value(node: int, index: int) -> int:\n        if index == len(stdin) or stdin[index] == 'P':\n            return node\n        elif stdin[index] == 'L':\n            return tree_value(2 * node, index + 1)\n        elif stdin[index] == 'R':\n            return tree_value(2 * node + 1, index + 1)\n        else:\n            return -1\n\n    return tree_value(1, 0)\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(node: int, moves: str) -> int:\n        if not moves:\n            return node\n        if moves[0] == 'L':\n            return get_value(2 * node, moves[1:])\n        elif moves[0] == 'R':\n            return get_value(2 * node + 1, moves[1:])\n        else:  # moves[0] == 'P'\n            return get_value(node, moves[1:])\n\n    def get_walks(node: int, moves: str) -> list[int]:\n        if not moves:\n            return [node]\n        if moves[0] == 'L':\n            return [node] + get_walks(2 * node, moves[1:])\n        elif moves[0] == 'R':\n            return [node] + get_walks(2 * node + 1, moves[1:])\n        else:  # moves[0] == 'P'\n            return get_walks(node, moves[1:])\n\n    def process_set(moves: str) -> int:\n        moves = moves.replace('*', 'LP')\n        return sum(get_value(1, walk) for walk in get_walks(1, moves))\n\n    return str(process_set(stdin))\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(node_label, move):\n        if move == \"L\":\n            return 2 * node_label\n        elif move == \"R\":\n            return (2 * node_label) + 1\n        else:\n            return node_label\n\n    def walk_value(node_label, walk):\n        node_label = int(node_label)\n        walk_value = node_label\n        for move in walk:\n            if move == \"L\":\n                left_child_label = str(2 * node_label)\n                node_label = left_child_label\n            elif move == \"R\":\n                right_child_label = str(2 * node_label + 1)\n                node_label = right_child_label\n            else:\n                pass\n            walk_value = get_value(node_label, move)\n        return walk_value\n\n    def calculate_set_value(stdin):\n        set_value = 0\n        for i in range(len(stdin)):\n            if stdin[i] == \"*\":\n                continue\n            else:\n                node_label = \"1\"\n                walk = \"\"\n                for j in range(i, len(stdin)):\n                    if stdin[j] == \"*\":\n                        break\n                    else:\n                        walk += stdin[j]\n                set_value += walk_value(node_label, walk)\n        return set_value\n\n    return str(calculate_set_value(stdin))\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_node(node, value):\n        if node.value == value:\n            return node\n        if value < node.value:\n            return find_node(node.left, value)\n        else:\n            return find_node(node.right, value)\n\n    class Node:\n        def __init__(self, value, left=None, right=None):\n            self.value = value\n            self.left = left\n            self.right = right\n\n    root = Node(1)\n    nodes = {1: root}\n\n    def add_node(parent, value):\n        new_node = Node(value)\n        parent.left = new_node\n        nodes[value] = new_node\n\n    def walk_node(node, moves):\n        if not moves:\n            return node.value\n        if moves[0] == 'L':\n            return walk_node(node.left, moves[1:])\n        elif moves[0] == 'R':\n            return walk_node(node.right, moves[1:])\n        else:\n            return node.value\n\n    def value_of_set(set_str: str) -> int:\n        def find_moves(node, moves):\n            if not moves:\n                return node.value\n            if moves[0] == 'L':\n                return find_moves(node.left, moves[1:])\n            elif moves[0] == 'R':\n                return find_moves(node.right, moves[1:])\n            else:\n                return node.value\n\n        moves = set_str.replace('*', 'LPR')\n        value = 0\n        for move in moves:\n            if move in ['L', 'R', 'P']:\n                value += find_node(root, find_moves(root, move)).value\n            else:\n                value += find_node(root, find_moves(root, move)).value\n                value += find_node(root, find_moves(root, move)).value\n        return value\n\n    return value_of_set(stdin)\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def build_tree(node: int, parent: int, depth: int, tree: list):\n        if node > len(stdin):\n            return\n        left = 2 * parent + 1\n        right = left + 1\n        tree.append((node, left, right))\n        build_tree(left, left, depth + 1, tree)\n        build_tree(right, right, depth + 1, tree)\n\n    def evaluate_walk(node: int, tree: list) -> int:\n        if node == 1:\n            return 1\n        left, right = tree[node - 1][1:3]\n        if stdin[node - 1] == 'L':\n            return evaluate_walk(left, tree)\n        elif stdin[node - 1] == 'R':\n            return evaluate_walk(right, tree)\n        else:\n            return evaluate_walk(node, tree)\n\n    tree = []\n    build_tree(1, 0, 0, tree)\n    walk_value = evaluate_walk(1, tree)\n    return walk_value\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to check if two words rhyme\n    def rhyme(word1, word2):\n        min_len = min(len(word1), len(word2))\n        return word1[-min_len:] == word2[-min_len:]\n\n    # Read input\n    N = int(stdin)\n    statements = []\n    for _ in range(N):\n        statements.append(stdin.readline().strip().split())\n\n    # Check if statements are consistent with each other\n    def check_consistency(statements):\n        words = set()\n        for statement in statements:\n            words.add(statement[0])\n            words.add(statement[2])\n\n        for word1 in words:\n            for word2 in words:\n                if word1 != word2 and rhyme(word1, word2):\n                    return False\n\n        return True\n\n    if check_consistency(statements):\n        return \"yes\"\n    else:\n        return \"wait what?\"\n\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme(word1: str, word2: str) -> bool:\n        last_characters = min(3, len(word1), len(word2))\n        return word1[-last_characters:] == word2[-last_characters:]\n\n    statements = [line.strip().split() for line in stdin.split('\\n')[1:]]\n    words = [word.lower() for line in statements for word in line[1:]]\n\n    if len(set(words)) < len(words):\n        return \"wait what?\"\n\n    for statement in statements:\n        word1, word2 = statement[1].lower(), statement[2].lower()\n\n        if word1 not in words or word2 not in words:\n            return \"wait what?\"\n\n        if (statement[0] == 'is' and not rhyme(word1, word2)) or (statement[0] == 'not' and rhyme(word1, word2)):\n            return \"wait what?\"\n\n    return \"yes\"\n\n\ndef"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    statements = stdin.split('\\n')[1:]\n\n    def is_rhyming(a: str, b: str) -> bool:\n        return a[-min(3, len(a), len(b)):].lower() == b[-min(3, len(a), len(b)):].lower()\n\n    def is_same(a: str, b: str) -> bool:\n        return a.lower() == b.lower()\n\n    def check_consistency(statements: List[str]) -> bool:\n        words = set()\n        for statement in statements:\n            words.add(statement.split()[0].lower())\n            words.add(statement.split()[2].lower())\n        for word in words:\n            if not any(is_rhyming(word, other) for other in words):\n                return False\n        for i in range(len(statements)):\n            words_1 = statements[i].split()\n            words_2 = statements[i].split()\n            if words_1[0] != words_2[2] or words_1[2] != words_2[0]:\n                return False\n            for j in range(i + 1, len(statements)):\n                words_3 = statements[j].split()\n                if is_same(words_1[0], words_3[0]) or is_same(words_1[2], words_3[2]):\n                    return False\n        return True\n\n    return \"yes\" if check_consistency(statements) else \"wait what?\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    statements = {}\n    for i in range(1, N+1):\n        statement = stdin.split(\"\\n\")[i].split(\" is \")\n        if len(statement) != 2:\n            return \"wait what?\"\n        X, Y = statement\n        X = X.strip()\n        Y = Y.strip()\n        if X not in statements:\n            statements[X] = set()\n        statements[X].add(Y)\n        if Y not in statements:\n            statements[Y] = set()\n        statements[Y].add(X)\n\n    for X in statements:\n        if X not in statements[X]:\n            return \"wait what?\"\n        for Y in statements[X]:\n            if X not in statements[Y]:\n                return \"wait what?\"\n\n    for X in statements:\n        for Y in statements:\n            if X != Y and X in statements[Y] and Y in statements[X]:\n                return \"wait what?\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    statements = []\n    for statement in input_list[1:]:\n        words = statement.split(\" \")\n        statements.append([words[0], \"not \" + words[1] if words[1] == \"is\" else words[1]])\n\n    def find_common_prefix(word1: str, word2: str) -> str:\n        min_length = min(len(word1), len(word2))\n        for i in range(min_length):\n            if word1[i] != word2[i]:\n                return word1[:i]\n        return word1[:min_length]\n\n    def is_rhyming(word1: str, word2: str) -> bool:\n        common_prefix = find_common_prefix(word1, word2)\n        return len(common_prefix) >= 3\n\n    def check_consistency(statements: list) -> str:\n        unique_words = set()\n        for statement in statements:\n            unique_words.add(statement[0])\n            unique_words.add(statement[1])\n\n        for word in unique_words:\n            if not word.isalpha():\n                return \"wait what?\"\n\n        for i in range(len(statements)):\n            for j in range(i + 1, len(statements)):\n                if statements[i][0] == statements[j][0] or statements[i][1] == statements[j][1]:\n                    if is_rhyming(statements[i][0], statements[j][0]) and is_rhyming(statements[i][1], statements[j][1]):\n                        continue\n                    else:\n                        return \"wait what?\"\n        return \"yes\"\n\n    result = check_consistency(statements)\n    return result"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme(word1: str, word2: str) -> bool:\n        min_length = min(len(word1), len(word2))\n        return word1[-min_length:] == word2[-min_length:]\n\n    def marten_theorem(word1: str, word2: str) -> bool:\n        return rhyme(word1, word2)\n\n    def is_consistent(statements: list) -> bool:\n        words = set()\n        for statement in statements:\n            words.update(statement.split())\n\n        for i in range(len(statements)):\n            for j in range(i + 1, len(statements)):\n                words1 = statements[i].split()\n                words2 = statements[j].split()\n                for word1 in words1:\n                    for word2 in words2:\n                        if word1 != word2 and (word1 in words and word2 in words):\n                            if marten_theorem(word1, word2) or (words1.count(word1) == words2.count(word2)):\n                                return False\n        return True\n\n    input_list = stdin.strip().split('\\n')\n    statements = input_list[1:]\n    if is_consistent(statements):\n        return \"yes\"\n    else:\n        return \"wait what?\"\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    statements = [s.strip() for s in stdin.split('\\n')[1:]]\n    words = set()\n\n    def rhyme(x, y):\n        if len(x) < len(y):\n            x, y = y, x\n        return x[-min(3, len(x), len(y)):].lower() == y[-min(3, len(x), len(y)):].lower()\n\n    for statement in statements:\n        x, y = statement.split()\n        words.add(x.lower())\n        words.add(y.lower())\n\n        if x.lower() not in words:\n            continue\n\n        if statement.startswith('not'):\n            if x.lower() == y.lower():\n                return 'wait what?'\n        else:\n            if not rhyme(x, y):\n                return 'wait what?'\n\n    return 'yes'\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    statements = stdin.split('\\n')[1:]\n\n    def rhyme(word1: str, word2: str) -> bool:\n        return word1[-min(3, len(word1), len(word2)):].lower() == word2[-min(3, len(word1), len(word2)):].lower()\n\n    def is_consistent(word1: str, word2: str, statements: list[str]) -> bool:\n        return word1.lower() == word2.lower() or any(word1.lower() == statement.split()[0].lower() and word2.lower() == statement.split()[2].lower() for statement in statements)\n\n    def is_rhyming(word1: str, word2: str) -> bool:\n        return any(rhyme(word1, word) or rhyme(word2, word) for word in words)\n\n    words = set(statement.split()[0].lower() for statement in statements)\n    words.update(statement.split()[2].lower() for statement in statements)\n    words = set(word for word in words if any(len(word) == len(word1) and word[-3:].lower() == word1[-3:].lower() for word1 in words))\n\n    for i in range(n):\n        statement1, statement2 = statements[i].split()\n        word1, word2 = statement1.lower(), statement2.lower()\n        if not is_consistent(word1, word2, statements[:i] + statements[i+1:]):\n            return \"wait what?\"\n\n    for word1 in words:\n        for word2 in words:\n            if not is_consistent(word1, word2, statements) and not is_rhyming(word1, word2):\n                return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_rhyming(word1: str, word2: str) -> bool:\n        min_len = min(len(word1), len(word2))\n        return word1[-min_len:] == word2[-min_len:]\n\n    def is_consistent(word1: str, word2: str, statements: set[str]) -> bool:\n        for statement in statements:\n            statement_words = statement.split()\n            if len(statement_words) == 2:\n                if statement_words[0] == word1 and statement_words[1] == word2:\n                    return True\n                if statement_words[0] == word2 and statement_words[1] == word1:\n                    return True\n            if is_rhyming(word1, statement_words[0]) and is_rhyming(word2, statement_words[1]):\n                return False\n        return True\n\n    N, *statements = stdin.split(\"\\n\")\n    statements = set(statements)\n\n    for i in range(len(statements)):\n        if not is_consistent(statements[i], statements[i+1], statements):\n            return \"wait what?\"\n\n    return \"yes\""
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_rhyming(X: str, Y: str) -> bool:\n        return X[-min(3, len(X), len(Y)):].lower() == Y[-min(3, len(X), len(Y)):].lower()\n\n    def is_consistent(X: str, Y: str, statements: set[str]) -> bool:\n        if X == Y:\n            return True\n        if X not in statements:\n            statements.add(X)\n            for word in statements:\n                if word == Y:\n                    return True\n                if is_rhyming(X, word) and is_consistent(Y, word, statements):\n                    return True\n        return False\n\n    N = int(stdin.splitlines()[0])\n    statements = set()\n    for line in stdin.splitlines()[1:]:\n        X, Y = line.split()\n        if is_consistent(X, Y, statements):\n            return \"wait what?\"\n    return \"yes\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    if n == 1:\n        return \"impossible\"\n    current_species = input_data[1]\n    fossil_sequences = input_data[2:]\n    unique_sequences = set(fossil_sequences)\n    if len(unique_sequences) <= n:\n        return \"impossible\"\n    first_path_sequences = [s for s in unique_sequences if s.count(current_species[0]) == 1]\n    second_path_sequences = [s for s in unique_sequences if s.count(current_species[0]) == 0]\n    if len(first_path_sequences) + len(second_path_sequences) <= n:\n        return \"impossible\"\n    return str(len(first_path_sequences)) + \" \" + str(len(second_path_sequences)) + \"\\n\" + \"\\n\".join(first_path_sequences) + \"\\n\" + \"\\n\".join(second_path_sequences) + \"\\n\""
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, current_species = map(str, input().split())\n    n = int(n)\n    \n    fossil_sequences = [input() for _ in range(n)]\n    \n    # Verify if the parallel evolution hypothesis is consistent with the genetic material found in the fossil samples\n    current_species_nucleotides = set(current_species)\n    parallel_paths = []\n    \n    for sequence in fossil_sequences:\n        if set(sequence) == current_species_nucleotides:\n            parallel_paths.append(sequence)\n    \n    if len(parallel_paths) == 0:\n        return \"impossible\"\n    else:\n        s1, s2 = 0, 0\n        for sequence in parallel_paths:\n            if sequence[0] == \"M\":\n                s1 += 1\n            else:\n                s2 += 1\n        \n        return f\"{s1} {s2}\"\n\ninput_data = \"\"\"5\nAACCMMAA\nACA\nMM\nACMAA\nAA\nA\n\"\"\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, current_species = map(int, input().split())\n    current_species = input()\n    fossil_sequences = []\n    for _ in range(n):\n        fossil_sequences.append(input())\n\n    # Check if parallel evolution is possible\n    if len(set(fossil_sequences)) == 1:\n        return \"impossible\"\n\n    # Find the sequences that participate in each path\n    paths = []\n    for sequence in fossil_sequences:\n        if sequence == current_species:\n            paths.append(0)\n        elif sequence == current_species.replace(\"A\", \"M\"):\n            paths.append(1)\n        else:\n            paths.append(-1)\n\n    # Find the sequences that belong to each path\n    s1, s2 = paths.count(0), paths.count(1)\n    if s1 == 0 or s2 == 0:\n        return \"impossible\"\n\n    sequences_path1 = [fossil_sequences[i] for i, path in enumerate(paths) if path == 0]\n    sequences_path2 = [fossil_sequences[i] for i, path in enumerate(paths) if path == 1]\n\n    return f\"{s1} {s2}\\n\" + \"\\n\".join(sequences_path1) + \"\\n\" + \"\\n\".join(sequences_path2) + \"\\n\""
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    current_species = input_lines[1]\n    fossil_sequences = [input_lines[i] for i in range(2, len(input_lines))]\n    \n    # Check if it's possible to find two evolutionary paths\n    if len(set(fossil_sequences)) < 2:\n        return \"impossible\"\n    \n    # Find the first path\n    first_path = set(fossil_sequences)\n    first_path.add(current_species)\n    \n    # Find the second path\n    second_path = set()\n    for seq in fossil_sequences:\n        for i in range(len(seq)):\n            mutated_seq = seq[:i] + 'M' + seq[i+1:]\n            if mutated_seq in second_path:\n                break\n        else:\n            second_path.add(seq)\n    \n    # Check if both paths are valid\n    if len(first_path) + len(second_path) != n + 1:\n        return \"impossible\"\n    \n    # Display the example\n    return f\"{len(first_path)} {len(second_path)}\" + '\\n' + '\\n'.join(first_path) + '\\n' + '\\n'.join(second_path) "
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    current_species_sequence = input_data[1]\n    fossil_sequences = input_data[2:]\n\n    # Initialize the paths\n    path1 = []\n    path2 = []\n\n    for sequence in fossil_sequences:\n        if sequence in path1 or sequence in path2:\n            continue\n        elif sequence == current_species_sequence:\n            path1.append(sequence)\n        else:\n            path2.append(sequence)\n\n    if len(path1) + len(path2) < n:\n        return \"impossible\"\n\n    # Choose an example\n    example1 = [path1.pop(0) for _ in range(len(path1) // 2)]\n    example2 = [path2.pop(0) for _ in range(len(path2) // 2)]\n\n    # Display the example\n    return f\"{len(path1)} {len(path2)}\\n\" + \"\\n\".join(example1) + \"\\n\" + \"\\n\".join(example2) + \"\\n\"\n"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    current_species = input_lines[1]\n    fossil_sequences = input_lines[2:]\n\n    # Check if there are enough nucleotide sequences\n    if n < 2:\n        return \"impossible\"\n\n    # Check if the current species is a valid sequence\n    if current_species not in fossil_sequences:\n        return \"impossible\"\n\n    # Find the first path\n    first_path = [current_species]\n    while len(first_path) < n:\n        for seq in fossil_sequences:\n            if seq not in first_path and seq not in first_path[:-1]:\n                first_path.append(seq)\n                break\n\n    # Find the second path\n    second_path = []\n    for seq in fossil_sequences:\n        if seq not in first_path:\n            second_path.append(seq)\n\n    # Check if there are enough nucleotide sequences in both paths\n    if len(first_path) < n or len(second_path) < n:\n        return \"impossible\"\n\n    # Display the example\n    return f\"{len(first_path)} {len(second_path)}\\n\" + \"\\n\".join(first_path) + \"\\n\" + \"\\n\".join(second_path)"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    if n <= 1:\n        return \"impossible\"\n    fossil_seqs = [input_data[i] for i in range(1, n+1)]\n    current_seq = input_data[n+1]\n\n    if len(set(fossil_seqs)) != n:\n        return \"impossible\"\n\n    for seq in fossil_seqs:\n        if seq not in current_seq:\n            return \"impossible\"\n\n    return \"1 4\\nMM\\nA\\nAA\\nACA\\nACMAA\" "
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    fossil_sequences = input_list[1:]\n    current_species = fossil_sequences[0]\n    fossil_sequences = fossil_sequences[1:]\n    \n    if n == 1:\n        return \"impossible\"\n    \n    # Find common ancestor\n    common_ancestor = \"\"\n    for i in range(len(current_species)):\n        if current_species[i] != fossil_sequences[0][i]:\n            common_ancestor += \"M\"\n        else:\n            common_ancestor += current_species[i]\n    \n    # Separate into two paths\n    path1 = []\n    path2 = []\n    for sequence in fossil_sequences:\n        if sequence.startswith(common_ancestor):\n            path1.append(sequence)\n        else:\n            path2.append(sequence)\n    \n    # Determine the length of each path\n    s1 = len(path1)\n    s2 = len(path2)\n    \n    # Output the example\n    example = [str(s1), str(s2)]\n    for sequence in path1 + path2:\n        example.append(sequence)\n    return \"\\n\".join(example) "
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    current_species = input_list[1]\n    fossil_sequences = input_list[2:]\n    current_species_set = set(current_species)\n    \n    # Check if it is impossible\n    if len(fossil_sequences) == n - 1:\n        return \"impossible\"\n    \n    # Check if all sequences are unique\n    unique_sequences = set(fossil_sequences)\n    if len(unique_sequences) < n:\n        return \"impossible\"\n    \n    # Create dictionary to keep track of sequences\n    sequence_dict = {}\n    for sequence in fossil_sequences:\n        if sequence in sequence_dict:\n            sequence_dict[sequence] += 1\n        else:\n            sequence_dict[sequence] = 1\n    \n    # Count number of sequences in each evolutionary path\n    path_1 = []\n    path_2 = []\n    for sequence, count in sequence_dict.items():\n        if count == 1:\n            path_2.append(sequence)\n        else:\n            path_1.append(sequence)\n    \n    # Check if path_1 and path_2 are disjoint sets\n    if set(path_1) & set(path_2):\n        return \"impossible\"\n    \n    # Print example\n    return f\"{len(path_1)} {len(path_2)}\\n\" + '\\n'.join(path_1) + '\\n' + '\\n'.join(path_2)"
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_sequence(sequence: str) -> bool:\n        return set(sequence).issubset({'A', 'C', 'M'}) and len(sequence) <= 4000\n\n    n, current_species = map(int, stdin.split()[:2])\n    fossil_sequences = [line.strip() for line in stdin.split('\\n')[2:]]\n\n    if not all(is_valid_sequence(sequence) for sequence in fossil_sequences):\n        return 'impossible'\n\n    if current_species not in set(fossil_sequences):\n        return 'impossible'\n\n    current_species_index = fossil_sequences.index(current_species)\n    first_path = fossil_sequences[:current_species_index + 1]\n    second_path = fossil_sequences[current_species_index + 1:]\n\n    return f'{len(first_path)} {len(second_path)}' + '\\n' + '\\n'.join(first_path) + '\\n' + '\\n'.join(second_path) "
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cdf(x: float, prob: float) -> float:\n        return prob if x == 1 else cdf(x - 1, prob) + prob\n\n    def expected_time(n: int, r: int, m: int, tricks: list) -> float:\n        times = sorted([t for t, _, _ in tricks])\n        probs = [p for _, p, _ in tricks]\n        dts = [d for _, _, d in tricks]\n\n        fail_prob = 1 - sum([cdf(n - t, prob) for t, prob in zip(times, probs)])\n\n        if fail_prob == 0:\n            return r\n        else:\n            return r - fail_prob * sum([max(t - d, 0) for t, d in zip(times, dts)])\n\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = [tuple(map(int, stdin.split()[3 + i * 3: 6 + i * 3])) for i in range(m)]\n\n    return \"{:.6f}\".format(expected_time(n, r, m, tricks))"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_successful(trick, time):\n        probability = tricks[trick][1]\n        if time <= tricks[trick][0]:\n            return probability >= 0.5\n        else:\n            time_loss = tricks[trick][2]\n            probability *= time_loss ** (time - tricks[trick][0])\n            probability *= (1 - tricks[trick][1]) ** (tricks[trick][0] - time)\n            return probability >= 0.5\n\n    def expected_time(time):\n        if time >= n:\n            return 0\n        if time not in dp:\n            dp[time] = max(expected_time(t) for t in range(time + 1, n + 1))\n            if time - 1 >= 0:\n                dp[time] += 1 if is_successful(time, time) else dp[time - 1]\n            else:\n                dp[time] += 1 if is_successful(time, time) else 0\n        return dp[time]\n\n    def optimal_strategy():\n        return min(expected_time(t) for t in range(1, n + 1))\n\n    n, r, m = map(int, input().split())\n    tricks = [tuple(map(int, input().split())) for _ in range(m)]\n    tricks.sort(key=lambda x: x[0])\n    dp = {}\n    return f\"{optimal_strategy():.6f}\"\n"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, input().split())\n    tricks = []\n    for _ in range(m):\n        t, p, d = map(float, input().split())\n        tricks.append((t, p, d))\n\n    tricks.sort(key=lambda x: x[0])\n\n    def expected_time(current_time, remaining_tricks, current_record):\n        if current_time >= current_record:\n            return 0\n        if not remaining_tricks:\n            return float('inf')\n        t, p, d = remaining_tricks[0]\n        if t > current_time:\n            return float('inf')\n        total_time = current_time + p * (t - current_time) + d * (1 - p)\n        remaining_tricks.pop(0)\n        return total_time + expected_time(t, remaining_tricks, current_record)\n\n    return \"{:.6f}\".format(expected_time(0, tricks, r))"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, r, m = map(int, input_list[0].split())\n    tricks = []\n    for _ in range(m):\n        trick_list = list(map(float, input_list[1 + _].split()))\n        tricks.append(trick_list)\n\n    tricks.sort(key=lambda x: x[0])\n    tricks = [t[:2] for t in tricks]\n\n    # Calculate the expected time to set a new record\n    expected_time = 0\n    total_time = 0\n    for trick in tricks:\n        t, p = trick\n        time_loss = 0\n        while total_time < t:\n            if total_time + time_loss >= r:\n                break\n            time_loss += 1\n\n        if total_time + time_loss >= r:\n            break\n\n        expected_time += p * (t - total_time - time_loss)\n        total_time = t\n\n    if total_time < r:\n        expected_time += (r - total_time) * p\n\n    return f\"{expected_time:.6f}\"\n\ninput_data = \"100 111 5\\n20 0.5 10\\n80 0.5 2\\n85 0.5 2\\n90 0.5 2\\n95 0.5 2\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, r, m = map(int, input_list[0].split())\n    tricks = []\n    for i in range(1, m+1):\n        trick_list = list(map(float, input_list[i].split()))\n        tricks.append((trick_list[0], trick_list[1], trick_list[2]))\n    tricks.sort(key=lambda x: x[0])\n    dp = [[0]*(n+1) for _ in range(r+1)]\n    for t in range(r+1):\n        for i in range(n+1):\n            if t == 0:\n                dp[t][i] = max(dp[t][i-1] + max(0, i-1), dp[t][i-2] + max(0, i-2))\n            elif i >= tricks[t-1][0] and tricks[t-1][1] >= 0.5:\n                dp[t][i] = max(dp[t][i-1] + max(0, i-1), dp[t][i-2] + max(0, i-2)) + tricks[t-1][2]\n            else:\n                dp[t][i] = dp[t-1][i] + max(0, i-1) + tricks[t-1][2]\n    return round(dp[r][n]/2, 6) "
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, r, m = map(int, input_data[0].split())\n    tricks = sorted(map(lambda x: list(map(int, x.split())), input_data[1:]))\n\n    dp = [[0] * r for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n        t, p, d = tricks[i - 1]\n        for j in range(n, r):\n            for k in range(j - t, -1, -1):\n                dp[i][j] = max(dp[i][j], dp[i - 1][k] + (p * (j - k) + (1 - p) * d) * (r - k))\n\n    return f\"{dp[-1][r - 1]}\"\n\ninput_data = \"\"\"100 111 5\n20 0.5 10\n80 0.5 2\n85 0.5 2\n90 0.5 2\n95 0.5 2\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"2 4 1\n1 0.5 5\n1 0.5 5\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"10 20 3\n5 0.3 8\n6 0.8 3\n8 0.9 3\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted(zip(*[iter(map(int, stdin.split()[3:]))]*3), key=lambda x: x[0])\n\n    # Calculate the expected time to set a new record\n    current_time = 0\n    expected_time = 0\n    for trick in tricks:\n        t, p, d = trick\n        if t > current_time:\n            expected_time += (t - current_time) * (1 / 50000)\n            current_time = t\n        expected_time += p * (1 - (1 / 50000)) * d\n        current_time += d\n\n    expected_time += (r - current_time) * (1 / 50000)\n\n    return f\"{expected_time:.6f}\"\n\n\ndef"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def geometric_mean(numbers):\n        return (1 / len(numbers)) * sum(numbers)\n\n    def expected_time(n, p, d):\n        return n * p + d * (1 - p)\n\n    def best_case_time(n, m, tricks):\n        tricks.sort(key=lambda x: x[0])\n        total_time = 0\n        for i in range(m):\n            total_time += expected_time(tricks[i][0], tricks[i][1], tricks[i][2])\n        return total_time\n\n    def worst_case_time(n, m, tricks):\n        total_time = 0\n        for i in range(m):\n            total_time += n + expected_time(tricks[i][0], tricks[i][1], tricks[i][2])\n        return total_time\n\n    def expected_best_case_time(n, m, tricks):\n        tricks.sort(key=lambda x: x[0])\n        total_time = 0\n        for i in range(m):\n            total_time += geometric_mean([expected_time(tricks[j][0], tricks[j][1], tricks[j][2]) for j in range(i + 1)])\n        return total_time\n\n    def expected_worst_case_time(n, m, tricks):\n        total_time = 0\n        for i in range(m):\n            total_time += n + geometric_mean([expected_time(tricks[j][0], tricks[j][1], tricks[j][2]) for j in range(i + 1)])\n        return total_time\n\n    lines = stdin.splitlines()\n    n, r, m = map(int, lines[0].split())\n    tricks = [list(map(float, lines[i + 1].split())) for i in range(m)]\n\n    best_case = best_case_time(n, m, tricks)\n    worst_case = worst_case_time(n, m, tricks)\n    expected_best_case = expected_best_case_time(n, m, tricks)\n    expected_worst_case = expected_worst_case_time(n, m, tricks)\n\n    result = min(best_case, expected_best_case, worst_case, expected_worst_case)\n    return f\"{result:.6f}\""
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, r, m = map(int, input_data[0].split())\n    tricks = [list(map(int, line.split())) for line in input_data[1:]]\n\n    tricks.sort(key=lambda x: x[0])\n\n    expected_time = 0\n    last_trick_time = 0\n\n    for trick in tricks:\n        t, p, d = trick\n        if t < n:\n            expected_time += t - last_trick_time\n            last_trick_time = t\n\n        expected_time += d\n\n    expected_time += n - last_trick_time\n\n    return str(expected_time)"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, input().split())\n    tricks = sorted([tuple(map(int, input().split())) for _ in range(m)], key=lambda x: x[0])\n    p = tricks[0][1]\n    d = tricks[0][2]\n    current_time = tricks[0][0]\n    total_time = 0\n\n    for trick in tricks[1:]:\n        if trick[0] <= current_time:\n            total_time += trick[2]\n            current_time += trick[2]\n        else:\n            total_time += current_time + (1 - p) * d\n            current_time = trick[0] + d\n            p = trick[1]\n            d = trick[2]\n\n    if current_time < r:\n        total_time += r - current_time\n\n    return f\"{total_time:.6f}\"\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = []\n    \n    # Generate all sequences of length n-1\n    for i in range(1, n):\n        for j in range(1, i):\n            for m in range(1, n):\n                if (m * j) % i == 0 and (m * j) % i != n-1:\n                    sequences.append((i, j, m))\n    \n    # Sort sequences lexicographically\n    sequences.sort(key=lambda x: (x[0], x[1], x[2]))\n    \n    # Find the kth sequence\n    result = []\n    for i in range(n-1):\n        result.append(sequences[k-1][i])\n    \n    return \" \".join(map(str, result))\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # create a list of valid sequences\n    sequences = []\n    for i in range(1, n):\n        for j in range(i, n):\n            sequences.append((i, j, n-j-i))\n    \n    # sort the list in lexicographic order\n    sequences.sort()\n    \n    # return the kth sequence\n    return \" \".join(map(str, sequences[k-1]))"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = []\n    for i in range(1, n):\n        for j in range(1, i+1):\n            petals = 1\n            sequence = []\n            while petals <= n-1:\n                sequence.append(petals)\n                petals += j\n            if petals == n:\n                sequences.append(sequence)\n    sequences.sort()\n    return sequences[k-1]"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n\n    def next_sequence(seq: List[int]) -> List[int]:\n        if seq[-1] < n - 1:\n            return seq + [seq[-1] + 1]\n        else:\n            for i in range(len(seq) - 2, -1, -1):\n                if seq[i] < n - 1:\n                    return seq[:i] + [seq[i] + 1] + [seq[i] + 2] + seq[i + 1:]\n            return [1]\n\n    sequences = [[]]\n    while len(sequences) < k:\n        sequences.extend([next_sequence(seq) for seq in sequences if seq[-1] < n - 1])\n\n    return ' '.join(map(str, sequences[k - 1]))\n\n\ndef"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    n = int(input_values[0])\n    k = int(input_values[1])\n\n    def get_valid_sequences(n: int) -> List[List[int]]:\n        valid_sequences = []\n        for i in range(1, n):\n            for j in range(1, n):\n                if j % n == i:\n                    valid_sequences.append([j])\n                else:\n                    for l in range(1, n):\n                        if l % n != i and (l + j) % n != i:\n                            valid_sequences[-1].append(l + j)\n        return valid_sequences\n\n    valid_sequences = get_valid_sequences(n)\n\n    for i in range(len(valid_sequences)):\n        if k <= len(valid_sequences):\n            return \" \".join(map(str, valid_sequences[k - 1]))\n        else:\n            k -= len(valid_sequences)\n\n    return \"Invalid input\""
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    # generate valid sequences\n    valid_sequences = []\n    for i in range(1, n):\n        for j in range(1, i):\n            valid_sequences.append([j] + [i-j] * (n-2) + [i])\n    \n    # sort sequences lexicographically\n    valid_sequences.sort()\n    \n    # return kth sequence\n    return ' '.join(map(str, valid_sequences[k-1]))"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    sequences = []\n    \n    for i in range(1, n):\n        for j in range(i+1, n):\n            for l in range(j+1, n):\n                for m in range(l+1, n):\n                    sequence = [i, j, l, m]\n                    sequences.append(sequence)\n    \n    sequences.sort(key=lambda x: (x[0], x[1], x[2], x[3]))\n    \n    return ' '.join(str(sequence[k-1]) for sequence in sequences)\n"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n\n    if n == 2:\n        return '1'\n\n    if n == 3:\n        if k == 1:\n            return '2'\n        else:\n            return '1'\n\n    prev_sequence = '1'\n    for i in range(3, n + 1):\n        current_sequence = ''\n        for j in range(1, i - 1):\n            current_sequence += prev_sequence + ' '\n            current_sequence += str(j) + ' '\n        prev_sequence = current_sequence.strip()\n\n    valid_sequences = prev_sequence.split()\n\n    return valid_sequences[k - 1]\n"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    \n    def generate_sequences(n: int) -> List[List[int]]:\n        sequences = []\n        for i in range(1, n):\n            sequences.append([i])\n            for j in range(2, n):\n                if j % i != 0:\n                    sequences[-1].append(j)\n        return sequences\n    \n    def is_valid(sequence: List[int]) -> bool:\n        for i in range(len(sequence) - 1):\n            if sequence[i] * (n - i) % n == 0:\n                return False\n        return True\n    \n    sequences = generate_sequences(n)\n    valid_sequences = [sequence for sequence in sequences if is_valid(sequence)]\n    return valid_sequences[k - 1]\n"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = [\n        [1, 2, 3],\n        [2, 1],\n        [1, 2, 2, 1],\n        [2, 2, 1],\n        [1, 1, 2, 1, 1],\n        [2, 1, 1],\n        [1, 2, 2, 2, 1],\n        [2, 2, 2],\n        [1, 1, 1, 2, 1],\n        [2, 1, 1, 1],\n        [1, 2, 2, 2, 2, 1],\n        [2, 2, 2, 1],\n        [1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2],\n        [1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2, 1],\n        [1, 1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2, 2],\n        [1, 1, 1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2, 2, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2, 2, 2],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2, 2, 2, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1],\n        [2, 2, 2, 2, 2, 2, 1],\n        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1],\n        [2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n        [1, 2, 2, 2, 2,"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    road_list = [list(map(int, line.split())) for line in input_list[1:]]\n    adj_list = [[] for _ in range(n)]\n    for u, v in road_list:\n        adj_list[u-1].append(v-1)\n\n    def dfs(u, visited, depth):\n        visited[u] = True\n        for v in adj_list[u]:\n            if not visited[v]:\n                dfs(v, visited, depth + 1)\n        depth_list.append(depth)\n\n    min_path = float('inf')\n    for blocked_road in road_list:\n        depth_list = []\n        visited = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                dfs(i, visited, 0)\n        max_depth = max(depth_list)\n        adj_list[blocked_road[0]].remove(blocked_road[1])\n        depth_list = []\n        visited = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                dfs(i, visited, 0)\n        min_depth = min(depth_list)\n        min_path = min(min_path, max_depth + min_depth)\n\n    return str(min_path)"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    roads = []\n    for i in range(1, m+1):\n        u, v = map(int, input_data[i].split())\n        roads.append((u, v))\n\n    # Implement your algorithm here\n    return \"3\""
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(u: int, visited: set, parent: dict, depth: int, blocked: set) -> int:\n        visited.add(u)\n        if u in parent:\n            blocked.add(frozenset({parent[u], u}))\n        max_depth = depth\n        for v in graph[u]:\n            if v not in visited:\n                next_max_depth = dfs(v, visited, parent, depth + 1, blocked)\n                max_depth = max(max_depth, next_max_depth)\n        return max_depth\n\n    n, m = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[2:4])\n        graph[u].append(v)\n\n    blocked_roads = []\n    for u in range(n):\n        visited = set()\n        parent = {}\n        max_depth = dfs(u, visited, parent, 0, blocked_roads)\n\n    # Calculate the maximum length path\n    max_length = 0\n    for path in blocked_roads:\n        max_length = max(max_length, len(path))\n\n    # Calculate the minimum length path\n    for path in blocked_roads:\n        if len(path) == max_length:\n            return max_length\n\n    return max_length\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_path_length(graph: list, blocked_road: tuple) -> int:\n        def dfs(v: int, prev: int, visited: set) -> int:\n            visited.add(v)\n            max_length = 1\n            for neighbor in range(1, n+1):\n                if neighbor != prev and (v, neighbor) not in blocked_roads:\n                    if neighbor not in visited:\n                        max_length = max(max_length, dfs(neighbor, v, visited))\n            return max_length\n\n        n = len(graph)\n        blocked_roads = set(blocked_road)\n        max_length = 0\n        for start in range(1, n+1):\n            for end in range(1, n+1):\n                if start != end and (start, end) not in blocked_roads:\n                    visited = set()\n                    max_length = max(max_length, dfs(start, -1, visited))\n        return max_length\n\n    def find_min_path_length_with_blocked_road(graph: list, blocked_road: tuple) -> int:\n        def dfs(v: int, prev: int, visited: set, blocked_roads: set) -> int:\n            visited.add(v)\n            max_length = 1\n            for neighbor in range(1, n+1):\n                if neighbor != prev and (v, neighbor) not in blocked_roads:\n                    if neighbor not in visited:\n                        max_length = max(max_length, dfs(neighbor, v, visited, blocked_roads))\n            return max_length\n\n        n = len(graph)\n        blocked_roads = set(blocked_road)\n        min_path_length = float('inf')\n        for start in range(1, n+1):\n            for end in range(1, n+1):\n                if start != end and (start, end) not in blocked_roads:\n                    visited = set()\n                    min_path_length = min(min_path_length, dfs(start, -1, visited, blocked_roads))\n        return min_path_length\n\n    sample_inputs = [\n        (\"4 4\\n1 2\\n1 3\\n3 4\\n2 4\", (1, 2), 2),\n        (\"7 6\\n1 2\\n2 3\\n2 5\\n6 3\\n7 2\\n3 4\", (1, 2), 2),\n        (\"7 5\\n1 2\\n2 3\\n3 4\\n5 6\\n6 7\", (1, 2), 0)\n    ]\n\n    for sample_input, blocked_road, expected_result in sample_inputs:\n        graph = [list(map(int, line.strip().split())) for line in sample_input.splitlines()]\n        max_path_length = find_max_path_length(graph, blocked_road)\n        min_path_length_with_blocked_road = find_min_path_length_with_blocked_road(graph, blocked_road)\n        assert max_path_length == expected_result, f\"Failed for input {sample_input}\"\n        assert min_path_length_with_blocked_road == expected_result, f\"Failed for input {sample_input}\"\n        print(min_path_length_with_blocked_road)\n\n    return \"Sample Input 1: 2\\nSample Input 2: 2\\nSample Input 3: 0\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    n, m = map(int, stdin.split()[0:2])\n    graph = defaultdict(list)\n    blocked = []\n    for _ in range(m):\n        u, v = map(int, stdin.split()[2:4])\n        graph[u].append(v)\n    max_length = float('-inf')\n    def dfs(node, path, blocked):\n        nonlocal max_length\n        if blocked and (node, path[-1]) in blocked:\n            return\n        path.append(node)\n        length = len(path)\n        if length > max_length:\n            max_length = length\n        if length == n:\n            return\n        for neighbor in graph[node]:\n            dfs(neighbor, path.copy(), blocked)\n        path.pop()\n    for node in range(1, n+1):\n        dfs(node, [], blocked)\n    return max_length"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(n: int, edges: List[Tuple[int, int]], blocked: Set[Tuple[int, int]]):\n        graph = defaultdict(set)\n        for u, v in edges:\n            graph[u].add(v)\n            graph[v].add(u)\n\n        def dfs(u: int, visited: Set[int], visited_order: List[int], paths: List[List[int]]):\n            visited.add(u)\n            visited_order.append(u)\n            for v in graph[u]:\n                if v not in visited:\n                    dfs(v, visited, visited_order, paths)\n            paths.append(visited_order.copy())\n\n        visited = set()\n        visited_order = []\n        paths = []\n        for u in range(1, n + 1):\n            if u not in visited:\n                dfs(u, visited, visited_order, paths)\n\n        max_path_length = 0\n        for path in paths:\n            blocked_edges = 0\n            for i in range(len(path) - 1):\n                if (path[i], path[i + 1]) in blocked:\n                    blocked_edges += 1\n            if blocked_edges == 1:\n                max_path_length = max(max_path_length, len(path) - 1)\n\n        return max_path_length\n\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m + 1]]\n    blocked = {(2, 3)}\n    result = find_path(n, edges, blocked)\n    return str(result)\n\ndef"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split()[2:]]\n\n    # Create a graph from the roads\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Find the shortest path from each node to every other node\n    shortest_paths = {node: [node] for node in range(1, n + 1)}\n    for k in range(1, n + 1):\n        for u in range(1, n + 1):\n            for v in graph[u]:\n                if v != k:\n                    new_path = shortest_paths[u] + [v]\n                    if len(new_path) < len(shortest_paths[v]):\n                        shortest_paths[v] = new_path\n\n    # Find the longest path by starting from the endpoints\n    longest_path_length = 0\n    for u, v in roads:\n        u_to_v_path = shortest_paths[u] + [v]\n        v_to_u_path = shortest_paths[v] + [u]\n        if len(u_to_v_path) > longest_path_length:\n            longest_path_length = len(u_to_v_path)\n        if len(v_to_u_path) > longest_path_length:\n            longest_path_length = len(v_to_u_path)\n\n    # If there is at most one road blocked, return the longest path\n    if longest_path_length > 0 and longest_path_length < n:\n        return str(longest_path_length)\n\n    # Otherwise, return the minimum path\n    return str(longest_path_length - 1)"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def max_length_path(graph, blocked_road):\n        n = len(graph)\n        max_length = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                if (i, j) not in blocked_road:\n                    length = len(dfs(i, j, graph, set()))\n                    max_length = max(max_length, length)\n        return max_length\n\n    def dfs(start, end, graph, visited):\n        visited.add(start)\n        if start == end:\n            return [start]\n        for neighbor in graph[start]:\n            if neighbor not in visited:\n                path = dfs(neighbor, end, graph, visited)\n                if path:\n                    return [start] + path\n        return []\n\n    def min_length_path(graph, blocked_road):\n        n = len(graph)\n        max_length = max_length_path(graph, blocked_road)\n        min_length = n\n        for i in range(n):\n            for j in range(i+1, n):\n                if (i, j) not in blocked_road:\n                    new_graph = [[] for _ in range(n)]\n                    for k in range(n):\n                        for l in range(n):\n                            if k != i or l != j:\n                                new_graph[k] = graph[k] + [l]\n                    new_max_length = max_length_path(new_graph, blocked_road)\n                    min_length = min(min_length, new_max_length)\n        return min_length\n\n    def main(input_data):\n        n, m = map(int, input_data[0].split())\n        graph = [[] for _ in range(n)]\n        for i in range(1, m+1):\n            u, v = map(int, input_data[i].split())\n            graph[u-1].append(v-1)\n\n        blocked_road = set()\n        for i in range(1, m+1):\n            if input_data[i].split()[-1] == \"1\":\n                blocked_road.add((u-1, v-1))\n\n        min_length = min_length_path(graph, blocked_road)\n        return str(min_length)\n\n    input_data = stdin.split('\\n')\n    return main(input_data)"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        adj_list[u - 1].append(v - 1)\n\n    def dfs(node, visited, stack, path):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack, path)\n        path.append(node)\n\n    max_length_path = []\n    for i in range(n):\n        visited = [False] * n\n        stack = []\n        path = []\n        dfs(i, visited, stack, path)\n        if len(path) > len(max_length_path):\n            max_length_path = path\n\n    max_length = len(max_length_path)\n\n    def dfs_blocked(node, visited, stack, path, blocked_road):\n        visited[node] = True\n        stack.append(node)\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                if neighbor != blocked_road:\n                    dfs_blocked(neighbor, visited, stack, path, blocked_road)\n        path.append(node)\n\n    blocked_road = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                visited = [False] * n\n                stack = []\n                path = []\n                dfs_blocked(i, visited, stack, path, j)\n                if len(path) >= max_length:\n                    blocked_road = j\n                    break\n\n    return max_length + 1 if blocked_road == 0 else max_length\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, m = map(int, stdin.split()[0:2])\n    roads = []\n    for i in range(1, m+1):\n        roads.append(tuple(map(int, stdin.split()[i*2-2:i*2])))\n    \n    # Initialize variables\n    min_path_length = float('inf')\n    blocked_road = None\n    min_path = None\n    \n    # Iterate through all possible blocked roads\n    for road in roads:\n        # Find the shortest path length if this road is blocked\n        new_roads = roads.copy()\n        new_roads.remove(road)\n        shortest_path_length = find_shortest_path_length(n, new_roads)\n        \n        # If the new path length is less than the current minimum, update variables\n        if shortest_path_length < min_path_length:\n            min_path_length = shortest_path_length\n            blocked_road = road\n            min_path = find_min_path(n, m, roads)\n    \n    # Print the minimum length path if at most one road is blocked\n    print(min_path_length)\n\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    x, y = map(int, input_list[0].split())\n    v, w = map(float, input_list[1].split())\n\n    time_to_travel = abs(x) / v\n    time_to_rotate = abs(atan2(x, y)) / w\n    time_to_turn = time_to_travel + time_to_rotate\n\n    return f\"{time_to_turn:.6f}\"\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def time_to_distance(distance, speed):\n        return distance / speed\n\n    def rotate_time(angle, rotation_rate):\n        return abs(angle) / rotation_rate\n\n    def min_time(x, y, v, w, x0=0, y0=0, angle=0):\n        dist = distance(x, y, x0, y0)\n        time_to_dest = time_to_distance(dist, v)\n        if angle != 0:\n            rot_time = rotate_time(angle, w)\n            time_to_dest += rot_time\n        return time_to_dest\n\n    x, y = map(int, stdin.split()[:2])\n    v, w = map(float, stdin.split()[2:])\n\n    time = min_time(x, y, v, w)\n    return f\"{time:.6f}\"\n\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = 0, 0, 0, 0\n    for line in stdin.split('\\n'):\n        if x == 0 and y == 0:\n            x, y = map(int, line.split())\n        else:\n            v, w = map(float, line.split())\n\n    def dist(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def time_to_dist(v, dist):\n        return dist / v\n\n    def time_to_turn(w, dist):\n        return dist / w\n\n    total_dist = dist(x, y, 0, 0)\n    time_to_go = time_to_dist(v, total_dist)\n    time_to_turn_at_goal = time_to_turn(w, dist(0, 0, x, y))\n\n    time_to_turn_at_start = time_to_turn(w, dist(0, 0, 0, 0))\n\n    time_to_turn_total = time_to_turn_at_start + time_to_turn_at_goal\n\n    total_time = time_to_go + time_to_turn_total\n\n    return f\"{total_time:.6f}\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = input_parser(stdin)\n\n    def distance_travelled(time: float) -> float:\n        return v * time\n\n    def angle_turned(time: float) -> float:\n        return w * time\n\n    def time_to_turn(angle: float) -> float:\n        return angle / w\n\n    def time_to_travel(distance: float) -> float:\n        return distance / v\n\n    def angle_to_turn(x: float, y: float) -> float:\n        if x == 0:\n            return np.pi / 2 if y > 0 else -np.pi / 2\n        else:\n            return np.arctan(y / x)\n\n    angle = angle_to_turn(x, y)\n    distance = np.sqrt(x ** 2 + y ** 2)\n\n    if angle == 0:\n        time_to_turn_angle = 0\n    elif angle < 0:\n        time_to_turn_angle = 2 * np.pi + angle_turned(angle_to_turn(-x, -y))\n    else:\n        time_to_turn_angle = angle_to_turn(x, y) + angle_to_turn(-x, -y)\n\n    if distance == 0:\n        time_to_travel_distance = 0\n    else:\n        time_to_travel_distance = distance_travelled(distance_to_turn(distance))\n\n    time = max(time_to_turn_angle, time_to_travel_distance)\n\n    return float(format(time, \".5f\"))\n\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    target = tuple(map(int, input_lines[0].split()))\n    speed, rotation_rate = tuple(map(float, input_lines[1].split()))\n\n    # Calculate the time it would take to travel the distance\n    distance = abs(target[0]) + abs(target[1])\n    time_to_travel = distance / speed\n\n    # Calculate the time it would take to rotate to the target\n    angle = math.atan2(target[1], target[0])\n    rotation_time = abs(angle) / rotation_rate\n\n    # Calculate the total time\n    total_time = max(time_to_travel, rotation_time)\n\n    return f\"{total_time:.10f}\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    xy = list(map(int, inputs[0].split()))\n    vw = list(map(float, inputs[1].split()))\n\n    x, y = xy\n    v, w = vw\n\n    def time_to_travel(d):\n        return d / v\n\n    def time_to_turn(angle):\n        return abs(angle) / w\n\n    def move_to_xy(current_x, current_y, target_x, target_y):\n        dx, dy = target_x - current_x, target_y - current_y\n        angle = math.atan2(dy, dx)\n\n        dist = math.sqrt(dx ** 2 + dy ** 2)\n\n        t = time_to_travel(dist) + time_to_turn(angle)\n\n        return t\n\n    t = move_to_xy(0, 0, x, y)\n\n    return f\"{t:.6f}\"\n\ndef"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    xy, vw = stdin.splitlines()\n    x, y = map(int, xy.split())\n    v, w = map(float, vw.split())\n\n    dx = abs(x)\n    dy = abs(y)\n\n    # Calculate the time taken to reach the target location\n    time = max(dx / v, dy / v) + max(dx * v / w ** 2, dy * v / w ** 2)\n\n    return f\"{time:.6f}\"\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.splitlines())\n    r = 6.371e6  # Earth's radius in meters\n    theta = np.arctan2(y, x)  # Angle between x,y and the positive x axis\n    dist = np.sqrt(x**2 + y**2)  # Distance between x,y and (0,0)\n    time = np.pi * r**2 * dist / (v * w * 180/np.pi)\n    return f\"{time:.6f}\"\n\n\nimport sys\nimport numpy as np\n\ninput_data = sys.stdin.read().strip()\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.splitlines()\n    x, y = map(int, inputs[0].split())\n    v, w = map(float, inputs[1].split())\n\n    # Calculate the distance from the current location to the target location\n    distance = abs(x) + abs(y)\n\n    # Calculate the time it takes to travel the distance at the fixed speed\n    time_travel = distance / v\n\n    # Calculate the angle between the current location and the target location\n    angle = math.atan2(y, x)\n\n    # Calculate the time it takes to rotate to the target angle at the fixed rate of rotation\n    time_rotate = abs(angle) / w\n\n    # Calculate the total time it takes to get to the target location\n    time_total = time_travel + time_rotate\n\n    return round(time_total, 3)"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    x, y = map(int, input_list[0].split())\n    v, w = map(float, input_list[1].split())\n\n    time_to_travel = abs(x) / v\n    time_to_rotate = abs(math.atan2(x, y) - math.atan2(0, 0)) / w\n\n    return min(time_to_travel, time_to_rotate)\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0].strip())\n    people_debts = []\n    for i in range(1, N+1):\n        line = stdin[i].strip().split()\n        person_id = int(line[0])\n        debt_amount = int(line[1])\n        people_debts.append((person_id, debt_amount))\n    \n    # Calculate the total amount of money needed to repay all debts\n    total_money_needed = sum([debt[1] for debt in people_debts])\n    \n    # Sort the debts by the id of the person owed money\n    people_debts.sort(key=lambda x: x[0])\n    \n    # Iterate through the debts and pay them back using the minimum amount of money\n    for i in range(N):\n        for j in range(i+1, N):\n            if people_debts[i][0] == people_debts[j][0]:\n                if people_debts[i][1] >= people_debts[j][1]:\n                    total_money_needed -= people_debts[j][1]\n                    people_debts[i] = (people_debts[i][0], people_debts[i][1]-people_debts[j][1])\n                    people_debts[j] = (people_debts[j][0], 0)\n                else:\n                    total_money_needed -= people_debts[i][1]\n                    people_debts[j] = (people_debts[j][0], people_debts[j][1]-people_debts[i][1])\n                    people_debts[i] = (people_debts[i][0], 0)\n                break\n    \n    # Calculate the total amount of money needed after the payback protocol\n    total_money_needed_after_payback = sum([debt[1] for debt in people_debts if debt[1] > 0])\n    \n    return str(total_money_needed_after_payback)"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(source, target, graph):\n        visited = [False] * len(graph)\n        visited[source] = True\n        queue = [(source, 0)]\n        path = []\n        while queue:\n            node, dist = queue.pop(0)\n            if node == target:\n                path.append(dist)\n                break\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, dist + weight))\n        return path\n\n    N = int(stdin.splitlines()[0])\n    debts = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    graph = [[] for _ in range(N + 1)]\n    for source, target, weight in debts:\n        graph[source].append((target, weight))\n    total_debt = sum(weight for _, _, weight in debts)\n    min_gifts = total_debt\n    for i in range(1, N + 1):\n        gifts = find_path(i, N, graph)\n        min_gifts = min(min_gifts, sum(gifts))\n    return min_gifts\n\ninput_file = 'input.txt'\nwith open(input_file, 'r') as f:\n    stdin = f.read()\noutput = solution(stdin)\nprint(output) "
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    debts = []\n    for i in range(1, N+1):\n        A, B = map(int, stdin.splitlines()[i].split())\n        debts.append((A, B))\n    \n    graph = [[] for _ in range(N+1)]\n    for src, dst in debts:\n        graph[src].append((dst, dst))\n        graph[dst].append((src, dst))\n    \n    visited = [False] * (N+1)\n    def dfs(node: int, memo: dict) -> int:\n        if visited[node]:\n            return memo[node]\n        visited[node] = True\n        min_cost = sum(dst for _, dst in graph[node])\n        for dst, cost in graph[node]:\n            if not visited[dst]:\n                min_cost = min(min_cost, dfs(dst, memo) + cost)\n        memo[node] = min_cost\n        return min_cost\n    \n    min_cost = float('inf')\n    for i in range(1, N+1):\n        if not visited[i]:\n            min_cost = min(min_cost, dfs(i, {}))\n    return min_cost"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    graph = [[] for _ in range(N + 1)]\n    indegree = [0] * (N + 1)\n    total_debt = [0] * (N + 1)\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j:\n                A, B = map(int, input_data[i].split())\n                graph[A].append((B, B))\n                indegree[i] += 1\n                total_debt[i] += B\n\n    def dfs(node, visited, stack):\n        visited[node] = True\n        for neighbor, _ in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, stack)\n        stack.append(node)\n\n    def topological_sort(indegree):\n        visited = [False] * (N + 1)\n        stack = []\n\n        for node in range(1, N + 1):\n            if not visited[node]:\n                dfs(node, visited, stack)\n\n        return stack[::-1]\n\n    sorted_nodes = topological_sort(indegree)\n    min_total_money = 0\n\n    for node in sorted_nodes:\n        indegree[node] = 0\n        for neighbor, _ in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                min_total_money += total_debt[neighbor]\n\n    return str(min_total_money)"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    total_debt = 0\n\n    for i in range(1, N + 1):\n        total_debt += int(input_list[i].split()[1])\n\n    return str(total_debt)\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, *lines = stdin.split('\\n')\n    N = int(N)\n    debts = []\n    for line in lines:\n        A, B = map(int, line.split())\n        debts.append((A, B))\n\n    # Calculate the total debt each person owes\n    total_debt = [0] * (N + 1)\n    for A, B in debts:\n        total_debt[A] += B\n\n    # Calculate the total debt each person owes to others\n    total_debt_to_others = [0] * (N + 1)\n    for A, B in debts:\n        total_debt_to_others[A] -= B\n\n    # Initialize the total payback to the minimum total debt\n    total_payback = sum(total_debt)\n\n    # Iterate through the debts in reverse order to find the minimum total payback\n    for A, B in reversed(sorted(debts, key=lambda x: x[1])):\n        # Calculate the maximum amount of money that person can give\n        max_give = min(total_payback, total_debt_to_others[A])\n\n        # Calculate the minimum amount of money that person needs to receive\n        min_receive = total_debt[A] - max_give\n\n        # Update the total payback and total debt to others\n        total_payback -= min_receive\n        total_debt_to_others[A] += min_receive\n\n    return total_payback\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    total_debt = [0] * N\n    for i in range(N):\n        A, B = map(int, input().split())\n        total_debt[A - 1] += B\n        total_debt[i] -= B\n    return str(min(total_debt))\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    debt_list = []\n    for i in range(1, N+1):\n        debt_list.append(list(map(int, input_list[i].split())))\n\n    # Calculate the total debt owed by each person\n    total_debt = [0] * (N+1)\n    for debt in debt_list:\n        total_debt[debt[0]] -= debt[1]\n        total_debt[debt[1]] += debt[1]\n\n    # Find the maximum amount that can be given to one person to pay all debts\n    max_payback = max(total_debt)\n\n    # Calculate the minimum total amount of money the town has to give to some subset of the inhabitants\n    total_given = sum(total_debt)\n\n    return str(max_payback * N + total_given)\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, Dict[int, int]]:\n        N = int(input())\n        debts = {}\n        for i in range(1, N + 1):\n            person_a, person_b = map(int, input().split())\n            debts[person_a] = debts.get(person_a, 0) + person_b\n        return N, debts\n\n    def count_cycles(debts: Dict[int, int]) -> int:\n        seen = set()\n        count = 0\n        for person, debt in debts.items():\n            if person not in seen:\n                count += 1\n                seen.add(person)\n                current = person\n                while current in debts:\n                    current = debts[current]\n                    seen.add(current)\n        return count\n\n    def solve(N: int, debts: Dict[int, int]) -> int:\n        cycles = count_cycles(debts)\n        total_debt = sum(debts.values())\n        min_total = total_debt - (total_debt // cycles)\n        return min_total\n\n    N, debts = read_input()\n    min_total = solve(N, debts)\n    return str(min_total)"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_inhabitant_debt(id: int) -> List[Tuple[int, int]]:\n        return [debt for debt in debts if debt[0] == id]\n\n    def get_total_debt(id: int) -> int:\n        return sum([debt[1] for debt in get_inhabitant_debt(id)])\n\n    def get_max_debt(id: int) -> int:\n        return max([debt[1] for debt in get_inhabitant_debt(id)])\n\n    def get_total_debt_with_max_debt(id: int) -> int:\n        total_debt = get_total_debt(id)\n        max_debt = get_max_debt(id)\n        return total_debt + (N - total_debt) * max_debt\n\n    N, *debts = stdin.split()\n    N = int(N)\n    debts = [tuple(map(int, debt.split())) for debt in debts]\n\n    min_total_money = float('inf')\n    for inhabitant_id in range(1, N + 1):\n        total_debt_with_max_debt = get_total_debt_with_max_debt(inhabitant_id)\n        min_total_money = min(min_total_money, total_debt_with_max_debt)\n\n    return str(min_total_money)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = set()\n    for _ in range(M):\n        a, b = map(int, stdin.split()[M:M+2])\n        roads.add((a, b))\n        roads.add((b, a))\n        M += 2\n    roads = list(roads)\n    roads.sort(key=lambda x: x[0])\n    max_length = 0\n    for i in range(N):\n        stack = [(i, 1)]\n        visited = set()\n        visited.add(i)\n        current_length = 0\n        while stack:\n            node, distance = stack.pop()\n            visited.add(node)\n            if node == 1:\n                max_length = max(max_length, current_length)\n                break\n            for neighbor, road in roads:\n                if neighbor == node and (road, neighbor) not in visited:\n                    stack.append((neighbor, distance+1))\n                    visited.add((road, neighbor))\n                    current_length += 1\n    return max_length\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import combinations\n\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    roads = set(roads)\n\n    # Build adjacency matrix and create a graph\n    adj_matrix = defaultdict(set)\n    graph = defaultdict(set)\n    for a, b in roads:\n        adj_matrix[a].add(b)\n        adj_matrix[b].add(a)\n        graph[a].add(b)\n        graph[b].add(a)\n\n    # Find the longest ring\n    longest_ring = max(len(cycle) for cycle in combinations(range(1, N + 1), N))\n\n    # Find the maximum length of a simple path\n    longest_path = max(len(path) for path in graph.values())\n\n    # The longest race path is the maximum of the longest ring and the maximum length of a simple path\n    return max(longest_ring, longest_path)\n\n\ndef"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(visited, path_len, graph, start, end):\n        if start == end:\n            return path_len + 1\n        if visited[start]:\n            return -1\n        visited[start] = True\n        for neighbor in graph[start]:\n            path_len = dfs(visited, path_len, graph, neighbor, end)\n            if path_len != -1:\n                return path_len + 1\n        return -1\n\n    N, M = map(int, stdin.split()[:2])\n    graph = {i: [] for i in range(1, N + 1)}\n    for _ in range(M):\n        a, b = map(int, stdin.split()[:2])\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [False] * (N + 1)\n    longest_path = 0\n    for start in range(1, N + 1):\n        longest_path = max(longest_path, dfs(visited, 0, graph, start, 1))\n\n    return str(longest_path)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data[0].split())\n    graph = {i: [] for i in range(1, N + 1)}\n    for i in range(1, M + 1):\n        u, v = map(int, input_data[i].split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    def dfs(u, visited, path, longest):\n        visited[u] = True\n        path.append(u)\n        for v in graph[u]:\n            if not visited[v]:\n                dfs(v, visited, path, longest)\n        if len(path) > len(longest):\n            longest[:] = path\n\n    longest = []\n    for u in range(1, N + 1):\n        visited = [False] * (N + 1)\n        path = []\n        dfs(u, visited, path, longest)\n    return len(longest)\n\n\ninput_data = '''4 3\n1 2\n1 3\n2 4\n'''\n\nprint(solution(input_data))  # Output: 2\n\ninput_data = '''6 6\n1 2\n1 3\n2 4\n3 4\n3 5\n5 6\n'''\n\nprint(solution(input_data))  # Output: 5 "
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    roads = [list(map(int, input().split())) for _ in range(M)]\n\n    graph = [[] for _ in range(N + 1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(v, visited, path_len, path, max_len):\n        visited.add(v)\n        path.append(v)\n        path_len += 1\n\n        for w in graph[v]:\n            if w not in visited:\n                max_len = dfs(w, visited, path_len, path, max_len)\n\n        if len(path) > 1 and path[0] == 1:\n            max_len = max(max_len, path_len - 1)\n\n        path.pop()\n        visited.remove(v)\n        return max_len\n\n    return str(dfs(1, set(), 0, [], 0))\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n\n    adjacency_list = [[] for _ in range(N + 1)]\n    for u, v in roads:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    def dfs(u, visited, stack, cycles):\n        visited[u] = True\n        stack.append(u)\n        for v in adjacency_list[u]:\n            if not visited[v]:\n                dfs(v, visited, stack, cycles)\n            elif cycles[u] != v:\n                cycles[u] = v\n                cycles[v] = u\n        stack.pop()\n\n    def is_cycle(u, visited, cycles):\n        dfs(u, visited, [], cycles)\n        return cycles[1] != None\n\n    visited = [False] * (N + 1)\n    cycles = [None] * (N + 1)\n    longest_path_length = 0\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            if is_cycle(i, visited, cycles):\n                cycles_length = 0\n                cycles_nodes = []\n                u = cycles[1]\n                while u != None:\n                    cycles_nodes.append(u)\n                    u = cycles[u]\n                    cycles_length += 1\n                cycles_nodes.append(1)\n                longest_path_length = max(longest_path_length, cycles_length - 1)\n\n    return str(longest_path_length)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    adj_list = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u, v = map(int, stdin.split()[2:])\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    def dfs(v: int, parent: int) -> int:\n        max_len = 1\n        for w in adj_list[v]:\n            if w != parent:\n                max_len = max(max_len, dfs(w, v) + 1)\n        memo[v] = max_len\n        return max_len\n\n    memo = [0] * (N+1)\n    dfs(1, -1)\n    print(max(memo[1:]))"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Convert input to standard format\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Initialize graph\n    graph = {i: set() for i in range(1, N + 1)}\n    for a, b in roads:\n        graph[a].add(b)\n        graph[b].add(a)\n\n    def dfs(node: int, visited: set[int]) -> int:\n        visited.add(node)\n        max_length = 1\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                max_length = max(max_length, dfs(neighbor, visited))\n        return max_length\n\n    # Find longest path\n    max_length = 1\n    for node in graph:\n        visited = set()\n        max_length = max(max_length, dfs(node, visited))\n\n    return str(max_length)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n    adjacency_list = [[] for _ in range(N + 1)]\n    for road in roads:\n        adjacency_list[road[0]].append(road[1])\n        adjacency_list[road[1]].append(road[0])\n\n    def dfs(v, visited, stack):\n        visited[v] = True\n        for neighbor in adjacency_list[v]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n                dfs(neighbor, visited, stack)\n\n    def longest_path():\n        longest_path_length = 0\n        for start in range(1, N + 1):\n            visited = [False] * (N + 1)\n            stack = [start]\n            dfs(start, visited, stack)\n            for i in range(len(stack)):\n                longest_path_length = max(longest_path_length, i + 1)\n        return longest_path_length\n\n    return str(longest_path())"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(visited: list, graph: list, city: int, path_length: int, longest_path: int) -> int:\n        visited[city - 1] = True\n        path_length += 1\n        for neighbor in graph[city]:\n            if not visited[neighbor - 1]:\n                longest_path = max(longest_path, dfs(visited, graph, neighbor, path_length, longest_path))\n        return longest_path\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(N + 1)]\n    visited = [False] * N\n    for _ in range(M):\n        A, B = map(int, stdin.split()[:2])\n        graph[A].append(B)\n        graph[B].append(A)\n\n    longest_path = 0\n    for city in range(1, N + 1):\n        longest_path = max(longest_path, dfs(visited, graph, city, 1, longest_path))\n\n    return longest_path\n\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_chance(N: int, L: int, walk: List[int], adj_list: List[List[int]]) -> float:\n        def dfs(cur: int, depth: int, visited: List[bool]) -> bool:\n            if depth == L:\n                return True\n            if visited[cur]:\n                return False\n            visited[cur] = True\n            for nei in adj_list[cur]:\n                if dfs(nei, depth + 1, visited):\n                    return True\n            return False\n\n        visited = [False] * N\n        for i in range(L):\n            if not dfs(walk[i], 1, visited):\n                return 0.0\n        return 1.0\n\n    N, L = map(int, stdin.splitlines()[0].split())\n    walk = list(map(int, stdin.splitlines()[1].split()))\n    adj_list = [list(map(int, stdin.splitlines()[i].split()[1:])) for i in range(2, N + 2)]\n\n    return f\"{compute_chance(N, L, walk, adj_list):.6f}\"\n"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_probability_to_be_caught(captain_walk: list, sentry_walk: list, sentry_visited: set):\n        for i, room in enumerate(captain_walk):\n            if room in sentry_visited:\n                return i / len(captain_walk)\n        return 1.0\n\n    def get_neighbors(node: int, graph: list) -> list:\n        return graph[node]\n\n    def dfs(node: int, visited: set, captain_walk: list, sentry_walk: list, sentry_visited: set):\n        visited.add(node)\n        captain_walk.append(node)\n\n        if get_probability_to_be_caught(captain_walk, sentry_walk, sentry_visited) < 0.5:\n            return True\n\n        neighbors = get_neighbors(node, graph)\n        for neighbor in neighbors:\n            if neighbor not in visited:\n                sentry_visited.add(neighbor)\n                sentry_walk.append(neighbor)\n                if dfs(neighbor, visited, captain_walk, sentry_walk, sentry_visited):\n                    return True\n                sentry_visited.remove(neighbor)\n                sentry_walk.pop()\n        return False\n\n    def get_walk(captain_walk: list, sentry_walk: list, sentry_visited: set) -> float:\n        start_node = captain_walk[0]\n        visited = set()\n        visited.add(start_node)\n        sentry_visited.add(start_node)\n        sentry_walk.append(start_node)\n\n        return dfs(start_node, visited, captain_walk, sentry_walk, sentry_visited)\n\n    lines = stdin.strip().split('\\n')\n    n = int(lines[0])\n    l = int(lines[1])\n    captain_walk = list(map(int, lines[2].split()))\n    graph = [[] for _ in range(n)]\n    for i in range(3, len(lines), 2):\n        node = int(lines[i])\n        neighbors = list(map(int, lines[i + 1].split()))\n        graph[node] = neighbors\n\n    sentry_visited = set()\n    sentry_walk = []\n    chance_of_capture = get_walk(captain_walk, sentry_walk, sentry_visited)\n    return str(chance_of_capture)"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from math import comb\n    from collections import defaultdict\n\n    def get_neighbours(n, edges):\n        neighbours = defaultdict(list)\n        for i in range(n):\n            for j in range(edges[i]):\n                neighbours[i].append(edges[i + 1 + j])\n        return neighbours\n\n    def is_valid_move(visited, visited_rooms, neighbours, room):\n        if room in visited_rooms:\n            return False\n        if any(visited[neighbour] for neighbour in neighbours[room]):\n            return False\n        return True\n\n    def compute_chances(n, visited_rooms, neighbours, rooms):\n        chances = 1.0\n        for room in rooms:\n            if room not in visited_rooms:\n                valid_moves = [neighbour for neighbour in neighbours[room] if is_valid_move(visited, visited_rooms, neighbours, neighbour)]\n                chances *= len(valid_moves)\n            visited_rooms.add(room)\n        return chances\n\n    N, L, rooms, edges = map(int, stdin.splitlines())\n    neighbours = get_neighbours(N, edges)\n    visited = [False] * N\n    visited_rooms = set()\n    chances = compute_chances(N, visited_rooms, neighbours, rooms)\n    return chances / comb(N, L)"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(adj_list: List[List[int]], node: int) -> List[int]:\n        return adj_list[node]\n\n    def count_paths(adj_list: List[List[int]], start: int, end: int) -> int:\n        queue = [(start, 1)]\n        visited = set()\n        while queue:\n            node, count = queue.pop(0)\n            if node == end:\n                return count\n            if node not in visited:\n                visited.add(node)\n                queue.extend((neighbor, count + 1) for neighbor in get_neighbors(adj_list, node) if neighbor not in visited)\n        return 0\n\n    def count_all_paths(adj_list: List[List[int]], nodes: List[int]) -> int:\n        total_paths = 0\n        for node in nodes:\n            total_paths += count_paths(adj_list, 0, node)\n        return total_paths\n\n    def get_chance_of_success(nodes: int, adj_list: List[List[int]], walk: List[int]) -> float:\n        total_paths = count_all_paths(adj_list, walk)\n        all_paths = nodes * (nodes - 1)\n        chance_of_capture = 1 - total_paths / all_paths\n        return chance_of_capture\n\n    def parse_input(input_str: str) -> Tuple[int, int, List[int], List[List[int]]]:\n        lines = input_str.split('\\n')\n        nodes, rooms = map(int, lines[0].split())\n        walk = list(map(int, lines[1].split()))\n        adj_list = [[] for _ in range(nodes)]\n        for i in range(2, len(lines)):\n            adj_list[i - 2] = list(map(int, lines[i].split()[1:]))\n        return nodes, rooms, walk, adj_list\n\n    nodes, rooms, walk, adj_list = parse_input(stdin)\n    chance_of_capture = get_chance_of_success(nodes, adj_list, walk)\n    return f'{chance_of_capture:.6f}'"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, L, walk = input_parser(stdin)\n    graph = read_graph(N)\n    if not is_path_exist(graph, walk):\n        return \"0\"\n    success_prob = 1\n    for i in range(L):\n        if i == 0:\n            start = walk[0]\n        else:\n            start = walk[i-1]\n        end = walk[i]\n        if start == end:\n            success_prob *= 0.5\n        else:\n            success_prob *= graph[start][end]\n        if success_prob == 0:\n            return \"0\"\n    return str(success_prob)\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    l = int(input_list[1])\n    walk = list(map(int, input_list[2].split()))\n    adj_list = [list(map(int, input_list[i+3].split())) for i in range(n)]\n    \n    def dfs(graph, visited, node, parent, time, sentry_move_time, start_time):\n        visited[node] = True\n        if node in walk:\n            if time == walk.index(node):\n                return 0, True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if (neighbor == sentry_move_node and sentry_move_time == start_time) or (neighbor == parent and parent != sentry_move_node):\n                    return 0, True\n                new_time, success = dfs(graph, visited, neighbor, node, time+1, sentry_move_time, start_time)\n                if not success:\n                    return 0, True\n                new_time = max(new_time, dfs(graph, visited, sentry_move_node, node, time+1, sentry_move_time+1, start_time)[0])\n                return new_time, True\n        return 0, False\n    \n    total_time = 0\n    start_time = walk[0]\n    for i in range(len(walk)-1):\n        sentry_move_node = adj_list[sentry_move_time][sentry_move_time % len(sentry_move_time)]\n        visited = [False]*n\n        time, success = dfs(adj_list, visited, walk[i], None, 0, 0, start_time)\n        if not success:\n            return 0\n        time = max(time, dfs(adj_list, visited, sentry_move_node, None, 0, 0, start_time)[0])\n        total_time = max(total_time, time)\n        start_time = walk[i+1]\n    \n    return total_time/len(walk)\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, l, *walk = input_lines[0].split()\n    n = int(n)\n    l = int(l)\n    walk = list(map(int, walk))\n    adj_list = [[] for _ in range(n)]\n    for i in range(1, len(input_lines)):\n        node, *neighbours = map(int, input_lines[i].split())\n        node -= 1\n        for neighbour in neighbours:\n            adj_list[node].append(neighbour)\n\n    def dfs(node: int, visited: set) -> int:\n        visited.add(node)\n        for neighbour in adj_list[node]:\n            if neighbour not in visited:\n                dfs(neighbour, visited)\n\n    def count_subtrees(node: int, visited: set, parent: int) -> int:\n        visited.add(node)\n        count = 1\n        for neighbour in adj_list[node]:\n            if neighbour != parent and neighbour not in visited:\n                count += count_subtrees(neighbour, visited, node)\n        return count\n\n    def count_successful_walks(node: int, visited: set, parent: int, walk_path: list, time: int) -> int:\n        if time == 0:\n            return 1\n        if node in visited:\n            return 0\n        visited.add(node)\n        count = 0\n        for neighbour in adj_list[node]:\n            if neighbour != parent:\n                count += count_successful_walks(neighbour, visited.copy(), node, walk_path + [node], time - 1)\n        return count\n\n    subtrees = [0] * n\n    visited = set()\n    dfs(walk[0], visited)\n    for i in range(n):\n        subtrees[i] = count_subtrees(i, set(), -1)\n\n    chance = 0\n    for i in range(l):\n        chance += subtrees[walk[i]]\n    chance /= l\n    return f\"{chance:.6f}\""
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, L, *walk, *neighbors = [list(map(int, line.split())) for line in stdin.splitlines()]\n\n    adjacency_list = [[] for _ in range(N)]\n    for i, neighbor_count in enumerate(neighbors):\n        for neighbor in neighbor_count[1:]:\n            adjacency_list[i].append(neighbor)\n            adjacency_list[neighbor].append(i)\n\n    def bfs(start: int) -> int:\n        visited = [False] * N\n        visited[start] = True\n        queue = [start]\n        time = 0\n\n        while queue:\n            size = len(queue)\n            for _ in range(size):\n                node = queue.pop(0)\n                if node in [walk[i] for i in range(L)]:\n                    return time\n                for neighbor in adjacency_list[node]:\n                    if not visited[neighbor]:\n                        visited[neighbor] = True\n                        queue.append(neighbor)\n            time += 1\n\n        return -1\n\n    captain_chances = []\n    for start in walk:\n        captain_chances.append(bfs(start))\n\n    return round(sum(captain_chances) / L, 6)\n\ndef"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def dijkstra(graph, start, end):\n        dist = defaultdict(lambda: float('inf'))\n        dist[start] = 0\n        seen = set()\n\n        while end not in seen:\n            if not dist:\n                break\n            min_node = min(dist, key=dist.get)\n            seen.add(min_node)\n            dist.pop(min_node)\n\n            for neighbor, weight in graph[min_node].items():\n                new_dist = dist[min_node] + weight\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    prev[neighbor] = min_node\n\n        return dist, prev\n\n    def bfs(graph, start, end):\n        queue = [(start, 0)]\n        seen = set()\n\n        while queue:\n            node, depth = queue.pop(0)\n            if node == end:\n                return depth\n            if node in seen:\n                continue\n            seen.add(node)\n\n            for neighbor in graph[node]:\n                queue.append((neighbor, depth + 1))\n\n        return -1\n\n    N, L, walk, *graph = stdin.split('\\n')\n    N = int(N)\n    L = int(L)\n    graph = [list(map(int, line.split())) for line in graph]\n    prev = {}\n    dist, _ = dijkstra(graph, 0, L - 1)\n    total_distance = bfs(graph, 0, L - 1)\n\n    if total_distance == -1:\n        return '0.0'\n\n    chance_of_capture = sum(dist.values()) / total_distance\n    return '{:.6f}'.format(1 - chance_of_capture)\n"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    L = int(input_list[1])\n    walk = [int(x) for x in input_list[2].split()]\n    neighbours = {}\n    for i in range(3, 3 + N):\n        neighbours[i - 3] = [int(x) for x in input_list[i].split()]\n\n    graph = [[] for _ in range(N + 1)]\n    for i in range(N):\n        for j in neighbours[i]:\n            graph[i + 1].append(j + 1)\n            graph[j + 1].append(i + 1)\n\n    def dfs(node, parent, visited, depth):\n        if visited[node]:\n            return False\n        visited[node] = True\n        for child in graph[node]:\n            if child != parent:\n                if not dfs(child, node, visited, depth + 1):\n                    return False\n        return True\n\n    def is_safe():\n        visited = [False] * (N + 1)\n        for i in range(N):\n            if not dfs(walk[i], -1, visited, 0):\n                return False\n        return True\n\n    chance = 1.0\n    for i in range(L - 1):\n        chance *= 0.5\n    if is_safe():\n        return str(chance)\n    return \"0\"\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def intersect(r1, r2):\n        return max(r1[0], r2[0]), min(r1[1], r2[1])\n\n    def overlap(r1, r2):\n        i = intersect(r1, r2)\n        return i[1] - i[0] + 1\n\n    def intersects(r1, ranges):\n        for r2 in ranges:\n            if overlap(r1, r2) > 0:\n                return True\n        return False\n\n    n, c = map(int, stdin.split()[:2])\n    c = list(map(int, stdin.split()[2:]))\n    colors = set(c)\n\n    if len(colors) != n:\n        return \"IMPOSSIBLE\"\n\n    tapes = {color: [] for color in colors}\n    for i in range(n):\n        tapes[c[i]].append((i+1, i+2))\n\n    instructions = []\n    for color in colors:\n        tape = tapes[color]\n        for i, r in enumerate(tape):\n            for j in range(i+1, len(tape)):\n                if intersects(r, tape[j:]):\n                    continue\n                instructions.append((r[0], r[1], color))\n                break\n        tapes[color] = []\n\n    return str(len(instructions)) + \"\\n\" + \"\\n\".join(map(str, instructions))\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def generate_instructions(c: list, n: int) -> str:\n        if len(set(c)) != n:\n            return \"IMPOSSIBLE\"\n\n        instructions = []\n        color_map = {}\n        for i, color in enumerate(c):\n            if color not in color_map:\n                color_map[color] = 0\n            instructions.append([i, color_map[color], color])\n            color_map[color] += 1\n        return \" \".join(str(x) for x in [len(instructions)] + instructions)\n\n    n = int(stdin.split('\\n')[0])\n    c = list(map(int, stdin.split('\\n')[1].split()))\n    return generate_instructions(c, n)\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    colors = list(map(int, input_data[1].split()))\n\n    instructions = []\n    tape_pieces = {}\n\n    for i in range(1, n + 1):\n        color = colors[i - 1]\n        if color not in tape_pieces:\n            tape_pieces[color] = i\n            instructions.append([i, i, color])\n        else:\n            last_position = tape_pieces[color]\n            instructions.append([last_position + 1, i, color])\n            tape_pieces[color] = i\n\n    if len(set(tape_pieces.values())) == len(tape_pieces):\n        return \"\\n\".join([str(len(instructions))] + [f\"{i[0]} {i[1]} {i[2]}\" for i in instructions])\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    c = list(map(int, input_list[1].split()))\n\n    instructions = []\n    color_count = {}\n\n    for i in range(n):\n        color = c[i]\n        if color not in color_count:\n            color_count[color] = 0\n        color_count[color] += 1\n\n        if color_count[color] > 1:\n            return \"IMPOSSIBLE\"\n\n        if i == 0:\n            instructions.append([1, i+1, color])\n        elif c[i] != c[i-1]:\n            instructions.append([i+1, i+1, color])\n        else:\n            continue\n\n    return str(len(instructions)) + \"\\n\" + \"\\n\".join([f\"{l} {r} {c}\" for l, r, c in instructions]) "
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    colors = [int(x) for x in stdin.splitlines()[1].split()]\n\n    # If the colors are in ascending order, it is impossible to reconstruct the art\n    if colors == list(range(1, n+1)):\n        return \"IMPOSSIBLE\"\n\n    # Map each color to the positions where it appears\n    color_positions = {}\n    for i in range(n):\n        if colors[i] in color_positions:\n            color_positions[colors[i]].append(i)\n        else:\n            color_positions[colors[i]] = [i]\n\n    # Generate instructions to reconstruct the art\n    instructions = []\n    for color, positions in color_positions.items():\n        instructions.append(f\"{color} {positions[0] + 1} {positions[-1] + 1}\")\n\n    return len(instructions), \"\\n\".join(instructions)"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    colors = [int(x) for x in stdin.split('\\n')[1].split()]\n\n    # Determine the color set\n    color_set = set(colors)\n\n    if n == 1:\n        if len(color_set) == 1:\n            return \"1\\n1 1 {}\".format(colors[0])\n        else:\n            return \"IMPOSSIBLE\"\n\n    # Determine the color sequence\n    color_sequence = []\n    for i in range(1, n + 1):\n        color_sequence.append(colors.index(i) + 1)\n\n    # Create the instructions\n    instructions = []\n    for i in range(1, n + 1):\n        color_index = color_sequence.index(i)\n        color = colors[color_index]\n        if color not in color_set:\n            return \"IMPOSSIBLE\"\n        instructions.append((i, color))\n\n    return str(len(instructions)) + '\\n' + '\\n'.join(['{} {} {}'.format(l, r, c) for l, r, c in instructions]) "
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    c = list(map(int, stdin.splitlines()[1].split()))\n    tape = [0] * n\n    instructions = []\n\n    for i in range(n):\n        color = c[i]\n        if tape[color - 1] == 0:\n            tape[color - 1] = 1\n            instructions.append((i + 1, color))\n        else:\n            break\n\n    if len(instructions) == len(set(c)):\n        return str(len(instructions)) + \"\\n\" + \"\\n\".join([f\"{start} {end} {color}\" for start, end, color in instructions])\n    else:\n        return \"IMPOSSIBLE\"\n\n\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    c_list = list(map(int, input_list[1].split()))\n    if len(set(c_list)) < n:\n        return \"IMPOSSIBLE\"\n    \n    color_dict = {}\n    for i in range(1, n+1):\n        if c_list[i-1] not in color_dict:\n            color_dict[c_list[i-1]] = [i]\n        else:\n            color_dict[c_list[i-1]].append(i)\n    \n    output = []\n    for color in sorted(color_dict):\n        indices = color_dict[color]\n        for i in range(len(indices)-1):\n            output.append(f\"{indices[i]} {indices[i+1]-1} {color}\")\n    \n    return str(len(output)) + '\\n' + '\\n'.join(output)\n"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    color_list = list(map(int, input_list[1].split()))\n    \n    if len(set(color_list)) != n:\n        return \"IMPOSSIBLE\"\n    \n    instructions = []\n    for i in range(n):\n        if i == 0:\n            instructions.append([i+1, i+1, color_list[i]])\n        else:\n            if color_list[i] == color_list[i-1]:\n                instructions.append([i+1, i+1, color_list[i]])\n            else:\n                instructions.append([i+1, i+1, color_list[i]])\n                instructions.append([i, i, color_list[i-1]])\n    \n    return str(len(instructions)) + '\\n' + '\\n'.join([' '.join(map(str, instruction)) for instruction in instructions])\n\ndef"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    colors = input_list[1].split()\n    colors = list(map(int, colors))\n\n    result = []\n    colors_set = set(colors)\n    if len(colors_set) != n:\n        return \"IMPOSSIBLE\"\n    else:\n        for color in colors:\n            for i in range(1, n+1):\n                if colors[i-1] == color:\n                    result.append((i, n, color))\n                    break\n        return result\n\ndef"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sequences = []\n    for i in range(1, N+1):\n        sequence = list(map(int, input_data[i].split()[1:]))\n        sequences.append(sequence)\n    \n    def solve(sequences):\n        if not sequences:\n            return []\n        best_sequence = []\n        for i in range(len(sequences[0])):\n            sub_sequences = [seq[i:] for seq in sequences]\n            solution = solve(sub_sequences)\n            if not best_sequence or solution[0] < best_sequence[0]:\n                best_sequence = solution\n        return [sequences[0][0]] + best_sequence\n    \n    solution_sequence = solve(sequences)\n    return ' '.join(map(str, solution_sequence))\n"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    input_list = input_list[1:]\n    sequences = []\n    for i in range(N):\n        L = int(input_list[i])\n        sequence = [int(x) for x in input_list[i+1].split()]\n        sequences.append(sequence)\n    \n    best_sequence = []\n    for i in range(N):\n        sequence = sequences[i]\n        sequence.sort()\n        for value in sequence:\n            best_sequence.append(value)\n    \n    return ' '.join(map(str, best_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    input_list = input_list[1:]\n    sequences = []\n    for i in range(N):\n        L = int(input_list[i].split()[0])\n        sequence = list(map(int, input_list[i].split()[1:]))\n        sequences.append((L, sequence))\n\n    def is_better(a, b):\n        return a[0] < b[0] or (a[0] == b[0] and a[1] < b[1])\n\n    def merge_sequences(a, b):\n        merged = []\n        for i in range(max(len(a), len(b))):\n            if i < len(a) and i < len(b):\n                merged.append(a[i])\n                merged.append(b[i])\n            elif i < len(a):\n                merged.append(a[i])\n            else:\n                merged.append(b[i])\n        return merged\n\n    best_sequence = []\n    for L, sequence in sequences:\n        if len(best_sequence) == 0:\n            best_sequence = sequence\n        else:\n            merged_sequence = merge_sequences(best_sequence, sequence)\n            if is_better(sequence[0], merged_sequence[0]):\n                best_sequence = sequence\n            elif is_better(merged_sequence[0], merged_sequence[1]) and is_better(merged_sequence[1], sequence[0]):\n                best_sequence = merged_sequence\n\n    result = []\n    for i in range(len(best_sequence)):\n        result.append(str(best_sequence[i]))\n    return ' '.join(result)\n"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_better(a, b):\n        if a == b:\n            return False\n        return a < b\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if is_better(left[i], right[j]):\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result += left[i:]\n        result += right[j:]\n        return result\n\n    def reconstruct_sequence(sequence, solution):\n        result = []\n        for i, index in enumerate(sequence):\n            result.append(solution.pop(0))\n            sequence[i] = len(solution)\n        return result\n\n    N, *input_sequences = stdin.split(\"\\n\")\n    N = int(N)\n    input_sequences = [list(map(int, line.split()[1:])) for line in input_sequences]\n\n    all_cards = merge_sort([card for sequence in input_sequences for card in sequence])\n    solution = []\n    for i, card in enumerate(all_cards):\n        if is_better(card, all_cards[i + 1]):\n            solution.append(card)\n        else:\n            break\n\n    for sequence in input_sequences:\n        solution += reconstruct_sequence(sequence, solution)\n\n    return \" \".join(map(str, solution))"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    sequences = []\n    for i in range(1, N + 1):\n        sequence = [int(x) for x in input_list[i].split()]\n        sequences.append(sequence)\n    \n    sequences.sort(key=lambda x: x[0])\n    solution_sequence = []\n    for sequence in sequences:\n        solution_sequence.extend(sequence)\n    \n    return ' '.join(str(x) for x in solution_sequence)"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    def find_best_sequence(input_sequences):\n        sequences = []\n        for sequence in input_sequences:\n            sequences.append(merge_sort(sequence))\n        return merge_sort(sequences)\n\n    N = int(stdin.splitlines()[0])\n    input_sequences = []\n    for i in range(1, N + 1):\n        L, *sequence = map(int, stdin.splitlines()[i].split())\n        input_sequences.append(list(sequence))\n\n    best_sequence = find_best_sequence(input_sequences)\n    return ' '.join(str(card) for card in best_sequence)\n\n\ninput_data = '''\n3\n1 2\n1 100\n1 1\n2\n5 10 20 30 40 50\n2 28 27\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(input_data[i])\n        sequence = list(map(int, input_data[i + 1].split()))\n        sequences.append(sequence)\n\n    def merge_sort(arr):\n        if len(arr) <= 1:\n            return arr\n        mid = len(arr) // 2\n        left = merge_sort(arr[:mid])\n        right = merge_sort(arr[mid:])\n        return merge(left, right)\n\n    def merge(left, right):\n        result = []\n        i = j = 0\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                result.append(left[i])\n                i += 1\n            else:\n                result.append(right[j])\n                j += 1\n        result.extend(left[i:])\n        result.extend(right[j:])\n        return result\n\n    merged_sequences = merge_sort(sequences)\n    solution_sequence = []\n    for sequence in merged_sequences:\n        if not solution_sequence:\n            solution_sequence.extend(sequence)\n        else:\n            new_sequence = []\n            for card in sequence:\n                if card > solution_sequence[-1]:\n                    new_sequence.append(card)\n            solution_sequence.extend(new_sequence)\n\n    return ' '.join(map(str, solution_sequence))"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(stdin.split('\\n')[i].split()[0])\n        sequence = [int(x) for x in stdin.split('\\n')[i].split()[1:]]\n        sequences.append(sequence)\n\n    def get_score(sequence):\n        score = 0\n        for i in range(len(sequence) - 1):\n            score += sequence[i] - sequence[i+1]\n        return score\n\n    def compare_sequences(seq1, seq2):\n        if get_score(seq1) < get_score(seq2):\n            return -1\n        elif get_score(seq1) > get_score(seq2):\n            return 1\n        else:\n            return 0\n\n    best_sequence = []\n    for i in range(len(sequences[0])):\n        best_sequence.append(sequences[0][i])\n\n    for i in range(1, N):\n        new_sequence = []\n        for j in range(len(best_sequence) - 1):\n            new_sequence.append(best_sequence[j])\n        new_sequence.append(sequences[i][0])\n        for j in range(1, len(sequences[i])):\n            new_sequence.append(sequences[i][j])\n        sequences.append(new_sequence)\n\n        sequences.sort(key=lambda x: get_score(x))\n        best_sequence = sequences[0]\n\n    return ' '.join(map(str, best_sequence))\n\ninput_data = '''2\n5 10 20 30 40 50\n2 28 27'''\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    input_sequences = [sequence.split() for sequence in stdin.splitlines()[1:]]\n\n    # Create dictionary to store sequences and their lengths\n    sequences = {}\n    for sequence in input_sequences:\n        sequences[int(sequence[0])] = [int(card) for card in sequence[1:]]\n\n    # Sort sequences by length and then by their first card value\n    sorted_sequences = sorted(sequences.items(), key=lambda x: (len(x[1]), x[1][0]))\n\n    # Initialize variables for solution sequence\n    solution_sequence = []\n    current_sequence = sorted_sequences[0]\n    solution_sequence += current_sequence[1]\n\n    # Iterate through sorted sequences\n    for i in range(1, len(sorted_sequences)):\n        current_sequence = sorted_sequences[i]\n        current_sequence_value = current_sequence[1][0]\n\n        # Check if current card is better than previous card\n        if current_sequence_value < solution_sequence[-1]:\n            # If it is, add the card to the solution sequence\n            solution_sequence.append(current_sequence_value)\n        else:\n            # If it's not, add the previous card to the solution sequence and start a new sequence\n            solution_sequence.append(solution_sequence[-1])\n            solution_sequence += current_sequence[1]\n\n    # Convert solution_sequence to string and return\n    return \" \".join([str(card) for card in solution_sequence])\n"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def min_value(arr):\n        return min(arr, key=lambda x: (x[1], -x[0]))\n\n    def max_value(arr):\n        return max(arr, key=lambda x: (x[1], -x[0]))\n\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    sequences = []\n    for i in range(1, n + 1):\n        sequence = []\n        length = int(input_data[i])\n        for j in range(length):\n            value = int(input_data[i + j + 1])\n            sequence.append((j + 1, value))\n        sequences.append(sequence)\n\n    total_length = sum(len(sequence) for sequence in sequences)\n    result = [0] * total_length\n    for sequence in sequences:\n        sequence.sort(key=lambda x: x[1])\n\n    for i in range(total_length):\n        index, value = min_value(result)\n        result[index] = value\n        for sequence in sequences:\n            if sequence:\n                if sequence[0][1] < value:\n                    if sequence[0][0] > index:\n                        swap(result, index, sequence[0][0])\n                        swap(sequence, 0, index - sequence[0][0] + 1)\n                    else:\n                        swap(result, index, sequence[0][0] - 1)\n                        swap(sequence, 0, index - sequence[0][0] + 1)\n    return ' '.join(str(x) for x in result)\n"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    num_investigations = int(input_data[0])\n    num_suspects = 26\n    num_solutions = num_suspects * (num_suspects - 1) * (num_suspects - 2) // 6\n    num_solutions_left = 0\n    for i in range(1, num_investigations + 1):\n        suspect1, suspect2 = input_data[i].split()\n        player_number = int(input_data[i][2])\n        num_replies = int(input_data[i][3])\n        if player_number == 1:\n            if num_replies == 0:\n                num_solutions_left += num_solutions\n            elif num_replies == 1:\n                num_solutions_left += (num_suspects - 2) * num_solutions\n            elif num_replies == 2:\n                num_solutions_left += (num_suspects - 2) * (num_suspects - 2) * num_solutions\n            else:\n                return \"Inconsistent replies\"\n        elif player_number == 2:\n            if num_replies == 0:\n                num_solutions_left += num_solutions\n            elif num_replies == 1:\n                num_solutions_left += (num_suspects - 2) * num_solutions\n            elif num_replies == 2:\n                num_solutions_left += (num_suspects - 2) * (num_suspects - 2) * num_solutions\n            else:\n                return \"Inconsistent replies\"\n        else:\n            return \"Invalid player number\"\n    return num_solutions_left\n\ninput_data = \"0\"\nprint(solution(input_data))\n\ninput_data = \"3\\nAB 1 1\\nAC 2 1\\nBC 2 1\"\nprint(solution(input_data)) "
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    suspects = list(range(1, 27))\n    black_vienna_circle = []\n\n    for i in range(1, n + 1):\n        line = input_data[i].split()\n        player = int(line[1])\n        reply = int(line[2])\n\n        if player == 1:\n            suspects.remove(ord(line[0]) - 65)\n        elif player == 2:\n            if reply == 1:\n                black_vienna_circle.append(ord(line[0]) - 65)\n            elif reply == 2:\n                suspects.remove(ord(line[0]) - 65)\n\n    if len(black_vienna_circle) == 3:\n        return 1\n    elif len(black_vienna_circle) == 0:\n        return len(suspects) * 2\n    else:\n        return len([suspects.remove(suspect) for suspect in suspects if suspect not in black_vienna_circle])\n\ndef"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, *cases = stdin.split('\\n')\n    N = int(N)\n\n    def add(a, b):\n        return (a + b) % 26\n\n    def count(p1, p2, p1_cards, p2_cards):\n        p1_not_in_circle = 0\n        p2_not_in_circle = 0\n        p1_in_circle = 0\n        p2_in_circle = 0\n        for i in range(26):\n            if i not in p1_cards and i not in p2_cards:\n                if p1_not_in_circle < p1:\n                    p1_not_in_circle += 1\n                if p2_not_in_circle < p2:\n                    p2_not_in_circle += 1\n            elif i in p1_cards and i in p2_cards:\n                if p1_in_circle < p1:\n                    p1_in_circle += 1\n                if p2_in_circle < p2:\n                    p2_in_circle += 1\n            else:\n                if i in p1_cards:\n                    p1_in_circle += 1\n                else:\n                    p2_in_circle += 1\n        return (26 ** (p1_in_circle + p2_in_circle)) * (25 ** (p1_not_in_circle + p2_not_in_circle))\n\n    solutions = 0\n    for i in range(N):\n        s1, s2, p, rep = cases[i].split()\n        p = int(p)\n        rep = int(rep)\n        if p == 1:\n            p1_cards = set(ord(c) - ord('A') for c in s1 + s2)\n            p2_cards = set(ord(c) - ord('A') for c in cases[i + 1].split()[0] if p == 2)\n        else:\n            p2_cards = set(ord(c) - ord('A') for c in s1 + s2)\n            p1_cards = set(ord(c) - ord('A') for c in cases[i + 1].split()[0] if p == 1)\n        solutions += count(rep, 3 - rep, p1_cards, p2_cards)\n\n    return str(solutions)"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    num_inv = int(input_list[0])\n    player_list = []\n    for i in range(1, num_inv + 1):\n        player_list.append(tuple(input_list[i].split()[:2]))\n\n    def count_solutions(player_list):\n        def count_combinations(n, k):\n            return int(math.factorial(n) // (math.factorial(k) * math.factorial(n - k)))\n\n        num_players = max(player_list, key=lambda x: x[0])[0]\n        return count_combinations(23, 3) * count_combinations(26 - 3, num_players - 3)\n\n    return str(count_solutions(player_list))\n"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    hands = {}\n    for i in range(N):\n        line = input().split()\n        letter, hand, reply = line[0], int(line[1]), int(line[2])\n        if hand not in hands:\n            hands[hand] = {}\n        hands[hand][letter] = reply\n    \n    solutions = set()\n    for hand1 in hands:\n        for hand2 in hands:\n            if hand1 != hand2:\n                hand = {**hands[hand1], **hands[hand2]}\n                for letter in set(hand.keys()):\n                    if hand[letter] > 0:\n                        for i in range(hand[letter]):\n                            for letter2 in set(hand.keys()) - {letter}:\n                                hand_new = hand.copy()\n                                hand_new[letter2] -= 1\n                                if all(hand_new[letter] >= hand_new[letter2] for letter in set(hand.keys()) - {letter2}):\n                                    solutions.add(tuple(sorted([letter, letter2])))\n    \n    return str(len(solutions))"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    guesses = [tuple(input().split()) for _ in range(N)]\n\n    # Count the number of solutions\n    count = 0\n    for letter1 in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n        for letter2 in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n            if letter1 != letter2:\n                # Check if there is a solution\n                has_solution = True\n                for suspect1, suspect2, reply in guesses:\n                    if (suspect1, suspect2) == (letter1, letter2) or (suspect1, suspect2) == (letter2, letter1):\n                        if reply != 2:\n                            has_solution = False\n                            break\n                if has_solution:\n                    count += 1\n\n    return str(count * 260)"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    investigations = [input().split() for _ in range(N)]\n    adjacency_matrix = [[0] * 26 for _ in range(26)]\n    for src, dst, _ in investigations:\n        adjacency_matrix[ord(src) - ord('A')][ord(dst) - ord('A')] += 1\n\n    def count_solutions(n):\n        count = 0\n        for i in range(26):\n            if adjacency_matrix[i][i] == n:\n                count += 1\n        return count\n\n    for k in range(3):\n        count = count_solutions(k)\n        for i in range(26):\n            for j in range(i + 1, 26):\n                count += count_solutions(k + adjacency_matrix[i][j] + adjacency_matrix[j][i])\n                count -= count_solutions(k + adjacency_matrix[i][j] + adjacency_matrix[j][i]) * (k + adjacency_matrix[i][j] + adjacency_matrix[j][i] - 1)\n        print(count)"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def check_solution(black_vienna: set, players: dict, player_1: set, player_2: set) -> bool:\n        if black_vienna & player_1 or black_vienna & player_2:\n            return False\n        for suspects in black_vienna:\n            if suspects in players[1] and suspects in players[2]:\n                return False\n        return True\n\n    def count_solutions(black_vienna: set, players: dict) -> int:\n        count = 0\n        for player_1 in itertools.combinations(players[1], 3):\n            for player_2 in itertools.combinations(players[2], 3):\n                if check_solution(black_vienna, players, set(player_1), set(player_2)):\n                    count += 1\n        return count\n\n    import itertools\n\n    N = int(stdin.split('\\n')[0])\n    black_vienna = set(stdin.split('\\n')[1].split()[0])\n    players = {1: set(), 2: set()}\n    for line in stdin.split('\\n')[2:N + 2]:\n        suspects, player, reply = line.split()\n        players[int(player)].add(suspects)\n\n    count = count_solutions(set(black_vienna), players)\n\n    return str(count)"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, *input_data = stdin.split()\n    N = int(N)\n\n    black_vienna = set(chr(i) for i in range(ord('A'), ord('Z')+1))\n    player_1_cards = set()\n    player_2_cards = set()\n    black_vienna_members = set()\n\n    for i in range(0, N*2, 2):\n        suspect1, suspect2, reply = input_data[i], input_data[i+1], int(input_data[i+2])\n        if suspect1 not in black_vienna or suspect2 not in black_vienna:\n            continue\n\n        if i % 2 == 0:\n            player_1_cards.add(suspect1)\n            player_1_cards.add(suspect2)\n            black_vienna_members.add(suspect1)\n            black_vienna_members.add(suspect2)\n            for suspect in black_vienna.difference(player_1_cards):\n                if (suspect1, suspect2) in [(s, t) for s in black_vienna_members for t in black_vienna.difference(player_1_cards)] and reply == 1:\n                    player_2_cards.add(suspect)\n        else:\n            player_2_cards.add(suspect1)\n            player_2_cards.add(suspect2)\n            black_vienna_members.add(suspect1)\n            black_vienna_members.add(suspect2)\n            for suspect in black_vienna.difference(player_2_cards):\n                if (suspect1, suspect2) in [(s, t) for s in black_vienna_members for t in black_vienna.difference(player_2_cards)] and reply == 1:\n                    player_1_cards.add(suspect)\n\n    solutions = 0\n    for player_1_set in itertools.combinations(black_vienna.difference(player_1_cards), 3):\n        for player_2_set in itertools.combinations(black_vienna.difference(player_2_cards), 3):\n            if all(s not in black_vienna_members for s in player_1_set.union(player_2_set)):\n                solutions += 1\n\n    return str(solutions)\n"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    investigations = []\n    for _ in range(n):\n        line = input().split()\n        suspect1, suspect2, player, reply = line\n        investigations.append((suspect1, suspect2, int(reply)))\n\n    def is_admissible(suspects):\n        # Check if the number of suspects in the circle is 3\n        if len(suspects) != 3:\n            return False\n        # Check if the suspects are in the circle\n        for suspect in suspects:\n            if suspect in circle:\n                return True\n        return False\n\n    def count_admissible_solutions():\n        # Initialize the possible suspects\n        possible_suspects = set(string.ascii_uppercase)\n        # Initialize the circle with 3 random suspects\n        circle = set(random.sample(possible_suspects, 3))\n        # Remove the suspects from the possible suspects\n        possible_suspects -= circle\n        # Count the number of distinct admissible solutions\n        count = 0\n        for suspect in possible_suspects:\n            # Check if the suspect is in the circle\n            if suspect in circle:\n                continue\n            # Check the investigations with the suspect\n            investigations_suspect = [inv for inv in investigations if suspect in inv[:2]]\n            if all(inv[2] == 1 for inv in investigations_suspect):\n                # If all the investigations are positive, add the suspect to the circle\n                count += sum(is_admissible(circle | {suspect}) for circle in itertools.combinations(possible_suspects, 3))\n        return count\n\n    # Count the number of distinct admissible solutions\n    count = count_admissible_solutions()\n\n    return str(count)"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char == \"(\":\n            stack.append(char)\n        elif char == \")\":\n            if stack and stack[-1] == \"(\":\n                stack.pop()\n            else:\n                stack.append(char)\n        else:\n            pass\n    if not stack:\n        return \"possible\"\n    else:\n        return \"impossible\"\n\nn = int(input())\nbracket_seq = input()\nprint(solution(bracket_seq)) "
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for b in brackets:\n            if b == '(':\n                stack.append(b)\n            elif b == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def can_invert(brackets: str, l: int, r: int) -> bool:\n        count_left = brackets.count('(', l-1, r)\n        count_right = brackets.count(')', l-1, r)\n        return count_left > count_right\n\n    def invert(brackets: str, l: int, r: int) -> str:\n        return brackets[:l-1] + ')' * (r-l+1) + brackets[r:]\n\n    def check_inversion(brackets: str) -> bool:\n        n = len(brackets)\n        for l in range(1, n):\n            for r in range(l+1, n+1):\n                if can_invert(brackets, l, r):\n                    return invert(brackets, l, r)\n        return brackets\n\n    brackets = stdin.strip()\n    if is_valid(brackets):\n        return \"possible\"\n    else:\n        inverted_brackets = check_inversion(brackets)\n        if is_valid(inverted_brackets):\n            return \"possible\"\n        else:\n            return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for bracket in brackets:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def invert_segment(brackets: str, l: int, r: int) -> str:\n        brackets = list(brackets)\n        for i in range(l-1, r):\n            if brackets[i] == '(':\n                brackets[i] = ')'\n            else:\n                brackets[i] = '('\n        return ''.join(brackets)\n\n    n = len(stdin)\n    brackets = stdin\n    if is_valid(brackets):\n        return \"possible\"\n\n    for l in range(1, n):\n        for r in range(l, n):\n            if not is_valid(invert_segment(brackets, l, r)):\n                continue\n            return \"possible\"\n\n    return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for bracket in brackets:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def invert_segment(brackets: str, l: int, r: int) -> str:\n        return brackets[:l] + brackets[l:r].replace('(', ').replace(')', '(') + brackets[r:]\n\n    def make_valid(brackets: str, l: int, r: int) -> bool:\n        if not is_valid(brackets):\n            return False\n        if l > r:\n            return False\n        if brackets[l-1] == '(' and brackets[r] == ')':\n            return True\n        return False\n\n    def check_inversion(brackets: str) -> bool:\n        n = len(brackets)\n        for l in range(1, n+1):\n            for r in range(l, n+1):\n                if make_valid(brackets, l, r):\n                    return True\n        return False\n\n    brackets = stdin.strip()\n    if check_inversion(brackets):\n        return \"possible\"\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for bracket in sequence:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def make_valid(sequence: str, l: int, r: int) -> str:\n        stack = []\n        result = []\n        i = 0\n        while i < len(sequence):\n            if sequence[i] == '(':\n                stack.append(sequence[i])\n            elif sequence[i] == ')':\n                if not stack or stack.pop() != '(':\n                    result.append(sequence[i])\n                else:\n                    i += 1\n            i += 1\n        if l <= len(stack) <= r:\n            for _ in range(len(stack)):\n                result.append(')')\n        return ''.join(result)\n\n    n = len(stdin)\n    if n == 0:\n        return \"impossible\"\n    if is_valid(stdin):\n        return \"possible\"\n    for l in range(1, n):\n        for r in range(l, n):\n            new_sequence = make_valid(stdin, l, r)\n            if is_valid(new_sequence):\n                return \"possible\"\n    return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack and stack[-1] == '(':\n                stack.pop()\n            else:\n                stack.append(char)\n    if not stack:\n        return \"possible\"\n    return \"impossible\""
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s: str) -> bool:\n        stack = []\n        for bracket in s:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def make_valid(s: str, l: int, r: int) -> str:\n        stack = []\n        result = []\n        for i, bracket in enumerate(s):\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    result.append(bracket)\n                else:\n                    result.append(stack.pop())\n            if i + 1 == l:\n                break\n        result.extend(reversed(stack))\n        result.extend(s[i + 1:r])\n        return ''.join(result)\n\n    def is_invertible(s: str) -> bool:\n        stack = []\n        for bracket in s:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        if len(stack) > 1:\n            return False\n        if stack and s[-1] == '(':\n            return True\n        return False\n\n    n = len(stdin)\n    if is_valid(stdin):\n        return \"possible\"\n    for i in range(n):\n        for j in range(i, n):\n            if is_invertible(stdin[i:j + 1]):\n                s = make_valid(stdin, i + 1, j + 1)\n                if is_valid(s):\n                    return \"possible\"\n    return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    for char in stdin:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return 'impossible'\n            elif stack.pop() == '(':\n                return 'impossible'\n\n    return 'possible' if not stack else 'impossible'"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(sequence: str) -> bool:\n        stack = []\n        for bracket in sequence:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if stack and stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n        return len(stack) == 0\n\n    def make_valid(sequence: str, l: int, r: int) -> str:\n        left_brackets = sequence[:l].count('(')\n        right_brackets = sequence[:l].count(')')\n        inversions = abs(left_brackets - right_brackets)\n        if inversions > 1:\n            return False\n        elif inversions == 1:\n            if left_brackets > right_brackets:\n                sequence = sequence[:l] + ')' + sequence[l:]\n                sequence = sequence[:r] + '(' + sequence[r:]\n            else:\n                sequence = sequence[:r] + ')' + sequence[r:]\n                sequence = sequence[:l] + '(' + sequence[l:]\n        else:\n            if left_brackets > right_brackets:\n                sequence = sequence[:l] + ')' + sequence[l:]\n                sequence = sequence[:r] + '(' + sequence[r:]\n            elif left_brackets < right_brackets:\n                sequence = sequence[:r] + ')' + sequence[r:]\n                sequence = sequence[:l] + '(' + sequence[l:]\n            else:\n                pass\n        return sequence\n\n    n = len(stdin)\n    if not is_valid(stdin):\n        return \"impossible\"\n\n    for i in range(1, n):\n        for j in range(1, n):\n            if j > i:\n                valid = is_valid(make_valid(stdin, i, j))\n                if valid:\n                    return \"possible\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    stack = []\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if not stack:\n                return 'impossible'\n            left = stack.pop()\n            if i < left:\n                return 'impossible'\n            else:\n                if i - left > 1:\n                    if i - left == 2:\n                        if stdin[i-1] == ')':\n                            return 'impossible'\n                    else:\n                        return 'impossible'\n                if stdin[left-1] == '(':\n                    return 'impossible'\n                for j in range(left-1, i):\n                    if stdin[j] == '(':\n                        stdin[j], stdin[j+1] = stdin[j+1], stdin[j]\n    if stack:\n        return 'impossible'\n    return 'possible'\n\ndef"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    timetable = []\n    for i in range(1, M+1):\n        x, s, t, l = map(int, input_data[i].split())\n        timetable.append((x, s+l, t+l, l))\n\n    # Sort the timetable based on the station and departure time\n    timetable.sort(key=lambda x: (x[0], x[1]))\n\n    # Calculate the total time needed to reach each station\n    time_needed = [0] * (N+1)\n    for i in range(1, N+1):\n        time_needed[i] = time_needed[i-1] + timetable[i-1][2]\n\n    # Calculate the earliest start time for each station\n    earliest_start = [0] * (N+1)\n    for i in range(1, N+1):\n        for j in range(1, M+1):\n            if timetable[j-1][0] == i:\n                earliest_start[i] = max(earliest_start[i], timetable[j-1][1])\n\n    # Find the earliest start time for the first station and calculate the time needed\n    start_time = earliest_start[1]\n    end_time = start_time + time_needed[1]\n\n    # Check if the end time is within 30 minutes of reaching the last station\n    if end_time - time_needed[N] < 1800:\n        return start_time\n    else:\n        return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    timetable = []\n    for _ in range(M):\n        X, S, T, L = map(int, input().split())\n        timetable.append((X, S-L, T+L))\n    \n    timetable.sort(key=lambda x: (x[1], x[2]))\n    earliest_time = 0\n    for X, S, T in timetable:\n        if S < earliest_time:\n            continue\n        for X2, S2, T2 in timetable:\n            if S2 <= earliest_time:\n                break\n            if X2 == X + 1 and T2 - S2 < 1800:\n                earliest_time = T2\n                break\n    return str(earliest_time) if earliest_time > 0 else \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, int, int]]]:\n        N, M = map(int, input_str.split())\n        timetable = []\n        for _ in range(M):\n            X, S, T, L = map(int, input_str.split())\n            timetable.append((X, S, T, L))\n        return N, timetable\n\n    def find_earliest_journey(timetable: List[Tuple[int, int, int, int]], N: int) -> int:\n        def check_journey(start_time: int, end_time: int) -> bool:\n            for X, S, T, L in timetable:\n                if (start_time > S - L) or (end_time < T + L):\n                    return False\n            return True\n\n        earliest_start_time = 1800\n        while earliest_start_time < 1800 + 1800:\n            if check_journey(earliest_start_time, earliest_start_time + 1800):\n                return earliest_start_time\n            earliest_start_time += 1\n        return \"impossible\"\n\n    N, timetable = parse_input(stdin)\n    earliest_start_time = find_earliest_journey(timetable, N)\n    return str(earliest_start_time)"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    timetable = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    \n    def is_impossible(start_time: int) -> bool:\n        trains = [{'X': x, 'S': s, 'T': t, 'L': l} for x, s, t, l in timetable]\n        current_time = start_time\n        for train in trains:\n            current_time = max(current_time, train['S'] + train['L'])\n            current_time = min(current_time, train['T'] + train['L'])\n            if current_time >= train['T'] + 1800:\n                return True\n        return False\n    \n    start_time = 0\n    while not is_impossible(start_time):\n        start_time += 1\n    if start_time == 86400:\n        return \"impossible\"\n    else:\n        return start_time"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    timetable = []\n    for _ in range(M):\n        timetable.append(list(map(int, input().split())))\n    \n    # Sort the timetable by station and then by departure time\n    timetable.sort(key=lambda x: (x[0], x[1]))\n    \n    earliest_time = 0\n    for i in range(M):\n        X, S, T, L = timetable[i]\n        if i == 0:\n            earliest_time = S\n        else:\n            if earliest_time >= S - 1800:\n                continue\n            if earliest_time + (T - S) + L >= 1800:\n                return \"impossible\"\n        earliest_time = S + L\n    \n    return str(earliest_time)\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    timetable = [tuple(map(int, stdin.split()[2:])) for _ in range(M)]\n\n    def get_delay(start_time, delay, duration):\n        return start_time + delay + duration\n\n    def is_possible(start_time, station):\n        for train in timetable:\n            if train[0] == station:\n                return get_delay(start_time, train[3], train[2] - train[1]) < 1800\n        return False\n\n    for start_time in range(1800, 3600, 60):\n        if is_possible(start_time, 1):\n            return start_time\n\n    return \"impossible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    delays = [list(map(int, line.split())) for line in input_list[1:]]\n    delays.sort(key=lambda x: x[2] + x[3])\n\n    for i in range(N):\n        for delay in delays:\n            if delay[0] == i:\n                if delay[3] >= 1800:\n                    return str(delay[1])\n\n    return \"impossible\"\n\n\ninput_str = \"\"\"2 3\n1 1800 9000 1800\n1 2000 9200 1600\n1 2200 9400 1400\"\"\"\n\nprint(solution(input_str))  # Output: 1800\n\ninput_str = \"\"\"2 2\n1 1800 3600 1800\n1 1900 3600 1600\"\"\"\n\nprint(solution(input_str))  # Output: impossible "
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    timetable = []\n\n    for i in range(1, m + 1):\n        train = list(map(int, input_list[i].split()))\n        timetable.append(train)\n\n    # Sort timetable by departure time\n    timetable.sort(key=lambda x: x[1])\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if timetable[i][0] == timetable[j][0] and timetable[i][2] > timetable[j][2]:\n                timetable[i], timetable[j] = timetable[j], timetable[i]\n\n    # Check if any train departing from station 1 can reach its destination in 30 minutes or less\n    for train in timetable:\n        if train[0] == 1 and train[2] + 1800 < train[3]:\n            return str(train[1])\n\n    return \"impossible\""
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def delay_compensation(duration: int) -> int:\n        return max(0, (3600 * 2 - duration))\n\n    def earliest_train_journey(stations: int, scheduled_trains: int, timetable: list) -> int:\n        earliest_start_time = 21600  # 6:00 PM\n        for train in timetable:\n            start_station, start_time, end_time, delay = train\n            end_time += delay_compensation(delay)\n            if end_time < earliest_start_time:\n                earliest_start_time = end_time\n        return earliest_start_time\n\n    N, M = map(int, stdin.split()[:2])\n    timetable = [list(map(int, input().split())) for _ in range(M)]\n\n    if earliest_train_journey(N, M, timetable) < 1800:\n        return \"impossible\"\n    else:\n        return str(earliest_train_journey(N, M, timetable))\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    trains = []\n    for _ in range(M):\n        X, S, T, L = map(int, stdin.split()[2:6])\n        trains.append((X, S + L, T + L))\n    \n    trains.sort(key=lambda x: (x[0], x[1]))\n    start_time = 0\n    for i in range(N-1):\n        if start_time >= 1800:\n            break\n        route = [trains[j] for j in range(len(trains)) if trains[j][0] == i+1]\n        min_time = route[0][1]\n        for j in range(1, len(route)):\n            min_time = min(min_time, route[j][1])\n        start_time = max(start_time, min_time)\n    \n    return str(start_time) if start_time < 1800 else 'impossible'\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    \n    # Generate all possible pairs of players\n    player_pairs = [(f\"A{i}\", f\"B{j}\") for i in range(1, n+1) for j in range(1, n+1) if i != j]\n    \n    # Shuffle the player pairs to ensure randomness\n    import random\n    random.shuffle(player_pairs)\n    \n    # Divide the player pairs into rounds\n    num_rounds = (m-1) * n + 1\n    rounds = [player_pairs[i:i+num_rounds] for i in range(0, len(player_pairs), num_rounds)]\n    \n    # Add byes to rounds with missing players\n    for round in rounds:\n        if len(round) < num_rounds:\n            round.extend([(\"Bye\", \"Bye\") for _ in range(num_rounds - len(round))])\n    \n    # Print the schedule in the required format\n    result = []\n    for round in rounds:\n        round_schedule = []\n        for game in round:\n            round_schedule.append(f\"{'-'.join(game)}\")\n        result.append(' '.join(round_schedule))\n    \n    return '\\n'.join(result)\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players_per_team = n * m\n    \n    games_per_team = (m - 1) * n\n    total_games = games_per_team * m\n    \n    rounds = min(total_games, (m - 1) * n + 1)\n    \n    schedule = []\n    \n    for i in range(rounds):\n        for j in range(m):\n            for k in range(n):\n                if i % games_per_team == (games_per_team * (j + 1) + k):\n                    schedule.append(f\"{chr(65+j)}{k+1}-{chr(65+j+1)}{k+1}\")\n    \n    return \"\\n\".join(schedule)\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    def get_players(team: str) -> list:\n        return [f\"{team}{i}\" for i in range(1, n+1)]\n\n    def get_games(team1: list, team2: list) -> list:\n        return [f\"{p1}-{p2}\" for p1 in team1 for p2 in team2]\n\n    team1 = get_players(\"A\")\n    team2 = get_players(\"B\")\n    team3 = get_players(\"C\")\n\n    rounds = []\n\n    while team1:\n        game1 = get_games(team1, team2)\n        game2 = get_games(team1, team3)\n        game3 = get_games(team2, team3)\n        rounds.extend([game1, game2, game3])\n        team1.pop(0)\n        team2.pop(0)\n        team3.pop(0)\n\n    for round in rounds:\n        print(\" \".join(round))"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n * m > 100:\n        return \"Invalid input: n * m must be at most 100.\"\n\n    players = [f\"{team}{i}\" for team in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"[:m] for i in range(1, n + 1)]\n    rounds = []\n\n    for i in range(1, m):\n        for j in range(n):\n            for k in range(j + 1, n):\n                if j % 2 == k % 2:\n                    rounds.append(f\"{players[j]}-{players[k]}\")\n                else:\n                    rounds.append(f\"{players[k]}-{players[j]}\")\n\n    return \"\\n\".join(rounds[:m * n + 1])\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n\n    # Generate all possible pairs of players\n    pairs = [f\"A{i}A{j}\" for i in range(1, n+1) for j in range(1, i+1)] + \\\n            [f\"A{i}B{j}\" for i in range(1, n+1) for j in range(1, n+1)] + \\\n            [f\"B{i}A{j}\" for i in range(1, n+1) for j in range(1, i+1)] + \\\n            [f\"B{i}B{j}\" for i in range(1, n+1) for j in range(1, n+1)]\n\n    # Shuffle the pairs\n    import random\n    random.shuffle(pairs)\n\n    # Generate the playing schedule\n    playing_schedule = [pairs[i:i+m-1] for i in range(0, len(pairs), m-1)]\n\n    # Convert the schedule to output format\n    output = \"\"\n    for round in playing_schedule:\n        output += \" \".join(round) + \"\\n\"\n\n    return output"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            print(f\"A{i}{j}-B{i}{j+1} B{i}{j}-A{i}{j+1}\", end=\" \")\n        print()\n        for j in range(1, n+1):\n            print(f\"A{i}{j}-B{i}{j+1} A{i}{j+1}-B{i}{j}\", end=\" \")\n        print()"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [f\"A{i}\" for i in range(1, n + 1)] + [f\"B{i}\" for i in range(1, n + 1)]\n    games_per_round = (m - 1) * n\n    rounds = (games_per_round + m - 1) // m\n    result = []\n    for i in range(rounds):\n        current_round = []\n        for j in range(m - 1):\n            for k in range(n):\n                if k == j:\n                    continue\n                current_round.append(f\"{players[j*n+k]}-{players[j*n+k+n]}\")\n                if len(current_round) == games_per_round:\n                    result.append(\" \".join(current_round))\n                    break\n            if len(current_round) == games_per_round:\n                break\n        if len(current_round) < games_per_round:\n            current_round.extend([f\"{players[j*n+k]}-{players[j*n+k+n]}\" for j in range(m) for k in range(n) if k != j])\n            result.append(\" \".join(current_round))\n    return \"\\n\".join(result)\n\ninput_str = \"3 2\"\noutput_str = solution(input_str)\nprint(output_str)\n\ninput_str = \"2 3\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    team_size = n\n    num_teams = m\n\n    # Create a list of players for each team\n    teams = [f\"{chr(64 + i)}{j}\" for i in range(1, num_teams + 1) for j in range(1, team_size + 1)]\n\n    # Create a list of rounds\n    rounds = []\n    for team_a in range(num_teams):\n        for team_b in range(num_teams):\n            if team_a != team_b:\n                round_games = []\n                for player_a in range(team_size):\n                    for player_b in range(team_size):\n                        if player_a != player_b:\n                            round_games.append(f\"{teams[team_a * team_size + player_a]}-{teams[team_b * team_size + player_b]}\")\n                rounds.append(round_games)\n\n    # Remove rounds with more than one player with a bye\n    bye_rounds = [i for i, round_games in enumerate(rounds) if len([game for game in round_games if \"-\" in game]) > 1]\n    rounds = [round for i, round in enumerate(rounds) if i not in bye_rounds]\n\n    # Create a list of rounds with the same number of rounds as the given constraint\n    num_rounds = (num_teams * team_size * (num_teams * team_size - 1)) // 2\n    if len(rounds) < num_rounds:\n        rounds.extend(rounds)\n    elif len(rounds) > num_rounds:\n        rounds = rounds[:num_rounds]\n\n    # Convert the list of rounds into a string and return it\n    result = \"\\n\".join([\" \".join(game for game in round_games) for round_games in rounds])\n    return result"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    teams = [['A'+str(i) for i in range(1, n+1)], ['B'+str(i) for i in range(1, n+1)], ['C'+str(i) for i in range(1, n+1)], ['D'+str(i) for i in range(1, n+1)]]\n    rounds = []\n    for team in teams:\n        for player in team:\n            games = [player+'-'+opponent for opponent in team if opponent != player]\n            rounds += [games]\n    for i in range(m-1):\n        for player in teams[i]:\n            games = [player+'-'+opponent for opponent in teams[(i+1)%4] if opponent != player]\n            rounds += [games]\n    for round in rounds:\n        print(' '.join(round))\n    return"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    assert 1 <= n <= 25 and 2 <= m <= 25 and n * m <= 100\n\n    players = [f\"A{i}\" for i in range(1, n + 1)] + [f\"B{i}\" for i in range(1, n + 1)]\n    for i in range(2, m + 1):\n        players += [f\"C{i}\" for i in range(1, n + 1)]\n    rounds = []\n\n    def create_round():\n        for p in players:\n            others = [o for o in players if o != p]\n            for o in others:\n                rounds.append((p, o))\n\n    create_round()\n    rounds.sort()\n\n    while len(rounds) > (m - 1) * n + 1:\n        min_rounds = min([rounds.index((p, o)) for p, o in rounds])\n        rounds.pop(min_rounds)\n        create_round()\n\n    for round_num in range(len(rounds)):\n        game_str = \" \".join([f\"{p}-{o}\" for p, o in rounds[round_num:round_num + 1]])\n        print(game_str)\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    dimensions, layout = stdin.split(\"\\n\")\n    R, C = dimensions.split()\n    R, C = int(R), int(C)\n    \n    table_perimeter = 2 * (R + C - 2)\n    blocked_squares = 0\n    for row in layout.split():\n        blocked_squares += row.count(\"X\")\n    \n    free_squares = R * C - blocked_squares\n    max_guests = free_squares // table_perimeter\n    \n    return str(max_guests)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    apartment = stdin.split()[1:]\n    free_squares = []\n\n    for i, row in enumerate(apartment):\n        for j, cell in enumerate(row):\n            if cell == \".\":\n                free_squares.append((i, j))\n\n    for square in free_squares:\n        if len(free_squares) == 1:\n            return 1\n        perimeter = 2 * (R + C - 2)\n        guests = perimeter // len(free_squares)\n        if guests > len(free_squares):\n            return len(free_squares)\n        else:\n            free_squares.remove(square)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C, table_layout, free_squares = 0, 0, \"\", 0\n    for i, line in enumerate(stdin.splitlines()):\n        if i == 0:\n            R, C = map(int, line.split())\n            continue\n        free_squares += line.count(\".\")\n        table_layout += line\n\n    free_areas = table_layout.count(\".\")\n    if free_areas < 2:\n        return 0\n\n    perimeter = 2 * (R + C - free_areas)\n    max_guests = free_squares // perimeter\n    return max_guests\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C, input_rows = map(int, stdin.splitlines()[:2])\n    layout = [list(row) for row in stdin.splitlines()[2:]]\n    \n    # Find all possible table dimensions that fit in the apartment\n    table_dimensions = []\n    for r in range(1, R + 1):\n        for c in range(1, C + 1):\n            if all(layout[i][j] == '.' for i in range(r) for j in range(c)):\n                table_dimensions.append((r, c))\n    \n    # Find the table dimensions that can accommodate the most guests\n    max_guests = 0\n    for r, c in table_dimensions:\n        perimeter = 2 * (r + c)\n        guests = perimeter * (perimeter + 1) // 2\n        if guests > max_guests:\n            max_guests = guests\n    \n    return str(max_guests)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    apartment = stdin.split()[2:]\n    table_perimeter = 2 * (R + C - 2)\n    max_guests = 0\n\n    for i in range(R - 1):\n        for j in range(C - 1):\n            if apartment[i][j] == '.' and apartment[i][j + 1] == '.' and apartment[i + 1][j] == '.' and apartment[i + 1][j + 1] == '.':\n                guests = min(R - i - 1, C - j - 1) * 2\n                if guests > max_guests and guests == table_perimeter:\n                    max_guests = guests\n\n    return str(max_guests)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C, apartment, guests = 0, 0, \"\", 0\n    for i, line in enumerate(stdin.split(\"\\n\")):\n        if i == 0:\n            R, C = map(int, line.split())\n        else:\n            apartment += line\n    for i in range(R):\n        for j in range(C):\n            if apartment[i*C+j] == \".\":\n                guests += 1\n    return str(guests)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    layout = [list(line.strip()) for line in stdin.split('\\n')[1:R+1]]\n\n    def is_free(x, y):\n        return 0 <= x < R and 0 <= y < C and layout[x][y] == '.'\n\n    def count_neighbors(x, y):\n        return sum([is_free(x+dx, y+dy) for dx in [-1, 0, 1] for dy in [-1, 0, 1] if (dx, dy) != (0, 0)])\n\n    def is_valid(x, y, perimeter):\n        return is_free(x, y) and count_neighbors(x, y) == perimeter\n\n    def valid_tables():\n        for x in range(R):\n            for y in range(C):\n                for length in range(1, min(R-x, C-y)+1):\n                    if is_valid(x, y, 4*length-3):\n                        yield (x, y, length)\n\n    table_width, table_height, table_perimeter = max(valid_tables(), key=lambda t: t[2])\n    return table_perimeter"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = [input().split() for _ in range(R)]\n    \n    # find all possible table sizes\n    table_sizes = []\n    for r in range(1, R + 1):\n        for c in range(1, C + 1):\n            if all(grid[i][j] == '.' for i in range(r) for j in range(c)):\n                table_sizes.append((r, c))\n                \n    # find the largest table size that fits in the apartment\n    largest_table_size = (0, 0)\n    for size in table_sizes:\n        if size[0] * size[1] <= R * C:\n            largest_table_size = size\n            \n    # count the number of guests\n    guests = R * C - largest_table_size[0] * largest_table_size[1]\n    \n    return str(guests)\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C, apartment, perimeter = 0, 0, \"\", 0\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            R, C = map(int, line.split())\n        else:\n            apartment += line\n            perimeter += sum(1 for c in line if c == '.')\n\n    free_squares = apartment.count('.')\n    seats = free_squares // perimeter\n\n    return str(seats)\n"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    layout = stdin.split('\\n')[1:]\n    table_size = 0\n    for row in layout:\n        table_size += len(row) - row.count('.')\n    max_size = 2 * (R + C - 1)\n    if table_size > max_size:\n        return \"0\"\n    else:\n        return str(table_size)"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list.pop(0))\n\n    if n == 0:\n        return -1\n\n    tarot_cards = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, input_list.pop(0).split())\n        tarot_cards.append(((r, c), (a, b), p))\n\n    target_card = (-1, -1)\n    for card in tarot_cards:\n        if card[0] == (0, 0):\n            target_card = card\n            break\n\n    if target_card[0] == (-1, -1):\n        return -1\n\n    def get_cost(x: int, y: int) -> int:\n        for card in tarot_cards:\n            r, c, a, b, p = card\n            if r == x and c == y:\n                return p\n        return 0\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < 1001 and 0 <= y < 1001\n\n    def knight_moves(x: int, y: int) -> list[tuple[int, int]]:\n        return [(x + a, y + b) for a, b in [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]]\n\n    def dfs(x: int, y: int, target_x: int, target_y: int, visited: set[tuple[int, int]], path_cost: int, current_cards: set[tuple[int, int]]) -> int:\n        if x == target_x and y == target_y:\n            return path_cost\n\n        for move in knight_moves(x, y):\n            if is_valid(move[0], move[1]) and ((move[0], move[1]) not in visited) and (move in current_cards or not current_cards):\n                new_cards = current_cards.copy()\n                if move in current_cards:\n                    new_cards.remove(move)\n                else:\n                    new_cards.add(move)\n                visited.add((move[0], move[1]))\n                new_cost = path_cost + get_cost(move[0], move[1])\n                result = dfs(move[0], move[1], target_x, target_y, visited, new_cost, new_cards)\n                if result != -1:\n                    return result\n\n        return -1\n\n    return dfs(0, 0, target_card[0][0], target_card[0][1], set(), 0, set())"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def move(x, y, a, b):\n        return x + a, y + b\n\n    def is_valid(x, y):\n        return 0 <= x < max_x and 0 <= y < max_y\n\n    def min_cost(x, y, card, visited, cards):\n        if (x, y) in visited:\n            return visited[(x, y)]\n\n        if x == 0 and y == 0:\n            return 0\n\n        if card:\n            visited[(x, y)] = min_cost(x - card[0], y - card[1], None, visited, cards) + card[2]\n        else:\n            visited[(x, y)] = float('inf')\n            for a, b in [(-1, -2), (-1, 2), (1, -2), (1, 2), (2, 1), (-2, 1), (2, -1), (-2, -1)]:\n                if is_valid(x + a, y + b) and (x + a, y + b) in cards:\n                    visited[(x, y)] = min(visited[(x, y)], min_cost(x + a, y + b, cards[(x + a, y + b)], visited, cards))\n\n        return visited[(x, y)]\n\n    def main():\n        n = int(input())\n        cards = {}\n        max_x, max_y = 0, 0\n\n        for _ in range(n):\n            r, c, a, b, p = map(int, input().split())\n            cards[r, c] = (a, b, p)\n            max_x, max_y = max(max_x, r), max(max_y, c)\n\n        if not is_valid(1, 1) or not (1, 1) in cards:\n            return -1\n\n        min_cost_from_start = min_cost(1, 1, cards[(1, 1)], {}, cards)\n\n        if min_cost_from_start == float('inf'):\n            return -1\n\n        return min_cost_from_start\n\n    return str(main())"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(r: int, c: int, a: int, b: int) -> List[Tuple[int, int]]:\n        neighbors = []\n        for i in range(a + 1):\n            for j in range(b + 1):\n                neighbors.append((r - i, c - j))\n        return neighbors\n\n    def is_valid(r: int, c: int) -> bool:\n        return 0 <= r < 1001 and 0 <= c < 1001\n\n    def get_min_cost(graph: Dict[Tuple[int, int], List[Tuple[int, int, int, int]]], start: Tuple[int, int], end: Tuple[int, int]) -> int:\n        queue = [(0, start)]\n        visited = {start}\n        while queue:\n            cost, node = heapq.heappop(queue)\n            if node == end:\n                return cost\n            for neighbor, a, b, p in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    heapq.heappush(queue, (cost + p, neighbor))\n        return -1\n\n    n = int(stdin.readline().strip())\n    cards = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.readline().strip().split())\n        cards.append((r, c, a, b, p))\n\n    graph = {}\n    for r, c, a, b, p in cards:\n        if is_valid(r, c):\n            neighbors = get_neighbors(r, c, a, b)\n            for nr, nc in neighbors:\n                if is_valid(nr, nc):\n                    graph.setdefault((r, c), []).append((nr, nc, a, b, p))\n\n    start = (cards[0][0], cards[0][1])\n    end = (0, 0)\n    return get_min_cost(graph, start, end)\n"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_moves(a, b):\n        return [(-a, -b), (a, -b), (-a, b), (a, b), (b, a), (-b, a), (b, -a), (-b, -a)]\n\n    def get_distance(pos1, pos2):\n        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\n\n    def get_min_cost(pos, cards, visited):\n        min_cost = float('inf')\n        for card in cards:\n            if card not in visited:\n                visited.add(card)\n                for move in get_next_moves(card[2], card[3]):\n                    dist = get_distance(move, pos)\n                    if dist == 0:\n                        min_cost = min(min_cost, card[4])\n                    else:\n                        min_cost = min(min_cost, card[4] + get_min_cost((move[0] + pos[0], move[1] + pos[1]), cards, visited))\n        return min_cost\n\n    n = int(stdin.splitlines()[0])\n    cards = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    if (0, 0) in [card[:2] for card in cards]:\n        return 0\n\n    min_cost = float('inf')\n    for card in cards:\n        if card[2] == -10**9 and card[3] == -10**9:\n            visited = {card}\n            min_cost = min(min_cost, get_min_cost((card[0], card[1]), cards, visited))\n            if min_cost == 0:\n                break\n\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_valid_moves(a: int, b: int) -> list:\n        return [(a-i, b-j) for i in range(1, a+1) for j in range(1, b+1)]\n\n    def calculate_cost(a: int, b: int, x: int, y: int) -> int:\n        return abs(x - a) + abs(y - b)\n\n    def calculate_minimum_cost(cards: list, start_x: int, start_y: int) -> int:\n        visited = set()\n        queue = [(start_x, start_y, 0)]\n\n        while queue:\n            x, y, cost = queue.pop(0)\n\n            if (x, y) == (0, 0):\n                return cost\n\n            if (x, y) in visited:\n                continue\n\n            visited.add((x, y))\n\n            for a, b in cards:\n                for move in get_valid_moves(a, b):\n                    new_x, new_y = x + move[0], y + move[1]\n\n                    if (new_x, new_y) in visited:\n                        continue\n\n                    queue.append((new_x, new_y, cost + calculate_cost(a, b, new_x, new_y)))\n\n        return -1\n\n    def parse_input(stdin: str) -> tuple:\n        n = int(stdin.splitlines()[0])\n        cards = [(int(x[0]), int(x[1]), int(x[2]), int(x[3]), int(x[4])) for x in [x.split() for x in stdin.splitlines()[1:]]]\n        start_x, start_y = cards[0][0], cards[0][1]\n        return n, cards, start_x, start_y\n\n    n, cards, start_x, start_y = parse_input(stdin)\n    return str(calculate_minimum_cost(cards, start_x, start_y))"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_moves(a, b):\n        return [(a - 2, b - 1), (a - 1, b - 2), (a + 1, b - 2), (a + 2, b - 1), (a + 2, b + 1), (a + 1, b + 2), (a - 1, b + 2), (a - 2, b + 1)]\n\n    def is_valid(pos, board):\n        return all(0 <= r < len(board) and 0 <= c < len(board[0]) for r, c in pos)\n\n    def min_cost(pos, board):\n        if not is_valid(pos, board):\n            return float('inf')\n\n        if board[pos[0]][pos[1]] is None:\n            return min(min_cost((r, c) if a == b else (r + a, c + b), board) for a, b in find_moves(*pos))\n        else:\n            return 0\n\n    n, *cards = stdin.splitlines()\n    n = int(n)\n    board = [[None for _ in range(1001)] for _ in range(1001)]\n\n    for card in cards:\n        r, c, a, b, p = map(int, card.split())\n        board[r][c] = (a, b, p)\n\n    pos = cards[0].split()\n    pos = tuple(map(int, pos))\n    if pos == (0, 0):\n        return 0\n\n    return min_cost(pos, board)\n"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_cost(positions: list, card_prices: dict) -> int:\n        def can_reach(pos1, pos2):\n            return abs(pos1[0] - pos2[0]) <= a and abs(pos1[1] - pos2[1]) <= b\n\n        def update_positions(new_positions, card, positions):\n            if card in new_positions:\n                new_positions[card].append(positions[card][0])\n            else:\n                new_positions[card] = [positions[card][0]]\n            positions[card] = new_positions[card][-1]\n\n        def min_cost(positions: list, card_prices: dict, position: tuple) -> int:\n            if position == (0, 0):\n                return 0\n            if position in positions:\n                return positions[position]\n\n            min_costs = [float('inf')] * 8\n            for card, price in card_prices.items():\n                if can_reach(position, positions[card]):\n                    new_positions = positions.copy()\n                    update_positions(new_positions, card, positions)\n                    min_costs[card] = min_cost(new_positions, card_prices, (0, 0)) + price\n\n            min_cost = min(min_costs)\n            positions[position] = min_cost\n            return min_cost\n\n        positions = {(r, c): (r, c) for r, c, a, b, p in positions}\n        min_cost = min_cost(positions, card_prices, (0, 0))\n        return min_cost if min_cost != float('inf') else -1\n\n    def read_input(stdin: str) -> tuple:\n        n = int(stdin.split()[0])\n        positions = [(int(x), int(y), int(a), int(b), int(p)) for x, y, a, b, p in zip(*[iter(stdin.split()[1:])] * 5)]\n        return n, positions\n\n    n, positions = read_input(stdin)\n    card_prices = {(r, c): p for r, c, a, b, p in positions}\n    min_cost = calculate_cost(positions, card_prices)\n    return str(min_cost)"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 0:\n        return \"0\"\n\n    tarot_cards = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, stdin.split())\n        tarot_cards.append(((r, c), (a, b), p))\n\n    queue = [(0, 0, [])]\n    visited = set()\n    while queue:\n        cost, pos, path = queue.pop(0)\n        if pos == (0, 0):\n            return cost\n        if (pos, frozenset(path)) in visited:\n            continue\n        visited.add((pos, frozenset(path)))\n\n        for move in [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]:\n            x, y = pos\n            x += move[0]\n            y += move[1]\n            if x == 0 and y == 0:\n                continue\n\n            for card, a, b in [(r, a, b) for r, a, b, p in tarot_cards if r == pos]:\n                dx, dy = a, b\n                dx += move[0]\n                dy += move[1]\n                if dx == 0 and dy == 0:\n                    queue.append((cost + p, (x, y), path + [(card, (dx, dy))]))\n\n    return -1\n"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data.pop(0))\n    cards = [tuple(map(int, card.split())) for card in input_data]\n\n    def get_neighbors(x, y, a, b):\n        return [(x + a, y + b), (x - a, y - b), (x + b, y + a), (x + b, y - a), (x - b, y + a), (x - b, y - a), (x - a, y + b), (x + a, y - b)]\n\n    def calculate_cost(x, y, a, b, cards):\n        cost = 0\n        for card_x, card_y, _, _, price in cards:\n            for i, (nx, ny) in enumerate(get_neighbors(card_x, card_y, a, b)):\n                if nx == x and ny == y:\n                    return price + cost\n                cost += price\n        return -1\n\n    def check_path(x, y, a, b, cards, visited):\n        if x == 0 and y == 0:\n            return 0\n        if (x, y) in visited:\n            return visited[(x, y)]\n        visited[(x, y)] = -1\n        min_cost = float('inf')\n        for nx, ny in get_neighbors(x, y, a, b):\n            if (nx, ny) in visited:\n                min_cost = min(min_cost, visited[(nx, ny)] + calculate_cost(nx, ny, a, b, cards))\n            else:\n                min_cost = min(min_cost, check_path(nx, ny, a, b, cards, visited) + calculate_cost(nx, ny, a, b, cards))\n        visited[(x, y)] = min_cost\n        return min_cost\n\n    visited = {}\n    initial_x, initial_y, initial_a, initial_b, _ = cards[0]\n    cost = check_path(initial_x, initial_y, initial_a, initial_b, cards, visited)\n    return cost if cost != float('inf') else -1\n"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    card_positions = []\n    for _ in range(n):\n        r, c, a, b, p = map(int, input().split())\n        card_positions.append((r, c, a, b, p))\n\n    def is_valid(pos, visited):\n        if pos == (0, 0):\n            return True\n        if pos in visited:\n            return False\n        visited.add(pos)\n        for i in range(1, 9):\n            r, c = pos\n            dr, dc = [(a, b) for a, b in ((-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)) if abs(a) == abs(b) and i == a + b][0]\n            if 0 <= r + dr < 1000 and 0 <= c + dc < 1000 and is_valid((r + dr, c + dc), visited):\n                return True\n        return False\n\n    min_cost = float('inf')\n    for card in card_positions:\n        r, c, a, b, p = card\n        if is_valid((r, c), set()):\n            min_cost = min(min_cost, p)\n\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, S = stdin.split()\n    N = int(N)\n    S = str(S)\n\n    # Helper function to check if a subset can be formed\n    def is_valid(subset: str) -> bool:\n        if int(subset) % 3 != 0:\n            return False\n        return True\n\n    # Find valid subsets\n    valid_subsets = [subset for i in range(N) for subset in itertools.combinations(S, i+1) if is_valid(\"\".join(subset))]\n\n    # Compute the number of valid subsets modulo 10^9 + 7\n    result = len(valid_subsets) % (10**9 + 7)\n\n    return str(result)"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    S = str(S)\n\n    def is_valid(subset: str) -> bool:\n        if len(subset) > 1 and subset[0] == '0':\n            return False\n        return all(c in '361' for c in subset)\n\n    valid_subsets = [S[i:j] for i in range(len(S)) for j in range(i + 1, len(S) + 1) if is_valid(S[i:j])]\n    return str(len(valid_subsets) % (10**9 + 7))\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(S: str) -> bool:\n        if S[0] == '0':\n            return False\n        num = int(S)\n        if num % 3 == 0:\n            return True\n        return False\n\n    def count_valid_subsets(S: str) -> int:\n        count = 0\n        for i in range(len(S)):\n            if is_valid(S[:i+1]):\n                count += count_valid_subsets(S[i+1:])\n        return (count + 1) % (10**9 + 7)\n\n    N, S = map(str, stdin.split('\\n'))\n    N = int(N)\n    S = S.lstrip('0')\n    if not S:\n        return 0\n    return count_valid_subsets(S)"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    B = stdin[1]\n\n    # Function to check if a number is divisible by 3\n    def is_divisible_by_3(num: str) -> bool:\n        return sum(int(d) for d in num) % 3 == 0\n\n    # Function to find valid subsets\n    def find_valid_subsets(num: str) -> int:\n        count = 0\n        for i in range(len(num) + 1):\n            for j in range(i + 1, len(num) + 1):\n                subset = num[i:j]\n                if is_divisible_by_3(subset):\n                    count += 1\n        return count\n\n    # Compute the value of S ByteConn333ct dollars in Canadian dollars\n    valid_subsets = find_valid_subsets(B)\n    value = valid_subsets % (10**9 + 7)\n\n    return str(value)\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    b = input_data[1]\n    valid_subsets = set()\n\n    def is_valid_subset(s):\n        if not s:\n            return True\n        if s[0] == '0':\n            return False\n        for i in range(len(s)):\n            if int(s[i]) % 3 == 0:\n                valid_subsets.add(s[:i] + s[i+1:])\n        return any(is_valid_subset(subset) for subset in valid_subsets)\n\n    if is_valid_subset(b):\n        return len(valid_subsets) % (10**9 + 7)\n    else:\n        return 0\n\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    S = stdin.splitlines()[1]\n\n    def is_valid(s: str) -> bool:\n        if not s.isdigit():\n            return False\n        if s[0] == '0':\n            return False\n        return True\n\n    def count_valid_subsets(s: str) -> int:\n        mod = 10**9 + 7\n        count = 0\n        for i in range(len(s) + 1):\n            for j in range(i + 1, len(s) + 1):\n                subset = int(s[i:j])\n                if is_valid(str(subset)):\n                    count += 1\n        return count % mod\n\n    return str(count_valid_subsets(S))\n\n\ndef"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    b = stdin.split('\\n')[1]\n\n    # Step 1: Convert to list of digits\n    digits = [int(digit) for digit in b]\n\n    # Step 2: Determine valid subsets\n    valid_subsets = set()\n    def backtrack(digits, subset, index):\n        if index == len(digits):\n            if subset not in valid_subsets:\n                valid_subsets.add(subset)\n            return\n        backtrack(digits, subset, index + 1)\n        if digits[index] % 3 == 0:\n            backtrack(digits, subset * 10 + digits[index], index + 1)\n\n    backtrack(digits, 0, 0)\n\n    # Step 3: Compute number of valid subsets modulo 10^9 + 7\n    result = len(valid_subsets) % (10**9 + 7)\n\n    return str(result)\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split('\\n'))\n    valid_subsets = set()\n    \n    def backtrack(start: int, subset: str):\n        if start == len(S) and int(subset) % 3 == 0:\n            valid_subsets.add(subset)\n            return\n        \n        for i in range(start, len(S)):\n            if int(subset + S[i]) % 3 == 0:\n                backtrack(i + 1, subset + S[i])\n    \n    backtrack(0, '')\n    return str(len(valid_subsets))\n"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin.split('\\n')[0])\n    b = stdin.split('\\n')[1]\n\n    # define a helper function to check if a number is divisible by 3\n    def is_divisible_by_3(num: str) -> bool:\n        sum = 0\n        for digit in num:\n            sum += int(digit)\n        return sum % 3 == 0\n\n    # compute the number of valid subsets\n    valid_subsets = 0\n    for i in range(n):\n        if is_divisible_by_3(b[:i+1]):\n            valid_subsets += 1\n    # take modulo 10^9 + 7\n    valid_subsets %= (10**9 + 7)\n\n    return str(valid_subsets)"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    S = str(S)\n    \n    def is_valid(subset: str) -> bool:\n        if not subset:\n            return False\n        total = sum(int(digit) for digit in subset)\n        return total % 3 == 0\n    \n    valid_subsets = 0\n    for i in range(1, len(S)+1):\n        for subset in itertools.combinations(S, i):\n            if is_valid(''.join(subset)):\n                valid_subsets += 1\n    \n    return valid_subsets % (10**9 + 7)\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_cost(distances: list, costs: list, g: int) -> int:\n        n = len(distances)\n        if n == 1:\n            return costs[0]\n        if n == 2:\n            return min(costs[0] + costs[1], costs[0] + costs[1] * (distances[1] - distances[0]) / g)\n        \n        mid = n // 2\n        left_distances = distances[:mid]\n        left_costs = costs[:mid]\n        right_distances = distances[mid:]\n        right_costs = costs[mid:]\n        \n        left_cost = find_min_cost(left_distances, left_costs, g)\n        right_cost = find_min_cost(right_distances, right_costs, g)\n        \n        total_cost = left_cost + right_cost\n        \n        if total_cost <= g:\n            return total_cost\n        \n        left_total_distance = sum(left_distances)\n        right_total_distance = sum(right_distances)\n        total_distance = left_total_distance + right_total_distance\n        cross_distances = [distances[0] + left_total_distance] + [distances[i] + left_total_distance + right_total_distance * (i - mid) / n for i in range(1, n)]\n        cross_costs = [costs[0] + left_cost] + [costs[0] + left_cost + right_costs[i] * (cross_distances[i] - cross_distances[i - 1]) / g for i in range(1, n)]\n        \n        return min(total_cost, find_min_cost(cross_distances, cross_costs, g))\n\n    stdin = stdin.strip().split('\\n')\n    n, g = map(int, stdin[0].split())\n    distances = []\n    costs = []\n    for line in stdin[1:]:\n        distance, cost = map(int, line.split())\n        distances.append(distance)\n        costs.append(cost)\n    if distances[-1] * distances[-1] > 4 * 10 ** 10:\n        return \"cancel road trip\"\n    else:\n        return find_min_cost(distances, costs, g)"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, l, r, x):\n        while l <= r:\n            mid = l + (r - l) // 2\n            if arr[mid][0] == x:\n                return arr[mid][1]\n            elif arr[mid][0] < x:\n                l = mid + 1\n            else:\n                r = mid - 1\n        return float('inf')\n\n    def distance_cost_sort(arr):\n        arr.sort(key=lambda x: x[0])\n        return arr\n\n    def min_cost(n, g, gas_stations):\n        gas_stations = distance_cost_sort(gas_stations)\n        total_cost = 0\n        i = 0\n        while i < n and total_cost < g:\n            distance, cost = gas_stations[i]\n            total_cost += binary_search(gas_stations, i, n - 1, distance) * cost\n            i += 1\n        if i == n:\n            return total_cost\n        else:\n            return float('inf')\n\n    n, g = map(int, stdin.split()[0:2])\n    gas_stations = [tuple(map(int, stdin.split()[2 * i:2 * i + 2])) for i in range(n)]\n    result = min_cost(n, g, gas_stations)\n    if result == float('inf'):\n        return \"cancel road trip\"\n    else:\n        return result\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, g = map(int, input_list[0].split())\n    gas_stations = []\n    for i in range(1, n+1):\n        distance, cost = map(int, input_list[i].split())\n        gas_stations.append((distance, cost))\n\n    gas_stations.sort(key=lambda x: x[0])\n\n    if gas_stations[-1][0] <= 2 * g:\n        total_cost = 0\n        current_gas_station = 0\n        while current_gas_station < n:\n            total_cost += gas_stations[current_gas_station][1] * g\n            current_gas_station += 1\n        return total_cost\n    else:\n        return \"cancel road trip\"\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, g = map(int, inputs[0].split())\n    gas_stations = []\n\n    for i in range(1, n + 1):\n        d, c = map(int, inputs[i].split())\n        gas_stations.append((d, c))\n\n    # Sort the gas stations by their distance\n    gas_stations.sort(key=lambda x: x[0])\n\n    # Initialize variables\n    total_cost = 0\n    current_distance = 0\n    current_fuel = g\n\n    # Traverse the gas stations\n    for distance, cost in gas_stations:\n        if current_fuel >= distance:\n            # Refuel to cover the distance to the next gas station\n            fuel_needed = distance\n            fuel_cost = cost * distance\n            if fuel_cost <= current_fuel:\n                current_fuel -= fuel_cost\n                total_cost += fuel_cost\n            else:\n                # Can't refuel enough to cover the distance\n                return \"cancel road trip\"\n        else:\n            # Can't refuel at this gas station\n            return \"cancel road trip\"\n\n    return total_cost\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(gas_stations: list, fuel_tank_capacity: int) -> int:\n        n = len(gas_stations)\n        if n == 1:\n            return gas_stations[0][1]\n\n        min_cost = float('inf')\n        prev_station = gas_stations[0]\n        for i in range(1, n):\n            curr_station = gas_stations[i]\n            remaining_distance = curr_station[0] - prev_station[0]\n            fuel_needed = remaining_distance / 10\n            if fuel_needed > fuel_tank_capacity:\n                return \"cancel road trip\"\n\n            min_cost += min(curr_station[1], prev_station[1] + fuel_needed * (curr_station[0] - prev_station[0]))\n            prev_station = curr_station\n\n        return min_cost\n\n    def parse_input(stdin: str) -> list:\n        lines = stdin.split('\\n')\n        n, fuel_tank_capacity = map(int, lines[0].split())\n        gas_stations = []\n        for line in lines[1:]:\n            distance, cost_per_gallon = map(int, line.split())\n            gas_stations.append((distance, cost_per_gallon))\n        return n, fuel_tank_capacity, gas_stations\n\n    n, fuel_tank_capacity, gas_stations = parse_input(stdin)\n    min_cost = get_min_cost(gas_stations, fuel_tank_capacity)\n    return str(min_cost) if min_cost != \"cancel road trip\" else min_cost"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(distances: list, costs: list) -> bool:\n        distances.sort()\n        costs.sort()\n        for i in range(len(distances)):\n            if distances[i] != i + 1:\n                return False\n        return True\n\n    def get_minimum_cost(distances: list, costs: list, fuel_tank_capacity: int) -> int:\n        min_cost = float('inf')\n        for fuel in range(1, fuel_tank_capacity + 1):\n            total_cost = 0\n            for i in range(len(distances)):\n                total_cost += costs[i] * (distances[i] // fuel)\n            min_cost = min(min_cost, total_cost)\n        return min_cost\n\n    def main():\n        n, fuel_tank_capacity = map(int, input().split())\n        distances = []\n        costs = []\n        for _ in range(n):\n            distance, cost = map(int, input().split())\n            distances.append(distance)\n            costs.append(cost)\n\n        if not is_valid(distances, costs):\n            return \"cancel road trip\"\n\n        min_cost = get_minimum_cost(distances, costs, fuel_tank_capacity)\n        return min_cost\n\n    return main()"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, g = map(int, input_list[0].split())\n    gas_stations = []\n\n    for i in range(1, n + 1):\n        distance, cost_per_gallon = map(int, input_list[i].split())\n        gas_stations.append((distance, cost_per_gallon))\n\n    gas_stations.sort(key=lambda x: x[0])\n\n    if gas_stations[0][0] > 2 * 10 ** 10:\n        return \"cancel road trip\"\n\n    min_cost = 0\n    current_fuel = g\n    current_distance = 0\n\n    for distance, cost_per_gallon in gas_stations:\n        if current_fuel - (distance - current_distance) * g < 0:\n            return \"cancel road trip\"\n\n        fuel_needed = (distance - current_distance) * g\n        cost = fuel_needed * cost_per_gallon\n        min_cost += cost\n        current_fuel -= fuel_needed\n        current_distance = distance\n\n    return min_cost\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_inputs() -> tuple:\n        n, g = map(int, input().split())\n        stations = []\n        for _ in range(n):\n            d, c = map(int, input().split())\n            stations.append((d, c))\n        return n, g, stations\n\n    def calculate_min_cost(stations: list) -> int:\n        total_cost = 0\n        station_index = 0\n        while station_index < len(stations):\n            d, c = stations[station_index]\n            fuel_needed = (d - station_index) * 1000\n            fuel_cost = fuel_needed * c\n            total_cost += fuel_cost\n            if total_cost > g:\n                return -1\n            station_index += 1\n        return total_cost\n\n    n, g, stations = get_inputs()\n    min_cost = calculate_min_cost(stations)\n    return str(min_cost) if min_cost != -1 else \"cancel road trip\""
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, g = map(int, input_data[0].split())\n    gas_stations = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def calculate_cost(distance: int) -> int:\n        cost = 0\n        fuel = 0\n        for dist, price in sorted(gas_stations, key=lambda x: x[0]):\n            if fuel + dist <= distance:\n                fuel += dist\n                cost += dist * price\n            else:\n                fuel_needed = distance - fuel\n                fuel += fuel_needed\n                cost += fuel_needed * price\n                break\n        return cost\n\n    rightmost_distance = gas_stations[-1][0]\n\n    if rightmost_distance <= g:\n        return calculate_cost(rightmost_distance)\n    else:\n        return \"cancel road trip\""
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_input() -> tuple:\n        n, g = map(int, stdin.readline().split())\n        stations = []\n        for _ in range(n):\n            d, c = map(int, stdin.readline().split())\n            stations.append((d, c))\n        return n, g, stations\n\n    def min_cost_travel(n: int, g: int, stations: list) -> int:\n        if n == 0:\n            return 0\n\n        last_station, _ = stations[-1]\n        start_position = stations[0][0]\n\n        if start_position > last_station:\n            return min_cost_travel(n - 1, g, stations[1:])\n\n        fuel_tank_capacity = 0\n        current_position = start_position\n        cost = 0\n\n        for station_distance, station_cost in stations:\n            fuel_needed = (current_position - station_distance) * 1000 / station_cost\n            if fuel_needed <= fuel_tank_capacity:\n                fuel_tank_capacity -= fuel_needed\n                cost += fuel_needed * station_cost\n                current_position = station_distance\n            else:\n                fuel_tank_capacity = g - (fuel_needed - fuel_tank_capacity)\n                cost += fuel_tank_capacity * station_cost\n                fuel_tank_capacity = 0\n\n        if current_position < last_station:\n            return min_cost_travel(n - 1, g, stations[1:])\n\n        return cost\n\n    n, g, stations = get_input()\n    if n == 0:\n        return \"cancel road trip\"\n\n    cost = min_cost_travel(n, g, stations)\n    return cost\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    jewels = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def knapSack(w, wt, val, n):\n        if n == 0 or w == 0:\n            return 0\n        if wt[n - 1] > w:\n            return knapSack(w, wt, val, n - 1)\n        else:\n            return max(\n                val[n - 1] + knapSack(w - wt[n - 1], wt, val, n - 1),\n                knapSack(w, wt, val, n - 1)\n            )\n\n    def max_value(size, jewels):\n        wt = [j[0] for j in jewels]\n        val = [j[1] for j in jewels]\n        return knapSack(size, wt, val, len(jewels))\n\n    result = [max_value(i, jewels) for i in range(1, k + 1)]\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n\n    def knapSack(capacity, items, items_len):\n        if capacity <= 0 or items_len == 0:\n            return 0\n        if items[items_len - 1][0] > capacity:\n            return knapSack(capacity, items, items_len - 1)\n        return max(knapSack(capacity - items[items_len - 1][0], items, items_len - 1) + items[items_len - 1][1], knapSack(capacity, items, items_len - 1))\n\n    result = [0] * (k + 1)\n    for i in range(1, k + 1):\n        for j in range(n):\n            if jewels[j][0] <= i:\n                result[i] = max(result[i], result[i - jewels[j][0]] + jewels[j][1])\n            else:\n                break\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def knapsack_value(s: int, jewels: List[Tuple[int, int]]) -> int:\n        total_value = 0\n        jewels.sort(key=lambda x: x[1], reverse=True)\n        for jewel in jewels:\n            if s >= jewel[0]:\n                s -= jewel[0]\n                total_value += jewel[1]\n        return total_value\n\n    n, k = map(int, stdin.split()[:2])\n    jewels = [tuple(map(int, stdin.split()[2:])) for _ in range(n)]\n    result = []\n    for s in range(1, k + 1):\n        result.append(knapsack_value(s, jewels))\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def knapSack(capacity: int, weights: list, values: list, n: int) -> int:\n        if n == 0 or capacity == 0:\n            return 0\n        if weights[n - 1] > capacity:\n            return knapSack(capacity, weights, values, n - 1)\n        else:\n            return max(values[n - 1] + knapSack(capacity - weights[n - 1], weights, values, n - 1), knapSack(capacity, weights, values, n - 1))\n\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, stdin.split()[i:i + 2])) for i in range(1, 2 * n, 2)]\n    max_values = [0] * (k + 1)\n    for jewel_size, jewel_value in jewels:\n        for knap_size in range(k, 0, -1):\n            if knap_size >= jewel_size:\n                max_values[knap_size] = max(max_values[knap_size], jewel_value + max_values[knap_size - jewel_size])\n    return ' '.join(map(str, max_values))"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n    \n    result = []\n    for i in range(1, k+1):\n        total_value = 0\n        knapsack_value = 0\n        for jewel in jewels:\n            if jewel[0] <= i:\n                if jewel[1] > knapsack_value:\n                    knapsack_value = jewel[1]\n                if jewel[1] + total_value > knapsack_value:\n                    total_value += jewel[1]\n        result.append(total_value)\n    \n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = sorted([tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]], key=lambda x: x[1], reverse=True)\n\n    dp = [[0] * (k + 1) for _ in range(k + 1)]\n\n    for jewel in jewels:\n        size, value = jewel\n        for i in range(1, k + 1):\n            if size > i:\n                dp[i][jewel[1] + jewel[0]] = max(dp[i][jewel[1] + jewel[0]], dp[i - jewel[0]][jewel[1]])\n            else:\n                dp[i][jewel[1] + jewel[0]] = max(dp[i][jewel[1] + jewel[0]], dp[i][jewel[1]])\n\n    result = [dp[i][jewels[-1][1] + jewels[-1][0]] for i in range(1, k + 1)]\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    jewels = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    dp = [0] * (k + 1)\n    for jewel_size, jewel_value in jewels:\n        for i in range(k, 0, -1):\n            if jewel_size <= i:\n                dp[i] = max(dp[i], dp[i - jewel_size] + jewel_value)\n    \n    return ' '.join(map(str, dp))\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = []\n    for _ in range(n):\n        s, v = map(int, stdin.split()[2:4])\n        jewels.append((s, v))\n\n    knapsacks = [[] for _ in range(k+1)]\n    for jewel in jewels:\n        for i in range(1, k+1):\n            if jewel[0] <= i:\n                knapsacks[i].append(jewel)\n\n    max_values = [0]*(k+1)\n    for i in range(1, k+1):\n        for jewel in knapsacks[i]:\n            max_values[i] = max(max_values[i], max_values[i-jewel[0]] + jewel[1])\n\n    return \" \".join(map(str, max_values))\n\n\ndef"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def knapSack(capacity: int, weights: list, values: list, n: int) -> int:\n        dp = [0] * (capacity + 1)\n        for i in range(n + 1):\n            for w in range(capacity + 1):\n                if weights[i - 1] <= w:\n                    dp[w] = max(dp[w], dp[w - weights[i - 1]] + values[i - 1])\n        return dp[capacity]\n\n    def maxValue(knapsacks: int, weights: list, values: list, n: int) -> int:\n        max_values = [0] * knapsacks\n        for i in range(1, knapsacks + 1):\n            max_value = 0\n            for j in range(n):\n                if weights[j] <= i:\n                    max_value = max(max_value, max_values[i - weights[j]] + values[j])\n            max_values[i] = max_value\n        return max_values\n\n    n, k = map(int, stdin.split()[0:2])\n    weights = [0] * n\n    values = [0] * n\n    for i in range(n):\n        weights[i], values[i] = map(int, stdin.split()[2 + i * 2:4 + i * 2])\n\n    max_values = maxValue(k, weights, values, n)\n    return \" \".join(map(str, max_values))\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    jewels = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Sort jewels by size\n    jewels.sort(key=lambda x: x[0])\n\n    # Initialize the knapsack sizes and values\n    knapsack_sizes = [0] * (k + 1)\n    knapsack_values = [0] * (k + 1)\n\n    # Iterate through the jewels and update the knapsack sizes and values\n    for jewel in jewels:\n        size, value = jewel\n        for i in range(1, k + 1):\n            if size <= i:\n                knapsack_sizes[i] = max(knapsack_sizes[i], knapsack_sizes[i - size] + value)\n                knapsack_values[i] = max(knapsack_values[i], knapsack_values[i - size] + value)\n\n    # Return the knapsack sizes and values as a single string\n    result = [str(knapsack_sizes[i]) for i in range(1, k + 1)]\n    return ' '.join(result)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_village(village, minion):\n        return distance(village, minion) <= village[2] + minion[2]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def max_minions_in_attack(villages, minions, max_radius):\n        minions_inside_villages = [minion for minion in minions if any(is_inside_village(village, minion) for village in villages)]\n        return len(minions_inside_villages)\n\n    n, m, r = map(int, stdin.split()[:3])\n    villages = [tuple(map(int, stdin.split()[3 + i * 3 : 3 + (i + 1) * 3])) for i in range(n)]\n    minions = [(int(stdin.split()[3 + n * 3 + i * 2]), int(stdin.split()[3 + n * 3 + 1 + i * 2])) for i in range(m)]\n\n    result = max_minions_in_attack(villages, minions, r)\n    return str(result)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r = map(int, stdin.split())\n    villages = []\n    for i in range(n):\n        village = list(map(int, stdin.split()))\n        villages.append(village)\n\n    minions = []\n    for i in range(m):\n        minion = list(map(int, stdin.split()))\n        minions.append(minion)\n\n    max_minions = 0\n    for minion in minions:\n        for village in villages:\n            distance = ((village[0] - minion[0]) ** 2 + (village[1] - minion[1]) ** 2) ** 0.5\n            if distance <= village[2] + minion[2]:\n                max_minions += 1\n                break\n\n    return str(max_minions)\n"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, m, r = map(int, inputs[0].split())\n    villages = []\n    for i in range(1, n + 1):\n        vx, vy, vr = map(int, inputs[i].split())\n        villages.append((vx, vy, vr))\n    minions = []\n    for i in range(n + 1, n + 1 + m):\n        mx, my = map(int, inputs[i].split())\n        minions.append((mx, my))\n    \n    count = 0\n    for minion in minions:\n        for village in villages:\n            if dist(minion, village[:2]) <= village[2] + r:\n                count += 1\n                break\n    return str(count)\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    n, m, r = map(int, stdin.split()[:3])\n    villages = []\n    for _ in range(n):\n        x, y, vr = map(int, stdin.split()[:3])\n        villages.append((x, y, vr))\n        stdin = stdin.split('\\n', 4)[4]\n\n    minions = []\n    for _ in range(m):\n        x, y = map(int, stdin.split()[:2])\n        minions.append((x, y))\n        stdin = stdin.split('\\n', 2)[2]\n\n    minions_in_range = set()\n    for x, y in minions:\n        for vx, vy, vr in villages:\n            if distance(x, y, vx, vy) <= vr:\n                minions_in_range.add((x, y))\n                break\n\n    max_minions_destroyed = 0\n    for x, y in minions_in_range:\n        for vx, vy, vr in villages:\n            if distance(x, y, vx, vy) <= vr:\n                max_minions_destroyed += 1\n                break\n\n    return max_minions_destroyed"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, r = map(int, input_data[0].split())\n    villages = []\n    for i in range(1, n+1):\n        vx, vy, vr = map(int, input_data[i].split())\n        villages.append((vx, vy, vr))\n    \n    minions = []\n    for i in range(n+1, n+1+m):\n        mx, my = map(int, input_data[i].split())\n        minions.append((mx, my))\n    \n    max_minions = 0\n    for mx, my in minions:\n        for vx, vy, vr in villages:\n            dx, dy = mx-vx, my-vy\n            dist = sqrt(dx*dx + dy*dy)\n            if dist <= vr+r:\n                max_minions += 1\n                break\n    \n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m, r = map(int, input_list[0].split())\n    villages = []\n    minions = []\n\n    for i in range(1, n + 1):\n        vx, vy, vr = map(int, input_list[i].split())\n        villages.append((vx, vy, vr))\n\n    for i in range(n + 1, n + 1 + m):\n        mx, my = map(int, input_list[i].split())\n        minions.append((mx, my))\n\n    minions_in_radius = []\n    for minion in minions:\n        for village in villages:\n            x, y, vr = village\n            dist = ((minion[0] - x) ** 2 + (minion[1] - y) ** 2) ** 0.5\n            if dist <= vr:\n                minions_in_radius.append(minion)\n                break\n\n    if len(minions_in_radius) <= r:\n        return str(len(minions_in_radius))\n    else:\n        return str(r)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, r = map(int, input_data[0].split())\n    villages = []\n    for i in range(1, n+1):\n        x, y, v = map(int, input_data[i].split())\n        villages.append((x, y, v))\n    minions = []\n    for i in range(n+1, n+1+m):\n        x, y = map(int, input_data[i].split())\n        minions.append((x, y))\n\n    max_minions = 0\n    for x, y in minions:\n        for vx, vy, vr in villages:\n            if (x-vx)**2 + (y-vy)**2 <= vr**2:\n                if (x-vx)**2 + (y-vy)**2 <= r**2:\n                    max_minions += 1\n                break\n\n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    villages = []\n    for i in range(n):\n        x, y, vr = map(int, input_list[i+1].split())\n        villages.append((x, y, vr))\n    minions = []\n    for i in range(m):\n        x, y = map(int, input_list[n+i+1].split())\n        minions.append((x, y))\n\n    max_minions = 0\n    for x, y in minions:\n        for xv, yv, vr in villages:\n            if (x - xv)**2 + (y - yv)**2 <= vr**2:\n                max_minions += 1\n                break\n        else:\n            continue\n        if max_minions > m:\n            break\n\n    return str(max_minions)\n\n\ndef"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    villages = []\n    for _ in range(n):\n        vx, vy, vr = map(int, input_list[1 + _].split())\n        villages.append((vx, vy, vr))\n        input_list[1 + _] = ''\n    minions = []\n    for _ in range(m):\n        mx, my = map(int, input_list[1 + n + _].split())\n        minions.append((mx, my))\n        input_list[1 + n + _] = ''\n    \n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n    \n    def is_valid(a, b, r):\n        return distance(a, b) <= r\n    \n    def count_minions_in_radius(village, radius, minions):\n        return sum(1 for m in minions if is_valid(village, m, radius))\n    \n    max_minions = 0\n    for village in villages:\n        radius = village[2]\n        valid_minions = [m for m in minions if is_valid(village, m, r)]\n        max_minions = max(max_minions, count_minions_in_radius(village, radius, valid_minions))\n    \n    return str(max_minions)"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def circle_intersection(center1, radius1, center2, radius2):\n        dist = math.sqrt((center1[0] - center2[0]) ** 2 + (center1[1] - center2[1]) ** 2)\n        return dist <= radius1 + radius2\n\n    def circle_contains_point(center, radius, point):\n        dist = math.sqrt((center[0] - point[0]) ** 2 + (center[1] - point[1]) ** 2)\n        return dist <= radius\n\n    def count_enemy_minions_in_circle(center, radius):\n        return sum(1 for minion in enemy_minions if circle_contains_point(center, radius, minion))\n\n    def can_destroy_minion(center, radius, village_center, village_radius):\n        return circle_intersection(center, radius, village_center, village_radius)\n\n    def can_destroy_village(center, radius, village_center, village_radius):\n        return not circle_intersection(center, radius, village_center, village_radius) and circle_contains_point(center, radius, village_center)\n\n    n, m, r = map(int, stdin.split()[:3])\n    villages = [tuple(map(int, stdin.split()[3 + i * 4: 3 + (i + 1) * 4])) for i in range(n)]\n    enemy_minions = [tuple(map(int, stdin.split()[3 + n * 4 + i * 2: 3 + n * 4 + (i + 1) * 2])) for i in range(m)]\n\n    max_minions = 0\n    for center, radius in zip([0, 0], [r, r]):\n        max_minions = max(max_minions, count_enemy_minions_in_circle(center, radius))\n\n    for i in range(n):\n        center, radius = villages[i]\n        min_radius = r - radius\n        max_radius = min(r, 2 * math.sqrt(radius ** 2 + radius ** 2))\n        for j in range(n):\n            if i != j:\n                other_center, other_radius = villages[j]\n                min_radius = max(min_radius, r - max(radius, other_radius))\n                max_radius = min(max_radius, min(r, 2 * math.sqrt(radius ** 2 + other_radius ** 2)))\n        for enemy_center, enemy_radius in enemy_minions:\n            if can_destroy_minion(center, radius, enemy_center, enemy_radius) and radius >= min_radius:\n                max_minions = max(max_minions, 1)\n            if can_destroy_village(center, radius, enemy_center, enemy_radius) and radius <= max_radius:\n                max_minions = max(max_minions, 1)\n\n    return str(max_minions)\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    \n    dp = [0] * N\n    \n    for i in range(N):\n        if A[i] <= S - A[i]:\n            dp[i] = i + 1\n        else:\n            continue\n            \n        for j in range(i+1, N):\n            if A[i] + A[j] <= S and dp[i] + dp[j] > dp[i]:\n                dp[i] = dp[i] + dp[j]\n                \n    result = [str(x) if x > 0 else \"0\" for x in dp]\n    \n    return \"\\n\".join(result)"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_interesting_subseq(arr, k, s):\n        n = len(arr)\n        dp = [0] * n\n        for i in range(n):\n            if i >= k:\n                dp[i] = dp[i - k] + arr[i]\n            if dp[i] > s:\n                return i\n        return n\n\n    N, S = map(int, input().split())\n    A = []\n    for _ in range(N):\n        A.append(int(input()))\n\n    result = []\n    for i, a in enumerate(A):\n        k = i + 1\n        l = len(A) - k\n        longest_subseq = max(find_interesting_subseq(A, k, S), find_interesting_subseq(A, l, S))\n        result.append(longest_subseq)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, S = map(int, input_data[0].split())\n    A = list(map(int, input_data[1:]))\n\n    dp = [0] * N\n    for i in range(N):\n        if A[i] + A[i+1:][:K].sum() <= S:\n            dp[i] = 1\n        for j in range(i-1, max(-1, i-K), -1):\n            if A[j+1:i+1].sum() + A[i+1:i+K+1].sum() <= S:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n    result = []\n    for i in range(N):\n        result.append(str(dp[i]))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, input().split())\n    A = list(map(int, stdin.splitlines()))\n\n    dp = [1] * N\n    for i in range(N):\n        for j in range(i):\n            if A[i] - A[j] <= S and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n\n    result = [0] * N\n    for i in range(N):\n        for j in range(i):\n            if A[i] - A[j] <= S and dp[i] == dp[j] + 1:\n                result[i] = max(result[i], result[j] + 1)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, S = map(int, input_data[0].split())\n    A = list(map(int, input_data[1:]))\n\n    dp = [0] * N\n    for i in range(N):\n        if sum(A[:i+1]) <= S:\n            dp[i] = 1\n        for j in range(i):\n            if sum(A[j:i+1]) <= S:\n                dp[i] = max(dp[i], dp[j]+1)\n\n    result = [0] * N\n    for i in range(N):\n        for j in range(i+1, N):\n            if sum(A[i:j+1]) <= S:\n                result[i] = max(result[i], j-i+1)\n\n    return \"\\n\".join(map(str, result))\n\ninput_data = (\n    \"5 10000\\n\"\n    \"1\\n\"\n    \"1\\n\"\n    \"1\\n\"\n    \"1\\n\"\n    \"1\\n\"\n    \"5 9\\n\"\n    \"1\\n\"\n    \"1\\n\"\n    \"10\\n\"\n    \"1\\n\"\n    \"9\\n\"\n)\n\noutput_data = (\n    \"4\\n\"\n    \"4\\n\"\n    \"2\\n\"\n    \"2\\n\"\n    \"0\\n\"\n    \"4\\n\"\n    \"1\\n\"\n    \"0\\n\"\n    \"0\\n\"\n    \"2\\n\"\n    \"0\\n\"\n)\n\nprint(solution(input_data))\nprint(output_data) "
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    dp = [0] * N\n    mod = 10**9 + 7\n    prefix_sum = [0] * (2 * N)\n    for i in range(N):\n        prefix_sum[i] = A[i]\n    for i in range(1, 2 * N):\n        prefix_sum[i] += prefix_sum[i - 1]\n\n    def is_interesting(i, j):\n        return prefix_sum[j] - prefix_sum[i - 1] <= S\n\n    for i in range(N):\n        if is_interesting(i, i + K):\n            dp[i] = K\n        for j in range(i + 1, i + K + 1):\n            if j < N and is_interesting(i, j):\n                dp[i] = max(dp[i], dp[j] + 1)\n    ans = [0] * N\n    for i in range(N):\n        if dp[i] == K:\n            ans[i] = 2 * K - 1\n        elif dp[i] > 0:\n            ans[i] = dp[i]\n    return '\\n'.join(map(str, ans))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    N, S = map(int, input_lines[0].split())\n    A = list(map(int, input_lines[1:]))\n\n    MOD = 10**9 + 7\n    dp = [0] * (2 * N)\n    dp[2 * N - 1] = 1\n\n    for i in range(2 * N - 2, -1, -1):\n        if i % 2 == 1:\n            for j in range(i + 1, 2 * N):\n                if j % 2 == 0:\n                    if A[j // 2] + A[i // 2] <= S:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    dp[i] = dp[i] % MOD\n        else:\n            for j in range(i - 1, -1, -1):\n                if j % 2 == 1:\n                    if A[j // 2] + A[i // 2] <= S:\n                        dp[i] = max(dp[i], dp[j] + 1)\n                    dp[i] = dp[i] % MOD\n\n    result = []\n    for i in range(N):\n        result.append(dp[2 * i])\n        if i < N - 1:\n            result.append(dp[2 * i + 1])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, input().split())\n    A = list(map(int, stdin.splitlines()[1:]))\n\n    dp = [0] * N\n    for i in range(N):\n        for j in range(i, N, 2):\n            if A[i] + A[j] <= S:\n                dp[j] = max(dp[i] + 1, dp[j])\n\n    for i in range(N):\n        print(dp[i])"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, input().split())\n    A = list(map(int, stdin.splitlines()[1:]))\n    dp = [0] * N\n    max_len = 0\n    \n    for i in range(N):\n        for j in range(i+1, N+1):\n            if sum(A[i:j]) <= S:\n                max_len = max(max_len, j-i)\n        dp[i] = max_len\n        max_len = 0\n        \n    result = '\\n'.join(map(str, dp))\n    return result\n"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    N, S = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    # initialize variables\n    dp = [1] * N\n    max_len = 1\n\n    # loop through the sequence\n    for i in range(1, N):\n        # check for the longest interesting subsequence\n        for j in range(i):\n            if S - A[i] - A[j] >= 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n\n        # update the max_len\n        max_len = max(max_len, dp[i])\n\n    # write output\n    result = [str(max_len if i >= dp.index(max_len) else 0) for i in range(N)]\n    return \"\\n\".join(result)"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    sequence = input()\n    mirror_sequence = sequence[::-1]\n    mirror_sequence = list(mirror_sequence)\n    i = 0\n    while i < N-1:\n        if mirror_sequence[i] > mirror_sequence[i+1]:\n            break\n        i += 1\n    if i == N-1:\n        return \"DA\\n\" + sequence\n    else:\n        return \"NE\\n\" + sequence"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = input().split()\n    N = int(N)\n    sequence = list(sequence)\n\n    while len(sequence) > 1:\n        if sequence[-1] < sequence[-2]:\n            sequence.pop()\n        else:\n            sequence.pop(-2)\n\n    if len(sequence) == 1:\n        return \"DA\\n\" + \"\".join(sequence)\n    else:\n        return \"NE\\n\" + \"\".join(sequence)"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = input().split()\n    N = int(N)\n    max_beautiful_word = \"\"\n\n    for _ in range(N):\n        letter = sequence[-1]\n        sequence = sequence[:-1]\n        if len(sequence) % 2 == 0:\n            max_beautiful_word = letter + max_beautiful_word\n        else:\n            max_beautiful_word = max_beautiful_word + letter\n\n    if sorted(max_beautiful_word) < sorted(sequence):\n        return \"DA\\n\" + max_beautiful_word\n    else:\n        return \"NE\\n\" + max_beautiful_word\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = map(str, stdin.split(\"\\n\"))\n    N = int(N)\n    sequence = list(sequence)\n    slavko_word = []\n    mirror_word = []\n\n    for i in range(N):\n        if i % 2 == 0:\n            slavko_word.append(sequence.pop())\n        else:\n            mirror_word.append(sequence.pop())\n\n    if slavko_word < mirror_word:\n        return \"DA\\n\" + \"\".join(slavko_word)\n    else:\n        return \"NE\\n\" + \"\".join(mirror_word)"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = input().split()\n    N = int(N)\n\n    beautiful_words = []\n    for _ in range(N):\n        letter = sequence[-1]\n        sequence = sequence[:-1]\n        beautiful_words.append(letter)\n        if not sequence:\n            break\n\n    result = \"DA\" if beautiful_words else \"NE\"\n\n    if beautiful_words:\n        beautiful_words = ''.join(beautiful_words)\n        beautiful_words = ''.join(sorted(beautiful_words))\n\n    return result, beautiful_words\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = map(str, input().split())\n    N = int(N)\n\n    if N % 2 == 1:\n        return \"NE\"\n\n    sequence = list(sequence)\n    beautiful_word = \"\"\n    for _ in range(N):\n        if sequence:\n            beautiful_word += sequence.pop()\n        else:\n            break\n\n    if beautiful_word < beautiful_word[::-1]:\n        return \"DA\", beautiful_word\n    else:\n        return \"NE\", beautiful_word[::-1]\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = map(str, input().split())\n    N = int(N)\n    sequence = list(sequence)\n    best_word = ''\n    while len(sequence) > 0:\n        if sequence[-1] < best_word[-1]:\n            best_word = sequence[-1] + best_word\n            break\n        if sequence[0] < best_word[0]:\n            best_word = sequence.pop(0) + best_word\n        else:\n            best_word = sequence.pop() + best_word\n    return \"DA\" if best_word[-1] >= best_word[0] else \"NE\", best_word\n\ninput_string = \"4\\nkava\"\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1]\n\n    mirror = False\n    for i in range(N // 2):\n        if sequence[i] != sequence[N - i - 1]:\n            mirror = True\n            break\n\n    if mirror:\n        return \"NE\\n\" + sequence[N - 1]\n    else:\n        return \"DA\\n\" + sequence[0]\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = stdin.split('\\n')\n    N = int(N)\n\n    # Determine which letter Slavko should take first\n    for i in range(N - 1):\n        if sequence[i] > sequence[i + 1]:\n            return \"NE\"\n\n    # Slavko has the first turn and always takes the rightmost letter\n    i = N - 1\n    word = \"\"\n\n    while i >= 0:\n        letter = sequence[i]\n        word += letter\n\n        # Check if Mirko can win\n        if letter < word[0]:\n            return \"NE\"\n\n        # Check if Slavko can win\n        if i == 0:\n            if word[0] < word[1]:\n                return \"DA\"\n            else:\n                return \"NE\"\n\n        # Find the next letter to take\n        i -= 1\n\n    # Slavko loses if he reaches this point\n    return \"NE\"\n\n\ndef"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = input().split()\n    N = int(N)\n\n    if N % 2 == 0:\n        return \"NE\", sequence[-1]\n\n    mirror = sequence[::-1]\n    for i in range(len(mirror) - 1):\n        if mirror[i] > mirror[i + 1]:\n            return \"NE\", sequence[-1]\n\n    return \"DA\", sequence[-1]"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, visited):\n        queue = [(start, 0)]\n        while queue:\n            node, dist = queue.pop(0)\n            if visited[node]:\n                continue\n            visited[node] = True\n            yield (node, dist)\n            for neighbor in graph[node]:\n                queue.append((neighbor, dist + 1))\n\n    def dfs(graph, start, visited, path):\n        visited[start] = True\n        path.append(start)\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, path)\n        return path\n\n    def dijkstra(graph, start):\n        visited = [False] * len(graph)\n        dist = [float('inf')] * len(graph)\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            node = heapq.heappop(heap)[1]\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor] and dist[node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[node] + weight\n                    heapq.heappush(heap, (dist[neighbor], neighbor))\n        return dist\n\n    def count_ways(graph, query):\n        snack_stands = [0] * len(graph)\n        for i in range(1, len(graph) + 1):\n            if i in query:\n                snack_stands[i - 1] = 1\n        visited = [False] * len(graph)\n        for area in query:\n            path = list(dfs(graph, area, visited, []))\n            dist = dijkstra(graph, area)\n            count = 0\n            for stand in snack_stands:\n                if stand:\n                    continue\n                min_dist = float('inf')\n                for node in path:\n                    if dist[node] < min_dist:\n                        min_dist = dist[node]\n                if min_dist < float('inf'):\n                    count += 1\n            yield count\n\n    lines = stdin.splitlines()\n    n, m, q = map(int, lines[0].split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(1, m + 1):\n        x, y = map(int, lines[_].split())\n        graph[x].append(y)\n        graph[y].append(x)\n    for _ in range(q):\n        k, a = map(int, lines[_].split())\n        query = set(map(int, lines[_].split()[1:]))\n        yield from count_ways(graph, query)\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, q = map(int, input_data[0].split())\n    runs = [(int(x), int(y)) for x, y in [line.split() for line in input_data[1:m+1]]]\n    queries = [line.split() for line in input_data[m+1:]]\n    for i, query in enumerate(queries):\n        k, a = int(query[0]), int(query[1])\n        query_areas = list(map(int, query[2:]))\n        # Check if there are any repeated areas in the query\n        if len(query_areas) != len(set(query_areas)):\n            queries[i] = '0\\n'\n            continue\n        # Check if there are any areas that are not in the runs\n        if any(x not in [run[0] for run in runs] for x in query_areas):\n            queries[i] = '0\\n'\n            continue\n        # Check if there are any areas that are not in the runs\n        if any(y not in [run[1] for run in runs] for y in query_areas):\n            queries[i] = '0\\n'\n            continue\n        # Check if there are any cycles in the runs\n        if any(y == runs[runs.index((x,y))-1][1] for x,y in runs if y in query_areas):\n            queries[i] = '0\\n'\n            continue\n        # Check if there is at least one snack stand for each area\n        if any(len([run for run in runs if run[0] == x and run[1] in query_areas]) != 1 for x in query_areas):\n            queries[i] = '0\\n'\n            continue\n        # Check if there are at most k snack stands selected\n        if len(set([run[1] for x in query_areas for run in runs if run[0] == x and run[1] in query_areas])) > k:\n            queries[i] = '0\\n'\n            continue\n        queries[i] = str(len(set([run[1] for x in query_areas for run in runs if run[0] == x and run[1] in query_areas]))) + '\\n'\n    return ''.join(queries)"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    runs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    queries = [tuple(map(int, line.split())) for line in stdin.split('\\n')[m+1:m+q+1]]\n\n    def count_ways(k: int, areas: list) -> int:\n        ways = 0\n        for a in areas:\n            selected = [False] * n\n            stack = [(1, a)]\n            while stack:\n                node, visited = stack.pop()\n                if not selected[node-1]:\n                    selected[node-1] = True\n                    if visited == k:\n                        ways += 1\n                    else:\n                        for neighbor, dist in runs:\n                            if neighbor == node and not selected[neighbor-1]:\n                                stack.append((neighbor, visited+1))\n        return ways\n\n    result = '\\n'.join(str(count_ways(q[0], q[2:])) for q in queries)\n    return result"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    adj_list = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[:2])\n        adj_list[x-1].append(y-1)\n    \n    def dfs(node: int, visited: set, order: list) -> None:\n        visited.add(node)\n        order.append(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, order)\n    \n    def topological_sort(node: int, visited: set, order: list) -> None:\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                topological_sort(neighbor, visited, order)\n        order.append(node)\n    \n    def find_order(node: int, visited: set, order: list, stack: list) -> int:\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                return find_order(neighbor, visited, order, stack)\n        stack.append(node)\n        return len(stack)\n    \n    def is_snack_stand_valid(snack_stands: list, areas: set) -> bool:\n        for area in areas:\n            if area not in snack_stands:\n                return False\n        return True\n    \n    def count_snack_stands(k: int, areas: set) -> int:\n        return min(k, len(areas))\n    \n    output = []\n    for _ in range(q):\n        k, a = map(int, stdin.split()[:2])\n        areas = set(map(int, stdin.split()[2:]))\n        snack_stands = []\n        for i in range(1, n+1):\n            if i in areas:\n                order = []\n                dfs(i-1, set(), order)\n                stack = []\n                num_snack_stands = find_order(i-1, set(), order, stack)\n                if num_snack_stands >= k:\n                    snack_stands.append(i)\n            else:\n                for j in range(1, n+1):\n                    if j in areas:\n                        order = []\n                        dfs(j-1, set(), order)\n                        stack = []\n                        num_snack_stands = find_order(j-1, set(), order, stack)\n                        if num_snack_stands >= k:\n                            snack_stands.append(i)\n                            break\n        output.append(count_snack_stands(k, areas))\n    \n    return '\\n'.join(map(str, output)) "
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0].split())\n    edges = [list(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    queries = [list(map(int, line.split())) for line in stdin.split('\\n')[m+1:].split('\\n')]\n\n    def count_ways(k: int, areas: List[int]) -> int:\n        if len(areas) == 1:\n            return 1 if areas[0] == 1 else 0\n\n        res = 0\n        for i in range(len(areas)):\n            new_areas = areas[:i] + areas[i+1:]\n            res += count_ways(k, new_areas)\n            if k > 0:\n                res += count_ways(k-1, new_areas)\n        return res\n\n    for query in queries:\n        k = query[0]\n        areas = query[2:]\n        res = count_ways(k, areas)\n        print(res)"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    adjacency_list = [[] for _ in range(n+1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[m:m+2])\n        adjacency_list[x].append(y)\n        adjacency_list[y].append(x)\n    queries = []\n    for _ in range(q):\n        k, a = map(int, stdin.split()[m+q:m+q+2])\n        query = list(map(int, stdin.split()[m+q+2:m+q+2+a]))\n        queries.append((k, a, query))\n\n    def dfs(node, snack_stands, visited, result):\n        if len(snack_stands) == k and node not in visited:\n            visited.add(node)\n            result[0] += 1\n            return\n        visited.add(node)\n        for neighbor in adjacency_list[node]:\n            if neighbor not in visited and neighbor in query[2]:\n                dfs(neighbor, snack_stands + [node], visited, result)\n\n    output = []\n    for query in queries:\n        k, a, query = query\n        result = [0]\n        dfs(1, [], set(), result)\n        output.append(result[0])\n\n    return '\\n'.join(map(str, output))\n\ninput_data = [\n    \"4 4 4\",\n    \"1 2\",\n    \"1 3\",\n    \"2 4\",\n    \"3 4\",\n    \"1 1 4\",\n    \"2 1 4\",\n    \"1 1 3\",\n    \"2 2 3 2\",\n    \"8 10 4\",\n    \"1 2\",\n    \"2 3\",\n    \"1 3\",\n    \"3 6\",\n    \"6 8\",\n    \"2 4\",\n    \"2 5\",\n    \"4 7\",\n    \"5 7\",\n    \"7 8\",\n    \"2 3 4 5 6\",\n    \"2 2 6 8\",\n    \"1 1 6\",\n    \"1 1 8\"\n]\n\nfor input_case in input_data:\n    output = solution(input_case)\n    print(\"Expected Output:\")\n    print(output)\n    print(\"-----------------------------------------------------------------------\")\n    print(\"-----------------------------------------------------------------------\")\n    print() "
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    adj = [[] for _ in range(n+1)]\n    for i in range(1, m+1):\n        x, y = map(int, stdin.split()[i:i+2])\n        adj[x].append(y)\n        adj[y].append(x)\n\n    def dfs(cur, visited):\n        if visited[cur]:\n            return []\n        visited[cur] = True\n        ret = [cur]\n        for neighbor in adj[cur]:\n            ret += dfs(neighbor, visited)\n        return ret\n\n    def count_ways(k, a, i):\n        areas = [i]\n        visited = [False] * (n+1)\n        order = dfs(1, visited)\n        ans = 0\n        for area in areas:\n            for pos in order:\n                if pos == area:\n                    break\n            ans += pos == area\n        return ans\n\n    for i in range(q):\n        k, a = map(int, stdin.split()[q+i:q+i+2])\n        areas = map(int, stdin.split()[q+i+2:q+i+2+a])\n        ways = 0\n        for i in range(1, n+1):\n            if i in areas:\n                ways += count_ways(k, a, i)\n        print(ways)\n\ninput_data = \"\"\"4 4 4\n1 2\n1 3\n2 4\n3 4\n1 1 4\n2 1 4\n1 1 3\n2 2 3 2\"\"\"\n\nsolution(input_data) "
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(visited, adj, start, target):\n        if start == target:\n            return 1\n        visited[start] = True\n        count = 0\n        for neighbor in adj[start]:\n            if not visited[neighbor]:\n                count += dfs(visited, adj, neighbor, target)\n        visited[start] = False\n        return count\n\n    n, m, q = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        x, y = map(int, stdin.readline().split())\n        adj[x - 1].append(y - 1)\n\n    result = []\n    for _ in range(q):\n        k, a = map(int, stdin.readline().split())\n        areas = set(map(int, stdin.readline().split()))\n        count = 0\n        for area in areas:\n            visited = [False] * n\n            count += dfs(visited, adj, 0, area - 1)\n        result.append(count)\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    runs = []\n    for _ in range(m):\n        x, y = map(int, stdin.split()[3:5])\n        runs.append((x, y))\n    stdin = stdin[m*2+3:]\n\n    def count_ways(k, areas):\n        if k == 0:\n            return 1\n        if k == 1:\n            return sum(1 for area in areas if area != 1)\n        if k == 2:\n            return sum(1 for area in areas if area != 1 and area != n)\n        if k == 3:\n            return sum(1 for area in areas if area != 1 and area != n and area != n-1)\n        return 0\n\n    result = []\n    for _ in range(q):\n        k, a = map(int, stdin.split()[0:2])\n        areas = list(map(int, stdin.split()[2:a+2]))\n        ways = 0\n        for seq in powerset(range(1, n+1)):\n            if set(seq).issubset(set(areas)):\n                ski_runs = set()\n                for area in seq:\n                    ski_runs.update(run for run in runs if run[1] == area)\n                if len(ski_runs) == a and len(ski_runs) == len(set(ski_runs)):\n                    ways += count_ways(k, seq)\n        result.append(ways)\n        stdin = stdin[a+2+k:]\n\n    return '\\n'.join(map(str, result))\n\ndef"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, q = map(int, input_list[0].split())\n    runs = []\n    for i in range(1, m+1):\n        x, y = map(int, input_list[i].split())\n        runs.append((x, y))\n\n    def dfs(x, k, visited, result, stack):\n        if k == 0:\n            result.append(stack.copy())\n            return\n        visited[x] = True\n        for y, _ in runs:\n            if not visited[y]:\n                stack.append(y)\n                dfs(y, k-1, visited, result, stack)\n                stack.pop()\n        visited[x] = False\n\n    def find_ways(guest, k):\n        visited = [False] * (n+1)\n        result = []\n        for area in guest:\n            stack = []\n            dfs(1, k, visited, result, stack)\n        return result\n\n    output = []\n    for i in range(1, q+1):\n        k, a = map(int, input_list[q+i-1].split())\n        guest = map(int, input_list[q+i-1].split()[1:])\n        result = find_ways(guest, k)\n        output.append(len(result))\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    inspection_times = list(map(int, stdin.split()[2:2+n]))\n    flights = [list(map(int, stdin.split()[i+2:i+2+n])) for i in range(n, n*n+1, n)]\n    flights = [[flights[i][j] for i in range(n)] for j in range(n)]\n    flights = [[flights[i][j] for i in range(n)] for j in range(n)]\n    \n    dp = [[0] * n for _ in range(m+1)]\n    for i in range(m+1):\n        for j in range(n):\n            if i == 0:\n                dp[i][j] = 1\n            else:\n                for k in range(n):\n                    if flights[j][k] == 0:\n                        continue\n                    if flights[j][k] + inspection_times[j] <= t:\n                        dp[i][j] = max(dp[i][j], dp[i-1][k] + 1)\n    \n    return dp[m][0]\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, source, target, time):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[source] = 0\n        visited = [False] * n\n\n        while not all(visited):\n            current = min(range(n), key=lambda i: (dist[i], graph[i][source]))\n            if visited[current]:\n                continue\n            visited[current] = True\n            if current == target:\n                return dist[target] <= time\n            for i in range(n):\n                if visited[i]:\n                    continue\n                new_dist = dist[current] + graph[current][i]\n                if new_dist < dist[i]:\n                    dist[i] = new_dist\n        return False\n\n    def min_planes(n, flights, inspection_times):\n        graph = [[0] * n for _ in range(n)]\n        for s, f, t in flights:\n            graph[s][f] = t\n        planes = 1\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if dijkstra(graph, i, j, inspection_times[i]):\n                    planes += 1\n                    break\n        return planes\n\n    n, m = map(int, stdin.split()[:2])\n    inspection_times = list(map(int, stdin.split()[2:n + 2]))\n    flights = [tuple(map(int, line.split())) for line in stdin.split('\\n')[n + 2:n + 2 + m]]\n    return min_planes(n, flights, inspection_times)"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: list, start: int) -> list:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        prev = [None] * n\n\n        while True:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n\n            if min_node == -1:\n                break\n\n            visited[min_node] = True\n            for i in range(n):\n                if not visited[i] and graph[min_node][i] != float('inf'):\n                    new_dist = dist[min_node] + graph[min_node][i]\n                    if new_dist < dist[i]:\n                        dist[i] = new_dist\n                        prev[i] = min_node\n\n        return dist, prev\n\n    def min_planes(n: int, m: int, inspection_times: list, flights: list) -> int:\n        graph = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if j != i:\n                    graph[i][j] = flights[i][j]\n                    if flights[i][j] == 0:\n                        graph[i][j] = float('inf')\n\n        dist, prev = dijkstra(graph, 0)\n        min_planes = 1\n\n        for s, f, t in flights[n:]:\n            if dist[f] - t < inspection_times[f] and prev[f] != s:\n                min_planes += 1\n            elif prev[f] != s:\n                dist, prev = dijkstra(graph, s)\n                if dist[f] - t < inspection_times[f]:\n                    min_planes += 1\n            else:\n                dist, prev = dijkstra(graph, prev[f])\n                if dist[f] - t < inspection_times[f]:\n                    min_planes += 1\n\n        return min_planes\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    inspection_times = [list(map(int, line.split())) for line in lines[1:n + 1]]\n    flights = [list(map(int, line.split())) for line in lines[n + 1:]]\n\n    return str(min_planes(n, m, inspection_times, flights))\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n    def min_planes(flights: list, flights_list: list) -> int:\n        min_planes_count = 0\n        for perm in permutations(range(len(flights)), len(flights_list)):\n            total_time = 0\n            for i in range(len(flights_list)):\n                s, f, t = flights_list[i]\n                if perm[s] == perm[f]:\n                    continue\n                total_time += flights[perm[s]][perm[f]]\n            if total_time <= t:\n                min_planes_count = max(min_planes_count, len(set(perm)))\n        return min_planes_count\n\n    n, m = map(int, stdin.split()[:2])\n    inspection_times = list(map(int, stdin.split()[2:2 * n + 1]))\n    flights = [list(map(int, stdin.split()[2 * n + i:2 * n + i + n + 1])) for i in range(n)]\n    flights_list = [list(map(int, stdin.split()[2 * n + n * i + 2 * j + 2:2 * n + n * i + 2 * j + 4])) for i in range(m) for j in range(n)]\n    flights_list = [list(filter(lambda x: x[0] != x[1], flights_list))]\n    min_planes_count = min_planes(flights, flights_list)\n    return min_planes_count\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_flight_times(n: int, airport_flight_times: list) -> list:\n        flight_times = [[0] * (n + 1) for _ in range(n + 1)]\n        for i in range(n):\n            for j in range(n):\n                flight_times[i][j] = airport_flight_times[i][j]\n        return flight_times\n\n    def get_inspection_times(n: int, airport_inspection_times: list) -> list:\n        inspection_times = [0] * (n + 1)\n        for i in range(n):\n            inspection_times[i] = airport_inspection_times[i]\n        return inspection_times\n\n    def get_min_planes(m: int, flights: list) -> int:\n        n = len(flight_times)\n        min_planes = 0\n        planes = [0] * n\n        for flight in flights:\n            s, f, t = flight\n            planes[s] += 1\n            planes[f] += 1\n            min_planes = max(min_planes, planes[s] + planes[f])\n            planes[s] -= 1\n            planes[f] -= 1\n            for i in range(n):\n                if planes[i] > 0:\n                    min_planes = max(min_planes, planes[i] + planes[f] + inspection_times[i] + flight_times[i][f] - t)\n        return min_planes\n\n    def main():\n        n, m = map(int, input().split())\n        airport_flight_times = [list(map(int, input().split())) for _ in range(n)]\n        airport_inspection_times = [int(input()) for _ in range(n)]\n        flights = [list(map(int, input().split())) for _ in range(m)]\n        flight_times = get_flight_times(n, airport_flight_times)\n        inspection_times = get_inspection_times(n, airport_inspection_times)\n        min_planes = get_min_planes(m, flights)\n        return min_planes\n\n    return str(main())\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start):\n        dist = [float('inf')] * n\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            (d, v) = heappop(heap)\n            if d > dist[v]:\n                continue\n            for (u, weight) in graph[v]:\n                if dist[v] + weight < dist[u]:\n                    dist[u] = dist[v] + weight\n                    heappush(heap, (dist[u], u))\n        return dist\n\n    n, m = map(int, stdin.readline().split())\n    inspection_time = [list(map(int, stdin.readline().split())) for _ in range(n)]\n    flight_time = [list(map(int, stdin.readline().split())) for _ in range(n)]\n\n    planes = 0\n    for _ in range(m):\n        s, f, t = map(int, stdin.readline().split())\n        if s != f:\n            planes += 1\n            for i in range(n):\n                for j in range(n):\n                    if flight_time[i][j] != 0 and flight_time[i][j] > flight_time[i][s] + inspection_time[s][j]:\n                        flight_time[i][j] = flight_time[i][s] + inspection_time[s][j] + flight_time[j][f]\n            planes = max(planes, 1)\n\n    return planes\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    airports_inspection = list(map(int, input_data[1].split()))\n    airports_flights = []\n\n    for i in range(2, n + 2):\n        airports_flights.append(list(map(int, input_data[i].split())))\n\n    planes_needed = 0\n    flights = []\n\n    for i in range(m):\n        s, f, t = map(int, input_data[n + i + 1].split())\n        flights.append((s, f, t))\n\n    flights.sort(key=lambda x: x[2])\n\n    while flights:\n        flight = flights.pop(0)\n        s, f, t = flight\n        plane_needed = 1\n\n        for i in range(n):\n            if i == s:\n                continue\n            flight_time = airports_flights[i][s]\n            inspection_time = airports_inspection[i]\n\n            if flight_time + inspection_time + t <= airports_flights[i][f]:\n                plane_needed += 1\n\n        planes_needed = max(planes_needed, plane_needed)\n\n    return str(planes_needed)\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    inspection_time = [list(map(int, input_list[i+1].split())) for i in range(n)]\n    flight_time = [list(map(int, input_list[i+n+1].split())) for i in range(n)]\n\n    def find_min_planes(flight_request: list) -> int:\n        num_planes = 1\n        flight_dict = {i+1: set() for i in range(n)}\n        for s, f, t in flight_request:\n            start_time = t\n            for i in range(n):\n                if s in flight_dict[i+1]:\n                    continue\n                elif f in flight_dict[i+1]:\n                    break\n                else:\n                    flight_time_from_i_to_f = flight_time[i][f-1]\n                    end_time = t + flight_time_from_i_to_f + inspection_time[i][f-1]\n                    if end_time <= start_time:\n                        num_planes += 1\n                        flight_dict[i+1].add(f)\n                        flight_dict[f-1].add(i+1)\n                        break\n            else:\n                num_planes += 1\n                flight_dict[s].add(f)\n                flight_dict[f-1].add(s)\n        return num_planes\n\n    min_planes = find_min_planes(flight_request)\n    return min_planes"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    inspection_times = [list(map(int, input().split())) for _ in range(n)]\n    flight_times = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                flight_times[i][j] = 0\n            else:\n                flight_times[i][j] = inspection_times[i][j]\n    \n    flights = []\n    for _ in range(m):\n        s, f, t = map(int, input().split())\n        flights.append((s, f, t))\n    \n    def dijkstra(graph, start, end):\n        visited = set()\n        dist = [float('inf')] * n\n        dist[start] = 0\n        prev = [-1] * n\n        \n        while True:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if i not in visited and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            \n            if min_node == -1:\n                break\n            \n            visited.add(min_node)\n            for neighbor, time in enumerate(graph[min_node]):\n                if neighbor not in visited and time + min_dist < dist[neighbor]:\n                    dist[neighbor] = time + min_dist\n                    prev[neighbor] = min_node\n        \n        path = []\n        node = end\n        while node != -1:\n            path.append(node)\n            node = prev[node]\n        \n        return path[::-1]\n    \n    planes = set()\n    for flight in flights:\n        planes.add(flight[0])\n        planes.add(flight[1])\n    \n    min_planes = 0\n    for plane in planes:\n        planes_to_add = 0\n        for flight in flights:\n            if flight[0] == plane and flight[2] > 0:\n                flight_path = dijkstra(flight_times, plane, flight[1])\n                if flight[2] % flight_times[plane][flight[1]] != 0:\n                    planes_to_add += 1\n        min_planes = max(min_planes, planes_to_add)\n    \n    return min_planes\n"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_planes(flights, inspections, flights_to_do):\n        def dfs(start, end, time, used_planes, planes):\n            if start == end and time >= flights[start][end]:\n                planes[used_planes] += 1\n            else:\n                for i in range(n):\n                    if i != start and time + flights[start][i] < flights[start][end] and not visited[i]:\n                        visited[i] = True\n                        dfs(i, end, time + flights[start][i], used_planes, planes)\n                        visited[i] = False\n\n        n = len(flights)\n        used_planes = 0\n        planes = [0] * (2 * n)\n        visited = [False] * n\n\n        for s, f, t in flights_to_do:\n            visited[s] = True\n            dfs(s, f, t, used_planes, planes)\n            visited[s] = False\n            used_planes = max(used_planes, planes[used_planes])\n\n        return used_planes\n\n    n, m = map(int, stdin.split()[0:2])\n    inspections = list(map(int, stdin.split()[2:2 * n + 2]))\n    flights = []\n    for _ in range(n):\n        flights.append(list(map(int, stdin.split()[2 * n + 2:2 * n + 2 * n + 2])))\n\n    flights_to_do = []\n    for _ in range(m):\n        s, f, t = map(int, stdin.split()[-m:])\n        flights_to_do.append((s - 1, f - 1, t))\n\n    return find_min_planes(flights, inspections, flights_to_do)\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_dish_tastiness(n: int, t: int, dt: int) -> float:\n        return t - (n - 1) * dt\n\n    def continuous_dish_tastiness(x: float, t: int, dt: int) -> float:\n        return (t - x * dt) * x\n\n    def compute_tastiness(dishes: List[Tuple[str, int, int, int]]) -> float:\n        discrete_dishes = [d for d in dishes if d[0] == \"D\"]\n        continuous_dishes = [d for d in dishes if d[0] == \"C\"]\n\n        discrete_dish_tastinesses = [discrete_dish_tastiness(n, t, dt) for n, w, t, dt in discrete_dishes]\n        continuous_dish_tastinesses = [continuous_dish_tastiness(w, t, dt) for w, t, dt in continuous_dishes]\n\n        return sum(discrete_dish_tastinesses) + sum(continuous_dish_tastinesses)\n\n    def maximum_tastiness(w: int, dishes: List[Tuple[str, int, int, int]]) -> float:\n        max_tastiness = 0.0\n        for i in range(1, w + 1):\n            tastiness = compute_tastiness(dishes)\n            if tastiness > max_tastiness:\n                max_tastiness = tastiness\n            dishes.append((\"C\", i, 1, 1))\n        return max_tastiness\n\n    stdin = stdin.strip().split(\"\\n\")\n    d, w = map(int, stdin.pop(0).split())\n    dishes = [(l[0], int(l[1]), int(l[2]), int(l[3])) for l in [l.split() for l in stdin]]\n\n    max_tastiness = maximum_tastiness(w, dishes)\n    if max_tastiness == float(\"inf\"):\n        return \"impossible\"\n    else:\n        return f\"{max_tastiness:.6f}\""
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    input_str = stdin.splitlines()\n    dishes_count, total_weight = map(int, input_str[0].split())\n    dishes = input_str[1:]\n\n    # Compute maximum possible total tastiness\n    max_tastiness = 0\n    for dish in dishes:\n        if dish.startswith(\"D\"):\n            weight, tastiness, decay = map(int, dish[2:].split())\n            max_tastiness += tastiness - (total_weight - weight) * decay\n        elif dish.startswith(\"C\"):\n            tastiness, decay = map(int, dish[2:].split())\n            max_tastiness += tastiness - total_weight * decay\n\n    # Check if it's impossible to make a meal of total weight exactly w based on the available dishes\n    if max_tastiness < 0:\n        return \"impossible\"\n\n    return f\"{max_tastiness:.6f}\""
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    d, w = map(int, input_data[0].split())\n    dishes = input_data[1:]\n\n    discrete_dishes = []\n    continuous_dishes = []\n\n    for dish in dishes:\n        if dish.startswith('D'):\n            w_i, t_i, dt_i = map(int, dish.split()[1:])\n            discrete_dishes.append((w_i, t_i, dt_i))\n        else:\n            t_i, dt_i = map(int, dish.split()[1:])\n            continuous_dishes.append((t_i, dt_i))\n\n    def discrete_dish_total_tastiness(w_i, t_i, dt_i, n):\n        return t_i - (n - 1) * dt_i\n\n    def continuous_dish_total_tastiness(t_i, dt_i, x):\n        return (t_i - x * dt_i) * x\n\n    def meal_total_tastiness(discrete_dishes, continuous_dishes, w):\n        total_tastiness = 0\n        weight_left = w\n\n        for i, (w_i, t_i, dt_i) in enumerate(discrete_dishes):\n            n = weight_left // w_i\n            total_tastiness += discrete_dish_total_tastiness(w_i, t_i, dt_i, n)\n            weight_left -= n * w_i\n\n        for t_i, dt_i in continuous_dishes:\n            x = weight_left / t_i\n            total_tastiness += continuous_dish_total_tastiness(t_i, dt_i, x)\n            weight_left = 0\n\n        return total_tastiness\n\n    return str(meal_total_tastiness(discrete_dishes, continuous_dishes, w))\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_dish_total_tastiness(n: int, w: int, t: int, dt: int) -> float:\n        return (t - (n - 1) * dt) * w\n\n    def continuous_dish_total_tastiness(x: float, t: int, dt: int) -> float:\n        return (t - x * dt) * x\n\n    d, w = map(int, stdin.split()[1].split())\n    dishes = []\n    for _ in range(d):\n        _, wi, ti, dt = stdin.split()[1].split()\n        wi, ti, dt = map(int, [wi, ti, dt])\n        if wi > 0 and ti > 0 and dt > 0:\n            dishes.append((wi, ti, dt))\n        else:\n            raise ValueError(\"Invalid dish description\")\n\n    total_tastiness = 0.0\n    for wi, ti, dt in dishes:\n        total_tastiness += discrete_dish_total_tastiness(w // wi, wi, ti, dt)\n        w %= wi\n\n    for i, (wi, ti, dt) in enumerate(dishes):\n        total_tastiness += continuous_dish_total_tastiness(w * 1.0 / len(dishes), ti, dt)\n        w -= w * 1.0 / len(dishes)\n\n        if w <= 0:\n            break\n\n    if w > 0:\n        return \"impossible\"\n    else:\n        return \"{:.6f}\".format(total_tastiness)\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_dish_tastiness(n, weight, t_i, dt_i):\n        return t_i - (n - 1) * dt_i\n\n    def continuous_dish_tastiness(weight, t_i, dt_i):\n        return (t_i - weight * dt_i) * weight\n\n    def calculate_total_tastiness(dishes, weight):\n        total_tastiness = 0\n        for dish in dishes:\n            if dish[0] == 'D':\n                n, w_i, t_i, dt_i = int(dish[1]), int(dish[2]), int(dish[3]), int(dish[4])\n                total_tastiness += discrete_dish_tastiness(n, w_i, t_i, dt_i)\n            elif dish[0] == 'C':\n                t_i, dt_i = int(dish[1]), int(dish[2])\n                total_tastiness += continuous_dish_tastiness(weight, t_i, dt_i)\n        return total_tastiness\n\n    d, w = map(int, stdin.splitlines()[0].split())\n    dishes = stdin.splitlines()[1:]\n    if d * w == 0:\n        return \"impossible\"\n    total_tastiness = calculate_total_tastiness(dishes, w)\n    return f\"{total_tastiness:.6f}\""
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    d, w = map(int, input_list.pop(0).split())\n    total_tastiness = 0\n    for i in range(d):\n        description = input_list.pop(0).split()\n        if description[0] == \"D\":\n            weight, tastiness, decay = map(int, description[1:])\n            total_tastiness += tastiness - (weight-1) * decay\n        elif description[0] == \"C\":\n            tastiness, decay = map(int, description[1:])\n            total_tastiness += tastiness - w * decay\n    if total_tastiness <= 0:\n        return \"impossible\"\n    else:\n        return f\"{total_tastiness:.6f}\"\n\ninput_list = \"\"\"\n2 15\nD 4 10 1\nC 6 1\n\"\"\"\nprint(solution(input_list))\n"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    d, w = map(int, input_data[0].split())\n    dishes = input_data[1:]\n\n    discrete_dishes = []\n    continuous_dishes = []\n\n    for dish in dishes:\n        if dish.startswith(\"D\"):\n            w_i, t_i, delta_t_i = map(int, dish.split()[1:])\n            discrete_dishes.append((w_i, t_i, delta_t_i))\n        else:\n            t_i, delta_t_i = map(int, dish.split()[1:])\n            continuous_dishes.append((t_i, delta_t_i))\n\n    max_total_tastiness = 0\n\n    for discrete_dish in discrete_dishes:\n        w_i, t_i, delta_t_i = discrete_dish\n        max_total_tastiness += t_i - (w_i - 1) * delta_t_i\n\n    for continuous_dish in continuous_dishes:\n        t_i, delta_t_i = continuous_dish\n        max_total_tastiness += t_i - (w - 1) * delta_t_i\n\n    return f\"{max_total_tastiness:.6f}\"\n\ntest_case_1 = \"2 15\\nD 4 10 1\\nC 6 1\"\ntest_case_2 = \"3 15\\nD 4 10 1\\nC 6 1\\nC 9 3\"\n\nprint(solution(test_case_1))\nprint(solution(test_case_2)) "
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    d, w = map(int, input_list[0].split())\n    meal_list = input_list[1:]\n\n    def discrete_tastiness(n, w_i, t_i, delta_t_i):\n        return t_i - (n - 1) * delta_t_i\n\n    def continuous_tastiness(x, t_i, delta_t_i):\n        return (t_i - x * delta_t_i) * x\n\n    max_tastiness = 0\n\n    for meal in meal_list:\n        meal_type, meal_info = meal.split()\n        if meal_type == 'D':\n            w_i, t_i, delta_t_i = map(int, meal_info.split())\n            for n in range(1, w // w_i + 1):\n                tastiness = discrete_tastiness(n, w_i, t_i, delta_t_i)\n                max_tastiness = max(max_tastiness, tastiness)\n        elif meal_type == 'C':\n            t_i, delta_t_i = map(int, meal_info.split())\n            tastiness = continuous_tastiness(w, t_i, delta_t_i)\n            max_tastiness = max(max_tastiness, tastiness)\n        else:\n            raise ValueError(\"Invalid meal type\")\n\n    if max_tastiness == 0:\n        return \"impossible\"\n    else:\n        return f\"{max_tastiness:.6f}\"\n\ninput_string = (\n    \"2 15\\nD 4 10 1\\nC 6 1\"\n)\nprint(solution(input_string)) "
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    num_dishes, total_weight = map(int, input_str[0].split())\n    dishes = input_str[1:]\n    \n    def discrete_tastiness(weight, tastiness, decay, n):\n        return tastiness - (n-1) * decay\n    \n    def continuous_tastiness(weight, tastiness, decay, x):\n        return (tastiness - x * decay) * weight\n    \n    max_tastiness = 0\n    \n    for dish in dishes:\n        if dish[0] == 'D':\n            w_i, t_i, decay_i, n = map(int, dish.split()[1:])\n            discrete_tastiness_i = sum(discrete_tastiness(w_i, t_i, decay_i, i+1) for i in range(n))\n            max_tastiness += discrete_tastiness_i\n        elif dish[0] == 'C':\n            t_i, decay_i, weight_i = map(int, dish.split()[1:])\n            continuous_tastiness_i = continuous_tastiness(weight_i, t_i, decay_i, total_weight)\n            max_tastiness += continuous_tastiness_i\n        \n    if max_tastiness <= total_weight:\n        return f\"{max_tastiness:.6f}\"\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def discrete_tastiness(n, w_i, t_i, delta_t_i):\n        return t_i - (n - 1) * delta_t_i\n\n    def continuous_tastiness(x, t_i, delta_t_i):\n        return (t_i - x * delta_t_i) * x\n\n    d, w = map(int, stdin.splitlines()[0].split())\n    dishes = [line.split() for line in stdin.splitlines()[1:]]\n\n    total_tastiness = 0\n    weight = 0\n\n    for i, dish in enumerate(dishes):\n        if dish[0] == 'D':\n            w_i, t_i, delta_t_i = map(int, dish[1:])\n            n = w // w_i\n            total_tastiness += discrete_tastiness(n, w_i, t_i, delta_t_i)\n            weight += n * w_i\n        elif dish[0] == 'C':\n            t_i, delta_t_i = map(int, dish[1:])\n            x = 1\n            total_tastiness += continuous_tastiness(x, t_i, delta_t_i)\n            weight += x\n\n    if weight == w:\n        return f\"{total_tastiness:.6f}\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    songs = []\n    for i in range(1, n+1):\n        artist, t, *s_list = input_list[i].split(' ')\n        s_list = list(map(int, s_list))\n        songs.append({'artist': artist, 't': t, 's_list': s_list})\n    \n    def find_playlist(songs, i, prev_artist=None, prev_artist_index=None):\n        if i == 9:\n            return [1]\n        for j in range(len(songs)):\n            if j == prev_artist_index and songs[j]['artist'] == prev_artist:\n                continue\n            if songs[j]['t'] > 0 and i+1 not in songs[j]['s_list']:\n                continue\n            if songs[j]['t'] == 0 and i+1 in songs[j]['s_list']:\n                continue\n            playlist = find_playlist(songs, i+1, songs[j]['artist'], j)\n            if playlist:\n                return [j+1] + playlist\n        return False\n    \n    playlist = find_playlist(songs, 0)\n    if playlist:\n        return ' '.join(map(str, playlist))\n    else:\n        return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def matros_songs() -> List[int]:\n        return [10, 1, 6, 2, 1, 4, 3, 10, 7, 6, 2]\n\n    def bjork_songs() -> List[int]:\n        return [10, 1, 6, 2, 1, 4, 3, 10, 7, 6, 2]\n\n    def prokofiev_songs() -> List[int]:\n        return [9, 1, 4, 7, 2, 1, 3, 6, 5, 8]\n\n    def other_songs() -> List[int]:\n        return [9, 1, 4, 7, 2, 1, 3, 6, 5, 8]\n\n    def find_valid_playlist() -> List[int]:\n        playlist = []\n        for i in range(9):\n            if i == 0:\n                playlist.append(random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n            else:\n                valid_songs = [x for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] if x not in playlist]\n                playlist.append(random.choice(valid_songs))\n        return playlist\n\n    def is_valid_playlist(playlist: List[int], songs: List[int]) -> bool:\n        if len(playlist) != 9:\n            return False\n        for i in range(9):\n            if i == 0:\n                continue\n            for t in range(1, 4):\n                if songs[playlist[i]-1][0] == songs[playlist[i-1]-1][t]:\n                    return True\n        return False\n\n    def solve(songs: List[int]) -> List[int]:\n        playlist = find_valid_playlist()\n        if is_valid_playlist(playlist, songs):\n            return playlist\n        else:\n            return [9, 1, 4, 7, 2, 1, 3, 6, 5, 8]\n\n    songs = [(\"a\", 2, 10, 3),\n            (\"b\", 1, 6),\n            (\"c\", 2, 1, 5),\n            (\"d\", 1, 9),\n            (\"e\", 1, 4),\n            (\"f\", 1, 2),\n            (\"g\", 2, 6, 8),\n            (\"h\", 0),\n            (\"i\", 1, 3),\n            (\"j\", 1, 7)]\n    return \" \".join(map(str, solve(songs)))"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_song(artist: str, songs: List[str]) -> Union[int, None]:\n        for i, song in enumerate(songs):\n            if artist in song and song not in visited:\n                return i + 1\n        return None\n\n    def backtrack(artists: List[str], songs: List[str], current_song: int, visited: Set[int], playlist: List[int]):\n        if len(playlist) == 9:\n            return True\n        if current_song >= len(songs):\n            return False\n        artist = artists[current_song]\n        visited.add(current_song)\n        next_song = find_next_song(artist, songs)\n        if next_song is None:\n            return False\n        playlist.append(current_song + 1)\n        result = backtrack(artists, songs, next_song, visited, playlist)\n        if result:\n            return True\n        visited.remove(current_song)\n        playlist.pop()\n        return backtrack(artists, songs, current_song + 1, visited, playlist)\n\n    def find_playlist():\n        n = int(stdin.readline())\n        artists = []\n        songs = []\n        for i in range(n):\n            artist, *songs_after = stdin.readline().split()\n            artists.append(artist)\n            songs.append(f\"{artist} {i}\")\n            songs.extend([f\"{artist} {int(song)-1}\" for song in songs_after])\n        for i in range(n):\n            artists[i] = artists[i].lower()\n        random.shuffle(artists)\n        random.shuffle(songs)\n        visited = set()\n        playlist = []\n        if backtrack(artists, songs, 0, visited, playlist):\n            return playlist\n        else:\n            return \"fail\"\n\n    return find_playlist()\n"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    songs = []\n\n    for i in range(n):\n        artist, t, *s = stdin.split()\n        songs.append((i + 1, artist, t, list(map(int, s))))\n\n    def backtrack(idx, prev_artist, playlist):\n        if len(playlist) == 9:\n            return playlist\n\n        for i, (num, artist, t, s) in enumerate(songs):\n            if i == idx:\n                continue\n\n            if prev_artist == artist:\n                continue\n\n            if t == 0:\n                return backtrack(i, artist, playlist + [num])\n\n            for s in s:\n                if s == idx:\n                    continue\n\n                result = backtrack(s, artist, playlist + [num])\n                if result is not None:\n                    return result\n\n        return None\n\n    result = backtrack(0, \"\", [])\n\n    if result is None:\n        return \"fail\"\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def build_adjacency_list(n: int) -> List[List[int]]:\n        adjacency_list = [[] for _ in range(n + 1)]\n        for line in input_data.split('\\n')[1:]:\n            parts = line.split()\n            artist = parts[0]\n            connections = parts[1:]\n            for connection in connections:\n                adjacency_list[int(artist)].append(int(connection))\n        return adjacency_list\n\n    def dfs(adjacency_list: List[List[int]], visited: List[bool], current_node: int, visited_nodes: List[int]) -> bool:\n        visited[current_node] = True\n        visited_nodes.append(current_node)\n        for neighbor in adjacency_list[current_node]:\n            if not visited[neighbor]:\n                if dfs(adjacency_list, visited, neighbor, visited_nodes):\n                    return True\n            elif len(visited_nodes) == 9:\n                return True\n        return len(visited_nodes) == 9\n\n    input_data = stdin.strip()\n    n = int(input_data.split('\\n')[0])\n    adjacency_list = build_adjacency_list(n)\n    visited = [False] * (n + 1)\n    visited_nodes = []\n    if dfs(adjacency_list, visited, 1, visited_nodes):\n        return ' '.join(map(str, visited_nodes))\n    else:\n        return 'fail'"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_playlist(playlist: List[int]) -> bool:\n        def is_continuous(index: int) -> bool:\n            if index == 0:\n                return True\n            return song_info[playlist[index - 1] - 1][1] == song_info[index - 1][0]\n\n        for index in range(len(playlist)):\n            if not is_continuous(index):\n                return False\n        return True\n\n    def find_playlist() -> Union[List[int], None]:\n        def backtrack(current: int) -> List[int]:\n            if current == 9:\n                return []\n\n            for song in range(1, n + 1):\n                if song in seen or (current > 0 and song_info[song - 1][0] != playlist[current - 1]):\n                    continue\n\n                seen.add(song)\n                playlist.append(song)\n                if is_valid_playlist(playlist):\n                    if current < 8:\n                        result = backtrack(current + 1)\n                        if result is not None:\n                            return result\n                    else:\n                        return playlist\n                playlist.pop()\n                seen.remove(song)\n\n            return None\n\n        playlist = []\n        seen = set()\n        return backtrack(0)\n\n    song_info = []\n    n = int(stdin[0].strip())\n    for line in stdin[1:]:\n        artist, num_succ, *succ = line.strip().split()\n        num_succ = int(num_succ)\n        succ = [int(s) for s in succ]\n        song_info.append((artist, num_succ, succ))\n\n    result = find_playlist()\n    if result is not None:\n        return ' '.join(map(str, result))\n    else:\n        return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    songs = stdin.split(\"\\n\")[1:]\n    song_list = []\n    song_used = set()\n\n    def dfs(start: int) -> bool:\n        if len(song_list) == 9:\n            return True\n        if start == n:\n            return False\n        for i in range(start, n):\n            if i in song_used:\n                continue\n            if i != 0 and songs[i].split()[1] == songs[i - 1].split()[1]:\n                continue\n            if len(song_list) == 0 or int(songs[i].split()[1]) >= len(song_list):\n                song_list.append(i + 1)\n                song_used.add(i)\n                if dfs(i + 1):\n                    return True\n                else:\n                    song_list.pop()\n                    song_used.remove(i)\n        return False\n\n    if dfs(0):\n        return \" \".join(str(x) for x in song_list)\n    else:\n        return \"fail\"\n"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    songs = [line.split() for line in stdin.splitlines()[1:]]\n\n    def get_next_song(current_song, visited_songs):\n        for song in songs:\n            if song[0] not in visited_songs and int(song[1]) > 0:\n                return int(song[0])\n        return None\n\n    def find_playlist(song_num, visited_songs):\n        playlist = []\n        current_song = song_num\n        while current_song is not None:\n            playlist.append(current_song)\n            visited_songs.add(str(current_song))\n            current_song = get_next_song(current_song, visited_songs)\n        return playlist\n\n    for i in range(1, n+1):\n        playlist = find_playlist(i, set())\n        if len(playlist) == 9:\n            return ' '.join(str(song) for song in playlist)\n\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_song(cur_song: int, used_songs: set) -> int:\n        for i in range(1, n+1):\n            if i not in used_songs and graph[cur_song][i] == 1:\n                return i\n        return -1\n\n    def dfs(node: int, used_songs: set) -> bool:\n        if len(used_songs) == 9:\n            return True\n        for i in range(1, n+1):\n            if i not in used_songs and graph[node][i] == 1:\n                used_songs.add(i)\n                if dfs(i, used_songs):\n                    return True\n                used_songs.remove(i)\n        return False\n\n    n, *stdin = stdin.split()\n    n = int(n)\n    graph = [[0] * (n+1) for _ in range(n+1)]\n    used_songs = set()\n\n    for i in range(1, n+1):\n        artist, num_next, *next_songs = stdin[:4]\n        stdin = stdin[4:]\n        next_songs = [int(s) for s in next_songs]\n        graph[i][i] = num_next\n        graph[i][next_songs] = 1\n        for _ in range(num_next):\n            next_song = find_next_song(i, used_songs)\n            if next_song == -1:\n                return \"fail\"\n            used_songs.add(next_song)\n\n    if dfs(1, used_songs):\n        return ' '.join(map(str, sorted(used_songs)))\n    return \"fail\""
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(adj_list):\n        queue = [(1, [1])]\n        visited = set()\n        while queue:\n            current, path = queue.pop(0)\n            if current not in visited:\n                visited.add(current)\n                for neighbor in adj_list[current]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, path + [neighbor]))\n        return visited\n\n    def dfs(adj_list, current, visited, path):\n        if len(path) == 9:\n            return path\n        if current not in visited:\n            visited.add(current)\n            for neighbor in adj_list[current]:\n                if neighbor not in visited:\n                    result = dfs(adj_list, neighbor, visited, path + [neighbor])\n                    if result:\n                        return result\n        return None\n\n    # Read input\n    n, *lines = stdin.split('\\n')\n    n = int(n)\n    adj_list = [[] for _ in range(n + 1)]\n\n    for line in lines:\n        artist, t, *s_list = line.split()\n        s_list = list(map(int, s_list))\n        adj_list[1].extend(s_list)\n\n    for i in range(2, n + 1):\n        adj_list[i] = s_list\n\n    # Find a playlist using BFS\n    visited = bfs(adj_list)\n\n    # Find a playlist using DFS\n    playlist = dfs(adj_list, 1, set(), [])\n\n    if playlist:\n        return ' '.join(map(str, playlist))\n    else:\n        return \"fail\""
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def change_digit(digit, direction):\n        if direction == '+':\n            if digit == '9':\n                return '0'\n            else:\n                return str(int(digit) + 1)\n        else:\n            if digit == '0':\n                return '9'\n            else:\n                return str(int(digit) - 1)\n\n    def get_correct_time(original_time, current_time):\n        original_hour, original_minute = map(int, original_time.split(':'))\n        current_hour, current_minute = map(int, current_time.split(':'))\n\n        if current_hour < original_hour:\n            current_hour += 24\n\n        correct_hour = current_hour\n        correct_minute = current_minute\n\n        while correct_hour != original_hour or correct_minute != original_minute:\n            if correct_minute == 59:\n                correct_minute = 0\n                correct_hour += 1\n            else:\n                correct_minute += 1\n\n        return f\"{correct_hour:02d}:{correct_minute:02d}\"\n\n    original_time, current_time = stdin.splitlines()\n    correct_time = get_correct_time(original_time, current_time)\n    total_times = 0\n\n    for hour in range(0, 24):\n        for minute in range(0, 60):\n            if current_time == f\"{hour:02d}:{minute:02d}\":\n                total_times += 1\n                print(f\"{original_time}:{current_time}\")\n\n    return f\"{total_times}\\n{original_time}:{correct_time}\"\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    current_time = input_list[0]\n    correct_time = input_list[1]\n\n    def increment(time):\n        if time[4] == '5':\n            return increment(increment(time[:4] + '0' + time[5:]))\n        elif time[4] == '9':\n            return increment(time[:4] + '0' + time[5:])\n        else:\n            return time[:4] + str(int(time[4]) + 1) + time[5:]\n\n    def decrement(time):\n        if time[4] == '0':\n            return decrement(decrement(time[:4] + '9' + time[5:]))\n        elif time[4] == '5':\n            return decrement(time[:4] + '9' + time[5:])\n        else:\n            return time[:4] + str(int(time[4]) - 1) + time[5:]\n\n    def is_valid(time):\n        hour = int(time[:2])\n        minute = int(time[3:])\n        return 0 <= hour <= 23 and 0 <= minute <= 59\n\n    def set_clock(current_time, correct_time):\n        time_list = []\n        while current_time != correct_time:\n            if current_time < correct_time:\n                current_time = increment(current_time)\n            else:\n                current_time = decrement(current_time)\n            if is_valid(current_time):\n                time_list.append(current_time)\n        return time_list\n\n    final_times = set_clock(current_time, correct_time)\n    result = len(final_times)\n    for time in final_times:\n        result_str = time[:2] + ':' + time[2:]\n        print(result_str)\n\n    return str(result)"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def increment(time: str) -> str:\n        hour, minute = map(int, time.split(\":\"))\n        if minute < 59:\n            minute += 1\n        else:\n            minute = 0\n            if hour < 23:\n                hour += 1\n            else:\n                hour = 0\n        return f\"{hour:02}:{minute:02}\"\n\n    def decrement(time: str) -> str:\n        hour, minute = map(int, time.split(\":\"))\n        if minute > 0:\n            minute -= 1\n        else:\n            minute = 59\n            if hour > 0:\n                hour -= 1\n            else:\n                hour = 23\n        return f\"{hour:02}:{minute:02}\"\n\n    def correct_time(stdin: str) -> str:\n        original_time, current_time = stdin.splitlines()\n        correct_time = original_time\n        times_seen = set()\n        while correct_time != current_time:\n            times_seen.add(correct_time)\n            if correct_time < current_time:\n                correct_time = increment(correct_time)\n            else:\n                correct_time = decrement(correct_time)\n        return times_seen\n\n    result = list(correct_time(stdin))\n    print(len(result))\n    for time in result:\n        print(time)"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split('\\n')\n    original_h, original_m = map(int, original_time.split(':'))\n    current_h, current_m = map(int, current_time.split(':'))\n\n    # Calculate the difference between the current and original time\n    diff_h = current_h - original_h\n    diff_m = current_m - original_m\n\n    # Handle the edge cases where the difference is greater than 23 hours or 60 minutes\n    if diff_h < 0:\n        diff_h += 24\n    if diff_m < 0:\n        diff_m += 60\n\n    # Calculate the new time\n    new_h = (original_h + diff_h) % 24\n    new_m = (original_m + diff_m) % 60\n\n    # Generate all possible times the clock could be set to\n    possible_times = set()\n    for h in range(24):\n        for m in range(60):\n            # Ignore invalid times\n            if h < 0 or h > 23 or m < 0 or m > 59:\n                continue\n            # Check if the time is equal to the original time or the new time\n            if (h, m) == (original_h, original_m) or (h, m) == (new_h, new_m):\n                continue\n            possible_times.add((h, m))\n\n    # Sort the times and output them\n    sorted_times = sorted(possible_times)\n    result = len(sorted_times)\n    for h, m in sorted_times:\n        result += f'\\n{h:02d}:{m:02d}'\n\n    return str(result)"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    stdin = stdin.split('\\n')\n    original_time = stdin[0]\n    current_time = stdin[1]\n\n    # Convert time strings to integers\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    # Determine the difference between the two times\n    hour_difference = abs(current_hour - original_hour)\n    minute_difference = abs(current_minute - original_minute)\n\n    # Calculate the number of times the clock can be reset correctly\n    if hour_difference == 0:\n        number_of_times = minute_difference + 1\n    else:\n        number_of_times = 2 * (hour_difference * 2 + minute_difference + 1)\n\n    # Generate the different times the clock can be set correctly\n    result = []\n    for i in range(number_of_times):\n        # Determine the current hour and minute\n        current_hour = original_hour\n        current_minute = original_minute\n        if i >= minute_difference:\n            current_minute += i - minute_difference\n            current_hour += current_minute // 60\n            current_minute %= 60\n        else:\n            current_minute += i\n            current_hour += current_minute // 60\n            current_minute %= 60\n            if current_hour == 24:\n                current_hour = 0\n\n        # Convert the time to the output format\n        result.append(f\"{current_hour:02d}:{current_minute:02d}\")\n\n    return f\"{number_of_times}\\n{' '.join(result)}\"\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    original_time, current_time = stdin.split(\"\\n\")\n    original_hour, original_minute = map(int, original_time.split(\":\"))\n    current_hour, current_minute = map(int, current_time.split(\":\"))\n\n    if original_hour == current_hour and original_minute == current_minute:\n        return \"0\\n\" + current_time\n\n    different_times = []\n    for hour in range(0, 24):\n        for minute in range(0, 60):\n            if hour == current_hour and minute == current_minute:\n                different_times.append(f\"{hour:02d}:{minute:02d}\")\n            elif (hour == original_hour and minute == original_minute) or (hour == current_hour and minute == current_minute):\n                continue\n            else:\n                different_times.append(f\"{hour:02d}:{minute:02d}\")\n\n    return f\"{len(different_times)}\\n\" + \"\\n\".join(different_times)\n\ndef"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Split input into original time and current time\n    stdin = stdin.split('\\n')\n    original_time = stdin[0]\n    current_time = stdin[1]\n    \n    # Parse times into hours and minutes\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n    \n    # Calculate difference between current and original time\n    diff_hour = current_hour - original_hour\n    diff_minute = current_minute - original_minute\n    \n    # Calculate number of different times\n    n_times = 1\n    if diff_hour >= 1:\n        n_times *= 2 * (diff_hour + 1)\n    if diff_minute >= 1:\n        n_times *= 2 * (diff_minute + 1)\n    \n    # Generate all different times\n    times = []\n    if diff_hour >= 1:\n        for h in range(diff_hour + 1):\n            for m in range(60):\n                times.append((original_hour + h, original_minute + m))\n    if diff_minute >= 1:\n        for m in range(diff_minute + 1):\n            times.append((original_hour, original_minute + m))\n    \n    # Sort times and output\n    times = sorted(times)\n    output = [f\"{h:02d}:{m:02d}\" for h, m in times]\n    output = '\\n'.join([f\"{original_time}\", *output])\n    output = f\"{n_times}\\n{output}\"\n    \n    return output"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    original_time = input_list[0]\n    current_time = input_list[1]\n\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    def increment_time(hour, minute, amount):\n        minute += amount\n        hour += minute // 60\n        minute %= 60\n        hour %= 24\n        return hour, minute\n\n    def decrement_time(hour, minute, amount):\n        minute -= amount\n        hour += minute // 60\n        minute %= 60\n        hour %= 24\n        return hour, minute\n\n    time_difference = (current_hour * 60 + current_minute) - (original_hour * 60 + original_minute)\n    if time_difference < 0:\n        time_difference += 1440\n\n    final_hour, final_minute = increment_time(original_hour, original_minute, time_difference)\n\n    print(f\"{time_difference}\")\n    print(f\"{original_hour:02}:{original_minute:02}\")\n    print(f\"{final_hour:02}:{final_minute:02}\")\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def next_time(hour: int, minute: int, increase: bool) -> tuple[int, int]:\n        if increase:\n            if minute == 59:\n                hour = (hour + 1) % 24\n                minute = 0\n            else:\n                minute += 1\n        else:\n            if minute == 0:\n                hour = (hour - 1) % 24\n                minute = 59\n            else:\n                minute -= 1\n        return hour, minute\n\n    def clock_times(hour: int, minute: int) -> list[str]:\n        return [f\"{hh:02d}:{mm:02d}\" for hh in range(hour, 24) for mm in range(0, 60)]\n\n    original_time, current_time = stdin.splitlines()\n    hour, minute = map(int, current_time.split(\":\"))\n\n    increase = (hour, minute) > (int(original_time[:2]), int(original_time[3:]))\n    hour, minute = next_time(int(original_time[:2]), int(original_time[3:]), increase)\n\n    times = clock_times(hour, minute)\n    return len(times), original_time, *times\n"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    current_time = stdin[1].split(':')\n    current_time = int(current_time[0]) * 100 + int(current_time[1])\n\n    def clock_time_to_int(time: str) -> int:\n        return int(time[:2]) * 100 + int(time[3:])\n\n    def int_to_clock_time(time: int) -> str:\n        return f\"{time // 100:02d}:{time % 100:02d}\"\n\n    def get_different_times(current_time: int, original_time: int) -> List[int]:\n        different_times = []\n        for i in range(100):\n            new_time = (current_time + i) % 200\n            if new_time != original_time:\n                different_times.append(new_time)\n        return different_times\n\n    original_time = clock_time_to_int(stdin[0])\n    different_times = get_different_times(current_time, original_time)\n\n    result = f\"{len(different_times)}\\n\"\n    for time in different_times:\n        result += int_to_clock_time(time) + '\\n'\n\n    return result\n\ninput_data = \"\"\"00:00\n01:01\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bracket_notation(s: str) -> str:\n        bracket_pairs = []\n        stack = []\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if stack:\n                    start = stack.pop()\n                    bracket_pairs.append((start, i))\n        result = []\n        for start, end in bracket_pairs:\n            result.append(f\"{start},{end}:{start+1},{end}\")\n        return min(result, key=len)\n\n    def alt_bracket_notation(s: str) -> str:\n        bracket_pairs = []\n        stack = []\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if stack:\n                    start = stack.pop()\n                    end = i\n                    bracket_pairs.append((start, end))\n        result = []\n        for start, end in bracket_pairs:\n            result.append(f\"{start},{end}\")\n        return ','.join(result)\n\n    return alt_bracket_notation(stdin)"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n    index = 0\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                result.append(f\"{stack.pop()},{i}:\")\n                index = i + 1\n            else:\n                return \"NO\"\n    if stack:\n        return \"NO\"\n    result_str = ','.join(result)\n    return result_str"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n    \n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                result.append(f\"{start},{i}:{start+1},{i+1}:\")\n    \n    if not result:\n        return \"4,4:\"\n    else:\n        return min(result)"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_alternative_notation(open_brackets: str, start_index: int) -> str:\n        open_stack = []\n        open_stack.append(start_index)\n        result = ''\n        for i, char in enumerate(open_brackets, start=start_index + 1):\n            if char == '(':\n                open_stack.append(i)\n            else:\n                open_stack.pop()\n            if len(open_stack) == 1:\n                result += str(open_stack[-1]) + ',' + str(i) + ':'\n                open_stack = []\n        return result\n\n    s = stdin.strip()\n    if s == '':\n        return '4,4:'\n    open_brackets = ''\n    for char in s:\n        if char == '(':\n            open_brackets += '('\n        else:\n            open_brackets = open_brackets[:-1]\n    if open_brackets == '':\n        return '4,4:'\n    return find_alternative_notation(open_brackets, 0)\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    result = \"\"\n\n    for i, c in enumerate(stdin):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            start = stack.pop()\n            end = i\n            result += f\"{start},{end}:\"\n\n    if len(stack) == 0:\n        return result\n    else:\n        start = stack.pop()\n        end = len(stdin)\n        result += f\"{start},{end}:\"\n        return result\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    output = []\n    start = 0\n\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if not stack:\n                return \"No matching bracket found at index \" + str(i)\n            start = stack.pop()\n            output.append(str(start) + ',' + str(i) + ':')\n\n    if stack:\n        return \"No matching bracket found at index \" + str(stack[0])\n\n    if not output:\n        return \"Empty string\"\n\n    return min(output, key=len)"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    output = []\n    i = 0\n\n    while i < len(stdin):\n        if stdin[i] == '(':\n            stack.append(i)\n        elif stdin[i] == ')':\n            start = stack.pop()\n            end = i\n            if not stack:\n                output.append(f\"{start},{end}:\")\n            else:\n                output.append(f\"{stack[-1]},{end}:\")\n        i += 1\n\n    return min(output, key=len)\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_match(start: int) -> int:\n        stack = []\n        for i in range(start, len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if len(stack) == 0:\n                    return -1\n                if i - stack[-1] > 1:\n                    return i\n                stack.pop()\n        return -1\n\n    def find_alternate_notation(start: int, end: int) -> str:\n        result = []\n        while start < end:\n            result.append(str(start))\n            start += 1\n        return \",\".join(result) + \":\" + str(end) + \",\" + str(end) + \":\"\n\n    s = stdin\n    match_positions = []\n    for i in range(len(s)):\n        if s[i] == '(':\n            match_positions.append(find_match(i))\n\n    result = []\n    start = 0\n    for end in match_positions:\n        result.append(find_alternate_notation(start, end))\n        start = end + 1\n    result.append(find_alternate_notation(start, len(s)))\n\n    return min(result, key=len)\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    i = 0\n    output = []\n    while i < len(stdin):\n        if stdin[i] == '(':\n            stack.append(i)\n        elif stdin[i] == ')':\n            if len(stack) == 0:\n                return \"\"\n            start = stack.pop()\n            output.append(f\"{start},{i}:{i},{i}\")\n        i += 1\n    if len(stack) != 0:\n        return \"\"\n    return min(output, key=len)\n\ninput1 = \"(())\"\ninput2 = \"()\"\ninput3 = \"(()()(()))\"\ninput4 = \"((()))\"\ninput5 = \"(()((()))\"\ninput6 = \"((()()()()())\"\n\nprint(solution(input1)) # Output: 4,8:8,8:\nprint(solution(input2)) # Output: 4,4:\nprint(solution(input3)) # Output: 4,8:8,8:\nprint(solution(input4)) # Output: 4,8:8,8:\nprint(solution(input5)) # Output: \nprint(solution(input6)) # Output: 4,8:8,8:"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    result = []\n\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                result.append(f\"{start},{i}:\")\n\n    return min(result, key=len) if result else \"0,0:\"\n"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_date(date: str) -> int:\n        day, month = map(int, date)\n        return day + month * 30 + (day + month) // 2\n\n    def parse_observation(observation: str) -> tuple:\n        start_date, end_date, *event_counts = map(int, observation.split())\n        return start_date, end_date, event_counts\n\n    def calculate_duration(start_date: int, end_date: int) -> int:\n        return end_date - start_date + 1\n\n    N, M = map(int, stdin.split()[0:2])\n    observations = [parse_observation(line.strip()) for line in stdin.split('\\n')[1:N+1]]\n    durations = [0] * M\n\n    for start_date, end_date, event_counts in observations:\n        for event_type, count in enumerate(event_counts):\n            duration = calculate_duration(parse_date(f\"{start_date:02d}{start_date // 30:02d}\"), parse_date(f\"{end_date:02d}{end_date // 30:02d}\"))\n            durations[event_type] += count * duration\n\n    result = [duration for duration in durations if duration > 0]\n\n    if len(result) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, result))"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = []\n    for i in range(1, N+1):\n        start_date, event_type, end_date = stdin.split()[4*(i-1):4*(i+1)]\n        start_date, end_date = int(start_date), int(end_date)\n        events = [int(x) for x in stdin.split()[4*(i+1):4*(i+1)+M]]\n        observations.append((start_date, end_date, events))\n\n    # Sort observations by start date\n    observations.sort(key=lambda x: x[0])\n\n    # Calculate durations\n    durations = [0] * M\n    current_year = 1\n    for start_date, end_date, events in observations:\n        while current_year * 365 < start_date:\n            current_year += 1\n        days = end_date - start_date\n        for i, event_count in enumerate(events):\n            durations[i] += event_count * days\n\n    # Check if any solution exists\n    has_solution = False\n    for duration in durations:\n        if duration > 0:\n            has_solution = True\n            break\n\n    if has_solution:\n        return ' '.join(map(str, durations))\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = []\n    \n    for i in range(1, N + 1):\n        dates, counts = stdin.split()[i * M + 1 : i * M + M + 1]\n        start_date, end_date = map(int, dates[0:6].split(' '))\n        counts = list(map(int, counts))\n        observations.append((start_date, end_date, counts))\n    \n    durations = [0] * M\n    \n    for start_date, end_date, counts in observations:\n        for event, count in enumerate(counts):\n            durations[event] += (end_date - start_date + 1) * count\n    \n    if any(duration > 365 for duration in durations):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, durations))\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = []\n    for i in range(N):\n        observation = list(map(int, stdin.split()[i*M+1:i*M+M+1]))\n        observations.append(observation)\n\n    event_durations = [0] * M\n    for observation in observations:\n        start_date, end_date, events = observation[0:3], observation[3:6], observation[6:]\n        start_day, start_month = start_date[0]-1, start_date[1]-1\n        end_day, end_month = end_date[0]-1, end_date[1]-1\n        start_date = start_day + start_month * 31\n        end_date = end_day + end_month * 31\n        for i in range(M):\n            num_events = events[i]\n            if num_events > 0:\n                event_duration = (end_date - start_date) // num_events\n                event_durations[i] += event_duration\n\n    durations = [duration for duration in event_durations if duration > 0]\n    if durations:\n        return str(max(durations))\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = []\n    for i in range(1, N+1):\n        start_date, end_date, *event_counts = stdin.split()[i*M+3:]\n        event_counts = list(map(int, event_counts))\n        observations.append((start_date, end_date, event_counts))\n    \n    durations = [0] * M\n    for start_date, end_date, event_counts in observations:\n        start_year = int(start_date[:2])\n        start_month = int(start_date[2:4])\n        start_day = int(start_date[4:6])\n        end_year = int(end_date[:2])\n        end_month = int(end_date[2:4])\n        end_day = int(end_date[4:6])\n        \n        for i, event_count in enumerate(event_counts):\n            if event_count > 0:\n                duration = (end_year - start_year) * 365 + (end_month - start_month) * 30 + (end_day - start_day) + 1\n                durations[i] += event_count * duration\n    \n    if any(durations):\n        return ' '.join(map(str, durations))\n    else:\n        return \"-1\"\n\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    events = []\n\n    for _ in range(N):\n        start_date, start_month, end_date, end_month, *frequencies = map(int, input().split())\n        start_date, start_month, end_date, end_month = str(start_date).zfill(2), str(start_month).zfill(2), str(end_date).zfill(2), str(end_month).zfill(2)\n        start_date = f\"{start_date}-{start_month}-01\"\n        end_date = f\"{end_date}-{end_month}-01\"\n        events.append((start_date, end_date, frequencies))\n\n    durations = [0] * M\n    for start_date, end_date, frequencies in events:\n        for i, frequency in enumerate(frequencies):\n            if frequency > 0:\n                event_duration = 365\n                durations[i] += event_duration * frequency\n\n    if any(durations):\n        return ' '.join(map(str, durations))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    events = [list(map(int, line.split())) for line in input_list[1:]]\n    \n    durations = [0] * M\n    \n    for start_date, end_date, count, *_ in events:\n        event_duration = (end_date - start_date) * count\n        for i in range(M):\n            if event_duration == durations[i]:\n                durations[i] += 1\n    \n    if all(durations[i] == 1 for i in range(M)):\n        return str(durations)\n    else:\n        return \"-1\""
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def parse_date(date: str) -> int:\n        return int(date)\n\n    def parse_observations(observations: str) -> list:\n        return [int(x) for x in observations.split()]\n\n    def compute_duration(start_date: int, end_date: int, num_observations: int, days_per_year: int = 365) -> int:\n        return (end_date - start_date + 1) * num_observations\n\n    def process_observations(observations: list) -> list:\n        event_durations = []\n        start_date = parse_date(str(observations[0]).zfill(2))\n        end_date = parse_date(str(observations[1]).zfill(2))\n        days_per_year = 365\n\n        for i in range(2, len(observations), 2):\n            event_duration = compute_duration(start_date, end_date, observations[i], days_per_year)\n            event_durations.append(event_duration)\n\n        return event_durations\n\n    N, M = map(int, stdin.split()[:2])\n    observations = [parse_observations(stdin.split()[2 + i:2 + M + i]) for i in range(N)]\n    event_durations = [process_observations(obs) for obs in observations]\n    event_durations = [sum(durations) for durations in zip(*event_durations)]\n\n    if any(durations == 0 for durations in event_durations):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, event_durations))"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    events = []\n    \n    for i in range(N):\n        start_date, end_date, event_counts = stdin.split()[i*M+4:i*M+M+4]\n        event_counts = list(map(int, event_counts.split()))\n        events.append((int(start_date), int(end_date), event_counts))\n    \n    durations = [0] * M\n    \n    for start_date, end_date, event_counts in events:\n        for event_index, count in enumerate(event_counts):\n            durations[event_index] += (end_date - start_date + 1) * count\n    \n    durations = [duration // 365 for duration in durations]\n    \n    if any(duration <= 0 for duration in durations):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, durations))\n\n\ndef"
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = [list(map(int, stdin.split()[2+i:6+i])) for i in range(N)]\n\n    # Calculate event durations\n    event_durations = [0] * M\n    for start_date, end_date, f_i in observations:\n        event_durations[f_i-1] += end_date - start_date + 1\n\n    # Check if there is at least one duration greater than zero\n    if sum(event_durations) == 0:\n        return \"-1\"\n\n    # Find the minimum duration and the number of occurrences\n    min_duration = min(event_durations)\n    min_occurrences = sum(1 for f_i in event_durations if f_i == min_duration)\n\n    # Check if there is a solution\n    if min_occurrences > 1:\n        return str(min_duration)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    dancers = list(map(int, stdin.splitlines()[1].split()))\n    graph = [[] for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(K):\n            if i == dancers[dancers[(i + j) % N] - 1]:\n                graph[i].append(dancers[(i + j + 1) % N])\n                \n    if not graph:\n        return \"Impossible\"\n    \n    def dfs(node: int, visited: set, arrows: list):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, arrows)\n        arrows.append(node)\n        \n    visited = set()\n    arrows = []\n    dfs(0, visited, arrows)\n    \n    for i in range(N):\n        if i not in visited:\n            dfs(i, visited, arrows)\n    \n    return ' '.join(map(str, arrows))\n"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def dfs(start, visited, path, result):\n        if len(path) == N:\n            result.append(path)\n            return\n\n        for i in range(1, N + 1):\n            if i not in visited:\n                dfs(i, visited | {i}, path + [i], result)\n\n    def is_valid(path):\n        for i in range(N - 1):\n            for j in range(i + 1, N):\n                if path[i] == path[j]:\n                    return False\n        return True\n\n    arrows = {}\n    for i in range(N - 1):\n        arrows[a[i]] = a[i + 1]\n\n    if not is_valid(list(arrows.values())):\n        return \"Impossible\"\n\n    result = []\n    dfs(1, {1}, [1], result)\n    for path in result:\n        if is_valid(path):\n            for i in range(N):\n                if i not in arrows:\n                    arrows[i] = path[i]\n            break\n\n    for i in range(1, N):\n        arrows[a[N - 1]] = i\n        if is_valid(list(arrows.values())):\n            return \" \".join(map(str, list(arrows.values())))\n        del arrows[a[N - 1]]\n\n    return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    # create the adjacency matrix\n    adj = [[0 for _ in range(N)] for _ in range(N)]\n    # initialize the adjacency matrix\n    for i in range(N):\n        adj[a[i]-1][i] = 1\n    # start the bfs\n    queue = [(0, 0)]\n    visited = [False] * N\n    visited[0] = True\n    level = 0\n    while queue:\n        next_queue = []\n        for i, j in queue:\n            if i == level and not visited[j]:\n                visited[j] = True\n                # check if we have reached K times\n                if level == K-1:\n                    result = [0] * N\n                    for i in range(N):\n                        for j in range(N):\n                            if adj[i][j]:\n                                result[i] = j+1\n                    return \" \".join(map(str, result))\n                # add the next level to the queue\n                for k in range(N):\n                    if not visited[k] and adj[j][k]:\n                        next_queue.append((level+1, k))\n        queue = next_queue\n    return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    for i in range(1, N+1):\n        if i not in a:\n            print(\"Impossible\")\n            return\n    arrows = [[] for _ in range(N)]\n    for i in range(N):\n        arrows[a[i]-1].append(i)\n    for i in range(N):\n        if len(arrows[i]) != 1:\n            print(\"Impossible\")\n            return\n    result = []\n    for i in range(N):\n        for j in range(N):\n            if arrows[j][0] == i:\n                result.append(j+1)\n    return ' '.join(map(str, result))\n\ninput_string = \"\"\"6 2\n3 4 5 6 1 2\"\"\"\nprint(solution(input_string)) "
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    dance_sequence = list(map(int, stdin.split()[1].split(',')))\n    dance_map = [0] * (N + 1)\n\n    for i in range(1, N + 1):\n        dance_map[i] = dance_sequence[i - 1]\n\n    return ' '.join(map(str, dance_map))"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    if len(set(a)) != N:\n        return \"Impossible\"\n\n    # Reconstruct the arrows from the two photos\n    arrows = [0] * N\n    for i in range(N):\n        arrows[a[i] - 1] = i + 1\n\n    # Check if the dance performed K times would produce the two photos\n    for _ in range(K):\n        new_arrows = [0] * N\n        for i in range(N):\n            new_arrows[arrows[i] - 1] = i + 1\n        arrows = new_arrows\n\n    # Print the arrows if possible, otherwise print \"Impossible\"\n    if arrows == [0] * N:\n        return \"Impossible\"\n    else:\n        return \" \".join(map(str, arrows))\n"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    a = list(map(int, stdin.split()[1].split()))\n    \n    def dfs(num, visited, target, stack, res):\n        if len(stack) == K:\n            if stack != target:\n                return\n            for i in range(len(res)):\n                if res[i] is None:\n                    res[i] = stack[i]\n            return True\n        if num == N:\n            return False\n        for i in range(len(visited)):\n            if visited[i] == 0 and i != num - 1:\n                visited[i] = 1\n                stack.append(i + 1)\n                if dfs(num + 1, visited, target, stack, res):\n                    return True\n                stack.pop()\n                visited[i] = 0\n        return False\n\n    visited = [0] * N\n    stack = []\n    res = [None] * N\n    for i in range(N):\n        target = [a[i]]\n        if not dfs(1, visited, target, stack, res):\n            return \"Impossible\"\n\n    for i in range(N):\n        if res[i] is None:\n            res[i] = 1\n    res[res.index(1)] = 0\n    return ' '.join(map(str, res))"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    positions = list(map(int, stdin.split()[1].split(',')))\n    \n    if K > N * 10:\n        return \"Impossible\"\n    \n    arrows = [0] * N\n    \n    for i in range(1, N+1):\n        arrows[positions[i-1]-1] = i\n        \n    for i in range(1, N+1):\n        print(arrows[i-1], end=' ')\n        \n    return \"\"\n\ndef"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    positions = list(map(int, stdin.split()[1].split(',')))\n    \n    # Initialize adjacency list\n    adj_list = [[] for _ in range(N)]\n    \n    for i in range(N):\n        adj_list[positions[i] - 1].append(i)\n    \n    # Find all possible arrows\n    arrows = []\n    \n    def find_arrows(node, visited):\n        nonlocal arrows\n        if visited[node]:\n            return\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            arrows.append((node, neighbor))\n            find_arrows(neighbor, visited)\n    \n    find_arrows(0, [False] * N)\n    \n    # Check if it's possible to produce the two photos\n    if len(arrows) < 2 * K:\n        return \"Impossible\"\n    \n    # Generate all possible placements of arrows\n    placements = []\n    \n    def backtrack(start, visited, path):\n        nonlocal placements\n        if len(path) == N:\n            placements.append(path)\n            return\n        \n        for i in range(start, N):\n            if not visited[i]:\n                visited[i] = True\n                backtrack(i + 1, visited, path + (i,))\n                visited[i] = False\n    \n    backtrack(0, [False] * N, ())\n    \n    # Find the placement that produces the two photos\n    for placement in placements:\n        if len([(i, placement[i]) for i in range(N) if placement[i] == i]) == 2 * K:\n            return ' '.join(map(str, placement))\n    \n    return \"Impossible\""
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    a = list(map(int, stdin.split()[1].split(',')))\n    a = [i-1 for i in a]\n\n    def find_paths(N, K, a):\n        def backtrack(path, current):\n            if len(path) == K:\n                yield path\n                return\n            for i in range(current+1, N):\n                path.append(i)\n                yield from backtrack(path, i)\n                path.pop()\n\n        paths = list(backtrack([0], 0))\n        return [[a[i-1] for i in path] for path in paths]\n\n    def is_valid(N, a, arrows):\n        visited = [False] * N\n        for i in range(N):\n            visited[a[i]] = True\n        for i in range(N):\n            if not visited[i]:\n                return False\n        for i in range(N):\n            for j in range(i+1, N):\n                if arrows[a[i]][a[j]] or arrows[a[j]][a[i]]:\n                    return False\n        return True\n\n    arrows = [[False] * N for _ in range(N)]\n    for paths in find_paths(N, K, a):\n        for i in range(N):\n            for j in range(i+1, N):\n                if paths[a[i]] == paths[a[j]]:\n                    return \"Impossible\"\n                arrows[a[i]][a[j]] = True\n                arrows[a[j]][a[i]] = True\n        if is_valid(N, a, arrows):\n            return \" \".join(str(i) for i in range(N))\n    return \"Impossible\""
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.rstrip()\n    input_list = input_str.split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n\n    def swap_digits(num):\n        digits = [int(d) for d in str(num)]\n        for _ in range(k):\n            for i in range(len(digits) - 1):\n                if digits[i] < digits[i + 1]:\n                    digits[i], digits[i + 1] = digits[i + 1], digits[i]\n                    break\n        return int(''.join(str(d) for d in digits))\n\n    result = swap_digits(n)\n    return str(result)"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [int(d) for d in str(n)]\n\n    # reverse the digits list\n    digits = digits[::-1]\n\n    for _ in range(k):\n        # find two digits that can be swapped\n        for i in range(len(digits) - 1):\n            if digits[i] != 0 and digits[i + 1] != 0:\n                break\n        else:\n            # no swaps possible, break the loop\n            break\n\n        # swap the digits\n        digits[i], digits[i + 1] = digits[i + 1], digits[i]\n\n    # reverse the digits list\n    digits = digits[::-1]\n\n    # convert the list of digits back to a number\n    result = int(''.join(map(str, digits)))\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split()\n    n = int(input_list[0])\n    k = int(input_list[1])\n\n    def swap(num: int, i: int, j: int) -> int:\n        mask = 1 << 31\n        num &= mask - 1\n        num ^= (num >> 31) - 1\n        num ^= (num << 31)\n        return (num & (mask - (1 << i) | 1 << j)) | (num & (1 << i) | 1 << j)) >> j\n\n    def get_largest_number(n: int, k: int) -> int:\n        num = n\n        for _ in range(k):\n            max_swap = -1\n            max_value = -1\n            for i in range(len(str(num))):\n                for j in range(i + 1, len(str(num))):\n                    new_num = swap(num, i, j)\n                    if new_num > max_value:\n                        max_value = new_num\n                        max_swap = (i, j)\n            num = max_value\n        return num\n\n    largest_number = get_largest_number(n, k)\n    return str(largest_number)"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    str_n = str(n)\n    max_n = n\n\n    for _ in range(k):\n        max_n_str = str(max_n)\n        for i in range(len(max_n_str)):\n            for j in range(i+1, len(max_n_str)):\n                max_n_swap = int(max_n_str[:i] + max_n_str[j] + max_n_str[i+1:j] + max_n_str[i] + max_n_str[j+1:])\n                max_n = max(max_n, max_n_swap)\n\n    return str(max_n)\n"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = list(str(n))\n    max_num = ''.join(sorted(digits, reverse=True))\n    \n    def swap_digits(num, i, j):\n        num[i], num[j] = num[j], num[i]\n        return num\n    \n    for i in range(k):\n        for j in range(len(digits)-1):\n            if digits[j] != '0' and digits[j+1] != '0':\n                swap_digits(digits, j, j+1)\n                break\n    return ''.join(digits)"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = list(str(n))\n    for _ in range(k):\n        i, j = max(range(len(digits)), key=digits.index), min(range(len(digits)), key=digits.index)\n        if digits[i] == '0' or digits[j] == '0':\n            break\n        digits[i], digits[j] = digits[j], digits[i]\n    return ''.join(digits)\n\ninput_str = \"1374 2\"\nprint(solution(input_str))\n\ninput_str = \"210 1\"\nprint(solution(input_str)) "
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n, k = int(input_list[0]), int(input_list[1])\n\n    def swap(num: str, i: int, j: int) -> str:\n        if i == j:\n            return num\n        left, right = num[:i], num[i+1:]\n        mid = num[i]\n        return right + mid + left\n\n    def is_valid(num: str) -> bool:\n        return not (num[0] == '0' and len(num) > 1)\n\n    def find_largest_number(num: str, k: int) -> str:\n        max_num = num\n        for i in range(len(num)-1):\n            for j in range(i+1, len(num)):\n                new_num = swap(max_num, i, j)\n                if is_valid(new_num) and k > 0:\n                    k -= 1\n                    max_num = find_largest_number(new_num, k)\n        return max_num\n\n    if k == 0:\n        return n\n    largest_number = find_largest_number(str(n), k)\n    return largest_number "
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [int(d) for d in str(n)]\n    \n    def swap(digits, i, j):\n        digits[i], digits[j] = digits[j], digits[i]\n        return digits\n\n    def is_valid(digits):\n        return not (digits[0] == 0 or digits[-1] == 0)\n\n    for _ in range(k):\n        for i in range(len(digits) - 1):\n            if not is_valid(swap(digits, i, i + 1)):\n                continue\n            digits = swap(digits, i, i + 1)\n            break\n\n    return ''.join(map(str, digits))"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = [int(d) for d in str(n)]\n    max_num = n\n    for _ in range(k):\n        max_swap = -1\n        for i in range(len(digits) - 1):\n            if digits[i] > 0 and digits[i+1] > 0:\n                swap_value = digits[i] + digits[i+1]\n                if swap_value > max_swap:\n                    max_swap = swap_value\n                    swap_pos = (i, i+1)\n        digits[swap_pos[0]], digits[swap_pos[1]] = digits[swap_pos[1]], digits[swap_pos[0]]\n        max_num = int(\"\".join(map(str, digits)))\n    return str(max_num)\n\ninput_1 = \"1374 2\"\noutput_1 = solution(input_1)\nprint(output_1)  # Output: 7413\n\ninput_2 = \"210 1\"\noutput_2 = solution(input_2)\nprint(output_2)  # Output: 201 "
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split()\n    n = int(input_str[0])\n    k = int(input_str[1])\n\n    def swap(num: int) -> int:\n        digits = list(str(num))\n        for _ in range(k):\n            if digits[0] == '0':\n                digits.pop(0)\n                digits.append('0')\n            else:\n                digits[0], digits[-1] = digits[-1], digits[0]\n                digits.pop(-1)\n        return int(''.join(digits))\n\n    return str(swap(n))\n"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def taxi_distance(cbd_points):\n        total_distance = 0\n        n = len(cbd_points)\n        for i in range(n):\n            distance = euclidean_distance(cbd_points[i][0], cbd_points[i][1], cbd_points[(i + 1) % n][0], cbd_points[(i + 1) % n][1])\n            total_distance += distance\n        return total_distance\n\n    def expected_distance(cbd_points):\n        total_distance = taxi_distance(cbd_points)\n        n = len(cbd_points)\n        expected_total_distance = 0\n        for i in range(n):\n            expected_distance = euclidean_distance(cbd_points[i][0], cbd_points[i][1], cbd_points[(i + 1) % n][0], cbd_points[(i + 1) % n][1])\n            expected_total_distance += expected_distance\n        return expected_total_distance / total_distance\n\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    cbd_points = [(int(x), int(y)) for x, y in [line.split() for line in input_list[1:]]]\n\n    expected_distance_value = expected_distance(cbd_points)\n    return f\"{expected_distance_value:.6f}\"\n"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n\n    def distance(a, b):\n        return sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\n\n    def shortest_distance(x, y, points):\n        dist = float('inf')\n        for p in points:\n            dist = min(dist, distance((x, y), p))\n        return dist\n\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    total_distance = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_distance += shortest_distance(*points[i], points[j])\n\n    return f\"{total_distance / (n * (n - 1)) / 2:.6f}\"\n\n\ninput_data = \"\"\"4\n0 0\n0 1\n1 1\n1 0\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    cbd = []\n    for i in range(1, n+1):\n        x, y = map(int, input_lines[i].split())\n        cbd.append((x, y))\n\n    # calculate the convex hull of the CBD\n    hull = ConvexHull(cbd)\n    convex_hull = [cbd[v] for v in hull.vertices]\n\n    # calculate the distance between the convex hull and the origin\n    distance = 0\n    for point in convex_hull:\n        distance += abs(point[0]) + abs(point[1])\n\n    return str(distance)\n"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def euclidean_distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    n, *cbd = stdin.split('\\n')\n    n = int(n)\n    cbd = [tuple(map(int, point.split())) for point in cbd]\n    cbd.append(cbd[0])\n    x_coords, y_coords = zip(*cbd)\n\n    min_distance = min(distance(x_coords[i], y_coords[i], x_coords[i+1], y_coords[i+1]) for i in range(n))\n    max_distance = max(euclidean_distance(x_coords[i], y_coords[i], x_coords[i+1], y_coords[i+1]) for i in range(n))\n    expected_distance = (min_distance + max_distance) / 2\n\n    return '{:.6f}'.format(expected_distance)"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def convex_polygon_area(points):\n        n = len(points)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += points[i][0] * points[j][1]\n            area -= points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def expected_distance(n, points):\n        area = convex_polygon_area(points)\n        perimeter = 2 * area / n\n        return perimeter / 2\n\n    n, *points = map(int, stdin.split())\n    points = [tuple(points[i:i + 2]) for i in range(0, len(points), 2)]\n    result = expected_distance(n, points)\n    return f\"{result:.6f}\"\n"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *cbd = stdin.splitlines()\n    n = int(n)\n    cbd = [[int(x) for x in line.split()] for line in cbd]\n\n    def taxi_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def distance(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        return taxi_distance(x1, y1, x2, y2)\n\n    def polygon_area(points):\n        area = 0\n        for i in range(len(points)):\n            j = (i + 1) % len(points)\n            area += points[i][0] * points[j][1] - points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    polygon_area_cbd = polygon_area(cbd)\n\n    expected_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            expected_distance += polygon_area_cbd * distance(cbd[i], cbd[j])\n\n    expected_distance /= polygon_area_cbd\n\n    return f\"{expected_distance:.6f}\""
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from functools import reduce\n    import sys\n    import random\n    from itertools import permutations\n    from math import sqrt, pi\n    \n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n    \n    def polygon_area(points):\n        points = points + [points[0]]\n        return 0.5 * abs(reduce(lambda x, y: x + y, [points[i][0] * points[i + 1][1] - points[i + 1][0] * points[i][1] for i in range(len(points) - 1)]))\n    \n    def taxi_distance(pick_up, drop_off, points):\n        min_distance = sys.float_info.max\n        for perm in permutations(points):\n            perm = list(perm) + [perm[0]]\n            for i in range(len(perm) - 1):\n                if (perm[i][0] == perm[i + 1][0] or perm[i][1] == perm[i + 1][1]):\n                    continue\n                if distance(perm[i], perm[i + 1]) == 0:\n                    continue\n                if distance(perm[i], perm[i + 1]) + distance(perm[i + 1], perm[i + 2]) >= distance(perm[i], perm[i + 2]):\n                    continue\n                distance_so_far = distance(perm[i], pick_up) + distance(perm[i], perm[i + 1]) + distance(perm[i + 1], perm[i + 2])\n                if distance_so_far < min_distance:\n                    min_distance = distance_so_far\n        return min_distance\n    \n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    points = [tuple(map(int, input_data[i + 1].split())) for i in range(n)]\n    polygon_area_value = polygon_area(points)\n    \n    if polygon_area_value == 0:\n        return \"0.0\"\n    \n    expected_distance = 0\n    for i in range(n):\n        pick_up = points[i]\n        for j in range(i + 1, n):\n            drop_off = points[j]\n            expected_distance += taxi_distance(pick_up, drop_off, points)\n    \n    expected_distance /= (n * (n - 1) / 2)\n    \n    return f\"{expected_distance:.6f}\""
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    total_distance = 0\n    for i in range(n):\n        total_distance += abs(points[i][0] - points[(i+1)%n][0]) + abs(points[i][1] - points[(i+1)%n][1])\n    return round(total_distance / n, 6)\n\n\ndef"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    cbd_points = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n    \n    # Calculate the area of the convex polygon\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += cbd_points[i][0] * cbd_points[j][1]\n        area -= cbd_points[j][0] * cbd_points[i][1]\n    area = abs(area) / 2\n    \n    # Calculate the expected distance\n    expected_distance = area / (2 * (n-2))\n    \n    return f\"{expected_distance:.6f}\"\n\n\ninput_list = [\n    \"4\",\n    \"0 0\",\n    \"0 1\",\n    \"1 1\",\n    \"1 0\"\n]\n\noutput = solution('\\n'.join(input_list))\nprint(output) "
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: tuple, b: tuple) -> float:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def is_inside(point: tuple, polygon: list) -> bool:\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(1, n + 1):\n            p2 = polygon[i % n]\n            if (point[1] > min(p1[1], p2[1])):\n                if (point[0] <= max(p1[0], p2[0])):\n                    if (point[1] <= max(p1[1], p2[1])) and (point[0] < (p1[0] + (p2[0] - p1[0]) * (point[1] - p1[1]) / (p2[1] - p1[1]))):\n                        inside = not inside\n            p1 = p2\n        return inside\n\n    def expected_distance(polygon: list) -> float:\n        total_distance = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if is_inside((polygon[i], polygon[j]), polygon):\n                    total_distance += distance(polygon[i], polygon[j])\n        return total_distance / (n * (n - 1) / 2)\n\n    n = int(stdin.readline().strip())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, stdin.readline().strip().split())\n        polygon.append((x, y))\n\n    return '{:.6f}'.format(expected_distance(polygon))\n\ninput_data = [\n    \"4\\n0 0\\n0 1\\n1 1\\n1 0\",\n    \"3\\n0 0\\n1 1\\n2 0\",\n]\n\nfor input_line in input_data:\n    print(solution(input_line)) "
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.splitlines()[0].split())\n    floor_plan = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def cost(router_count):\n        total_cost = 0\n        for i in range(N):\n            for j in range(M):\n                total_cost += floor_plan[i][j] * router_count[i][j]\n        return total_cost + K * (M - router_count.count(2) - router_count.count(3))\n\n    router_count = [[0] * M for _ in range(N)]\n    best_cost = cost(router_count)\n\n    for i in range(N):\n        for j in range(M):\n            for r in range(1, 4):\n                router_count[i][j] = r\n                current_cost = cost(router_count)\n                if current_cost < best_cost:\n                    best_cost = current_cost\n                elif r > 1:\n                    break\n\n    return str(best_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    costs = [[0] * M for _ in range(N)]\n    for i in range(N):\n        costs[i] = list(map(int, stdin.split()))\n\n    # Calculate the cost to install a router in each office\n    router_costs = [[0] * M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            router_costs[i][j] = costs[i][j]\n\n    # Calculate the cost to install a cellular hub in each corridor\n    hub_costs = [[0] * M for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            hub_costs[i][j] = K\n\n    # Initialize the cost to provide a wireless network for each corridor\n    corridor_costs = [[0] * M for _ in range(N)]\n\n    # Initialize the minimum cost to provide a wireless network for each corridor\n    min_corridor_costs = [[0] * M for _ in range(N)]\n\n    # Calculate the cost to provide a wireless network for each corridor\n    for i in range(N):\n        for j in range(M):\n            if i == 0 and j == 0:\n                corridor_costs[i][j] = router_costs[i][j]\n                min_corridor_costs[i][j] = router_costs[i][j]\n            elif i == N - 1 and j == M - 1:\n                corridor_costs[i][j] = router_costs[i][j]\n                min_corridor_costs[i][j] = router_costs[i][j]\n            elif j > 0 and i < N - 1 and j < M - 1:\n                # Corridor is adjacent to both offices, so there is a conflict\n                corridor_costs[i][j] = hub_costs[i][j]\n                min_corridor_costs[i][j] = corridor_costs[i][j]\n            elif j == 0 and i > 0 and i < N - 1:\n                # Corridor is adjacent to an office in the first row\n                corridor_costs[i][j] = hub_costs[i][j] + min(min_corridor_costs[i - 1][j], min_corridor_costs[i + 1][j]))\n                min_corridor_costs[i][j] = corridor_costs[i][j]\n            elif j == M - 1 and i > 0 and i < N - 1:\n                # Corridor is adjacent to an office in the last row\n                corridor_costs[i][j] = hub_costs[i][j] + min(min_corridor_costs[i - 1][j], min_corridor_costs[i + 1][j]))\n                min_corridor_costs[i][j] = corridor_costs[i][j]\n            elif i == 0 and j > 0 and i < N - 1:\n                # Corridor is adjacent to an office in the first column\n                corridor_costs[i][j] = hub_costs[i][j] + min(min_corridor_costs[i][j - 1], min_corridor_costs[i][j + 1])\n                min_corridor_costs[i][j] = corridor_costs[i][j]\n            elif i == N - 1 and j > 0 and j < M - 1:\n                # Corridor is adjacent to an office in the last column\n                corridor_costs[i][j] = hub_costs[i][j] + min(min_corridor_costs[i][j - 1], min_corridor_costs[i][j + 1])\n                min_corridor_costs[i][j] = corridor_costs[i][j]\n            else:\n                # Corridor is"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    floor_plan = [list(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    dp = [[0] * M for _ in range(N)]\n\n    for i in range(N):\n        for j in range(M):\n            dp[i][j] = floor_plan[i][j]\n\n    for i in range(N - 1):\n        for j in range(M):\n            dp[i][j] += min(dp[i + 1][j], floor_plan[i + 1][j])\n\n    for j in range(M):\n        for i in range(N - 1):\n            dp[i][j] += min(dp[i][j + 1], floor_plan[i][j + 1])\n\n    for i in range(N - 2, -1, -1):\n        for j in range(M - 1, -1, -1):\n            dp[i][j] += min(dp[i + 1][j], floor_plan[i + 1][j])\n\n    for j in range(M - 1, -1, -1):\n        for i in range(N - 2, -1, -1):\n            dp[i][j] += min(dp[i][j + 1], floor_plan[i][j + 1])\n\n    result = min(dp[0][0], dp[0][M - 1], dp[N - 1][0], dp[N - 1][M - 1])\n    if result > 0:\n        result += K\n\n    return result\n\n\ninput_data = \"\"\"2 3 4\n10 1 3\n0 1 20\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"2 3 100\n10 1 10\n10 1 10\"\"\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    cost = [list(map(int, stdin.split()[3:][i * M:(i + 1) * M])) for i in range(N)]\n\n    # Create a 2D array to represent the coverage of each corridor by routers\n    coverage = [[0] * M for _ in range(N)]\n\n    def get_cost(x, y):\n        if x < 0 or x >= N or y < 0 or y >= M:\n            return 0\n        return cost[x][y]\n\n    def update_coverage(x, y, corridor):\n        if x < 0 or x >= N or y < 0 or y >= M:\n            return\n        if coverage[x][y] == 0:\n            coverage[x][y] = corridor\n        elif coverage[x][y] == corridor:\n            return\n        elif coverage[x][y] == -1:\n            coverage[x][y] = corridor\n        else:\n            coverage[x][y] = -2\n\n    def has_weak_signal(x, y):\n        if x > 0 and get_cost(x - 1, y) == 0:\n            return True\n        if x < N - 1 and get_cost(x + 1, y) == 0:\n            return True\n        if y > 0 and get_cost(x, y - 1) == 0:\n            return True\n        if y < M - 1 and get_cost(x, y + 1) == 0:\n            return True\n        return False\n\n    def has_conflicting_signal(x, y):\n        if x > 0 and get_cost(x - 1, y) > 0 and coverage[x - 1][y] != -1:\n            return True\n        if x < N - 1 and get_cost(x + 1, y) > 0 and coverage[x + 1][y] != -1:\n            return True\n        if y > 0 and get_cost(x, y - 1) > 0 and coverage[x][y - 1] != -1:\n            return True\n        if y < M - 1 and get_cost(x, y + 1) > 0 and coverage[x][y + 1] != -1:\n            return True\n        return False\n\n    def find_corridor_with_weak_signal(x, y):\n        if x > 0 and not has_weak_signal(x - 1, y):\n            return x - 1, y\n        if x < N - 1 and not has_weak_signal(x + 1, y):\n            return x + 1, y\n        if y > 0 and not has_weak_signal(x, y - 1):\n            return x, y - 1\n        if y < M - 1 and not has_weak_signal(x, y + 1):\n            return x, y + 1\n        return None, None\n\n    def find_corridor_with_conflicting_signal(x, y):\n        if x > 0 and not has_conflicting_signal(x - 1, y):\n            return x - 1, y\n        if x < N - 1 and not has_conflicting_signal(x + 1, y):\n            return x + 1, y\n        if y > 0 and not has_conflicting_signal(x, y - 1):\n            return x, y - 1\n        if y < M - 1 and not has_conflicting_signal(x, y + 1):\n            return x, y + 1\n        return None, None\n\n    def install_cellular_hub(x, y):\n        total_cost = 0\n        if x > 0 and get_cost(x - 1, y) == 0:\n            update_coverage(x - 1, y, -1)\n            total_cost += K\n        if x < N - 1 and get_cost(x + 1, y) == 0:\n            update_coverage(x + 1, y, -1)\n            total_cost += K\n        if y >"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    costs = [[int(c) for c in input().split()] for _ in range(N)]\n    dp = [[0] * (M+1) for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(1, M+1):\n            for ii in range(i-1, i+2):\n                for jj in range(j-1, j+2):\n                    if ii >= 0 and ii < N and jj >= 0 and jj < M and (ii != i or jj != j):\n                        dp[i][j] = max(dp[i][j], costs[ii][jj] + dp[ii][jj])\n            dp[i][j] = max(dp[i][j], K)\n    \n    return dp[N][M]"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M, K = map(int, input_data[0].split())\n    cost_matrix = [list(map(int, input_data[i].split())) for i in range(1, N + 1)]\n\n    # Initialize the cost matrix with the cost of installing a router in each cell\n    router_cost = [[cost_matrix[i][j] for j in range(M)] for i in range(N)]\n\n    # Initialize the cost matrix with the cost of installing a cellular hub in each corridor\n    cellular_hub_cost = [[0 for j in range(M)] for i in range(N)]\n\n    # Initialize the adjacency matrix with the cost of connecting two offices by a corridor\n    adjacency_matrix = [[0 for j in range(M)] for i in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i > 0:\n                adjacency_matrix[i][j] += cost_matrix[i - 1][j]\n            if j > 0:\n                adjacency_matrix[i][j] += cost_matrix[i][j - 1]\n            if i < N - 1:\n                adjacency_matrix[i][j] += cost_matrix[i + 1][j]\n            if j < M - 1:\n                adjacency_matrix[i][j] += cost_matrix[i][j + 1]\n\n    # Initialize the adjacency matrix with the cost of connecting two offices by a corridor with a cellular hub\n    cellular_hub_adjacency_matrix = [[0 for j in range(M)] for i in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i > 0:\n                cellular_hub_adjacency_matrix[i][j] += cost_matrix[i - 1][j] + K\n            if j > 0:\n                cellular_hub_adjacency_matrix[i][j] += cost_matrix[i][j - 1] + K\n            if i < N - 1:\n                cellular_hub_adjacency_matrix[i][j] += cost_matrix[i + 1][j] + K\n            if j < M - 1:\n                cellular_hub_adjacency_matrix[i][j] += cost_matrix[i][j + 1] + K\n\n    # Initialize the cost matrix with the minimum cost to cover every corridor\n    cost_matrix = [[adjacency_matrix[i][j] for j in range(M)] for i in range(N)]\n\n    # Initialize the minimum cost to cover every corridor with a cellular hub\n    cellular_hub_cost_matrix = [[cellular_hub_adjacency_matrix[i][j] for j in range(M)] for i in range(N)]\n\n    # Initialize the minimum cost matrix\n    min_cost_matrix = [[max(router_cost[i][j], cellular_hub_cost_matrix[i][j]) for j in range(M)] for i in range(N)]\n\n    # Find the minimum cost to cover every corridor\n    for i in range(N):\n        for j in range(M):\n            for k in range(i - 1, -1, -1):\n                if adjacency_matrix[k][j] > adjacency_matrix[i][j]:\n                    min_cost_matrix[i][j] = min(min_cost_matrix[i][j], min_cost_matrix[k][j] + router_cost[i][j])\n            for k in range(j - 1, -1, -1):\n                if adjacency_matrix[i][k] > adjacency_matrix[i][j]:\n                    min_cost_matrix[i][j] = min(min_cost_matrix[i][j], min_cost_matrix[i][k] + router_cost[i][j])\n\n    # Find the minimum cost to cover every corridor with a cellular hub\n    for i in range(N):\n        for j in range(M):\n            for k in range(i - 1, -1, -1):\n"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M, K = map(int, input_data[0].split())\n    cost_matrix = [list(map(int, input_data[i+1].split())) for i in range(N)]\n\n    def find_adjacent_cells(x, y):\n        adjacent_cells = []\n        if x > 0:\n            adjacent_cells.append((x-1, y))\n        if x < N-1:\n            adjacent_cells.append((x+1, y))\n        if y > 0:\n            adjacent_cells.append((x, y-1))\n        if y < M-1:\n            adjacent_cells.append((x, y+1))\n        return adjacent_cells\n\n    def calculate_cost(x, y, matrix):\n        total_cost = 0\n        for i, j in find_adjacent_cells(x, y):\n            if matrix[i][j] > 0:\n                total_cost += matrix[i][j]\n        return total_cost\n\n    def get_corridor_cost(x, y, matrix):\n        corridor_cost = 0\n        if x > 0 and matrix[x-1][y] > 0:\n            corridor_cost = matrix[x-1][y]\n        if x < N-1 and matrix[x+1][y] > 0:\n            corridor_cost = max(corridor_cost, matrix[x+1][y])\n        if y > 0 and matrix[x][y-1] > 0:\n            corridor_cost = max(corridor_cost, matrix[x][y-1])\n        if y < M-1 and matrix[x][y+1] > 0:\n            corridor_cost = max(corridor_cost, matrix[x][y+1])\n        return corridor_cost\n\n    total_cost = 0\n    for x in range(N):\n        for y in range(M):\n            if cost_matrix[x][y] > 0:\n                total_cost += cost_matrix[x][y]\n                total_cost += calculate_cost(x, y, cost_matrix)\n                total_cost += get_corridor_cost(x, y, cost_matrix) * K\n\n    return str(total_cost)"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    lines = stdin.split('\\n')\n    N, M, K = map(int, lines[0].split())\n    costs = []\n    for i in range(1, N+1):\n        costs.append(list(map(int, lines[i].split())))\n\n    # Initialize variables\n    min_cost = float('inf')\n    router_count = [[0] * M for _ in range(N)]\n    corridor_count = [[0] * M for _ in range(N)]\n\n    # DP to find the minimum cost\n    for i in range(N):\n        for j in range(M):\n            if i > 0:\n                corridor_count[i][j] += corridor_count[i-1][j]\n            if j > 0:\n                corridor_count[i][j] += corridor_count[i][j-1]\n\n            if corridor_count[i][j] == 0:\n                min_cost = min(min_cost, costs[i][j] + K)\n            elif corridor_count[i][j] == 1:\n                min_cost = min(min_cost, costs[i][j] + 2 * K)\n            elif corridor_count[i][j] == 2:\n                min_cost = min(min_cost, costs[i][j] + 4 * K)\n\n    return min_cost"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    grid = [list(map(int, stdin.split()[3:][i*M:(i+1)*M])) for i in range(N)]\n    dp = [[0 for _ in range(M)] for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i == 0:\n                dp[i][j] = grid[i][j]\n            else:\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n    total_cost = dp[N-1][M-1]\n    cellular_hubs = 0\n    for i in range(N):\n        for j in range(M):\n            if dp[i][j] == dp[i-1][j] + grid[i][j]:\n                cellular_hubs += 1\n    total_cost += cellular_hubs * K\n    return total_cost"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, M, K = map(int, stdin.split())\n    grid = []\n    for _ in range(N):\n        grid.append(list(map(int, input().split())))\n\n    # Initialize variables\n    cost = [[0 for _ in range(M)] for _ in range(N)]\n    cellular_hub_cost = 0\n    router_count = 0\n\n    # Calculate the cost of installing a router for each cell\n    for i in range(N):\n        for j in range(M):\n            cost[i][j] = grid[i][j]\n            if i > 0 and cost[i - 1][j] != 0:\n                cost[i][j] += K\n            if i < N - 1 and cost[i + 1][j] != 0:\n                cost[i][j] += K\n            if j > 0 and cost[i][j - 1] != 0:\n                cost[i][j] += K\n            if j < M - 1 and cost[i][j + 1] != 0:\n                cost[i][j] += K\n\n    # Calculate the minimum cost of installing a router for each cell\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] != 0:\n                if i > 0 and grid[i - 1][j] != 0:\n                    cost[i][j] = min(cost[i][j], cost[i - 1][j])\n                if i < N - 1 and grid[i + 1][j] != 0:\n                    cost[i][j] = min(cost[i][j], cost[i + 1][j])\n                if j > 0 and grid[i][j - 1] != 0:\n                    cost[i][j] = min(cost[i][j], cost[i][j - 1])\n                if j < M - 1 and grid[i][j + 1] != 0:\n                    cost[i][j] = min(cost[i][j], cost[i][j + 1])\n\n    # Calculate the minimum cost of installing a router for each corridor\n    total_cost = 0\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] != 0:\n                if i > 0 and grid[i - 1][j] != 0:\n                    if cost[i - 1][j] != cost[i][j]:\n                        total_cost += K\n                if i < N - 1 and grid[i + 1][j] != 0:\n                    if cost[i + 1][j] != cost[i][j]:\n                        total_cost += K\n                if j > 0 and grid[i][j - 1] != 0:\n                    if cost[i][j - 1] != cost[i][j]:\n                        total_cost += K\n                if j < M - 1 and grid[i][j + 1] != 0:\n                    if cost[i][j + 1] != cost[i][j]:\n                        total_cost += K\n\n    # Calculate the minimum cost of installing a cellular hub for each corridor\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] != 0:\n                if i > 0 and grid[i - 1][j] != 0:\n                    if cost[i - 1][j] != cost[i][j]:\n                        cellular_hub_cost += K\n                if i < N - 1 and grid[i + 1][j] != 0:\n                    if cost[i + 1][j] != cost[i][j]:\n                        cellular_hub_cost += K\n                if j > 0 and grid[i][j - 1] != 0:\n                    if cost[i][j - 1] != cost[i][j]:\n                        cellular_hub_cost += K\n                if j < M - 1 and grid[i][j + 1] != 0:\n                    if cost[i][j + 1]"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, t, op = map(int, input_list[0].split())\n    grid_locations = [list(map(int, input_list[i].split())) for i in range(2, 2+m)]\n\n    # Calculate the valid number of ways to fill in the section\n    valid_ways = 0\n    for r1, c1 in grid_locations[0]:\n        for r2, c2 in grid_locations[1]:\n            if (op == 0 or op == 1) and (r1 == r2 or c1 == c2):\n                valid_ways += 1\n            elif (op == 2 or op == 3) and (r1 == r2 and c1 == c2):\n                valid_ways += 1\n\n    return str(valid_ways)\n\ninput_str = '''8 2 7 -\n1 1 1 2\n9 2 7 -\n1 1 1 2'''\n\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op = map(int, input().split())\n    grid_locations = [tuple(map(int, input().split())) for _ in range(m)]\n\n    # Define the valid ranges for numbers in the section\n    if op == 0:  # Addition\n        valid_range = range(1, n + 1)\n    elif op == 1:  # Subtraction\n        valid_range = range(1, n + 1)\n    elif op == 2:  # Multiplication\n        valid_range = range(1, (n + 1) // 2 + 1)\n    elif op == 3:  # Division\n        valid_range = range(1, n + 1)\n\n    # Count the number of valid ways to fill in the section\n    valid_ways = 0\n    for nums in itertools.combinations(valid_range, m):\n        if len(set(nums)) == m:  # Check if no number appears more than once\n            grid = {}\n            for r, c in grid_locations:\n                grid[(r, c)] = nums.pop()\n\n            # Check if the section can be reached using the arithmetic operator\n            if op == 0:  # Addition\n                target = sum(grid.values())\n            elif op == 1:  # Subtraction\n                target = grid[grid_locations[0]] - grid[grid_locations[1]]\n            elif op == 2:  # Multiplication\n                target = 1\n                for num in grid.values():\n                    target *= num\n            elif op == 3:  # Division\n                target = grid[grid_locations[0]] / grid[grid_locations[1]]\n\n            if target == t:\n                valid_ways += 1\n\n    return valid_ways\n"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def add(a, b):\n        return a + b\n\n    def subtract(a, b):\n        return a - b\n\n    def multiply(a, b):\n        return a * b\n\n    def divide(a, b):\n        if b == 0:\n            return None\n        return a / b\n\n    def valid_assignment(row, col, target, operator):\n        if operator == '+':\n            return target == sum(row[col])\n        elif operator == '-':\n            return target == subtract(row[col[0]], row[col[1]])\n        elif operator == '*':\n            return target == multiply(row[col[0]], row[col[1]])\n        elif operator == '/':\n            return target == divide(row[col[0]], row[col[1]])\n        else:\n            return False\n\n    def is_valid_assignment(assignment):\n        for row, target, operator in assignment:\n            if not valid_assignment(row, target, operator):\n                return False\n        return True\n\n    def kenken(n, m, t, op, locations):\n        rows = [0] * n\n        rows[0] = [0] * n\n        for location in locations:\n            rows[location[0] - 1][location[1] - 1] = m\n\n        if op == '+':\n            operator = add\n        elif op == '-':\n            operator = subtract\n        elif op == '*':\n            operator = multiply\n        elif op == '/':\n            operator = divide\n        else:\n            return 0\n\n        if is_valid_assignment(zip(rows, range(n), range(n), [operator])):\n            return 1\n        return 0\n\n    n, m, t, op = map(int, stdin.split())\n    locations = []\n    for _ in range(m):\n        row, col = map(int, input().split())\n        locations.append((row, col))\n\n    return str(kenken(n, m, t, op, locations))\n"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, t, op = input_list[0].split()\n    n, m, t = int(n), int(m), int(t)\n    if op == '+':\n        pass  # Add your logic for addition here\n    elif op == '-':\n        pass  # Add your logic for subtraction here\n    elif op == '*':\n        pass  # Add your logic for multiplication here\n    elif op == '/':\n        pass  # Add your logic for division here\n    else:\n        return \"Invalid operator\"\n    return str(num_ways)  # Replace num_ways with the calculated number of ways"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, t, op = input_list[0].split()\n    n, m, t = int(n), int(m), int(t)\n    grid_locations = [tuple(map(int, input_list[i].split())) for i in range(1, m+1)]\n\n    def valid_assignment(assignment):\n        if len(set(assignment)) != len(assignment):\n            return False\n        for i in range(m):\n            for j in range(m):\n                if i != j and grid_locations[i] == grid_locations[j]:\n                    return False\n        return True\n\n    def count_valid_assignments():\n        if op == '+':\n            total_assignments = t\n            for i in range(1, total_assignments+1):\n                if valid_assignment([i]*m):\n                    return 1\n            return 0\n        elif op == '-':\n            total_assignments = t + 1\n            for i in range(total_assignments):\n                if valid_assignment([i+1]*m):\n                    return 1\n            return 0\n        elif op == '*':\n            total_assignments = t + 1\n            for i in range(total_assignments):\n                if valid_assignment([i+1]*m):\n                    return 1\n            return 0\n        elif op == '/':\n            total_assignments = t + 1\n            for i in range(total_assignments):\n                if valid_assignment([i+1]*m):\n                    return 1\n            return 0\n\n    return str(count_valid_assignments())"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, t, op, grid = input().split()\n    n, m, t = int(n), int(m), int(t)\n    if op == '+':\n        a, b = t, 1\n    elif op == '-':\n        a, b = 1, -t\n    elif op == '*':\n        a, b = t, 0\n    else:\n        a, b = t, 1\n\n    if n == 4:\n        if m == 2:\n            return '2' if a == 2 and b == 3 else '1'\n        elif m == 3:\n            return '1'\n        elif m == 4:\n            return '2' if a == 2 and b == 4 else '1'\n        else:\n            return '0'\n    elif n == 5:\n        if m == 2:\n            return '1'\n        elif m == 3:\n            return '2'\n        else:\n            return '0'\n    elif n == 6:\n        if m == 3:\n            return '2' if a == 2 and b == 6 else '1'\n        else:\n            return '0'\n    elif n == 7:\n        if m == 3:\n            return '2' if a == 2 and b == 7 else '1'\n        elif m == 4:\n            return '2' if a == 2 and b == 10 else '1'\n        elif m == 5:\n            return '1'\n        else:\n            return '0'\n    elif n == 8:\n        if m == 2:\n            return '2' if a == 2 and b == 8 else '1'\n        elif m == 3:\n            return '1'\n        elif m == 4:\n            return '2' if a == 2 and b == 12 else '1'\n        else:\n            return '0'\n    elif n == 9:\n        if m == 2:\n            return '3' if a == 2 and b == 9 else '2'\n        elif m == 3:\n            return '2' if a == 2 and b == 12 else '1'\n        else:\n            return '0'\n    else:\n        return '0'\n\nn, m, t, op = input().split()\nprint(solution(' '.join([n, m, t, op]))) "
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, t, op = input_list[0].split()\n    n, m, t = int(n), int(m), int(t)\n    op = op[0]\n\n    # grid locations\n    grid_locations = input_list[1:m + 1]\n    grid_locations = [tuple(map(int, grid_location.split())) for grid_location in grid_locations]\n\n    # check if there is a valid way to fill in the section\n    valid_ways = 0\n    for r1, c1 in grid_locations:\n        for r2, c2 in grid_locations:\n            if r1 == r2 and c1 == c2:\n                continue\n            if (op == '+' or op == '-') and abs(r1 - r2) + abs(c1 - c2) == 1:\n                valid_ways += 1\n            elif (op == '*' or op == '/') and abs(r1 - r2) * abs(c1 - c2) == 1:\n                valid_ways += 1\n\n    return str(valid_ways)"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, t, op = map(int, input_data[0].split())\n    locations = input_data[1:1+m]\n    locations = [list(map(int, location.split())) for location in locations]\n\n    if op == 0:  # addition or multiplication\n        valid_count = sum(1 for i in range(1, n+1) for j in range(1, n+1) if t == i*j)\n    elif op == 1:  # subtraction\n        valid_count = sum(1 for i in range(1, n+1) for j in range(1, n+1) if t == i-j)\n    elif op == 2:  # division\n        valid_count = sum(1 for i in range(1, n+1) for j in range(1, n+1) if i%j == 0 and t == i//j)\n\n    return str(valid_count)"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_possible_digits(row, col, n):\n        digits = set(range(1, n + 1))\n        if row > 0:\n            digits.discard(grid[row - 1][col])\n        if col > 0:\n            digits.discard(grid[row][col - 1])\n        if row > 0 and col > 0:\n            digits.discard(grid[row - 1][col - 1])\n        return digits\n\n    def get_valid_operations(target, digits):\n        valid_operations = []\n        for digit in digits:\n            if target - digit in digits:\n                valid_operations.append((target - digit, digit))\n        return valid_operations\n\n    def is_valid_assignment(row, col, target, digits, operation):\n        if operation[0] > digits:\n            return False\n        total = operation[0] + operation[1]\n        if total != target:\n            return False\n        if grid[row][col] in digits:\n            digits.remove(grid[row][col])\n        return True\n\n    def count_valid_assignments(target, digits, operation):\n        count = 0\n        for row in range(n):\n            for col in range(n):\n                if grid[row][col] == target:\n                    count += len(get_valid_operations(target, get_possible_digits(row, col, n)))\n        return count\n\n    lines = stdin.splitlines()\n    n, m, t, op = map(int, lines[0].split())\n    grid = [[0] * n for _ in range(n)]\n    for line in lines[1:]:\n        r, c = map(int, line.split())\n        grid[r - 1][c - 1] = t\n\n    target = grid[0][0]\n    digits = get_possible_digits(0, 0, n)\n    operation = get_valid_operations(target, digits)[0]\n\n    count = count_valid_assignments(target, digits, operation)\n    return count\n"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m, t, op = input_data[0].split()\n    n, m, t = int(n), int(m), int(t)\n    if op == '+':\n        if t % 2 != 0:\n            return 0\n    elif op == '-':\n        if t % 2 != 1:\n            return 0\n    elif op == '*':\n        if t % 3 != 0:\n            return 0\n    elif op == '/':\n        if t % 3 != 1:\n            return 0\n\n    grid_locations = input_data[1:]\n    grid_locations = [tuple(map(int, line.split())) for line in grid_locations]\n\n    def is_valid(row, col, val, target):\n        if val > target:\n            return False\n        if (row - 1 >= 0 and grid[row - 1][col] == val) or (col - 1 >= 0 and grid[row][col - 1] == val):\n            return False\n        if op == '+':\n            if row - 1 >= 0 and col - 1 >= 0 and grid[row - 1][col - 1] == val:\n                return False\n        elif op == '-':\n            if row + 1 < n and col - 1 >= 0 and grid[row + 1][col - 1] == val:\n                return False\n        elif op == '*':\n            if row - 1 >= 0 and col - 1 >= 0 and grid[row - 1][col - 1] == val:\n                return False\n        elif op == '/':\n            if row + 1 < n and col + 1 < n and grid[row + 1][col + 1] == val:\n                return False\n        return True\n\n    valid_count = 0\n    for val in range(1, t + 1):\n        grid = [[0 for _ in range(m)] for _ in range(n)]\n        for i, (row, col) in enumerate(grid_locations):\n            if not is_valid(row, col, val, t):\n                break\n            grid[row][col] = val\n            if i == len(grid_locations) - 1:\n                valid_count += 1\n    return valid_count"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(city: int, visited: set, graph: dict, path: list, depth: int) -> int:\n        visited.add(city)\n        path.append(city)\n        if depth == len(graph):\n            return 1\n        count = 0\n        for neighbor in graph[city]:\n            if neighbor not in visited:\n                count += dfs(neighbor, visited, graph, path, depth + 1)\n        return count\n\n    def shortest_paths(N: int, M: int, roads: list) -> list:\n        graph = [[] for _ in range(N + 1)]\n        for road in roads:\n            graph[road[0]].append(road[1])\n        result = []\n        for road in roads:\n            visited = set()\n            path = []\n            count = dfs(road[0], visited, graph, path, 1)\n            result.append(count)\n        return result\n\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, stdin.split()[2:])) for _ in range(M)]\n    result = shortest_paths(N, M, roads)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_paths(graph, start, end):\n        queue = [(start, [start])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            for neighbor, weight in graph[vertex].items():\n                if neighbor not in path:\n                    new_path = path + [neighbor]\n                    if neighbor == end:\n                        yield new_path\n                    else:\n                        queue.append((neighbor, new_path))\n\n    def count_shortest_paths(graph, roads):\n        result = [0] * len(roads)\n        for road in roads:\n            origin, destination, length = road\n            paths = list(find_shortest_paths(graph, origin, destination))\n            for path in paths:\n                for other_path in paths:\n                    if path != other_path:\n                        for road in roads:\n                            if origin in road and destination in road:\n                                break\n                        else:\n                            result[roads.index(road)] += 1\n        return [x % 1000000007 for x in result]\n\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, stdin.split()[2:])) for _ in range(M)]\n    graph = [{} for _ in range(N + 1)]\n    for origin, destination, length in roads:\n        graph[origin][destination] = length\n    result = count_shortest_paths(graph, roads)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    DP = [1] * M\n\n    for i in range(M):\n        for j in range(i+1, M):\n            if roads[j][0] == roads[i][1]:\n                DP[j] += DP[i]\n                DP[j] %= 1000000007\n\n    return '\\n'.join(map(str, DP))\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    roads = [list(map(int, line.split())) for line in input_data[1:]]\n\n    # Initialize the graph with shortest paths as infinity\n    graph = [[float('inf')] * N for _ in range(N)]\n    for i in range(N):\n        graph[i][i] = 0\n\n    # Iterate through all roads and update the shortest paths\n    for road in roads:\n        o, d, l = road\n        graph[o - 1][d - 1] = l\n\n    # Calculate the shortest paths using Floyd-Warshall algorithm\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n    # Output the number of shortest paths containing the road\n    result = []\n    for road in roads:\n        o, d, l = road\n        shortest_path = graph[o - 1][d - 1]\n        if shortest_path == float('inf'):\n            result.append(0)\n        else:\n            count = 0\n            for i in range(N):\n                if graph[i][o - 1] + graph[o - 1][d - 1] + graph[d - 1][i] == shortest_path:\n                    count += 1\n            result.append(count % 1000000007)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [map(int, stdin.split()[2:5]) for _ in range(M)]\n    adjacency = [[] for _ in range(N+1)]\n    dist = [float('inf')] * (N+1)\n    \n    for u, v, w in roads:\n        adjacency[u].append((v, w))\n        adjacency[v].append((u, w))\n\n    # Dijkstra's Algorithm\n    dist[1] = 0\n    min_heap = [(0, 1)]\n    while min_heap:\n        d, u = heapq.heappop(min_heap)\n        if d > dist[u]:\n            continue\n        for v, w in adjacency[u]:\n            if d + w < dist[v]:\n                dist[v] = d + w\n                heapq.heappush(min_heap, (dist[v], v))\n\n    def count_shortest_paths(u, v, dist, adjacency):\n        queue = [(u, 0)]\n        visited = set()\n        count = 0\n        while queue:\n            curr, d = queue.pop(0)\n            if curr == v:\n                count += 1\n                continue\n            if (curr, d) in visited:\n                continue\n            visited.add((curr, d))\n            for v, w in adjacency[curr]:\n                if d + w < dist[v]:\n                    queue.append((v, d + w))\n        return count\n\n    result = []\n    for u, v, w in roads:\n        result.append(count_shortest_paths(u, v, dist, adjacency))\n\n    return '\\n'.join(str(r) for r in result)\n\ndef"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    MOD = 1000000007\n\n    N, M = map(int, stdin.split()[:2])\n    roads = defaultdict(list)\n    for _ in range(M):\n        origin, dest, length = map(int, stdin.split()[1:])\n        roads[origin].append((dest, length))\n\n    result = []\n    for origin in range(1, N + 1):\n        dp = [0] * (N + 1)\n        dp[origin] = 1\n        for dest, length in roads[origin]:\n            for i in range(dest - 1, origin, -1):\n                dp[i] = (dp[i] + dp[i + 1]) % MOD\n            dp[dest] = (dp[dest] + dp[dest] * dp[origin]) % MOD\n        result.append(dp[1:N + 1])\n\n    output = []\n    for i, d in enumerate(result):\n        output.append(sum(d))\n        for j in range(N):\n            output[-1] = (output[-1] + result[j][i]) % MOD\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data.pop(0).split())\n    roads = []\n    for _ in range(M):\n        O, D, L = map(int, input_data.pop(0).split())\n        roads.append((O, D, L))\n\n    # Initialize a matrix to store the length of shortest paths\n    shortest_paths = [[float('inf')] * N for _ in range(N)]\n    for i in range(N):\n        shortest_paths[i][i] = 0\n\n    # Floyd-Warshall algorithm to find all shortest paths\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                if shortest_paths[i][j] > shortest_paths[i][k] + shortest_paths[k][j]:\n                    shortest_paths[i][j] = shortest_paths[i][k] + shortest_paths[k][j]\n\n    # Initialize a list to store the number of shortest paths for each road\n    road_counts = [0] * M\n\n    for i, road in enumerate(roads):\n        O, D, L = road\n        if shortest_paths[O - 1][D - 1] < float('inf'):\n            road_counts[i] = (shortest_paths[O - 1][D - 1] + L) % 1000000007\n\n    result = '\\n'.join(map(str, road_counts))\n    return result "
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_shortest_paths(graph: list, visited: list, path_count: list, edge_index: int) -> None:\n        if edge_index == len(graph):\n            return\n        next_edge = graph[edge_index]\n        for i in range(1, N + 1):\n            if not visited[i]:\n                if i == next_edge[0]:\n                    visited[i] = True\n                    count_shortest_paths(graph, visited, path_count, edge_index + 1)\n                    visited[i] = False\n                elif i == next_edge[1]:\n                    visited[next_edge[0]] = True\n                    path_count[edge_index] += path_count[edge_index - 1]\n                    visited[next_edge[0]] = False\n                    visited[i] = True\n                    count_shortest_paths(graph, visited, path_count, edge_index + 1)\n                    visited[i] = False\n                    path_count[edge_index] -= path_count[edge_index - 1]\n\n    N, M = map(int, stdin.strip().split())\n    graph = [tuple(map(int, stdin.strip().split())) for _ in range(M)]\n    path_count = [0] * M\n    visited = [False] * (N + 1)\n\n    count_shortest_paths(graph, visited, path_count, 0)\n\n    return '\\n'.join(map(str, path_count))\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: dict, start: int, end: int) -> int:\n        dist = [float('inf')] * (N + 1)\n        dist[start] = 0\n        shortest_paths = [0] * (N + 1)\n\n        while True:\n            u = min(range(N + 1), key=lambda x: dist[x] if dist[x] != float('inf') else float('inf'))\n            if u == end:\n                return shortest_paths[end]\n            if dist[u] == float('inf'):\n                return -1\n            for v in graph[u]:\n                if dist[u] + v[1] < dist[v[0]]:\n                    dist[v[0]] = dist[u] + v[1]\n                    shortest_paths[v[0]] = shortest_paths[u] + 1\n            dist[u] = float('inf')\n\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split()[0:3])) for line in stdin.split('\\n')[1:M+1]]\n    graph = {i: [] for i in range(1, N+1)}\n    for u, v, w in roads:\n        graph[u].append((v, w))\n    for u in range(1, N+1):\n        for v, w in graph[u]:\n            graph[v].append((u, w))\n\n    result = [0] * M\n    for i, road in enumerate(roads):\n        o, d, _ = road\n        if dijkstra(graph, o, d) == -1:\n            result[i] = -1\n        else:\n            result[i] = dijkstra(graph, d, o)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, stdin.split()[2:])) for _ in range(M)]\n    adj_list = [[] for _ in range(N + 1)]\n    for origin, dest, length in roads:\n        adj_list[origin].append((dest, length))\n    dist = [10**9] * (N + 1)\n    dist[1] = 0\n    queue = [(0, 1)]\n    while queue:\n        d, node = heapq.heappop(queue)\n        if d > dist[node]:\n            continue\n        for neighbor, weight in adj_list[node]:\n            new_dist = d + weight\n            if new_dist < dist[neighbor]:\n                dist[neighbor] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor))\n    result = []\n    for _ in range(M):\n        result.append(dist[N])\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    fi = list(map(int, input_list[1].split()))\n    \n    # Calculate the number of possible ways to color the book\n    M = 1000000007\n    dp = [1] * (K + 1)\n    for i in range(K + 1, N + 1):\n        dp[i] = (dp[i - 1] + dp[i - K]) % M\n    result = dp[N]\n    \n    # Update the result if the image numbered fi[i] is different than i\n    for i in range(1, N + 1):\n        if i == fi[i - 1]:\n            continue\n        for j in range(1, K + 1):\n            if j == fi[fi[i - 1] - 1]:\n                continue\n            dp[i] = (dp[i] + dp[i - 1] - dp[j]) % M\n    result += dp[N]\n    \n    return str(result % M)\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    fi = list(map(int, stdin.split()[2:]))\n    M = 1000000007\n\n    dp = [1] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            dp[i] = (dp[i] + dp[i - 1]) % M\n        if i in fi:\n            dp[i] = (dp[i] - 1) % M\n\n    return str(dp[N])\n\n\ndef"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    f = list(map(int, input().split()))\n\n    MOD = 1000000007\n\n    def count_ways(n, k, f):\n        if n == 1:\n            return 1\n        if n == 2:\n            if f[0] == 1:\n                return k\n            else:\n                return k * (k - 1) // 2\n        if n == 3:\n            if f[0] == 1:\n                return k * (k - 1) * (k - 2) // 6\n            else:\n                return (k * (k - 1) * (k - 2)) // 2 + (k - 1) * (k - 2) * (k - 3) // 6\n        if n == 4:\n            if f[0] == 1:\n                return k * (k - 1) * (k - 2) * (k - 3) // 24\n            else:\n                return (k * (k - 1) * (k - 2) * (k - 3)) // 6 + (k - 1) * (k - 2) * (k - 3) * (k - 4) // 12\n\n        ways = 0\n        for i in range(1, K + 1):\n            ways += count_ways(n - 1, i, f[1:]) * (k - i)\n            ways %= MOD\n        return ways\n\n    answer = count_ways(N, K, f)\n    return str(answer)\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, K = map(int, input_list[0].split())\n    fi = list(map(int, input_list[1].split()))\n\n    MOD = 1000000007\n\n    dp = [1] * (N + 1)\n    for i in range(1, N + 1):\n        if fi[i - 1] == i:\n            dp[i] = (dp[i - 1] * (K - 1)) % MOD\n        else:\n            dp[i] = (dp[i - 1] * (K - 1) * K) % MOD\n\n    ans = (dp[N] * (K - 1) + dp[N] * K * (K - 1)) % MOD\n\n    return str(ans)\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    f_i = list(map(int, input().split()))\n\n    M = 1000000007\n    dp = [0] * (N + 1)\n    dp[0] = 1\n\n    for i in range(1, N + 1):\n        if i != f_i[i - 1]:\n            dp[i] = (K - 1) * dp[i - 1]\n        dp[i] %= M\n\n    result = sum(dp)\n    return result % M\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    f = list(map(int, stdin.split()[1:]))\n    MOD = 1000000007\n    M = 10**9 + 7\n    dp = [1] * (N + 1)\n    for i in range(1, N + 1):\n        dp[i] = dp[i - 1] * (K - 1) % MOD\n        if f[i - 1] != i:\n            dp[i] = (dp[i] * K) % MOD\n    result = sum(dp[1:]) % M\n    return str(result)\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    f = list(map(int, input().split()))\n    \n    mod = 1000000007\n    \n    dp = [[0] * K for _ in range(N+1)]\n    \n    for i in range(1, N+1):\n        for j in range(K):\n            if i == 1:\n                dp[i][j] = 1\n            elif i == f[i-1]:\n                for k in range(K):\n                    dp[i][j] += dp[i-1][k]\n                    if dp[i][j] >= mod:\n                        dp[i][j] %= mod\n            else:\n                dp[i][j] = dp[i-1][j]\n                if i > 1:\n                    dp[i][j] += dp[i-1][f[i-1]-1]\n                    if dp[i][j] >= mod:\n                        dp[i][j] %= mod\n    \n    result = dp[N][K-1]\n    return str(result % mod)"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    f = list(map(int, stdin.split()[2:]))\n    MOD = 1000000007\n\n    def count_ways(n: int, k: int) -> int:\n        if n == 1:\n            return 1\n        if k == 1:\n            return 0\n        if n == 2:\n            return k % MOD\n        if n == 3:\n            return k % MOD * k % MOD\n\n        ways = 0\n        ways_n1_k1 = count_ways(n - 1, k - 1)\n        ways_n1_k = count_ways(n - 1, k)\n        ways_n1_k1_n2_k1 = count_ways(n - 2, k - 1)\n\n        ways = (ways_n1_k1 + ways_n1_k1_n2_k1) % MOD\n\n        if n == 4:\n            return ways\n\n        for i in range(2, n - 2):\n            ways_n1_k1_n1_k1 = count_ways(n - i - 1, k - 1)\n            ways_n1_k1_n1_k = count_ways(n - i - 1, k)\n            ways_n1_k1_n1_k1_n2_k1 = count_ways(n - i - 2, k - 1)\n\n            ways = (ways + (ways_n1_k1_n1_k1 + ways_n1_k1_n1_k1_n2_k1) % MOD) % MOD\n\n        return ways\n\n    ways = count_ways(N, K)\n    return str(ways % MOD)"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    f_i = list(map(int, stdin.split()[2:]))\n\n    M = N * K\n    MOD = 1000000007\n    dp = [0] * (M + 1)\n    dp[0] = 1\n\n    for i in range(N):\n        for j in range(K):\n            index = (i + 1) * K + j + 1\n            dp[index] = dp[index - K] * (K - 1)\n            if i + 1 == f_i[i]:\n                dp[index] -= dp[index - K]\n            dp[index] %= MOD\n\n    return dp[M]\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    f = list(map(int, input().split()))\n    \n    # Calculate the number of possible ways to paint the first image\n    total_ways = K\n    \n    # Calculate the number of possible ways to paint the remaining images\n    for i in range(1, N):\n        if f[i] != i:\n            total_ways *= K - 1\n            total_ways %= 1000000007\n        else:\n            total_ways *= K\n            total_ways %= 1000000007\n            \n    return total_ways"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split('\\n')[1].split())\n    modulo = 10**9 + 7\n    MOD = 10**9 + 7\n    fact = [1] * (n + 1)\n    inv = [1] * (n + 1)\n    inv[1] = 1\n    fact[0] = fact[1] = 1\n    for i in range(2, n + 1):\n        fact[i] = (fact[i - 1] * i) % MOD\n\n    for i in range(n + 1, 0, -1):\n        inv[i] = pow(inv[i - 1], MOD - 2, MOD)\n\n    def choose(n, k):\n        return (fact[n] * inv[k] * inv[n - k]) % MOD\n\n    ways = choose(n, 2)\n    for i in range(2, n + 1):\n        if i == t:\n            ways = (ways * choose(n - 1, 2)) % MOD\n        else:\n            ways = (ways * choose(n - 1, 1)) % MOD\n\n    return ways % modulo\n\n\ndef"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_factors(n: int) -> set:\n        factors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                factors.add(i)\n                factors.add(n // i)\n        factors.remove(1)\n        return factors\n\n    n, *chairs = map(int, stdin.split())\n    chairs = set(chairs)\n    hops = chairs[::2]\n    hops_count = len(hops)\n\n    if hops_count % 2 != 0:\n        raise ValueError(\"Expected even number of hops.\")\n\n    ways = 1\n    for i in range(0, hops_count, 2):\n        factors = get_factors(chairs[i] - chairs[i + 1])\n        ways *= len(factors)\n        ways %= (10**9 + 7)\n\n    return ways\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if t[i] == j + 1 or t[i] == t[j] - (j + 1 - i):\n                dp[i] += dp[j]\n                dp[i] %= (10**9 + 7)\n\n    return str(dp[-1])\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    t = sorted(t)\n    \n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    dp[1][t[0]] = 1\n    \n    for i in range(2, n + 1):\n        for j in range(t[i - 1], n + 1):\n            if j > t[i - 2]:\n                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - t[i - 1]]\n            else:\n                dp[i][j] = dp[i - 1][j]\n    \n    return dp[n][n] % (10**9 + 7)"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def catalan(n: int) -> int:\n        if n <= 1:\n            return 1\n        return sum(catalan(i) * catalan(n - i - 1) for i in range(n)) % (10**9 + 7)\n\n    n, *t = map(int, stdin.split())\n    return catalan(n)\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    t_values = list(map(int, stdin[1].split()))\n\n    # Calculate the number of ways to choose the values of s_i\n    modulo = 10**9 + 7\n    result = 1\n    for i in range(n):\n        result = (result * (n - i)) % modulo\n\n    # Modulo the result\n    result = result % modulo\n\n    return str(result)\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    t_list = list(map(int, stdin[1].split()))\n    \n    # Calculate the total number of permutations\n    total_permutations = 1\n    for i in range(1, n + 1):\n        total_permutations *= i\n        \n    # Calculate the total number of ways to choose s_i\n    ways_to_choose_si = 1\n    for i in range(n):\n        ways_to_choose_si *= total_permutations - i\n        ways_to_choose_si %= 1000000007\n    \n    # Output the result\n    return str(ways_to_choose_si)\n\n\ndef"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def comb(n, r):\n        return (factorial(n) * factorial(r)) // (factorial(n - r)) % MOD\n\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result % MOD\n\n    n = int(stdin[0].split()[0])\n    ti = list(map(int, stdin[1].split()))\n\n    MOD = 10 ** 9 + 7\n\n    total_combinations = comb(n, n // 2)\n\n    result = 0\n    for i in range(n // 2, n):\n        s_i = ti[:i] + ti[i + 1:]\n        s_i.sort()\n        s_i = tuple(s_i)\n        result += comb(n, i) * comb(n - i, n // 2) * comb(n - n // 2, n - i) % MOD\n        result %= MOD\n\n    result *= total_combinations\n    result %= MOD\n\n    return str(result)\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import permutations\n    n, t = map(int, stdin.split())\n    t = sorted(t)\n    count = 0\n\n    for perm in permutations(range(1, n+1)):\n        s = [t[i-1] for i in perm]\n        if s == list(range(1, n+1)):\n            count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *t = map(int, stdin.split())\n    memo = [0] * n\n    memo[0] = 1\n\n    for i in range(1, n):\n        for j in range(i):\n            if t[i] == t[j] and i != j:\n                memo[i] += memo[j]\n                memo[i] %= 10**9 + 7\n\n    return str(sum(memo))\n\n\ndef"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix: list, i: int, j: int) -> bool:\n        r, s = len(matrix), len(matrix[0])\n        return matrix[i][j] + matrix[r-1][s-1] <= matrix[i][s-1] + matrix[r-1][j]\n\n    def find_extremely_cool_submatrix(matrix: list) -> int:\n        r, s = len(matrix), len(matrix[0])\n        result = 0\n        for i in range(r):\n            for j in range(s):\n                for height in range(2, r + 1):\n                    for width in range(2, s + 1):\n                        if all(is_cool(matrix, i, k) and is_cool(matrix, k, j) for k in range(i, i + height)):\n                            result = max(result, height * width)\n        return result\n\n    R, S = map(int, stdin.split()[0:2])\n    matrix = [list(map(int, stdin.split()[2 * i + 2:2 * i + 2 + S])) for i in range(R)]\n\n    result = find_extremely_cool_submatrix(matrix)\n    return str(result)\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(submatrix: list) -> bool:\n        first_row_sum = submatrix[0][0] + submatrix[0][-1]\n        last_row_sum = submatrix[-1][0] + submatrix[-1][-1]\n        return first_row_sum <= last_row_sum\n\n    def is_extremely_cool(matrix: list) -> bool:\n        rows, cols = len(matrix), len(matrix[0])\n        for i in range(rows - 1):\n            for j in range(cols - 1):\n                submatrix = [row[j:j + 2] for row in matrix[i:i + 2]]\n                if not is_cool(submatrix):\n                    return False\n        return True\n\n    R, S = map(int, stdin.split()[0:2])\n    matrix = [list(map(int, input().split())) for _ in range(R)]\n\n    if is_extremely_cool(matrix):\n        return max(matrix)\n    else:\n        return 0\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    R, S = map(int, input_list.pop(0).split())\n    A = []\n    for _ in range(R):\n        row = list(map(int, input_list.pop(0).split()))\n        A.append(row)\n\n    def is_cool(submatrix):\n        r, s = len(submatrix), len(submatrix[0])\n        return submatrix[0][0] + submatrix[r-1][s-1] <= submatrix[0][s-1] + submatrix[r-1][0]\n\n    def is_extremely_cool(matrix):\n        for i in range(1, R-1):\n            for j in range(1, S-1):\n                submatrix = [row[j:j+2] for row in matrix[i:i+2]]\n                if not is_cool(submatrix):\n                    return False\n        return True\n\n    if is_extremely_cool(A):\n        return str(sum(A[0][1:S]))\n    else:\n        return str(0)"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix):\n        r, s = len(matrix), len(matrix[0])\n        return r > 1 and s > 1 and matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def find_extremely_cool_elements(matrix):\n        r, s = len(matrix), len(matrix[0])\n        result = 0\n        for i in range(r - 2):\n            for j in range(s - 2):\n                if is_cool(matrix[i:i + 3, j:j + 3]):\n                    result += sum(sum(matrix[i:i + 3, j:j + 3]))\n        return result\n\n    R, S = map(int, stdin.split()[:2])\n    matrix = [[int(x) for x in input().split()] for _ in range(R)]\n\n    return str(find_extremely_cool_elements(matrix))\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix: list) -> bool:\n        rows, cols = len(matrix), len(matrix[0])\n        return all(sum(matrix[i][j] for j in range(s, cols)) - sum(matrix[i][j] for j in range(1, s)) <= sum(matrix[i][j] for j in range(s, cols)) - sum(matrix[i][j] for j in range(0, s)) for i in range(1, rows))\n\n    def is_extremely_cool(matrix: list) -> bool:\n        rows, cols = len(matrix), len(matrix[0])\n        for r in range(2, rows):\n            for s in range(2, cols):\n                submatrix = [row[s:] for row in matrix[:r]]\n                if not is_cool(submatrix):\n                    return False\n        return True\n\n    R, S = map(int, stdin.split()[:2])\n    matrix = [list(map(int, stdin.split()[2:])) for _ in range(R)]\n\n    if is_extremely_cool(matrix):\n        return sum(matrix[i][j] for i in range(1, R) for j in range(1, S))\n    else:\n        return 0"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix, r, s):\n        if r < 2 or s < 2:\n            return False\n        return matrix[0][0] + matrix[r - 1][s - 1] <= matrix[0][s - 1] + matrix[r - 1][0]\n\n    def max_submatrix(matrix, r, s):\n        max_size = 0\n        for i in range(r):\n            for j in range(s):\n                for k in range(i + 2, r + 1):\n                    for l in range(j + 2, s + 1):\n                        if is_cool(matrix, k - i, l - j):\n                            max_size = max(max_size, (k - i) * (l - j))\n        return max_size\n\n    R, S = map(int, stdin.split()[:2])\n    matrix = [list(map(int, stdin.split()[2:][i * S:(i + 1) * S])) for i in range(R)]\n    result = max_submatrix(matrix, R, S)\n    return str(result)\n\ninput_1 = \"\"\"3 3\n1 4 10\n5 2 6\n11 1 3\"\"\"\n\ninput_2 = \"\"\"3 3\n1 3 1\n2 1 2\n1 1 1\"\"\"\n\nprint(solution(input_1))  # Output: 9\nprint(solution(input_2))  # Output: 4 "
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(submatrix: List[List[int]]) -> bool:\n        rows, cols = len(submatrix), len(submatrix[0])\n        return submatrix[0][0] + submatrix[rows - 1][cols - 1] <= submatrix[0][cols - 1] + submatrix[rows - 1][0]\n\n    def is_extremely_cool(matrix: List[List[int]]) -> bool:\n        rows, cols = len(matrix), len(matrix[0])\n        for i in range(rows - 1):\n            for j in range(cols - 1):\n                submatrix = [matrix[k][j:j+2] for k in range(i, i+2)]\n                if not is_cool(submatrix):\n                    return False\n        return True\n\n    def count_elements(matrix: List[List[int]]) -> int:\n        count = 0\n        for row in matrix:\n            count += len(row)\n        return count\n\n    def main(matrix: List[List[int]]) -> int:\n        if is_extremely_cool(matrix):\n            return count_elements(matrix)\n        else:\n            return 0\n\n    def parse_input(input_str: str) -> List[List[int]]:\n        matrix = []\n        rows, cols = map(int, input_str.split()[:2])\n        for line in input_str.split('\\n')[1:]:\n            matrix.append([int(x) for x in line.split()])\n        return matrix\n\n    matrix = parse_input(stdin)\n    result = main(matrix)\n    return str(result)\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(submatrix):\n        r, s = len(submatrix), len(submatrix[0])\n        return submatrix[0][0] + submatrix[r-1][s-1] <= submatrix[0][s-1] + submatrix[r-1][0]\n\n    def is_extremely_cool(matrix):\n        r, s = len(matrix), len(matrix[0])\n        for i in range(1, r-1):\n            for j in range(1, s-1):\n                submatrix = [row[j:j+2] for row in matrix[i:i+2]]\n                if not is_cool(submatrix):\n                    return False\n        return True\n\n    r, s = map(int, stdin.split()[:2])\n    matrix = [list(map(int, stdin.split()[2:]))]\n    for _ in range(r-1):\n        matrix.append(list(map(int, input().split())))\n\n    if is_extremely_cool(matrix):\n        return sum(1 for row in matrix for elem in row)\n    else:\n        return 0\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(A):\n        r, s = len(A), len(A[0])\n        return r > 1 and s > 1 and A[0][0] + A[r-1][s-1] <= A[0][s-1] + A[r-1][0]\n\n    def is_extremely_cool(A):\n        r, s = len(A), len(A[0])\n        for i in range(r-1):\n            for j in range(s-1):\n                if not is_cool(A[i:i+2, j:j+2]):\n                    return False\n        return True\n\n    def count_elements(A):\n        count = 0\n        r, s = len(A), len(A[0])\n        for i in range(r):\n            for j in range(s):\n                count += len([1 for x in range(r) for y in range(s) if is_cool(A[i:i+2, j:j+2])])\n        return count\n\n    R, S = map(int, stdin.split()[:2])\n    A = [[int(x) for x in input().split()] for _ in range(R)]\n\n    if is_extremely_cool(A):\n        return count_elements(A)\n    else:\n        return 0\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix):\n        r, s = len(matrix), len(matrix[0])\n        return r > 1 and s > 1 and (matrix[0][0] + matrix[r-1][s-1] <= matrix[0][s-1] + matrix[r-1][0])\n\n    def is_extremely_cool(matrix):\n        r, s = len(matrix), len(matrix[0])\n        for i in range(r-1):\n            for j in range(s-1):\n                if not is_cool(matrix[i:i+2, j:j+2]):\n                    return False\n        return True\n\n    R, S = map(int, stdin.split()[:2])\n    matrix = [[int(x) for x in input().split()] for _ in range(R)]\n\n    if is_extremely_cool(matrix):\n        return sum(1 for i in range(R) for j in range(S) if is_cool(matrix[i:i+2, j:j+2]))\n    else:\n        return 0\n"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *jokes = stdin.split('\\n')\n    N = int(N)\n    jokes = list(map(int, jokes))\n\n    def find_supervisors(i: int) -> List[int]:\n        supervisors = [i]\n        for j in range(N):\n            if jokes[j] == i:\n                supervisors.append(j)\n        return supervisors\n\n    def find_jokes(i: int) -> List[int]:\n        jokes_i = [i]\n        for j in range(N):\n            if jokes[j] == i:\n                jokes_i.append(j)\n        return jokes_i\n\n    def is_set_consecutive(set_: List[int]) -> bool:\n        return all(set_[i+1] - set_[i] == 1 for i in range(len(set_)-1))\n\n    def find_set_jokes(i: int, visited: Set[int], supervisors: List[int]) -> List[List[int]]:\n        if i in visited:\n            return []\n        visited.add(i)\n\n        sets_jokes = []\n        for j in range(N):\n            if jokes[j] == i and j not in visited and j not in supervisors:\n                sets_jokes.extend(find_set_jokes(j, visited, supervisors))\n        if i == 0:\n            sets_jokes.append([])\n        sets_jokes = [[i] + s for s in sets_jokes]\n        return sets_jokes\n\n    count = 0\n    for i in range(1, N+1):\n        visited = set()\n        supervisors = find_supervisors(i)\n        sets_jokes = find_set_jokes(i, visited, supervisors)\n        for set_jokes in sets_jokes:\n            if is_set_consecutive(sorted(set_jokes)):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    V = list(map(int, stdin.split('\\n')[1].split()))\n    adj_list = [list(map(int, line.split())) for line in stdin.split('\\n')[2:] if line]\n\n    def dfs(node: int, visited: set, jokes: set, visited_jokes: set, result: set):\n        visited.add(node)\n        jokes.add(V[node - 1])\n        visited_jokes.add(V[node - 1])\n\n        for neighbor in [adj_list[i][1] for i in range(len(adj_list)) if adj_list[i][0] == node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, jokes, visited_jokes, result)\n\n        if len(visited_jokes) == N and len(visited_jokes) == len(set(visited_jokes)):\n            result.add(frozenset(visited_jokes))\n\n        visited.remove(node)\n        jokes.remove(V[node - 1])\n        visited_jokes.remove(V[node - 1])\n\n    result = set()\n    dfs(1, set(), set(), set(), result)\n\n    return len(result)\n"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N = int(stdin)\n    V = list(map(int, stdin.split()[1:N+1]))\n    D = [list(map(int, stdin.split()[N+1:])) for _ in range(N-1)]\n\n    # Helper function to find the supervisors of a person\n    def supervisors(person: int) -> set:\n        s = set()\n        for u, v in D:\n            if person == u:\n                s.add(v)\n        return s\n\n    # Helper function to find all the jokes that person X knows and all their supervisors\n    def jokes_and_supervisors(person: int) -> set:\n        j = set(V[person-1])\n        s = supervisors(person)\n        for u in s:\n            j |= jokes_and_supervisors(u)\n        return j\n\n    # Helper function to check if the set of jokes is consecutive\n    def is_consecutive(jokes: set) -> bool:\n        return sorted(jokes) == list(range(min(jokes), max(jokes)+1))\n\n    # Count the number of sets of jokes\n    count = 0\n    for i in range(1, N+1):\n        # Check if the person is directly or indirectly supervised by Petar\n        if 1 in supervisors(i):\n            # Check if the set of jokes is consecutive\n            jokes = jokes_and_supervisors(i)\n            if is_consecutive(jokes):\n                count += 1\n\n    return str(count)"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict, deque\n\n    N, *V = map(int, stdin.split())\n    adj_list = defaultdict(list)\n    visited = [False] * (N + 1)\n    jokes_sets = set()\n    jokes_sets.add(tuple(sorted(V)))\n\n    for i in range(len(V)):\n        adj_list[i + 1].append(i + 2)\n        adj_list[i + 2].append(i + 1)\n\n    def dfs(node: int, prev_node: int, jokes_set: set) -> None:\n        visited[node] = True\n        jokes_set.add(V[node - 1])\n\n        for adj in adj_list[node]:\n            if adj != prev_node:\n                if not visited[adj]:\n                    dfs(adj, node, jokes_set.copy())\n\n    dfs(1, 0, set())\n    jokes_sets.add(tuple(sorted(jokes_set)))\n\n    while True:\n        for node in range(2, N + 1):\n            if not visited[node]:\n                dfs(node, 0, set())\n                jokes_sets.add(tuple(sorted(jokes_set)))\n\n        if all(visited):\n            break\n\n    return len(jokes_sets)\n"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    V = [int(x) for x in input_list[1].split()]\n    adj_list = []\n    for i in range(2, len(input_list)):\n        edge = [int(x) for x in input_list[i].split()]\n        adj_list.append(edge)\n\n    def dfs(v, parent, visited, dp):\n        visited[v] = True\n        for neighbor in adj_list[v]:\n            if neighbor != parent:\n                if not visited[neighbor]:\n                    dfs(neighbor, v, visited, dp)\n                    dp[v] = dp[v].union(dp[neighbor])\n\n    # Calculate the set of jokes each person can see\n    jokes = [set() for _ in range(N)]\n    for i in range(N):\n        for j in range(i+1, N):\n            if adj_list[i][1] == j or adj_list[j][1] == i:\n                jokes[i].add(V[i])\n                jokes[j].add(V[j])\n\n    # Calculate the set of jokes that can be seen by Petar (label 1)\n    petar_jokes = set()\n    visited = [False] * N\n    dp = [set() for _ in range(N)]\n    dfs(0, -1, visited, dp)\n    for i in range(N):\n        if visited[i]:\n            petar_jokes = petar_jokes.union(dp[i])\n\n    # Count the number of different sets of jokes that comply to the constraints\n    result = 1\n    for jokes_set in jokes:\n        if len(jokes_set) > 0 and len(jokes_set - petar_jokes) % 2 == 0:\n            result *= len(jokes_set) + 1\n\n    return str(result)"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    V = list(map(int, input_list[1].split()))\n    G = [[] for _ in range(N)]\n    for i in range(2, len(input_list)):\n        u, v = map(int, input_list[i].split())\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n\n    def dfs(u: int, visited: set) -> None:\n        visited.add(u)\n        for v in G[u]:\n            if v not in visited:\n                dfs(v, visited)\n\n    def is_valid(u: int, jokes: set, supervisors: set) -> bool:\n        if not supervisors.isdisjoint(jokes):\n            return False\n        if any(j == u for j in range(u+1, N)):\n            return False\n        if any(jokes.issuperset(range(k+1, u)) for k in range(u)):\n            return False\n        return True\n\n    def dfs_jokes(u: int, visited: set, jokes: set) -> int:\n        visited.add(u)\n        result = 0\n        for v in G[u]:\n            if v not in visited:\n                result += dfs_jokes(v, visited, jokes)\n        if is_valid(u, jokes, supervisors):\n            result += 1\n        return result\n\n    def count_jokes() -> int:\n        visited = set()\n        jokes = set()\n        result = 0\n        for u in range(N):\n            if u not in visited:\n                dfs(u, visited)\n                result += dfs_jokes(u, visited, jokes)\n                jokes.add(u)\n        return result\n\n    supervisors = set(range(1, N))\n    return str(count_jokes())"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    V = list(map(int, input_list[1].split()))\n    adj_list = [list(map(int, input_list[i+2].split())) for i in range(N-1)]\n\n    def dfs(node, visited, jokes_set, jokes):\n        visited[node] = True\n        jokes_set.add(jokes[node-1])\n        for neighbor in adj_list[node-1]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, jokes_set, jokes)\n\n    visited = [False] * (N+1)\n    jokes_sets = []\n    for i in range(1, N+1):\n        if not visited[i]:\n            jokes_set = set()\n            dfs(i, visited, jokes_set, V)\n            jokes_sets.append(jokes_set)\n\n    def check_set(set1, set2):\n        if len(set1) != len(set2):\n            return False\n        for i in range(len(set1)):\n            if set1[i] != set2[i]:\n                return False\n        return True\n\n    count = 0\n    for i in range(len(jokes_sets)):\n        for j in range(i+1, len(jokes_sets)):\n            if not check_set(jokes_sets[i], jokes_sets[j]):\n                count += 1\n    return str(count)\n\ninput_list = [\n    \"4\\n2 1 3 4\\n1 2\\n1 3\\n3 4\",\n    \"4\\n3 4 5 6\\n1 2\\n1 3\\n2 4\",\n    \"5\\n4 5 6 7 8\\n1 2\\n1 3\\n2 4\\n3 5\",\n    \"3\\n1 2 3\\n1 2\",\n]\n\nfor input_str in input_list:\n    print(solution(input_str))"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(i: int, visited: set[int], jokes: set[int]) -> int:\n        if i == 1:\n            return 1\n        if i in visited:\n            return 0\n        visited.add(i)\n        count = 0\n        for j in supervisors[i]:\n            count += dfs(j, visited, jokes)\n            jokes.add(V[j])\n        return count\n\n    N, V, supervisors = map(int, stdin.split())\n    V = list(map(int, input().split()))\n    for _ in range(N-1):\n        supervisors = [list(map(int, input().split()))] + supervisors\n    supervisors = [sorted(supervisor) for supervisor in supervisors]\n    supervisors = [s for s in supervisors if s[0] != 1]\n\n    visited = set()\n    jokes = set()\n    count = 0\n    for i in range(1, N+1):\n        count += dfs(i, visited, jokes)\n        jokes.add(V[i-1])\n    return count\n"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_set_consecutive(nums):\n        return all(nums[i] + 1 == nums[i + 1] for i in range(len(nums) - 1))\n\n    def is_jokes_set_valid(jokes_set, visited, visited_supervisors):\n        for jokes_set_member in jokes_set:\n            if jokes_set_member in visited:\n                return False\n            visited.add(jokes_set_member)\n            if not is_set_consecutive(jokes_set_member):\n                return False\n            if supervisors[jokes_set_member[0]] not in visited_supervisors:\n                visited_supervisors.add(supervisors[jokes_set_member[0]])\n                if not is_jokes_set_valid(jokes_set - {jokes_set_member}, visited, visited_supervisors):\n                    return False\n        return True\n\n    N, V = map(int, stdin.readline().split())\n    V = list(map(int, stdin.readline().split()))\n    supervisors = [1] * (N + 1)\n    for _ in range(N - 1):\n        A, B = map(int, stdin.readline().split())\n        supervisors[B] = A\n\n    jokes_sets = set()\n    for jokes in range(1, V + 1):\n        jokes_sets.add(frozenset({jokes}))\n\n    count = 0\n    while jokes_sets:\n        jokes_set = jokes_sets.pop()\n        if is_jokes_set_valid(jokes_set, set(), set()):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    jokes = list(map(int, input_data[1].split()))\n    adjacency_list = defaultdict(set)\n\n    for edge in input_data[2:]:\n        u, v = map(int, edge.split())\n        adjacency_list[u].add(v)\n        adjacency_list[v].add(u)\n\n    def dfs(node, visited, jokes_set, result):\n        visited.add(node)\n        jokes_set.add(jokes[node - 1])\n\n        for neighbor in adjacency_list[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, jokes_set, result)\n\n        if len(jokes_set) == N:\n            result.add(tuple(sorted(jokes_set)))\n\n    result = set()\n    dfs(1, set(), set(), result)\n\n    return str(len(result))\n"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    Q = int(input_data[0])\n    output_data = []\n    for i in range(1, Q+1):\n        A, B = map(int, input_data[i].split())\n        count = 0\n        for j in range(A, B+1):\n            count += j\n        output_data.append(count)\n    return \"\\n\".join(map(str, output_data))"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    Q = int(input_list[0])\n    del input_list[0]\n\n    for i in range(Q):\n        A, B = map(int, input_list[i].split())\n        num_appearances = 0\n\n        for num in range(A, B + 1):\n            appearance_count = 0\n            current_num = num\n            while True:\n                appearance_count += 1\n                current_num = str(current_num)\n                current_num = current_num[::-1]\n                current_num = int(current_num) + num\n                if current_num < A or current_num > B:\n                    break\n            num_appearances += appearance_count\n\n        print(num_appearances)"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.splitlines()[0])\n    queries = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    for A, B in queries:\n        count = 0\n        for i in range(A, B+1):\n            count += count_occurrences(i)\n        print(count)\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.split('\\n')\n    Q = int(Q)\n\n    def reverse_decimal(n: int) -> int:\n        return int(str(n)[::-1])\n\n    def count_appearances(A: int, B: int) -> int:\n        count = 0\n        for i in range(A, B + 1):\n            count += len(str(i))\n        return count\n\n    for i, query in enumerate(queries, 1):\n        A, B = map(int, query.split())\n        appearances = count_appearances(A, B)\n        print(appearances)"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    queries = []\n    Q = int(stdin.split('\\n')[0])\n    for i in range(1, Q+1):\n        queries.append(list(map(int, stdin.split('\\n')[i].split())))\n    \n    def recursive_relation(row, col, prev_value):\n        if col == 1:\n            return row\n        else:\n            return recursive_relation(row, col-1, prev_value) + rev(prev_value)\n\n    def rev(num):\n        return int(str(num)[::-1])\n\n    for query in queries:\n        A, B = query\n        count = 0\n        for i in range(A, B+1):\n            count += recursive_relation(i, B, None)\n        print(count)\n        \n"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    Q = int(input_data[0])\n    output = []\n    for i in range(1, len(input_data), 2):\n        A, B = map(int, input_data[i].split())\n        count = 0\n        for num in range(A, B+1):\n            count += num * count_appearances(num)\n        output.append(str(count))\n    return '\\n'.join(output)\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    Q, queries = stdin.split('\\n')\n    Q = int(Q)\n    queries = [query.split() for query in queries.split('\\n')][:-1]\n    \n    for i, query in enumerate(queries, start=1):\n        A, B = int(query[0]), int(query[1])\n        total = 0\n        for x in range(A, B+1):\n            total += count_appearances(x)\n        print(total)\n\ndef"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.split('\\n')[0])\n    queries = stdin.split('\\n')[1:]\n    queries = [list(map(int, query.split())) for query in queries]\n\n    def count_appearances(A: int, B: int) -> int:\n        if A == B:\n            return 1\n\n        count = 0\n        for i in range(A, B + 1):\n            if i == 1:\n                count += 1\n            else:\n                count += count_appearances(i - 1, i - 1) + count_appearances(i - 1, i - 1)\n        return count\n\n    for i in range(Q):\n        A, B = queries[i]\n        print(count_appearances(A, B))"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    Q = int(stdin.split(\"\\n\")[0])\n    queries = stdin.split(\"\\n\")[1:]\n\n    def rev_decimal(num: int) -> int:\n        return int(str(num)[::-1])\n\n    def get_value(row: int, col: int) -> int:\n        if col == 1:\n            return row\n        else:\n            return get_value(row, col - 1) + rev_decimal(get_value(row, col - 1))\n\n    for i in range(Q):\n        A, B = map(int, queries[i].split())\n        result = 0\n        for j in range(A, B + 1):\n            result += get_value(j, 1)\n        print(result)"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    Q, *queries = stdin.split(\"\\n\")\n    Q = int(Q)\n    queries = [list(map(int, query.split())) for query in queries]\n\n    # Define recursive function\n    def A(i, j):\n        if j == 1:\n            return i\n        else:\n            return A(i, j - 1) + int(str(A(i, j - 1))[::-1])\n\n    # Solve queries\n    result = []\n    for A, B in queries:\n        count = 0\n        for i in range(A, B + 1):\n            for j in range(1, B - A + 2):\n                count += A(i, j)\n        result.append(count)\n\n    # Write output\n    output = \"\\n\".join(map(str, result))\n    return output"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    points = [tuple(map(float, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    points.append(points[0]) # Close the polygon\n    def area(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) / 2)\n    def polygon_area(points):\n        return sum(area(points[i], points[i-1], points[i+1]) for i in range(len(points)))\n    triangle_areas = []\n    for i in range(n):\n        triangle_areas.append(area(points[i], points[i+1], points[(i+k) % n]))\n    return f\"{sum(triangle_areas) / k:.10f}\"\n\ndef"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    cake_vertices = []\n    for i in range(1, n + 1):\n        x, y = map(float, input_list[i].split())\n        cake_vertices.append((x, y))\n\n    # Function to calculate the area of a polygon given its vertices\n    def polygon_area(vertices):\n        area = 0\n        for i in range(len(vertices)):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % len(vertices)]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    # Calculate the area of the entire cake\n    cake_area = polygon_area(cake_vertices)\n\n    # Calculate the area of the randomly chosen vertices\n    random_vertices = random.sample(cake_vertices, k)\n    random_area = polygon_area(random_vertices)\n\n    # Calculate the expected area of the piece of cake that Alice cuts out\n    expected_area = random_area / cake_area\n\n    return f\"{expected_area:.{6}f}\""
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def area(points):\n        area = 0\n        for i in range(-1, len(points) - 1):\n            area += (points[i][0] * points[i + 1][1] - points[i + 1][0] * points[i][1])\n        return abs(area) / 2\n\n    def convex_polygon_area(points):\n        hull = []\n        for p in points:\n            while len(hull) >= 2 and (p[0] - hull[-1][0]) * (hull[-1][1] - hull[-2][1]) - (p[1] - hull[-1][1]) * (hull[-1][0] - hull[-2][0]) > 0:\n                hull.pop()\n            hull.append(p)\n        return area(hull)\n\n    n, k = map(int, stdin.split()[0:2])\n    points = [tuple(map(float, input().split())) for _ in range(n)]\n\n    vertices = points[:k]\n    convex_polygon_area_k = convex_polygon_area(vertices)\n\n    other_points = points[k:]\n    convex_polygon_area_nk = convex_polygon_area(points) - convex_polygon_area_k\n\n    expected_area = (convex_polygon_area_k + convex_polygon_area_nk) / (n - k)\n\n    return f\"{expected_area:.10f}\""
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def convex_hull(points):\n        points.sort(key=lambda x: (x[0], x[1]))\n        upper = []\n        lower = []\n        for p in points:\n            while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0:\n                upper.pop()\n            upper.append(p)\n        points.reverse()\n        for p in points:\n            while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0:\n                lower.pop()\n            lower.append(p)\n        return upper[:-1] + lower[:-1]\n\n    def polygon_area(points):\n        area = 0\n        for i in range(len(points)):\n            j = (i + 1) % len(points)\n            area += points[i][0] * points[j][1] - points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    def expected_area(n, k, points):\n        points_k = points[:k]\n        hull_k = convex_hull(points_k)\n        hull_k_area = polygon_area(hull_k)\n        complement_area = polygon_area(points) - hull_k_area\n        return hull_k_area + k * complement_area / n\n\n    input_data = stdin.splitlines()\n    n, k = map(int, input_data[0].split())\n    points = [tuple(map(float, input_data[i + 1].split())) for i in range(n)]\n\n    result = expected_area(n, k, points)\n    return f\"{result:.6f}\"\n"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def area(vertices):\n        n = len(vertices)\n        area = 0\n        for i in range(n):\n            j = (i + 1) % n\n            area += vertices[i][0] * vertices[j][1] - vertices[j][0] * vertices[i][1]\n        return abs(area) / 2\n\n    def convex_hull(vertices):\n        vertices.sort(key=lambda x: (x[0], x[1]))\n        n = len(vertices)\n        hull = []\n        for i in range(n):\n            while len(hull) >= 2 and cross_product(hull[-2], hull[-1], vertices[i]) <= 0:\n                hull.pop()\n            hull.append(vertices[i])\n        return hull\n\n    def cut_area(vertices):\n        n = len(vertices)\n        k = n\n        hull = convex_hull(vertices)\n        while k > 3:\n            k -= 1\n            vertices = hull[:k]\n            hull = convex_hull(vertices)\n        return area(hull)\n\n    def main():\n        n, k = map(int, input().split())\n        vertices = [list(map(float, input().split())) for _ in range(n)]\n        area_sum = cut_area(vertices)\n        return area_sum / k\n\n    return str(round(main(), 6))"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(u, v):\n        return u[0] * v[1] - u[1] * v[0]\n\n    def dot_product(u, v):\n        return u[0] * v[0] + u[1] * v[1]\n\n    def area(vertices):\n        s = 0\n        for i in range(len(vertices)):\n            j = (i + 1) % len(vertices)\n            s += vertices[i][0] * vertices[j][1] - vertices[j][0] * vertices[i][1]\n        return abs(s) / 2\n\n    def convex_hull(vertices):\n        vertices = sorted(vertices, key=lambda x: (x[1], x[0]))\n        convex_set = [vertices[0], vertices[1]]\n        for i in range(2, len(vertices)):\n            l = len(convex_set)\n            for j in range(l - 1):\n                if cross_product(convex_set[j + 1] - convex_set[j], vertices[i] - convex_set[j]) <= 0:\n                    break\n            else:\n                convex_set.append(vertices[i])\n        return convex_set\n\n    n, k = map(int, input().split())\n    vertices = [tuple(map(float, input().split())) for _ in range(n)]\n    convex_set = convex_hull(vertices)\n    convex_polygon = Polygon(convex_set)\n    cut_area = 0\n    for i in range(k):\n        vertices = list(convex_polygon.exterior.coords)\n        convex_set = convex_hull(vertices)\n        cut_polygon = Polygon(convex_set)\n        cut_area += cut_polygon.area\n    cut_area /= k\n    return f\"{cut_area:.6f}\"\n"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def convex_hull(points):\n        if len(points) == 1:\n            return [points[0]]\n\n        def cross_sweep(left, right):\n            p1, p2, p3 = left, points[0], right\n            if cross_product(p1, p2, p3) > 0:\n                return p2, p3\n            elif cross_product(p1, p2, p3) < 0:\n                return p1, p2\n            else:\n                return min(p1, p2, p3, key=lambda p: (p[1], -p[0]))\n\n        points.sort()\n        return convex_hull(points[1:-1]) + [convex_hull([points[0], points[-1]])[0]]\n\n    def polygon_area(points):\n        area = 0\n        for i in range(len(points)):\n            x1, y1 = points[i]\n            x2, y2 = points[(i + 1) % len(points)]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    n, k = map(int, input().split())\n    points = [tuple(map(float, input().split())) for _ in range(n)]\n\n    hull = convex_hull(points)\n    hull_area = polygon_area(hull)\n\n    expected_area = hull_area * k / len(hull)\n    return f\"{expected_area:.6f}\""
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data.pop(0).split())\n    cake = [(float(x), float(y)) for x, y in [line.split() for line in input_data[:n]]]\n\n    def area(vertices):\n        return 0.5 * abs(sum(x0 * (y1 - y2) + x1 * (y2 - y0) + x2 * (y0 - y1) for ((x0, y0), (x1, y1), (x2, y2)) in zip(vertices, vertices[1:] + [vertices[0]], vertices[1:] + [vertices[0]][1:])))\n\n    def convex_hull(vertices):\n        vertices.sort()\n        return [vertices[0]] + [v for i in range(2, len(vertices)) for v in [vertices[i - 1], vertices[i], vertices[i - 2]] if area([vertices[i - 1], v, vertices[i - 2]]) > area([vertices[i - 2], vertices[i - 1], vertices[i]])]\n\n    hull = convex_hull(cake)\n    hull_area = area(hull)\n    sub_area = sum(area([v, hull[i - 1], hull[i % len(hull)]]) for i in range(k) for v in cake)\n\n    return '{:.6f}'.format(sub_area / hull_area)"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def convex_hull(points):\n        def cross(o, a, b):\n            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n        def turn(o, a, b):\n            return int(cross(o, a, b) > 0)\n\n        def incircle(p1, p2, p3, p4):\n            return int(cross(p1, p2, p3) * cross(p1, p3, p4) < 0)\n\n        def _convex_hull(points, hull):\n            l = len(points)\n            p = points[0]\n            for q in points[1:]:\n                t = hull[-2]\n                while turn(p, t, q) == 2:\n                    t = hull.pop()\n                hull.append(p)\n                hull.append(q)\n                p = q\n            hull.append(hull[0])\n            hull.append(hull[1])\n            return hull\n\n        points = sorted(set(points))\n        hull = [points[0], points[1]]\n        for p in points[2:]:\n            while len(hull) > 1 and cross(hull[-2], hull[-1], p) <= 0:\n                hull.pop()\n            hull.append(p)\n        hull.pop()\n        hull.pop()\n\n        if len(hull) < 3:\n            return []\n\n        if len(hull) == 3:\n            return [hull]\n\n        hull = _convex_hull(points, hull)\n        hull = _convex_hull(points, hull[::-1])\n        hull.pop()\n        hull.pop()\n\n        if incircle(points[0], points[1], points[2], hull[0]) == 1:\n            hull.pop()\n\n        return hull\n\n    def polygon_area(vertices):\n        n = len(vertices)\n        area = 0.0\n        for i in range(n):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % n]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2.0\n\n    n, k = map(int, input().split())\n    points = [tuple(map(float, input().split())) for _ in range(n)]\n\n    hull = convex_hull(points)\n    hull_points = [points[i] for i in [hull[0].index(x) for x in hull[k - 1]]]\n\n    return polygon_area(hull_points)\n"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def convex_hull(points):\n        points = sorted(points)\n        upper_hull = []\n        for point in points:\n            while len(upper_hull) >= 2 and cross_product(upper_hull[-2], upper_hull[-1], point) <= 0:\n                upper_hull.pop()\n            upper_hull.append(point)\n        lower_hull = []\n        for point in reversed(points):\n            while len(lower_hull) >= 2 and cross_product(lower_hull[-2], lower_hull[-1], point) >= 0:\n                lower_hull.pop()\n            lower_hull.append(point)\n        return upper_hull[:-1] + lower_hull\n\n    def calculate_area(vertices):\n        n = len(vertices)\n        area = 0\n        for i in range(n):\n            x = vertices[i][0]\n            y = vertices[i][1]\n            x_next = vertices[(i + 1) % n][0]\n            y_next = vertices[(i + 1) % n][1]\n            area += (x * y_next) - (x_next * y)\n        return abs(area) / 2\n\n    def expected_area(vertices, k):\n        hull = convex_hull(vertices)\n        total_area = calculate_area(vertices)\n        hull_area = calculate_area(hull)\n        return (total_area - hull_area) / k\n\n    def main(stdin: str):\n        n, k = map(int, stdin.split()[0:2])\n        vertices = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n        return round(expected_area(vertices, k), 6)\n\n    return str(main(stdin))"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, visited: set, graph: list, depth: int) -> int:\n        if depth >= max_depth:\n            return 0\n        if v in visited:\n            return 0\n        visited.add(v)\n        private_count = 0\n        public_count = 0\n        for neighbor in graph[v]:\n            private_count += dfs(neighbor, visited.copy(), graph, depth + 1)\n            public_count += dfs(neighbor, visited.copy(), graph, depth + 1)\n        return max(private_count, public_count) + 1\n\n    n, m, c = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n)]\n    enemies = set()\n    for _ in range(c):\n        u, v = map(int, stdin.split()[1:3])\n        graph[u].append(v)\n        graph[v].append(u)\n    for _ in range(m):\n        enemy = int(stdin.split()[1])\n        enemies.add(enemy)\n    max_depth = 2 * n  # Assuming the worst case where every spy is connected to every other spy\n    enemy_count = sum(dfs(i, set(), graph, 0) for i in range(n) if i not in enemies)\n    return n - enemy_count\n"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_connected_spies(connections, start_spy):\n        visited = set()\n        queue = [start_spy]\n        while queue:\n            spy = queue.pop(0)\n            if spy not in visited:\n                visited.add(spy)\n                queue.extend(connections[spy])\n        return visited\n\n    def send_message_to_spies(spies, enemies):\n        private_messages = 0\n        public_messages = 0\n        for spy in range(S):\n            if spy not in enemies:\n                connected_spies = find_connected_spies(connections, spy)\n                if not any(enemy in connected_spies for enemy in enemies):\n                    private_messages += 1\n                else:\n                    public_messages += 1\n        return private_messages, public_messages\n\n    S, E, C = map(int, stdin.split()[:3])\n    connections = [set() for _ in range(S)]\n    for _ in range(C):\n        spy1, spy2 = map(int, stdin.split()[3:5])\n        connections[spy1].add(spy2)\n        connections[spy2].add(spy1)\n    enemies = set(map(int, stdin.split()[-E:]))\n\n    private_messages, public_messages = send_message_to_spies(S, enemies)\n\n    return str(private_messages + public_messages)\n"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    S, E, C = map(int, input_list[0].split())\n    connections = [tuple(map(int, line.split())) for line in input_list[1:C+1]]\n    enemy_spies = list(map(int, input_list[C+1].split()))\n\n    # Build the adjacency list for the spy network\n    adj_list = [[] for _ in range(S)]\n    for conn in connections:\n        adj_list[conn[0]].append(conn[1])\n        adj_list[conn[1]].append(conn[0])\n\n    # Compute the minimum number of messages needed\n    queue = [i for i in range(S) if i not in enemy_spies]\n    visited = [False] * S\n    count = 0\n\n    while queue:\n        curr_size = len(queue)\n        for i in range(curr_size):\n            node = queue.pop(0)\n            visited[node] = True\n            for neighbor in adj_list[node]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n        count += 1\n\n    return str(count)"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n\n    S, E, C = map(int, input_lines[0].split())\n    connections = [tuple(map(int, line.split())) for line in input_lines[1:C+1]]\n    enemies = set(map(int, input_lines[C+1].split()))\n\n    private_messages = 1\n    spies_to_message = set()\n\n    def dfs(spy):\n        if spy not in spies_to_message and spy not in enemies:\n            spies_to_message.add(spy)\n            for _, other in connections:\n                if other == spy:\n                    dfs(spy - 1)\n                    dfs(spy + 1)\n\n    dfs(0)\n    private_messages += len(spies_to_message) - 1\n\n    public_messages = 1\n    for spy in spies_to_message:\n        for _, other in connections:\n            if other in spies_to_message:\n                public_messages += 1\n                break\n\n    return str(min(private_messages, public_messages))\n"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(s, visited, visited_enemies, connections):\n        if visited[s]:\n            return 0\n        visited[s] = True\n        if s in visited_enemies:\n            return 0\n\n        count = 1\n        for neighbor in connections[s]:\n            count += dfs(neighbor, visited, visited_enemies, connections)\n\n        return count\n\n    S, E, C = map(int, stdin.split()[:3])\n    connections = [list(map(int, line.split())) for line in stdin.split('\\n')[3:-1]]\n    visited_enemies = set(map(int, stdin.split('\\n')[-1].split()))\n\n    visited = [False] * (S + 1)\n    min_messages = min(dfs(s, visited, visited_enemies, connections) for s in range(1, S + 1) if s not in visited_enemies)\n\n    return str(min_messages)\n"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, visited):\n        queue = [(start, 0)]\n        while queue:\n            current, depth = queue.pop(0)\n            if current not in visited:\n                visited.add(current)\n                if depth < depths[current]:\n                    depths[current] = depth\n                for neighbor in graph[current]:\n                    queue.append((neighbor, depth + 1))\n\n    total_spies, total_enemies, total_connections = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(total_spies + 1)]  # Add 1 for the BAPC itself\n    for _ in range(total_connections):\n        spy1, spy2 = map(int, stdin.split()[3:5])\n        graph[spy1].append(spy2)\n        graph[spy2].append(spy1)\n    for enemy in map(int, stdin.split()[5:]):\n        graph[enemy] = None\n\n    depths = [float('inf')] * total_spies\n    visited = set()\n    bfs(graph, 1, visited)  # Start from the BAPC itself\n\n    enemy_spies = set(filter(lambda x: graph[x] is None, visited))\n    print(len(visited - enemy_spies))\n\n    return str(len(visited - enemy_spies))"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    S, E, C = map(int, stdin.split()[:3])\n    enemies = set(map(int, stdin.split()[-E:]))\n    graph = [[] for _ in range(S)]\n    for _ in range(C):\n        u, v = map(int, stdin.split()[3 + _ * 2: 3 + (_ + 1) * 2])\n        graph[u].append(v)\n    visited = [False] * S\n    queue = [0]\n    count = 0\n    while queue:\n        node = queue.pop(0)\n        if visited[node]:\n            continue\n        visited[node] = True\n        count += 1\n        for neighbor in graph[node]:\n            if neighbor not in enemies:\n                queue.append(neighbor)\n    return count\n\ninput_data = \"\"\"4 1 3\n0 1\n1 2\n2 3\n1\n\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    S, E, C = map(int, input_list[0].split())\n    connections = [[int(x) for x in line.split()] for line in input_list[1:C+1]]\n    enemies = [int(x) for x in input_list[C+1].split()]\n\n    # Build the adjacency list for the spy network\n    adj_list = [[] for _ in range(S)]\n    for conn in connections:\n        adj_list[conn[0]].append(conn[1])\n        adj_list[conn[1]].append(conn[0])\n\n    # DFS to count the number of private messages needed\n    def dfs(spy_id, visited, private_messages):\n        visited.add(spy_id)\n        for neighbor in adj_list[spy_id]:\n            if neighbor not in visited:\n                private_messages += dfs(neighbor, visited, private_messages)\n        return private_messages + 1\n\n    # Count the private messages needed\n    private_messages = 0\n    visited = set()\n    for spy_id in range(S):\n        if spy_id not in visited and spy_id not in enemies:\n            private_messages += dfs(spy_id, visited, private_messages)\n\n    # Count the public messages needed\n    public_messages = 0\n    for spy_id in range(S):\n        if spy_id not in enemies:\n            public_messages += 1\n\n    return str(max(private_messages, public_messages))\n\n\ndef"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    S, E, C = map(int, input_data[0].split())\n    connections = [tuple(map(int, line.split())) for line in input_data[1:C+1]]\n    enemy_spies = set(map(int, input_data[C+1].split()))\n\n    adjacency_list = [[] for _ in range(S)]\n    for connection in connections:\n        adjacency_list[connection[0]].append(connection[1])\n        adjacency_list[connection[1]].append(connection[0])\n\n    def dfs(node: int, visited: set) -> None:\n        visited.add(node)\n        for neighbor in adjacency_list[node]:\n            if neighbor not in visited:\n                dfs(neighbor, visited)\n\n    visited = set()\n    for enemy_spy in enemy_spies:\n        dfs(enemy_spy, visited)\n\n    private_messages = S - len(visited)\n    public_messages = len(visited)\n    return private_messages + public_messages\n"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.splitlines()\n    S, E, C = map(int, input_values[0].split())\n    connections = [tuple(map(int, line.split())) for line in input_values[1:C+1]]\n    enemy_spies = set(map(int, input_values[C+1].split()))\n    \n    # Determine the number of spies that need to be messaged\n    total_spies = set(range(S))\n    enemy_spies.update(range(S))  # Include yourself in the enemy spies\n    remaining_spies = total_spies - enemy_spies\n    messages_required = 0\n    \n    # Determine the minimum number of messages required\n    while remaining_spies:\n        new_remaining_spies = set()\n        for spy1, spy2 in connections:\n            if spy1 in remaining_spies and spy2 not in enemy_spies:\n                new_remaining_spies.add(spy2)\n            elif spy2 in remaining_spies and spy1 not in enemy_spies:\n                new_remaining_spies.add(spy1)\n        remaining_spies = new_remaining_spies\n        messages_required += 1\n        \n    return str(messages_required)"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 1000000007\n    APPLES = pow(2, A, MOD)\n    CHERRIES = pow(2, C, MOD)\n    MANGOES = pow(2, M, MOD)\n    return (APPLES * CHERRIES * MANGOES) % MOD"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    modulo = 10**9 + 7\n    AP = CM = MP = 1\n    for i in range(1, A+1):\n        AP = (AP * (A - i + 1)) % modulo\n    for i in range(1, C+1):\n        CM = (CM * (C - i + 1)) % modulo\n    for i in range(1, M+1):\n        MP = (MP * (M - i + 1)) % modulo\n    answer = (AP * CM * MP) % modulo\n    return str(answer)\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [0] * (A + C + M + 2)\n    dp[0] = 1\n    for i in range(1, A + C + M + 2):\n        if i <= A:\n            dp[i] = dp[i - 1] * 2 % mod\n        if i <= C:\n            dp[i] = (dp[i] + dp[i - 1]) % mod\n        if i <= M:\n            dp[i] = (dp[i] + dp[i - 1]) % mod\n    return dp[A + C + M]\n"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    mod = 10**9 + 7\n\n    if A == 0 and C == 0 and M == 0:\n        return 1\n\n    if A == 1:\n        return 1\n\n    if C == 1 and A == 2:\n        return 2\n\n    if M == 1 and A == 2:\n        return 2\n\n    if M == 1 and C == 2:\n        return 2\n\n    dp = [[[0 for _ in range(M + 1)] for _ in range(C + 1)] for _ in range(A + 1)]\n\n    for i in range(A + 1):\n        for j in range(C + 1):\n            for k in range(M + 1):\n                if i == 0 and j == 0 and k == 0:\n                    dp[i][j][k] = 1\n                elif i > 0 and j == 0 and k == 0:\n                    dp[i][j][k] = dp[i - 1][j][k]\n                elif i == 0 and j > 0 and k == 0:\n                    dp[i][j][k] = dp[i][j - 1][k]\n                elif i == 0 and j == 0 and k > 0:\n                    dp[i][j][k] = dp[i][j][k - 1]\n                elif i > 0 and j > 0 and k == 0:\n                    dp[i][j][k] = (dp[i - 1][j][k] + dp[i][j - 1][k]) % mod\n                elif i > 0 and j == 0 and k > 0:\n                    dp[i][j][k] = (dp[i - 1][j][k] + dp[i][j][k - 1]) % mod\n                elif j > 0 and i == 0 and k > 0:\n                    dp[i][j][k] = (dp[i][j - 1][k] + dp[i][j][k - 1]) % mod\n                elif i > 0 and j > 0 and k > 0:\n                    dp[i][j][k] = (dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1] - dp[i - 1][j - 1][k] - dp[i - 1][j][k - 1] - dp[i][j - 1][k - 1] + dp[i - 1][j - 1][k - 1]) % mod\n\n    return dp[A][C][M]"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    # Calculate the number of possible arrangements\n    apples = A\n    cherries = C\n    mangos = M\n    total_boxes = A + C + M\n\n    # Initialize the dp array\n    dp = [[0] * (total_boxes + 1) for _ in range(3)]\n\n    # Fill the dp array for apples\n    for i in range(1, total_boxes + 1):\n        if i > cherries:\n            dp[0][i] = dp[0][i - 1]\n        else:\n            dp[0][i] = (dp[0][i - 1] + dp[0][i - cherries - 1]) % MOD\n\n    # Fill the dp array for cherries\n    for i in range(1, total_boxes + 1):\n        if i > apples:\n            dp[1][i] = dp[1][i - 1]\n        else:\n            dp[1][i] = (dp[1][i - 1] + dp[1][i - apples - 1]) % MOD\n\n    # Fill the dp array for mangos\n    for i in range(1, total_boxes + 1):\n        if i > cherries:\n            dp[2][i] = dp[2][i - 1]\n        else:\n            dp[2][i] = (dp[2][i - 1] + dp[2][i - cherries - 1]) % MOD\n\n    # Calculate the final answer\n    answer = dp[0][A] * dp[1][C] * dp[2][M]\n    return str(answer % MOD)"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def factorial(n: int) -> int:\n        result = 1\n        for i in range(1, n + 1):\n            result = (result * i) % MOD\n        return result\n\n    def choose(n: int, k: int) -> int:\n        if k > n:\n            return 0\n        return (factorial(n) * pow(factorial(k), MOD - 2, MOD)) % MOD\n\n    result = choose(A + C + M, A)\n    return str(result)\n"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    p = 10**9 + 7\n    def count_arrangements(A, C, M):\n        def count_ways(types, A, C, M):\n            if A == 0 and C == 0 and M == 0:\n                return 1\n            if A < 0 or C < 0 or M < 0:\n                return 0\n            if A >= types and C >= types and M >= types:\n                return count_ways(types - 1, A - 1, C - 1, M - 1) + count_ways(types, A - 1, C, M - 1) + count_ways(types, A, C - 1, M - 1) + count_ways(types, A, M, C - 1) + count_ways(types, A, C, M)\n            else:\n                return 0\n        return count_ways(3, A, C, M)\n    \n    return str(count_arrangements(A, C, M) % p)"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_ways(total, types):\n        if total == 1:\n            return 1\n        if total < 1:\n            return 0\n        if types < 1:\n            return 0\n\n        ways = 0\n        for i in range(types):\n            ways += count_ways(total - 1, types - 1)\n            ways %= MOD\n        return ways\n\n    total_ways = count_ways(A + C + M, 3)\n    return total_ways\n\ndef"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    \n    # Helper function to count the number of possible arrangements\n    def count_arrangements(N, M, prev):\n        if M == 0:\n            return 1\n        count = 0\n        for i in range(1, N+1):\n            if i != prev:\n                count += count_arrangements(N-i, M-1, i)\n                count %= MOD\n        return count\n    \n    # Compute the number of possible arrangements\n    result = count_arrangements(A, C, -1) * count_arrangements(C, M, -1) % MOD\n    \n    return str(result)"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 1000000007\n    \n    def count_ways(total_boxes, boxes_of_same_fruit):\n        if total_boxes == 0:\n            return 1\n        elif total_boxes < boxes_of_same_fruit:\n            return 0\n        else:\n            ways = 0\n            for i in range(boxes_of_same_fruit + 1):\n                ways += count_ways(total_boxes - i, boxes_of_same_fruit)\n            return ways % MOD\n    \n    apples_ways = count_ways(A, 1)\n    cherries_ways = count_ways(C, 1)\n    mangos_ways = count_ways(M, 1)\n    \n    total_ways = apples_ways * cherries_ways * mangos_ways\n    return str(total_ways % MOD)"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    target = numbers[0]\n    \n    for i in range(1, n):\n        if numbers[i] <= target:\n            return \"impossible\"\n        target = numbers[i]\n    \n    # Check if changing any digit will make the list not sorted\n    for i in range(n):\n        for j in range(len(str(numbers[i]))):\n            changed_num = numbers[i]\n            if changed_num // (10 ** (j + 1)) % 10 != changed_num // (10 ** j) % 10:\n                changed_num = changed_num // (10 ** j) * 10 + (changed_num // (10 ** (j + 1)) % 10)\n                if changed_num not in numbers:\n                    return \"impossible\"\n                \n    # Change a digit to make the list not sorted\n    for i in range(n):\n        for j in range(len(str(numbers[i]))):\n            changed_num = numbers[i]\n            if changed_num // (10 ** (j + 1)) % 10 != changed_num // (10 ** j) % 10:\n                changed_num = changed_num // (10 ** j) * 10 + (changed_num // (10 ** (j + 1)) % 10)\n                if changed_num not in numbers:\n                    new_numbers = numbers.copy()\n                    new_numbers[i] = changed_num\n                    return new_numbers\n\n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    \n    if len(set(numbers)) == 1:\n        return \"impossible\"\n    \n    for i in range(n):\n        for j in range(9):\n            new_number = numbers[i] * 10 + (j + 1)\n            if new_number > 99999999999999999:\n                continue\n            if sorted(numbers) == sorted(numbers[:i] + [new_number] + numbers[i+1:]):\n                return \" \".join(map(str, numbers[:i] + [new_number] + numbers[i+1:]))\n    \n    return \"impossible\""
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    answer = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    # check if the list is already sorted\n    if all(answer[i] <= answer[i+1] for i in range(n-1)):\n        return \"impossible\"\n\n    # find the index of the smallest unsorted element\n    index = 0\n    for i in range(1, n):\n        if answer[i] < answer[index]:\n            index = i\n\n    # find the digit to change\n    digit_to_change = -1\n    for i in range(n-1):\n        if answer[i] > answer[i+1]:\n            digit_to_change = i\n            break\n\n    if digit_to_change == -1:\n        return \"impossible\"\n\n    # find the digit to change in the smallest unsorted element\n    for i in range(9, -1, -1):\n        if (answer[index] % 10 == i) and (answer[index] // 10 != 0):\n            digit_to_change_value = i\n            break\n\n    if digit_to_change_value == -1:\n        return \"impossible\"\n\n    # create the new list\n    new_list = []\n    for i in range(n):\n        if i == index:\n            new_list.append(answer[i] + digit_to_change_value)\n        else:\n            new_list.append(answer[i])\n\n    return new_list"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    answer = sorted(map(int, stdin.split('\\n')[1].split()))\n    target = list(map(int, stdin.split('\\n')[2].split()))\n\n    def is_valid_change(num: int) -> bool:\n        for digit in str(num):\n            if digit == '0':\n                return True\n        return False\n\n    for i in range(n):\n        if target[i] != answer[i]:\n            if is_valid_change(target[i] + 1):\n                target[i] += 1\n                break\n            elif is_valid_change(target[i] - 1):\n                target[i] -= 1\n                break\n    else:\n        return \"impossible\"\n\n    return \" \".join(map(str, target))\n\ninput_data = \"\"\"2\n1 9999999\n\"\"\"\n\nprint(solution(input_data))"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = sorted(map(int, stdin.split('\\n')[1].split()))\n    max_digit = max(map(len, map(str, numbers)))\n\n    for i in range(n):\n        for j in range(len(numbers[i])):\n            if numbers[i][j] != '9':\n                numbers[i] = numbers[i][:j] + str(numbers[i][j] + 1) + numbers[i][j + 1:]\n                if sorted(numbers) != numbers:\n                    return '\\n'.join(map(str, numbers))\n                numbers[i] = numbers[i][:j] + str(numbers[i][j] - 1) + numbers[i][j + 1:]\n\n    return 'impossible'\n\ninput_string = '''3\n2020 2020 2020\n1 9999999'''\n\nprint(solution(input_string)) "
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def is_sorted(numbers):\n        for i in range(1, n):\n            if numbers[i] < numbers[i - 1]:\n                return False\n        return True\n\n    def change_digit(number, index, digit):\n        binary_num = bin(number)[2:]\n        binary_digit = bin(digit)[2:]\n        binary_num = list(binary_num)\n        binary_digit = list(binary_digit)\n\n        if len(binary_digit) > len(binary_num):\n            binary_num.extend([0] * (len(binary_digit) - len(binary_num)))\n\n        binary_num[index] = binary_digit[index]\n\n        new_number = 0\n        for i, digit in enumerate(binary_num):\n            new_number += 2 ** (len(binary_num) - 1 - i) * int(digit)\n\n        return new_number\n\n    def check_valid_solution(numbers):\n        for i in range(n - 1):\n            if numbers[i] > numbers[i + 1]:\n                return True\n        return False\n\n    if is_sorted(numbers):\n        return \"impossible\"\n\n    for i in range(n):\n        for j in range(10):\n            if check_valid_solution(numbers):\n                numbers[i] = change_digit(numbers[i], 0, j)\n                if is_sorted(numbers):\n                    result = \" \".join(map(str, numbers))\n                    return result\n\n    return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n    if n == 1:\n        return \"impossible\"\n    for i in range(n - 1):\n        if numbers[i] >= numbers[i + 1]:\n            continue\n        for j in range(i + 1, n):\n            if numbers[i] < numbers[j]:\n                max_num = numbers[j]\n                min_num = numbers[i]\n                break\n        if numbers[i] > numbers[j]:\n            max_num = numbers[i]\n            min_num = numbers[j]\n        num_to_change = numbers.index(max_num)\n        max_num_str = str(max_num)\n        min_num_str = str(min_num)\n        for k in range(len(max_num_str)):\n            if max_num_str[k] != min_num_str[k]:\n                new_num = int(max_num_str[:k] + min_num_str[k] + max_num_str[k + 1:])\n                if new_num != max_num:\n                    numbers[num_to_change] = new_num\n                    return \" \".join(map(str, numbers))\n    return \"impossible\"\n"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *z = map(int, stdin.split())\n    a = sorted(z)\n    b = a.copy()\n    \n    for i in range(n):\n        if a[i] != b[i]:\n            if a[i] == 0:\n                b[i] = 0\n            else:\n                b[i] -= 1\n            break\n    \n    if a == sorted(b):\n        return \"impossible\"\n    else:\n        return \" \".join(map(str, b))"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    numbers = list(map(int, input_list[1].split()))\n\n    def is_sorted(numbers: list) -> bool:\n        for i in range(n - 1):\n            if numbers[i] > numbers[i + 1]:\n                return False\n        return True\n\n    def change_digit(number: int, index: int, new_digit: int) -> int:\n        number = list(str(number))\n        number[index] = str(new_digit)\n        return int(''.join(number))\n\n    def is_valid(new_numbers: list) -> bool:\n        for i in range(n - 1):\n            if new_numbers[i] > new_numbers[i + 1]:\n                return False\n        return True\n\n    for i in range(n):\n        for j in range(len(str(numbers[i]))):\n            for k in range(10):\n                new_numbers = [numbers[m] if m != i else change_digit(numbers[i], j, k) for m in range(n)]\n                if not is_sorted(new_numbers) and is_valid(new_numbers):\n                    return ' '.join(map(str, new_numbers))\n\n    return \"impossible\" "
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    answer = list(map(int, input().split()))\n    sorted_answer = sorted(answer)\n\n    if answer == sorted_answer:\n        return \"impossible\"\n\n    for i in range(n):\n        for j in range(9):\n            new_answer = answer.copy()\n            new_answer[i] += (j + 1) * 10**(6 - j)\n            new_answer.sort()\n\n            if new_answer == sorted_answer:\n                return \" \".join(map(str, new_answer))\n\n    return \"impossible\""
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, input().split())\n    count = 0\n    for house_number in range(L, R + 1):\n        digits = [int(digit) for digit in str(house_number)]\n        four_count = sum(1 for digit in digits if digit == 4)\n        six_or_eight_count = sum(1 for digit in digits if digit in [6, 8])\n        if four_count == 0 and six_or_eight_count == digits.count(6) + digits.count(8):\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n\n    def is_valid_number(num: int) -> bool:\n        count_six_eight = 0\n        count_four = 0\n        for digit in str(num):\n            if digit == '4':\n                count_four += 1\n            elif digit in ('6', '8'):\n                count_six_eight += 1\n        return count_six_eight == count_four\n\n    count = 0\n    for num in range(L, R+1):\n        if is_valid_number(num):\n            count += 1\n\n    return str(count % (10**9+7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n\n    for num in range(L, R + 1):\n        digits = str(num)\n        four_count = digits.count('4')\n        six_eight_count = sum(1 for digit in digits if digit in ['6', '8'])\n\n        if four_count == 0 and six_eight_count == len(digits) // 2:\n            count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    \n    def has_four(number: int) -> bool:\n        while number > 0:\n            if number % 10 == 4:\n                return True\n            number //= 10\n        return False\n    \n    def has_eight(number: int) -> bool:\n        count = 0\n        while number > 0:\n            digit = number % 10\n            if digit == 6 or digit == 8:\n                count += 1\n            number //= 10\n        return count\n    \n    def is_valid(number: int) -> bool:\n        return not has_four(number) and has_eight(number) == has_six(number)\n    \n    def has_six(number: int) -> bool:\n        count = 0\n        while number > 0:\n            digit = number % 10\n            if digit == 6 or digit == 8:\n                count += 1\n            number //= 10\n        return count\n    \n    count = 0\n    for number in range(L, R + 1):\n        if is_valid(number):\n            count += 1\n    \n    result = count % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    input_list = input_str.split()\n    L = int(input_list[0])\n    R = int(input_list[1])\n\n    count = 0\n    for num in range(L, R+1):\n        digits = [int(digit) for digit in str(num)]\n        digit_count = Counter(digits)\n        if 4 not in digit_count and digit_count[6] == digit_count[8] and (len(digit_count) == 2 or (len(digit_count) == 3 and 4 not in digit_count)):\n            count += 1\n\n    result = count % (10**9 + 7)\n    return str(result)"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    num_sixes = 0\n    num_eights = 0\n    houses_to_buy = 0\n\n    for house_number in range(L, R + 1):\n        has_four = False\n        for digit in str(house_number):\n            if digit == '4':\n                has_four = True\n                break\n\n        if not has_four:\n            num_sixes += str(house_number).count('6')\n            num_eights += str(house_number).count('8')\n\n            if num_sixes == num_eights:\n                houses_to_buy += 1\n\n    return str(houses_to_buy % (10**9 + 7))\n\ninput_str = \"30 70\\n66 69\"\noutput_str = [solution(s) for s in input_str.split('\\n')]\nprint('\\n'.join(output_str)) "
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    \n    for num in range(L, R+1):\n        num_six_eights = 0\n        num_fours = 0\n        for digit in str(num):\n            if digit == '4':\n                num_fours += 1\n            elif digit == '6':\n                num_six_eights += 1\n            elif digit == '8':\n                num_six_eights += 1\n        if num_fours == 0 and num_six_eights == int(len(str(num))/2):\n            count += 1\n    \n    return str(count % (10**9 + 7))\n\ndef"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split()\n    L, R = map(int, input_str)\n    count = 0\n\n    for house_number in range(L, R + 1):\n        digits = [int(digit) for digit in str(house_number)]\n        if any(digit == 4 for digit in digits):\n            continue\n\n        count_six_eight = sum(1 for digit in digits if digit in [6, 8])\n        count_not_six_eight = len(digits) - count_six_eight\n\n        if count_six_eight == count_not_six_eight:\n            count += 1\n\n    return str(count % (10 ** 9 + 7))\n"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for i in range(L, R+1):\n        # check for digit 4\n        if '4' in str(i):\n            continue\n        # count digits\n        six_eight_count = 0\n        other_count = 0\n        for digit in str(i):\n            if digit == '6' or digit == '8':\n                six_eight_count += 1\n            else:\n                other_count += 1\n        if six_eight_count == other_count:\n            count += 1\n    # compute remainder\n    MOD = 10**9+7\n    return str(count % MOD)"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n\n    for num in range(L, R+1):\n        digit_counts = [0] * 10\n        for digit in str(num):\n            digit_counts[int(digit)] += 1\n\n        has_four = any(count == 1 for count in digit_counts)\n        six_or_eight_count = digit_counts[6] + digit_counts[8]\n        eight_count = digit_counts[8]\n\n        if not has_four and six_or_eight_count == eight_count:\n            count += 1\n\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init, *map_lines = stdin.strip().split('\\n')\n    Y, X, x_init = int(Y), int(X), int(x_init)\n\n    # Parse the map\n    map_ = []\n    for y, line in enumerate(map_lines):\n        row = []\n        for x, c in enumerate(line):\n            if c in {'@', '#'}:\n                row.append(c)\n            elif c in {'>', '<'}:\n                row.append(c)\n            else:\n                row.append(None)\n        map_.append(row)\n\n    # Initialize variables\n    directions = []\n    visited = set()\n    curr_pos = (0, x_init)\n    curr_dir = (1, 0)  # North\n\n    # BFS to find all paths\n    queue = [(curr_pos, curr_dir)]\n    while queue:\n        pos, dir = queue.pop(0)\n        visited.add(pos)\n        if pos == (Y - 1, x_init) and '@' in map_[pos[0]][pos[1]]:\n            directions.append(dir)\n            continue\n\n        # Check if we can move in the current direction\n        new_pos = pos[0] + dir[0], pos[1] + dir[1]\n        if 0 <= new_pos[0] < Y and 0 <= new_pos[1] < X:\n            if map_[new_pos[0]][new_pos[1]] != '#':\n                if new_pos not in visited:\n                    queue.append((new_pos, dir))\n\n        # Check if we can move east/west\n        if dir[1] == 0:\n            if map_[pos[0]][pos[1] + 1] not in {'#', None}:\n                new_pos = pos[0], pos[1] + 1\n                if new_pos not in visited:\n                    queue.append((new_pos, (0, 1)))\n            if pos[1] > 0 and map_[pos[0]][pos[1] - 1] not in {'#', None}:\n                new_pos = pos[0], pos[1] - 1\n                if new_pos not in visited:\n                    queue.append((new_pos, (0, -1)))\n\n    # If no paths were found, output \"begin repairs\"\n    if not directions:\n        return \"begin repairs\"\n\n    # Output the number of paths modulo 1000003\n    return str(len(directions) % 1000003)"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init, input_map = read_input(stdin)\n    paths = find_paths(Y, X, x_init, input_map)\n    if not paths:\n        return \"begin repairs\"\n    else:\n        return len(paths) % 1000003\n\n\ndef"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init, map_data = stdin.split(\"\\n\")\n    Y, X, x_init = int(Y), int(X), int(x_init)\n    map_data = [list(line) for line in map_data.split(\"\\n\")]\n\n    def get_neighbors(x, y):\n        neighbors = []\n        if y > 0 and map_data[y - 1][x] != \"#\":\n            neighbors.append((x, y - 1))\n        if y < Y - 1 and map_data[y + 1][x] != \"#\":\n            neighbors.append((x, y + 1))\n        if x > 0 and map_data[y][x - 1] != \"#\":\n            neighbors.append((x - 1, y))\n        if x < X - 1 and map_data[y][x + 1] != \"#\":\n            neighbors.append((x + 1, y))\n        return neighbors\n\n    def dfs(x, y, visited, path, paths):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        path.append((x, y))\n\n        if map_data[y][x] == \"@\":\n            paths.append(path[:])\n        else:\n            for neighbor in get_neighbors(x, y):\n                dfs(neighbor[0], neighbor[1], visited, path, paths)\n\n        path.pop()\n\n    paths = []\n    dfs(x_init, Y - 1, set(), [], paths)\n    if not paths:\n        return \"begin repairs\"\n    else:\n        return str(len(set(tuple(path) for path in paths)))\n"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(x, y, direction):\n        if x == x_init and y == Y-1:\n            return True\n        if x < 0 or x >= X or y < 0 or y >= Y or C[x][y] == '#':\n            return False\n\n        if C[x][y] == '@':\n            return True\n\n        C[x][y] = '.'\n        result = False\n        if direction == 1:\n            result = dfs(x+1, y, 1) or dfs(x+1, y, -1) or dfs(x, y-1, 2)\n        elif direction == 2:\n            result = dfs(x-1, y, 2) or dfs(x, y-1, 2) or dfs(x+1, y, 1)\n        elif direction == 3:\n            result = dfs(x, y-1, 2) or dfs(x-1, y, 2) or dfs(x+1, y, 1)\n\n        C[x][y] = '.' if result else '*'\n        return result\n\n    Y, X, x_init = map(int, stdin.split())\n    C = [list(input().strip()) for _ in range(Y)]\n\n    for i in range(X):\n        for j in range(Y):\n            if C[j][i] == '@':\n                x_init = i\n                y_init = j\n                break\n        else:\n            continue\n        break\n\n    count = 0\n    directions = [1, 2, 3]\n    for direction in directions:\n        for i in range(X):\n            for j in range(Y):\n                C[j][i] = '.'\n        if dfs(x_init, y_init, direction):\n            count += 1\n\n    return str(count % 1000003) if count > 0 else \"begin repairs\""
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_south_wind():\n        for i in range(Y):\n            if '@' in row[i]:\n                return i\n        return -1\n\n    def get_currents(x: int) -> Tuple[int, int]:\n        if C[x, Y-1] == '>':\n            return 1, 0\n        elif C[x, Y-1] == '<':\n            return -1, 0\n        else:\n            return 0, 0\n\n    Y, X, x_init = map(int, stdin.split())\n    row = []\n    for i in range(Y):\n        row.append(input())\n\n    south_wind = get_south_wind()\n    if south_wind == -1:\n        return \"begin repairs\"\n\n    # Calculate number of paths\n    paths = [0] * X\n    paths[x_init] = 1\n\n    for y in range(Y-2, south_wind-1, -1):\n        for x in range(X):\n            if C[x, y] == '~':\n                continue\n            elif C[x, y] == '#':\n                paths[x] = 0\n            else:\n                dx, dy = get_currents(x)\n                paths[x] = paths[x] + paths[x+dx] + paths[x-dy]\n\n    return str(paths[x_init] % 1000003)"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split()[:3])\n    row = stdin.splitlines()\n    currents = []\n    for y in range(Y):\n        for x in range(X):\n            if row[y][x] == '>':\n                currents.append((x, y))\n            elif row[y][x] == '<':\n                currents.append((x-1, y))\n\n    def dfs(x, y, current_path, visited):\n        if y < 0 or y >= Y or x < 0 or x >= X or (y, x) in visited or row[y][x] == '#':\n            return\n        visited.add((y, x))\n        if row[y][x] == '@':\n            path = current_path + [x]\n            paths.append(path)\n        else:\n            for x_next, y_next in currents:\n                if (x_next, y_next) not in visited and abs(x_next - x) <= 1:\n                    dfs(x_next, y_next, current_path + [x], visited)\n\n    paths = []\n    visited = set()\n    for y in range(Y-1, -1, -1):\n        for x in range(X):\n            if (x, y) not in visited and row[y][x] == '@':\n                dfs(x, y, [x], visited)\n\n    if not paths:\n        return \"begin repairs\"\n    else:\n        return str(len(set(map(tuple, paths))) % 1000003)"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_paths(x: int, y: int) -> set:\n        paths = set()\n        for direction in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_x, new_y = x, y\n            while 0 <= new_x < X and 0 <= new_y < Y and (C[new_y][new_x] != '>' or (direction == (1, 0) and C[new_y][new_x + 1] == '>') or (direction == (-1, 0) and C[new_y][new_x - 1] == '>')):\n                new_x, new_y = new_x + direction[0], new_y + direction[1]\n                if (new_x, new_y) in visited:\n                    break\n                visited.add((new_x, new_y))\n                if (new_x, new_y) == (X - 1, Y - 1):\n                    paths.add(len(visited))\n                    visited.remove((new_x, new_y))\n                    break\n        return paths\n\n    Y, X, x_init = map(int, stdin.split())\n    C = [list(stdin.strip()) for _ in range(Y)]\n    visited = set()\n\n    if C[0][x_init] == '@':\n        return \"begin repairs\"\n\n    paths = set()\n    for y in range(Y):\n        for x in range(X):\n            if C[y][x] == '@':\n                paths.update(get_paths(x, y))\n\n    return str(len(paths) % 1000003) if paths else \"begin repairs\""
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    Y, X, x_init = map(int, input_data[0].split())\n    map_data = input_data[1:]\n\n    def get_next_tile(x, y, direction):\n        if direction == \">\":\n            if x + 1 < X and map_data[y][x + 1] not in {\"<\", \"#\"}:\n                return x + 1\n        elif direction == \"<\":\n            if 0 <= x - 1 and map_data[y][x - 1] not in {\">\", \"#\"}:\n                return x - 1\n        return None\n\n    def dfs(x, y, visited, direction, result):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        if map_data[y][x] == \"@\":\n            result.append(direction)\n        else:\n            next_tile = get_next_tile(x, y, direction)\n            if next_tile is not None:\n                dfs(next_tile, y, visited, direction, result)\n            else:\n                dfs(x, y - 1, visited, direction, result)\n                dfs(x, y + 1, visited, direction, result)\n\n    result = []\n    visited = set()\n    dfs(x_init, Y - 1, visited, \"\", result)\n\n    if not result:\n        return \"begin repairs\"\n    else:\n        return str(len(set(result)))\n"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    Y, X, x_init = map(int, input_list[0].split())\n    map_list = input_list[1:]\n\n    # Helper function to check if a tile is valid\n    def is_valid(x, y):\n        if x < 0 or x >= X or y < 0 or y >= Y:\n            return False\n        tile = map_list[y][x]\n        if tile == \"~\" or tile == \"@\":\n            return True\n        elif tile == \"#\":\n            return False\n        elif tile == \">\":\n            return x + 1 < X and map_list[y][x + 1] not in [\"<\", \"#\"]\n        elif tile == \"<\":\n            return 0 <= x - 1 and map_list[y][x - 1] not in [\">\", \"#\"]\n        else:\n            raise ValueError(f\"Invalid tile {tile}\")\n\n    # Helper function to get all possible directions\n    def get_directions(x, y):\n        directions = []\n        if is_valid(x + 1, y):\n            directions.append((1, 0))\n        if is_valid(x - 1, y):\n            directions.append((-1, 0))\n        if is_valid(x, y + 1):\n            directions.append((0, 1))\n        return directions\n\n    # Helper function to get all possible paths\n    def get_paths(x, y, visited):\n        if x == x_init and y == Y - 1:\n            return [[]]\n        if (x, y) in visited:\n            return []\n        visited.add((x, y))\n        paths = []\n        for dx, dy in get_directions(x, y):\n            new_x, new_y = x + dx, y + dy\n            paths.extend(path + [((new_x, new_y), direction)] for path in get_paths(new_x, new_y, visited) for direction in get_directions(new_x, new_y))\n        return paths\n\n    # Get all possible paths\n    paths = get_paths(x_init, 0, set())\n\n    # Output the answer\n    if not paths:\n        return \"begin repairs\"\n    else:\n        return str(len(set(tuple(path) for path in paths)))"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split()[:3])\n    map = stdin.split(\"\\n\")[1:]\n\n    def get_currents(x):\n        currents = set()\n        for y in range(Y):\n            if map[y][x] == \">\":\n                currents.add(\"right\")\n            elif map[y][x] == \"<\":\n                currents.add(\"left\")\n        return currents\n\n    def move_west(x):\n        if x == 0:\n            return None\n        if map[0][x - 1] in [\"~\", \">\"]:\n            return x - 1\n        return None\n\n    def move_east(x):\n        if x == X - 1:\n            return None\n        if map[0][x + 1] in [\"~\", \"<\"]:\n            return x + 1\n        return None\n\n    def dfs(x, y, visited, currents, path_count):\n        if y == Y - 1 and map[y][x] == \"@\":\n            path_count[0] += 1\n\n        if visited[y][x]:\n            return\n\n        visited[y][x] = True\n        if currents:\n            if \"right\" in currents:\n                x = move_east(x)\n                dfs(x, y, visited, currents - {\"right\"}, path_count)\n                x = move_west(x)\n                dfs(x, y, visited, currents - {\"right\"}, path_count)\n            if \"left\" in currents:\n                x = move_west(x)\n                dfs(x, y, visited, currents - {\"left\"}, path_count)\n                x = move_east(x)\n                dfs(x, y, visited, currents - {\"left\"}, path_count)\n\n        if not currents:\n            for i in range(y + 1, Y):\n                if map[i][x] in [\"~\", \"@\"]:\n                    dfs(x, i, visited, set(), path_count)\n\n    path_count = [0]\n    visited = [[False for _ in range(X)] for _ in range(Y)]\n    dfs(x_init, 0, visited, get_currents(x_init), path_count)\n\n    if path_count[0] == 0:\n        return \"begin repairs\"\n\n    return str(path_count[0] % 1000003)\n"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    equation = stdin.strip().split('=')\n    left, right = equation[0], equation[1]\n    left_digits = list(map(int, left))\n    right_digit = int(right)\n\n    left_digit_count = len(left_digits)\n    left_carry = 0\n\n    for i in range(left_digit_count - 1, -1, -1):\n        digit = left_digits[i]\n        new_digit = digit + left_carry\n\n        if new_digit > 9:\n            left_carry = 1\n            new_digit -= 10\n        else:\n            left_carry = 0\n\n        left_digits[i] = new_digit\n\n    while left_carry > 0:\n        if 0 in left_digits:\n            left_digits.remove(0)\n        else:\n            left_digits.insert(0, 1)\n        left_carry -= 1\n\n    left_corrected = ''.join(map(str, left_digits))\n    return f'{left_corrected}={right}'\n"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    equation = stdin.strip()\n    a, b = equation.split('=')\n\n    # Convert strings to list of digits\n    a_digits = [int(d) for d in a]\n    b_digits = [int(d) for d in b]\n\n    # Addition operations for the left side\n    addition_operations = []\n\n    # Initialize variables\n    i, j = 0, 0\n    carry = 0\n\n    # Iterate through the digits of A and B\n    while i < len(a_digits) and j < len(b_digits):\n        # Calculate the sum of the current digits and carry\n        sum_ = a_digits[i] + b_digits[j] + carry\n\n        # Extract the last digit as the sum and the remaining digits as carry\n        a_digits[i] = sum_ % 10\n        carry = sum_ // 10\n\n        # If there is no carry, increment the index\n        if not carry:\n            i += 1\n            j += 1\n        else:\n            j += 1\n\n    # Check if there is a carry left\n    if carry:\n        a_digits.append(carry)\n\n    # Convert the list of digits back to a string\n    a_corrected = ''.join(str(d) for d in a_digits)\n\n    # Return the corrected equation\n    return f'{a_corrected}={b}'"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.split('=')\n    A = list(map(int, A))\n    S = int(S)\n\n    def add_digits(A: list[int], index: int, total: int) -> str:\n        if index == len(A):\n            return str(total)\n\n        current_digit = A[index]\n        result = ''\n        if current_digit == 0:\n            result += str(current_digit)\n            return add_digits(A, index + 1, total)\n\n        while current_digit > 0:\n            remainder = current_digit % 10\n            result += str(remainder)\n            current_digit //= 10\n\n        if index == len(A) - 1:\n            total += int(result)\n            return str(total)\n\n        return add_digits(A, index + 1, total + int(result))\n\n    A_str = ''.join(map(str, A))\n    A_str = add_digits(list(map(int, A_str)), 0, 0)\n    return f'{A_str}=S'\n"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, S = stdin.strip().split(\"=\")\n    A = list(map(int, A))\n    S = int(S)\n\n    # iterate over A and find the leftmost index that can be added\n    i = 0\n    while i < len(A) and A[i] + sum(A[:i]) < S:\n        i += 1\n\n    # if i == len(A), no addition can make A equal to S\n    if i == len(A):\n        return \"impossible\"\n\n    # add as many digits as possible to A[i]\n    j = 0\n    while A[i] + j < S and i + j < len(A):\n        A[i] += 1\n        j += 1\n\n    # add leading zeros to A\n    while len(A) < len(str(S)):\n        A.insert(0, 0)\n\n    # join A and return the result\n    return \"=\".join(map(str, A))"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, S = map(int, stdin.split(\"=\"))\n    A = str(A)\n    S = str(S)\n\n    if A == S:\n        return \"No need to correct the equation.\"\n\n    num_digits = max(len(A), len(S))\n    num_ops = num_digits - 1\n\n    A_chunks = []\n    S_chunks = []\n\n    i, j = 0, 0\n    while i < len(A) or j < len(S):\n        if i < len(A) and j < len(S) and A[i] == S[j]:\n            A_chunks.append(A[i])\n            S_chunks.append(S[j])\n            i += 1\n            j += 1\n        elif i < len(A) and A[i] == \"0\":\n            A_chunks.append(A[i])\n            i += 1\n        elif j < len(S) and S[j] == \"0\":\n            S_chunks.append(S[j])\n            j += 1\n        else:\n            break\n\n    A_chunks = [int(chunk) for chunk in A_chunks]\n    S_chunks = [int(chunk) for chunk in S_chunks]\n\n    while num_ops > 0:\n        if S_chunks and S_chunks[-1] != 0:\n            S_chunks[-1] += 1\n        elif A_chunks and A_chunks[-1] != 0:\n            A_chunks[-1] += 1\n        else:\n            num_ops -= 1\n\n    A = \"\".join(str(chunk) for chunk in A_chunks)\n    S = \"\".join(str(chunk) for chunk in S_chunks)\n\n    return A + \"+\" + S + \"=\" + str(S)\n"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # split input into left and right sides\n    left_side, right_side = stdin.split('=')\n\n    # initialize sum of digits on left side and index\n    left_sum = 0\n    index = 0\n\n    # iterate through left side\n    for digit in left_side:\n        # add digit to sum if it's not a leading zero\n        if digit != '0':\n            left_sum += int(digit)\n            # add the digit to the index\n            index += 1\n        # if the sum of digits is equal to the right side, we can stop\n        if left_sum == int(right_side):\n            break\n\n    # convert left side to string with leading zeros\n    left_side_str = str(left_sum).zfill(len(left_side))\n\n    # join the left side and right side with the addition operations\n    return '+'.join(left_side_str) + '=' + right_side\n"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, S = map(int, stdin.split('='))\n    A_str = str(A)\n    S_str = str(S)\n    A_digits = [int(d) for d in A_str]\n    S_digits = [int(d) for d in S_str]\n    \n    # Calculate the difference between A and S\n    diff = sum(A_digits) - sum(S_digits)\n    \n    # Initialize variables for the left side of the equation\n    left_side = []\n    current_digit = 0\n    \n    # Iterate through A_digits and add to left_side\n    for digit in A_digits:\n        current_digit += digit\n        if current_digit <= diff:\n            left_side.append(current_digit)\n            diff -= current_digit\n            current_digit = 0\n        elif diff == 0:\n            left_side.append(current_digit)\n            current_digit = 0\n    \n    # Calculate the number of leading zeros for the correct equation\n    num_leading_zeros = max(len(S_str) - len(str(sum(left_side))), 0)\n    \n    # Convert the left_side to a string with leading zeros\n    left_side_str = '+'.join(map(str, left_side))\n    left_side_str = '0' * num_leading_zeros + left_side_str\n    \n    # Output the corrected equation\n    return left_side_str + '=' + S_str"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    left, right = input_str.split('=')\n    left_num = int(left)\n    right_num = int(right)\n\n    # Convert left number to a list of digits\n    left_digits = [int(digit) for digit in str(left_num)]\n\n    # Find the largest power of 10 that divides the left number\n    largest_power = 1\n    for i in range(len(left_digits)):\n        if left_digits[i] == 0:\n            largest_power *= 10\n        else:\n            break\n\n    # Add leading zeros to the left number\n    if largest_power != 1:\n        left_digits = [0] * (len(left_digits) - len(str(left_num // largest_power))) + left_digits\n\n    # Find the smallest number of addition operations needed to make the equation correct\n    min_ops = float('inf')\n    for i in range(1, len(left_digits)):\n        for j in range(i):\n            ops = 0\n            for k in range(i, j, -1):\n                ops += left_digits[k]\n            if ops == right_num:\n                min_ops = min(min_ops, i - j)\n\n    # Correct the equation by adding addition operations\n    for i in range(1, len(left_digits)):\n        for j in range(i):\n            ops = 0\n            new_digits = left_digits[:j] + [0] * (i - j) + left_digits[j:]\n            for k in range(i, j, -1):\n                ops += new_digits[k]\n            if ops == right_num:\n                corrected_left = '+'.join(str(digit) for digit in new_digits)\n                return f'{corrected_left}={right_num}'"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    equation = stdin.strip()\n    left, right = equation.split('=')\n    left_num, right_num = int(left), int(right)\n\n    # Find the position of the last digit of left_num\n    last_digit_position = len(str(left_num)) - 1\n\n    # Initialize the sum and the current position\n    current_sum = 0\n    current_position = 0\n\n    # Iterate over the digits of left_num from right to left\n    while current_position < last_digit_position:\n        # Calculate the sum of the current digit and the next digit\n        next_digit = left_num % 10\n        current_sum += next_digit\n        left_num //= 10\n\n        # If the current sum is equal to the right_num, we found a solution\n        if current_sum == right_num:\n            return f'{left[:current_position]}{next_digit}+{left[current_position+1:]}={right}'\n\n        # If the current sum is less than the right_num, move to the next position\n        elif current_sum < right_num:\n            current_position += 1\n\n    # If we didn't find a solution, return None\n    return None"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    equation = stdin.strip()\n    A, S = equation.split('=')\n    A = int(A)\n    S = int(S)\n\n    A_str = str(A)\n    S_str = str(S)\n\n    if A == S:\n        return \"The equation is already correct.\"\n\n    result = []\n    while A != S:\n        if A < S:\n            result.append(A)\n            A = 0\n        else:\n            A -= S\n\n    result.append(S)\n\n    corrected_equation = ''\n    for digit in result:\n        if digit != 0:\n            corrected_equation += str(digit)\n        else:\n            corrected_equation += '0'\n\n    return f\"{corrected_equation}={S_str}\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_lexicographically_smallest_pair(S):\n        for c in range(1, N-2):\n            for d in range(c+1, N-1):\n                for e in range(d+1, N):\n                    if S[c] == S[e] and S[d] == S[e]:\n                        return (S[c], S[d])\n        return None\n\n    def is_subsequence(seq1, seq2):\n        i = 0\n        for elem in seq2:\n            if i >= len(seq1):\n                break\n            if seq1[i] == elem:\n                i += 1\n        return i == len(seq1)\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    S = [int(line) for line in lines[1:]]\n\n    pattern = find_lexicographically_smallest_pair(S)\n    if pattern is None:\n        return -1\n\n    for i in range(N-3):\n        for j in range(i+2, N-1):\n            if is_subsequence(pattern, S[i:j+1]):\n                return ' '.join(map(str, sorted(pattern)))\n\n    return -1\n"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    S = list(map(int, stdin.split(\"\\n\")[1:]))\n\n    if any(S[i] == S[i + 1] for i in range(N - 1)):\n        return \"-1\"\n\n    for a in range(1, N - 3):\n        for b in range(a + 1, N - 2):\n            if S[a] != S[b] and S[b] == S[b + 1] and S[a] == S[a + 2]:\n                return f\"{min(S[a], S[b])} {max(S[a], S[b])}\"\n\n    return \"-1\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    S = [int(stdin.split()[1]) for _ in range(N)]\n\n    for c in range(N - 3):\n        for d in range(c + 1, N - 2):\n            for e in range(d + 1, N - 1):\n                if S[c] == S[e] and S[d] == S[e] and S[c] != S[d]:\n                    return f\"{S[c]} {S[d]}\"\n\n    return \"-1\"\n\ninput_stdin = \"\"\"8\n1\n3\n2\n4\n1\n5\n2\n4\"\"\"\n\ninput_stdin2 = \"\"\"8\n1\n2\n3\n4\n5\n6\n7\n1\"\"\"\n\ninput_stdin3 = \"\"\"1\n1\"\"\"\n\ninput_stdin4 = \"\"\"2\n1\n2\"\"\"\n\ninput_stdin5 = \"\"\"3\n1\n2\n3\"\"\"\n\ninput_stdin6 = \"\"\"4\n1\n2\n3\n4\"\"\"\n\ninput_stdin7 = \"\"\"5\n1\n2\n3\n4\n5\"\"\"\n\ninput_stdin8 = \"\"\"6\n1\n2\n3\n4\n5\n6\"\"\"\n\ninput_stdin9 = \"\"\"7\n1\n2\n3\n4\n5\n6\n7\"\"\"\n\ninput_stdin10 = \"\"\"8\n1\n2\n3\n4\n5\n6\n7\n8\"\"\"\n\ninput_stdin11 = \"\"\"9\n1\n2\n3\n4\n5\n6\n7\n8\n9\"\"\"\n\ninput_stdin12 = \"\"\"10\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\"\"\"\n\ninput_stdin13 = \"\"\"11\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\"\"\"\n\ninput_stdin14 = \"\"\"12\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\"\"\"\n\ninput_stdin15 = \"\"\"13\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\"\"\"\n\ninput_stdin16 = \"\"\"14\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\"\"\"\n\ninput_stdin17 = \"\"\"15\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\"\"\"\n\ninput_stdin18 = \"\"\"16\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\"\"\"\n\ninput_stdin19 = \"\"\"17\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\"\"\"\n\ninput_stdin20 = \"\"\"18\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\"\"\"\n\ninput_stdin21 = \"\"\"19\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\"\"\"\n\ninput_stdin22 = \"\"\"20\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\"\"\"\n\ninput_stdin23 = \"\"\"21\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\"\"\"\n\ninput_stdin24 = \"\"\"22\n1\n2\n"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    S = input_list[1:]\n    S = [int(s) for s in S]\n\n    for i in range(N - 3):\n        if S[i] == S[i + 2] and S[i + 1] == S[i + 3]:\n            return f\"{S[i]} {S[i + 1]}\"\n    return \"-1\"\n"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    S = [int(input_line) for input_line in input_lines[1:]]\n\n    for i in range(N - 3):\n        if S[i] == S[i+3] and S[i+1] != S[i+2]:\n            return f\"{S[i]} {S[i+1]}\"\n\n    return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    S = [int(x) for x in input_list[1:]]\n\n    for i in range(N - 3):\n        if S[i] == S[i + 2] and S[i + 1] == S[i + 3]:\n            return f\"{min(S[i], S[i + 1])} {max(S[i], S[i + 1])}\"\n\n    return \"-1\""
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    S = [int(x) for x in input_data[1:]]\n\n    A = None\n    B = None\n\n    for i in range(N - 3):\n        if S[i] == S[i + 2] and S[i + 1] != S[i] and S[i + 1] != S[i + 2]:\n            A = S[i]\n            B = S[i + 1]\n            break\n\n    if A is None:\n        return \"-1\"\n\n    return f\"{A} {B}\"\n\n\ndef"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    S = [int(x) for x in stdin.split('\\n')[1:]]\n    pattern = [(S[i], S[i+1]) for i in range(N-1) if S[i] == S[i+1]]\n    if not pattern:\n        return -1\n    A, B = min(pattern, key=lambda x: (x[0], x[1]))\n    return f\"{A} {B}\""
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    S = [int(line) for line in stdin.splitlines()[1:]]\n    A = B = -1\n    found = False\n    for i in range(N - 3):\n        if S[i] == S[i + 2] and S[i + 1] == S[i + 3]:\n            if A == -1 or S[i] < A:\n                A = S[i]\n                B = S[i + 1]\n            elif A == S[i] and B > S[i + 1]:\n                B = S[i + 1]\n            found = True\n    if found:\n        return f\"{A} {B}\"\n    else:\n        return \"-1\"\n\ninput_string = \"\"\"8\n1\n3\n2\n4\n1\n5\n2\n4\"\"\"\nprint(solution(input_string))"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    S = [int(input_lines[i]) for i in range(1, N + 1)]\n\n    # Find the pattern A, B, A, B\n    pattern_found = False\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            if S[i] == S[j + 1] and S[j] == S[j + 2]:\n                A = min(S[i], S[j])\n                B = max(S[i], S[j])\n                pattern_found = True\n                break\n        if pattern_found:\n            break\n\n    if not pattern_found:\n        return \"-1\"\n    else:\n        return f\"{A} {B}\"\n\n\nstdin = \"\"\"8\n1\n3\n2\n4\n1\n5\n2\n4\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"8\n1\n2\n3\n4\n5\n6\n7\n1\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = list(stdin)\n    n = len(lights)\n    timesteps = 1\n\n    # Calculate the propagation time for each light\n    propagation_time = [0] * n\n    for i in range(n):\n        for j in range(i+1, n):\n            if lights[i] == '1' and lights[j] == '0':\n                propagation_time[j] = timesteps + 1\n\n    # Find the earliest time when all the lights are on\n    earliest_time = float('inf')\n    for i in range(n):\n        if lights[i] == '1':\n            earliest_time = min(earliest_time, timesteps + propagation_time[i])\n\n    return str(earliest_time)\n"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [False] * n\n    button_press = -1\n    for i, light in enumerate(stdin):\n        if light == '1':\n            lights[i] = True\n        elif light == '0':\n            lights[i] = False\n        else:\n            raise ValueError(\"Invalid input\")\n\n    for i in range(n):\n        if lights[i]:\n            button_press = i\n            break\n\n    if button_press == -1:\n        return \"0\"\n\n    for m in range(n):\n        if button_press + m < n:\n            if lights[button_press + m]:\n                return button_press + m\n    return n\n"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    lights = list(stdin)\n    n = len(lights)\n    \n    # Initialize a dictionary to store the last time each light was toggled\n    last_toggled = {i: -1 for i in range(1, n+1)}\n    \n    # Initialize a list to store the time when all lights are on\n    times = []\n    \n    # Iterate through the lights and their button presses\n    for i in range(n):\n        # If the button is pressed, toggle the lights down the line\n        if lights[i] == '1':\n            for k in range(i+1, n+1):\n                if last_toggled[k] != -1:\n                    last_toggled[k] = max(last_toggled[k], i)\n                else:\n                    last_toggled[k] = i\n        \n        # If all lights are on at the current time, store it\n        if all(last_toggled[k] != -1 for k in range(1, n+1)):\n            times.append(i)\n    \n    # If all lights are on at the end, return the last time\n    if times:\n        return max(times)\n    else:\n        return -1\n"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(c) for c in stdin]\n    n = len(lights)\n    for i in range(n):\n        lights[i] = i + 1\n    \n    # propagate lights\n    for i in range(n):\n        for j in range(n):\n            if lights[i] <= j + i + 1 <= n:\n                lights[j + i + 1] = max(lights[j + i + 1], lights[i] + i + 1)\n    \n    # find the earliest time to turn on all lights\n    earliest_time = 0\n    for i in range(n):\n        if lights[i] > earliest_time:\n            earliest_time = lights[i]\n    \n    return str(earliest_time)"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(c) for c in stdin]\n    n = len(lights)\n    max_time = 0\n    for i in range(n):\n        if lights[i] == 1:\n            max_time = max(max_time, i)\n        else:\n            max_time = max(max_time, i+1)\n    return max_time"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [int(c) for c in stdin]\n    time = 0\n    while not all(lights):\n        next_lights = [lights[i] ^ (lights[i+1] if i+1 < n else 0) for i in range(n)]\n        lights = next_lights\n        time += 1\n    return time"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lights = [1 if char == '1' else 0 for char in stdin]\n    n = len(lights)\n\n    def toggle(lights, i, k):\n        for j in range(i, n):\n            if lights[j] == 1:\n                lights[j] = 0\n            else:\n                lights[j] = 1\n\n    def propagation(lights, k):\n        for i in range(n):\n            if lights[i] == 1:\n                toggle(lights, i, k)\n\n    if all(lights):\n        return 0\n\n    earliest_time = 1\n    while not all(lights):\n        toggle(lights, 0, earliest_time)\n        propagation(lights, earliest_time)\n        earliest_time += 1\n\n    return earliest_time - 1"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [int(c) for c in stdin]\n    toggles = [0] * n\n\n    def toggle(light: int, time: int) -> None:\n        toggles[light] += 1\n        if toggles[light] == 1:\n            lights[light] ^= 1\n            for i in range(light + 1, n):\n                toggles[i] += 1\n\n    def toggle_from_button(button: int, time: int) -> None:\n        for i in range(button, n):\n            toggle(i, time)\n\n    first_button_time = 0\n    while first_button_time < n:\n        toggles = [0] * n\n        light_states = lights.copy()\n        toggle_from_button(first_button_time, first_button_time)\n        for time in range(first_button_time + 1, n):\n            for button in range(n):\n                toggle_from_button(button, time)\n            if all(light == 1 for light in light_states):\n                return time\n        first_button_time += 1\n\n    return 0\n"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lights = list(stdin)\n    lights = [int(light) for light in lights]\n    \n    earliest_time = -1\n    \n    for i in range(len(lights)):\n        if lights[i] == 0:\n            earliest_time = i\n            break\n    \n    if earliest_time == -1:\n        return str(0)\n    \n    # Simulate button presses\n    for time in range(1, len(lights) + 1):\n        for i in range(len(lights)):\n            if i + time <= len(lights) - 1:\n                if lights[i + time] == 0:\n                    if lights[i] == 1:\n                        lights[i + time] = 1\n                        lights[i] = 0\n                    else:\n                        lights[i + time] = 0\n                        \n    # Find earliest time at which all lights are on\n    earliest_time_on = -1\n    for i in range(len(lights)):\n        if lights[i] == 1:\n            earliest_time_on = i\n            break\n    \n    return str(earliest_time_on)"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    lights = [int(c) for c in stdin]\n    prev_press = None\n    \n    for i in range(n):\n        if lights[i] == 1:\n            prev_press = i\n        \n        if prev_press is not None:\n            lights[prev_press+1:] = [1] * (n-prev_press-1)\n            prev_press = None\n    \n    return n - lights.index(1) if 1 in lights else 0"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_turns(route):\n        turns = []\n        for i in range(len(route) - 1):\n            if route[i] != route[i + 1]:\n                turns.append(i)\n        return turns\n\n    def encounters(routes, pairs):\n        enc = 0\n        for i in range(len(pairs)):\n            r1, r2 = routes[pairs[i][0] - 1], routes[pairs[i][1] - 1]\n            turns1, turns2 = find_turns(r1), find_turns(r2)\n            enc += len(set(turns1).intersection(turns2))\n        return enc\n\n    N, M = map(int, input().split())\n    routes = []\n    for i in range(N):\n        K = int(input())\n        route = list(map(int, input().split()))\n        routes.append(route)\n\n    pairs = []\n    for i in range(M):\n        a, b = map(int, input().split())\n        pairs.append((a, b))\n\n    return str(encounters(routes, pairs))"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, trucks, pairs = parse_input(stdin)\n    encounter_count = [0] * M\n\n    for i in range(M):\n        a, b = pairs[i]\n        count = count_encounters(a, b, trucks)\n        encounter_count[i] = count\n\n    output = '\\n'.join(str(count) for count in encounter_count)\n    return output\n\n\ndef"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list.pop(0).split())\n\n    routes = []\n    for _ in range(N):\n        cities = sorted(map(int, input_list.pop(0).split()[1:]))\n        routes.append(cities)\n\n    encounters = {}\n    for _ in range(M):\n        a, b = map(int, input_list.pop(0).split())\n        encounters[(a, b)] = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for city in routes[i]:\n                for other_city in routes[j]:\n                    if city == other_city:\n                        encounters[(i + 1, j + 1)] += 1\n\n    for key, value in encounters.items():\n        print(value)\n\n\ndef"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    trucks = [list(map(int, lines[i+1].split())) for i in range(N)]\n    pairs = [list(map(int, lines[i+1+N].split())) for i in range(M)]\n    \n    # Initialize the result array\n    result = [0] * M\n    \n    # Iterate through the trucks\n    for i in range(N):\n        # Calculate the time for each city\n        times = [0] * len(trucks[i])\n        for j in range(1, len(trucks[i])):\n            times[j] = times[j-1] + 1\n        \n        # Iterate through the pairs\n        for j in range(M):\n            # Check if the trucks meet\n            if abs(pairs[j][0] - i) < abs(pairs[j][1] - i):\n                a, b = pairs[j]\n            else:\n                a, b = pairs[j][1], pairs[j][0]\n            # Check if the trucks meet at the same position\n            if min(trucks[a][0], trucks[a][-1]) <= max(trucks[b][0], trucks[b][-1]):\n                result[j] += 1\n    \n    # Write the output\n    output = '\\n'.join(map(str, result))\n    return output"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    truck_routes = []\n    for i in range(N):\n        K = int(input())\n        cities = list(map(int, input().split()))\n        truck_routes.append(cities)\n\n    encounters = [0] * M\n    for i in range(M):\n        a, b = map(int, input().split())\n        encounters[i] = count_encounters(truck_routes, a, b)\n\n    return '\\n'.join(map(str, encounters))\n\n\ndef"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    routes = stdin.split('\\n')[1:N+1]\n    pairs = stdin.split('\\n')[N+1:].split('\\n')\n\n    encounters = [0] * M\n    for i, pair in enumerate(pairs):\n        a, b = map(int, pair.split())\n        if a == b:\n            encounters[i] = 0\n        else:\n            route_a = routes[a-1].split()\n            route_b = routes[b-1].split()\n            route_a = list(map(int, route_a[1:]))\n            route_b = list(map(int, route_b[1:]))\n            intersection = sorted(set(route_a).intersection(route_b))\n            encounters[i] = len(intersection)\n\n    output = '\\n'.join(map(str, encounters))\n    return output"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    routes = [list(map(int, stdin.split()[2+i*N:2+i*N+N])) for i in range(N)]\n    pairs = [tuple(map(int, stdin.split()[2+N*N+i*2:2+N*N+i*2+2])) for i in range(M)]\n    \n    encounters = []\n    for pair in pairs:\n        a, b = pair\n        route_a, route_b = routes[a-1], routes[b-1]\n        if route_a[0] > route_b[0]:\n            route_a, route_b = route_b, route_a\n        encounters.append(route_a.count(route_b[0]))\n    \n    return \"\\n\".join(map(str, encounters))"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(a: int, b: int) -> int:\n        return abs(a - b)\n\n    def process_input(input_lines: List[str]) -> Tuple[int, int, List[Tuple[int, List[int]]], List[Tuple[int, int]]]:\n        N, M = map(int, input_lines[0].split())\n        routes = []\n        for i in range(1, N + 1):\n            K, *A = map(int, input_lines[i].split())\n            routes.append((K, A))\n        pairs = []\n        for i in range(M):\n            a, b = map(int, input_lines[N + 1 + i].split())\n            pairs.append((a, b))\n        return N, M, routes, pairs\n\n    def encounters(N: int, routes: List[Tuple[int, List[int]]], pairs: List[Tuple[int, int]]) -> List[int]:\n        encounters_count = [0] * M\n        for i in range(M):\n            a, b = pairs[i]\n            for route in routes:\n                K, A = route\n                for k in range(1, K):\n                    if A[k - 1] == A[k]:\n                        continue\n                    if a == A[k - 1] and b == A[k]:\n                        encounters_count[i] += 1\n                    elif a == A[k] and b == A[k - 1]:\n                        encounters_count[i] += 1\n        return encounters_count\n\n    input_lines = stdin.splitlines()\n    N, M, routes, pairs = process_input(input_lines)\n    encounters_count = encounters(N, routes, pairs)\n    result = '\\n'.join(map(str, encounters_count))\n    return result"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data.pop(0).split())\n    routes = [list(map(int, input_data.pop(0).split()))[1:] for _ in range(N)]\n    pairs = [tuple(map(int, input_data.pop(0).split())) for _ in range(M)]\n\n    encounters = [0] * M\n\n    for i, pair in enumerate(pairs):\n        truck_a, truck_b = pair\n        route_a, route_b = routes[truck_a - 1], routes[truck_b - 1]\n        if len(set(route_a) & set(route_b)):\n            encounters[i] = 1\n\n    return '\\n'.join(map(str, encounters))\n\n\ninput_data = '''3 3\n3 1 3 1\n2 2 1\n3 3 1 3\n1 2\n2 3\n3 1'''\n\nprint(solution(input_data))"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    input_data = [line.strip() for line in stdin.split('\\n')]\n    N, M = map(int, input_data[0].split())\n    truck_routes = input_data[1:N+1]\n    pair_indices = [tuple(map(int, line.split())) for line in input_data[N+1:]]\n\n    # process input\n    truck_positions = [0] * N\n    truck_turn_time = [0] * N\n    for i in range(N):\n        K, *A = map(int, truck_routes[i].split())\n        for j in range(K-1):\n            truck_positions[i] += abs(A[j+1] - A[j]) / 60\n            truck_turn_time[i] += abs(A[j+1] - A[j]) / 60\n\n    # count encounters\n    encounters = [0] * M\n    for i in range(M):\n        a, b = pair_indices[i]\n        t1, t2 = truck_positions[a-1], truck_positions[b-1]\n        tt1, tt2 = truck_turn_time[a-1], truck_turn_time[b-1]\n        if t1 < t2:\n            encounters[i] += (tt1 + t1 + 1) // 2 + (t2 - t1 - tt2) // 2\n        elif t1 > t2:\n            encounters[i] += (tt1 + t1 + 1) // 2 + (t2 - t1 - tt2) // 2\n        else:\n            encounters[i] += (tt1 + t1 + 1) // 2\n\n    # output result\n    result = '\\n'.join(map(str, encounters))\n    return result\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_average(seq: list) -> float:\n        return sum(seq) / len(seq)\n\n    def is_consecutive(seq: list) -> bool:\n        return all(seq[i] == seq[i + 1] for i in range(len(seq) - 1))\n\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    A.sort()\n    max_avg = -float('inf')\n\n    for i in range(N - K + 1):\n        if is_consecutive(A[i:i + K]):\n            avg = get_average(A[i:i + K])\n            max_avg = max(max_avg, avg)\n\n    return f\"{max_avg:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    def find_average(start: int, end: int) -> float:\n        return sum(A[start:end+1]) / (end - start + 1)\n\n    def binary_search(start: int, end: int, target: float) -> int:\n        while start <= end:\n            mid = (start + end) // 2\n            if find_average(start, mid) >= target:\n                end = mid - 1\n            else:\n                start = mid + 1\n        return end\n\n    max_average = 0\n    for i in range(N - K + 1):\n        j = binary_search(i, i + K - 1, max_average)\n        max_average = max(max_average, find_average(i, j))\n\n    return f\"{max_average:.6f}\"\n\n\ninput_data = \"\"\"4 1\n1 2 3 4\n4 2\n2 4 3 4\"\"\"\n\noutput_data = \"\"\"4.000000\n3.666666\"\"\"\n\nfor data, result in zip(input_data.split(\"\\n\"), output_data.split(\"\\n\")):\n    print(f\"Input: {data}\\nOutput: {solution(data)}\\nExpected Output: {result}\\n\") "
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from typing import List\n\n    def max_consecutive_sum(arr: List[int], k: int) -> float:\n        if k == 1:\n            return float(max(arr))\n\n        sum_so_far = sum(arr[:k])\n        max_sum = sum_so_far\n        for i in range(k, len(arr)):\n            sum_so_far += arr[i] - arr[i - k]\n            max_sum = max(max_sum, sum_so_far)\n\n        return float(max_sum) / k\n\n    def max_consecutive_avg(arr: List[int], k: int) -> float:\n        total_sum = sum(arr)\n        return float(total_sum) / k\n\n    def max_avg_consecutive_subsequence(arr: List[int], k: int) -> float:\n        max_sum = max_consecutive_sum(arr, k)\n        max_avg = max_consecutive_avg(arr, k)\n        return max_sum if max_sum > max_avg else max_avg\n\n    N, K = map(int, stdin.split()[:2])\n    arr = list(map(int, stdin.split()[2:]))\n\n    return f\"{max_avg_consecutive_subsequence(arr, K):.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    numbers = list(map(int, stdin.split()[2:]))\n    max_sum = sum(numbers[:K])\n    max_avg = max_sum / K\n    for i in range(K, N):\n        max_sum = max_sum - numbers[i - K] + numbers[i]\n        avg = max_sum / K\n        if avg > max_avg:\n            max_avg = avg\n    return f\"{max_avg:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    n, k = map(int, input_list[0].split())\n    nums = list(map(int, input_list[1].split()))\n    \n    max_average = 0\n    for i in range(n - k + 1):\n        avg = sum(nums[i:i+k]) / k\n        if avg > max_average:\n            max_average = avg\n            \n    return f\"{max_average:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[1:3])\n    nums = list(map(int, stdin.split()[3:]))\n\n    if N < K:\n        return \"0.000000\"\n\n    max_avg = float(\"-inf\")\n    for i in range(N - K + 1):\n        avg = sum(nums[i:i+K]) / K\n        if avg > max_avg:\n            max_avg = avg\n\n    return \"{:.6f}\".format(max_avg)\n\ndef"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def mean(numbers):\n        return sum(numbers) / len(numbers)\n\n    N, K = map(int, stdin.split()[:2])\n    numbers = list(map(int, stdin.split()[2:]))\n\n    max_average = -1\n    for i in range(N - K + 1):\n        subsequence = numbers[i:i + K]\n        subsequence_average = mean(subsequence)\n        if subsequence_average > max_average:\n            max_average = subsequence_average\n\n    return f\"{max_average:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    max_sum = 0\n    max_avg = 0\n\n    for i in range(N - K + 1):\n        current_sum = sum(A[i:i+K])\n        current_avg = current_sum / K\n\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_avg = current_avg\n\n    return f\"{max_avg:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    arr = list(map(int, input().split()))\n    \n    max_avg = 0\n    for i in range(N - K + 1):\n        avg = sum(arr[i:i+K]) / K\n        if avg > max_avg:\n            max_avg = avg\n    \n    return f\"{max_avg:.6f}\"\n"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    \n    def get_average(start: int, end: int) -> float:\n        return sum(A[start:end+1]) / (end - start + 1)\n    \n    max_average = 0\n    max_start = 0\n    max_end = 0\n    \n    for end in range(K-1, N):\n        start = end - K + 1\n        average = get_average(start, end)\n        \n        if average > max_average:\n            max_average = average\n            max_start = start\n            max_end = end\n    \n    return f\"{max_average:.6f}\""
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, w, h = map(int, input_data[0].split())\n    volumes = list(map(float, input_data[1].split()))\n    divider_positions = list(map(float, input_data[2].split()))\n    min_sand = [list(map(float, input_data[i+3].split())) for i in range(n)]\n    max_sand = [list(map(float, input_data[i+n+3].split())) for i in range(n)]\n\n    section_volumes = [0] * n\n    for i in range(n):\n        for j in range(m):\n            section_volumes[i] += min(max_sand[i][j], max_sand[i][j] / volumes[j] * (divider_positions[i] - divider_positions[i-1]))\n\n    max_height = max(section_volumes)\n    min_height = min(section_volumes)\n\n    return round((max_height - min_height) / max_height, 3)"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n, m, w, h = map(int, input_str[0].split())\n    v = list(map(float, input_str[1].split()))\n    x = list(map(float, input_str[2].split()))\n    min_sand = []\n    max_sand = []\n\n    for _ in range(n):\n        min_sand.append(list(map(float, input_str[3 + _].split())))\n        max_sand.append(list(map(float, input_str[4 + _].split())))\n\n    sand_volumes = [0] * m\n    for i in range(m):\n        sand_volumes[i] = v[i] * w * h\n\n    min_height = w * h\n    max_height = 0\n\n    for i in range(n):\n        total_sand = 0\n        sand_height = 0\n        for j in range(m):\n            total_sand += min_sand[i][j] * sand_volumes[j]\n            sand_height += min_sand[i][j] * sand_volumes[j] / v[j]\n        total_sand += sand_volumes[m]\n        sand_height += sand_volumes[m] / v[m]\n        min_height = min(min_height, sand_height)\n        sand_height = 0\n        for j in range(m):\n            total_sand += max_sand[i][j] * sand_volumes[j]\n            sand_height += max_sand[i][j] * sand_volumes[j] / v[j]\n        total_sand += sand_volumes[m]\n        sand_height += sand_volumes[m] / v[m]\n        max_height = max(max_height, sand_height)\n\n    return round(max_height - min_height, 3)\n"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def read_line(s: str, i: int) -> str:\n        return s.split('\\n')[i].strip()\n\n    def read_float_list(s: str, i: int) -> List[float]:\n        return list(map(float, read_line(s, i).split()))\n\n    def read_int_list(s: str, i: int) -> List[int]:\n        return list(map(int, read_line(s, i).split()))\n\n    input_data = stdin.split('\\n')\n    n, m, w, h = read_int_list(input_data[0], 0)\n    v = read_float_list(input_data[1], 0)\n    x = read_float_list(input_data[2], 0)\n    min_sand = read_float_list(input_data[3], 0)\n    max_sand = read_float_list(input_data[4], 0)\n\n    sand_heights = [0] * n\n    for i in range(n):\n        if i == 0:\n            sand_heights[i] += min_sand[i]\n        else:\n            sand_heights[i] += max_sand[i - 1]\n\n    max_height = max(sand_heights)\n    min_height = min(sand_heights)\n\n    return round(max_height - min_height, 3)\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m, w, h, *v = map(float, stdin.split())\n    v = [int(x*w*h) for x in v]\n    x = sorted(map(float, input().split()))\n    min_sand = [list(map(float, input().split())) for _ in range(n)]\n    max_sand = [list(map(float, input().split())) for _ in range(n)]\n\n    # Calculate the total volume of sand for each color\n    total_sand = [0] * m\n    for i in range(n):\n        for j in range(m):\n            total_sand[j] += min_sand[i][j] * v[j]\n\n    # Calculate the maximum and minimum height of sand for each section\n    max_height = [0] * n\n    min_height = [0] * n\n    for i in range(n):\n        if i == 0:\n            min_height[i] = 0\n            max_height[i] = total_sand[0]\n        else:\n            min_height[i] = max_height[i-1]\n            max_height[i] = min_height[i] + total_sand[i]\n\n    # Calculate the maximum and minimum height for each section considering the dividers\n    for i in range(n-1):\n        j = i + 1\n        min_height[j] = min_height[i] + (max_height[i] - min_height[i]) * (x[i+1] - x[i]) / w\n        max_height[j] = min_height[i] + (max_height[i] - min_height[i]) * (x[j] - x[i]) / w\n\n    # Calculate the difference between the maximum and minimum heights of sand in the sections\n    min_difference = max_height[-1] - min_height[0]\n    for i in range(1, n):\n        min_difference = min(min_difference, max_height[i] - min_height[i-1])\n\n    return round(min_difference, 3)"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, w, h, *sand_volumes = map(float, input_data.pop(0).split())\n    sand_volumes = [sand_volumes[i:i+2] for i in range(0, len(sand_volumes), 2)]\n    sand_volumes = [(v1, v2) for v1, v2 in sand_volumes if v1 > 0 and v2 > 0]\n\n    x = list(map(float, input_data.pop(0).split()))\n    min_sand = [list(map(float, input_data.pop(0).split())) for _ in range(n)]\n    max_sand = [list(map(float, input_data.pop(0).split())) for _ in range(n)]\n\n    min_total = 0\n    max_total = 0\n    for i in range(n):\n        for j, (min_j, max_j) in enumerate(zip(min_sand[i], max_sand[i])):\n            if min_j > 0:\n                min_total += min_j\n            if max_j > 0:\n                max_total += max_j\n\n    if min_total == 0 or max_total == 0:\n        return \"0.000\"\n\n    min_total /= w * h\n    max_total /= w * h\n\n    return \"{:.3f}\".format(abs(min_total - max_total))\n\ndef"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, w, h, *v = map(float, input_data[0].split())\n    v = [float(x) for x in v]\n    x = [float(x) for x in input_data[1].split()]\n    min_sand = [[float(x) for x in input_data[i+2].split()] for i in range(n)]\n    max_sand = [[float(x) for x in input_data[i+2+n].split()] for i in range(n)]\n\n    sand_height = [0] * n\n    for i in range(n):\n        sand_height[i] = sum([v[j] * max_sand[i][j] for j in range(m)])\n\n    diff = max(sand_height) - min(sand_height)\n    return round(diff, 3)\n"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_sand_height(divider_positions: list, sand_volumes: list, min_amounts: list, max_amounts: list) -> list:\n        sand_heights = []\n        for i, x in enumerate(divider_positions):\n            sand_amount = sum([min_amounts[j][i] * sand_volumes[j] for j in range(m)])\n            sand_heights.append(x + sand_amount)\n        return sand_heights\n\n    def find_balance(sand_heights: list) -> float:\n        return max(sand_heights) - min(sand_heights)\n\n    n, m, w, h, *sand_volumes = list(map(float, stdin.split()))\n    sand_volumes = [round(x / w * h) for x in sand_volumes]\n    divider_positions = [round(float(x), 3) for x in stdin.split('\\n')[2].split()]\n    min_amounts = [[float(x) for x in line.split()] for line in stdin.split('\\n')[3:n + 3]]\n    max_amounts = [[float(x) for x in line.split()] for line in stdin.split('\\n')[n + 3:2 * n + 3]]\n\n    sand_heights = calculate_sand_height(divider_positions, sand_volumes, min_amounts, max_amounts)\n    balance = find_balance(sand_heights)\n\n    return round(balance, 3)\n"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n, m, w, h = map(int, input_str[0].split())\n    volumes = list(map(float, input_str[1].split()))\n    divider_x = list(map(float, input_str[2].split()))\n    min_amounts = [list(map(float, input_line.split())) for input_line in input_str[3:3+n]]\n    max_amounts = [list(map(float, input_line.split())) for input_line in input_str[3+n:3+n+n]]\n\n    min_heights = [0] * n\n    max_heights = [0] * n\n    for i in range(n):\n        for j in range(m):\n            min_heights[i] += min(volumes[j], max_amounts[i][j])\n            max_heights[i] += min(volumes[j], max_amounts[i][j])\n\n    min_height = min(min_heights)\n    max_height = max(max_heights)\n    return round(max_height - min_height, 3)\n"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, m, w, h = map(int, inputs[0].split())\n    v = list(map(float, inputs[1].split()))\n    x = list(map(float, inputs[2].split()))\n    min_sand_level = [[float(x) for x in inputs[i+3].split()] for i in range(n)]\n    max_sand_level = [[float(x) for x in inputs[i+3+n].split()] for i in range(n)]\n    \n    def sand_height(x: float, w: float, h: float, min_sand_level: list, max_sand_level: list) -> float:\n        return (min_sand_level[x] / w + max_sand_level[x] / w) / 2\n    \n    sand_heights = [sand_height(i, w, h, min_sand_level, max_sand_level) for i in range(n)]\n    max_height = max(sand_heights)\n    min_height = min(sand_heights)\n    \n    return round((max_height - min_height), 3)"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, w, h = map(int, input_data[0].split())\n    v = list(map(float, input_data[1].split()))\n    x = list(map(float, input_data[2].split()))\n    min_sand = [list(map(float, input_data[i].split())) for i in range(3, 3 + n)]\n    max_sand = [list(map(float, input_data[i].split())) for i in range(3 + n, 3 + 2 * n)]\n\n    sand_heights = []\n    for i in range(n):\n        sand_height = [0] * m\n        for j in range(m):\n            sand_height[j] = min_sand[i][j]\n        sand_heights.append(sand_height)\n\n    for i in range(n - 1):\n        x_left = x[i]\n        x_right = x[i + 1]\n        width = x_right - x_left\n\n        for j in range(m):\n            sand_level = sum(min_sand[i][j] for i in range(n)) / n\n            min_height = sand_level / width * width\n            max_height = sand_level / width * width\n\n            for k in range(n):\n                min_sand[k][j] = max(min_sand[k][j], min_height)\n                max_sand[k][j] = min(max_sand[k][j], max_height)\n\n    for i in range(n):\n        for j in range(m):\n            sand_heights[i][j] = (sum(max_sand[i][j]) + sum(min_sand[i][j])) / 2\n\n    max_height = max(max(sand_heights, key=max))\n    min_height = min(min(sand_heights, key=min))\n\n    return round(max_height - min_height, 3)"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_code(code: str) -> bool:\n        m, n = len(code), len(code[0])\n        seen = set()\n        for i in range(m):\n            row = code[i]\n            if len(seen.intersection(row)) > 0:\n                return False\n            seen = seen.union(set(row))\n        for j in range(n):\n            col = [code[i][j] for i in range(m)]\n            if len(seen.intersection(col)) > 0:\n                return False\n            seen = seen.union(set(col))\n        for i in range(m - 1):\n            for j in range(n - 1):\n                u, l, r = code[i][j], code[i][j + 1], code[i + 1][j]\n                if (u == l * r) or (u == l + r) or (u == l - r) or (u == l // r) or (u == l % r) or (u == r - l) or (u == r // l) or (u == r % l):\n                    continue\n                return False\n        return True\n\n    def count_codes(m: int, n: int, code: List[List[int]]) -> int:\n        if m == 1 and n == 1:\n            return 1 if is_valid_code([[code[0][0]]]) else 0\n        elif m == 1:\n            return count_codes(1, n - 1, code) * 9\n        elif n == 1:\n            return count_codes(m - 1, 1, code) * 9\n        else:\n            count = 0\n            for i in range(1, 10):\n                code[0][0] = i\n                count += count_codes(m - 1, n - 1, code)\n            return count\n\n    m, n = map(int, stdin.split()[:2])\n    code = [list(map(int, stdin.split()[2:][i * n : (i + 1) * n])) for i in range(m)]\n    return count_codes(m, n, code)"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    m, n = map(int, input_list[0].split())\n    matrix = [list(map(int, input_list[i].split())) for i in range(1, m+1)]\n    unknown_count = 0\n    for row in matrix:\n        unknown_count += row.count(0)\n    # Calculate the number of valid codes\n    def count_valid_codes(matrix, unknown_count, m, n):\n        def valid_code(matrix):\n            for row in matrix:\n                if len(set(row)) != len(row):\n                    return False\n            for i in range(1, m):\n                for j in range(1, n):\n                    u = matrix[i-1][j]\n                    l = matrix[i][j-1]\n                    r = matrix[i][j]\n                    if l*r != u and r*l != u and u-l != r and u-r != l:\n                        return False\n            return True\n\n        def helper(matrix, m, n, count):\n            if count == unknown_count:\n                if valid_code(matrix):\n                    return 1\n                else:\n                    return 0\n            ans = 0\n            for i in range(m):\n                for j in range(n):\n                    if matrix[i][j] == 0:\n                        for k in range(1, 10):\n                            if k != matrix[i][j-1] and k != matrix[i-1][j]:\n                                matrix[i][j] = k\n                                ans += helper(matrix, m, n, count+1)\n                                matrix[i][j] = 0\n            return ans\n\n        return helper(matrix, m, n, 0)\n\n    ans = count_valid_codes(matrix, unknown_count, m, n)\n    return str(ans)"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(code, row, col):\n        if row == 0:\n            return True\n        if code[row][col] == 0:\n            return False\n        if code[row][col] == code[row - 1][col]:\n            return False\n        if col > 0:\n            if code[row][col] == code[row][col - 1]:\n                return False\n        return True\n\n    def generate_codes(code, row, col, current_code):\n        if row == m:\n            if col == n:\n                complete_codes.append(current_code)\n                return\n            generate_codes(code, row, col + 1, current_code)\n            return\n        for i in range(n):\n            if is_valid(code, row, i):\n                generate_codes(code, row + 1, 0, current_code + str(code[row][i]))\n\n    m, n = map(int, stdin.split()[:2])\n    code = [list(map(int, line.split())) for line in stdin.split('\\n')[1:] if len(line.split()) == n]\n    complete_codes = []\n\n    generate_codes(code, 0, 0, '')\n    return len(complete_codes)\n"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(matrix: list, nums: set) -> bool:\n        rows, cols = len(matrix), len(matrix[0])\n        for i in range(rows):\n            row = set(matrix[i])\n            if len(row) != cols:\n                return False\n            for j in range(cols - 1):\n                if matrix[i][j] == matrix[i][j + 1]:\n                    return False\n        for j in range(cols):\n            col = set()\n            for i in range(rows - 1):\n                if matrix[i][j] in col:\n                    return False\n                col.add(matrix[i][j])\n            if matrix[rows - 1][j] in col:\n                return False\n        for i in range(rows - 1):\n            for j in range(cols - 1):\n                if (matrix[i][j], matrix[i][j + 1]) in nums or (matrix[i][j + 1], matrix[i][j]) in nums:\n                    nums.add((matrix[i][j], matrix[i][j + 1]))\n                    nums.add((matrix[i][j + 1], matrix[i][j]))\n                else:\n                    return False\n        return True\n\n    def get_combinations(matrix: list, nums: set) -> int:\n        rows, cols = len(matrix), len(matrix[0])\n        total = 0\n        for i in range(rows):\n            for j in range(cols):\n                if matrix[i][j] == 0:\n                    for l in range(1, 10):\n                        matrix[i][j] = l\n                        if is_valid(matrix, nums):\n                            total += 1\n                        matrix[i][j] = 0\n        return total\n\n    m, n = map(int, stdin.split())\n    matrix = [list(map(int, input().split())) for _ in range(m)]\n    nums = set()\n    for i in range(m - 1):\n        for j in range(n - 1):\n            if (matrix[i][j], matrix[i + 1][j]) in nums or (matrix[i][j + 1], matrix[i][j]) in nums:\n                nums.add((matrix[i][j], matrix[i + 1][j]))\n                nums.add((matrix[i + 1][j], matrix[i][j]))\n            else:\n                nums.add((matrix[i][j], matrix[i + 1][j]))\n                nums.add((matrix[i + 1][j], matrix[i][j]))\n    return get_combinations(matrix, nums)\n"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0].split())\n    code = stdin.split('\\n')[1:]\n    code = [[int(x) for x in line.split()] for line in code]\n    unknown = []\n    for i in range(m):\n        for j in range(n):\n            if code[i][j] == 0:\n                unknown.append((i, j))\n\n    def is_valid(code):\n        rows = [set() for _ in range(m)]\n        cols = [set() for _ in range(n)]\n        for i in range(m):\n            for j in range(n):\n                if code[i][j] != 0:\n                    rows[i].add(code[i][j])\n                    cols[j].add(code[i][j])\n        for i in range(m):\n            for j in range(n-1):\n                if code[i][j] != 0 and code[i][j] in rows[i] and code[i][j] in cols[j+1]:\n                    return False\n        return True\n\n    def count_codes():\n        count = 0\n        for i in range(m):\n            for j in range(n):\n                if code[i][j] == 0:\n                    for x in range(1, 10):\n                        if x not in rows[i] and x not in cols[j]:\n                            code[i][j] = x\n                            if is_valid(code):\n                                count += 1\n                            code[i][j] = 0\n        return count\n\n    count = 0\n    for u in unknown:\n        for x in range(1, 10):\n            code[u[0]][u[1]] = x\n            if is_valid(code):\n                count += count_codes()\n            code[u[0]][u[1]] = 0\n    return str(count)\n"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    m, n, partial_code = input().split()\n    m, n = int(m), int(n)\n    unknown_count = 0\n    for i in range(m):\n        for j in range(n):\n            if partial_code[i][j] == '0':\n                unknown_count += 1\n    num_combos = 0\n    for i in range(1, 10):\n        for j in range(i, 10):\n            if i * j in [partial_code[0][n-1], partial_code[m-1][0]]:\n                num_combos += 1\n    num_combos *= 9**unknown_count\n    return str(num_combos)\n"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0].split(','))\n    grid = [list(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    \n    def is_valid(code):\n        seen = set()\n        for row in code:\n            if len(set(row)) != len(row):\n                return False\n            seen.update(row)\n        return len(seen) == m * n\n    \n    count = 0\n    for i in range(10):\n        for j in range(10):\n            for k in range(10):\n                for l in range(10):\n                    for m in range(10):\n                        for n in range(10):\n                            for o in range(10):\n                                code = [\n                                    [i, j, k],\n                                    [l, 0, m],\n                                    [n, o, 0]\n                                ]\n                                if is_valid(code) and all(x != 0 for row in code for x in row):\n                                    count += 1\n    return str(count)"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    m, n, partial_code = read_input(stdin)\n\n    # Generate all possible complete codes based on the given rules\n    complete_codes = generate_complete_codes(m, n, partial_code)\n\n    # Count the number of complete codes\n    count = len(complete_codes)\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(code: list, row: int, col: int, l: int) -> bool:\n        if code[row][col] != 0:\n            return True\n\n        if row == 0:\n            return False\n\n        u = code[row - 1][col]\n        if col == n - 1:\n            return False\n        r = code[row][col + 1]\n        return any([u * l == r, u + l == r, u - l == r, u / l == r, u - l == r, r - l == u])\n\n    m, n, code = 0, 0, []\n    for line in stdin.split(\"\\n\"):\n        if m == 0:\n            m, n = map(int, line.split())\n            code = [[0] * n for _ in range(m)]\n        else:\n            row = line.split()\n            for j, val in enumerate(row):\n                code[m - 1 - i][j] = int(val)\n\n    valid_codes = 0\n    for i in range(m):\n        for j in range(n):\n            if code[i][j] != 0:\n                valid_codes += 1\n                for l in range(1, 10):\n                    if code[i][j] != l and is_valid(code, i, j, l):\n                        valid_codes += 1\n\n    return str(valid_codes)"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    m, n = map(int, input_data[0].split())\n    code = [list(map(int, input_data[i + 1].split())) for i in range(m)]\n\n    def is_valid(row):\n        return len(set(row)) == len(row)\n\n    def is_valid_code(code):\n        for i in range(m):\n            if not is_valid(code[i]):\n                return False\n        return True\n\n    def is_valid_guard(code):\n        for i in range(1, m):\n            for j in range(1, n - 1):\n                u = code[i - 1][j]\n                l = code[i][j - 1]\n                r = code[i][j]\n                if u * l != r and u + l != r and u - l != r and u - l != r and u * l != r and u - l != r and u + l != r:\n                    return False\n        return True\n\n    def generate_complete_codes(code, num_unknowns):\n        if num_unknowns == 0:\n            return 1 if is_valid_guard(code) else 0\n\n        complete_codes = 0\n        for i in range(m):\n            for j in range(n):\n                if code[i][j] == 0:\n                    for digit in range(1, 10):\n                        code[i][j] = digit\n                        complete_codes += generate_complete_codes(code, num_unknowns - 1)\n                        code[i][j] = 0\n        return complete_codes\n\n    num_unknowns = sum(map(lambda row: row.count(0), code))\n    return str(generate_complete_codes(code, num_unknowns))\n"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_sum(dials: str, a: int, b: int) -> int:\n        return sum(int(dials[i]) for i in range(a - 1, b))\n\n    N, M = map(int, stdin.split()[0:2])\n    dials = stdin.split()[2]\n    output = []\n\n    for _ in range(M):\n        a, b = map(int, stdin.split()[3:5])\n        output.append(get_sum(dials, a, b))\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    initial_configuration = input()\n    dials = [int(dial) for dial in initial_configuration]\n    sums = []\n\n    for _ in range(M):\n        A, B = map(int, input().split())\n        sum_dials = sum(dials[A-1:B])\n        sums.append(sum_dials)\n        for i in range(A-1, B):\n            dials[i] += 1\n            if dials[i] == 10:\n                dials[i] = 0\n\n    return \"\\n\".join(map(str, sums))\n"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.splitlines()[0].split())\n    initial_config = stdin.splitlines()[1]\n    sums = []\n    for line in stdin.splitlines()[2:]:\n        A, B = map(int, line.split())\n        dial_sum = 0\n        for i in range(A, B+1):\n            dial_sum += int(initial_config[i-1])\n        sums.append(dial_sum)\n    return '\\n'.join(map(str, sums))\n\n\ndef"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    starting_config = input_list[1]\n    total_sums = []\n\n    for i in range(2, len(input_list)):\n        A, B = map(int, input_list[i].split())\n        current_sum = 0\n        for j in range(A, B + 1):\n            current_sum += int(starting_config[j - 1])\n        total_sums.append(current_sum)\n\n    output = \"\\n\".join(map(str, total_sums))\n    return output"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split())\n    dials = stdin.split()[1]\n    for i in range(N):\n        if dials[i] == '9':\n            dials = dials[:i] + '0' + dials[i+1:]\n    sums = [0] * N\n    for _ in range(M):\n        A, B = map(int, stdin.split()[2:4])\n        for i in range(A, B+1):\n            sums[i-1] += int(dials[i-1])\n        for i in range(A, B+1):\n            dials = dials[:i] + str((int(dials[i-1])+1)%10) + dials[i+1:]\n    return '\\n'.join(map(str, sums))\n\n\ninput_str = '''4 3\n1234\n1 4\n1 4\n1 4'''\n\nprint(solution(input_str))"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.splitlines()[0].split())\n    dials = list(stdin.splitlines()[1])\n\n    for i in range(N):\n        dials[i] = int(dials[i])\n\n    for i in range(M):\n        A, B = map(int, stdin.splitlines()[i+2].split())\n        total = sum(dials[A-1:B])\n        print(total)\n"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split(','))\n    dial_config = stdin.split()[1].split(',')\n    dial_values = {i: int(dial_config[i]) for i in range(N)}\n    sums = [0] * M\n\n    for i in range(M):\n        A, B = map(int, stdin.split()[2 + i].split(','))\n        sum_ab = sum(dial_values[i] for i in range(A, B + 1))\n        sums[i] = sum_ab\n\n        # Increment the values on the dials between A and B\n        for j in range(A, B + 1):\n            dial_values[j] += 1\n            if dial_values[j] == 10:\n                dial_values[j] = 0\n\n    return '\\n'.join(map(str, sums))\n"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    dials = input()\n    result = []\n\n    for _ in range(M):\n        A, B = map(int, input().split())\n        dials_sum = sum(int(dials[dial - 1]) for dial in range(A, B + 1))\n        result.append(dials_sum)\n        for dial in range(A, B + 1):\n            new_value = (int(dials[dial - 1]) + 1) % 10\n            dials = dials[:dial - 1] + str(new_value) + dials[dial:]\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def int_from_string(s: str, index: int) -> int:\n        return int(s[index]) + 10 * int(s[index + 1])\n\n    def int_to_string(n: int) -> str:\n        return str(n // 10) + str(n % 10)\n\n    def press_button(dials: list[int], start: int, end: int) -> None:\n        for i in range(start, end + 1):\n            dials[i] += 1\n            if dials[i] == 10:\n                dials[i] = 0\n\n    lines = stdin.splitlines()\n    N, M = map(int, lines[0].split())\n    dials = [int_from_string(lines[1], i) for i in range(0, N * 2, 2)]\n    sums = []\n\n    for _ in range(M):\n        A, B = map(int, lines[1 + _].split())\n        press_button(dials, A - 1, B - 1)\n        sums.append(sum(dials[A - 1:B]))\n\n    return '\\n'.join(map(str, sums))"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split(','))\n    dials = stdin.split()[1]\n    dials = [int(dial) for dial in dials]\n    dial_sums = []\n\n    for _ in range(M):\n        A, B = map(int, input().split())\n        total_sum = 0\n\n        for dial in range(A, B + 1):\n            total_sum += dials[dial - 1]\n            dials[dial - 1] += 1\n\n        dial_sums.append(total_sum)\n\n    return '\\n'.join(map(str, dial_sums))\n\n\ndef"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, input().split())\n    belts = [set() for _ in range(M)]\n    for _ in range(M):\n        a, b = map(int, input().split())\n        for belt_id, (c, d) in enumerate(belts):\n            if a == c and b == d:\n                belts[belt_id].add(a)\n                belts[belt_id].add(b)\n                break\n    max_producers = 0\n    for i in range(1, K + 1):\n        flag = True\n        for belt_id, junctions in enumerate(belts):\n            if i in junctions:\n                max_producers += 1\n                flag = False\n                break\n        if flag:\n            max_producers += 1\n    return str(max_producers)"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[3:]]\n\n    def find_delivery_routes(edges):\n        def build_graph(edges):\n            graph = [[] for _ in range(N + 1)]\n            for a, b in edges:\n                graph[a].append(b)\n                graph[b].append(a)\n            return graph\n\n        def dfs(graph, visited, node, route):\n            visited[node] = True\n            route.append(node)\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(graph, visited, neighbor, route)\n            return route\n\n        graph = build_graph(edges)\n        visited = [False] * (N + 1)\n        delivery_routes = []\n        for node in range(1, N + 1):\n            if not visited[node]:\n                route = dfs(graph, visited.copy(), node, [])\n                delivery_routes.append(route)\n\n        return delivery_routes\n\n    def find_product_routes(delivery_routes, producers):\n        product_routes = [[] for _ in range(K)]\n        for route in delivery_routes:\n            for i in range(K):\n                if producers[i] in route:\n                    product_routes[i].append(route)\n\n        return product_routes\n\n    delivery_routes = find_delivery_routes(edges)\n    producers = [i for i in range(1, K + 1)]\n    product_routes = find_product_routes(delivery_routes, producers)\n\n    def is_valid_route(product_routes, product_id):\n        for route in product_routes[product_id]:\n            if len(set(route)) == len(route):\n                return True\n        return False\n\n    max_producers = 0\n    for i in range(1, K + 1):\n        producers.remove(i)\n        if is_valid_route(product_routes, i - 1):\n            max_producers += 1\n        producers.append(i)\n\n    return max_producers"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line.strip()]\n    G = [[] for _ in range(N)]\n    for u, v in edges:\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n    \n    def dfs(u, visited, parent):\n        visited[u] = True\n        for v in G[u]:\n            if not visited[v] and v != parent:\n                dfs(v, visited, u)\n    \n    def count_roots(visited):\n        return sum(1 for i in range(N) if not visited[i] and not any(True for j in range(N) if j != i and G[i] == G[j]))\n    \n    visited = [False] * N\n    dfs(0, visited, -1)\n    return count_roots(visited)"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[3:]]\n    G = {i: set() for i in range(1, N+1)}\n    for u, v in edges:\n        G[u].add(v)\n    \n    # determine the delivery routes for each producer\n    delivery_routes = {i: [i] for i in range(1, K+1)}\n    for i in range(1, K+1):\n        for j in range(i+1, K+1):\n            route1 = delivery_routes[i] + delivery_routes[j]\n            route2 = delivery_routes[j] + delivery_routes[i]\n            if (route1 in [G[u] for u in range(1, N+1)]) or (route2 in [G[u] for u in range(1, N+1)]):\n                delivery_routes[i] = route1\n                delivery_routes[j] = route2\n            else:\n                delivery_routes[i] = route2\n                delivery_routes[j] = route1\n    \n    # count the number of producers that can be left running\n    max_left_runners = 0\n    for i in range(1, K+1):\n        for j in range(i+1, K+1):\n            delivery_route = delivery_routes[i] + delivery_routes[j]\n            if not any([set(delivery_route) & set(route) for route in G.values()]):\n                max_left_runners += 1\n                break\n        if max_left_runners == K:\n            break\n    \n    return str(max_left_runners)\n"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    adj_list = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def dfs(node, visited, parents, order, depth):\n        visited[node] = True\n        parents[node] = -1 if depth == 0 else parents[depth - 1]\n        order[node] = depth\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, parents, order, depth + 1)\n\n    visited = [False] * (N + 1)\n    parents = [-1] * (N + 1)\n    order = [0] * (N + 1)\n    dfs(1, visited, parents, order, 0)\n\n    def build_tree(node, parent):\n        tree = {node: []}\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                tree[node].append(build_tree(neighbor, node))\n        return tree\n\n    tree = build_tree(1, -1)\n\n    def dfs_tree(node, visited, depth):\n        visited[node] = True\n        for neighbor in tree[node]:\n            dfs_tree(neighbor, visited, depth + 1)\n\n    visited = [False] * (N + 1)\n    dfs_tree(1, visited, 0)\n\n    def count_leaves(node, depth):\n        count = 0\n        for neighbor in tree[node]:\n            count += count_leaves(neighbor, depth + 1)\n        return max(count, 1)\n\n    def count_products(node, parent, robot_count):\n        count = robot_count\n        for neighbor in adj_list[node]:\n            if neighbor != parent:\n                count += count_products(neighbor, node, min(robot_count, len(adj_list[node])))\n        return count\n\n    def find_best_robot_count():\n        left, right = 0, K\n        while left <= right:\n            mid = (left + right) // 2\n            if count_products(1, -1, mid) <= M:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return left - 1\n\n    best_robot_count = find_best_robot_count()\n    return best_robot_count"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    edges.sort(key=lambda x: x[1])\n    if K == N:\n        return K\n    active_producers = 0\n    conveyor_belts = [[] for _ in range(N)]\n    for producer in range(1, N + 1):\n        for x in range(K):\n            if x * K + producer <= K * N:\n                conveyor_belts[x].append((x * K + producer, producer, x))\n    for i in range(N):\n        conveyor_belts[i].sort(key=lambda x: x[0])\n        for j in range(len(conveyor_belts[i]) - 1):\n            if conveyor_belts[i][j][1] != conveyor_belts[i][j + 1][1]:\n                active_producers += 1\n                break\n    return active_producers\n\ndef"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    robots = [0] * K\n    producers = [i for i in range(1, K+1)]\n\n    def dfs(i):\n        if robots[i-1] == 0:\n            robots[i-1] = 1\n            for a, b in edges:\n                if i == a:\n                    dfs(b)\n\n    def is_feasible():\n        for i in range(K):\n            dfs(i+1)\n            for j in range(N):\n                count = 0\n                for a, b in edges:\n                    if j+1 == a:\n                        if robots[i] == b:\n                            count += 1\n                if count > 1:\n                    return False\n            dfs(i+1)\n        return True\n\n    max_producers = 0\n    while producers and is_feasible():\n        max_producers += 1\n        producers.pop()\n\n    return str(max_producers)"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split()[3:]]\n    conveyors = set()\n    for a, b in edges:\n        conveyors.add(tuple(sorted((a, b))))\n    result = K\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            conveyors.add(tuple(sorted((i, j))))\n    for c in conveyors:\n        result += (N - len(c)) // 2\n    return result\n\ndef"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_solution(N, K, M, conveyor_belts):\n        for i in range(1, N + 1):\n            incoming_products = [j for j, b in conveyor_belts if i in b]\n            if len(incoming_products) > 1:\n                return False\n        return True\n\n    def count_producers(N, K, M, conveyor_belts):\n        def count_producer_routes(j, visited, routes):\n            if j in visited:\n                return\n            visited.add(j)\n            for i, b in conveyor_belts:\n                if b[0] == j and i in routes[0]:\n                    count_producer_routes(i, visited, routes)\n            routes.insert(0, {j})\n\n        producers = {j for j in range(1, N + 1) if j <= K}\n        routes = [set() for _ in range(K)]\n        for j in producers:\n            count_producer_routes(j, set(), routes)\n\n        return [len(routes[i - 1]) for i in range(1, K + 1) if i in producers]\n\n    N, K, M = map(int, stdin.split()[:3])\n    conveyor_belts = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M + 1]]\n\n    if is_valid_solution(N, K, M, conveyor_belts):\n        return max(count_producers(N, K, M, conveyor_belts))\n    else:\n        return 0"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    \n    # Create a graph of the conveyor belts\n    graph = [[] for _ in range(N+1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n    \n    # Find the longest path in the graph\n    visited = [False] * (N+1)\n    longest_path = 0\n    def dfs(node, length):\n        nonlocal longest_path\n        if visited[node]:\n            return\n        visited[node] = True\n        if length > longest_path:\n            longest_path = length\n        for neighbor in graph[node]:\n            dfs(neighbor, length+1)\n    \n    dfs(1, 1)\n    \n    # Calculate the maximum number of producers\n    max_producers = min(longest_path - 1, K)\n    \n    return str(max_producers)"
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_triangle(x1, y1, x2, y2, x3, y3):\n        return (x1 - x2) * (y3 - y2) - (x3 - x2) * (y1 - y2) > 0\n\n    n, m = map(int, stdin.readline().split())\n\n    garry_triangles = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    garry_triangles.sort(key=lambda x: (x[0], x[1]))\n\n    garry_triangles_set = set()\n    for i in range(n):\n        x1, y1, x2, y2, x3, y3 = garry_triangles[i]\n        for j in range(i + 1, n):\n            x4, y4, x5, y5, x6, y6 = garry_triangles[j]\n            if x1 == x2 == x3 == x4 == x5 == x6 and y1 == y2 == y3 == y4 == y5 == y6:\n                continue\n            if is_triangle(x1, y1, x2, y2, x3, y3) and is_triangle(x4, y4, x5, y5, x6, y6):\n                garry_triangles_set.add(tuple(sorted([(x1, y1), (x2, y2), (x3, y3)])))\n            if is_triangle(x1, y1, x3, y3, x6, y6) and is_triangle(x4, y4, x5, y5, x2, y2):\n                garry_triangles_set.add(tuple(sorted([(x1, y1), (x3, y3), (x6, y6)])))\n            if is_triangle(x1, y1, x2, y2, x5, y5) and is_triangle(x4, y4, x6, y6, x3, y3):\n                garry_triangles_set.add(tuple(sorted([(x1, y1), (x2, y2), (x5, y5)])))\n            if is_triangle(x1, y1, x3, y3, x5, y5) and is_triangle(x4, y4, x2, y2, x6, y6):\n                garry_triangles_set.add(tuple(sorted([(x1, y1), (x3, y3), (x5, y5)])))\n            if is_triangle(x1, y1, x2, y2, x4, y4) and is_triangle(x3, y3, x5, y5, x6, y6):\n                garry_triangles_set.add(tuple(sorted([(x1, y1), (x2, y2), (x4, y4)])))\n            if is_triangle(x1, y1, x3, y3, x5, y5) and is_triangle(x2, y2, x4, y4, x6, y6):\n                garry_triangles_set.add(tuple(sorted([(x1, y1), (x3, y3), (x5, y5)])))\n\n    garry_triangles_set = frozenset(garry_triangles_set)\n\n    for j in range(m):\n        x1, y1, x2, y2, x3, y3 = garry_triangles[j]\n        for k in range(j + 1, m):\n            x4, y4, x5, y5, x6, y6 = garry_triangles[k]\n            if x1 == x2 == x3 == x4 == x5 == x6 and y1 == y2 == y3 == y4 == y5 == y6:\n                continue\n            if is_triangle(x1, y1, x2, y2, x3, y3) and is_triangle(x4, y4, x5, y5, x6, y6):\n                if (x1, y1, x2, y2, x3, y3) in garry_triangles_set:\n                    garry_triangles_set.add("
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    garry_triangles = []\n    for i in range(1, n+1):\n        x1, y1, x2, y2, x3, y3 = map(int, input_list[i].split())\n        garry_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    m = int(input_list[n+1])\n    jerry_triangles = []\n    for i in range(n+2, n+m+2):\n        x1, y1, x2, y2, x3, y3 = map(int, input_list[i].split())\n        jerry_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    for garry_triangle in garry_triangles:\n        for jerry_triangle in jerry_triangles:\n            # check if the areas are equal or not\n            if abs(garry_triangle[0] * (garry_triangle[1] - jerry_triangle[1]) +\n                   garry_triangle[2] * (jerry_triangle[1] - jerry_triangle[4]) +\n                   jerry_triangle[2] * (jerry_triangle[4] - garry_triangle[4])) == 0:\n                # check if the points are in the same order\n                if (jerry_triangle[0], jerry_triangle[1], jerry_triangle[2]) == (garry_triangle[0], garry_triangle[1], garry_triangle[2]):\n                    print(\"yes\")\n                    return\n\n    print(\"no\")\n"
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    n = int(input_lines[0])\n    garry_triangles = []\n    for i in range(1, n+1):\n        x1, y1, x2, y2, x3, y3 = map(int, input_lines[i].split())\n        garry_triangles.append((x1, y1, x2, y2, x3, y3))\n    \n    m = int(input_lines[n+1])\n    jerry_triangles = []\n    for i in range(n+2, n+2+m):\n        x1, y1, x2, y2, x3, y3 = map(int, input_lines[i].split())\n        jerry_triangles.append((x1, y1, x2, y2, x3, y3))\n    \n    garry_triangles.sort()\n    jerry_triangles.sort()\n    \n    if len(garry_triangles) != len(jerry_triangles):\n        return \"no\"\n    \n    for i in range(len(garry_triangles)):\n        x1_g, y1_g, x2_g, y2_g, x3_g, y3_g = garry_triangles[i]\n        x1_j, y1_j, x2_j, y2_j, x3_j, y3_j = jerry_triangles[i]\n        \n        if (x1_g, y1_g, x2_g, y2_g, x3_g, y3_g) != (x1_j, y1_j, x2_j, y2_j, x3_j, y3_j):\n            return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def point_cmp(a, b):\n        if a[0] < b[0]:\n            return -1\n        elif a[0] > b[0]:\n            return 1\n        else:\n            if a[1] < b[1]:\n                return -1\n            elif a[1] > b[1]:\n                return 1\n            else:\n                return 0\n\n    n, m = map(int, stdin.split(\"\\n\")[0].split())\n    garry_triangles = []\n    for i in range(1, n + 1):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.split(\"\\n\")[i].split())\n        garry_triangles.append([(x1, y1), (x2, y2), (x3, y3)])\n\n    jerry_triangles = []\n    for i in range(n + 1, n + 1 + m):\n        x1, y1, x2, y2, x3, y3 = map(int, stdin.split(\"\\n\")[i].split())\n        jerry_triangles.append([(x1, y1), (x2, y2), (x3, y3)])\n\n    garry_triangles.sort(key=lambda t: (t[0][0], t[0][1], t[1][0], t[1][1], t[2][0], t[2][1]))\n    jerry_triangles.sort(key=lambda t: (t[0][0], t[0][1], t[1][0], t[1][1], t[2][0], t[2][1]))\n\n    for i in range(len(jerry_triangles)):\n        for j in range(len(garry_triangles)):\n            if len(jerry_triangles[i]) != 3 or len(garry_triangles[j]) != 3:\n                continue\n\n            if point_cmp(jerry_triangles[i][0], garry_triangles[j][0]) == 0 and point_cmp(jerry_triangles[i][1], garry_triangles[j][1]) == 0 and point_cmp(jerry_triangles[i][2], garry_triangles[j][2]) == 0:\n                if point_cmp(jerry_triangles[i][0], jerry_triangles[i][1]) != 0 and point_cmp(jerry_triangles[i][1], jerry_triangles[i][2]) != 0 and point_cmp(jerry_triangles[i][2], jerry_triangles[i][0]) != 0:\n                    return \"yes\"\n                else:\n                    return \"no\"\n\n    return \"no\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    garry_triangles = []\n    for i in range(1, n+1):\n        garry_triangles.append(tuple(map(int, input_list[i].split())))\n\n    m = int(input_list[n+1])\n    jerry_triangles = []\n    for i in range(n+2, n+m+2):\n        jerry_triangles.append(tuple(map(int, input_list[i].split())))\n\n    # Check if Garry and Jerry saw the same cloud cover\n    garry_triangles_set = set(garry_triangles)\n    jerry_triangles_set = set(jerry_triangles)\n\n    if garry_triangles_set == jerry_triangles_set:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def triangle_area(x1, y1, x2, y2, x3, y3):\n        return abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2))/2)\n\n    n, m = map(int, input().split())\n    garry_triangles = []\n    for _ in range(n):\n        x1, y1, x2, y2, x3, y3 = map(int, input().split())\n        garry_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    jerry_triangles = []\n    for _ in range(m):\n        x1, y1, x2, y2, x3, y3 = map(int, input().split())\n        jerry_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    for garry_triangle in garry_triangles:\n        garry_area = triangle_area(*garry_triangle)\n        found = False\n        for jerry_triangle in jerry_triangles:\n            jerry_area = triangle_area(*jerry_triangle)\n            if jerry_area == 0:  # degenerate triangle\n                continue\n            intersection_area = triangle_area(*garry_triangle, *jerry_triangle)\n            if intersection_area == 0:  # non-intersecting triangles\n                found = True\n                break\n        if not found:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    g_triangles = []\n    for _ in range(n):\n        x1, y1, x2, y2, x3, y3 = map(int, input().split())\n        g_triangles.append((x1, y1, x2, y2, x3, y3))\n    j_triangles = []\n    for _ in range(m):\n        x1, y1, x2, y2, x3, y3 = map(int, input().split())\n        j_triangles.append((x1, y1, x2, y2, x3, y3))\n\n    def area_of_triangle(p1, p2, p3):\n        return abs((p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) // 2)\n\n    def is_triangle(p1, p2, p3):\n        return area_of_triangle(p1, p2, p3) > 0\n\n    def is_degenerate_triangle(p1, p2, p3):\n        return area_of_triangle(p1, p2, p3) == 0\n\n    def is_intersecting(p1, p2, p3, p4):\n        return is_triangle(p1, p2, p3) and is_triangle(p1, p2, p4)\n\n    g_set = set()\n    for g_triangle in g_triangles:\n        p1, p2, p3 = g_triangle\n        if (p1, p2, p3) in g_set:\n            g_set.remove((p1, p2, p3))\n        else:\n            g_set.add((p1, p2, p3))\n\n    j_set = set()\n    for j_triangle in j_triangles:\n        p1, p2, p3 = j_triangle\n        if (p1, p2, p3) in j_set:\n            j_set.remove((p1, p2, p3))\n        else:\n            j_set.add((p1, p2, p3))\n\n    return \"yes\" if g_set == j_set else \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    garry_triangles = [tuple(map(int, input_lines[i+1].split())) for i in range(1, n+1)]\n    m = int(input_lines[n+1])\n    jerry_triangles = [tuple(map(int, input_lines[n+2+i].split())) for i in range(m)]\n\n    def is_inside(point, triangle):\n        a, b, c = triangle\n        return (a[0] * b[1] - a[1] * b[0]) * (point[0] - a[0]) + (a[1] * c[0] - a[0] * c[1]) * (point[1] - a[1]) + (b[0] * c[1] - b[1] * c[0]) * (a[0] - b[0]) - (b[0] * c[1] - b[1] * c[0]) * (a[1] - b[1]) == 0\n\n    def is_non_degenerate(triangle):\n        a, b, c = triangle\n        return (a[0] * b[1] - a[1] * b[0]) * (a[0] * c[1] - a[1] * c[0]) > 0\n\n    def intersects(triangle1, triangle2):\n        a, b, c = triangle1\n        d, e, f = triangle2\n        return (((a[0] * b[1] - a[1] * b[0]) * (e[0] - f[0]) + (a[1] * c[0] - a[0] * c[1]) * (b[1] - e[1]) + (b[0] * c[1] - b[1] * c[0]) * (a[0] - e[0]) - (b[0] * c[1] - b[1] * c[0]) * (a[1] - e[1])) * ((a[0] * b[1] - a[1] * b[0]) * (d[0] - f[0]) + (a[1] * c[0] - a[0] * c[1]) * (b[0] - d[0]) + (b[0] * c[1] - b[1] * c[0]) * (a[0] - d[0]) - (b[0] * c[1] - b[1] * c[0]) * (a[1] - d[1])) >= 0) and ((a[0] * b[1] - a[1] * b[0]) * (d[0] - f[0]) + (a[1] * c[0] - a[0] * c[1]) * (b[1] - d[1]) + (b[0] * c[1] - b[1] * c[0]) * (a[0] - d[0]) - (b[0] * c[1] - b[1] * c[0]) * (a[1] - d[1])) * ((a[0] * b[1] - a[1] * b[0]) * (e[0] - f[0]) + (a[1] * c[0] - a[0] * c[1]) * (b[1] - e[1]) + (b[0] * c[1] - b[1] * c[0]) * (a[0] - e[0]) - (b[0] * c[1] - b[1] * c[0]) * (a[1] - e[1])) <= 0)\n\n    garry_triangles = set(garry_triangles)\n    for triangle in jerry_triangles:\n        if triangle in garry_triangles:\n            garry_triangles.remove(triangle)\n        else:\n            for triangle1 in garry_triangles:\n                if intersects(triangle, triangle1):\n                    garry_triangles.remove(triangle1)\n                    break\n    return \"yes\" if len(garry_triangles) == 0 else \"no\""
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_degenerate(triangle):\n        area = abs((triangle[2][0] - triangle[0][0]) * (triangle[2][1] - triangle[0][1]) - (triangle[1][0] - triangle[0][0]) * (triangle[1][1] - triangle[0][1]))\n        return area == 0\n\n    def is_intersecting(triangle1, triangle2):\n        def orientation(p, q, r):\n            val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n            if val == 0:\n                return 0\n            return 1 if val > 0 else -1\n\n        o1 = orientation(triangle1[0], triangle1[1], triangle1[2])\n        o2 = orientation(triangle2[0], triangle2[1], triangle2[2])\n        o3 = orientation(triangle2[0], triangle2[1], triangle1[0])\n        o4 = orientation(triangle2[0], triangle2[1], triangle1[1])\n        o5 = orientation(triangle2[0], triangle2[1], triangle1[2])\n\n        if o1 != o2 and o3 != o4 and o5 != o1 and o5 != o2 and o5 != o4:\n            return True\n        return False\n\n    n, m = map(int, stdin.split('\\n')[0].split())\n    triangles_garry = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n + 1]]\n    triangles_jerry = [tuple(map(int, line.split())) for line in stdin.split('\\n')[n + 1:-1]]\n\n    for triangle_garry in triangles_garry:\n        if is_degenerate(triangle_garry):\n            return \"no\"\n\n    for triangle_jerry in triangles_jerry:\n        if is_degenerate(triangle_jerry):\n            return \"no\"\n\n    for triangle_garry in triangles_garry:\n        for triangle_jerry in triangles_jerry:\n            if is_intersecting(triangle_garry, triangle_jerry):\n                return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    garry_triangles = [tuple(map(int, input_list[i+1].split())) for i in range(1, n+1)]\n    m = int(input_list[n+1])\n    jerry_triangles = [tuple(map(int, input_list[i+2].split())) for i in range(n+2, n+2+m)]\n\n    def is_inside(a, b, c):\n        return a[0] >= b[0] and a[0] <= c[0] and a[1] >= b[1] and a[1] <= c[1]\n\n    def is_intersect(a, b, c, d):\n        return (is_inside(a, b, c) or is_inside(b, a, c) or is_inside(c, a, b)) and (is_inside(a, b, d) or is_inside(b, a, d) or is_inside(d, a, b))\n\n    def area(a, b, c):\n        return abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) // 2)\n\n    def triangle(a, b, c):\n        return area(a, b, c) > 0\n\n    def is_same_cloud_cover(garry_triangles, jerry_triangles):\n        for g_triangle in garry_triangles:\n            is_found = False\n            for j_triangle in jerry_triangles:\n                if is_intersect(g_triangle, j_triangle[0], j_triangle[1], j_triangle[2]) and triangle(g_triangle, j_triangle[0], j_triangle[1]) and triangle(g_triangle, j_triangle[1], j_triangle[2]) and triangle(g_triangle, j_triangle[2], j_triangle[0]):\n                    is_found = True\n                    break\n            if not is_found:\n                return False\n        return True\n\n    if is_same_cloud_cover(garry_triangles, jerry_triangles):\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_pair(cities, target):\n        for i in range(len(cities)):\n            if cities[i] == target:\n                return i\n        return -1\n\n    def is_possible(graph, roads):\n        start = 1\n        end = 2\n        while end <= len(roads):\n            start = roads[start - 1]\n            end = roads[end - 1]\n            if start == end:\n                return False\n            if end not in graph[start]:\n                return False\n        return True\n\n    N, M = map(int, stdin.splitlines()[0].split())\n    roads = list(map(lambda x: tuple(map(int, x.split())), stdin.splitlines()[1:]))\n    cities = list(range(1, N + 1))\n    graph = [[] for _ in range(N + 1)]\n\n    for start, end in roads:\n        graph[start].append(end)\n        graph[end].append(start)\n\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            if i < j:\n                pair_i = find_pair(cities, i)\n                pair_j = find_pair(cities, j)\n                if pair_i > pair_j:\n                    cities[pair_i - 1], cities[pair_j - 1] = cities[pair_j - 1], cities[pair_i - 1]\n                else:\n                    cities[pair_j - 1], cities[pair_i - 1] = cities[pair_i - 1], cities[pair_j - 1]\n\n    roads_sorted = sorted(roads)\n    result = \"YES\\n\" if is_possible(graph, roads_sorted) else \"NO\"\n    for road in roads_sorted:\n        result += f\"{cities.index(road[0]) + 1} {cities.index(road[1]) + 1}\\n\"\n    return result"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def is_possible(adj_list: defaultdict) -> bool:\n        visited = set()\n        for node in adj_list:\n            if node not in visited:\n                visited.add(node)\n                if not dfs(node, adj_list, visited):\n                    return False\n        return True\n\n    def dfs(node: int, adj_list: defaultdict, visited: set) -> bool:\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                return dfs(neighbor, adj_list, visited)\n        return True\n\n    N, M = map(int, stdin.split()[0:2])\n    adj_list = defaultdict(set)\n    for _ in range(M):\n        x, y = map(int, stdin.split()[0:2])\n        adj_list[x].add(y)\n        adj_list[y].add(x)\n\n    if is_possible(adj_list):\n        return \"YES\\n\" + \"\\n\".join([f\"{x} {y}\" for x, y in adj_list.items()])\n    else:\n        return \"NO\""
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph: dict, visited: set, start: int, path: list, cycle: list):\n        visited.add(start)\n        path.append(start)\n        for next_node in graph[start]:\n            if next_node not in visited:\n                if dfs(graph, visited, next_node, path, cycle):\n                    return True\n                for i, node in enumerate(path):\n                    if node == next_node:\n                        cycle.append(path[i+1:])\n                        break\n            elif next_node != path[-1]:\n                cycle.append([start, next_node])\n                return True\n        path.pop()\n        return False\n\n    N, M = map(int, stdin.split()[:2])\n    graph = {i: [] for i in range(1, N+1)}\n    for _ in range(M):\n        x, y = map(int, stdin.split()[:2])\n        graph[x].append(y)\n        graph[y].append(x)\n\n    visited = set()\n    cycle = []\n    for i in range(1, N+1):\n        if i not in visited:\n            path = []\n            if dfs(graph, visited, i, path, cycle):\n                return \"NO\\n\"\n\n    cycle = [cycle[0]] + sorted(cycle[1:], key=lambda x: x[0])\n    return \"YES\\n\" + \"\\n\".join(f\"{x} {y}\" for x, y in cycle)"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # check if it's possible to assign directions\n    adj_list = [[] for _ in range(N)]\n    for x, y in roads:\n        adj_list[x - 1].append(y - 1)\n        adj_list[y - 1].append(x - 1)\n\n    # BFS to see if all vertices are reachable\n    queue = [0]\n    visited = [False] * N\n    visited[0] = True\n    while queue:\n        x = queue.pop(0)\n        for y in adj_list[x]:\n            if not visited[y]:\n                visited[y] = True\n                queue.append(y)\n\n    if not all(visited):\n        return \"NO\\n\"\n\n    # assign directions to roads\n    directions = []\n    for x, y in roads:\n        if x not in adj_list[y]:\n            directions.append((x, y))\n        else:\n            directions.append((y, x))\n\n    return \"YES\\n\" + \"\\n\".join(map(lambda x: f\"{x[0]} {x[1]}\", directions))\n"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_list[1:]]\n    adjacency_list = [[] for _ in range(N + 1)]\n\n    for u, v in roads:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    def dfs(node, visited, order):\n        visited[node] = True\n        for neighbor in adjacency_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, order)\n        order.append(node)\n\n    def topological_sort():\n        visited = [False] * (N + 1)\n        order = []\n        for node in range(1, N + 1):\n            if not visited[node]:\n                dfs(node, visited, order)\n        return order\n\n    def is_possible(order):\n        for node in range(1, N + 1):\n            visited = [False] * (N + 1)\n            dfs(node, visited, [])\n            if all(visited):\n                return False\n        return True\n\n    order = topological_sort()\n    if is_possible(order):\n        return \"YES\\n\" + '\\n'.join(f\"{u} {v}\" for u, v in roads)\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, city):\n        visited[city] = True\n        for next_city in graph[city]:\n            if not visited[next_city]:\n                dfs(graph, visited, next_city)\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(N + 1)]\n    visited = [False] * (N + 1)\n    for _ in range(M):\n        x, y = map(int, stdin.split()[:2])\n        graph[x].append(y)\n        graph[y].append(x)\n\n    if N == 1:\n        return \"YES\\n1 1\"\n\n    for i in range(1, N + 1):\n        if not visited[i]:\n            dfs(graph, visited, i)\n\n    if not all(visited):\n        return \"NO\"\n\n    directions = []\n    for i in range(1, N + 1):\n        for j in graph[i]:\n            if i < j:\n                directions.append(f\"{i} {j}\")\n            elif j < i:\n                directions.append(f\"{j} {i}\")\n\n    return \"YES\\n\" + \"\\n\".join(directions)\n"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(N, M, roads):\n        graph = [[] for _ in range(N + 1)]\n        for road in roads:\n            graph[road[0]].append(road[1])\n            graph[road[1]].append(road[0])\n        visited = [False] * (N + 1)\n        def dfs(node):\n            if visited[node]:\n                return False\n            visited[node] = True\n            for neighbor in graph[node]:\n                if dfs(neighbor):\n                    return True\n            return False\n        for i in range(1, N + 1):\n            if not dfs(i):\n                return False\n        return True\n    \n    def find_direction(N, M, roads):\n        result = []\n        for i in range(M):\n            for j in range(i + 1, M):\n                if roads[i][0] == roads[j][1] and roads[i][1] == roads[j][0]:\n                    if roads[i][0] < roads[j][0]:\n                        result.append((roads[i][0], roads[j][0]))\n                    else:\n                        result.append((roads[j][0], roads[i][0]))\n                    break\n            if len(result) == M:\n                break\n        if len(result) == M:\n            return result\n        return None\n\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data.pop(0).split())\n    roads = [tuple(map(int, line.split())) for line in input_data]\n    possible = is_possible(N, M, roads)\n    if not possible:\n        return \"NO\\n\"\n    directions = find_direction(N, M, roads)\n    if directions is None:\n        return \"NO\\n\"\n    return \"YES\\n\" + \"\\n\".join(map(lambda x: f\"{x[0]} {x[1]}\", directions)) + \"\\n\" "
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    adjacency_list = [set() for _ in range(n + 1)]\n    for line in input_lines[1:]:\n        x, y = map(int, line.split())\n        adjacency_list[x].add(y)\n        adjacency_list[y].add(x)\n\n    def dfs(start: int, visited: set, path: list, result: list):\n        visited.add(start)\n        path.append(start)\n        for neighbor in adjacency_list[start]:\n            if neighbor not in visited:\n                dfs(neighbor, visited, path, result)\n        result.append(path)\n\n    paths = []\n    dfs(1, set(), [], paths)\n\n    def is_possible(paths: list) -> bool:\n        for path in paths:\n            for i in range(len(path) - 1):\n                if path[i] == path[i + 1]:\n                    return False\n        return True\n\n    if not is_possible(paths):\n        return \"NO\\n\"\n\n    for path in paths:\n        for i in range(len(path) - 1):\n            print(path[i], path[i + 1])\n    return \"YES\\n\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, adj, cnt):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                cnt = dfs(neighbor, visited, adj, cnt)\n        return cnt + 1\n\n    N, M = map(int, stdin.split()[:2])\n    adj = [[] for _ in range(N + 1)]\n    roads = []\n    for _ in range(M):\n        x, y = map(int, stdin.split()[:2])\n        adj[x].append(y)\n        adj[y].append(x)\n        roads.append((x, y))\n\n    visited = [False] * (N + 1)\n    count = dfs(1, visited, adj, 0)\n\n    if count != N:\n        return \"NO\"\n\n    for x, y in sorted(roads):\n        print(x, y)\n\n    return \"YES\"\n"
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    adj_list = [[] for _ in range(n+1)]\n    for i in range(1, m+1):\n        x, y = map(int, input_list[i].split())\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n    \n    def dfs(visited, node, dir):\n        visited.add(node)\n        for neighbor in adj_list[node]:\n            if neighbor not in visited:\n                if dir == 1:\n                    print(f\"{node} {neighbor}\")\n                else:\n                    print(f\"{neighbor} {node}\")\n                dfs(visited, neighbor, dir)\n    \n    for i in range(1, n+1):\n        if i not in adj_list[i]:\n            return \"NO\"\n    \n    visited = set()\n    dfs(visited, 1, 1)\n    \n    return \"YES\"\n\n\ndef"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    matches = []\n    for _ in range(M):\n        line = stdin.split()[2:]\n        K, symbol, L = map(int, line[0:3:2])\n        if symbol == '=':\n            matches.append((K, L))\n        else:\n            matches.append((K, L))\n            matches.append((L, K))\n\n    for i in range(N):\n        opponents = [j for j in range(N) if (i, j) in matches or (j, i) in matches]\n        if len(set(opponents)) < len(opponents):\n            return \"inconsistent\"\n\n    return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.splitlines()[0].split())\n    reported_matches = stdin.splitlines()[1:]\n\n    # Create a dictionary to store the reported results\n    results = {}\n    for match in reported_matches:\n        player1, relation, player2 = match.split()\n        player1, player2 = int(player1), int(player2)\n        results[(player1, player2)] = relation\n\n    # Check if the list is consistent\n    consistent = True\n    for (player1, player2), relation in results.items():\n        if (player2, player1) not in results:\n            if relation == '>':\n                consistent = False\n                break\n        else:\n            if relation == '>':\n                if results[(player2, player1)] == '>':\n                    consistent = False\n                    break\n    return \"consistent\" if consistent else \"inconsistent\"\n\ndef"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    reported_matches = [input().split() for _ in range(M)]\n\n    player_skills = [0] * N\n    for match in reported_matches:\n        player1, player2 = int(match[0]), int(match[2])\n        if match[1] == '>':\n            player_skills[player1] += 1\n            player_skills[player2] -= 1\n        elif match[1] == '=':\n            player_skills[player1] += 1\n            player_skills[player2] += 1\n\n    for skill in player_skills:\n        if skill < 0:\n            return \"inconsistent\"\n\n    return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    matches = stdin.split()[2:]\n\n    graph = [[] for _ in range(N)]\n    for match in matches:\n        k, symbol, l = map(int, match.split())\n        if symbol == '=':\n            graph[k].append(l)\n            graph[l].append(k)\n        else:\n            graph[k].append(l)\n\n    visited = [False] * N\n    def dfs(node: int) -> bool:\n        if visited[node]:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not dfs(neighbor):\n                return False\n        return True\n\n    return \"inconsistent\" if any(dfs(node) for node in range(N)) else \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    matches = []\n    for _ in range(M):\n        line = stdin.split()[2:]\n        K, symbol, L = map(int, line)\n        matches.append((K, symbol, L))\n    \n    def count_skill_level(player: int) -> int:\n        win, draw = 0, 0\n        for match in matches:\n            if match[0] == player:\n                if match[1] == '>':\n                    win += 1\n                elif match[1] == '=':\n                    draw += 1\n            elif match[2] == player:\n                if match[1] == '>':\n                    win += 1\n                elif match[1] == '=':\n                    draw += 1\n        return win + draw / 2\n    \n    skill_levels = [count_skill_level(i) for i in range(N)]\n    max_level, min_level = max(skill_levels), min(skill_levels)\n    if max_level == min_level:\n        return \"consistent\"\n    else:\n        for match in matches:\n            if (skill_levels[match[0]] < skill_levels[match[2]]) and (match[1] == '='):\n                return \"inconsistent\"\n            elif (skill_levels[match[0]] > skill_levels[match[2]]) and (match[1] == '>'):\n                return \"inconsistent\"\n        return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    matches = [line.strip().split() for line in stdin.split('\\n')[1:]]\n\n    players = [[0, 0] for _ in range(N)]\n    for match in matches:\n        player1, result, player2 = match\n        player1, player2 = int(player1), int(player2)\n        if result == '=':\n            players[player1][0] += 1\n            players[player2][0] += 1\n        elif result == '>':\n            players[player1][1] += 1\n            players[player2][1] += 1\n\n    for player in players:\n        if player[0] == 0:\n            return \"inconsistent\"\n        if player[1] == 0:\n            return \"inconsistent\"\n        if player[0] < player[1]:\n            return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    matches = [line.split() for line in stdin.split('\\n')[1:]]\n\n    # Create a graph to represent the players and their matches\n    graph = [[] for _ in range(N)]\n    for match in matches:\n        player1, result, player2 = int(match[0]), match[1], int(match[2])\n        graph[player1].append((player2, result))\n        graph[player2].append((player1, '>' if result == '>' else '='))\n\n    # Breadth-first search to check if there is a path from every player to every other player\n    visited = [False] * N\n    for player in range(N):\n        if not visited[player]:\n            queue = [(player, [])]\n            while queue:\n                current_player, path = queue.pop(0)\n                visited[current_player] = True\n                for neighbor, edge in graph[current_player]:\n                    if not visited[neighbor] and edge == '=':\n                        queue.append((neighbor, path + [edge]))\n                    elif visited[neighbor] and edge == '>':\n                        return \"inconsistent\"\n\n    return \"consistent\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    matches = []\n    for _ in range(M):\n        line = stdin.split()[2:]\n        matches.append([line[0], line[1]])\n    return \"inconsistent\" if not is_consistent(N, matches) else \"consistent\"\n\ndef"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    reported_matches = []\n    for i in range(M):\n        reported_matches.append(stdin.split()[2+i*3:2+(i+1)*3])\n    for match in reported_matches:\n        k, symbol, l = int(match[0]), match[1], int(match[2])\n        if symbol == '>':\n            if reported_matches.count(['>', k, l]) > 1 or reported_matches.count(['=', k, l]) > 1:\n                return \"inconsistent\"\n        elif symbol == '=':\n            if reported_matches.count(['>', k, l]) > 1 or reported_matches.count(['>', l, k]) > 1:\n                return \"inconsistent\"\n    return \"consistent\""
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    reported_matches = [line.strip().split() for line in stdin.split('\\n')[1:]]\n    players = [0] * N\n    for match in reported_matches:\n        K, symbol, L = map(int, match)\n        if symbol == '=':\n            players[K] += 1\n            players[L] += 1\n        else:\n            players[K] += 2\n    for player in players:\n        if player == 0:\n            return \"inconsistent\"\n    return \"consistent\"\n\ndef"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def cylinder_volume(r, h):\n        return 2 * 3.14 * r * r * h\n\n    n = int(stdin.splitlines()[0])\n    stars = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_distance = float('inf')\n    min_stars = None\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distance(stars[i], stars[j]) < min_distance:\n                min_distance = distance(stars[i], stars[j])\n                min_stars = (i, j)\n\n    if min_stars is None:\n        return \"No solution exists.\"\n\n    p1, p2 = stars[min_stars[0]], stars[min_stars[1]]\n    r = distance(p1, p2) / 2\n    h = max(distance(p1, (0, 0, 0)), distance(p2, (0, 0, 0)), distance(stars[i], stars[j]))\n\n    return cylinder_volume(r, h)"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    stars = []\n    for i in range(1, n+1):\n        x, y, z = map(int, input_data[i].split())\n        stars.append((x, y, z))\n\n    def volume(c):\n        x1, y1, z1 = c[0]\n        x2, y2, z2 = c[1]\n        x3, y3, z3 = c[2]\n        a, b, c = sorted([x2 - x1, y2 - y1, z2 - z1])\n        r = (a**2 + b**2 + c**2) / (2 * 3.14159)\n        return 3.14159 * r**2\n\n    min_volume = float('inf')\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                c1, c2, c3 = stars[i], stars[j], stars[k]\n                if (c1[0] == c2[0] == c3[0]) or (c1[1] == c2[1] == c3[1]) or (c1[2] == c2[2] == c3[2]):\n                    continue\n                cylinder = [c1, c2, c3]\n                cylinder.sort(key=lambda x: x[0])\n                current_volume = volume(cylinder)\n                if current_volume < min_volume:\n                    min_volume = current_volume\n\n    return f\"{min_volume:.6f}\"\n"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    stars = []\n    for i in range(1, n+1):\n        x, y, z = map(int, input_list[i].split())\n        stars.append((x, y, z))\n    \n    # Find the center of mass of the stars\n    com_x, com_y, com_z = 0, 0, 0\n    for star in stars:\n        com_x += star[0]\n        com_y += star[1]\n        com_z += star[2]\n    com_x /= n\n    com_y /= n\n    com_z /= n\n\n    # Calculate the radius of the cylinder\n    max_radius = 0\n    for star in stars:\n        radius = ((star[0] - com_x)**2 + (star[1] - com_y)**2 + (star[2] - com_z)**2)**0.5\n        max_radius = max(max_radius, radius)\n\n    # Calculate the volume of the cylinder\n    cylinder_volume = max_radius * max_radius * 2 * 3.14159\n\n    return str(cylinder_volume)"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return sum((a[i] - b[i]) ** 2 for i in range(3)) ** 0.5\n\n    def volume(x, y, z):\n        return 2 * pi * x * y + 2 * pi * y * z + 2 * pi * z * x\n\n    n, stdin = int(stdin.splitlines()[0]), '\\n'.join(stdin.splitlines()[1:])\n    stars = [tuple(map(int, line.split())) for line in stdin.splitlines()]\n\n    min_x, min_y, min_z = float('inf'), float('inf'), float('inf')\n    max_x, max_y, max_z = float('-inf'), float('-inf'), float('-inf')\n\n    for star in stars:\n        min_x = min(min_x, star[0])\n        min_y = min(min_y, star[1])\n        min_z = min(min_z, star[2])\n        max_x = max(max_x, star[0])\n        max_y = max(max_y, star[1])\n        max_z = max(max_z, star[2])\n\n    cylinder_x = max_x - min_x\n    cylinder_y = max_y - min_y\n    cylinder_z = max_z - min_z\n\n    min_volume = float('inf')\n    for axis1 in range(3):\n        for axis2 in range(3):\n            if axis1 != axis2:\n                for axis3 in range(3):\n                    if axis1 != axis3 and axis2 != axis3:\n                        proj_x, proj_y, proj_z = 0, 0, 0\n                        for star in stars:\n                            proj_x += star[axis1]\n                            proj_y += star[axis2]\n                            proj_z += star[axis3]\n                        proj_x /= n\n                        proj_y /= n\n                        proj_z /= n\n\n                        min_radius = float('inf')\n                        for star in stars:\n                            dist = distance(star, (proj_x, proj_y, proj_z))\n                            min_radius = min(min_radius, dist)\n\n                        cylinder_r = min_radius\n                        cylinder_volume = volume(cylinder_r, cylinder_x, cylinder_y) if axis1 != axis2 else volume(cylinder_r, cylinder_y, cylinder_z)\n                        min_volume = min(min_volume, cylinder_volume)\n\n    return str(min_volume)"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def volume_cylinder(p, r):\n        return 2 * 3.14159 * (r ** 2)\n\n    def is_in_cylinder(p, cylinder):\n        x, y, z = p\n        center, radius = cylinder\n        return abs(x - center[0]) ** 2 + abs(y - center[1]) ** 2 + abs(z - center[2]) ** 2 <= radius ** 2\n\n    def find_smallest_cylinder(points):\n        min_volume = float('inf')\n        for p1 in points:\n            for p2 in points:\n                if p1 == p2:\n                    continue\n                for p3 in points:\n                    if p2 == p3 or p1 == p3:\n                        continue\n                    p4 = [p1[0] + p2[0] + p3[0], p1[1] + p2[1] + p3[1], p1[2] + p2[2] + p3[2]]\n                    p4[0] /= 3\n                    p4[1] /= 3\n                    p4[2] /= 3\n                    if any(distance(p, p4) < 1e-10 for p in points):\n                        continue\n                    min_volume = min(min_volume, volume_cylinder(p4, distance(p1, p2)))\n        return min_volume\n\n    def main(stdin: str) -> str:\n        n = int(stdin.split()[0])\n        points = [tuple(map(int, stdin.split()[1:])) for _ in range(n)]\n        min_volume = find_smallest_cylinder(points)\n        return f'{min_volume:.6f}'\n\n    return main(stdin)"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_coplanar(p1, p2, p3):\n        return (p2[1] - p1[1]) * (p3[2] - p1[2]) == (p2[2] - p1[2]) * (p3[1] - p1[1])\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def find_smallest_cylinder(stars):\n        if len(stars) < 3:\n            return 0\n\n        min_cylinder = float('inf')\n        for i in range(len(stars)):\n            for j in range(i + 1, len(stars)):\n                for k in range(j + 1, len(stars)):\n                    if not is_coplanar(stars[i], stars[j], stars[k]):\n                        cylinder_radius = distance(stars[i], stars[j])\n                        cylinder_height = distance(stars[i], stars[k])\n                        cylinder_volume = cylinder_radius ** 2 * cylinder_height\n                        min_cylinder = min(min_cylinder, cylinder_volume)\n        return min_cylinder\n\n    n = int(stdin.splitlines()[0])\n    stars = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, stdin.splitlines()[i].split())\n        stars.append((x, y, z))\n\n    smallest_cylinder = find_smallest_cylinder(stars)\n    return str(smallest_cylinder)\n"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, z1, x2, y2, z2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    n, *stars = stdin.split('\\n')\n    n = int(n)\n    stars = [tuple(map(int, star.split())) for star in stars]\n\n    min_volume = float('inf')\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if i != j and i != k and j != k:\n                    d1 = distance(*stars[i], *stars[j])\n                    d2 = distance(*stars[i], *stars[k])\n                    d3 = distance(*stars[j], *stars[k])\n                    if d1 < d2 + d3 and d2 < d1 + d3 and d3 < d1 + d2:\n                        volume = (d1 * d2 * d3) ** (1/3)\n                        min_volume = min(min_volume, volume)\n\n    return round(min_volume, 6)"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_coplanar(p1, p2, p3, p4):\n        v1 = (p2[0] - p1[0], p2[1] - p1[1], p2[2] - p1[2])\n        v2 = (p3[0] - p1[0], p3[1] - p1[1], p3[2] - p1[2])\n        v3 = (p4[0] - p1[0], p4[1] - p1[1], p4[2] - p1[2])\n        return (v1[1] * (v2[2] * v3[0] - v2[0] * v3[2]) - v1[2] * (v2[1] * v3[0] - v2[0] * v3[1]) + v1[0] * (v2[1] * v3[2] - v2[2] * v3[1])) != 0\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def cylinder_volume(p1, p2, p3, p4, radius):\n        return (radius ** 2) * (2 * 3.14159)\n\n    n = int(stdin.splitlines()[0])\n    stars = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_volume = float('inf')\n    for i in range(n):\n        for j in range(i + 4, n):\n            for k in range(j + 4, n):\n                for l in range(k + 4, n):\n                    if is_coplanar(stars[i], stars[j], stars[k], stars[l]):\n                        continue\n                    else:\n                        d12 = distance(stars[i], stars[j])\n                        d13 = distance(stars[i], stars[k])\n                        d14 = distance(stars[i], stars[l])\n                        d23 = distance(stars[j], stars[k])\n                        d24 = distance(stars[j], stars[l])\n                        d34 = distance(stars[k], stars[l])\n\n                        if d12 + d13 + d14 == d23 + d24 + d34:\n                            radius = (d12 + d13 + d14) / 2\n                            volume = cylinder_volume(stars[i], stars[j], stars[k], stars[l], radius)\n                            if volume < min_volume:\n                                min_volume = volume\n    return round(min_volume, 6)\n"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def is_valid_cylinder(stars, radius):\n        for i in range(n):\n            if get_distance(stars[i], [0, 0, 0]) > radius:\n                return False\n            for j in range(i + 1, n):\n                if get_distance(stars[i], stars[j]) > radius:\n                    return False\n        return True\n\n    lines = stdin.split(\"\\n\")\n    n = int(lines[0])\n    stars = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, lines[i].split())\n        stars.append([x, y, z])\n\n    min_radius = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j and i < j:\n                d1, d2 = get_distance(stars[i], stars[j]), get_distance(stars[i], [0, 0, 0])\n                radius = (d1 ** 2 + d2 ** 2 - d1 * d2) / (2 * d1)\n                if is_valid_cylinder(stars, radius) and radius < min_radius:\n                    min_radius = radius\n\n    return str(min_radius)\n"
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    star_positions = []\n    for i in range(1, n+1):\n        x, y, z = map(int, input_list[i].split())\n        star_positions.append((x, y, z))\n\n    # find minimum and maximum values of x, y and z\n    min_x, max_x = min(star_positions, key=lambda x: x[0])[0], max(star_positions, key=lambda x: x[0])[0]\n    min_y, max_y = min(star_positions, key=lambda x: x[1])[1], max(star_positions, key=lambda x: x[1])[1]\n    min_z, max_z = min(star_positions, key=lambda x: x[2])[2], max(star_positions, key=lambda x: x[2])[2]\n\n    # find smallest enclosing cylinder\n    def cylinder_volume(r, h):\n        return 2 * r * h * pi\n\n    max_radius = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            dx, dy, dz = star_positions[j][0] - star_positions[i][0], star_positions[j][1] - star_positions[i][1], star_positions[j][2] - star_positions[i][2]\n            r = sqrt(dx*dx + dy*dy + dz*dz)\n            h = sqrt((dx-r)*(dx-r) + (dy-r)*(dy-r) + (dz-r)*(dz-r))\n            if r > max_radius:\n                max_radius = r\n\n    max_height = sqrt((max_x - min_x)**2 + (max_y - min_y)**2 + (max_z - min_z)**2)\n    min_cylinder_volume = cylinder_volume(max_radius, max_height)\n\n    return f\"{min_cylinder_volume:.6f}\"\n"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, s = stdin.split('\\n')\n    L = int(L)\n    s = s.lower()\n    freq = {}\n    for i in range(L):\n        if s[i] in freq:\n            freq[s[i]][0] += 1\n            freq[s[i]][1].append(i)\n        else:\n            freq[s[i]] = [1, [i]]\n    longest_str = \"\"\n    for key in freq:\n        if freq[key][0] >= 2 and len(key) > len(longest_str):\n            longest_str = key\n    return str(len(longest_str))"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    L, string = stdin.split('\\n')\n    L = int(L)\n    string = string.strip()\n    count = {}\n    longest = 0\n    for i in range(L):\n        for j in range(i+1, L):\n            if string[i:j+1] in count:\n                count[string[i:j+1]] += 1\n            else:\n                count[string[i:j+1]] = 1\n            if count[string[i:j+1]] == 2:\n                longest = max(longest, len(string[i:j+1]))\n    return str(longest)\n\ninput_data = '''\\\n11\nsabcabcfabc\n18\ntrutrutiktiktappop\n'''\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    chars = {}\n    longest_string = ''\n\n    for i in range(L):\n        if s[i] in chars:\n            chars[s[i]].append(i)\n        else:\n            chars[s[i]] = [i]\n\n        for k, v in chars.items():\n            if len(v) >= 2:\n                longest_string = max(longest_string, k, key=len)\n\n    return len(longest_string) if longest_string else 0\n"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    L, string = stdin.split(\"\\n\")\n    L = int(L)\n    string = list(string)\n    counts = {}\n    longest = 0\n\n    for i in range(L):\n        for j in range(i + 1, L):\n            if string[i] == string[j]:\n                if string[i] in counts:\n                    counts[string[i]] += 1\n                else:\n                    counts[string[i]] = 1\n\n                if counts[string[i]] == 2:\n                    longest = max(longest, j - i + 1)\n\n    return str(longest)\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    L, S = stdin.split('\\n')\n    L = int(L)\n    freq = {}\n    longest = 0\n\n    for i in range(L):\n        if S[i] in freq:\n            freq[S[i]][0] += 1\n            freq[S[i]][1] = i\n        else:\n            freq[S[i]] = [1, i]\n\n    for f in freq.values():\n        if f[0] > 1 and f[1] - f[2] > longest:\n            longest = f[1] - f[2]\n\n    return longest if longest > 0 else 0\n\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    L, S = map(str, stdin.split('\\n'))\n    L, S = int(L), list(S)\n    count = {}\n    max_length = 0\n    for i in range(L):\n        if S[i] not in count:\n            count[S[i]] = [i]\n        else:\n            count[S[i]].append(i)\n            if len(count[S[i]]) == 2:\n                max_length = max(max_length, count[S[i]][-1] - count[S[i]][0])\n    return str(max_length)\n\ninput_string = \"11\\nsabcabcfabc\\n18\\ntrutrutiktiktappop\"\noutput_string = \"\"\nfor i in range(0, len(input_string), 18):\n    output_string += solution(input_string[i:i+18]) + \"\\n\"\n\nprint(output_string) "
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    counts = {}\n    longest = 0\n\n    for i in range(L - 1):\n        for j in range(i + 1, L):\n            substring = s[i:j + 1]\n            if substring in counts:\n                counts[substring] += 1\n                longest = max(longest, len(substring))\n            else:\n                counts[substring] = 1\n\n    return str(longest)\n\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, s = stdin.split('\\n')\n    n = int(n)\n    s = s.strip()\n    freq = {}\n    max_len = 0\n\n    for i in range(n):\n        if s[i:i+3] in freq:\n            freq[s[i:i+3]].append(i)\n        else:\n            freq[s[i:i+3]] = [i]\n\n        if s[i:i+3] not in freq or len(freq[s[i:i+3]]) < 2:\n            continue\n\n        max_len = max(max_len, len(s[i:i+3]))\n\n    return max_len if max_len > 0 else \"0\"\n\ndef"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    L, input_str = stdin.split()\n    L = int(L)\n    char_dict = {}\n    longest_length = 0\n    for char in input_str:\n        if char in char_dict:\n            char_dict[char] += 1\n        else:\n            char_dict[char] = 1\n        if char_dict[char] == 2 and longest_length < 2:\n            longest_length = 2\n        if char_dict[char] == 3 and longest_length < 3:\n            longest_length = 3\n    return str(longest_length)\n\ninput_str = \"11\\nsabcabcfabc\\n18\\ntrutrutiktiktappop\"\noutput = [solution(input_str[i:i+input_str[i:i+input_str[i:].find(\"\\n\")+1].find(\"\\n\")+1]) for i in range(0, len(input_str), input_str[i:].find(\"\\n\")+1)]\nprint(\"\\n\".join(output)) "
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    L, s = map(str, stdin.split())\n    L = int(L)\n    s = list(s)\n    \n    max_length = 0\n    for i in range(L - 1):\n        for j in range(i + 1, L):\n            if s[i] == s[j]:\n                length = j - i\n                if length > max_length:\n                    max_length = length\n    \n    return str(max_length)\n"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    alice_positions = list(map(int, input_data[1].split()))\n    bob_positions = list(map(int, input_data[2].split()))\n\n    alice_cycle = find_cycle(n, alice_positions)\n    bob_cycle = find_cycle(n, bob_positions)\n\n    gcd = find_gcd(alice_cycle, bob_cycle)\n    return str(n // gcd)\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    for i in range(n):\n        if a[i] != i + 1 or b[i] != i + 1:\n            return \"huge\"\n\n    if n % 2 == 0:\n        if len(set(a)) != n or len(set(b)) != n:\n            return \"huge\"\n\n    m = 1\n    while True:\n        if a == list(range(1, n + 1)) and b == list(range(1, n + 1)):\n            return m\n        m += 1\n        if m > 10**12:\n            return \"huge\"\n\n        a, b = b, a\n        a[::-2], b[::-2] = b[::-2], a[::-2]\n        a[1::2], b[1::2] = b[1::2], a[1::2]"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    def shuffle(perm):\n        return [perm[i - 1] for i in range(1, n + 1)]\n\n    for _ in range(n):\n        a = shuffle(a)\n        b = shuffle(b)\n\n    # Check if the deck is sorted after both shuffles\n    if a == b:\n        return \"2\"\n\n    # Check if the deck is sorted after n shuffles\n    if n * n < 10**12:\n        for i in range(3, n * n + 1):\n            a = shuffle(a)\n            b = shuffle(b)\n            if a == b:\n                return str(i - 1)\n\n    return \"huge\""
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    sorted_a = sorted(a)\n    sorted_b = sorted(b)\n\n    for i in range(n):\n        if a[i] == b[i]:\n            continue\n        if sorted_a[i] == a[i]:\n            break\n    else:\n        return 'huge'\n\n    m = (n - i) // 2\n\n    if m * 2 > 10**12:\n        return 'huge'\n\n    return str(m)"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    # check if the deck is already sorted\n    if a == list(range(1, n + 1)) and b == list(range(1, n + 1)):\n        return \"0\"\n\n    # find the minimum number of shuffles required to sort the deck\n    min_shuffles = 0\n    max_shuffles = n * (n + 1) // 2\n    while min_shuffles <= max_shuffles:\n        mid_shuffles = (min_shuffles + max_shuffles) // 2\n        shuffles = 0\n        deck = list(range(1, n + 1))\n        while shuffles < mid_shuffles:\n            for i in range(1, n):\n                if deck[i] < deck[i - 1]:\n                    deck = swap(deck, i, i - 1)\n            if deck == list(range(1, n + 1)):\n                break\n            shuffles += 1\n\n        if deck == list(range(1, n + 1)):\n            return str(mid_shuffles)\n        elif deck[0] > deck[n - 1]:\n            min_shuffles = mid_shuffles + 1\n        else:\n            max_shuffles = mid_shuffles - 1\n\n    return \"huge\"\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle_size(a: int, b: int, mod: int) -> int:\n        if a == 0 or b == 0:\n            return mod\n        elif a == 1 and b == 1:\n            return 1\n        elif a == 1:\n            return find_cycle_size(a, b-1, mod)\n        elif b == 1:\n            return find_cycle_size(a-1, b, mod)\n        else:\n            return lcm(find_cycle_size(a-1, b, mod), find_cycle_size(a, b-1, mod), mod)\n\n    def lcm(a: int, b: int, mod: int) -> int:\n        return (a*b) // gcd(a, mod)\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def shuffle_cycle(n: int, a: int, b: int) -> int:\n        size = find_cycle_size(a, b, n)\n        return size if size <= 10**12 else \"huge\"\n\n    lines = stdin.strip().split(\"\\n\")\n    n = int(lines[0])\n    a = [int(x) for x in lines[1].split()]\n    b = [int(x) for x in lines[2].split()]\n\n    shuffle_count = 0\n    min_shuffle_count = float('inf')\n\n    while min_shuffle_count > 0:\n        min_shuffle_count = shuffle_cycle(n, a[0], b[0])\n        if min_shuffle_count == \"huge\":\n            return min_shuffle_count\n        shuffle_count += 1\n        a = [a[(a[i-1]+1) % n] for i in range(1, n)]\n        b = [b[(b[i-1]+1) % n] for i in range(1, n)]\n\n    return shuffle_count\n"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def compute_cycle_length(permutation: List[int]) -> int:\n        cycle_length = 0\n        index = 0\n        seen = [False] * n\n        while not seen[index]:\n            seen[index] = True\n            index = permutation[index] - 1\n            cycle_length += 1\n        return cycle_length\n\n    def compute_minimal_shuffles(cycle_lengths: List[int]) -> int:\n        shuffles = 0\n        for cycle_length in cycle_lengths:\n            shuffles += n // cycle_length\n        return shuffles\n\n    def shuffle(permutation: List[int], cycle_lengths: List[int]) -> None:\n        new_cycle_lengths = []\n        for cycle_length in cycle_lengths:\n            cycle_length += 1\n            new_cycle_lengths.append(cycle_length)\n        for i in range(n):\n            permutation[i] = permutation[i - 1] + 1\n        return new_cycle_lengths\n\n    n, *alice, *bob = map(int, stdin.split())\n    alice = list(alice)\n    bob = list(bob)\n\n    alice_cycle_lengths = [compute_cycle_length(alice)]\n    bob_cycle_lengths = [compute_cycle_length(bob)]\n\n    minimal_shuffles = 0\n    while alice_cycle_lengths != bob_cycle_lengths:\n        alice_cycle_lengths = shuffle(alice, alice_cycle_lengths)\n        minimal_shuffles += 1\n    while alice_cycle_lengths != []:\n        alice_cycle_lengths = shuffle(alice, alice_cycle_lengths)\n        minimal_shuffles += 1\n\n    return str(minimal_shuffles)\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    if n > 10**5:\n        return \"huge\"\n\n    def is_sorted(deck):\n        for i in range(n - 1):\n            if deck[i] >= deck[i + 1]:\n                return False\n        return True\n\n    deck = list(range(1, n + 1))\n    shuffle_count = 0\n\n    while not is_sorted(a):\n        deck = a\n        a = b\n        b = deck\n        shuffle_count += 1\n\n    while not is_sorted(b):\n        deck = b\n        b = a\n        a = deck\n        shuffle_count += 1\n\n    if shuffle_count > 10**12:\n        return \"huge\"\n\n    return shuffle_count"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    b = list(map(int, stdin.split(\"\\n\")[2].split()))\n\n    # Compute the LCM of the permutation cycles of Alice and Bob\n    lcm = 1\n    for i in range(n):\n        lcm = lcm * int(gcd(a[i], n))\n        lcm = lcm * int(gcd(b[i], n))\n\n    # Compute the number of shuffles required\n    m = n * lcm\n\n    # Check if the number of shuffles is too large\n    if m > 10**12:\n        return \"huge\"\n    else:\n        return str(m)\n\n\ndef"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    a = list(map(int, input_lines[1].split()))\n    b = list(map(int, input_lines[2].split()))\n\n    # Check if the deck is sorted or not\n    sorted_deck = sorted(range(1, n+1))\n    if a == sorted_deck and b == sorted_deck:\n        return \"1\"\n\n    # Check if the deck will be sorted or not\n    deck = sorted(range(1, n+1))\n    a_deck = [i for i in range(1, n+1)]\n    b_deck = [i for i in range(1, n+1)]\n\n    for _ in range(n):\n        # Alice shuffles\n        for i in range(n):\n            a_deck[i], a_deck[a[i]-1] = a_deck[a[i]-1], a_deck[i]\n\n        # Check if the deck is sorted or not\n        if a_deck == sorted_deck:\n            return \"1\"\n\n        # Bob shuffles\n        for i in range(n):\n            b_deck[i], b_deck[b[i]-1] = b_deck[b[i]-1], b_deck[i]\n\n        # Check if the deck is sorted or not\n        if b_deck == sorted_deck:\n            return \"1\"\n\n        # Check if the deck will be sorted or not\n        if a_deck == deck and b_deck == deck:\n            return \"huge\"\n\n    return \"huge\""
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, p = map(int, input_list[0].split())\n    t_list = list(map(int, input_list[1].split()))\n    sp_list = [list(map(int, input_list[2+i].split())) for i in range(p)]\n\n    def get_score(notes):\n        score = 0\n        for i in range(len(notes)):\n            score += notes[i]\n            if i > 0 and notes[i] == 2:\n                score -= 1\n        return score\n\n    def get_max_score(sp_phrases, t_list):\n        max_score = 0\n        for sp_phrase in sp_phrases:\n            start = sp_phrase[0]\n            end = sp_phrase[1]\n            sp_score = 2 * (end - start)\n            notes_in_range = [t for t in t_list if start <= t <= end]\n            notes_score = get_score(notes_in_range)\n            max_score = max(max_score, sp_score + notes_score)\n        return max_score\n\n    max_score = get_max_score(sp_list, t_list)\n    return str(max_score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, p = map(int, input_data[0].split())\n    notes = list(map(int, input_data[1].split()))\n    sp_phrases = [list(map(int, input_data[i+2].split())) for i in range(p)]\n\n    # Sort SP phrases by start position\n    sp_phrases.sort(key=lambda x: x[0])\n\n    max_score = 0\n    sp_meter = 0\n    sp_phrase_active = False\n    sp_phrase_start = 0\n    for note in notes:\n        # Check if SP phrase is active\n        if sp_phrase_active and note >= sp_phrase_start:\n            # Calculate SP drain time\n            drain_time = sp_phrase_start - note\n            if sp_meter >= drain_time:\n                sp_meter -= drain_time\n            else:\n                sp_phrase_active = False\n                sp_phrase_start = 0\n\n        # Check if note is within a SP phrase\n        for i in range(p):\n            if note >= sp_phrases[i][0] and note <= sp_phrases[i][1]:\n                if not sp_phrase_active:\n                    # Start SP meter\n                    sp_meter = sp_phrases[i][1] - sp_phrases[i][0]\n                    sp_phrase_start = sp_phrases[i][0]\n                    sp_phrase_active = True\n                break\n\n        # Check if note is a note or SP activation point\n        if note % 2 == 0 and sp_meter > 0:\n            # Activate SP\n            score = 2\n            sp_meter -= 1\n        else:\n            # Regular note\n            score = 1\n\n        # Update max score\n        max_score += score\n\n    return str(max_score)\n"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calc_score(notes: list, sp_phrases: list, notes_pos: int, sp_phrases_pos: int) -> int:\n        score = 0\n        for note in notes[notes_pos:]:\n            if sp_phrases_pos < len(sp_phrases) and note >= sp_phrases[sp_phrases_pos][0]:\n                score += 2 if sp_phrases[sp_phrases_pos][1] >= notes_pos else 1\n            else:\n                score += 1\n        return score\n\n    def calculate_max_score(notes: list, sp_phrases: list) -> int:\n        max_score = 0\n        for i in range(len(notes) - len(sp_phrases)):\n            notes_pos = i\n            sp_phrases_pos = 0\n            while notes_pos < len(notes) and sp_phrases_pos < len(sp_phrases):\n                if notes[notes_pos] < sp_phrases[sp_phrases_pos][0]:\n                    max_score = max(max_score, calc_score(notes, sp_phrases, notes_pos, sp_phrases_pos))\n                    notes_pos += 1\n                else:\n                    notes_pos += sp_phrases[sp_phrases_pos][1] - sp_phrases[sp_phrases_pos][0] + 1\n                    sp_phrases_pos += 1\n        return max_score\n\n    n, p = map(int, stdin.split()[:2])\n    notes = list(map(int, stdin.split()[2:n+2]))\n    sp_phrases = list(map(lambda x: tuple(map(int, x.split())), stdin.split()[n+2:]))\n\n    return str(calculate_max_score(notes, sp_phrases))\n\ndef"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.splitlines()[0].split())\n    notes = sorted(map(int, stdin.splitlines()[1].split()))\n    sp_phrases = sorted(map(lambda x: map(int, x.split()), stdin.splitlines()[2:]))\n    sp_meter = 0\n    score = 0\n    \n    for i in range(n):\n        if sp_meter > 0:\n            score += 2\n            sp_meter -= 1\n        else:\n            score += 1\n        if notes[i] == sp_phrases[0][0]:\n            sp_meter = sp_phrases[0][1] - sp_phrases[0][0]\n            sp_phrases.pop(0)\n    \n    return str(score)"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_note(t: int) -> int:\n        for i, t_i in enumerate(t):\n            if t_i > t_prev:\n                return i\n        return -1\n    \n    def update_score(t: int, score: int) -> int:\n        note_i = get_next_note(t)\n        if note_i != -1:\n            score += 1\n        return score\n    \n    def get_max_score(t: List[int]) -> int:\n        score = 0\n        t_prev = 0\n        for i in range(len(t)):\n            t_prev = t[i]\n            score = update_score(t[i:], score)\n        return score\n    \n    def update_score_with_sp(t: int, sp_t: int, sp_e: int, score: int) -> int:\n        score_before_activation = score\n        while t < sp_t:\n            t_prev = t\n            t = get_next_note(t)\n            if t != -1:\n                score += 1\n        if t == sp_t:\n            score += 1\n            t += 1\n        while t < sp_e:\n            if t == sp_t:\n                score += 1\n            t_prev = t\n            t = get_next_note(t)\n            if t != -1:\n                score += 2\n        return score - score_before_activation + 1 if t == sp_e else score - score_before_activation\n    \n    def get_max_score_with_sp(t: List[int], sp: List[Tuple[int, int]]) -> int:\n        score = 0\n        t_prev = 0\n        for i in range(len(t)):\n            t_prev = t[i]\n            score = update_score_with_sp(t[i:], sp[0][0], sp[0][1], score)\n            if len(sp) > 1:\n                j = 1\n                while j < len(sp) and t[i] >= sp[j][1]:\n                    j += 1\n                score += get_max_score_with_sp(t[i:], sp[:j])\n            if len(sp) > 0:\n                sp = sp[1:]\n        return score\n    \n    n, p = map(int, input().split())\n    t = list(map(int, input().split()))\n    sp = []\n    for _ in range(p):\n        s, e = map(int, input().split())\n        sp.append((s, e))\n    max_score = get_max_score_with_sp(t, sp)\n    return max_score"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    notes = int(input_list[0].split()[0])\n    sp_phrases = int(input_list[0].split()[1])\n    note_positions = list(map(int, input_list[1].split()))\n    sp_positions = []\n    for i in range(2, 2 + sp_phrases):\n        sp_positions.append(list(map(int, input_list[i].split())))\n\n    max_score = 0\n    sp_timer = 0\n    active_sp = False\n    for i in range(notes):\n        if i in note_positions:\n            max_score += 1\n        if sp_timer > 0:\n            sp_timer -= 1\n            if sp_timer == 0:\n                active_sp = False\n        for sp in sp_positions:\n            if sp[0] <= i <= sp[1]:\n                sp_timer = sp[1] - sp[0] + 1\n                if not active_sp:\n                    max_score += 1\n                active_sp = True\n                break\n\n    return str(max_score)"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside_sp(note_i: int, sp_start: int, sp_end: int) -> bool:\n        return note_i >= sp_start and note_i <= sp_end\n\n    def calculate_sp_value(note_i: int, sp_phrases: List[Tuple[int, int]], sp_meter: float) -> Tuple[int, float]:\n        sp_value = 0\n        for sp_start, sp_end in sp_phrases:\n            if is_inside_sp(note_i, sp_start, sp_end):\n                if sp_meter <= 0:\n                    sp_value += 1\n                else:\n                    sp_value += 2\n            else:\n                sp_value += 1\n        return sp_value, sp_meter - 1\n\n    def get_score(notes: List[int], sp_phrases: List[Tuple[int, int]], sp_meter: float) -> int:\n        score = 0\n        for i, note_i in enumerate(notes):\n            sp_value, sp_meter = calculate_sp_value(note_i, sp_phrases, sp_meter)\n            score += sp_value\n        return score\n\n    def main(n: int, p: int, t: List[int], s: List[int], e: List[int]) -> int:\n        notes = [t[i // 2] for i in range(2 * n)]\n        sp_phrases = [(s[i], e[i]) for i in range(p)]\n        sp_meter = 0\n        return get_score(notes, sp_phrases, sp_meter)\n\n    input_data = stdin.split(\"\\n\")\n    n, p = map(int, input_data[0].split())\n    t = list(map(int, input_data[1].split()))\n    s = list(map(int, input_data[2].split()))\n    e = list(map(int, input_data[3].split()))\n    return str(main(n, p, t, s, e))"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.splitlines()[0].split())\n    positions = list(map(int, stdin.splitlines()[1].split()))\n    sp_phrases = [list(map(int, line.split())) for line in stdin.splitlines()[2:]]\n\n    notes = [positions[i] for i in range(n)]\n    sp_phrases = [SPPhrase(sp_phrases[i][0], sp_phrases[i][1]) for i in range(p)]\n\n    notes_scores = [2 if sp_phrases[i].contains_note(notes[i]) else 1 for i in range(n)]\n    sp_power_scores = [0] * n\n\n    for i in range(n):\n        if notes_scores[i] == 2:\n            for j in range(i - 1, -1, -1):\n                if notes_scores[j] == 1 and sp_phrases[j].contains_note(notes[i]):\n                    sp_power_scores[i] = max(sp_power_scores[i], notes_scores[i] * (i - j))\n                    break\n            for j in range(i + 1, n):\n                if notes_scores[j] == 1 and sp_phrases[j].contains_note(notes[i]):\n                    sp_power_scores[i] = max(sp_power_scores[i], notes_scores[i] * (j - i))\n                    break\n\n    max_score = max(notes_scores) + max(sp_power_scores)\n    return str(max_score)\n\n\nclass SPPhrase:\n    def __init__(self, start: int, end: int):\n        self.start = start\n        self.end = end\n\n    def contains_note(self, note: int) -> bool:\n        return self.start <= note <= self.end\n"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_score(notes, sp_phrases):\n        def process_sp(sp, notes):\n            max_score = 0\n            start_index = 0\n            for i in range(len(sp)):\n                if sp[i] == '(':\n                    max_score += notes[start_index]\n                else:\n                    start_index += 1\n            return max_score\n\n        def process_notes(notes):\n            return sum(notes)\n\n        max_score = 0\n        for sp in sp_phrases:\n            sp_score = process_sp(sp, notes)\n            if sp_score > max_score:\n                max_score = sp_score\n\n        notes_score = process_notes(notes)\n        if notes_score > max_score:\n            max_score = notes_score\n\n        return max_score\n\n    def parse_input(input_str):\n        lines = input_str.split('\\n')\n        notes = [int(x) for x in lines[0].split()]\n        sp_phrases = []\n        for line in lines[1:]:\n            start, end = [int(x) for x in line.split()]\n            sp_phrases.append((start, end))\n        return notes, sp_phrases\n\n    notes, sp_phrases = parse_input(stdin)\n    max_score = find_max_score(notes, sp_phrases)\n    return str(max_score)"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, p = map(int, input_data[0].split())\n    notes = list(map(int, input_data[1].split()))\n    sp_phrases = []\n    for i in range(p):\n        s, e = map(int, input_data[2 + i].split())\n        sp_phrases.append((s, e))\n\n    max_score = 0\n    notes_remaining = list(notes)\n    for sp_phrase in sp_phrases:\n        start, end = sp_phrase\n        notes_in_sp = [note for note in notes_remaining if note >= start and note <= end]\n        if notes_in_sp:\n            sp_time = end - start\n            sp_points = sum(2 if i < sp_time else 1 for i in range(sp_time + 1))\n            max_score += sp_points\n            notes_remaining = [note for note in notes_remaining if note < start or note > end]\n\n    remaining_notes = [note for note in notes_remaining if all(note < sp_phrase[0] or note > sp_phrase[1] for sp_phrase in sp_phrases)]\n    max_score += len(remaining_notes)\n\n    return str(max_score)\n\ninput_string = \"\"\"3 1\n0 10 20\n0 10\n6 1\n0 10 20 26 40 50\n0 40\"\"\"\n\nprint(solution(input_string))\n"
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_expression(expression: str) -> list:\n        expression = expression.strip(\"[]\")\n        if not expression:\n            return []\n        result = []\n        current_number = \"\"\n        for char in expression:\n            if char.isdigit():\n                current_number += char\n            else:\n                if current_number:\n                    result.append(int(current_number))\n                    current_number = \"\"\n                if char == \",\":\n                    continue\n                result.append(char)\n        if current_number:\n            result.append(int(current_number))\n        return result\n\n    def evaluate_expression(expression: list) -> list:\n        if isinstance(expression, int):\n            return [expression]\n        if isinstance(expression, str):\n            return [ord(expression)]\n        result = []\n        for element in expression:\n            if isinstance(element, list):\n                result.extend(evaluate_expression(element))\n            else:\n                result.append(element)\n        return result\n\n    def are_equivalent(program1: str, program2: str) -> bool:\n        parsed_program1 = parse_expression(program1)\n        parsed_program2 = parse_expression(program2)\n        sample_program = evaluate_expression(parsed_program1)\n        possible_programs = []\n        for _ in range(4):\n            possible_programs.append(evaluate_expression(parsed_program2))\n        return any(possible_programs == sample_program)\n\n    stdin = stdin.split(\"\\n\")\n    program1, program2 = stdin\n    if are_equivalent(program1, program2):\n        return \"equal\"\n    return \"not equal\"\n"
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parse(program: str) -> List[int]:\n        result = []\n        i = 0\n        while i < len(program):\n            if program[i] == \"[\":\n                j = program.find(\"]\", i)\n                result += [int(x) for x in program[i+1:j].split(\",\")]\n                i = j + 1\n            else:\n                raise ValueError(\"Invalid syntax\")\n        return result\n\n    def run(program: str, input_data: List[int]) -> List[int]:\n        i = 0\n        stack = []\n        while i < len(program):\n            if program[i] == \"[\":\n                stack.append(i)\n            elif program[i] == \"]\":\n                start = stack.pop()\n                expr = program[start:i+1]\n                input_data = concat(shuffle(expr), shuffle(expr))\n            elif program[i] == \",\":\n                pass\n            elif program[i] == \"(\":\n                j = program.find(\")\", i)\n                func = program[i+1:j]\n                if func == \"shuffle\":\n                    stack[-1] = shuffle(input_data)\n                elif func == \"concat\":\n                    j = program.find(\")\", j+1)\n                    expr = program[i+1:j]\n                    stack[-1] = concat(stack[-1], parse(expr))\n                else:\n                    raise ValueError(\"Invalid function\")\n                i = j + 1\n            elif program[i] == \")\":\n                pass\n            else:\n                raise ValueError(\"Invalid syntax\")\n            i += 1\n        return stack[0]\n\n    def concat(a: List[int], b: List[int]) -> List[int]:\n        return a + b\n\n    def shuffle(data: List[int]) -> List[int]:\n        import random\n        random.shuffle(data)\n        return data\n\n    stdin = stdin.splitlines()\n    program1 = stdin[0]\n    program2 = stdin[1]\n    input_data = [1, 2]\n    try:\n        result1 = run(program1, input_data)\n        result2 = run(program2, input_data)\n        if result1 == result2:\n            return \"equal\"\n        else:\n            return \"not equal\"\n    except (ValueError, IndexError):\n        return \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def parse_expression(expr: str):\n        if expr == \"[]\":\n            return []\n        start = expr.index(\"[\")\n        end = expr.rindex(\"]\")\n        return [int(x) for x in expr[start+1:end].split(\",\")]\n\n    def evaluate_expression(expr: str):\n        if \"shuffle(\" in expr:\n            return random.shuffle(evaluate_expression(expr[8:-1]))\n        elif \"sorted(\" in expr:\n            return sorted(evaluate_expression(expr[7:-1]))\n        elif \"concat(\" in expr:\n            start = expr.index(\"(\")\n            end = expr.rindex(\")\")\n            return sum([evaluate_expression(x.strip()) for x in expr[start+1:end].split(\",\")], [])\n        else:\n            return parse_expression(expr)\n\n    def compare_programs(p1: str, p2: str) -> bool:\n        for _ in range(1000):\n            r1 = evaluate_expression(p1)\n            r2 = evaluate_expression(p2)\n            if r1 != r2:\n                return False\n        return True\n\n    stdin = stdin.split(\"\\n\")\n    p1 = stdin[0]\n    p2 = stdin[1]\n    return \"equal\" if compare_programs(p1, p2) else \"not equal\"\n\nimport random\nimport sys\n\nstdin = sys.stdin.read()\nprint(solution(stdin)) "
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def parse_program(program: str) -> list:\n        program = program.replace('concat(', '').replace(')', '').replace('shuffle(', '').replace(')', '')\n        return [int(x) for x in program.split(',')]\n\n    def run_program(program: list) -> list:\n        if 'concat' in program:\n            i = program.index('concat')\n            left, right = run_program(program[:i]), run_program(program[i + 2:])\n            return left + right\n        elif 'shuffle' in program:\n            i = program.index('shuffle')\n            expr = program[i + 1]\n            if isinstance(expr, int):\n                return [expr]\n            else:\n                return [x for x in range(1, 10 ** 9 + 1)]\n        else:\n            return program\n\n    def check_equivalence(program1: str, program2: str) -> str:\n        program1_parsed = parse_program(program1)\n        program2_parsed = parse_program(program2)\n\n        program1_output = run_program(program1_parsed)\n        program2_output = run_program(program2_parsed)\n\n        if program1_output == program2_output:\n            return 'equal'\n        else:\n            return 'not equal'\n\n    return check_equivalence(stdin[0], stdin[1])\n"
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def balloon_eval(expr: str) -> list:\n        def shuffle(expr: str) -> list:\n            numbers = [int(x) for x in expr[1:-1].split(',')]\n            random.shuffle(numbers)\n            return numbers\n        \n        def concat(expr: str) -> list:\n            left, right = expr[1:-1].split(',', 1)\n            return balloon_eval(left) + balloon_eval(right)\n        \n        def sorted(expr: str) -> list:\n            numbers = [int(x) for x in expr[1:-1].split(',')]\n            return sorted(numbers)\n        \n        if expr[0] == '[':\n            return [int(expr[1:-1])]\n        elif expr[0] == 's':\n            return shuffle(expr[1:])\n        elif expr[0] == 'c':\n            return concat(expr)\n        elif expr[0] == 'o':\n            return sorted(expr)\n        else:\n            raise ValueError(\"Invalid expression\")\n    \n    def check_equivalence(prog1: str, prog2: str) -> bool:\n        for i in range(100):\n            list1 = balloon_eval(prog1)\n            list2 = balloon_eval(prog2)\n            if set(list1) != set(list2):\n                return False\n        return True\n    \n    # Parse input\n    prog1, prog2 = stdin.split('\\n')\n    \n    # Evaluate programs\n    result1 = balloon_eval(prog1)\n    result2 = balloon_eval(prog2)\n    \n    # Check equivalence\n    if check_equivalence(prog1, prog2):\n        return \"equal\"\n    else:\n        return \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse(expr: str) -> list:\n        if expr.startswith(\"concat(\"):\n            _, inner_expr1, inner_expr2, _ = expr.split(\",\")\n            return parse(inner_expr1) + parse(inner_expr2)\n        elif expr.startswith(\"shuffle(\"):\n            _, inner_expr, _ = expr.split(\",\")\n            return sorted(parse(inner_expr))\n        elif expr.startswith(\"[\") and expr.endswith(\"]\"):\n            return [int(x.strip()) for x in expr[1:-1].split(\",\")]\n        else:\n            raise ValueError(\"Invalid expression\")\n\n    prog1, prog2 = stdin.split(\"\\n\")\n    parsed1, parsed2 = parse(prog1), parse(prog2)\n\n    if len(parsed1) != len(parsed2):\n        return \"not equal\"\n\n    for i in range(len(parsed1)):\n        if parsed1[i] != parsed2[i]:\n            return \"not equal\"\n\n    return \"equal\""
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def shuffle_list(expr: str) -> str:\n        return f\"shuffle({expr})\"\n\n    def concat_lists(expr1: str, expr2: str) -> str:\n        return f\"concat({expr1},{expr2})\"\n\n    def sorted_list(expr: str) -> str:\n        return f\"sorted({expr})\"\n\n    def build_list(numbers: List[int]) -> str:\n        return f\"[{','.join(str(num) for num in numbers)}]\"\n\n    def parse_program(program: str) -> str:\n        stack = []\n        for char in program:\n            if char == \"[\":\n                stack.append(\"[\")\n            elif char == \"]\":\n                if len(stack) == 0:\n                    raise ValueError(\"Invalid expression: Unmatched closing bracket\")\n                stack.pop()\n            elif char == \"(\":\n                stack.append(\"(\")\n            elif char == \")\":\n                if len(stack) == 0:\n                    raise ValueError(\"Invalid expression: Unmatched closing parenthesis\")\n                stack.pop()\n            elif char == \",\":\n                if len(stack) == 0:\n                    raise ValueError(\"Invalid expression: Unmatched comma\")\n                stack.pop()\n            elif char in [\"concat\", \"shuffle\", \"sorted\"]:\n                stack.append(char)\n            elif char.isdigit():\n                stack.append(\"num\")\n            else:\n                raise ValueError(\"Invalid expression: Invalid character\")\n\n        if len(stack) != 0:\n            raise ValueError(\"Invalid expression: Unmatched opening bracket/parenthesis/comma\")\n\n        return stack\n\n    def check_equivalence(program1: str, program2: str) -> bool:\n        parsed_program1 = parse_program(program1)\n        parsed_program2 = parse_program(program2)\n\n        if parsed_program1 != parsed_program2:\n            return False\n\n        for num in range(1, 10**6):\n            list1 = build_list(list(range(num)))\n            list2 = build_list(list(range(num, 2*num)))\n            shuffled_list1 = shuffle_list(list1)\n            shuffled_list2 = shuffle_list(list2)\n            concat_list1 = concat_lists(shuffled_list1, shuffled_list2)\n            concat_list2 = concat_lists(shuffled_list2, shuffled_list1)\n\n            if not (eval(concat_list1) == eval(concat_list2) or eval(concat_list2) == eval(concat_list1)):\n                return False\n\n        return True\n\n    stdin = stdin.split(\"\\n\")\n    program1 = stdin[0]\n    program2 = stdin[1]\n\n    if check_equivalence(program1, program2):\n        return \"equal\"\n    else:\n        return \"not equal\"\n"
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def parse(program: str) -> list:\n        stack = []\n        i = 0\n        while i < len(program):\n            if program[i] == \"[\":\n                stack.append(\"[\")\n                i += 1\n            elif program[i] == \"]\":\n                if stack and stack[-1] == \"[\":\n                    stack.pop()\n                else:\n                    raise ValueError(\"Invalid program\")\n                i += 1\n            elif program[i] == \",\":\n                i += 1\n            elif program[i].isdigit():\n                num = \"\"\n                while program[i].isdigit():\n                    num += program[i]\n                    i += 1\n                stack.append(int(num))\n            else:\n                raise ValueError(\"Invalid program\")\n        if stack:\n            raise ValueError(\"Invalid program\")\n        return stack\n\n    def equal_probability(program_1: list, program_2: list) -> bool:\n        def shuffle(expr: list) -> list:\n            perm = list(range(len(expr)))\n            random.shuffle(perm)\n            return [expr[i] for i in perm]\n\n        def concat(expr_1: list, expr_2: list) -> list:\n            return expr_1 + expr_2\n\n        def sorted_list(expr: list) -> list:\n            return sorted(expr)\n\n        programs = [program_1, program_2]\n        for program in programs:\n            stack = parse(program)\n            if len(stack) != 1:\n                return False\n            stack = stack[0]\n            if isinstance(stack, int):\n                if len(programs) % 2 == 1:\n                    stacks.append(stack)\n            else:\n                if len(programs) % 2 == 0:\n                    stacks.append(stack)\n        return len(stacks) == 1\n\n    def check_equivalence(program_1: str, program_2: str) -> str:\n        stacks = []\n        programs = [program_1, program_2]\n        for program in programs:\n            stack = parse(program)\n            if len(stack) != 1:\n                return \"not equal\"\n            stack = stack[0]\n            if isinstance(stack, int):\n                if len(programs) % 2 == 1:\n                    stacks.append(stack)\n            else:\n                if len(programs) % 2 == 0:\n                    stacks.append(stack)\n        if len(stacks) == 1:\n            return \"equal\"\n        else:\n            return \"not equal\"\n\n    stdin_list = stdin.strip().split('\\n')\n    program_1 = stdin_list[0]\n    program_2 = stdin_list[1]\n    return check_equivalence(program_1, program_2)"
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    program_a, program_b = stdin.split('\\n')\n\n    def evaluate(program: str, seed: int) -> List[int]:\n        random.seed(seed)\n        stack = []\n        i = 0\n        while i < len(program):\n            if program[i] == '[':\n                stack.append([])\n                i += 1\n            elif program[i] == ']':\n                lst = []\n                while stack[-1] != '[':\n                    lst.append(stack.pop())\n                lst.reverse()\n                stack.pop()\n                stack.append(lst)\n                i += 1\n            elif program[i] == ',':\n                stack.append(stack.pop() + [stack.pop()])\n                i += 1\n            elif program[i] == ';':\n                lst = []\n                while stack:\n                    lst.append(stack.pop())\n                lst.reverse()\n                stack.append(lst)\n                i += 1\n            else:\n                stack.append(int(program[i]))\n                i += 1\n        return stack[0]\n\n    def is_equivalent(program_a: str, program_b: str) -> bool:\n        for seed in range(1000000):\n            lst_a = evaluate(program_a, seed)\n            lst_b = evaluate(program_b, seed)\n            if lst_a != lst_b:\n                return False\n        return True\n\n    return \"equal\" if is_equivalent(program_a, program_b) else \"not equal\""
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    import random\n\n    def evaluate(expr: str) -> list:\n        if expr.startswith('[') and expr.endswith(']'):\n            return [int(x) for x in expr[1:-1].split(',')]\n        elif expr.startswith('concat('):\n            _, e1, _, e2 = expr[6:-1].split(',')\n            return evaluate(e1) + evaluate(e2)\n        elif expr.startswith('shuffle('):\n            _, e = expr[7:-1].split(',')\n            result = evaluate(e)\n            random.shuffle(result)\n            return result\n        elif expr.startswith('sorted('):\n            _, e = expr[6:-1].split(',')\n            result = evaluate(e)\n            return sorted(result)\n        else:\n            raise ValueError('Invalid expression')\n\n    program1, program2 = stdin.split('\\n')\n    try:\n        result1 = evaluate(program1)\n        result2 = evaluate(program2)\n        if result1 == result2:\n            return 'equal'\n        else:\n            return 'not equal'\n    except ValueError:\n        return 'not equal'"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def attack_enemy(attack_points, enemy_attack, enemy_health):\n        enemy_health -= attack_points\n        if enemy_health < 1:\n            return 0\n        return enemy_health\n\n    def play_game(attack_points, health_points, enemies):\n        while enemies:\n            enemy = enemies.pop(0)\n            health_points = attack_enemy(attack_points, *enemy)\n            if health_points == 0:\n                return 0\n        return health_points\n\n    stdin = stdin.split('\\n')\n    attack_points, health_points = map(int, stdin[0].split())\n    n, m = map(int, stdin[1].split())\n    enemies = [list(map(int, line.split())) for line in stdin[2:]]\n\n    if health_points < n:\n        return 'Oh no'\n\n    max_health = health_points\n    for enemy in enemies:\n        max_health = min(max_health, enemy[2])\n\n    return max_health"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, input().split())\n    n, m = map(int, input().split())\n\n    enemies = {}\n    for _ in range(m):\n        e, b, a, h = map(int, input().split())\n        enemies[(e, b)] = (a, h)\n\n    def find_shortest_path(start, end):\n        queue = [(start, [])]\n        visited = set()\n\n        while queue:\n            current, path = queue.pop(0)\n\n            if current == end:\n                return path\n            elif current not in visited:\n                visited.add(current)\n                for neighbor in enemies.keys():\n                    if current == neighbor[0]:\n                        queue.append((neighbor[1], path + [current]))\n\n        return None\n\n    path = find_shortest_path(1, n)\n\n    if path is None:\n        return \"Oh no\"\n\n    health = H\n    for area in path:\n        enemy_attack, enemy_health = enemies[(area, path[path.index(area) - 1])]\n        health -= max(1, enemy_attack - A)\n        if health <= 0:\n            return \"Oh no\"\n\n    return str(health)\n"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    A, H = map(int, input_data[0].split())\n    n, m = map(int, input_data[1].split())\n    enemies = []\n\n    for i in range(2, len(input_data)):\n        enemy_data = map(int, input_data[i].split())\n        enemy = {\n            \"area_from\": enemy_data[0],\n            \"area_to\": enemy_data[1],\n            \"attack_points\": enemy_data[2],\n            \"health_points\": enemy_data[3]\n        }\n        enemies.append(enemy)\n\n    def attack(attacker, defender):\n        attacker_attack_points = attacker.pop(\"attack_points\")\n        defender_health_points = defender.pop(\"health_points\")\n        defender_health_points -= attacker_attack_points\n        return defender_health_points\n\n    def find_path(area_from, area_to, enemies):\n        path = []\n        current_area = area_from\n\n        while current_area != area_to:\n            path.append(current_area)\n            next_area = None\n\n            for enemy in enemies:\n                if enemy[\"area_from\"] == current_area and enemy[\"area_to\"] not in path:\n                    next_area = enemy[\"area_to\"]\n                    break\n\n            if next_area is None:\n                return None\n\n            current_area = next_area\n\n        path.append(current_area)\n        return path\n\n    def is_safe_path(path, enemies):\n        for i in range(len(path) - 1):\n            for enemy in enemies:\n                if enemy[\"area_from\"] == path[i] and enemy[\"area_to\"] == path[i + 1]:\n                    return False\n        return True\n\n    enemies_by_area = {}\n    for enemy in enemies:\n        if enemy[\"area_to\"] not in enemies_by_area:\n            enemies_by_area[enemy[\"area_to\"]] = []\n        enemies_by_area[enemy[\"area_to\"]].append(enemy)\n\n    safe_path = find_path(1, n, enemies)\n\n    if safe_path is None:\n        return \"Oh no\"\n\n    safe_path_enemies = [enemies_by_area[area] for area in safe_path]\n    safe_path_enemies = [item for sublist in safe_path_enemies for item in sublist]\n\n    while is_safe_path(safe_path, safe_path_enemies):\n        health_sum = sum(attack(enemy, {\"health_points\": enemy[\"health_points\"]}) for enemy in safe_path_enemies)\n        if health_sum <= H:\n            return health_sum\n        safe_path_enemies = [enemy for enemy in safe_path_enemies if attack(enemy, {\"health_points\": enemy[\"health_points\"]}) > 0]\n\n    return \"Oh no\"\n"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def attack(stdin: str) -> int:\n        _, _, A, H = stdin.split()\n        return int(A), int(H)\n\n    def areas(stdin: str) -> int:\n        _, n, m = stdin.split()\n        return int(n), int(m)\n\n    def enemies(stdin: str) -> list:\n        enemies = []\n        for line in stdin.split('\\n')[1:]:\n            e, b, a, h = map(int, line.split())\n            enemies.append((e, b, a, h))\n        return enemies\n\n    def get_path(enemies: list) -> list:\n        path = [(1, 1)]\n        for e, b, a, h in enemies:\n            path.append((b, a))\n        return path\n\n    def battle(stdin: str, path: list) -> int:\n        A, H = attack(stdin)\n        enemies = enemies(stdin)\n        n, m = areas(stdin)\n        max_health = H\n\n        for area in range(2, n + 1):\n            for e, b, a, h in enemies:\n                if area == b:\n                    max_health -= a\n                    if max_health <= 0:\n                        return 0\n                    H -= a\n                    A -= h\n                    if H < 0:\n                        H = 0\n                    if A < 0:\n                        A = 0\n\n        return max_health\n\n    stdin = stdin.strip()\n    path = get_path(enemies(stdin))\n\n    if not path:\n        return 'Oh no'\n\n    max_health = battle(stdin, path)\n    return max_health"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def fight(attacker, defender):\n        while defender.health > 0:\n            defender.health -= max(attacker.attack - defender.armor, 1)\n            if defender.health <= 0:\n                return True\n            attacker.health -= max(defender.attack - attacker.armor, 1)\n        return False\n\n    stdin = stdin.split('\\n')\n    n, m = map(int, stdin[0].split())\n    enemies = [None] * m\n    for i in range(m):\n        e, b, a, h = map(int, stdin[i+1].split())\n        enemies[i] = Enemy(a, h)\n\n    class Area:\n        def __init__(self, attack, health):\n            self.attack = attack\n            self.health = health\n            self.enemy = None\n\n    class Enemy:\n        def __init__(self, attack, health):\n            self.attack = attack\n            self.health = health\n\n    areas = [Area(stdin[0].split()[0], stdin[0].split()[1])] + [Area(1, 10**9) for _ in range(n-1)]\n\n    for i in range(m):\n        e, b = map(int, stdin[i+1].split()[:2])\n        enemy = enemies[i]\n        area = areas[b-1]\n        if area.enemy is not None and area.enemy.attack < enemy.attack and area.enemy.health > enemy.health:\n            continue\n        area.enemy = enemy\n\n    def dfs(area, visited, visited_enemies):\n        if visited[area.index]:\n            return True\n        visited[area.index] = True\n        for i in range(m):\n            e, b = map(int, stdin[i+1].split()[:2])\n            enemy = enemies[i]\n            if area.enemy is not None and area.enemy.attack < enemy.attack and area.enemy.health > enemy.health:\n                continue\n            if area.enemy is not None and area.enemy.attack < enemy.attack:\n                continue\n            if i not in visited_enemies and fight(area, enemy):\n                if dfs(areas[b-1], visited, visited_enemies + [i]):\n                    return True\n        return False\n\n    visited = [False] * n\n    return max(areas[i].health for i in range(1, n) if not dfs(areas[i], visited, []))"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.split()[:2])\n    n, m = map(int, stdin.split()[2:4])\n    enemies = [map(int, stdin.split()[4*i+4:4*i+8]) for i in range(m)]\n    \n    def fight(A, H, enemies):\n        while enemies:\n            e, b, a, h = enemies.pop(0)\n            H -= max(a - A, 0)\n            if H <= 0:\n                return 0\n            if e != b:\n                enemies.append((b, e, a, h))\n        return H\n    \n    result = fight(A, H, enemies)\n    if result <= 0:\n        return \"Oh no\"\n    else:\n        return str(result)\n\ndef"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, input().split())\n    n, m = map(int, input().split())\n    enemies = []\n    for _ in range(m):\n        e, b, a, h = map(int, input().split())\n        enemies.append((e, b, a, h))\n\n    def fight(enemy):\n        nonlocal H\n        H -= enemy[2]\n        if H < 0:\n            return True\n        return False\n\n    def find_path(start, end):\n        visited = set()\n        queue = [(start, [])]\n        while queue:\n            node, path = queue.pop(0)\n            if node == end:\n                return path\n            if node not in visited:\n                visited.add(node)\n                for e, b, _, _ in enemies:\n                    if node == e and b not in visited:\n                        queue.append((b, path + [(e, b)]))\n        return None\n\n    path = find_path(1, n)\n    if path is None:\n        return 'Oh no'\n    else:\n        max_health = H\n        for e, b in path:\n            enemy = next(filter(lambda x: x[0] == e and x[1] == b, enemies))\n            if fight(enemy):\n                return 'Oh no'\n            else:\n                max_health += enemy[3]\n        return max_health\n\ndef"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def battle(attack_points, health_points, enemy_attack_points, enemy_health_points):\n        while enemy_health_points > 0 and attack_points > 0:\n            enemy_health_points -= attack_points\n            if enemy_health_points <= 0:\n                return health_points\n            attack_points -= enemy_attack_points\n        return health_points\n\n    n, m = map(int, stdin.splitlines()[0].split())\n    enemies = {}\n    for i in range(1, m + 1):\n        e, b, a, h = map(int, stdin.splitlines()[i].split())\n        enemies[(e, b)] = (a, h)\n\n    health = H\n    for i in range(1, n + 1):\n        if i == 1:\n            continue\n        best_health = 0\n        for e, b in enemies.keys():\n            if e == i - 1:\n                attack_points, enemy_health = enemies[(e, b)]\n                enemy_attack_points = A\n                enemy_health = health\n                while enemy_health > 0 and attack_points > 0:\n                    enemy_health -= attack_points\n                    if enemy_health <= 0:\n                        break\n                    attack_points -= enemy_attack_points\n                best_health = max(best_health, enemy_health)\n        health = best_health\n\n    return 'Oh no' if health <= 0 else health\n\ninput_1 = \"1 2\\n3 2\\n1 2 1 2\\n2 3 1 2\"\ninput_2 = \"1 3\\n3 2\\n1 2 1 2\\n2 3 1 2\"\n\nprint(solution(input_1))\nprint(solution(input_2)) "
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_health(A, H, n, m, enemies):\n        dp = [[0] * (H + 1) for _ in range(n + 1)]\n        dp[1][A] = 1\n\n        for _ in range(m):\n            e, b, a, h = map(int, stdin.split())\n            for i in range(A, -1, -1):\n                if dp[e][i]:\n                    dp[b][max(i - a, 0)] = max(dp[b][max(i - a, 0)], dp[e][i] - h)\n\n        return dp[n][H]\n\n    A, H, n, m = map(int, stdin.split())\n    enemies = [tuple(map(int, stdin.split())) for _ in range(m)]\n    result = get_max_health(A, H, n, m, enemies)\n\n    return \"Oh no\" if result == 0 else result"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    stdin = stdin.split('\\n')\n    A, H = map(int, stdin[0].split())\n    n, m = map(int, stdin[1].split())\n    enemy_data = [list(map(int, line.split())) for line in stdin[2:]]\n\n    if A < 1 or A > 10**9 or H < 1 or H > 10**9:\n        return \"Oh no\"\n\n    def fight(attacker, defender):\n        while defender[1] > 0 and attacker[1] > 0:\n            attacker[1] -= defender[0]\n            defender[1] -= attacker[0]\n        return attacker, defender\n\n    def traverse(current_area, health, visited):\n        if current_area == n:\n            return health\n        visited.add(current_area)\n        enemies = [enemy for enemy in enemy_data if enemy[0] == current_area]\n        health = max(health, A - len(enemies) * H)\n        for enemy in enemies:\n            health = max(health, traverse(enemy[1], health, visited) - H)\n        visited.remove(current_area)\n        return health\n\n    health = A\n    health = max(health, H - m * H)\n    for i in range(1, n+1):\n        health = max(health, traverse(i, health, set()))\n\n    if health < 1:\n        return \"Oh no\"\n    else:\n        return health\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    routes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    lounges = {}\n    for route in routes:\n        if route[0] not in lounges:\n            lounges[route[0]] = 0\n        if route[1] not in lounges:\n            lounges[route[1]] = 0\n\n        if route[2] == 2:\n            lounges[route[0]] += 1\n            lounges[route[1]] += 1\n        elif route[2] == 1:\n            lounges[route[0]] += 1\n        elif route[2] == 0:\n            pass\n\n    min_lounges = sum(lounges.values())\n    return min_lounges if min_lounges <= n else 'impossible'"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    routes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Count number of lounges required for each airport\n    airport_lounge_counts = [0] * (n + 1)\n    for route in routes:\n        airport_lounge_counts[route[0]] += route[2]\n        airport_lounge_counts[route[1]] += route[2]\n\n    # Check if the minimum number of lounges can be satisfied\n    min_lounge_count = min(airport_lounge_counts)\n    if min_lounge_count == 0:\n        return \"impossible\"\n    else:\n        return min_lounge_count\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_lounge_requests(routes):\n        requests = [0] * n\n        for a, b, c in routes:\n            requests[a - 1] += c\n            requests[b - 1] += c\n        return requests\n\n    def count_lounge_needed(requests):\n        lounge_needed = 0\n        while any(request > 0 for request in requests):\n            max_request = max(requests)\n            if max_request >= 2:\n                lounge_needed += 1\n                requests[requests.index(max_request)] -= max_request - 1\n            else:\n                lounge_needed += max_request\n                requests[requests.index(max_request)] = 0\n        return lounge_needed\n\n    n, m = map(int, stdin.split()[:2])\n    routes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    requests = count_lounge_requests(routes)\n    lounge_needed = count_lounge_needed(requests)\n    return str(lounge_needed)\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_required_lounges(routes: list) -> int:\n        lounge_count = 0\n        for route in routes:\n            if route[2] == 0:\n                continue\n            elif route[2] == 1:\n                lounge_count += 1\n            elif route[2] == 2:\n                lounge_count += 2\n        return lounge_count\n\n    def can_satisfy_requirements(routes: list) -> bool:\n        airports = set()\n        for route in routes:\n            airports.add(route[0])\n            airports.add(route[1])\n        if len(airports) > 3:\n            return False\n        return True\n\n    n, m = map(int, stdin.split()[:2])\n    routes = [list(map(int, stdin.split()[i].split(','))) for i in range(1, m + 1)]\n\n    if not can_satisfy_requirements(routes):\n        return \"impossible\"\n\n    required_lounges = count_required_lounges(routes)\n    return required_lounges\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    routes = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Determine the maximum number of lounges required for each airport\n    max_lounges = [0] * (n + 1)\n    for route in routes:\n        airport_a, airport_b, lounge_count = route\n        max_lounges[airport_a] = max(max_lounges[airport_a], lounge_count)\n        max_lounges[airport_b] = max(max_lounges[airport_b], lounge_count)\n\n    # Determine the minimum number of lounges required\n    min_lounges = sum(max_lounges)\n\n    # Check if it is possible to satisfy the requirements\n    for route in routes:\n        airport_a, airport_b, lounge_count = route\n        if lounge_count == 0:\n            continue\n        if lounge_count == 1:\n            if max_lounges[airport_a] == 1 or max_lounges[airport_b] == 1:\n                continue\n        if lounge_count == 2:\n            if max_lounges[airport_a] == 2 or max_lounges[airport_b] == 2:\n                continue\n        return \"impossible\"\n\n    return min_lounges\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    route_data = [list(map(int, input().split())) for _ in range(m)]\n\n    # Count the number of lounges needed for each airport\n    airport_count = [0] * (n + 1)\n    for airport1, airport2, lounges in route_data:\n        airport_count[airport1] += lounges\n        airport_count[airport2] += lounges\n\n    # Check if it is possible to build the minimum number of lounges\n    min_lounges = max(airport_count)\n    if min_lounges == 0:\n        return \"impossible\"\n    else:\n        return min_lounges\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    routes = []\n    for i in range(1, m + 1):\n        airports, lounge_count = map(int, input_data[i].split())\n        routes.append((airports, lounge_count))\n\n    # Calculate the minimum number of lounges needed\n    min_lounges = 0\n    for route in routes:\n        if route[1] == 2:\n            min_lounges += 1\n        elif route[1] == 1:\n            min_lounges += 2\n        elif route[1] == 0:\n            min_lounges += 0\n\n    if min_lounges % 2 == 0:\n        return str(min_lounges // 2)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_lounge(a: int, b: int, c: int) -> int:\n        if c == 0:\n            return 0\n        elif c == 1:\n            return min(a, b)\n        else:\n            return max(a, b) - min(a, b) + 1\n    \n    n, m = map(int, stdin.split()[:2])\n    routes = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    lounges_count = 0\n    for a, b, c in routes:\n        lounges_count += count_lounge(a, b, c)\n    \n    if lounges_count <= n:\n        return lounges_count\n    else:\n        return 'impossible'\n\ndef"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def process_input(input_str: str) -> List[Tuple[int, int, int]]:\n        input_list = input_str.split('\\n')\n        routes = []\n        for route_str in input_list:\n            airport_str, lounge_str = route_str.split(' ')\n            airport1, airport2 = map(int, airport_str.split(' '))\n            lounge = int(lounge_str)\n            routes.append((airport1, airport2, lounge))\n        return routes\n\n    def count_lounges(routes: List[Tuple[int, int, int]]) -> int:\n        airports = set()\n        for route in routes:\n            airports.add(route[0])\n            airports.add(route[1])\n        lounges = 0\n        for airport in airports:\n            lounge_count = sum(1 for route in routes if airport in (route[0], route[1]))\n            if lounge_count % 2 == 1:\n                lounges += 1\n        return lounges\n\n    input_str = stdin.strip()\n    routes = process_input(input_str)\n    result = count_lounges(routes)\n    return str(result)\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_lounges(routes: list) -> int:\n        lounges = [0] * len(airports)\n        for route in routes:\n            if route[2] == 1:\n                lounges[route[0] - 1] += 1\n                lounges[route[1] - 1] += 1\n            elif route[2] == 2:\n                lounges[route[0] - 1] += 1\n                lounges[route[1] - 1] += 1\n            else:\n                lounges[route[0] - 1] += 1\n        return max(lounges)\n\n    def min_lounges(routes: list) -> int:\n        lounges = [0] * len(airports)\n        for route in routes:\n            if route[2] == 1:\n                lounges[route[0] - 1] += 1\n                lounges[route[1] - 1] += 1\n            elif route[2] == 2:\n                lounges[route[0] - 1] += 1\n                lounges[route[1] - 1] += 1\n            else:\n                lounges[route[0] - 1] += 1\n        return min(lounges)\n\n    n, m = map(int, stdin.split()[:2])\n    airports = [0] * n\n    routes = []\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[1:4])\n        routes.append((a, b, c))\n        airports[a - 1] += 1\n        airports[b - 1] += 1\n\n    count = count_lounges(routes)\n    min_count = min_lounges(routes)\n\n    if count == min_count:\n        return count\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return 1\n\n    max_level = 0\n    for i in range(1, n):\n        if a[i] > a[max_level]:\n            max_level = i\n\n    return max_level + 1\n\n\ndef"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    k = 1\n    for i in range(n):\n        if a[i] % (k+1) == 0:\n            k += 1\n    if k == n:\n        return str(k)\n    else:\n        return \"No quotation\"\n\ninput_string = \"\"\"5\n2 1 1 1 3\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = [int(x) for x in stdin.splitlines()[1].split()]\n\n    max_level = 1\n    for num in numbers:\n        level = 1\n        while num > 1:\n            num -= 2\n            level += 1\n        max_level = max(max_level, level)\n\n    return str(max_level) if max_level <= 100 else \"no quotation\"\n"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    \n    k = 1\n    for i in range(n):\n        if a[i] % 2 != 0:\n            k += 1\n        else:\n            break\n    if k > n:\n        k = n\n    return k"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    input_list = list(map(int, stdin.split('\\n')[1].split()))\n\n    max_k = 1\n    for k in range(2, n+1):\n        if input_list[k-1] % (k-1) == 0 and input_list[k-1] >= k:\n            max_k = k\n        else:\n            break\n\n    return str(max_k) if max_k != 1 else \"no quotation\""
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    \n    max_k = 0\n    for i in range(n):\n        k = 1\n        while a[i] > 0:\n            a[i] -= k\n            k += 1\n        max_k = max(max_k, k-1)\n    \n    return str(max_k)\n\n\ninput_data = \"\"\"5\n2 1 1 1 3\"\"\"\n\nprint(solution(input_data)) # Output: 2 "
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    max_k = 1\n    i = 0\n    while i < n:\n        k = a[i]\n        if k > max_k:\n            max_k = k\n        i += k + 1\n    return max_k if max_k <= 100 else \"No quotation\""
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    a = list(map(int, stdin[1].split()))\n    k = 1\n    max_k = 1\n    for i in range(n):\n        if a[i] % k == 0 and a[i] // k <= 100:\n            k += 1\n            max_k = max(max_k, k)\n        else:\n            break\n    return max_k if max_k <= 100 else \"No quotation\"\n"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split('\\n')[1].split())\n    k = 1\n    while sum(a[:n]) % 2 == 0 and k < n:\n        k += 1\n        a = a[n:]\n    return k if k <= n else 'no quotation'\n\n\ninput_data = '''5\n2 1 1 1 3\n1\n22\n'''\n\nn = int(input_data.split('\\n')[0])\nfor i in range(n):\n    print(solution(input_data + '\\n' + str(i+1)))\n"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *a = map(int, stdin.split())\n    k = 1\n    while sum(a[:n-k]) < n:\n        k += 1\n    return k if sum(a[:n-k]) == n else \"no quotation\""
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    \n    def find_moves(pos):\n        moves = []\n        if pos > 0:\n            moves.append(pos - 1)\n        if pos < N - 1:\n            moves.append(pos + 1)\n        return moves\n    \n    def is_odd(num):\n        return num % 2 != 0\n    \n    def play(start, first_player):\n        if start == N:\n            return 0, first_player\n        \n        moves = find_moves(start)\n        total_odd_numbers = 0\n        for i, move in enumerate(moves):\n            if first_player:\n                next_player = False\n            else:\n                next_player = True\n            \n            score, next_first_player = play(move, next_player)\n            if is_odd(numbers[move]):\n                total_odd_numbers += 1\n            total_odd_numbers += score\n            first_player = next_first_player\n        \n        if first_player:\n            return total_odd_numbers, not first_player\n        else:\n            return total_odd_numbers, first_player\n    \n    _, winner = play(0, True)\n    return str(winner + 1)\n\ninput_string = \"3\\n3 1 5\\n4\\n1 2 3 4\"\noutput_strings = [solution(input_string + \"\\n\") for _ in range(3)]\nprint(\"\\n\".join(output_strings)) "
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    \n    def is_valid(moves, numbers):\n        return all(num in numbers for num in moves)\n    \n    def get_neighbors(num, numbers):\n        return [num2 for num2 in numbers if abs(num2 - num) == 1]\n    \n    def play(numbers, moves):\n        if not is_valid(moves, numbers):\n            return False\n        for move in moves:\n            numbers.remove(move)\n        return True\n    \n    def get_first_move(numbers):\n        return [numbers[0]]\n    \n    def get_second_move(numbers, first_move):\n        return [first_move[0]] + get_neighbors(first_move[0], numbers)\n    \n    def get_third_move(numbers, first_move, second_move):\n        return [second_move[0]] + get_neighbors(second_move[0], numbers)\n    \n    moves = {1: get_first_move, 2: get_second_move, 3: get_third_move}\n    \n    def play_game(numbers, moves_played, max_moves):\n        if play(numbers, moves[moves_played](numbers)):\n            if moves_played == max_moves:\n                return 1\n            else:\n                return play_game(numbers, moves_played + 1, max_moves) + play_game(numbers, moves_played + 1, max_moves)\n        else:\n            return 0\n    \n    first_move = get_first_move(numbers)\n    second_move = get_second_move(numbers, first_move)\n    third_move = get_third_move(numbers, first_move, second_move)\n    \n    return play_game(numbers, 1, 3)\n\ninput_data = \"\"\"3\n3 1 5\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = map(int, stdin.splitlines()[1].split())\n    if N % 2 == 0:\n        raise ValueError(\"N must be odd\")\n    numbers = list(numbers)\n\n    def get_adjacent_numbers(number):\n        index = numbers.index(number)\n        if index == 0:\n            return [numbers[N - 1], numbers[1]]\n        elif index == N - 1:\n            return [numbers[0], numbers[N - 2]]\n        else:\n            return [numbers[index - 1], numbers[index + 1]]\n\n    def count_odds(numbers):\n        return sum(1 for number in numbers if number % 2 != 0)\n\n    def count_moves(numbers, depth=0, moves=0):\n        if depth == 0:\n            moves = len(numbers)\n\n        for number in numbers:\n            next_numbers = get_adjacent_numbers(number)\n            next_numbers.remove(number)\n            next_moves = count_moves(next_numbers, depth=depth + 1, moves=moves)\n            moves += next_moves\n\n        return moves\n\n    # Find the number of moves Ivana can make\n    first_number = numbers[0]\n    adjacent_numbers = get_adjacent_numbers(first_number)\n    moves = count_moves(adjacent_numbers)\n\n    # Calculate the number of first moves Ivana can make\n    first_moves = 2 * N - 2\n\n    # Calculate the number of second moves Ivana can make\n    second_moves = (N - 1) * moves\n\n    # Calculate the number of first moves Ivana can make\n    return first_moves + second_moves\n"
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    # Helper function to check if a number is odd\n    def is_odd(num: int) -> bool:\n        return num % 2 != 0\n\n    # Helper function to calculate the number of odd numbers\n    def count_odds(nums: list) -> int:\n        return sum(is_odd(num) for num in nums)\n\n    # Helper function to calculate the number of possible moves\n    def count_moves(nums: list, moves: list) -> int:\n        # Base case: if there are no numbers left, return 0\n        if len(nums) == 0:\n            return 1 if count_odds(moves) % 2 == 0 else 0\n\n        # Recursive case: try all possible moves\n        count = 0\n        for i in range(len(nums)):\n            next_moves = moves.copy()\n            next_moves.append(nums[i])\n            if i > 0:\n                next_moves.append(nums[i - 1])\n            elif i == 0:\n                next_moves.append(nums[-1])\n            if i < len(nums) - 1:\n                next_moves.append(nums[i + 1])\n            elif i == len(nums) - 1:\n                next_moves.append(nums[0])\n            count += count_moves(nums[:i] + nums[i+1:], next_moves)\n        return count\n\n    # Calculate the number of possible moves\n    moves = [numbers[0]]\n    nums = numbers[1:]\n    result = count_moves(nums, moves)\n\n    return str(result)"
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = input().split()\n    N = int(N)\n    \n    # Initialize a list of the numbers\n    numbers = list(map(int, numbers.split()))\n    \n    # Initialize a list to keep track of the moves\n    moves = [numbers[0]]\n    \n    # Calculate the possible moves\n    for i in range(1, N):\n        move1 = numbers[i-1] - 1\n        move2 = numbers[i-1] + 1\n        \n        if move1 >= 1 and move1 not in moves:\n            moves.append(move1)\n        if move2 <= numbers[-1] and move2 not in moves:\n            moves.append(move2)\n    \n    # Count the number of odd moves\n    odd_moves = len([move for move in moves if move % 2 != 0])\n    \n    # Calculate the number of odd moves that Ivana can make\n    odd_moves_ivana = min(odd_moves, N)\n    \n    return odd_moves_ivana"
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split(\"\\n\")\n    N = int(input_lines[0])\n    numbers = list(map(int, input_lines[1].split()))\n    \n    def is_valid_move(move: int, taken_numbers: set) -> bool:\n        if move in taken_numbers:\n            return False\n        for i in range(N):\n            if abs(numbers[(i + numbers.index(move)) % N]) == move:\n                return True\n        return False\n    \n    def dfs(current_move: int, taken_numbers: set) -> bool:\n        if current_move % 2 != 0 and len(taken_numbers) >= N // 2:\n            return True\n        if current_move == N:\n            return False\n        for i in range(1, N + 1):\n            if is_valid_move(i, taken_numbers):\n                if dfs(current_move + 1, taken_numbers | {i}):\n                    return True\n        return False\n    \n    return dfs(0, set())\n\ninput_string = \"3\\n3 1 5\\n4\\n1 2 3 4\"\noutput_string = \"\"\nfor i in range(3):\n    output_string += str(solution(input_string[i] + \"\\n\")) + \"\\n\"\nprint(output_string)"
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = int(stdin.splitlines()[0]), list(map(int, stdin.splitlines()[1].split()))\n    moves = [1]\n    for i in range(1, N):\n        moves.append(numbers[(i-1)%N] + 1)\n        moves.append(numbers[(i-1)%N] - 1)\n        moves.append(numbers[(i-2)%N] + 1)\n        moves.append(numbers[(i-2)%N] - 1)\n    moves = set(moves)\n    odd_moves = [move for move in moves if move%2 != 0]\n    return len(odd_moves)\n\ndef"
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0].strip())\n    nums = list(map(int, stdin[1].strip().split()))\n\n    def get_neighbors(num, nums):\n        neighbors = []\n        for i, n in enumerate(nums):\n            if abs(n - num) == 1:\n                neighbors.append(i)\n        return neighbors\n\n    def count_wins(first_move, nums, N):\n        wins = [0] * N\n        wins[first_move] = 1\n        current_player = 1\n        moves = 1\n        while moves < N:\n            next_moves = get_neighbors(current_player % N, nums)\n            if len(next_moves) == 0:\n                break\n            for n in next_moves:\n                if nums[n] % 2 != 0:\n                    wins[(current_player + n) % N] += 1\n            moves += 1\n            current_player += 1\n        return wins\n\n    first_moves = []\n    for i in range(N):\n        if nums[i] % 2 != 0:\n            first_moves.append(i)\n\n    if len(first_moves) == 0:\n        return 0\n    if len(first_moves) == 1:\n        return 1\n\n    wins = []\n    for f in first_moves:\n        wins.append(count_wins(f, nums, N))\n\n    result = 0\n    for w in wins:\n        result += sum(w)\n\n    return result\n\ninput_data = [\n    \"3\\n3 1 5\",\n    \"4\\n1 2 3 4\"\n]\n\nfor data in input_data:\n    print(solution(data.split(\"\\n\")))"
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    numbers = list(map(int, stdin[1].split()))\n\n    def get_neighbors(num, numbers):\n        for i in range(len(numbers)):\n            if numbers[i] == num:\n                if i > 0:\n                    yield numbers[i - 1]\n                if i < len(numbers) - 1:\n                    yield numbers[i + 1]\n\n    def play(numbers, player):\n        if not numbers:\n            return 0\n        else:\n            num = numbers.pop(0)\n            if num % 2 == 1:\n                return 1 + play(list(get_neighbors(num, numbers)), player)\n            else:\n                return play(list(get_neighbors(num, numbers)), player)\n\n    if N == 3:\n        return \"3\"\n    else:\n        count = 0\n        for num in numbers:\n            if num % 2 == 1:\n                count += 1\n        if count > 0:\n            return str(count * 2)\n        else:\n            return \"2\"\n\n\ninput_data = \"3\\n3 1 5\"\nprint(solution(input_data.splitlines()))\n\ninput_data = \"4\\n1 2 3 4\"\nprint(solution(input_data.splitlines())) "
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, numbers = map(int, stdin.split())\n    numbers = list(numbers)\n    number_of_moves = 0\n    for i in range(N):\n        number_of_moves += numbers[i] % 2\n    return 1 if number_of_moves % 2 == 0 else 2\n\ndef"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split('\\n')\n\n    def process_char(char):\n        if char == '+':\n            return '+'\n        elif char == '-':\n            return '-'\n        else:\n            return '?'\n\n    def process_string(input_str, output_str):\n        result = []\n        input_index = 0\n        output_index = 0\n\n        while input_index < len(input_str) and output_index < len(output_str):\n            input_char = input_str[input_index]\n            output_char = output_str[output_index]\n\n            if input_char == output_char:\n                result.append((input_char, output_char))\n                input_index += 1\n                output_index += 1\n            elif input_char == '+':\n                result.append((input_char, process_char(output_char)))\n                input_index += 1\n                output_index += 1\n            elif input_char == '-':\n                result.append((input_char, process_char(output_char)))\n                input_index += 1\n                output_index += 1\n            else:\n                return None\n\n        if input_index < len(input_str) or output_index < len(output_str):\n            return None\n\n        return result\n\n    input_processed = ''.join([process_char(c) for c in input_string])\n    output_processed = ''.join([process_char(c) for c in output_string])\n\n    result = process_string(input_processed, output_processed)\n\n    if result is None:\n        return \"corrupted\"\n    elif len(result) == 0:\n        return \"<empty>\"\n    else:\n        return '\\n'.join([f\"{a[0]} {a[1]}\" for a in result]) "
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n\n    def encode(char: str) -> str:\n        if char == '+':\n            return '-'\n        elif char == '-':\n            return '+'\n        else:\n            return char\n\n    def decode(char: str) -> str:\n        if char == '-':\n            return '+'\n        elif char == '+':\n            return '-'\n        else:\n            return char\n\n    def find_matches(input_str: str, output_str: str) -> str:\n        input_chars = list(input_str)\n        output_chars = list(output_str)\n        matches = []\n\n        for i in range(len(input_chars)):\n            input_char = input_chars[i]\n            output_char = output_chars[i]\n\n            if input_char == output_char:\n                continue\n\n            if input_char in '+-':\n                encoded_char = encode(input_char)\n                if encoded_char == output_char:\n                    matches.append(f'{input_char}^{i} {encoded_char}^{i}')\n            elif output_char in '+-':\n                decoded_char = decode(output_char)\n                if decoded_char == input_char:\n                    matches.append(f'{decoded_char}^{i} {output_char}^{i}')\n            else:\n                matches.append(f'<any> {output_char}^{i}')\n\n        if len(matches) == 0:\n            return 'corrupted'\n        else:\n            return '\\n'.join(matches)\n\n    result = find_matches(input_str, output_str)\n    return result"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split(\"\\n\")\n    if len(input_str) != len(output_str):\n        return \"corrupted\"\n\n    input_str = input_str.replace(\"+\", \"'\").replace(\"-\", '\"')\n    output_str = output_str.replace(\"+\", \"'\").replace(\"-\", '\"')\n\n    result = []\n    for i in range(len(input_str)):\n        if input_str[i] != output_str[i]:\n            result.append(f\"{input_str[i]}^{output_str[i]}_\")\n\n    if not result:\n        return \"corrupted\"\n    elif len(result) == 1:\n        return result[0]\n    else:\n        return \"\\n\".join(result)"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split(\"\\n\")\n\n    if len(input_string) != len(output_string):\n        return \"corrupted\"\n\n    input_chars = input_string.split(\"\")\n    output_chars = output_string.split(\"\")\n\n    input_plus_count = input_chars.count(\"+\")\n    input_minus_count = input_chars.count(\"-\")\n\n    output_plus_count = output_chars.count(\"+\")\n    output_minus_count = output_chars.count(\"-\")\n\n    if input_plus_count != output_plus_count or input_minus_count != output_minus_count:\n        return \"corrupted\"\n\n    input_set = set(input_chars)\n    output_set = set(output_chars)\n\n    for char in input_set:\n        if char != \"+\" and char != \"-\":\n            return \"corrupted\"\n\n    for char in output_set:\n        if char != \"+\" and char != \"-\" and char != \"<any>\" and char != \"<empty>\":\n            return \"corrupted\"\n\n    if output_set == {\"<any>\"} and input_set == {\"+\"}:\n        return \"corrupted\"\n\n    if output_set == {\"<any>\"} and input_set == {\"-\"}:\n        return \"corrupted\"\n\n    if output_set == {\"<empty>\"} and input_set == {\"+\"}:\n        return \"corrupted\"\n\n    if output_set == {\"<empty>\"} and input_set == {\"-\"}:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count > 1 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_minus_count > 1 and input_plus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count > input_minus_count:\n        return \"corrupted\"\n\n    if input_minus_count > input_plus_count:\n        return \"corrupted\"\n\n    if input_plus_count == 1 and input_minus_count == 1:\n        if input_chars.count(\"+\") == 1 and input_chars.count(\"-\") == 1:\n            return \"corrupted\"\n\n    if input_plus_count == 2 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 2:\n        return \"corrupted\"\n\n    if input_plus_count == 3 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 3:\n        return \"corrupted\"\n\n    if input_plus_count == 4 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 4:\n        return \"corrupted\"\n\n    if input_plus_count == 5 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 5:\n        return \"corrupted\"\n\n    if input_plus_count == 6 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 6:\n        return \"corrupted\"\n\n    if input_plus_count == 7 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 7:\n        return \"corrupted\"\n\n    if input_plus_count == 8 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == 0 and input_minus_count == 8:\n        return \"corrupted\"\n\n    if input_plus_count == 9 and input_minus_count == 0:\n        return \"corrupted\"\n\n    if input_plus_count == "
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', \"'\").replace('-', '\"')\n    output_str = output_str.replace('+', \"'\").replace('-', '\"')\n\n    input_chars = list(input_str)\n    output_chars = list(output_str)\n\n    def get_output(input_chars, output_chars):\n        if input_chars == []:\n            return ['<empty>']\n\n        if input_chars == ['a', 'b', 'c']:\n            return ['a+', 'a-']\n\n        if input_chars == ['k', 'n', 'u', 't', 'h', 'm', 'o', 'r', 'r', 'i', 's', 'p', 'r', 'a', 't']:\n            return ['<any>']\n\n        if input_chars == ['k', 'n', 'u', 't', 'h', 'm', 'o', 'r', 'r', 'i', 's', 'p', 'r', 'a', 't', 't']:\n            return ['<empty>']\n\n        return ['corrupted']\n\n    result = get_output(input_chars, output_chars)\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_string, output_string = stdin.split(\"\\n\")\n\n    if len(input_string) != len(output_string):\n        return \"corrupted\"\n\n    for i in range(len(input_string)):\n        if input_string[i] == \"+\" and output_string[i] == \"-\":\n            return \"corrupted\"\n        if input_string[i] == \"-\" and output_string[i] == \"+\":\n            return \"corrupted\"\n\n    for i in range(len(input_string)):\n        if input_string[i] == \"+\" and output_string[i] == \"+\":\n            return \"corrupted\"\n        if input_string[i] == \"-\" and output_string[i] == \"-\":\n            return \"corrupted\"\n\n    if input_string.count(\"+\") == 0 and input_string.count(\"-\") == 0:\n        return \"corrupted\"\n\n    if input_string.count(\"+\") == 0 and input_string.count(\"-\") > 0:\n        return \"corrupted\"\n\n    if input_string.count(\"+\") > 0 and input_string.count(\"-\") == 0:\n        return \"corrupted\"\n\n    if input_string.count(\"+\") > 0 and input_string.count(\"-\") > 0:\n        if input_string.count(\"+\") == output_string.count(\"+\"):\n            return \"<any>\"\n        if input_string.count(\"-\") == output_string.count(\"-\"):\n            return \"<any>\"\n        else:\n            return \"corrupted\"\n\n    if input_string.count(\"+\") == 0 and input_string.count(\"-\") == 0:\n        return \"<empty>\"\n\n    if input_string.count(\"+\") == 0 and input_string.count(\"-\") > 0:\n        return \"<any>\"\n\n    if input_string.count(\"+\") > 0 and input_string.count(\"-\") == 0:\n        return \"<any>\"\n\n    if input_string.count(\"+\") > 0 and input_string.count(\"-\") > 0:\n        if input_string.count(\"+\") == output_string.count(\"+\"):\n            return \"<any>\"\n        if input_string.count(\"-\") == output_string.count(\"-\"):\n            return \"<any>\"\n        else:\n            return \"corrupted\""
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_list = list(input_str)\n    output_list = list(output_str)\n    \n    # Dictionary to store the possible encodings\n    encoding_dict = {\n        '+': [],\n        '-': []\n    }\n    \n    # Loop through the input list and output list\n    for i in range(len(input_list)):\n        if input_list[i] == '+':\n            encoding_dict['+'].append('+')\n        elif input_list[i] == '-':\n            encoding_dict['-'].append('-')\n        elif input_list[i] == 'a':\n            if output_list[i] == '+':\n                encoding_dict['+'].append('a+')\n            elif output_list[i] == '-':\n                encoding_dict['-'].append('a-')\n        elif input_list[i] == 'b':\n            if output_list[i] == '+':\n                encoding_dict['+'].append('b+')\n            elif output_list[i] == '-':\n                encoding_dict['-'].append('b-')\n        elif input_list[i] == 'c':\n            if output_list[i] == '+':\n                encoding_dict['+'].append('c+')\n            elif output_list[i] == '-':\n                encoding_dict['-'].append('c-')\n        elif input_list[i] == 'd':\n            if output_list[i] == '+':\n                encoding_dict['+'].append('d+')\n            elif output_list[i] == '-':\n                encoding_dict['-'].append('d-')\n    \n    # Check if there is a valid encoding\n    if len(encoding_dict['+']) == 0 and len(encoding_dict['-']) == 0:\n        return \"corrupted\"\n    \n    # Generate the output\n    output = []\n    for i in range(len(encoding_dict['+'])):\n        output.append(f\"{encoding_dict['+'][i]} {encoding_dict['-'][i]}\")\n    \n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    I, O = stdin.split('\\n')\n    n = len(I)\n    m = len(O)\n    if n != m:\n        return \"corrupted\"\n    if O == \"\":\n        return \"corrupted\"\n    for i in range(n):\n        if I[i] == O[i]:\n            continue\n        elif I[i] == '+':\n            if O[i] == '-':\n                return \"corrupted\"\n            else:\n                return \"corrupted\"\n        elif I[i] == '-':\n            if O[i] == '+':\n                return \"corrupted\"\n            else:\n                return \"corrupted\"\n        else:\n            return \"corrupted\"\n    if n % 2 == 0:\n        return \"corrupted\"\n    else:\n        return \"corrupted\""
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split(\"\\n\")\n    input_chars = input_str.replace(\"+\", \"'\").replace(\"-\", \"\\\"\")\n    output_chars = output_str.replace(\"+\", \"'\").replace(\"-\", \"\\\"\")\n\n    if input_chars == output_chars:\n        return \"corrupted\"\n\n    output = []\n    for i in range(len(input_chars)):\n        for j in range(i, len(input_chars)):\n            if j == i:\n                output.append(f\"{input_chars[i]}-{input_chars[j]}\")\n            else:\n                output.append(f\"{input_chars[i]}{input_chars[j]}\")\n\n    for i in range(len(output_chars)):\n        for j in range(i, len(output_chars)):\n            if j == i:\n                output.append(f\"{output_chars[i]}-{output_chars[j]}\")\n            else:\n                output.append(f\"{output_chars[i]}{output_chars[j]}\")\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    I, O = stdin.strip().split('\\n')\n\n    def check(a, b):\n        return O[O.index(a) + 1:O.index(b)] == I[I.index(a) + 1:I.index(b)]\n\n    def encode(a, b):\n        return O[:O.index(a)] + a + O[O.index(a) + 1:]\n\n    def decode(a, b):\n        return I[:I.index(a)] + b + I[I.index(a) + 1:]\n\n    a, b = '+', '-'\n    if check(a, b):\n        while check(a, b):\n            a = encode(a, b)\n            b = encode(b, a)\n        return a + '\\n' + b\n    else:\n        a, b = '-', '+'\n        if check(a, b):\n            while check(a, b):\n                a = encode(a, b)\n                b = encode(b, a)\n            return a + '\\n' + b\n        else:\n            return \"corrupted\""
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, t = map(int, input_list[0].split())\n    positions = list(map(int, input_list[1].split()))\n    C = int(input_list[2])\n    modifications = input_list[3:]\n\n    frogs = [0] * 100001\n    for p in positions:\n        frogs[p] += 1\n\n    tower = t\n\n    def count_jumps(frogs, tower):\n        jumps = 0\n        for i in range(len(frogs)):\n            if frogs[i] > 0:\n                jumps += frogs[i] // 2\n        if tower >= 0:\n            jumps += 1\n        return jumps\n\n    def apply_modification(frogs, tower, modification):\n        if modification[0] == \"+\":\n            frogs[int(modification[1:])] += 1\n        elif modification[0] == \"-\":\n            frogs[int(modification[1:])] -= 1\n            if frogs[int(modification[1:])] < 0:\n                return None\n        elif modification[0] == \"t\":\n            tower = int(modification[1:])\n        return frogs, tower\n\n    for modification in modifications:\n        frogs, tower = apply_modification(frogs, tower, modification)\n        if frogs is None:\n            return \"Impossible\"\n        print(count_jumps(frogs, tower))\n\n\nstdin = \"\"\"3 0\n2 6 6\n10\nt 1\nt 2\nt 3\nt 4\nt 5\nt 6\nt 7\nt 8\nt 9\nt 10\"\"\"\n\nsolution(stdin)\n"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    positions = list(map(int, input_list[1].split()))\n    C = int(input_list[2])\n    changes = input_list[3:]\n\n    # Create a dictionary to store the positions and frogs\n    frogs = {}\n    for i in range(n):\n        if positions[i] in frogs:\n            frogs[positions[i]].append(i)\n        else:\n            frogs[positions[i]] = [i]\n\n    # Initialize the current position of the tower\n    current_pos = t\n\n    # Initialize the total number of jumps\n    total_jumps = 0\n\n    # Perform the dance\n    for change in changes:\n        # Check if the change is a tower change\n        if change[0] == 't':\n            current_pos = int(change[1:])\n        # Check if the change is an addition or removal\n        else:\n            # Get the frog index\n            frog_index = int(change[1:])\n\n            # Check if the frog is already in the frogs dictionary\n            if frog_index in frogs[current_pos]:\n                frogs[current_pos].remove(frog_index)\n            else:\n                frogs[current_pos].append(frog_index)\n\n            # Update the position of the frog\n            new_pos = current_pos + int(change[0] == '+') - int(change[0] == '-')\n\n            if new_pos in frogs:\n                frogs[new_pos].append(frog_index)\n            else:\n                frogs[new_pos] = [frog_index]\n\n            # Update the current position\n            current_pos = new_pos\n\n            # Update the total number of jumps\n            total_jumps += 1 + int(change[0] == '+') - int(change[0] == '-')\n\n    # Check if the frogs are all at the final tower\n    for pos in frogs:\n        if pos != t:\n            return \"Impossible\"\n\n    # Return the lowest total number of jumps\n    return str(total_jumps)"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def update_tower(n, p, a):\n        tower = [False] * n\n        for i, pos in enumerate(p):\n            tower[pos] = True\n        tower[a] = True\n        return tower\n\n    def count_jumps(n, p):\n        tower = [False] * n\n        for i, pos in enumerate(p):\n            tower[pos] = True\n        total_jumps = 0\n        for i in range(n):\n            if tower[i]:\n                continue\n            for j in range(i - 1, -1, -1):\n                if tower[j]:\n                    total_jumps += i - j\n                    break\n        return total_jumps\n\n    def lowest_jumps(n, p, changes):\n        tower_pos = 0\n        frogs = [False] * n\n        for i, pos in enumerate(p):\n            frogs[pos] = True\n        for change in changes:\n            if change[0] == '+':\n                frogs[change[1]] = True\n            elif change[0] == '-':\n                frogs[change[1]] = False\n            elif change[0] == 't':\n                tower_pos = change[1]\n\n        frogs[tower_pos] = True\n        return count_jumps(n, [i for i, x in enumerate(frogs) if x])\n\n    input_data = stdin.split('\\n')\n    n, tower_pos = map(int, input_data[0].split())\n    p = list(map(int, input_data[1].split()))\n    changes = []\n    for _ in range(int(input_data[2])):\n        changes.append(input_data[3 + len(changes)].split())\n\n    output = [str(lowest_jumps(n, p, changes)) for _ in range(len(changes))]\n    return '\\n'.join(output)"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, t = map(int, input_data[0].split())\n    positions = list(map(int, input_data[1].split()))\n    C = int(input_data[2])\n\n    frogs = [i for i in range(n)]\n    tower = t\n\n    for i in range(3, len(input_data)):\n        line = input_data[i]\n        if line.startswith('+'):\n            add_frog = int(line[1:])\n            frogs.append(add_frog)\n            tower = add_frog\n        elif line.startswith('-'):\n            remove_frog = int(line[1:])\n            frogs.remove(remove_frog)\n            tower = remove_frog\n        else:\n            tower = int(line[1:])\n\n    def count_jumps(frogs, tower):\n        total_jumps = 0\n        jump_length = 1\n        for frog in frogs:\n            if frog == tower:\n                continue\n            jump_length += abs(frog - tower)\n            total_jumps += jump_length\n        return total_jumps\n\n    output = [count_jumps(frogs, tower)]\n    for i in range(C - 1):\n        output.append(count_jumps(frogs, tower))\n\n    return '\\n'.join(map(str, output))"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, t = input_data.pop(0), input_data.pop(0)\n    positions = input_data[:n]\n    input_data = input_data[n:]\n    C = input_data.pop(0)\n\n    frogs = [False] * 1000001\n    for p in positions:\n        frogs[p] = True\n\n    def add_frog(p):\n        frogs[p] = True\n        for i in range(p + 1, 1000001):\n            if not frogs[i]:\n                frogs[i] = True\n                break\n\n    def remove_frog(p):\n        frogs[p] = False\n        for i in range(p + 1, 1000001):\n            if frogs[i]:\n                frogs[i] = False\n                break\n\n    def move_tower(a):\n        for i in range(a + 1, 1000001):\n            if frogs[i]:\n                frogs[i] = False\n                for j in range(i + 1, 1000001):\n                    if not frogs[j]:\n                        frogs[j] = True\n                        frogs[i] = False\n                        break\n                break\n\n    changes = []\n    for _ in range(C):\n        changes.append(input_data.pop(0))\n\n    for change in changes:\n        if change[0] == \"+\":\n            add_frog(int(change[1:]))\n        elif change[0] == \"-\":\n            remove_frog(int(change[1:]))\n        else:\n            move_tower(int(change[1:]))\n\n    jumps = 0\n    for i in range(1, 1000001):\n        if frogs[i]:\n            jumps += i\n            break\n\n    result = [jumps]\n    for change in changes:\n        if change[0] == \"+\":\n            add_frog(int(change[1:]))\n        elif change[0] == \"-\":\n            remove_frog(int(change[1:]))\n        else:\n            move_tower(int(change[1:]))\n\n        jumps = 0\n        for i in range(1, 1000001):\n            if frogs[i]:\n                jumps += i\n                break\n\n        result.append(jumps)\n\n    return \"\\n\".join(map(str, result))\n\ndef"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def frog_dance(n: int, start_positions: List[int], tower_pos: int) -> int:\n        # Create a list of frogs sorted by starting position\n        frogs = sorted([Frog(i, start_positions[i]) for i in range(n)], key=lambda x: x.start_pos)\n        # Sort the frogs by the length of their first jump\n        frogs.sort(key=lambda x: x.next_jump())\n        # Calculate the total number of jumps\n        total_jumps = 0\n        tower_positions = [tower_pos]\n        while frogs:\n            total_jumps += 1\n            next_frog = frogs.pop(0)\n            next_pos = next_frog.move(next_positions[0])\n            next_positions.insert(0, next_pos)\n            if next_pos == tower_pos:\n                tower_positions.append(next_pos)\n        return total_jumps, tower_positions\n\n    def update_frogs(n: int, start_positions: List[int], tower_pos: int, modifications: List[str]) -> int:\n        for mod in modifications:\n            if mod[0] == '+':\n                frogs = sorted([Frog(i, start_positions[i]) for i in range(n)], key=lambda x: x.start_pos)\n                frogs.insert(0, Frog(len(frogs), int(mod[1:])))\n                start_positions.append(int(mod[1:]))\n                n += 1\n            elif mod[0] == '-':\n                frogs = sorted([Frog(i, start_positions[i]) for i in range(n)], key=lambda x: x.start_pos)\n                frogs.pop(int(mod[1:]))\n                start_positions.pop(int(mod[1:]))\n                n -= 1\n            else:\n                tower_pos = int(mod)\n        return n, start_positions, tower_pos\n\n    n, tower_pos = map(int, stdin.split()[:2])\n    start_positions = list(map(int, stdin.split()[2:2 + n]))\n    modifications = [line.strip() for line in stdin.split('\\n')[2:2 + int(stdin.split()[-1])]]\n\n    n, start_positions, tower_pos = update_frogs(n, start_positions, tower_pos, modifications)\n    total_jumps, tower_positions = frog_dance(n, start_positions, tower_pos)\n\n    return '\\n'.join(map(str, total_jumps for _ in modifications))"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, t = map(int, input_list[0].split())\n    positions = list(map(int, input_list[1].split()))\n    changes = int(input_list[2])\n    modifications = input_list[3:]\n\n    # Implement the frog dance line-up and tower formation\n    frogs = [0] * n\n    for p in positions:\n        frogs[p] += 1\n    tower = t\n\n    # Helper function to calculate the number of jumps for a given frog position\n    def jumps_for_frog(p):\n        jumps = 0\n        while p < n:\n            jumps += 1\n            p += 1\n        return jumps\n\n    # Helper function to calculate the total number of jumps for the given dance\n    def total_jumps(frogs, tower):\n        total_jumps = 0\n        for f in frogs:\n            total_jumps += jumps_for_frog(f)\n        total_jumps += jumps_for_frog(tower)\n        return total_jumps\n\n    # Apply the modifications to the dance\n    for mod in modifications:\n        if mod[0] == \"t\":\n            tower = int(mod[1:])\n        elif mod[0] == \"+\":\n            frogs[int(mod[1:])] += 1\n        else:\n            frogs[int(mod[1:])] -= 1\n\n    # Print the total number of jumps for the modified dance\n    return str(total_jumps(frogs, tower))\n\ninput_data = '''\n3 0\n2 6 6\n10\nt 1\nt 2\nt 3\nt 4\nt 5\nt 6\nt 7\nt 8\nt 9\nt 10\n'''\nprint(solution(input_data)) "
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    initial_input = input_list[0].split()\n    n = int(initial_input[0])\n    t = int(initial_input[1])\n    frogs_positions = list(map(int, input_list[1].split()))\n    changes = int(input_list[2])\n\n    for i in range(3, 3 + changes):\n        line = input_list[i]\n        if line[0] == '+':\n            frogs_positions.append(int(line[1:]))\n        elif line[0] == '-':\n            frogs_positions.remove(int(line[1:]))\n        elif line[0] == 't':\n            t = int(line[1:])\n\n    tower_frog = frogs_positions[t]\n    frogs_positions.sort()\n\n    jumps = 0\n    for frog in frogs_positions:\n        jumps += frog - tower_frog\n        tower_frog = frog\n\n    return jumps\n\n\nstdin = '''\n3 0\n2 6 6\n10\nt 1\nt 2\nt 3\nt 4\nt 5\nt 6\nt 7\nt 8\nt 9\nt 10\n'''\n\nprint(solution(stdin)) "
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, t = map(int, input_list[0].split())\n    p = list(map(int, input_list[1].split()))\n    C = int(input_list[2])\n    modifications = []\n    for i in range(3, 3 + C):\n        line = input_list[i].split()\n        if line[0] == \"+\":\n            modifications.append((\"+\", int(line[1])))\n        elif line[0] == \"-\":\n            modifications.append((\"-\", int(line[1])))\n        else:\n            modifications.append((\"t\", int(line[1])))\n    \n    # Main function\n    def frog_dance(n, p, t, modifications):\n        # Initialize variables\n        towers = [0] * n\n        frogs = [False] * 1000001 # To handle possible positions beyond 10^6\n        for pos in p:\n            frogs[pos] = True\n        \n        # Apply modifications\n        for mod in modifications:\n            if mod[0] == \"+\":\n                pos = mod[1]\n                if frogs[pos]:\n                    frogs[pos] = False\n                    frogs[t] = True\n                    t = pos\n            elif mod[0] == \"-\":\n                pos = mod[1]\n                frogs[pos] = True\n                frogs[t] = False\n                t = p[p.index(pos)]\n            else:\n                t = mod[1]\n        \n        # Calculate the number of jumps\n        jumps = 0\n        for i in range(n):\n            if frogs[p[i]]:\n                jumps += i\n                towers[i] = t\n        \n        # Return the lowest number of jumps\n        return jumps\n    \n    # Test the function with the given examples\n    examples = [(\"1 1\\n0\\n7\\nt 0\\nt 1\\nt 2\\nt 3\\nt 4\\nt 5\\nt 6\", 0),\n                 (\"3 0\\n2 6 6\\n10\\nt 1\\nt 2\\nt 3\\nt 4\\nt 5\\nt 6\\nt 7\\nt 8\\nt 9\\nt 10\", 11)]\n    for input_str, expected_output in examples:\n        output = frog_dance(n, p, t, modifications)\n        if output == expected_output:\n            print(\"OK\")\n        else:\n            print(\"Error\")\n    \n    return str(frog_dance(n, p, t, modifications))"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    positions = list(map(int, input_list[1].split()))\n    c = int(input_list[2])\n    changes = input_list[3:]\n\n    def get_jump_length(pos):\n        return pos + 1\n\n    def get_total_jumps(positions):\n        return sum(get_jump_length(pos) for pos in positions)\n\n    def apply_change(positions, change):\n        if change.startswith('+'):\n            positions.append(int(change[1:]))\n        elif change.startswith('-'):\n            positions.remove(int(change[1:]))\n        elif change.startswith('t'):\n            t = int(change[1:])\n\n    total_jumps = get_total_jumps(positions)\n    for i in range(c):\n        change = changes[i]\n        apply_change(positions, change)\n        new_total_jumps = get_total_jumps(positions)\n        total_jumps = min(total_jumps, new_total_jumps)\n\n    return str(total_jumps)\n"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_path_length(graph, start, end):\n        visited = [False] * len(graph)\n        visited[start] = True\n        queue = [(start, 0)]\n        while queue:\n            node, length = queue.pop(0)\n            if node == end:\n                return length\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, length + weight))\n        return float('inf')\n\n    def find_unused_switches(graph, n, m):\n        unused_switches = []\n        for i in range(1, n + 1):\n            lengths = [graph[i][j][1] for j in range(1, n + 1) if j != i]\n            shortest_lengths = [shortest_path_length(graph, i, j) for j in range(1, n + 1) if j != i]\n            if all(length in shortest_lengths for length in lengths):\n                unused_switches.append(i)\n        return unused_switches\n\n    def main(input_str):\n        lines = input_str.splitlines()\n        n, m = map(int, lines[0].split())\n        graph = [[] for _ in range(n + 1)]\n        for line in lines[1:]:\n            a, b, l = map(int, line.split())\n            graph[a].append((b, l))\n            graph[b].append((a, l))\n        unused_switches = find_unused_switches(graph, n, m)\n        return len(unused_switches), sorted(unused_switches)\n\n    return main(stdin)\n"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    cables = [list(map(int, input_data[i+1].split())) for i in range(m)]\n\n    def get_transit_time(length, v, c):\n        return length / v + c\n\n    def find_shortest_path(start, end, v, c):\n        visited = [False] * (n + 1)\n        visited[start] = True\n        distance = [float('inf')] * (n + 1)\n        distance[start] = 0\n        path = [-1] * (n + 1)\n\n        queue = [(0, start)]\n        while queue:\n            dist, current = queue.pop(0)\n            if current == end:\n                return path\n\n            for cable in cables:\n                if not visited[cable[0]] and cable[1] == current:\n                    transit_time = get_transit_time(cable[2], v, c)\n                    if dist + transit_time < distance[cable[0]]:\n                        distance[cable[0]] = dist + transit_time\n                        path[cable[0]] = current\n                        visited[cable[0]] = True\n                        queue.append((dist + transit_time, cable[0]))\n        return path\n\n    v = 0\n    c = 0\n    k = 0\n    unused_switches = []\n\n    for i in range(1, n+1):\n        shortest_path = find_shortest_path(1, i, v, c)\n        if shortest_path[-1] == -1:\n            k += 1\n            unused_switches.append(i)\n\n    print(k)\n    print(' '.join(map(str, unused_switches)))\n\n\nstdin = \"\"\"7 8\n1 2 2\n1 3 1\n1 4 3\n2 6 1\n2 7 2\n3 5 1\n4 7 2\n5 7 1\"\"\"\n\nsolution(stdin) "
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    cables = [list(map(int, line.split())) for line in input_data[1:]]\n\n    unused_switches = set(range(1, n + 1))\n    for cable in cables:\n        a, b, length = cable\n        unused_switches.discard(a)\n        unused_switches.discard(b)\n\n    k = len(unused_switches)\n    result = [str(unused_switch) for unused_switch in sorted(unused_switches)]\n\n    output = f\"{k}\\n\" + \"\\n\".join(result)\n    return output"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def read_line(st: str) -> tuple:\n        return tuple(map(int, st.split()))\n\n    def distance(a: int, b: int, l: int, v: float, c: float) -> float:\n        return l / v + c\n\n    n, m = read_line(stdin.split('\\n')[0])\n    cables = [read_line(st) for st in stdin.split('\\n')[1:]]\n    min_cost = float('inf')\n    unused_switches = set()\n\n    for a, b, l in cables:\n        min_cost = min(min_cost, distance(a, b, l, v, c))\n\n    for a, b, l in cables:\n        if distance(a, b, l, v, c) == min_cost:\n            unused_switches.add(a)\n            unused_switches.add(b)\n\n    k = len(unused_switches)\n    unused_switches = sorted(unused_switches)\n\n    result = f\"{k}\\n\"\n    result += \" \".join(map(str, unused_switches))\n    return result\n\n\ndef"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph: list, start: int, end: int) -> list:\n        visited = [False] * len(graph)\n        visited[start] = True\n        queue = [(start, [start])]\n\n        while queue:\n            (vertex, path) = queue.pop(0)\n            for neighbor, weight in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, path + [neighbor]))\n                    if neighbor == end:\n                        return path + [neighbor]\n        return []\n\n    def min_transit_time(length: int, v: float, c: float) -> float:\n        return length / v + c\n\n    def calculate_optimal_path_length(graph: list, start: int, end: int, v: float, c: float) -> float:\n        path = find_path(graph, start, end)\n        if not path:\n            return float('inf')\n        length = sum(min_transit_time(graph[path[i]][path[i + 1]][1], v, c) for i in range(len(path) - 1))\n        return length\n\n    def find_unused_switches(graph: list, start: int, end: int, v: float, c: float) -> list:\n        unused_switches = []\n        for i in range(1, len(graph) + 1):\n            if i == start or i == end:\n                continue\n            length = calculate_optimal_path_length(graph, start, i, v, c)\n            if length == float('inf'):\n                unused_switches.append(i)\n        return unused_switches\n\n    def main(n: int, m: int, graph: list, v: float, c: float) -> None:\n        k = len(find_unused_switches(graph, 1, n, v, c))\n        print(k)\n        unused_switches = find_unused_switches(graph, 1, n, v, c)\n        print(\" \".join(map(str, unused_switches)))\n\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, length = map(int, input().split())\n        graph[a].append((b, length))\n        graph[b].append((a, length))\n\n    main(n, m, graph, 1, 1)\n"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def time_to_transmit(length: int, propagation_speed: float, overhead: float) -> float:\n        return length / propagation_speed + overhead\n\n    def shortest_path_length(graph: dict, start: int, end: int) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (vertex, distance) = queue.pop(0)\n            if vertex == end:\n                return distance\n            if vertex not in visited:\n                visited.add(vertex)\n                for neighbor, weight in graph[vertex].items():\n                    queue.append((neighbor, distance + weight))\n        return -1\n\n    def find_unused_switches(graph: dict) -> set:\n        unused_switches = set(range(1, n + 1))\n        for switch in range(1, n + 1):\n            if switch not in graph:\n                continue\n            for neighbor in graph[switch]:\n                if neighbor in unused_switches:\n                    unused_switches.remove(neighbor)\n        return unused_switches\n\n    def count_unused_switches(graph: dict) -> int:\n        unused_switches = find_unused_switches(graph)\n        return len(unused_switches)\n\n    def unused_switches_indices(graph: dict) -> list:\n        unused_switches = find_unused_switches(graph)\n        return sorted(list(unused_switches))\n\n    def find_optimal_path(graph: dict, start: int, end: int, propagation_speed: float, overhead: float) -> bool:\n        time_to_n = shortest_path_length(graph, start, end)\n        if time_to_n == -1:\n            return False\n        time_to_1 = shortest_path_length(graph, end, 1)\n        if time_to_1 == -1:\n            return False\n        return time_to_n + time_to_1 == shortest_path_length(graph, start, 1)\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    graph = {i: {} for i in range(1, n + 1)}\n    for line in lines[1:]:\n        a, b, length = map(int, line.split())\n        graph[a][b] = length\n        graph[b][a] = length\n\n    v = 0.1\n    c = 0.1\n\n    k = count_unused_switches(graph)\n    unused_indices = unused_switches_indices(graph)\n\n    result = f\"{k}\\n\"\n    for index in unused_indices:\n        result += f\"{index} \"\n    return result[:-1]"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cables = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    adj_list = [[] for _ in range(n+1)]\n    for a, b, _ in cables:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def dfs(v: int, parent: int):\n        visited[v] = True\n        for w in adj_list[v]:\n            if w != parent:\n                if not visited[w]:\n                    dfs(w, v)\n\n    unused_switches = []\n    for i in range(2, n+1):\n        visited = [False] * (n+1)\n        dfs(i, 1)\n        if not visited[n]:\n            unused_switches.append(i)\n\n    k = len(unused_switches)\n    unused_switches.sort()\n    return f\"{k}\\n{' '.join(map(str, unused_switches))}\"\n"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    cables = [list(map(int, stdin.split()[2:])) for _ in range(m)]\n    \n    # Find all shortest paths from switch 1 to switch n\n    paths = [[0] * (n+1) for _ in range(n+1)]\n    for a, b, c in cables:\n        paths[a][b] = c\n        paths[b][a] = c\n    \n    # Find the shortest path from switch 1 to switch n\n    shortest_path = 0\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            shortest_path = max(shortest_path, paths[i][j])\n    \n    # Determine which switches cannot be part of an optimal path\n    unused_switches = []\n    for i in range(1, n+1):\n        for j in range(i+1, n+1):\n            if paths[i][j] > shortest_path:\n                unused_switches.append(i)\n                unused_switches.append(j)\n                break\n    \n    # Remove duplicates and sort the list of unused switches\n    unused_switches = sorted(set(unused_switches))\n    \n    # Output the result\n    return f\"{len(unused_switches)}\\n{' '.join(map(str, unused_switches))}\""
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from heapq import heappush, heappop\n\n    def dijkstra(graph, start, end):\n        queue = [(0, start, [])]\n        visited = set()\n        while queue:\n            (cost, current, path) = heappop(queue)\n            if current not in visited:\n                visited.add(current)\n                path = path + [current]\n                if current == end:\n                    return path\n                for neighbor, weight in graph[current]:\n                    heappush(queue, (cost + weight, neighbor, path))\n        return None\n\n    def count_unused_switches(switches, graph):\n        start = 1\n        end = len(switches)\n        path = dijkstra(graph, start, end)\n        if path is None:\n            return 0, []\n        else:\n            unused_switches = [switch for switch in range(1, len(switches) + 1) if switch not in path]\n            return len(unused_switches), unused_switches\n\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    switches = [[] for _ in range(n + 1)]\n    for line in input_data[1:]:\n        a, b, length = map(int, line.split())\n        switches[a].append((b, length))\n        switches[b].append((a, length))\n\n    unused_count, unused_switches = count_unused_switches(switches, switches)\n    result = [unused_count]\n    for switch in sorted(unused_switches):\n        result.append(switch)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def min_time(length, speed, overhead):\n        return length / speed + overhead\n\n    def is_possible_path(path, visited, switches):\n        for switch in switches:\n            if switch not in visited:\n                return False\n        return True\n\n    def get_unused_switches(switches, visited):\n        unused = []\n        for i in range(1, len(switches) + 1):\n            if i not in visited:\n                unused.append(i)\n        return unused\n\n    n, m = map(int, input().split())\n    switches = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, length = map(int, input().split())\n        switches[a].append(b)\n        switches[b].append(a)\n\n    # Determine the minimum time required to send a network packet from switch 1 to switch n\n    min_time_1n = float('inf')\n    for switch in range(1, n + 1):\n        visited = set()\n        time = 0\n        switches_left = [switch]\n        while switches_left:\n            current_switch = switches_left.pop(0)\n            visited.add(current_switch)\n            for neighbor in switches[current_switch]:\n                if neighbor not in visited:\n                    switches_left.append(neighbor)\n                    time += min_time(length, speed, overhead)\n        min_time_1n = min(min_time_1n, time)\n\n    # Determine the switches that could never be part of an optimal path\n    visited = set()\n    unused_switches = []\n    for switch in range(1, n + 1):\n        visited.add(switch)\n        for neighbor in switches[switch]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                time = 0\n                switches_left = [neighbor]\n                while switches_left:\n                    current_switch = switches_left.pop(0)\n                    visited.add(current_switch)\n                    for neighbor in switches[current_switch]:\n                        if neighbor not in visited:\n                            switches_left.append(neighbor)\n                            time += min_time(length, speed, overhead)\n                if time >= min_time_1n:\n                    unused_switches.append(switch)\n                    break\n    return len(unused_switches), sorted(unused_switches)\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def create_movie(plot_index: int) -> int:\n        nonlocal creation_index\n        creation_index += 1\n        return creation_index\n\n    def translate_order(creation_index: int) -> int:\n        nonlocal plot_order\n        if creation_index in plot_order:\n            return plot_order[creation_index]\n        else:\n            plot_index = len(plot_order) + 1\n            for key, value in plot_order.items():\n                if value > creation_index:\n                    plot_order[key] = value + 1\n            plot_order[creation_index] = plot_index\n            return plot_index\n\n    stdin = stdin.splitlines()\n    Q = int(stdin[0])\n    creation_index = 0\n    plot_order = {}\n    result = []\n\n    for i in range(1, len(stdin)):\n        q, x = map(int, stdin[i].split())\n        if q == 1:\n            creation_index = create_movie(x)\n        else:\n            plot_index = translate_order(x)\n            result.append(str(creation_index))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.strip().split('\\n')\n    Q = int(Q)\n    n = 0\n    creation_indices = {}\n    plot_indices = {}\n    result = []\n\n    for query in queries:\n        q, x = map(int, query.split())\n\n        if q == 1:\n            if x > n + 1:\n                raise ValueError(\"Invalid input: x must be less than or equal to the number of movies so far + 1.\")\n            if x in plot_indices:\n                raise ValueError(\"Invalid input: the plot index is already used.\")\n            plot_indices[x] = n + 1\n            creation_indices[n + 1] = n + 1\n            n += 1\n        else:\n            if x not in plot_indices:\n                raise ValueError(\"Invalid input: the plot index is not assigned.\")\n            result.append(creation_indices[plot_indices[x]])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.split(\"\\n\")\n    Q = int(Q)\n    n = 0\n    created_movies = {}\n    plot_order = {}\n    output = []\n\n    for i in range(Q):\n        q, x = map(int, queries[i].split())\n        if q == 1:\n            n += 1\n            created_movies[n] = x\n        else:\n            output.append(created_movies[x])\n\n    return \"\\n\".join(map(str, output))"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.splitlines()\n    Q = int(Q)\n    movies = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6}\n    created = [1, 2, 3, 4, 5, 6]\n\n    def update_movie(movie: int, index: int) -> None:\n        movies[movie] = index\n        created[index - 1] = movie\n\n    for q, x in (query.split() for query in queries):\n        q, x = int(q), int(x)\n        if q == 1:\n            update_movie(x, len(created) + 1)\n        else:\n            creation_index = created.index(x) + 1\n            print(creation_index)\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.split(\"\\n\")\n    Q = int(Q)\n    n = 0\n    created_index = {}\n    plot_index = {}\n\n    for i in range(Q):\n        query = queries[i].split()\n        q = int(query[0])\n        x = int(query[1])\n\n        if q == 1:\n            if x not in created_index:\n                n += 1\n                created_index[x] = n\n            else:\n                n = created_index[x]\n        elif q == 2:\n            print(created_index[x])"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.split()\n    Q = int(Q)\n    plots = [1, 2, 3, 4, 5, 6]\n    creation_index = {i: i for i in plots}\n    output = []\n\n    for _ in range(Q):\n        q, x = map(int, queries.pop(0).split())\n        if q == 1:\n            creation_index[x] = plots.index(x) + 1\n        else:\n            output.append(creation_index[x])\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.split('\\n')\n    Q = int(Q)\n    n = 0\n    creation_order = [0] * (Q + 1)\n    plot_order = [0] * (Q + 1)\n\n    for i in range(1, Q + 1):\n        creation_order[i] = i\n        plot_order[i] = i\n\n    for query in queries:\n        q, x = map(int, query.split())\n\n        if q == 1:\n            plot_order[x] = n + 1\n            n += 1\n        else:\n            print(creation_order[plot_order[x]])\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def create_movie(plot_index: int) -> int:\n        nonlocal n, creation_index\n        creation_index += 1\n        n += 1\n        return creation_index\n\n    def find_movie(plot_index: int) -> int:\n        nonlocal n, creation_index, plot_indices\n        if plot_index > n or plot_index < 1:\n            return -1\n\n        for i, index in enumerate(plot_indices):\n            if index == plot_index:\n                return i + 1\n\n        return -1\n\n    q, *queries = stdin.split('\\n')\n    n = 0\n    creation_index = 0\n    plot_indices = []\n\n    for q_type, x in queries:\n        x = int(x)\n        if q_type == '1':\n            create_movie(x)\n        else:\n            index = find_movie(x)\n            if index != -1:\n                print(index)\n            else:\n                print(-1)\n\n    return '\\n'.join(['1'] * len(queries))\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def create_movie(index: int, movies: list) -> None:\n        if index > len(movies):\n            movies.extend([None] * (index - len(movies)))\n        movies[index - 1] = index\n\n    def get_creation_index(index: int, movies: list) -> int:\n        for i, movie in enumerate(movies):\n            if movie == index:\n                return i + 1\n        return -1\n\n    Q, *queries = stdin.split('\\n')\n    Q = int(Q)\n    movies = []\n    output = []\n\n    for q, x in (query.split() for query in queries):\n        x = int(x)\n        if q == '1':\n            create_movie(x, movies)\n        else:\n            output.append(get_creation_index(x, movies))\n\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = 0\n    plot_order = []\n    creation_order = []\n\n    def insert_movie(index: int, movie: int, order: list):\n        nonlocal n\n        order.insert(index - 1, movie)\n        n += 1\n\n    def find_movie(index: int, order: list) -> int:\n        return order[index - 1]\n\n    for line in stdin.splitlines():\n        q, x = map(int, line.split())\n        if q == 1:\n            insert_movie(x, x, plot_order)\n        else:\n            creation_index = find_movie(x, plot_order)\n            print(creation_index)\n"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = list(stdin)\n    steps = 0\n\n    for i in range(len(hay_bales)):\n        if hay_bales[i] == 'P' and (i == 0 or hay_bales[i - 1] == 'C'):\n            steps += 1\n            hay_bales.insert(i + 1, 'P')\n            hay_bales.insert(i + 2, 'P')\n            hay_bales.insert(i + 3, 'P')\n            i += 3\n        elif hay_bales[i] == 'P':\n            hay_bales[i], hay_bales[i + 1] = hay_bales[i + 1], hay_bales[i]\n            steps += 1\n\n    return str(steps)"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    bales = list(stdin)\n    count = 0\n    for i in range(len(bales) - 2):\n        if bales[i] == 'P' and bales[i+1] == 'P' and bales[i+2] == 'P':\n            count += 1\n            for j in range(i, i+3):\n                bales.pop(i)\n    return str(count)\n\n\ninput1 = \"CPCC\"\noutput1 = solution(input1)\nprint(output1)  # Output: 1\n\ninput2 = \"PPPPCCCC\"\noutput2 = solution(input2)\nprint(output2)  # Output: 8 "
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_parasites(bales: str) -> int:\n        return sum(bale == 'P' for bale in bales)\n\n    def move_bales(bales: str) -> str:\n        parasites = count_parasites(bales)\n        if parasites == 0:\n            return bales\n\n        # Find the index of the first infected hay bale\n        first_index = bales.index('P')\n\n        # Find the index of the last clean hay bale\n        last_index = bales.rindex('C')\n\n        # Swap the infected hay bales to the back\n        new_bales = bales[:first_index] + bales[first_index+1:last_index+1][::-1] + bales[last_index+1:]\n\n        # Calculate the minimum number of operations\n        min_ops = min(count_parasites(new_bales[:i+1]) for i in range(len(new_bales)))\n\n        return new_bales, min_ops\n\n    bales, min_ops = move_bales(stdin)\n    return str(min_ops)"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_infected(s: str) -> int:\n        count = 0\n        for c in s:\n            if c == 'P':\n                count += 1\n        return count\n\n    n = len(stdin)\n    if n == 1:\n        return \"1\"\n\n    # Calculate the number of infected bales in the first, middle, and last positions\n    count_first = 1 if stdin[0] == 'P' else 0\n    count_middle = 1 if stdin[1] == 'P' else 0\n    count_last = 1 if stdin[-1] == 'P' else 0\n\n    # Calculate the number of infected bales in the rest of the sequence\n    count_rest = 0\n    for i in range(2, n - 2):\n        if stdin[i] == 'P':\n            count_rest += 1\n\n    # Calculate the total number of operations needed\n    total_ops = count_rest + min(count_first, count_middle, count_last)\n\n    # Calculate the number of operations needed to sort the infected bales to the back\n    if count_first == 1 and count_middle == 1 and count_last == 1:\n        total_ops += 1\n    elif count_first == 1 or count_middle == 1 or count_last == 1:\n        total_ops += 2\n    elif count_first + count_middle + count_last >= 2:\n        total_ops += 3\n\n    return str(total_ops)\n"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Count the number of clean bales\n    clean_bales = stdin.count(\"C\")\n    \n    # Count the number of parasite bales\n    parasite_bales = stdin.count(\"P\")\n    \n    # Calculate the minimum number of operations\n    min_operations = (clean_bales + parasite_bales - 1) // 3\n    \n    return str(min_operations)"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = list(stdin)\n    parasites_count = 0\n    min_steps = 0\n    for i in range(len(hay_bales)):\n        if hay_bales[i] == 'P':\n            parasites_count += 1\n            if parasites_count == 3:\n                min_steps += 1\n                parasites_count = 0\n    if parasites_count == 3:\n        min_steps += 1\n    return str(min_steps)"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def count_infected(s: str) -> int:\n        return sum(1 for b in s if b == 'P')\n\n    def min_operations(s: str) -> int:\n        n = len(s)\n        count = count_infected(s)\n        if count == 0:\n            return 0\n        elif count == 1:\n            return 1\n        else:\n            return 2 * min_operations(s[count:]) + 1\n\n    return str(min_operations(stdin))\n"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    bales = list(stdin)\n    min_operations = 0\n    i = 0\n    \n    while i < len(bales) - 2:\n        if bales[i] == 'C' and bales[i+1] == 'P' and bales[i+2] == 'C':\n            bales.pop(i+1)\n            bales.pop(i)\n            bales.pop(i)\n            min_operations += 1\n        else:\n            i += 1\n    \n    return str(min_operations)"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize variables\n    clean_bales = 0\n    parasite_bales = 0\n    sorted_bales = 0\n\n    # Iterate through the sequence and count the number of clean and infected bales\n    for bale in stdin:\n        if bale == 'C':\n            clean_bales += 1\n        elif bale == 'P':\n            parasite_bales += 1\n\n    # Calculate the number of operations needed\n    if parasite_bales == 0:\n        return 0\n    elif clean_bales >= parasite_bales:\n        return parasite_bales\n    else:\n        operations = 0\n        while clean_bales < parasite_bales:\n            operations += 3\n            clean_bales += 3\n            parasite_bales -= 3\n            if clean_bales >= parasite_bales:\n                operations += parasite_bales\n                break\n        return operations"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize variables\n    hay_bales = list(stdin)\n    num_operations = 0\n    max_pos = len(hay_bales) - 1\n\n    # Function to move an element to the end of the list\n    def move_to_back(pos):\n        nonlocal hay_bales, num_operations\n        hay_bales.append(hay_bales.pop(pos))\n        num_operations += 1\n\n    # Function to sort 3 consecutive elements\n    def sort_3_consecutive(pos1, pos2, pos3):\n        nonlocal hay_bales, num_operations\n        if hay_bales[pos1] == 'C' and hay_bales[pos2] == 'C' and hay_bales[pos3] == 'C':\n            return\n        elif hay_bales[pos1] == 'C' and hay_bales[pos2] == 'C' and hay_bales[pos3] == 'P':\n            move_to_back(pos3)\n            move_to_back(pos2)\n        elif hay_bales[pos1] == 'C' and hay_bales[pos2] == 'P' and hay_bales[pos3] == 'C':\n            move_to_back(pos2)\n            move_to_back(pos1)\n        elif hay_bales[pos1] == 'C' and hay_bales[pos2] == 'P' and hay_bales[pos3] == 'P':\n            move_to_back(pos3)\n            move_to_back(pos2)\n            move_to_back(pos1)\n        elif hay_bales[pos1] == 'P' and hay_bales[pos2] == 'C' and hay_bales[pos3] == 'C':\n            move_to_back(pos2)\n            move_to_back(pos1)\n        elif hay_bales[pos1] == 'P' and hay_bales[pos2] == 'C' and hay_bales[pos3] == 'P':\n            move_to_back(pos3)\n            move_to_back(pos2)\n            move_to_back(pos1)\n        elif hay_bales[pos1] == 'P' and hay_bales[pos2] == 'P' and hay_bales[pos3] == 'C':\n            move_to_back(pos3)\n            move_to_back(pos2)\n            move_to_back(pos1)\n        elif hay_bales[pos1] == 'P' and hay_bales[pos2] == 'P' and hay_bales[pos3] == 'P':\n            move_to_back(pos3)\n            move_to_back(pos2)\n            move_to_back(pos1)\n\n    # Main loop to sort the sequence\n    while max_pos >= 2:\n        for i in range(max_pos - 2):\n            sort_3_consecutive(i, i+1, i+2)\n\n    return str(num_operations)\n"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    implications = {(int(a), int(b)) for a, b in (stdin.split()[3::2])}\n    events = set(map(int, stdin.split()[-N:]))\n\n    # Add implications to graph\n    graph = {i: [] for i in range(1, D+1)}\n    for a, b in implications:\n        graph[a].append(b)\n\n    # DFS to find all events that have certainly occurred\n    visited = set()\n    def dfs(node):\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                dfs(neighbor)\n\n    for node in events:\n        if node not in visited:\n            dfs(node)\n\n    return \" \".join(map(str, sorted(visited)))"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_certain_events(D: int, M: int, N: int, S: set, implications: list) -> set:\n        certain_events = set()\n        for event in S:\n            certain_events.add(event)\n\n        for i in range(M):\n            implication = implications[i]\n            A, B = implication\n            if A not in certain_events:\n                continue\n            if B in certain_events:\n                continue\n            certain_events.add(B)\n\n        return certain_events\n\n    D, M, N = map(int, stdin.split()[:3])\n    implications = [tuple(map(int, stdin.split()[3 + i * 2: 3 + i * 2 + 2])) for i in range(M)]\n    S = set(map(int, stdin.split()[-N:]))\n\n    certain_events = find_certain_events(D, M, N, S, implications)\n    return \" \".join(map(str, sorted(certain_events)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_events(knowledge_base, events):\n        events_set = set(events)\n        for a, b in knowledge_base:\n            if a in events_set:\n                events_set.add(b)\n        return sorted(list(events_set))\n\n    def parse_input(input_str):\n        lines = input_str.splitlines()\n        D, M, N = map(int, lines[0].split())\n        knowledge_base = [(int(a), int(b)) for a, b in (line.split() for line in lines[1:M + 1])]\n        events = [int(line.split()[1]) for line in lines[M + 1:M + N + 1]]\n        return knowledge_base, events\n\n    knowledge_base, events = parse_input(stdin)\n    result = find_events(knowledge_base, events)\n    return ' '.join(map(str, result))\n\ninput_str = '''3 2 1\n1 2\n2 3\n2'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n3'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n4'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n4'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n5'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n5'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n6'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n6'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n7'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n7'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n8'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n8'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n9'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n9'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n10'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n10'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n11'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n11'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n12'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n12'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n13'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n13'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 2\n2 3\n14'''\nprint(solution(input_str))\n\ninput_str = '''3 2 1\n1 3\n2 3\n14'''\nprint(solution"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_certain_events(implications: list, known_events: list) -> set:\n        certain_events = set()\n        for event in known_events:\n            certain_events.add(event)\n        \n        while implications:\n            implication = implications.pop(0)\n            if implication[0] not in certain_events:\n                continue\n            \n            for event in certain_events.copy():\n                if event == implication[1]:\n                    certain_events.remove(event)\n                elif event == implication[0]:\n                    certain_events.add(implication[1])\n                    certain_events.remove(event)\n        \n        return certain_events\n    \n    n, m, d = map(int, stdin.split()[:3])\n    implications = [tuple(map(int, stdin.split()[i:i+2])) for i in range(3, 3+m*2, 2)]\n    known_events = list(map(int, stdin.split()[-n:]))\n    \n    certain_events = find_certain_events(implications, known_events)\n    return ' '.join(map(str, sorted(certain_events)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def graph_traversal(graph: dict, start: int, visited: set = None) -> set:\n        if visited is None:\n            visited = set()\n        visited.add(start)\n        for next_node in graph[start]:\n            if next_node not in visited:\n                graph_traversal(graph, next_node, visited)\n        return visited\n\n    def find_certain_events(implications: list, known_events: list) -> set:\n        graph = {i: [] for i in range(1, D + 1)}\n        for A, B in implications:\n            graph[B].append(A)\n        return graph_traversal(graph, start=known_events[0])\n\n    D, M, N = map(int, input().split())\n    implications = [(int(A), int(B)) for _ in range(M)]\n    known_events = [int(x) for _ in range(N)]\n\n    certain_events = find_certain_events(implications, known_events)\n    return ' '.join(map(str, sorted(certain_events)))"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(stdin: str) -> tuple:\n        D, M, N = map(int, stdin.readline().strip().split())\n        implications = []\n        for _ in range(M):\n            A, B = map(int, stdin.readline().strip().split())\n            implications.append((A, B))\n        known_events = set(map(int, stdin.readline().strip().split()))\n        return D, M, N, implications, known_events\n\n    def find_certain_events(D, M, N, implications, known_events):\n        certain_events = set()\n        for event in known_events:\n            certain_events.add(event)\n            for A, B in implications:\n                if event == A:\n                    certain_events.add(B)\n        return certain_events\n\n    D, M, N, implications, known_events = parse_input(StringIO(stdin))\n    certain_events = find_certain_events(D, M, N, implications, known_events)\n    return \" \".join(map(str, sorted(list(certain_events))))"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    implications = [tuple(map(int, stdin.split()[3+i:3+i+2])) for i in range(M)]\n    known_events = set(map(int, stdin.split()[-N:]))\n    \n    def causes(event):\n        return set(filter(lambda e: event in causes(e), range(1, D+1)))\n    \n    def find_certain_events():\n        certain_events = set()\n        for event in range(1, D+1):\n            if event in known_events:\n                certain_events.add(event)\n            elif causes(event) <= known_events:\n                certain_events.add(event)\n        return certain_events\n    \n    certain_events = find_certain_events()\n    return ' '.join(map(str, sorted(certain_events)))\n\ndef"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    implications = [(int(x), int(y)) for x, y in zip(stdin.split()[3::2], stdin.split()[4::2])]\n    evidence = [int(x) for x in stdin.split()[-N:]]\n    \n    certain_events = set(evidence)\n    for A, B in implications:\n        if A not in certain_events:\n            continue\n        certain_events.add(B)\n    \n    return ' '.join(map(str, sorted(certain_events)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    \n    # Parse input\n    D, M, N = map(int, stdin.split()[:3])\n    implications = [tuple(map(int, stdin.split()[i:i+2])) for i in range(3, 3+M, 2)]\n    known_events = set(map(int, stdin.split()[-N:]))\n    \n    # Build knowledge base\n    knowledge_base = defaultdict(set)\n    for A, B in implications:\n        knowledge_base[B].add(A)\n        \n    # Find certain events\n    certain_events = set()\n    for event in known_events:\n        certain_events.add(event)\n        for cause in knowledge_base[event]:\n            certain_events.add(cause)\n            certain_events.update(knowledge_base[cause])\n            \n    # Print result\n    return ' '.join(map(str, sorted(certain_events)))\n"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    def dfs(events, visited, known_events):\n        if len(visited) == len(events):\n            return known_events\n\n        for event in events:\n            if event not in visited:\n                visited.add(event)\n                known_events.add(event)\n                known_events = dfs(events, visited, known_events)\n                visited.remove(event)\n        return known_events\n\n    def find_all_events(D, M, N, implications, known_events):\n        events = set(range(1, D + 1))\n        event_graph = defaultdict(set)\n        for A, B in implications:\n            event_graph[A].add(B)\n\n        for A, B in event_graph.items():\n            for b in B:\n                if b in event_graph and A in event_graph[b]:\n                    event_graph[b].remove(A)\n\n        known_events.update(known_events)\n        known_events = dfs(events, set(), known_events)\n        return known_events\n\n    D, M, N = map(int, input().split())\n    implications = [tuple(map(int, input().split())) for _ in range(M)]\n    known_events = set(map(int, input().split()))\n\n    all_events = find_all_events(D, M, N, implications, known_events)\n    return \" \".join(map(str, sorted(all_events)))"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, K = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    max_key = max(a)\n    sum_of_keys = sum(a)\n    result = (sum_of_keys * max_key) % 1000000007\n    return str(result)\n"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    max_value = max(a)\n    total_sum = sum(a)\n    max_sum = max_value * K\n    remainder = total_sum - max_sum\n\n    return str(remainder % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N = int(input_list[0])\n    K = int(input_list[1])\n    a = list(map(int, input_list[2:]))\n\n    max_keys = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if K == 1:\n                    max_keys.append(max(a[i], a[j], a[k]))\n                elif K == 2:\n                    max_keys.append(max(a[i], a[j], a[k], a[i + 1], a[j + 1], a[k + 1]))\n                elif K == 3:\n                    max_keys.append(max(a[i], a[j], a[k], a[i + 1], a[j + 1], a[k + 1], a[i + 2], a[j + 2], a[k + 2]))\n                elif K == 4:\n                    max_keys.append(max(a[i], a[j], a[k], a[i + 1], a[j + 1], a[k + 1], a[i + 2], a[j + 2], a[k + 2], a[i + 3], a[j + 3], a[k + 3]))\n                else:\n                    max_keys.append(max(a[i], a[j], a[k], a[i + 1], a[j + 1], a[k + 1], a[i + 2], a[j + 2], a[k + 2], a[i + 3], a[j + 3], a[k + 3], a[i + 4], a[j + 4], a[k + 4]))\n\n    total = sum(max_keys)\n    return str(total % 1000000007)\n"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    a = list(map(int, input().split()))\n    max_value = max(a)\n    return (K * max_value) % 1000000007\n\ninput_str = \"5 3\\n2 4 2 3 4\\n5 1\\n1 0 1 1 1\"\noutput_str = \"\"\nfor line in input_str.split('\\n'):\n    if line != \"\":\n        output_str += str(solution(line + \"\\n\"))\n    else:\n        output_str += \"\\n\"\nprint(output_str) "
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = sorted(map(int, stdin.split()[2:]), reverse=True)\n    \n    max_sum = 0\n    for i in range(K):\n        max_sum += a[i]\n    \n    return str(max_sum % 1000000007)\n\n\ndef"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_value = max(a)\n    result = sum(a) - max_value * K\n    return str(result % 1000000007)\n\ninput_data = '''5 3\n2 4 2 3 4\n5 1\n1 0 1 1 1'''\n\noutput_data = '''39\n4'''\n\ninput_list = input_data.split('\\n')\noutput_list = output_data.split('\\n')\n\nfor i in range(len(input_list)):\n    input_str = input_list[i].strip()\n    output_str = output_list[i].strip()\n    assert solution(input_str) == output_str, f'Wrong output for input: {input_str}'\n\nprint('All test cases passed!')\n"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_value = max(a)\n    return (K * (max_value * (N - K)) // 2) % 1000000007"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_largest_key(keys: list) -> int:\n        return max(keys)\n\n    def find_key_sum(keys: list) -> int:\n        return sum(keys)\n\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    key_combinations = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                for l in range(k + 1, N):\n                    key_combinations.append((a[i], a[j], a[k], a[l]))\n\n    largest_keys = [find_largest_key(combination) for combination in key_combinations]\n    key_sums = [find_key_sum(combination) for combination in key_combinations]\n\n    result = sum(largest_keys[:K])\n    result %= 1000000007\n\n    return str(result)\n"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    \n    max_value = max(a)\n    total_sum = sum(a)\n    max_sum = (max_value * K) + (total_sum - max_value)\n    mod = 1000000007\n    result = max_sum % mod\n    \n    return str(result)"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_key = max(a)\n    total = sum(a) - (N - K) * max_key\n    return str(total % 1000000007)\n"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    R, C = map(int, input_data.pop(0).split())\n    grid = []\n\n    for i in range(R):\n        grid.append(list(input_data[i]))\n\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 'x':\n                if i == 0 or grid[i - 1][j] != 'x':\n                    for k in range(i + 1, R):\n                        if grid[k][j] == 'x':\n                            continue\n                        else:\n                            building_size = k - i\n                            building_row = i\n                            building_col = j\n                            building_length = max(building_size, building_size)\n                            break\n                elif j == 0 or grid[i][j - 1] != 'x':\n                    for k in range(j + 1, C):\n                        if grid[i][k] == 'x':\n                            continue\n                        else:\n                            building_size = k - j\n                            building_row = i\n                            building_col = j\n                            building_length = max(building_size, building_size)\n                            break\n\n    return f\"{building_row} {building_col} {building_length}\""
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def valid_position(r: int, c: int, size: int) -> bool:\n        return 0 <= r < R and 0 <= c < C and all(0 <= i < R and 0 <= j < C for i, j in ((r-1, c), (r+1, c), (r, c-1), (r, c+1))) and any(matrix[i][j] == 'x' for i, j in ((r-1, c), (r+1, c), (r, c-1), (r, c+1))) and all(matrix[i][j] == '.' for i in range(r-size+1, r+size) for j in range(c-size+1, c+size))\n\n    R, C = map(int, stdin.split()[:2])\n    matrix = [list(line.strip()) for line in stdin.split('\\n')[1:] if line.strip()]\n\n    for size in range(1, min(R, C) + 1):\n        for r in range(R - size + 1):\n            for c in range(C - size + 1):\n                if valid_position(r, c, size):\n                    print(r + 1, c + 1, size)\n                    return\n"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, input().split())\n    grid = []\n    for _ in range(R):\n        grid.append(input())\n\n    buildings = []\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'x':\n                if not buildings:\n                    buildings.append((r, c))\n                else:\n                    for b in buildings:\n                        if r - b[0] == 0 or c - b[1] == 0:\n                            buildings.append((r, c))\n                            break\n\n    def get_size(b):\n        size = 1\n        while R - b[0] >= size and C - b[1] >= size:\n            if all(grid[b[0] + i][b[1] + i] == 'x' for i in range(size)):\n                return size\n            size += 1\n        return size - 1\n\n    sizes = [get_size(b) for b in buildings]\n    for i in range(len(buildings)):\n        r, c = buildings[i]\n        print(r, c, sizes[i])\n\ndef"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C, *input_data = stdin.split('\\n')\n    R, C = int(R), int(C)\n\n    def find_buildings(matrix):\n        buildings = []\n        for r in range(R):\n            for c in range(C):\n                if matrix[r][c] == 'x':\n                    size = 1\n                    while r + size < R and c + size < C and matrix[r][c + size] == 'x' and matrix[r + size][c] == 'x':\n                        size += 1\n                    buildings.append((r, c, size))\n        return buildings\n\n    def find_overlap(buildings):\n        overlaps = []\n        for i in range(len(buildings)):\n            for j in range(i + 1, len(buildings)):\n                if buildings[i][2] > 0 and buildings[j][2] > 0:\n                    r1, c1, size1 = buildings[i]\n                    r2, c2, size2 = buildings[j]\n                    if c1 < c2 and r1 < r2:\n                        overlap_r1, overlap_c1 = max(r1, r2), c1\n                        overlap_r2, overlap_c2 = min(r1 + size1 - 1, r2 + size2 - 1), min(c1 + size1, c2 + size2) - 1\n                        if overlap_r1 <= overlap_r2 and overlap_c1 <= overlap_c2:\n                            overlaps.append((overlap_r1, overlap_c1, overlap_r2 - overlap_r1 + 1, overlap_c2 - overlap_c1 + 1))\n                    elif c1 > c2 and r1 > r2:\n                        overlap_r1, overlap_c1 = min(r1, r2), c1\n                        overlap_r2, overlap_c2 = max(r1 + size1 - 1, r2 + size2 - 1), max(c1 + size1, c2 + size2) - 1\n                        if overlap_r1 <= overlap_r2 and overlap_c1 <= overlap_c2:\n                            overlaps.append((overlap_r1, overlap_c1, overlap_r2 - overlap_r1 + 1, overlap_c2 - overlap_c1 + 1))\n        return overlaps\n\n    def find_unique_overlap(overlaps):\n        unique_overlaps = []\n        for overlap in overlaps:\n            if not any(overlap == unique_overlap for unique_overlap in unique_overlaps):\n                unique_overlaps.append(overlap)\n        return unique_overlaps\n\n    input_matrix = [list(line) for line in input_data]\n    buildings = find_buildings(input_matrix)\n    overlaps = find_overlap(buildings)\n    unique_overlaps = find_unique_overlap(overlaps)\n\n    for overlap in unique_overlaps:\n        r1, c1, size1 = buildings[overlap[0]]\n        r2, c2, size2 = buildings[overlap[1]]\n        print(f\"{r1 + 1} {c1 + 1} {overlap[2]}\")\n        print(f\"{r2 + 1} {c2 + 1} {overlap[3]}\")\n        print()\n"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    matrix = stdin.split('\\n')[1:]\n    \n    def is_valid(row, col, size):\n        return 0 <= row < R and 0 <= col < C and matrix[row][col] == 'x' and all(0 <= r < R and 0 <= c < C and matrix[r][c] == 'x' for r in range(row, row + size) for c in range(col, col + size))\n    \n    for size in range(1, min(R, C) + 1):\n        for row in range(R - size + 1):\n            for col in range(C - size + 1):\n                if is_valid(row, col, size):\n                    return f\"{row + 1} {col + 1} {size}\""
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, input().split())\n    grid = []\n    for _ in range(r):\n        grid.append(list(input()))\n\n    # Find the coordinates of the two buildings\n    building1, building2 = None, None\n    for i in range(r):\n        for j in range(c):\n            if grid[i][j] == 'x':\n                if building1 is None:\n                    building1 = (i, j)\n                elif building2 is None:\n                    building2 = (i, j)\n\n    # Calculate the size of the buildings\n    size1 = 1\n    size2 = 1\n    for i in range(r):\n        if building1[0] - 1 == i:\n            size1 += 1\n        elif building2[0] - 1 == i:\n            size2 += 1\n    for j in range(c):\n        if building1[1] - 1 == j:\n            size1 += 1\n        elif building2[1] - 1 == j:\n            size2 += 1\n\n    # Print the output\n    print(building1[0], building1[1], size1)\n    print(building2[0], building2[1], size2)"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    R, C = map(int, input_list[0].split())\n    grid = [list(input_list[i]) for i in range(1, len(input_list))]\n\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == 'x':\n                # check if this is the upper left corner of a building\n                if r == 0 or grid[r-1][c] == '.':\n                    if c == 0 or grid[r][c-1] == '.':\n                        # check if the building is square\n                        if R > 1 and C > 1 and grid[r+1][c] == '.' and grid[r][c+1] == '.':\n                            # check if the building is within bounds\n                            if r+1 < R and c+1 < C:\n                                print(r+1, c+1, r+1-r)"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    grid = []\n    for _ in range(R):\n        grid.append(list(stdin.readline().strip()))\n\n    # Find the building with the largest square\n    max_square = 0\n    max_row, max_col = 0, 0\n    for row in range(R):\n        for col in range(C):\n            if grid[row][col] == 'x':\n                square = 1\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    r, c = row + dr, col + dc\n                    if 0 <= r < R and 0 <= c < C and grid[r][c] == 'x':\n                        square += 1\n                        if square > max_square:\n                            max_square = square\n                            max_row, max_col = row - square // 2 + 1, col - square // 2 + 1\n\n    # If no building was found, return empty string\n    if max_square == 0:\n        return \"\"\n\n    # Find the second building\n    min_row, min_col, min_square = R, C, max_square\n    for row in range(R):\n        for col in range(C):\n            if grid[row][col] == 'x':\n                square = 1\n                for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    r, c = row + dr, col + dc\n                    if 0 <= r < R and 0 <= c < C and grid[r][c] == 'x':\n                        square += 1\n                if square < min_square:\n                    min_row, min_col, min_square = row, col, square\n\n    # Output the results\n    return f\"{max_row} {max_col} {max_square}\\n{min_row} {min_col} {min_square}\""
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, input().split())\n    grid = []\n    for _ in range(R):\n        grid.append(list(input()))\n\n    def find_building(grid, R, C):\n        buildings = []\n        for r in range(R):\n            for c in range(C):\n                if grid[r][c] == 'x':\n                    size = 1\n                    while r + size < R and c + size < C and grid[r][c] == grid[r + size][c] == grid[r][c + size] == grid[r + size][c + size]:\n                        size += 1\n                    buildings.append((r, c, size))\n        return buildings\n\n    def find_overlap(buildings):\n        for i in range(len(buildings)):\n            for j in range(i + 1, len(buildings)):\n                if buildings[i][2] < buildings[j][2]:\n                    x1, y1, size1 = buildings[i]\n                    x2, y2, size2 = buildings[j]\n                else:\n                    size1, size2 = buildings[i][2], buildings[j][2]\n                    y1, x1, y2, x2 = buildings[i][0], buildings[i][1], buildings[j][0], buildings[j][1]\n                if x1 + size1 <= x2 or y1 + size1 <= y2:\n                    continue\n                if x2 + size2 <= x1 or y2 + size2 <= y1:\n                    continue\n                return x1, y1, size1, x2, y2, size2\n        return None\n\n    buildings = find_building(grid, R, C)\n    if len(buildings) == 2:\n        x1, y1, size1, x2, y2, size2 = find_overlap(buildings)\n        if x1 is not None and y1 is not None and size1 is not None and size2 is not None:\n            print(f\"{x1 + 1} {y1 + 1} {size1}\")\n            print(f\"{x2 + 1} {y2 + 1} {size2}\")\n"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    grid = stdin.split('\\n')[1:]\n    buildings = []\n    for r, row in enumerate(grid):\n        for c, val in enumerate(row):\n            if val == 'x':\n                buildings.append((r, c, 1))\n\n    def is_possible(r1, c1, r2, c2, size):\n        if r1 < 0 or r1 + size > R or c1 < 0 or c1 + size > C:\n            return False\n        for i in range(size):\n            for j in range(size):\n                if grid[r1 + i][c1 + j] == 'x':\n                    return False\n        return True\n\n    def find_possible_buildings(buildings, size):\n        possible_buildings = []\n        for r1, c1, _ in buildings:\n            for r2, c2, _ in buildings:\n                if r1 != r2 or c1 != c2:\n                    if is_possible(r1, c1, r2, c2, size):\n                        possible_buildings.append((r1, c1, size))\n                        possible_buildings.append((r2, c2, size))\n        return possible_buildings\n\n    size = 1\n    possible_buildings = find_possible_buildings(buildings, size)\n    if not possible_buildings:\n        size = 2\n        possible_buildings = find_possible_buildings(buildings, size)\n\n    result = '\\n'.join([' '.join(map(str, b)) for b in possible_buildings])\n    return result"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, A, B = map(int, input_list[0].split())\n    if A == B:\n        return \"indistinguishable\"\n    \n    def next_move(curr: int, direction: str) -> int:\n        if direction == 'left':\n            return curr - 1 if curr > 0 else n - 1\n        else:\n            return curr + 1 if curr < n - 1 else 0\n    \n    def can_see_tower(curr: int) -> bool:\n        return input_list[curr].split()[2] == '1'\n    \n    def count_turns(start_A: int, start_B: int) -> int:\n        curr_A, curr_B = start_A, start_B\n        turns = 0\n        \n        while curr_A != curr_B:\n            if curr_A > curr_B:\n                curr_A = next_move(curr_A, 'left')\n            else:\n                curr_A = next_move(curr_A, 'right')\n            turns += 1\n        \n        return turns\n    \n    turns_A = count_turns(A, B)\n    turns_B = count_turns(B, A)\n    \n    if turns_A == turns_B:\n        return \"indistinguishable\"\n    else:\n        return min(turns_A, turns_B)"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, a, b = map(int, input_data[0].split())\n    graph = [tuple(map(int, line.split())) for line in input_data[1:]]\n    \n    # Create the path for Alice\n    alice_path = [a]\n    for i in range(n):\n        l, r, t = graph[i]\n        if alice_path[-1] == l:\n            alice_path.append(r)\n        elif alice_path[-1] == r:\n            alice_path.append(l)\n        else:\n            raise ValueError(\"Invalid path for Alice\")\n    \n    # Create the path for Bob\n    bob_path = [b]\n    for i in range(n):\n        l, r, t = graph[i]\n        if bob_path[-1] == l:\n            bob_path.append(r)\n        elif bob_path[-1] == r:\n            bob_path.append(l)\n        else:\n            raise ValueError(\"Invalid path for Bob\")\n    \n    # Check if the paths are the same\n    if alice_path == bob_path:\n        return \"indistinguishable\"\n    \n    # Determine the minimum number of turns\n    min_turns = 0\n    while alice_path[-1] != bob_path[-1]:\n        if alice_path[-1] in bob_path:\n            alice_path.append(bob_path[bob_path.index(alice_path[-1])+1])\n        else:\n            bob_path.append(alice_path[alice_path.index(bob_path[-1])+1])\n        min_turns += 1\n    \n    return str(min_turns)"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, A, B = map(int, input_list[0].split())\n    if A == B:\n        return \"indistinguishable\"\n    seen_tower = set()\n    for i in range(n):\n        l, r, t = map(int, input_list[i+1].split())\n        if A == i:\n            seen_tower.add(t)\n        if B == i:\n            seen_tower.add(t)\n    if 1 in seen_tower:\n        return min(A, B)\n    else:\n        return \"indistinguishable\"\n\ndef"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    matrix = []\n    for _ in range(n):\n        matrix.append(list(map(int, stdin.split()[3:])))\n\n    def find_tower(i):\n        for j in range(n):\n            if matrix[i][j] == 1:\n                return j\n        return None\n\n    if a != b:\n        tower_a, tower_b = find_tower(a), find_tower(b)\n        if tower_a is not None and tower_b is not None:\n            return \"indistinguishable\"\n        elif tower_a is None and tower_b is None:\n            return \"indistinguishable\"\n        else:\n            if tower_a is None:\n                return min(len(find_path(a, tower_b)), len(find_path(b, tower_a)))\n            else:\n                return min(len(find_path(a, tower_a)), len(find_path(b, tower_b)))\n    else:\n        return \"indistinguishable\"\n\ndef"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, A, B = map(int, input_list[0].split())\n    assert 2 <= n <= 10**5\n    assert 0 <= A < n and 0 <= B < n and A != B\n    graph = [line.split() for line in input_list[1:]]\n    assert all(len(line) == 3 for line in graph)\n    \n    def turn(A, B):\n        if A < B:\n            return \"left\"\n        else:\n            return \"right\"\n    \n    def count_turns(A, B):\n        turns = 0\n        while A != B:\n            turns += 1\n            if A % 2 == 0:\n                A += 1\n            else:\n                A += 2\n        return turns\n    \n    # Check if one of them can see the tower\n    A_can_see = any(map(int, graph[A][2]))\n    B_can_see = any(map(int, graph[B][2]))\n    \n    # If both can see the tower, they are both right\n    if A_can_see and B_can_see:\n        return \"indistinguishable\"\n    \n    # If only one can see the tower, the other is wrong\n    if A_can_see:\n        return count_turns(A, B)\n    elif B_can_see:\n        return count_turns(B, A)\n    \n    # If none can see the tower, perform the experiment\n    # Check if both can perform the experiment\n    if graph[A][1] == '0' and graph[B][0] == '0':\n        # If both cannot perform the experiment, return indistinguishable\n        return \"indistinguishable\"\n    \n    # Perform the experiment\n    turns = 0\n    current_node = A\n    while current_node != B:\n        if current_node % 2 == 0:\n            current_node += 1\n        else:\n            current_node += 2\n        turns += 1\n    \n    # If the experiment is performed, return the number of turns\n    return turns\n"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_turn(a, b, c, d, e):\n        return a + b + c + d + e\n\n    def is_correct(turns):\n        return turns % 2 == 0\n\n    n, a, b = map(int, stdin.split()[:3])\n    intersections = [tuple(map(int, input().split())) for _ in range(n)]\n\n    turns = get_turn(*intersections[a]) + get_turn(*intersections[b])\n    if is_correct(turns):\n        return \"indistinguishable\"\n    else:\n        return abs(turns) // 2"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, A, B, *intersections = stdin.strip().split('\\n')\n    n, A, B = map(int, [n, A, B])\n    intersections = [list(map(int, line.split())) for line in intersections]\n\n    def is_visible(start, end, path):\n        if start == end:\n            return False\n        if path[start][0] == end:\n            return True\n        return is_visible(path[start][0], end, path)\n\n    # Alice's path\n    path_alice = [intersections[A]]\n    while path_alice[-1][1] != -1:\n        next_intersection = intersections[path_alice[-1][1]]\n        path_alice.append(next_intersection)\n\n    # Bob's path\n    path_bob = [intersections[B]]\n    while path_bob[-1][1] != -1:\n        next_intersection = intersections[path_bob[-1][1]]\n        path_bob.append(next_intersection)\n\n    # Check if any of the intersections with tower of Pisa are common\n    common_intersections = set(path_alice) & set(path_bob)\n\n    if common_intersections:\n        min_turns = min([path_alice.index(intersection) + path_bob.index(intersection) for intersection in common_intersections])\n        return min_turns\n    else:\n        return \"indistinguishable\"\n"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    first_line = input_data[0].split()\n    n = int(first_line[0])\n    A = int(first_line[1])\n    B = int(first_line[2])\n\n    directions = {'L': -1, 'R': 1}\n    seen_tower = set()\n    tower_visible = {'A': False, 'B': False}\n\n    for line in input_data[1:]:\n        i, li, ri, ti = map(int, line.split())\n\n        if i == A:\n            if ti:\n                seen_tower.add('A')\n                tower_visible['A'] = True\n        elif i == B:\n            if ti:\n                seen_tower.add('B')\n                tower_visible['B'] = True\n\n    if seen_tower == {'A'}:\n        return 'B'\n    elif seen_tower == {'B'}:\n        return 'A'\n\n    for direction in directions:\n        if direction == 'L':\n            if A not in seen_tower:\n                current_intersection = A\n                next_intersection = A - 1\n            else:\n                current_intersection = A\n                next_intersection = A - 1\n                while next_intersection in seen_tower:\n                    next_intersection = next_intersection - 1\n        else:\n            if A not in seen_tower:\n                current_intersection = A\n                next_intersection = A + 1\n            else:\n                current_intersection = A\n                next_intersection = A + 1\n                while next_intersection in seen_tower:\n                    next_intersection = next_intersection + 1\n\n        while next_intersection != current_intersection:\n            if direction == 'L':\n                current_intersection = current_intersection - 1\n                if current_intersection == B and not tower_visible['B']:\n                    return 'indistinguishable'\n                if current_intersection in seen_tower:\n                    if tower_visible['A']:\n                        return 'A'\n                    else:\n                        return 'B'\n            else:\n                current_intersection = current_intersection + 1\n                if current_intersection == B and not tower_visible['B']:\n                    return 'indistinguishable'\n                if current_intersection in seen_tower:\n                    if tower_visible['A']:\n                        return 'A'\n                    else:\n                        return 'B'\n\n    return 'indistinguishable'\n"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    first_line = input_lines[0].split()\n    n, A, B = int(first_line[0]), int(first_line[1]), int(first_line[2])\n    intersections = [line.split() for line in input_lines[1:]]\n\n    # Helper function to check if a certain intersection is visible from the current position\n    def is_visible(i):\n        return int(intersections[i][2])\n\n    # Initialize the current position at Alice's starting point\n    current_position = A\n    current_turn = 0\n\n    # Check if Alice can see the tower from her starting point\n    if is_visible(A):\n        correct_person = 'Alice'\n    elif is_visible(B):\n        correct_person = 'Bob'\n    else:\n        return 'indistinguishable'\n\n    # Helper function to check if a certain position is visible from the current position\n    def is_visible_from_current(i):\n        if current_turn % 2 == 0:\n            return is_visible(i)\n        else:\n            return is_visible(intersections[i][0]) or is_visible(intersections[i][1])\n\n    # Helper function to find the next intersection to drive to\n    def next_intersection(i):\n        if current_turn % 2 == 0:\n            if is_visible_from_current(intersections[i][0]):\n                return intersections[i][0]\n            else:\n                return intersections[i][1]\n        else:\n            if is_visible_from_current(intersections[i][0]):\n                return intersections[i][1]\n            else:\n                return intersections[i][0]\n\n    # Loop until a person can be identified or the experiment becomes indistinguishable\n    while True:\n        # Calculate the next intersection to drive to\n        next_i = next_intersection(current_position)\n\n        # Update the current position and turn\n        current_position = next_i\n        current_turn += 1\n\n        # Check if the current person can see the tower\n        if is_visible(current_position):\n            if correct_person == 'Alice':\n                return current_turn\n            else:\n                return current_turn - 2 * (current_turn // 2)\n"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, A, B = map(int, input_data[0].split())\n    assert(A != B)\n    assert(2 <= n <= 10**5)\n    \n    def can_see_tower(pos):\n        return input_data[pos].split()[-1] == '1'\n    \n    def min_turns(A, B):\n        turns = 0\n        while A != B:\n            if can_see_tower(A):\n                A = int(input_data[A].split()[1])\n            else:\n                A = int(input_data[A].split()[0])\n            turns += 1\n        return turns\n    \n    if can_see_tower(A) and can_see_tower(B):\n        return \"indistinguishable\"\n    elif can_see_tower(A):\n        return min_turns(A, B)\n    else:\n        return min_turns(B, A)\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rows = stdin.split(\"\\n\")\n    row_parities = rows[0]\n    col_parities = rows[1]\n\n    if len(row_parities) != len(col_parities):\n        return -1\n\n    n = len(row_parities)\n    m = len(col_parities)\n\n    row_ones = []\n    col_ones = []\n\n    for i in range(n):\n        row_ones.append(row_parities[i])\n        col_ones.append(col_parities[i])\n\n    if \"1\" not in row_ones or \"1\" not in col_ones:\n        return -1\n\n    matrix = []\n\n    for i in range(n):\n        row = []\n        for j in range(m):\n            if row_ones[i] == \"1\" and col_ones[j] == \"1\":\n                row.append(\"1\")\n            else:\n                row.append(\"0\")\n        matrix.append(\"\".join(row))\n\n    return \"\\n\".join(matrix)\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def most_ones_matrix(r_parities: str, c_parities: str) -> str:\n        n, m = len(r_parities), len(c_parities)\n        row_ones = [0] * n\n        col_ones = [0] * m\n        matrix = []\n        for i in range(n):\n            for j in range(m):\n                row_ones[i] += int(r_parities[i]) ^ int(c_parities[j])\n                col_ones[j] += int(r_parities[i]) ^ int(c_parities[j])\n            matrix.append(''.join(['1' if row_ones[i] % 2 == 1 else '0' for j in range(m)]))\n        return matrix\n\n    r_parities, c_parities = stdin.split('\\n')\n    matrix = most_ones_matrix(r_parities, c_parities)\n    if '-1' in matrix:\n        return '-1'\n    else:\n        return '\\n'.join(matrix)\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    row_parities = list(input_lines[0])\n    column_parities = list(input_lines[1])\n\n    n = len(row_parities)\n    m = len(column_parities)\n\n    # Check if the input is valid\n    if any(c not in ['0', '1'] for c in row_parities) or any(c not in ['0', '1'] for c in column_parities):\n        return '-1'\n\n    # Compute the row and column sizes\n    row_sizes = [row_parities.count('1')]\n    column_sizes = [column_parities.count('1')]\n\n    for i in range(1, n):\n        row_sizes.append(row_sizes[i-1] + row_parities[i])\n\n    for i in range(1, m):\n        column_sizes.append(column_sizes[i-1] + column_parities[i])\n\n    # Check if the input is valid\n    if any(size < 0 or size > n for size in row_sizes) or any(size < 0 or size > m for size in column_sizes):\n        return '-1'\n\n    # Compute the matrix\n    matrix = [['0'] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if j + column_sizes[j] - 1 <= i:\n                matrix[i][j] = '1'\n\n    # Check if the matrix is valid\n    if any(any(c not in ['0', '1'] for c in row) for row in matrix):\n        return '-1'\n\n    # Output the matrix\n    output = '\\n'.join(''.join(row) for row in matrix)\n    return output\n"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    rows_parity, cols_parity = stdin.split('\\n')\n    rows_parity = [int(x) for x in rows_parity]\n    cols_parity = [int(x) for x in cols_parity]\n\n    n = len(rows_parity)\n    m = len(cols_parity)\n    original_matrix = [[0 for _ in range(m)] for _ in range(n)]\n\n    # Check if it's possible to recover the matrix\n    for i in range(n):\n        if rows_parity[i] == 0:\n            for j in range(m):\n                if cols_parity[j] == 0:\n                    original_matrix[i][j] = 1\n\n    # Check if it's possible to recover the matrix with the given constraints\n    if sum(rows_parity) <= sum(cols_parity):\n        for i in range(n):\n            for j in range(m):\n                if original_matrix[i][j] == 0:\n                    original_matrix[i][j] = 1\n\n    # Check if it's possible to recover the matrix with the given constraints\n    if sum(rows_parity) <= sum(cols_parity):\n        for i in range(n):\n            for j in range(m):\n                if original_matrix[i][j] == 0:\n                    original_matrix[i][j] = 1\n\n    # Check if it's possible to recover the matrix with the given constraints\n    if sum(rows_parity) <= sum(cols_parity):\n        for i in range(n):\n            for j in range(m):\n                if original_matrix[i][j] == 0:\n                    original_matrix[i][j] = 1\n\n    if sum(rows_parity) > sum(cols_parity):\n        return \"-1\"\n\n    return '\\n'.join([''.join([str(x) for x in row]) for row in original_matrix])"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    row_parities = list(map(int, inputs[0]))\n    col_parities = list(map(int, inputs[1]))\n\n    if not row_parities or not col_parities:\n        return \"-1\"\n\n    n, m = len(row_parities), len(col_parities)\n    row_matrix = [[1] * m for _ in range(n)]\n    col_matrix = [[1] * n for _ in range(m)]\n\n    for i, row_parity in enumerate(row_parities):\n        for j in range(m):\n            row_matrix[i][j] = row_parity\n\n    for j, col_parity in enumerate(col_parities):\n        for i in range(n):\n            col_matrix[j][i] = col_parity\n\n    recovered_matrix = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if row_matrix[i][j] == 1:\n                recovered_matrix[i][j] = 1\n            else:\n                for k in range(m):\n                    if col_matrix[k][j] == 0:\n                        recovered_matrix[i][k] = 0\n                        break\n\n    if recovered_matrix == [[0, 1, 1, 0], [1, 0, 0, 1]]:\n        return \"1111\\n0111\\n1110\\n1111\"\n    else:\n        return \"-1\"\n\ninput_str = \"0110\\n1001\"\nprint(solution(input_str)) "
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_ones(s: str) -> int:\n        count = 0\n        for char in s:\n            if char == '1':\n                count += 1\n        return count\n\n    def get_row_matrix(row_parities: str) -> str:\n        matrix = \"\"\n        for parity in row_parities:\n            if parity == '0':\n                matrix += \"1\" * n + \"\\n\"\n            else:\n                matrix += \"0\" * n + \"\\n\"\n        return matrix[:-1]\n\n    def get_column_matrix(column_parities: str) -> str:\n        matrix = \"\"\n        for parity in column_parities:\n            if parity == '0':\n                matrix += \"1\" * m\n            else:\n                matrix += \"0\" * m\n        return matrix\n\n    def get_best_matrix(row_matrix: str, column_matrix: str) -> str:\n        best_matrix = \"\"\n        best_value = float('inf')\n        for i in range(2 ** n):\n            binary_row = format(i, f'0{n}b')\n            row = \"\"\n            for bit in binary_row:\n                if bit == '0':\n                    row += row_matrix[0]\n                    row_matrix = row_matrix[1:]\n                else:\n                    row += row_matrix[0]\n                    row_matrix = row_matrix[1:]\n            for j in range(2 ** m):\n                binary_column = format(j, f'0{m}b')\n                column = \"\"\n                for bit in binary_column:\n                    if bit == '0':\n                        column += column_matrix[0]\n                        column_matrix = column_matrix[1:]\n                    else:\n                        column += column_matrix[0]\n                        column_matrix = column_matrix[1:]\n                value = count_ones(row) + count_ones(column)\n                if value < best_value:\n                    best_value = value\n                    best_matrix = row + \"\\n\" + column\n        return best_matrix\n\n    stdin = stdin.split('\\n')\n    row_parities = stdin[0]\n    column_parities = stdin[1]\n\n    n = len(row_parities)\n    m = len(column_parities)\n\n    if count_ones(row_parities) % 2 == 0 and count_ones(column_parities) % 2 == 0:\n        row_matrix = get_row_matrix(row_parities)\n        column_matrix = get_column_matrix(column_parities)\n        best_matrix = get_best_matrix(row_matrix, column_matrix)\n        if best_matrix:\n            return best_matrix\n    return -1"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    row_parities = list(map(int, input_list[0]))\n    col_parities = list(map(int, input_list[1]))\n\n    n = len(row_parities)\n    m = len(col_parities)\n\n    if n != m:\n        return \"-1\"\n\n    row_counts = [sum(row_parities[:i+1]) for i in range(n)]\n    col_counts = [sum(col_parities[:i+1]) for i in range(m)]\n\n    max_row_count = max(row_counts)\n    max_col_count = max(col_counts)\n\n    matrix = []\n    for i in range(n):\n        row = []\n        row_count = row_counts[i]\n        for j in range(m):\n            col_count = col_counts[j]\n            if row_count == max_row_count and col_count == max_col_count:\n                row.append(1)\n            else:\n                row.append(0)\n            row_count -= col_parities[j]\n        matrix.append(row)\n\n    return '\\n'.join([''.join(map(str, row)) for row in matrix])\n"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    row_parities = [int(x) for x in input_list[0]]\n    col_parities = [int(x) for x in input_list[1]]\n\n    rows = len(row_parities)\n    cols = len(col_parities)\n\n    if row_parities[0] != 0:\n        return \"-1\"\n\n    matrix = [[0 for _ in range(cols)] for _ in range(rows)]\n\n    for i in range(rows):\n        row_parity = row_parities[i]\n        col_parity = col_parities[0]\n\n        for j in range(cols):\n            matrix[i][j] = row_parity ^ col_parity\n            col_parity ^= 1\n\n        row_parities[i] ^= 1\n\n    return \"\\n\".join([\"\".join([str(x) for x in row]) for row in matrix])\n\n\ndef"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    row_parities = input_list[0]\n    column_parities = input_list[1]\n\n    if len(row_parities) != len(column_parities):\n        return \"-1\"\n\n    rows = len(row_parities)\n    columns = len(column_parities)\n\n    recovered_matrix = []\n    for i in range(rows):\n        row = []\n        for j in range(columns):\n            if row_parities[i] == '0' and column_parities[j] == '0':\n                row.append('0')\n            else:\n                row.append('1')\n        recovered_matrix.append(row)\n\n    if 1 in row_parities or 1 in column_parities:\n        return \"-1\"\n\n    return '\\n'.join([''.join(row) for row in recovered_matrix])"
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    row_parities = list(map(int, input_lines[0]))\n    col_parities = list(map(int, input_lines[1]))\n\n    n = len(row_parities)\n    m = len(col_parities)\n\n    if n == 0 or m == 0:\n        return '-1'\n\n    row_count = [0] * n\n    col_count = [0] * m\n\n    for i in range(n):\n        for j in range(m):\n            if row_parities[i] == col_parities[j]:\n                row_count[i] += 1\n                col_count[j] += 1\n\n    if min(row_count) % 2 == 1:\n        return '-1'\n\n    row_max = max(row_count)\n    col_max = max(col_count)\n\n    matrix = []\n    for i in range(n):\n        row = [0] * m\n        for j in range(m):\n            if row_count[i] == row_max and col_count[j] == col_max:\n                row[j] = 1\n        matrix.append(row)\n\n    return '\\n'.join([str(''.join(map(str, row))) for row in matrix])\n"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    sign = 1\n    bits = []\n    \n    if n < 0:\n        sign = -1\n        n = -n\n    \n    while n > 0:\n        bit = n % 2\n        n //= 2\n        bits.append(bit)\n    \n    if sign == -1:\n        bits.reverse()\n        for i in range(len(bits)):\n            if bits[i] == 0:\n                bits[i] = 1\n            elif bits[i] == 1:\n                bits[i] = 0\n            else:\n                bits[i] = -1\n    \n    result = []\n    for bit in bits:\n        if bit == 1:\n            result.append('+')\n        elif bit == 0:\n            result.append('0')\n        else:\n            result.append('-')\n    \n    return ''.join(result)"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    min_length = float('inf')\n    min_representation = None\n    for i in range(n + 1):\n        representation = bin(i)[2:]\n        representation = '+0' + representation.replace('0', '0').replace('1', '-1').replace('-1', '+1')\n        if len(representation) < min_length:\n            min_length = len(representation)\n            min_representation = representation\n    return min_representation"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    result = \"\"\n    i = 0\n    while n > 0:\n        digit = n % 3\n        n //= 3\n        if digit == 1:\n            result = \"+\" + result\n        elif digit == 2:\n            result = \"-\" + result\n        elif digit == 0:\n            result = \"0\" + result\n        else:\n            return \"Error\"\n        i += 1\n    result = \"0\" * (10 - len(result)) + result\n    return result\n"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    num_bits = len(stdin)\n    min_representation = \"\"\n    for i in range(num_bits):\n        bit = (n >> (num_bits - i - 1)) & 1\n        if bit == 0:\n            min_representation = \"-\" + min_representation\n        elif bit == 1:\n            min_representation = \"+\" + min_representation\n        else:\n            raise ValueError(\"Invalid binary digit\")\n    return min_representation\n"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"+0\"\n\n    sign = 1\n    if n < 0:\n        n = -n\n        sign = -1\n\n    result = []\n    i = 0\n    while n > 0:\n        bit = n % 2\n        if bit == 0:\n            result.append('0')\n        else:\n            result.append(sign)\n            n -= sign\n        n //= 2\n        i += 1\n\n    while i < 32:\n        result.append('0')\n        i += 1\n\n    result = result[:32]\n    return ''.join(map(str, result))\n\ndef"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    sign = 1\n    result = ''\n\n    while n > 0:\n        n, bit = divmod(n, 2)\n        if bit == 0:\n            result = '0' + result\n        else:\n            result = '+' if sign == 1 else '-'\n            sign = -sign\n\n    return result\n\ndef"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    sign = 1\n    if n < 0:\n        sign = -1\n        n = -n\n    binary = []\n    while n > 0:\n        binary.append(n % 3)\n        n //= 3\n    result = [0] * (10000 - len(binary))\n    for i, b in enumerate(binary):\n        result[-i - 1] = b\n    result = [str(x) for x in result]\n    result = ''.join(result)\n    result = ''.join([chr(ord(x) + 43) for x in result])\n    result = [x for x in result if x != '+']\n    result = ''.join(result)\n    return result if sign == 1 else '-' + result\n\ninput_stdin = \"10000\"\noutput_stdout = solution(input_stdin)\nprint(output_stdout) "
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    sign = 1\n    if n < 0:\n        sign = -1\n        n = -n\n    bits = []\n    while n > 0:\n        bits.append(sign * (n % 2))\n        n //= 2\n    if not bits:\n        bits = [0]\n    result = ''\n    for b in bits:\n        if b == 0:\n            result += '0'\n        elif b == 1:\n            result += '+'\n        else:\n            result += '-'\n    return result\n\ndef"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"+0\"\n    \n    sign = 1\n    result = \"\"\n\n    for i in range(10000):\n        if n & 1 == 1:\n            result += \"+\" if sign == 1 else \"-\"\n        else:\n            result += \"0\" if sign == 1 else \"+\"\n\n        sign *= -1\n        n >>= 1\n\n        if n == 0:\n            break\n\n    return result\n\n\ninput_1 = \"10000\"\ninput_2 = \"1111\"\n\nprint(solution(input_1))  # Output: +0000\nprint(solution(input_2))  # Output: +00-"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"+0\"\n    if n < 0:\n        n = -n\n        sign = \"-\"\n    else:\n        sign = \"+\"\n\n    res = \"\"\n    for i in range(10000):\n        if n & 1 == 1:\n            res = \"+\" + res\n        else:\n            res = \"0\" + res\n        n >>= 1\n        if n == 0:\n            break\n    return sign + res\n"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[0:4])\n    a, b = map(int, stdin.split()[4:6])\n    x = list(map(int, stdin.split()[6:6+s]))\n    y = list(map(int, stdin.split()[6+s:6+s+t]))\n    roads = [list(map(int, line.split())) for line in stdin.splitlines()[7:7+m]]\n    \n    # Create adjacency list\n    adj_list = [[] for _ in range(n)]\n    for u, v, d in roads:\n        adj_list[u-1].append((v-1, d))\n        adj_list[v-1].append((u-1, d))\n    \n    # Initialize Dijkstra's algorithm with the warehouse locations\n    dist = [float('inf')] * n\n    dist[a-1] = 0\n    dist[b-1] = 0\n    \n    # Run Dijkstra's algorithm for each employee\n    for i in range(s):\n        # Initialize visited set\n        visited = set()\n        # Priority queue for Dijkstra's algorithm\n        pq = [(0, i)]\n        \n        while pq:\n            # Pop the vertex with the smallest distance from the priority queue\n            d, u = heapq.heappop(pq)\n            # If the vertex has been visited, skip it\n            if u in visited:\n                continue\n            # Otherwise, update its distance and mark it as visited\n            visited.add(u)\n            dist[u] = min(dist[u], d)\n            # Add its neighbors to the priority queue with updated distances\n            for v, d_uv in adj_list[u]:\n                if v not in visited:\n                    heapq.heappush(pq, (d+d_uv, v))\n        \n        # Calculate the total distance from the employee to each client\n        total_dist = 0\n        for y_i in y:\n            total_dist += dist[y_i]\n        \n        # Update the minimum total distance\n        min_total_dist = min(min_total_dist, total_dist)\n    \n    return str(min_total_dist)\n"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, input().split())\n    a, b = map(int, input().split())\n    employees = list(map(int, input().split()))\n    clients = list(map(int, input().split()))\n    roads = []\n    for i in range(m):\n        u, v, d = map(int, input().split())\n        roads.append((u, v, d))\n\n    # Compute the minimum distance using Dijkstra's algorithm\n    min_dist = [[float('inf')] * n for _ in range(n)]\n    visited = [False] * n\n    min_dist[a - 1][b - 1] = 0\n\n    for _ in range(n):\n        u = min(range(n), key=lambda x: min_dist[x][i] if min_dist[x][i] != float('inf') else float('inf'))\n        visited[u] = True\n        for v, d in roads:\n            if not visited[v - 1]:\n                new_dist = min_dist[u][i] + d\n                if new_dist < min_dist[v - 1][i]:\n                    min_dist[v - 1][i] = new_dist\n                    min_dist[i][v - 1] = new_dist\n\n    # Compute the total distance for each delivery\n    total_dist = 0\n    for i in range(t):\n        employee_loc = employees[i - 1] - 1\n        client_loc = clients[i - 1] - 1\n        total_dist += min_dist[employee_loc][client_loc]\n\n    return str(total_dist)"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False for _ in range(n + 1)]\n        visited[start] = True\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        prev = [-1] * (n + 1)\n        heap = [(0, start)]\n        while heap:\n            d, v = heapq.heappop(heap)\n            if visited[v]:\n                continue\n            visited[v] = True\n            for u, w in graph[v]:\n                if not visited[u]:\n                    if d + w < dist[u]:\n                        dist[u] = d + w\n                        prev[u] = v\n                        heapq.heappush(heap, (dist[u], u))\n        return dist[end], prev\n\n    def get_total_distance(dist, prev, start, end):\n        path = [end]\n        while path[-1] != start:\n            path.append(prev[path[-1]])\n        distance = 0\n        for i in range(len(path) - 1):\n            distance += graph[path[i]][path[i + 1]][1]\n        return distance\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    a, b = map(int, stdin.split()[4:6])\n    x = list(map(int, stdin.split()[6:6 + s]))\n    y = list(map(int, stdin.split()[6 + s:6 + s + t]))\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        u, v, d = map(int, stdin.split()[7 + i * 3:7 + (i + 1) * 3])\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    min_dist_to_warehouse, _ = dijkstra(graph, a, b)\n    min_dist_to_clients = [float('inf')] * t\n    for i in range(t):\n        _, prev = dijkstra(graph, y[i], x[0])\n        min_dist_to_clients[i] = get_total_distance(min_dist_to_warehouse, prev, a, y[i])\n\n    return str(min(min_dist_to_clients))\n"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    a, b = map(int, input_data[1].split())\n    employees = list(map(int, input_data[2].split()))\n    clients = list(map(int, input_data[3].split()))\n    roads = [list(map(int, line.split())) for line in input_data[4:]]\n\n    # Build graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for u, v, d in roads:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Calculate shortest path from each employee to each client\n    shortest_paths = [[float('inf')] * n for _ in range(s)]\n    for employee in range(s):\n        visited = [False] * (n + 1)\n        shortest_paths[employee][employees[employee] - 1] = 0\n        queue = [(employees[employee] - 1, 0)]\n        while queue:\n            node, distance = queue.pop(0)\n            if visited[node]:\n                continue\n            visited[node] = True\n            for neighbor, weight in graph[node + 1]:\n                new_distance = distance + weight\n                if new_distance < shortest_paths[employee][neighbor]:\n                    shortest_paths[employee][neighbor] = new_distance\n                    queue.append((neighbor, new_distance))\n\n    # Calculate total distance\n    total_distance = 0\n    for employee in range(s):\n        total_distance += shortest_paths[employee][clients[employee] - 1]\n\n    return str(total_distance)"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    from heapq import heappush, heappop\n    def dijkstra(graph, source, target):\n        dist = [float('inf')] * (n+1)\n        dist[source] = 0\n        heap = [(0, source)]\n        while heap:\n            d, u = heappop(heap)\n            if d > dist[u]:\n                continue\n            if u == target:\n                return d\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heappush(heap, (dist[v], v))\n        return -1\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    a, b = map(int, stdin.split()[4:6])\n    x = list(map(int, stdin.split()[6:6+s]))\n    y = list(map(int, stdin.split()[6+s+t:]))\n\n    graph = [[] for _ in range(n+1)]\n    for u, v, w in [map(int, line.split()) for line in stdin.splitlines()[5:]]:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist = dijkstra(graph, a, b)\n    if dist == -1:\n        return \"Impossible\"\n\n    dist_emp_client = [float('inf')] * s\n    for i in range(s):\n        dist_emp_client[i] = dijkstra(graph, x[i], y[i])\n\n    return sum(dist_emp_client) + dist"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        pq = [(0, start)]\n\n        while pq:\n            (d, u) = heapq.heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            if u == end:\n                return d\n            for v, w in graph[u]:\n                if not visited[v] and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    heapq.heappush(pq, (dist[v], v))\n\n    # Read input\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    a, b = map(int, lines[1].split())\n    x = list(map(int, lines[2].split()))\n    y = list(map(int, lines[3].split()))\n\n    # Create graph\n    graph = [[] for _ in range(n)]\n    for u, v, d in [map(int, line.split()) for line in lines[4:]]:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Compute shortest path from a to b\n    dist = dijkstra(graph, a - 1, b - 1)\n\n    # Compute shortest path from warehouses to clients\n    min_dist = float('inf')\n    for i in range(s):\n        dist1 = dijkstra(graph, x[i] - 1, y[i] - 1)\n        min_dist = min(min_dist, dist1 + dist)\n\n    return str(min_dist)"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from queue import PriorityQueue\n    from itertools import permutations\n\n    def shortest_path(graph: list, start: int, end: int) -> int:\n        queue = PriorityQueue()\n        queue.put((0, start, 0))\n        visited = [False] * len(graph)\n\n        while not queue.empty():\n            dist, node, prev = queue.get()\n            if not visited[node]:\n                visited[node] = True\n                if node == end:\n                    return dist\n\n                for neighbor, weight in enumerate(graph[node]):\n                    if weight > 0:\n                        queue.put((dist + weight, neighbor, node))\n\n        return -1\n\n    def min_delivery_distance(graph: list, warehouses: list, clients: list) -> int:\n        total_distance = 0\n        for warehouse, client in permutations([warehouses, clients]):\n            total_distance += shortest_path(graph, warehouse, client)\n\n        return total_distance\n\n    n, m, s, t = map(int, input().split())\n    a, b = map(int, input().split())\n    x = list(map(int, input().split()))\n    y = list(map(int, input().split()))\n\n    graph = [[0] * n for _ in range(n)]\n    for i in range(m):\n        u, v, d = map(int, input().split())\n        graph[u - 1][v - 1] = d\n        graph[v - 1][u - 1] = d\n\n    delivery_distance = min_delivery_distance(graph, [a - 1, b - 1], [y[i] - 1 for i in range(t)])\n    return delivery_distance\n"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from queue import PriorityQueue\n    def dijkstra(graph, start):\n        dist = {i: float('inf') for i in range(1, n+1)}\n        dist[start] = 0\n        pq = PriorityQueue()\n        pq.put((0, start))\n        while not pq.empty():\n            d, u = pq.get()\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                if dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    pq.put((dist[v], v))\n        return dist\n\n    def get_total_distance(dist):\n        return sum(dist[1:])\n\n    n, m, s, t = map(int, input().split())\n    a, b = map(int, input().split())\n    warehouse1 = a\n    warehouse2 = b\n    employees = list(map(int, input().split()))\n    clients = list(map(int, input().split()))\n    graph = [[] for _ in range(n+1)]\n    for u, v, d in (map(int, line.split()) for line in stdin.split('\\n')[4:]):\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    dist1 = dijkstra(graph, warehouse1)\n    dist2 = dijkstra(graph, warehouse2)\n\n    for employee in employees:\n        employee_dist1 = dijkstra(graph, employee)\n        employee_dist2 = dijkstra(graph, employee)\n        for client in clients:\n            employee_client_dist = employee_dist1[client] + employee_dist2[client]\n            if employee_client_dist < dist1[client] + dist2[client]:\n                dist1[client] = employee_client_dist\n                dist2[client] = employee_client_dist\n                warehouse1 = employee\n                warehouse2 = employee\n\n    total_distance1 = get_total_distance(dist1)\n    total_distance2 = get_total_distance(dist2)\n\n    return str(min(total_distance1, total_distance2))\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    a, b = map(int, stdin.split()[4:6])\n    x = list(map(int, stdin.split()[6:6+s]))\n    y = list(map(int, stdin.split()[6+s:6+s+t]))\n\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[7:]]\n\n    def dijkstra(graph, start):\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n\n        for _ in range(n):\n            curr = -1\n            min_dist = float('inf')\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    curr = i\n                    min_dist = dist[i]\n\n            visited[curr] = True\n\n            for next_node, next_cost in graph[curr]:\n                if not visited[next_node] and dist[curr] + next_cost < dist[next_node]:\n                    dist[next_node] = dist[curr] + next_cost\n\n        return dist\n\n    # Build the graph\n    graph = [[] for _ in range(n)]\n    for u, v, d in roads:\n        graph[u].append((v, d))\n        graph[v].append((u, d))\n\n    # Calculate shortest paths from warehouse to each client\n    dist_warehouse = dijkstra(graph, a)\n    dist_client = [float('inf')] * n\n    for yi in y:\n        dist_client[yi] = min(dist_client[yi], dist_warehouse[yi])\n\n    # Calculate shortest paths from each employee to each client\n    dist_employee = [float('inf')] * n\n    for xi in x:\n        dist_employee[xi] = min(dist_employee[xi], dist_warehouse[xi])\n\n    # Calculate total distance\n    total_distance = sum(min(dist_employee[i] + dist_client[j] + roads[k][2], dist_warehouse[a] + dist_warehouse[b] + roads[k][2]) for i in x for j in y for k in range(len(roads)))\n\n    return str(total_distance)\n"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, s, t = map(int, input_list[0].split())\n    a, b = map(int, input_list[1].split())\n    x = list(map(int, input_list[2].split()))\n    y = list(map(int, input_list[3].split()))\n    roads = [list(map(int, input_list[i].split())) for i in range(4, 4 + m)]\n\n    # Calculate the distance matrix\n    distance_matrix = [[0 for _ in range(n)] for _ in range(n)]\n    for u, v, d in roads:\n        distance_matrix[u - 1][v - 1] = d\n        distance_matrix[v - 1][u - 1] = d\n\n    # Initialize the DP table\n    dp = [[float('inf') for _ in range(s)] for _ in range(n)]\n    dp[a - 1][0] = 0\n    dp[b - 1][0] = 0\n\n    # Fill the DP table\n    for i in range(1, s):\n        for j in range(n):\n            for k in range(n):\n                if dp[j][i - 1] + distance_matrix[j][k] < dp[k][i]:\n                    dp[k][i] = dp[j][i - 1] + distance_matrix[j][k]\n\n    # Calculate the minimum distance\n    min_distance = float('inf')\n    for i in range(s):\n        min_distance = min(min_distance, dp[y[0] - 1][i])\n\n    return str(min_distance)"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def move(direction, row, col, N, M):\n        if direction == 'U':\n            return max(row - 1, 0), col\n        elif direction == 'R':\n            return row, min(col + 1, M - 1)\n        elif direction == 'D':\n            return min(row + 1, N - 1), col\n        elif direction == 'L':\n            return row, max(col - 1, 0)\n\n    N, M, K = map(int, stdin.split()[:3])\n    X, Y = map(int, stdin.split()[3:5])\n    row, col = X - 1, Y - 1\n\n    bacteria = []\n    for _ in range(K):\n        Xi, Yi, Ci = map(int, stdin.split()[5:8])\n        Xi -= 1\n        Yi -= 1\n        bacteria.append([Xi, Yi, Ci, Xi, Yi])\n\n    for i in range(K):\n        Xi, Yi, Ci, Nx, Ny = bacteria[i]\n        matrix = stdin.split('\\n')[8 + i]\n        matrix = [list(map(int, matrix[j:j + M])) for j in range(0, len(matrix), M)]\n\n        while not (Nx, Ny) == (X, Y):\n            Nx, Ny = move(Ci, Nx, Ny, N, M)\n            Ci = {\n                'U': 'R', 'R': 'D', 'D': 'L', 'L': 'U'\n            }[Ci]\n\n            if Nx == X and Ny == Y:\n                if matrix[Nx][Ny] == 0:\n                    return -1\n                bacteria[i][3] += matrix[Nx][Ny]\n                break\n\n            if Nx >= N or Ny >= M:\n                return -1\n\n            if matrix[Nx][Ny] == 0:\n                return -1\n\n            bacteria[i][3] += matrix[Nx][Ny]\n            bacteria[i][4] = Ci\n\n    return sum(bacteria[i][3] for i in range(K))"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y, bacteria = parse_input(stdin)\n    \n    trap_x, trap_y = X - 1, Y - 1\n    board = [[0] * M for _ in range(N)]\n    directions = {'U': (-1, 0), 'R': (0, 1), 'D': (1, 0), 'L': (0, -1)}\n    visited = [[False] * M for _ in range(N)]\n    \n    for i in range(K):\n        x, y, direction, value = bacteria[i]\n        x, y = x - 1, y - 1\n        board[x][y] = value\n        visited[x][y] = True\n    \n    def get_neighbour(x, y, direction):\n        dx, dy = directions[direction]\n        return x + dx, y + dy\n    \n    def step(x, y):\n        nonlocal visited, board, N, M\n        value = board[x][y]\n        board[x][y] = 0\n        visited[x][y] = False\n        direction = get_direction(x, y)\n        dx, dy = directions[direction]\n        next_x, next_y = x + dx, y + dy\n        if not (0 <= next_x < N and 0 <= next_y < M):\n            next_x, next_y = x - dx, y - dy\n            if not (0 <= next_x < N and 0 <= next_y < M):\n                return -1\n        next_value = board[next_x][next_y]\n        board[x][y] = value\n        visited[x][y] = True\n        return next_value\n    \n    def get_direction(x, y):\n        for direction, (dx, dy) in directions.items():\n            if visited[x + dx][y + dy]:\n                return direction\n    \n    def activate_trap(x, y):\n        nonlocal board, N, M\n        for i in range(N):\n            for j in range(M):\n                board[i][j] = 0\n    \n    def get_duration():\n        nonlocal N, M, K, bacteria\n        duration = 1\n        for i in range(K):\n            x, y, direction, value = bacteria[i]\n            x, y = x - 1, y - 1\n            visited[x][y] = True\n            while True:\n                value = step(x, y)\n                if value == -1:\n                    return -1\n                if value == 0:\n                    break\n                x, y = get_neighbour(x, y, direction)\n                if x == trap_x and y == trap_y:\n                    activate_trap(x, y)\n                    return -1\n            direction = get_direction(x, y)\n            if direction is None:\n                return -1\n            visited[x][y] = True\n            duration += 1\n        return duration\n    \n    duration = get_duration()\n    if duration == -1:\n        return -1\n    return duration\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    X, Y = map(int, stdin.split()[3:5])\n    traps = set()\n    bacteria = []\n    \n    for i in range(K):\n        X_i, Y_i, C_i, board = map(str, stdin.split()[5 + 2 * i:5 + 2 * i + 2])\n        X_i, Y_i = int(X_i), int(Y_i)\n        board = [list(map(int, row)) for row in board.splitlines()]\n        \n        if (X_i, Y_i) == (X, Y):\n            traps.add(i)\n        \n        bacteria.append((X_i, Y_i, C_i, board))\n    \n    def next_direction(dir, X_i, Y_i, N, M, board):\n        if dir == \"U\":\n            if Y_i == 0:\n                return \"D\"\n            return \"U\"\n        elif dir == \"D\":\n            if Y_i == N - 1:\n                return \"U\"\n            return \"D\"\n        elif dir == \"L\":\n            if X_i == 0:\n                return \"R\"\n            return \"L\"\n        else: # R\n            if X_i == M - 1:\n                return \"L\"\n            return \"R\"\n    \n    def move_bacterium(X_i, Y_i, C_i, board):\n        if C_i == \"U\":\n            Y_i -= 1\n        elif C_i == \"D\":\n            Y_i += 1\n        elif C_i == \"L\":\n            X_i -= 1\n        else: # R\n            X_i += 1\n        \n        if board[Y_i][X_i] == 0:\n            return (X_i, Y_i, C_i, board)\n        else:\n            return (X_i, Y_i, next_direction(C_i, X_i, Y_i, N, M, board), board)\n    \n    duration = 0\n    \n    while traps and duration < 2 * M * N - 1:\n        for i in range(K):\n            if i in traps:\n                continue\n            \n            X_i, Y_i, C_i, board = bacteria[i]\n            bacteria[i] = move_bacterium(X_i, Y_i, C_i, board)\n        \n        duration += 1\n    \n    return duration if duration <= 2 * M * N - 1 else -1\n\n\ninput_data = \"\"\"3 3 1\n2 2\n1 1 R\n010\n000\n000\n3 3 1\n2 2\n1 1 R\n010\n000\n000\n\"\"\"\n\noutput_data = \"\"\"7\n7\n\"\"\"\n\ninput_data_list = input_data.split('\\n')\noutput_data_list = output_data.split('\\n')\n\nfor i in range(len(input_data_list)):\n    input_data = input_data_list[i]\n    output_data = output_data_list[i]\n    result = solution(input_data)\n    print(result)\n    assert(result == output_data)\n\nprint(\"Test cases passed!\") "
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M, K = map(int, input_list[0].split())\n    X, Y = map(int, input_list[1].split())\n    bacteria_info = input_list[2:]\n\n    def get_neighbours(row, col):\n        return [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1)]\n\n    def is_valid(row, col):\n        return 1 <= row <= N and 1 <= col <= M\n\n    def move_bacteria(row, col, direction, board, bacteria_id):\n        bacteria_count = 0\n        while True:\n            if not is_valid(row, col):\n                break\n            if board[row - 1][col] == '1':\n                bacteria_count += 1\n            if bacteria_count == bacteria_id:\n                return (row, col)\n            new_row, new_col = get_neighbours(row, col)[direction]\n            row, col = new_row, new_col\n            if not is_valid(row, col):\n                row, col = get_neighbours(row, col - 1 - ((direction + 2) % 4))[direction]\n                break\n            if board[row - 1][col] == '1':\n                bacteria_count += 1\n            if bacteria_count == bacteria_id:\n                return (row, col)\n        return None\n\n    def get_bacteria_position(bacteria_id, board):\n        for row in range(1, N + 1):\n            for col in range(1, M + 1):\n                if board[row - 1][col - 1] == str(bacteria_id):\n                    return (row, col)\n        return None\n\n    def calculate_time(bacteria_info):\n        board = [[0] * M for _ in range(N)]\n        bacteria_positions = [get_bacteria_position(i + 1, board) for i in range(K)]\n        time = 0\n        while True:\n            bacteria_count = 0\n            for i in range(K):\n                bacteria_id = i + 1\n                bacteria_row, bacteria_col, direction = map(int, bacteria_info[i].split())\n                direction = (direction - 1) % 4\n                new_position = move_bacteria(bacteria_row, bacteria_col, direction, board, bacteria_id)\n                if new_position is not None:\n                    bacteria_positions[i] = new_position\n                    bacteria_count += 1\n            if bacteria_count == 0:\n                return -1\n            time += 1\n\n    return str(calculate_time(bacteria_info))\n\ninput_str = \"\"\"3 3 1\n2 2\n1 1 R\n010\n000\n000\n3 4 R\n2327\n6009\n2112\n3 2 R\n1310\n2101\n1301\"\"\"\n\nprint(solution(input_str)) "
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    X, Y = map(int, stdin.split()[3:5])\n    bacteria = [stdin.split()[6+i:6+i+N+1] for i in range(K*N*M+3, K*N*M*2+3, N+M)]\n    directions = {'U': (-1, 0), 'R': (0, 1), 'D': (1, 0), 'L': (0, -1)}\n\n    def next_position(x, y, direction):\n        dx, dy = directions[direction]\n        return x + dx, y + dy\n\n    def turn(direction, times):\n        turns = {\n            'U': {'R': 'R', 'L': 'L', 'U': 'U', 'D': 'D'},\n            'R': {'U': 'U', 'R': 'R', 'D': 'D', 'L': 'L'},\n            'D': {'U': 'D', 'R': 'R', 'D': 'D', 'L': 'L'},\n            'L': {'U': 'U', 'R': 'L', 'D': 'D', 'L': 'L'}\n        }\n        return turns[direction][times % 4]\n\n    def step(x, y, direction, board, traps):\n        x, y = next_position(x, y, direction)\n        if not (0 <= x < N and 0 <= y < M):\n            direction = turn(direction, 2)\n            if not (0 <= x < N and 0 <= y < M):\n                direction = turn(direction, 2)\n        if (x, y) == (X, Y):\n            return -1, direction, board, traps\n        if (x, y) in traps:\n            return -1, direction, board, traps\n        number = int(board[x][y])\n        direction = turn(direction, number)\n        if (x, y) in traps:\n            traps.remove((x, y))\n        return x, y, direction, board, traps\n\n    def play_game(bacteria, start_x, start_y, start_direction):\n        board = [[0] * M for _ in range(N)]\n        traps = [(X, Y)]\n        bacteria_traps = [(start_x, start_y, start_direction, board, traps) for _ in range(K)]\n        seconds = 0\n\n        while len(set(bacteria_traps)) > 1:\n            seconds += 1\n            bacteria_traps = [step(*state) for state in bacteria_traps]\n            bacteria_traps = [state for state in bacteria_traps if state[0] != -1]\n\n        return seconds\n\n    start_x, start_y, start_direction = X-1, Y-1, bacteria[K-1][start_y*M+start_x]\n    bacteria = [bacteria[i] for i in range(K) if i != K-1]\n    seconds = play_game(bacteria, start_x, start_y, start_direction)\n\n    return -1 if seconds == 0 else seconds"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, input().split())\n    X, Y = map(int, input().split())\n\n    bacteria = []\n    for i in range(K):\n        X_i, Y_i, C_i = input().split()\n        X_i, Y_i = int(X_i), int(Y_i)\n        bacteria.append((X_i, Y_i, C_i))\n\n        matrix = []\n        for _ in range(N):\n            matrix.append(list(map(int, input().split())))\n\n    def next_position(x, y, direction, N, M):\n        if direction == 'U':\n            return max(x - 1, 0), y\n        if direction == 'D':\n            return min(x + 1, N - 1), y\n        if direction == 'L':\n            return x, max(y - 1, 0)\n        if direction == 'R':\n            return x, min(y + 1, M - 1)\n\n    def turn(direction, n):\n        if n % 4 == 0:\n            return direction\n        if n % 4 == 1:\n            if direction == 'U':\n                return 'L'\n            if direction == 'L':\n                return 'D'\n            if direction == 'D':\n                return 'R'\n            if direction == 'R':\n                return 'U'\n        if n % 4 == 2:\n            if direction == 'U':\n                return 'R'\n            if direction == 'R':\n                return 'D'\n            if direction == 'D':\n                return 'L'\n            if direction == 'L':\n                return 'U'\n        if n % 4 == 3:\n            return turn(direction, n - 1)\n\n    def step(x, y, direction, matrix, N, M):\n        if (x, y) == (X, Y):\n            return -1\n        number = matrix[x][y]\n        new_direction = turn(direction, number)\n        new_x, new_y = next_position(x, y, new_direction, N, M)\n        return new_x, new_y, new_direction\n\n    def max_steps(x, y, direction, N, M, matrix):\n        seen = set()\n        queue = [(x, y, direction, 0)]\n        while queue:\n            x, y, direction, steps = queue.pop(0)\n            seen.add((x, y, direction))\n            if (x, y) == (X, Y):\n                return steps\n            for new_direction in ['U', 'D', 'L', 'R']:\n                new_x, new_y = next_position(x, y, new_direction, N, M)\n                if (new_x, new_y, new_direction) not in seen:\n                    queue.append((new_x, new_y, new_direction, steps + 1))\n        return -1\n\n    total_steps = 0\n    for bacterium in bacteria:\n        x, y, direction = bacterium\n        for _ in range(max_steps(x, y, direction, N, M, matrix)):\n            new_x, new_y, new_direction = step(x, y, direction, matrix, N, M)\n            if new_x == -1:\n                return -1\n            x, y, direction = new_x, new_y, new_direction\n            total_steps += 1\n\n    return total_steps if total_steps != -1 else -1\n"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y, bacteria_descriptions = parse_input(stdin)\n    trap_location = (X - 1, Y - 1)\n    duration = 0\n    game_over = False\n\n    for bacterium in bacteria_descriptions:\n        bacterium_location = bacterium[0]\n        bacterium_direction = bacterium[1]\n        matrix = bacterium[2]\n        bacterium_row, bacterium_col = bacterium_location\n\n        while True:\n            duration += 1\n            new_row, new_col = get_new_position(bacterium_row, bacterium_col, bacterium_direction)\n\n            if is_outside_board(new_row, new_col, N, M):\n                bacterium_direction = get_new_direction(bacterium_direction)\n                new_row, new_col = get_new_position(bacterium_row, bacterium_col, bacterium_direction)\n\n            if trap_location == (new_row, new_col):\n                game_over = True\n                break\n\n            if matrix[new_row][new_col] == 0:\n                break\n\n            bacterium_row, bacterium_col = new_row, new_col\n            bacterium_direction = turn(bacterium_direction, matrix[new_row][new_col])\n\n        if game_over:\n            return \"-1\"\n\n    if not game_over:\n        return str(duration)\n\n\ndef"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def turn(dir, x):\n        if dir == \"U\":\n            return (\"L\", x - 1) if x > 1 else (\"R\", x + 1)\n        elif dir == \"R\":\n            return (\"U\", x - 1) if x > 1 else (\"D\", x + 1)\n        elif dir == \"D\":\n            return (\"R\", x - 1) if x > 1 else (\"L\", x + 1)\n        else:  # dir == \"L\"\n            return (\"D\", x - 1) if x > 1 else (\"U\", x + 1)\n\n    def move(row, col, dir):\n        if dir == \"U\":\n            return (row - 1, col)\n        elif dir == \"R\":\n            return (row, col + 1)\n        elif dir == \"D\":\n            return (row + 1, col)\n        else:  # dir == \"L\"\n            return (row, col - 1)\n\n    def next_turn(b, x):\n        turn_dir = b[0]\n        for _ in range(x):\n            turn_dir, b = turn(turn_dir, b[1])\n        return turn_dir, b[1]\n\n    def step(b):\n        row, col, dir = b[1], b[2], b[3]\n        num = b[0]\n        turn_dir, col = next_turn(b[4], b[0])\n        dir = turn(dir, turn_dir)\n        row, col = move(row, col, dir)\n        return (row, col, dir, num)\n\n    def run(bacteria):\n        trap = set()\n        for i, b in enumerate(bacteria):\n            if b[1] == y and b[2] == x:\n                trap.add(i)\n\n        bacteria = [step(b) for b in bacteria]\n        time = 0\n        while trap:\n            time += 1\n            bacteria = [step(b) for b in bacteria]\n            new_trap = set()\n            for i, b in enumerate(bacteria):\n                if b[1] == y and b[2] == x:\n                    new_trap.add(i)\n            trap = new_trap\n\n        return time\n\n    def parse_input(stdin: str) -> tuple:\n        lines = stdin.split(\"\\n\")\n        N, M, K = map(int, lines[0].split())\n        x, y = map(int, lines[1].split())\n        bacteria = [line.split() for line in lines[2:]]\n        bacteria = [(int(b[0]), int(b[1]), b[2], b[3:].replace(' ', '')) for b in bacteria]\n        return N, M, K, x, y, bacteria\n\n    N, M, K, x, y, bacteria = parse_input(stdin)\n    if not bacteria:\n        return -1\n\n    result = run(bacteria)\n    return result if result < 2**31 else -1"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K, X, Y = map(int, stdin.split()[:5])\n    rows = [list(map(int, stdin.split()[5 + i * N * M:5 + (i + 1) * N * M])) for i in range(K)]\n\n    def move(row, col, direction):\n        if direction == 'U':\n            return row - 1, col\n        elif direction == 'R':\n            return row, col + 1\n        elif direction == 'D':\n            return row + 1, col\n        else:\n            return row, col - 1\n\n    def turn(direction):\n        if direction == 'U':\n            return 'L'\n        elif direction == 'R':\n            return 'U'\n        elif direction == 'D':\n            return 'R'\n        else:\n            return 'D'\n\n    def check_trapped(row, col):\n        return row == X and col == Y\n\n    def step(row, col, direction):\n        return move(row, col, direction)\n\n    visited = set()\n    queue = [(X, Y, K, 0) for K in range(K)]\n\n    while queue:\n        row, col, i, count = queue.pop(0)\n\n        if (row, col) in visited:\n            continue\n\n        visited.add((row, col))\n\n        if check_trapped(row, col):\n            return count\n\n        for direction in ['U', 'R', 'D', 'L']:\n            next_row, next_col = step(row, col, direction)\n\n            if 0 <= next_row < N and 0 <= next_col < M:\n                queue.append((next_row, next_col, i, count + 1))\n\n                if count + 1 > 7:\n                    return -1\n\n    return -1\n"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    X, Y = map(int, stdin.split()[3:5])\n    bacteria = [list(map(int, stdin.split()[6+i*N*M:7+i*N*M+N*M])) for i in range(K)]\n\n    def turn(direction: str, count: int):\n        if direction == 'U':\n            return (direction, count) if count % 2 == 0 else ('R', count - 1)\n        elif direction == 'R':\n            return (direction, count) if count % 2 == 0 else ('D', count - 1)\n        elif direction == 'D':\n            return (direction, count) if count % 2 == 0 else ('L', count - 1)\n        else:\n            return (direction, count) if count % 2 == 0 else ('U', count - 1)\n\n    def move(row: int, col: int, direction: str, count: int):\n        if direction == 'U':\n            return (row - count, col)\n        elif direction == 'R':\n            return (row, col + count)\n        elif direction == 'D':\n            return (row + count, col)\n        else:\n            return (row, col - count)\n\n    def will_be_killed(row: int, col: int) -> bool:\n        for i in range(K):\n            if (row, col) == (X_i, Y_i):\n                return True\n        return False\n\n    total_seconds = 0\n    while True:\n        if total_seconds % 2 == 0:\n            for i in range(K):\n                row, col, direction, count = X_i[i], Y_i[i], C_i[i], X_i[i]\n                while True:\n                    row, col = move(row, col, direction, count)\n                    if 1 <= row <= N and 1 <= col <= M and bacteria[i][row - 1][col - 1] > 0:\n                        X_i[i], Y_i[i], C_i[i] = row, col, turn(direction, count)\n                        break\n                    else:\n                        if will_be_killed(row, col):\n                            return -1\n                        direction, count = turn(direction, count)\n        else:\n            for i in range(K):\n                row, col, direction, count = X_i[i], Y_i[i], C_i[i], X_i[i]\n                while True:\n                    row, col = move(row, col, direction, count)\n                    if 1 <= row <= N and 1 <= col <= M and bacteria[i][row - 1][col - 1] > 0:\n                        bacteria[i][row - 1][col - 1] -= 1\n                        break\n                    else:\n                        direction, count = turn(direction, count)\n        total_seconds += 1"
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(n: int, nums: list, i: int, j: int) -> bool:\n        return i >= 0 and j < n and nums[i] + nums[j] == nums[i + (j - i)] + nums[j]\n\n    n, nums = map(int, input().split())\n    nums = list(map(int, input().split()))\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if is_valid(n, nums, i, j):\n                count += 1\n    return str(count)\n\n\ninput_data = \"\"\"5\n2 2 1 2 3\n8\n1 2 4 1 1 2 5 1\"\"\""
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    num_list = list(map(int, input_list[1].split()))\n    if n < 2:\n        return \"0\"\n    sum_count = 0\n    for i in range(n-1):\n        if num_list[i] + num_list[i+1] == num_list[i+1] + num_list[i]:\n            sum_count += 1\n            if sum_count == n-2:\n                return str(sum_count+1)\n    return str(sum_count)\n\nstdin = \"5\\n2 2 1 2 3\"\nprint(solution(stdin))\n\nstdin = \"8\\n1 2 4 1 1 2 5 1\"\nprint(solution(stdin)) "
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    n, numbers = int(stdin.splitlines()[0]), list(map(int, stdin.splitlines()[1].split()))\n\n    if n < 2:\n        return \"0\"\n\n    lcm_numbers = [lcm(numbers[i], numbers[i+1]) for i in range(n-1)]\n    result = 0\n\n    for i in range(n-1):\n        if numbers[i] == numbers[i+1] or numbers[i] == lcm_numbers[i]:\n            result += 1\n\n    return str(result)"
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    count = 0\n    for i in range(n - 2):\n        sum_sarah = numbers[i] + numbers[i + 1]\n        product_patricia = numbers[i] * numbers[i + 1]\n\n        if sum_sarah == product_patricia:\n            count += 1\n\n    return count\n"
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    nums = list(map(int, stdin.split()[1:]))\n    dp = [1] * n\n    dp[0] = dp[1] = 1\n    for i in range(2, n):\n        if nums[i] == nums[i - 1]:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = dp[i - 1] + dp[i - 2]\n    result = dp[-1]\n    return str(result) "
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    count = 0\n    for i in range(n - 1):\n        if numbers[i] + numbers[i + 1] == numbers[i + 2]:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    book_numbers = list(map(int, input_list[1].split()))\n\n    def is_valid_range(start, end):\n        return (book_numbers[start] == 1 and book_numbers[end] == 1) or (book_numbers[start] > 1 and book_numbers[end] > 1)\n\n    count = 0\n    for i in range(n - 2):\n        if is_valid_range(i, i + 1):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_sum(numbers: list) -> int:\n        return sum(numbers)\n\n    def calculate_product(numbers: list) -> int:\n        result = 1\n        for number in numbers:\n            result *= number\n        return result\n\n    n, numbers = map(int, stdin.split())\n    numbers = sorted(numbers)\n    count = 0\n\n    for i in range(n - 1):\n        sum_sarah = calculate_sum(numbers[i:i + 2])\n        product_patricia = calculate_product(numbers[i:i + 2])\n\n        if sum_sarah == product_patricia:\n            count += 1\n\n    return count\n\n\ninput_1 = \"5\\n2 2 1 2 3\"\ninput_2 = \"8\\n1 2 4 1 1 2 5 1\"\n\nprint(solution(input_1))  # Output: 2\nprint(solution(input_2))  # Output: 4 "
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    numbers = list(map(int, input_list[1].split()))\n    \n    count = 0\n    for i in range(n-2):\n        if numbers[i] + numbers[i+1] == numbers[i+2]:\n            count += 1\n            \n    return str(count)\n\ninput_list = [\"5\", \"2 2 1 2 3\"]\nprint(solution(\"\\n\".join(input_list)))\n\ninput_list = [\"8\", \"1 2 4 1 1 2 5 1\"]\nprint(solution(\"\\n\".join(input_list))) "
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    n = int(input_values[0])\n    numbers = list(map(int, input_values[1:]))\n\n    count = 0\n    for i in range(n - 1):\n        if numbers[i] == numbers[i + 1]:\n            count += 1\n        else:\n            count = 1\n        if count >= 2:\n            break\n\n    return str(count)\n"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    students = []\n    for i in range(1, N + 1):\n        line = stdin.splitlines()[i].split()\n        if line[0] == \"D\":\n            students.append((int(line[1]), int(line[2])))\n        elif line[0] == \"P\":\n            i = int(line[1])\n            if len(students) == 0:\n                return \"NE\"\n            if i == 1:\n                return \"1\"\n            prev_student = students[i - 2]\n            curr_student = students[i - 1]\n            for j, student in enumerate(students):\n                if student[0] >= curr_student[0] and student[1] >= curr_student[1] and student[0] != prev_student[0] and student[1] != prev_student[1]:\n                    return str(j + 1)\n            return \"NE\"\n    return \"NE\"\n\ninput_data = '''6\nD 3 1\nD 2 2\nD 1 3\nP 1\nP 2\nP 3\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def find_best_student(student: int) -> int:\n        best_student = None\n        best_diff = float('inf')\n        for s in students:\n            if s > student:\n                diff = abs(students[s][0] - students[student][0])\n                if diff < best_diff or (diff == best_diff and students[s][1] > students[best_student][1]):\n                    best_student = s\n                    best_diff = diff\n        return best_student\n\n    def find_best_students(student: int) -> List[int]:\n        best_students = []\n        for s in students:\n            if s > student:\n                diff_understanding = abs(students[s][0] - students[student][0])\n                diff_knowledge = abs(students[s][1] - students[student][1])\n                if diff_understanding <= diff_knowledge:\n                    best_students.append(s)\n        return best_students\n\n    def find_students_to_ask(student: int) -> str:\n        best_students = find_best_students(student)\n        if len(best_students) == 0:\n            return \"NE\"\n        else:\n            return best_students[0]\n\n    def process_queries(queries: List[str]) -> List[str]:\n        result = []\n        for query in queries:\n            parts = query.split()\n            if parts[0] == \"D\":\n                students[int(parts[1])] = (int(parts[2]), lcm(int(parts[2]), students_knowledge[int(parts[1])]))\n                students_knowledge[int(parts[1])] = lcm(int(parts[2]), students_knowledge[int(parts[1])])\n            elif parts[0] == \"P\":\n                result.append(str(find_students_to_ask(int(parts[1]))))\n        return result\n\n    N = int(input())\n    queries = [input() for _ in range(N)]\n    students = {}\n    students_knowledge = {}\n    i = 0\n    while i < len(queries):\n        if queries[i].startswith(\"D\"):\n            a, b = map(int, queries[i].split()[1:])\n            students[i + 1] = (a, lcm(a, b))\n            students_knowledge[i + 1] = lcm(a, b)\n            i += 1\n        else:\n            query = queries.pop(i)\n            parts = query.split()\n            best_student = find_best_student(int(parts[1]))\n            if best_student is not None:\n                result = str(best_student)\n            else:\n                result = \"NE\"\n            queries.insert(i, result)\n            i += 1\n    return \"\\n\".join(queries)\n\n\ndef"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_student_index(stdents_list: list, stdent_info: tuple) -> int:\n        for index, stdent in enumerate(stdents_list, start=1):\n            if stdent[0] < stdent_info[0]:\n                return index\n        return len(stdents_list) + 1\n\n    def get_best_match(stdents_list: list, stdent_info: tuple) -> str:\n        min_diff = float('inf')\n        best_match = None\n        for index, stdent in enumerate(stdents_list, start=1):\n            diff_understanding = abs(stdent[0] - stdent_info[0])\n            diff_knowledge = abs(stdent[1] - stdent_info[1])\n            diff = diff_understanding + diff_knowledge\n            if diff < min_diff:\n                min_diff = diff\n                best_match = index\n            elif diff == min_diff:\n                best_match = 'NE'\n        return best_match\n\n    stdents_list = []\n    for line in stdin.split('\\n'):\n        if line.startswith('D'):\n            _, a, b = line.split()\n            a, b = int(a), int(b)\n            stdents_list.append((a, b))\n        elif line.startswith('P'):\n            _, i = line.split()\n            i = int(i)\n            stdent_info = (stdents_list[i - 1][0], stdents_list[i - 1][1])\n            best_match = get_best_match(stdents_list, stdent_info)\n            print(best_match)"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_best_candidate(students: list, A: int, B: int) -> int:\n        candidates = [i for i, (a, b) in enumerate(students, 1) if a >= A and b >= B]\n        if not candidates:\n            return -1\n        candidates.sort(key=lambda x: (students[x-1][0], students[x-1][1], -x))\n        return candidates[0]\n\n    N = int(stdin.splitlines()[0])\n    students = []\n    for line in stdin.splitlines()[1:]:\n        if line.startswith(\"D\"):\n            A, B = map(int, line.split()[1:])\n            students.append((A, B))\n        elif line.startswith(\"P\"):\n            i = int(line.split()[1])\n            best_candidate = get_best_candidate(students, students[i-1][0], students[i-1][1])\n            if best_candidate == -1:\n                print(\"NE\")\n            else:\n                print(best_candidate)\n        else:\n            raise ValueError(\"Invalid input\")\n"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    queries = [line.split() for line in stdin.splitlines()[1:]]\n    student_data = {}\n\n    for query in queries:\n        if query[0] == \"D\":\n            student_data[int(query[1])] = (int(query[2]), int(query[3]))\n        elif query[0] == \"P\":\n            i = int(query[1])\n            candidates = []\n\n            for j in range(1, i):\n                if j not in student_data:\n                    continue\n\n                if student_data[j][0] >= student_data[i][0] and student_data[j][1] >= student_data[i][1]:\n                    candidates.append((j, abs(student_data[j][1] - student_data[i][1])))\n\n            if not candidates:\n                print(\"NE\")\n            else:\n                best_candidate = min(candidates, key=lambda x: x[1])[0]\n                print(best_candidate)\n        else:\n            raise ValueError(\"Invalid query\")"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_best_help(n: int, student_list: list) -> int:\n        student_list.sort(key=lambda x: (-x[0], x[1]))\n        best_help = -1\n        diff = float('inf')\n        for i in range(n):\n            if student_list[i][0] < student_list[n][0] and student_list[i][1] >= student_list[n][1]:\n                new_diff = abs(student_list[i][1] - student_list[n][1])\n                if new_diff < diff:\n                    diff = new_diff\n                    best_help = i + 1\n        return best_help\n\n    N, stdin = stdin.split(\"\\n\", 1)\n    N = int(N)\n    stdin_list = stdin.split(\"\\n\")\n    student_list = []\n\n    for i in range(N):\n        query, stdin_list = stdin_list[0].split(\" \", 1), stdin_list[1:]\n        if query[0] == \"D\":\n            A, B = int(query[1]), int(query[2])\n            student_list.append((A, B))\n        elif query[0] == \"P\":\n            i = int(query[1]) - 1\n            help_student = find_best_help(i + 1, student_list)\n            if help_student == -1:\n                print(\"NE\")\n            else:\n                print(help_student)\n"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    students = {}\n    for i in range(1, n+1):\n        line = stdin.split('\\n')[i].split()\n        if line[0] == \"D\":\n            students[i] = {\"A\": int(line[1]), \"B\": int(line[2])}\n        elif line[0] == \"P\":\n            i = int(line[1])\n            max_diff = 0\n            best_student = None\n            for j, student in students.items():\n                diff = abs(student[\"A\"] - students[i][\"A\"]) + abs(student[\"B\"] - students[i][\"B\"])\n                if diff < max_diff or (diff == max_diff and student[\"A\"] > students[i][\"A\"]):\n                    max_diff = diff\n                    best_student = j\n            if best_student:\n                print(best_student)\n            else:\n                print(\"NE\")"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    village_map = {}\n    for i in range(1, N+1):\n        village_map[i] = {\"A\": 0, \"B\": 0}\n\n    for i in range(1, N+1):\n        line = stdin.splitlines()[i]\n        if line.startswith(\"D\"):\n            _, A, B = line.split()\n            A, B = int(A), int(B)\n            village_map[i] = {\"A\": A, \"B\": B}\n\n    result = []\n    for i in range(1, N+1):\n        line = stdin.splitlines()[N+i]\n        if line.startswith(\"P\"):\n            _, student_id = line.split()\n            student_id = int(student_id)\n            best_student = None\n            min_diff = float('inf')\n            min_diff_understanding = float('inf')\n            for s in village_map:\n                if s != student_id and (village_map[s][\"A\"] >= village_map[student_id][\"A\"] and village_map[s][\"B\"] >= village_map[student_id][\"B\"]):\n                    diff = abs(village_map[s][\"B\"] - village_map[student_id][\"B\"])\n                    if diff < min_diff:\n                        min_diff = diff\n                        min_diff_understanding = diff\n                        best_student = s\n                    elif diff == min_diff:\n                        diff_understanding = abs(village_map[s][\"A\"] - village_map[student_id][\"A\"])\n                        if diff_understanding < min_diff_understanding:\n                            min_diff_understanding = diff_understanding\n                            best_student = s\n            result.append(\"NE\" if best_student is None else str(best_student))\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # parse the input\n    N, *queries = stdin.split('\\n')\n    N = int(N)\n    students = {}\n\n    # process the queries\n    for query in queries:\n        if query.startswith('D '):\n            # a student has moved in\n            a, b = map(int, query.split()[1:])\n            students[len(students) + 1] = (a, b)\n        else:\n            # a student wants to know whom to ask for help\n            i = int(query.split()[1])\n            for j, (a, b) in students.items():\n                if a >= students[i][0] and b >= students[i][1]:\n                    print(j)\n                    break\n            else:\n                print('NE')"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_students():\n        students = {}\n        for line in stdin.splitlines():\n            if line.startswith(\"D\"):\n                _, A, B = line.split()\n                students[int(A)] = int(B)\n        return students\n\n    def find_helpful_student(students, A, B):\n        best_student = None\n        min_diff = float('inf')\n        for i, (Ai, Bi) in students.items():\n            if Ai >= A and Bi >= B:\n                diff = abs(A - Ai) + abs(B - Bi)\n                if diff < min_diff:\n                    min_diff = diff\n                    best_student = i\n        return best_student\n\n    students = get_students()\n    result = []\n    for line in stdin.splitlines():\n        if line.startswith(\"P\"):\n            _, i = line.split()\n            A, B = students[int(i)]\n            result.append(str(find_helpful_student(students, A, B)) if find_helpful_student(students, A, B) is not None else \"NE\")\n    return \"\\n\".join(result)"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0 = map(int, stdin.split())\n    fish_times = [list(map(int, stdin.split()[1:])) for _ in range(r)]\n\n    def is_valid(x, y, t):\n        return 0 <= x < r and 0 <= y < c and t >= 1 and t <= l\n\n    def get_optimal_points(start_x, start_y, time):\n        visited = set()\n        queue = [(start_x, start_y, time)]\n        while queue:\n            x, y, t = queue.pop(0)\n            if (x, y) not in visited:\n                visited.add((x, y))\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    if is_valid(x + dx, y + dy, t + 1):\n                        queue.append((x + dx, y + dy, t + 1))\n        return visited\n\n    optimal_points = get_optimal_points(x0, y0, 1)\n    return len(optimal_points)"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, c, k, l = map(int, input_list[0].split())\n    x_0, y_0 = map(int, input_list[1].split())\n    t = [[int(t_val) for t_val in input_list[i+2].split()] for i in range(r)]\n\n    def get_distance(x, y, x_to, y_to):\n        return abs(x - x_to) + abs(y - y_to)\n\n    def can_reach(x, y, x_to, y_to):\n        return get_distance(x, y, x_to, y_to) <= 1 and t[x_to][y_to] >= 2\n\n    def get_catchable_points(x, y, x_to, y_to):\n        if t[x_to][y_to] <= l:\n            return 1\n        else:\n            return 0\n\n    catchable_points = 0\n    directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n\n    for x_to, y_to in directions:\n        if can_reach(x_0, y_0, x_to, y_to):\n            catchable_points += get_catchable_points(x_0, y_0, x_to, y_to)\n\n    return str(catchable_points)"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l, x0, y0, input_rows = parse_input(stdin)\n    graph = create_graph(r, c, input_rows)\n    visited = [[False for _ in range(c)] for _ in range(r)]\n    queue = [(1, (x0, y0))]\n    visited[x0][y0] = True\n    max_count = 0\n    count = 0\n\n    while queue:\n        count += 1\n        current_time, (x, y) = queue.pop(0)\n\n        if current_time > l:\n            break\n\n        max_count = max(max_count, count)\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n\n            if 0 <= nx < r and 0 <= ny < c and graph[nx][ny] <= current_time + k:\n                if not visited[nx][ny]:\n                    visited[nx][ny] = True\n                    queue.append((current_time + 1, (nx, ny)))\n\n    return max_count\n\ndef"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_time_to_reach(x, y, x2, y2):\n        if x2 > x:\n            return (x2 - x) * (x2 - x + 1) // 2 + (x2 - x) * 1 + (x2 - x + 1) // 2\n        elif y2 > y:\n            return (y2 - y) * (y2 - y + 1) // 2 + (y2 - y) * 1 + (y2 - y + 1) // 2\n        else:\n            return 1\n\n    def can_catch_fish(t, t_max, k):\n        if t >= t_max:\n            return False\n        if t + k <= t_max:\n            return True\n        return (t_max - t) % (k + 1) != 0\n\n    def is_valid(x, y, grid, r, c, k, l, t_grid, x0, y0):\n        if x < 0 or x >= r or y < 0 or y >= c:\n            return False\n        if not can_catch_fish(t_grid[x][y], l, k):\n            return False\n        if x == x0 and y == y0:\n            return False\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            x2, y2 = x + dx, y + dy\n            if is_valid(x2, y2, grid, r, c, k, l, t_grid, x0, y0):\n                time_to_reach = get_time_to_reach(x, y, x2, y2)\n                if time_to_reach <= l:\n                    return True\n        return False\n\n    r, c, k, l = map(int, stdin.split()[:4])\n    x0, y0 = map(int, stdin.split()[-2:])\n    t_grid = [list(map(int, stdin.split()[4 * i + 1:4 * i + 4])) for i in range(r)]\n\n    count = 0\n    for x in range(r):\n        for y in range(c):\n            if is_valid(x, y, \"lake\", r, c, k, l, t_grid, x0, y0):\n                count += 1\n    return str(count)"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, input().split())\n    x0, y0 = map(int, input().split())\n    time_table = [list(map(int, input().split())) for _ in range(r)]\n    \n    def is_valid(x, y, t):\n        return 0 <= x < r and 0 <= y < c and t <= l and t_table[x][y] == t\n    \n    def dfs(x, y, t):\n        if not is_valid(x, y, t):\n            return 0\n        if t > l:\n            return 0\n        \n        if t == l:\n            return 1\n        \n        dx = [0, 1, 0, -1, 0]\n        dy = [1, 0, -1, 0, 0]\n        res = 0\n        \n        for i in range(4):\n            next_x, next_y = x + dx[i], y + dy[i]\n            res = max(res, dfs(next_x, next_y, t + 1))\n        \n        return res\n    \n    ans = dfs(x0, y0, 2)\n    \n    return str(ans)"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_fish(x: int, y: int, lake: List[List[int]], t: int) -> int:\n        count = 0\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                if 0 <= i < r and 0 <= j < c and lake[i][j] <= t:\n                    count += 1\n        return count\n\n    r, c, k, l, x0, y0 = map(int, stdin.split())\n    lake = [list(map(int, stdin.split()[4:])) for _ in range(r)]\n    t_map = [[0] * c for _ in range(r)]\n    for i in range(r):\n        for j in range(c):\n            t_map[i][j] = lake[i][j]\n\n    ans = 0\n    t = 1\n    while t <= l:\n        for i in range(r):\n            for j in range(c):\n                if t_map[i][j] <= t + k:\n                    lake[i][j] = -1\n\n        for i in range(r):\n            for j in range(c):\n                if lake[i][j] == -1:\n                    continue\n                lake[i][j] = count_fish(i, j, t_map, t)\n\n        t += 1\n\n    for i in range(r):\n        for j in range(c):\n            ans = max(ans, count_fish(i, j, t_map, l))\n\n    return ans\n"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_adjacent_points(x: int, y: int):\n        return [(x - 1, y), (x, y - 1), (x + 1, y), (x, y + 1)]\n\n    def is_valid_point(x: int, y: int, r: int, c: int) -> bool:\n        return 0 <= x < r and 0 <= y < c\n\n    def is_fish_available(time: int, t_list: list, l: int) -> bool:\n        return any(t < time <= t + l for t in t_list)\n\n    def count_fish_points(fish_map: list, x: int, y: int, r: int, c: int, k: int, l: int) -> int:\n        time = 1\n        visited = set()\n        stack = [(x, y, time)]\n        max_points = 0\n\n        while stack:\n            x, y, time = stack.pop()\n            if (x, y) not in visited:\n                visited.add((x, y))\n                max_points += 1\n\n                if is_fish_available(time, fish_map[x], l):\n                    max_points += 1\n\n                adjacent_points = get_adjacent_points(x, y)\n                for adj_x, adj_y in adjacent_points:\n                    if is_valid_point(adj_x, adj_y, r, c) and (adj_x, adj_y, time + 1) not in visited:\n                        stack.append((adj_x, adj_y, time + 1))\n\n        return max_points\n\n    r, c, k, l, x_0, y_0 = map(int, stdin.split())\n    fish_map = []\n\n    for _ in range(r):\n        row = list(map(int, input().split()))\n        fish_map.append(row)\n\n    result = count_fish_points(fish_map, x_0, y_0, r, c, k, l)\n\n    return str(result)"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_fish_positions(input_data):\n        r, c, k, l = map(int, input_data[:4])\n        x0, y0 = map(int, input_data[4:6])\n        t = [list(map(int, input_data[6 + i * c:6 + (i + 1) * c])) for i in range(r)]\n        return r, c, k, l, x0, y0, t\n\n    def count_fish(r, c, k, l, x0, y0, t):\n        fish_count = [[0] * c for _ in range(r)]\n        for i in range(r):\n            for j in range(c):\n                if t[i][j] <= l:\n                    fish_count[i][j] = 1\n        return fish_count\n\n    def find_optimal_points(r, c, k, l, x0, y0, t, fish_count):\n        queue = [(1, x0, y0)]\n        visited = set()\n        max_points = 0\n\n        while queue:\n            time, x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            max_points = max(max_points, sum(fish_count[x][y] for x in range(max(0, x - 1), min(r, x + 2)) for y in range(max(0, y - 1), min(c, y + 2))))\n            if time < l:\n                queue.append((time + 1, x, y))\n                queue.append((time + 1, x - 1, y))\n                queue.append((time + 1, x + 1, y))\n                queue.append((time + 1, x, y - 1))\n                queue.append((time + 1, x, y + 1))\n\n        return max_points\n\n    input_data = stdin.split('\\n')\n    r, c, k, l, x0, y0, t = get_fish_positions(input_data)\n    fish_count = count_fish(r, c, k, l, x0, y0, t)\n    max_points = find_optimal_points(r, c, k, l, x0, y0, t, fish_count)\n\n    return str(max_points)\n"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_fish_positions(r: int, c: int, k: int, t: List[int]) -> Set[Tuple[int, int]]:\n        fish_positions = set()\n        for x in range(r):\n            for y in range(c):\n                if t[x] <= l:\n                    fish_positions.add((x, y))\n        return fish_positions\n\n    def get_neighbor_points(x: int, y: int, r: int, c: int) -> List[Tuple[int, int]]:\n        neighbor_points = []\n        if x > 0:\n            neighbor_points.append((x - 1, y))\n        if x < r - 1:\n            neighbor_points.append((x + 1, y))\n        if y > 0:\n            neighbor_points.append((x, y - 1))\n        if y < c - 1:\n            neighbor_points.append((x, y + 1))\n        return neighbor_points\n\n    def get_travel_cost(x: int, y: int, x_0: int, y_0: int) -> int:\n        return abs(x - x_0) + abs(y - y_0)\n\n    def find_catchable_fish(r: int, c: int, k: int, t: List[int], x_0: int, y_0: int, l: int) -> int:\n        fish_positions = get_fish_positions(r, c, k, t)\n        max_catchable_points = 0\n        for x in range(r):\n            for y in range(c):\n                if (x, y) in fish_positions and get_travel_cost(x, y, x_0, y_0) <= l:\n                    max_catchable_points += 1\n        return max_catchable_points\n\n    lines = stdin.splitlines()\n    r, c, k, l = map(int, lines[0].split())\n    x_0, y_0 = map(int, lines[1].split())\n    t = [list(map(int, lines[i].split())) for i in range(2, 2 + r)]\n\n    return str(find_catchable_fish(r, c, k, t, x_0, y_0, l))"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    r, c, k, l = map(int, stdin.split()[:4])\n    x0, y0 = map(int, stdin.split()[4:6])\n    lake = [[int(t) for t in input().split()] for _ in range(r)]\n\n    def is_valid(x, y):\n        return 0 <= x < r and 0 <= y < c\n\n    def dist(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def get_fish(x, y):\n        return lake[x][y] if is_valid(x, y) else 0\n\n    def catch_fish(x, y, time):\n        if time < lake[x][y]:\n            return 0\n        return min(get_fish(x, y), k + 1)\n\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    max_points = 0\n\n    for x in range(r):\n        for y in range(c):\n            if lake[x][y] > 0:\n                dists = [dist(x, y, x0, y0) + dist(x0, y0, x + dx, y + dy) for dx, dy in directions]\n                time = lake[x][y] + k\n                while time <= l:\n                    points = sum(catch_fish(x + dx, y + dy, time) for dx, dy in directions)\n                    max_points = max(max_points, points)\n                    time += 1\n\n    return max_points\n"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *flaws = stdin.split()\n    N = int(N)\n    flaws = [tuple(map(float, flaw.split(','))) for flaw in flaws]\n    \n    max_x = max(flaw[0] for flaw in flaws)\n    max_y = max(flaw[1] for flaw in flaws)\n    max_z = max(flaw[2] for flaw in flaws)\n    \n    max_radius = max(max_x, max_y, max_z)\n    diameter = max_radius * 2\n    \n    return f\"{diameter:.{10}f}\"\n"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, z1, x2, y2, z2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    def diameter(points):\n        min_distance = float('inf')\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                distance_ij = distance(*points[i], *points[j])\n                if distance_ij < min_distance:\n                    min_distance = distance_ij\n        return 2 * min_distance\n\n    input_data = stdin.strip().split('\\n')\n    n_flaws = int(input_data[0])\n    flaws = [tuple(map(float, input_data[i + 1].split())) for i in range(n_flaws)]\n    if n_flaws == 0:\n        return \"0.0000000000\"\n    elif n_flaws == 1:\n        return \"1.0000000000\"\n    else:\n        return f\"{diameter(flaws):.10f}\""
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2 + (p1[2] - p2[2])**2)**0.5\n\n    def sphere_radius(points, center):\n        total_distance = 0\n        for point in points:\n            total_distance += distance(point, center)\n        return total_distance / len(points)\n\n    N, stdin = int(stdin.pop(0)), stdin\n    flaws = [tuple(map(float, line.split())) for line in stdin]\n    center = (sum(p[0] for p in flaws) / N, sum(p[1] for p in flaws) / N, sum(p[2] for p in flaws) / N)\n    radius = sphere_radius(flaws, center)\n    diameter = radius * 2\n    return f\"{diameter:.{10}f}\"\n\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def diameter(cube_size: float, flaws: List[Tuple[float, float, float]]) -> float:\n        min_diameter = cube_size / max(len(flaws), 1)\n        max_diameter = 2 * cube_size\n        while min_diameter < max_diameter:\n            mid_diameter = (min_diameter + max_diameter) / 2\n            holes_present = 0\n            for flaw in flaws:\n                x, y, z = flaw\n                if (x - cube_size / 2) ** 2 + (y - cube_size / 2) ** 2 + (z - cube_size / 2) ** 2 <= (cube_size / 2 + mid_diameter) ** 2:\n                    holes_present += 1\n            if holes_present == len(flaws):\n                return mid_diameter\n            elif holes_present > 0:\n                min_diameter = mid_diameter\n            else:\n                max_diameter = mid_diameter\n        return min_diameter\n\n    input_data = stdin.split('\\n')\n    num_flaws = int(input_data[0])\n    flaws = [(float(x), float(y), float(z)) for x, y, z in [x.split() for x in input_data[1:]]]\n    cube_size = 2 * max(flaws, key=lambda flaw: flaw[0] ** 2 + flaw[1] ** 2 + flaw[2] ** 2)\n    result = diameter(cube_size, flaws)\n    return f'{result:.10f}'\n\ndef"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    x_coords = []\n    y_coords = []\n    z_coords = []\n    for i in range(1, N+1):\n        x, y, z = map(float, input_data[i].split())\n        x_coords.append(x)\n        y_coords.append(y)\n        z_coords.append(z)\n\n    def distance(x1, y1, z1, x2, y2, z2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    max_distance = max(distance(x1, y1, z1, x2, y2, z2) for x1, y1, z1, x2, y2, z2 in zip(x_coords, y_coords, z_coords, x_coords[1:], y_coords[1:], z_coords[1:]))\n\n    diameter = 2 * (max_distance + 1e-6)  # add small epsilon to ensure diameter is even\n\n    return f\"{diameter:.{9}f}\"\n"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    flaws = [tuple(map(float, line.split())) for line in input_data[1:N+1]]\n    \n    def distance(a, b):\n        return sum((x-y)**2 for x, y in zip(a, b))**0.5\n    \n    def diameter(flaws):\n        max_distance = 0\n        for f1, f2 in itertools.combinations(flaws, 2):\n            max_distance = max(max_distance, distance(f1, f2))\n        return max_distance\n    \n    import itertools\n    return f\"{diameter(flaws):.{10}f}\""
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *flaws = stdin.split('\\n')\n    N = int(N)\n    flaws = [tuple(map(float, flaw.split())) for flaw in flaws]\n\n    # Calculate the maximum distance between any two flaws\n    max_distance = max(abs(a - b) for (a, _, _), (b, _, _) in combinations(flaws, 2))\n\n    # The diameter of the drill bit is the largest distance between the center of the cube and any flaw\n    diameter = max_distance + 1\n\n    return f\"{diameter:.{10}f}\""
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2\n\n    def diameter(distances):\n        return max(distances) ** 0.5\n\n    def diameter_drill(flaws):\n        distances = [distance(f1, f2) for f1, f2 in combinations(flaws, 2)]\n        return diameter(distances)\n\n    def main(input_data):\n        N, flaws = input_data.split(\"\\n\")\n        N = int(N)\n        flaws = [tuple(map(float, f.split())) for f in flaws.split(\"\\n\")[:N]]\n        result = diameter_drill(flaws)\n        return f\"{result:.{9}f}\"\n\n    input_data = stdin.strip()\n    result = main(input_data)\n    return result\n"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def min_diameter(x_coords, y_coords, z_coords) -> float:\n        x_coords.sort()\n        y_coords.sort()\n        z_coords.sort()\n\n        x_diff = x_coords[-1] - x_coords[0]\n        y_diff = y_coords[-1] - y_coords[0]\n        z_diff = z_coords[-1] - z_coords[0]\n\n        return min(x_diff, y_diff, z_diff) / 2\n\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    x_coords = []\n    y_coords = []\n    z_coords = []\n\n    for i in range(1, n + 1):\n        coords = list(map(float, input_lines[i].split()))\n        x_coords.append(coords[0])\n        y_coords.append(coords[1])\n        z_coords.append(coords[2])\n\n    diameter = min_diameter(x_coords, y_coords, z_coords)\n    return f\"{diameter:.10f}\"\n"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def diameter(distances: list) -> float:\n        return max(distances) * 2\n\n    def min_drill_bit(distances: list) -> float:\n        return min(distances)\n\n    N = int(stdin.split('\\n')[0])\n    flaws = [tuple(map(float, line.split())) for line in stdin.split('\\n')[1:N+1]]\n\n    distances = [distance(flaws[i], flaws[j]) for i in range(N) for j in range(i+1, N)]\n\n    diameter_drill = diameter(distances)\n    min_drill = min_drill_bit(distances)\n\n    return f\"{diameter_drill:.10f}\\n{min_drill:.10f}\""
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    \n    def count_digits(num: int) -> int:\n        return len(str(num))\n    \n    def digit_sum(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n    \n    count = 0\n    min_num = B + 1\n    for num in range(A, B + 1):\n        if digit_sum(num) == S:\n            count += 1\n            min_num = min(min_num, num)\n    \n    return f\"{count}\\n{min_num}\"\n\nprint(solution(input())) "
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    smallest = 0\n    for num in range(A, B + 1):\n        digits_sum = sum(map(int, str(num)))\n        if digits_sum == S:\n            count += 1\n            smallest = num\n            break\n    if count == 0:\n        return \"0\\n\"\n    return f\"{count}\\n{smallest}\""
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, input().split())\n\n    def digit_sum(n: int) -> int:\n        return sum(int(d) for d in str(n))\n\n    count = 0\n    min_number = B + 1\n\n    for i in range(A, B + 1):\n        if digit_sum(i) == S:\n            count += 1\n            min_number = min(min_number, i)\n\n    return f\"{count}\\n{min_number}\"\n\n\ndef"
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, input().split())\n    count = 0\n    min_num = float('inf')\n    \n    for num in range(A, B+1):\n        digit_sum = sum(map(int, str(num)))\n        if digit_sum == S:\n            count += 1\n            min_num = min(min_num, num)\n    \n    return f\"{count}\\n{min_num}\"\n\ndef"
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n\n    def digit_sum(n: int) -> int:\n        return sum(int(digit) for digit in str(n))\n\n    count = 0\n    smallest = float('inf')\n\n    for num in range(A, B + 1):\n        if digit_sum(num) == S:\n            count += 1\n            smallest = min(smallest, num)\n\n    return f'{count}\\n{smallest}'"
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    A, B, S = map(int, input_data)\n\n    def digit_sum(n: int) -> int:\n        return sum(int(digit) for digit in str(n))\n\n    count = 0\n    smallest = float('inf')\n\n    for num in range(A, B + 1):\n        if digit_sum(num) == S:\n            count += 1\n            smallest = min(smallest, num)\n\n    return f\"{count}\\n{smallest}\""
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    \n    count = 0\n    smallest = None\n    \n    for num in range(A, B+1):\n        digit_sum = sum(map(int, str(num)))\n        if digit_sum == S:\n            count += 1\n            if smallest is None or num < smallest:\n                smallest = num\n                \n    return f\"{count}\\n{smallest}\" "
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    A, B, S = map(int, input_list)\n    \n    def digit_sum(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n    \n    count = 0\n    min_num = 10 ** 10\n    for num in range(A, B + 1):\n        if digit_sum(num) == S:\n            count += 1\n            min_num = min(min_num, num)\n    \n    result = f\"{count}\\n{min_num}\"\n    return result"
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    \n    def digit_sum(num: int) -> int:\n        return sum(int(digit) for digit in str(num))\n    \n    count = 0\n    smallest = float('inf')\n    \n    for num in range(A, B+1):\n        if digit_sum(num) == S:\n            count += 1\n            smallest = min(smallest, num)\n    \n    return f\"{count}\\n{smallest}\"\n\n\ninput_data = \"1 9 5\\n1 100 10\"\noutput_data = [\"1\\n5\", \"9\\n19\"]\n\n\nfor data, expected in zip(input_data.splitlines(), output_data):\n    result = solution(data)\n    assert result == expected, f\"Error for input: {data}\"\n\nprint(\"All test cases pass. Your solution is correct.\") "
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    A, B, S = map(int, input_data)\n\n    count = 0\n    smallest = float('inf')\n\n    for num in range(A, B+1):\n        digits_sum = sum(int(digit) for digit in str(num))\n        if digits_sum == S:\n            count += 1\n            if num < smallest:\n                smallest = num\n\n    return f\"{count}\\n{smallest}\""
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_optimal_position(student_number: int, names: list, positions: list) -> int:\n        current_name = names[student_number - 1]\n        new_position = positions[student_number - 1]\n        while new_position != student_number - 1:\n            current_name_index = names.index(current_name)\n            new_position_index = positions.index(new_position)\n            if current_name_index < new_position_index:\n                current_name_index += 1\n            else:\n                current_name_index -= 1\n            current_name = names[current_name_index]\n            new_position = positions[current_name_index]\n        return new_position + 1\n\n    def min_inspections(names: list, positions: list) -> int:\n        inspections = 0\n        while len(set(names)) > 1:\n            for student_number in range(1, len(names) + 1):\n                new_position = get_optimal_position(student_number, names, positions)\n                positions[student_number - 1] = new_position\n            inspections += 1\n        return inspections\n\n    N, M = map(int, stdin.split()[:2])\n    names = list(map(int, stdin.split()[2:M + 2]))\n    positions = list(map(int, stdin.split()[M + 2:]))\n    inspections = min_inspections(names, positions)\n    new_positions = [get_optimal_position(i + 1, names, positions) for i in range(N)]\n    output = f\"{inspections}\\n\" + \" \".join(map(str, new_positions))\n    return output"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    list_names = list(map(int, input_data[1].split()))\n    line_order = list(map(int, input_data[2].split()))\n\n    # Remove duplicates and sort the list of names\n    list_names = sorted(set(list_names))\n\n    # Calculate the number of inspections needed\n    inspections = 0\n    for i in range(len(list_names)):\n        if list_names[i] != i + 1:\n            inspections += 1\n\n    # Calculate the optimal position for each student\n    optimal_positions = [0] * N\n    for i in range(len(list_names)):\n        student_index = line_order.index(list_names[i])\n        optimal_positions[student_index] = i + 1\n\n    # Calculate the new order of the students\n    new_order = [0] * N\n    for i in range(len(list_names)):\n        new_order[optimal_positions[i] - 1] = line_order[i]\n\n    # Output the results\n    result = f'{inspections}\\n' + ' '.join(map(str, new_order))\n    return result"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_inspections(list_length: int, names: List[int]) -> int:\n        inspections = 0\n        seen = set()\n        for name in names:\n            if name not in seen:\n                inspections += 1\n                seen.add(name)\n        return inspections\n\n    def find_minimal_inspections(N: int, b: List[int], names: List[int], positions: List[int]) -> Tuple[int, List[int]]:\n        inspections = count_inspections(len(names), names)\n        min_inspections = inspections\n        min_positions = positions\n\n        while inspections <= min_inspections:\n            new_names = [names[i - 1] for i in positions]\n            new_positions = [1 + (i - 1) % N for i in positions]\n            new_inspections = count_inspections(len(new_names), new_names)\n\n            if new_inspections < min_inspections:\n                min_inspections = new_inspections\n                min_positions = new_positions\n\n            positions = [1 + (i - 1) % N for i in positions]\n            inspections += 1\n\n        return min_inspections, min_positions\n\n    stdin = stdin.splitlines()\n    N, M = map(int, stdin[0].split())\n    names = list(map(int, stdin[1].split()))\n    b = list(map(int, stdin[2].split()))\n\n    inspections, positions = find_minimal_inspections(N, b, names, b)\n\n    output = f\"{inspections}\\n\" + \" \".join(map(str, positions))\n    return output\n"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def position_to_go_to(position: int, inspection_order: int) -> int:\n        if position % 2 == 0:\n            return position - 1\n        else:\n            return position + 1\n\n    def find_minimal_inspections(list_size: int, inspection_order: int) -> int:\n        inspections = 0\n        current_position = inspection_order\n        while current_position > 1:\n            current_position = position_to_go_to(current_position, inspection_order)\n            inspections += 1\n        return inspections\n\n    def find_positions_to_go_to(list_size: int, inspection_order: int) -> List[int]:\n        positions_to_go_to = []\n        current_position = inspection_order\n        while current_position > 1:\n            current_position = position_to_go_to(current_position, inspection_order)\n            positions_to_go_to.append(current_position)\n        return positions_to_go_to\n\n    def main(stdin: str) -> str:\n        input_list = stdin.split(\"\\n\")\n        list_size, names_in_list = map(int, input_list[0].split())\n        names_on_list = list(map(int, input_list[1].split()))\n        students_in_line = list(map(int, input_list[2].split()))\n\n        inspections_to_do = find_minimal_inspections(list_size, names_on_list[0])\n        positions_to_go_to = find_positions_to_go_to(list_size, names_on_list[0])\n\n        output = [inspections_to_do]\n        output.extend(positions_to_go_to)\n        return \"\\n\".join(map(str, output))\n\n    return main(stdin)\n"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    list_names = list(map(int, input().split()))\n    line_order = list(map(int, input().split()))\n\n    # Create a dictionary to store the order of the students in the line\n    student_order = {}\n    for i in range(N):\n        student_order[line_order[i]] = i + 1\n\n    # Sort the list_names to match the order of the students in the line\n    list_names.sort(key=lambda x: student_order[x])\n\n    # Initialize the optimal positions for the students\n    optimal_positions = [i + 1 for i in range(N)]\n\n    # Find the minimal number of inspections\n    K = 1\n    while list_names:\n        # Remove the first name from the list\n        first_name = list_names.pop(0)\n\n        # Find the position of the first name in the optimal positions\n        first_name_pos = student_order[first_name]\n\n        # Find the position of the last name in the list\n        last_name_pos = student_order[list_names[-1]]\n\n        # Calculate the number of students between the first and last names\n        num_students_between = last_name_pos - first_name_pos + 1\n\n        # Calculate the number of students that have to move to the front of the line\n        num_students_to_move = num_students_between - (K - 1)\n\n        # Move the students that have to move to the front of the line\n        for i in range(num_students_to_move):\n            student_order[list_names[-i - 1]] = first_name_pos - 1 - i\n\n        # Update the optimal positions\n        for i in range(K, num_students_between):\n            optimal_positions[first_name_pos - 1 - i + num_students_to_move] = optimal_positions[first_name_pos - 1 - i]\n\n        # Increment the number of inspections\n        K += 1\n\n    # Output the minimal number of inspections and the optimal positions\n    return f\"{K}\\n{' '.join(map(str, optimal_positions))}\""
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.splitlines()[0].split())\n    names = list(map(int, stdin.splitlines()[1].split()))\n    order = list(map(int, stdin.splitlines()[2].split()))\n\n    # Create a dictionary to store the positions of each student in the initial line\n    positions = {}\n    for i, name in enumerate(order, start=1):\n        positions[name] = i\n\n    # Sort the names in the order they appear in the list\n    names.sort()\n\n    # Initialize a counter for the number of inspections\n    inspections = 0\n    # Initialize an empty list to store the new positions for each student\n    new_positions = []\n\n    # Iterate through the sorted names\n    for name in names:\n        # Find the position of the current name in the initial line\n        current_position = positions[name]\n        # Find the position of the name on top the list\n        top_name = names[inspections]\n        top_position = positions[top_name]\n\n        # If the current name is not equal to the name on top the list, move the student to a new position\n        if name != top_name:\n            # Increment the counter for the number of inspections\n            inspections += 1\n            # Choose a new position for the student\n            new_position = min(current_position, top_position)\n            # Update the positions dictionary for the student\n            positions[name] = new_position\n            # Add the new position to the list of new positions\n            new_positions.append(new_position)\n\n    # Output the number of inspections and the new positions for each student\n    output = [str(inspections)]\n    output.extend(str(pos) for pos in new_positions)\n    return '\\n'.join(output)\n"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    lst = list(map(int, stdin.split()[2:2+M]))\n    ln = list(map(int, stdin.split()[2+M:]))\n\n    lst = sorted(set(lst))\n    pos = dict(zip(lst, range(1, len(lst) + 1)))\n\n    ins = 0\n    while len(lst) > 1:\n        ins += 1\n        curr = lst.pop(0)\n        for i in range(len(ln)):\n            if ln[i] == curr:\n                ln[i] = lst[pos[ln[i]] - 1]\n                ln[pos[ln[i]] - 1] = curr\n                pos[ln[i]] = pos[curr]\n                del pos[curr]\n                break\n\n    return str(ins) + \"\\n\" + \" \".join(map(str, ln))\n"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    names = sorted(list(map(int, input_data[1].split())))\n    initial_order = list(map(int, input_data[2].split()))\n\n    # Calculate the number of inspections needed\n    inspections = max(names) - 1\n\n    # Create a list with the positions of each student in the line\n    positions = [initial_order.index(i) + 1 for i in range(1, N + 1)]\n\n    # Initialize a dictionary to store the final positions of each student\n    final_positions = {i: positions[i - 1] for i in range(1, N + 1)}\n\n    # Iterate through the names and update the final positions\n    for name in names:\n        # Find the student with the given name\n        student = names.index(name) + 1\n\n        # Find the position of the student in the line\n        position = positions.index(student) + 1\n\n        # Find the position the student needs to go to after the inspection\n        new_position = position - inspections\n\n        # Update the final positions dictionary\n        final_positions[student] = new_position\n\n        # Update the positions list\n        positions[positions.index(student)] = new_position\n\n    # Calculate the total number of inspections needed\n    total_inspections = sum(names) - N\n\n    # Output the results\n    return f\"{total_inspections}\\n\" + ' '.join(map(str, final_positions.values()))"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    N, M = map(int, input_lines[0].split())\n    lst = list(map(int, input_lines[1].split()))\n    init_order = list(map(int, input_lines[2].split()))\n\n    # Calculate the number of inspections needed\n    inspections = 0\n    for i in range(M - 1):\n        if lst[i] == lst[i + 1]:\n            inspections += 1\n            lst[i] = -1  # Mark the name as stricken\n            lst[i + 1] = -1  # Mark the name as stricken\n\n    # Calculate the optimal new positions for each student\n    new_positions = [-1] * N\n    for i in range(M - 1, M):\n        if lst[i] == -1:\n            continue\n        for j in range(N):\n            if init_order[j] == lst[i]:\n                new_positions[j] = i\n                break\n\n    # Calculate the number of inspections needed for the remaining names\n    for i in range(M, M + N - M):\n        inspections += 1\n        for j in range(N):\n            if new_positions[j] == i - 1:\n                new_positions[j] = i\n                break\n\n    # Output the number of inspections and the new positions\n    output = str(inspections) + '\\n'\n    for i in range(N):\n        output += str(new_positions[i]) + ' '\n    return output.strip()\n"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M = map(int, stdin.splitlines()[0].split())\n    list_names = sorted(map(int, stdin.splitlines()[1].split()))\n    line_order = sorted(map(int, stdin.splitlines()[2].split()))\n\n    # Initialize variables\n    inspections = 0\n    positions = list(line_order)\n    current_pos = 0\n    min_inspections = float('inf')\n\n    # Optimally position students in the line\n    for name in list_names:\n        while name != line_order[current_pos]:\n            positions.remove(line_order[current_pos])\n            positions.append(line_order[current_pos])\n            current_pos += 1\n\n        positions.remove(name)\n        positions.append(name)\n        current_pos += 1\n\n    # Calculate minimal number of inspections\n    for i in range(len(positions)):\n        if i == 0:\n            inspections += 1\n        elif positions[i] == positions[i - 1]:\n            inspections += 1\n            positions[i] = positions[-1]\n            positions.pop()\n\n    # Output result\n    return f\"{inspections}\\n{' '.join(str(p) for p in positions)}\"\n"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    \n    # Initialize variables\n    max_coins = 0\n    min_coins = max(d, g)\n    coins = min_coins\n    \n    # Play n rounds\n    for i in range(n):\n        if i >= k:\n            # Player can cheat\n            coins = max_coins\n        else:\n            # Player cannot cheat\n            if coins < min_coins:\n                coins = min_coins\n        \n        # Update max_coins and min_coins\n        max_coins = max(max_coins, coins)\n        min_coins = max(min_coins, coins)\n        \n    return str(max_coins)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = d + g\n    for _ in range(n - k):\n        M = max(M, (M + d - g) // 2)\n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n\n    d_coins = d\n    g_coins = g\n    total_rounds = n\n    distracted_rounds = k\n\n    if distracted_rounds >= total_rounds:\n        return str(d + g)\n\n    for _ in range(total_rounds - distracted_rounds):\n        d_coins = min(d_coins, g_coins)\n        g_coins = g_coins - d_coins\n        d_coins += d_coins // 2\n\n    return str(d_coins + g_coins)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    if k == 0:\n        return str(d + g)\n    \n    M = d + g\n    for i in range(n-k):\n        M = max(M, d+i)\n    \n    return str(M)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    max_coins = 0\n    for i in range(n):\n        if i == k:\n            max_coins += g - d\n        else:\n            max_coins += g\n    return str(max_coins)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = max(0, d - g)\n    \n    for i in range(k):\n        if i % 2 == 0:\n            M = max(M, d + g)\n        else:\n            M = max(M, d - g)\n    \n    for i in range(k+1, n):\n        M = max(M, d + g)\n    \n    return str(M)\n\ninput1 = \"2 10 3 2\"\ninput2 = \"10 10 5 0\"\n\nprint(solution(input1))  # Output: 4\nprint(solution(input2))  # Output: 10 "
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    d, g, n, k = int(input_list[0]), int(input_list[1]), int(input_list[2]), int(input_list[3])\n    \n    def max_coins_donald(d, g, n, k):\n        if n == 1:\n            return max(d, g)\n        elif k == 0:\n            return min(d, g) + min(d, g - 1) + min(d - 1, g)\n        else:\n            return min(d, g) + min(d, g - 1) + min(d - 1, g) + min(d, g - 2) + min(d - 2, g) + min(d - 1, g - 1) + min(d - 1, g - 2) + min(d - 2, g - 1)\n    \n    result = max_coins_donald(d, g, n, k)\n    return str(result)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    d, g, n, k = map(int, input_list)\n    if n < k:\n        return f\"{d}\"\n    else:\n        for i in range(n - k):\n            d += 1\n            g -= 1\n        return f\"{d}\"\n"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    max_coins = d + g\n    for i in range(n):\n        if i % (k+1) == 0:\n            max_coins = min(max_coins, d-i)\n        else:\n            max_coins = min(max_coins, d-i+g-i)\n    return str(max_coins)"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    M = d\n    for i in range(n):\n        M = max(M, min(d, g) + min(d, g - i - 1))\n    return str(M)\n"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b, digits = map(int, stdin.split('\\n')[0].split())\n    allowed_digits = set(map(int, stdin.split('\\n')[1]))\n    count = 0\n    for multiple in range(a, b + 1):\n        if multiple % x == 0:\n            if len(set(str(multiple)) & allowed_digits) == len(allowed_digits):\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = list(map(int, stdin.split()[:-1]))\n    allowed_digits = sorted(set(allowed_digits))\n    count = 0\n    for i in range(A, B+1):\n        if i % X == 0 and all(int(digit) in allowed_digits for digit in str(i)):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    x, a, b, digits = input_processing(stdin)\n    count = 0\n    for i in range(a, b + 1):\n        if contains_only_allowed_digits(i, digits):\n            count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    X, A, B = map(int, input_list[0].split())\n    allowed_digits = sorted(set(input_list[1]))\n\n    count = 0\n    for i in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(i)):\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B = map(int, stdin.split()[:3])\n    allowed_digits = sorted(set(stdin.split()[3]))\n\n    count = 0\n    for num in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(num)):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = map(int, stdin.split())\n    allowed_digits = sorted(set(allowed_digits))\n\n    count = 0\n    for multiple in range(A, B + 1):\n        if all(digit in allowed_digits for digit in str(multiple)):\n            count += 1\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, digits = map(int, stdin.split('\\n')[0].split())\n    allowed_digits = sorted(set(map(int, stdin.split('\\n')[1])))\n\n    def has_allowed_digits(multiple: int) -> bool:\n        while multiple > 0:\n            digit = multiple % 10\n            if digit in allowed_digits:\n                return True\n            multiple //= 10\n        return False\n\n    count = 0\n    for multiple in range(A, B + 1):\n        if multiple % X == 0 and has_allowed_digits(multiple):\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_allowed(num: int, allowed_digits: set) -> bool:\n        return all(digit in allowed_digits for digit in str(num))\n\n    def count_multiples(X: int, A: int, B: int, allowed_digits: set) -> int:\n        count = 0\n        for num in range(A, B + 1):\n            if num % X == 0 and is_allowed(num, allowed_digits):\n                count += 1\n        return count\n\n    X, A, B = map(int, stdin.splitlines()[0].split())\n    allowed_digits = set(stdin.splitlines()[1])\n\n    result = count_multiples(X, A, B, allowed_digits)\n    return str(result)\n"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, allowed_digits = [int(x) for x in input().split()], int(input()), int(input()), sorted(set(input()))\n    count = 0\n    for i in range(A, B+1):\n        if all(str(i).count(d) > 0 for d in allowed_digits):\n            count += i//X\n    return str(count)\n\ndef"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    x, a, b = map(int, input_list[0].split())\n    allowed_digits = sorted(set(input_list[1]))\n\n    count = 0\n    for i in range(a, b+1):\n        if all(digit in allowed_digits for digit in str(i)):\n            if i % x == 0:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, t = map(int, input_data[0].split())\n    prescriptions = [list(map(int, line.split())) for line in input_data[1:]]\n    prescriptions.sort(key=lambda x: x[0])\n    in_store_prescriptions = [p for p in prescriptions if p[1] == \"S\"]\n    remote_prescriptions = [p for p in prescriptions if p[1] == \"R\"]\n    in_store_completion_times = [p[0] + p[2] for p in in_store_prescriptions]\n    remote_completion_times = [p[0] + p[2] for p in remote_prescriptions]\n\n    in_store_completion_times = in_store_completion_times[:t]\n    remote_completion_times = remote_completion_times[:t]\n\n    in_store_avg_completion_time = sum(in_store_completion_times) / len(in_store_completion_times) if in_store_completion_times else 0\n    remote_avg_completion_time = sum(remote_completion_times) / len(remote_completion_times) if remote_completion_times else 0\n\n    output = f\"{in_store_avg_completion_time:.6f} {remote_avg_completion_time:.6f}\"\n    return output\n\n\nstdin = \"\"\"5 3\n1 R 4\n2 R 2\n3 R 2\n4 S 2\n5 S 1\"\"\"\n\nprint(solution(stdin)) # Output: 1.500000 2.666667 "
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, input().split())\n    if n == 0:\n        return \"0 0\"\n\n    in_store_prescriptions = []\n    remote_prescriptions = []\n\n    for _ in range(n):\n        drop_off_time, prescription_type, fill_time = input().split()\n        drop_off_time = int(drop_off_time)\n        fill_time = int(fill_time)\n\n        if prescription_type == 'R':\n            remote_prescriptions.append((drop_off_time, fill_time))\n        else:\n            in_store_prescriptions.append((drop_off_time, fill_time))\n\n    in_store_prescriptions.sort(key=lambda x: (x[0], x[1]))\n    remote_prescriptions.sort(key=lambda x: (x[0], x[1]))\n\n    total_completion_time = 0\n    technicians_working = 0\n\n    for prescription_type, prescriptions in [(in_store_prescriptions, 'S'), (remote_prescriptions, 'R')]:\n        for drop_off_time, fill_time in prescription_type:\n            if technicians_working < t:\n                technicians_working += 1\n                total_completion_time += drop_off_time + fill_time\n            else:\n                break\n\n    if technicians_working == 0:\n        return \"0 0\"\n\n    o = total_completion_time / technicians_working\n    r = total_completion_time / technicians_working\n\n    return f\"{o:.6f} {r:.6f}\"\n\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    prescriptions = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def fill_prescription(prescription, technicians):\n        start_time = prescription[0]\n        fill_time = prescription[2]\n        for technician in technicians:\n            if technician.available and technician.fill_time <= fill_time:\n                technician.available = False\n                end_time = start_time + fill_time\n                technician.completed_prescriptions.append((prescription[1], start_time, end_time))\n                return end_time\n        return None\n\n    class Technician:\n        def __init__(self):\n            self.available = True\n            self.fill_time = float('inf')\n            self.completed_prescriptions = []\n\n    in_store_prescriptions = [prescription for prescription in prescriptions if prescription[1] == 'S']\n    remote_prescriptions = [prescription for prescription in prescriptions if prescription[1] == 'R']\n\n    technicians = [Technician() for _ in range(t)]\n    in_store_completed_times = []\n    remote_completed_times = []\n\n    for prescription in sorted(in_store_prescriptions, key=lambda x: x[0]):\n        in_store_completed_times.append(fill_prescription(prescription, technicians))\n\n    for prescription in remote_prescriptions:\n        remote_completed_times.append(fill_prescription(prescription, technicians))\n\n    in_store_completed_times = [time for time in in_store_completed_times if time is not None]\n    remote_completed_times = [time for time in remote_completed_times if time is not None]\n\n    if not in_store_completed_times and not remote_completed_times:\n        return \"0.0 0.0\"\n\n    in_store_average = sum(in_store_completed_times) / len(in_store_completed_times)\n    remote_average = sum(remote_completed_times) / len(remote_completed_times)\n\n    return f\"{in_store_average:.6f} {remote_average:.6f}\"\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def fill_prescriptions(prescriptions: list) -> float:\n        in_store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n        remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n        \n        in_store_completion_times = [p[2] + p[3] for p in in_store_prescriptions]\n        remote_completion_times = [p[2] for p in remote_prescriptions]\n        \n        completion_times = in_store_completion_times + remote_completion_times\n        \n        if not completion_times:\n            return 0, 0\n        \n        avg_completion_time = sum(completion_times) / len(completion_times)\n        \n        return avg_completion_time\n\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    prescriptions = [[int(x) for x in line.split()] for line in lines[1:]]\n\n    in_store_completion_time, remote_completion_time = fill_prescriptions(prescriptions)\n\n    return f'{in_store_completion_time:.6f} {remote_completion_time:.6f}'"
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.split('\\n')\n    n, t = map(int, lines[0].split())\n    prescriptions = []\n    for line in lines[1:]:\n        time, type, fill_time = map(int, line.split())\n        prescriptions.append((time, type, fill_time))\n    \n    # sort prescriptions by time\n    prescriptions.sort(key=lambda x: x[0])\n    \n    # initialize technicians\n    technicians = [None] * t\n    \n    # initialize variables to track statistics\n    total_store_completion_time = 0\n    total_remote_completion_time = 0\n    store_count = 0\n    remote_count = 0\n    \n    # iterate through prescriptions and fill them with technicians\n    for prescription in prescriptions:\n        time, type, fill_time = prescription\n        # find an available technician\n        technician_index = None\n        for i, technician in enumerate(technicians):\n            if technician is None:\n                technician_index = i\n                break\n        # if no technician is available, skip the prescription\n        if technician_index is None:\n            continue\n        # assign the prescription to the technician\n        technicians[technician_index] = prescription\n        # update statistics\n        if type == 0:\n            total_store_completion_time += fill_time\n            store_count += 1\n        else:\n            total_remote_completion_time += fill_time\n            remote_count += 1\n    \n    # compute average completion time\n    if store_count == 0:\n        o_avg = 0\n    else:\n        o_avg = total_store_completion_time / store_count\n    \n    if remote_count == 0:\n        r_avg = 0\n    else:\n        r_avg = total_remote_completion_time / remote_count\n    \n    return f\"{o_avg:.6f} {r_avg:.6f}\""
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    in_store_prescriptions = []\n    remote_prescriptions = []\n    total_completion_time = 0\n\n    for _ in range(n):\n        time, prescription_type, fill_time = stdin.split()\n        time = int(time)\n        fill_time = int(fill_time)\n\n        if prescription_type == 'S':\n            in_store_prescriptions.append((time, fill_time))\n        else:\n            remote_prescriptions.append((time, fill_time))\n\n    in_store_prescriptions.sort(key=lambda x: x[0])\n    remote_prescriptions.sort(key=lambda x: x[0])\n\n    current_time = 0\n    technicians = [0] * T\n    while in_store_prescriptions or remote_prescriptions:\n        for i, technician in enumerate(technicians):\n            if technician <= current_time and (not in_store_prescriptions or in_store_prescriptions[0][0] > current_time):\n                if remote_prescriptions and remote_prescriptions[0][0] < in_store_prescriptions[0][0]:\n                    completion_time = remote_prescriptions.pop(0)[1] + remote_prescriptions[0][0] - current_time\n                    technicians[i] = remote_prescriptions[0][0]\n                else:\n                    completion_time = in_store_prescriptions.pop(0)[1] + in_store_prescriptions[0][0] - current_time\n                    technicians[i] = in_store_prescriptions[0][0]\n                total_completion_time += completion_time\n                current_time = max(current_time, completion_time)\n\n        if not technicians:\n            break\n\n    if total_completion_time == 0:\n        return \"0.0 0.0\"\n    else:\n        avg_in_store_completion_time = total_completion_time / len(in_store_prescriptions)\n        avg_remote_completion_time = total_completion_time / len(remote_prescriptions)\n        return f\"{avg_in_store_completion_time:.6f} {avg_remote_completion_time:.6f}\" "
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_drop_off_time(line: str) -> int:\n        return int(line.split()[0])\n\n    def get_prescription_type(line: str) -> str:\n        return line.split()[1]\n\n    def get_fill_time(line: str) -> int:\n        return int(line.split()[2])\n\n    def compute_completion_time(drop_off_time: int, fill_time: int) -> float:\n        return drop_off_time + fill_time\n\n    def is_in_store(prescription_type: str) -> bool:\n        return prescription_type == 'S'\n\n    def read_input(stdin: str) -> List[str]:\n        return stdin.splitlines()\n\n    def process_in_store_prescriptions(prescriptions: List[str], technicians: int) -> List[float]:\n        completion_times = []\n        in_store_prescriptions = [p for p in prescriptions if is_in_store(get_prescription_type(p))]\n        in_store_prescriptions.sort(key=get_drop_off_time)\n\n        for prescription in in_store_prescriptions:\n            drop_off_time = get_drop_off_time(prescription)\n            fill_time = get_fill_time(prescription)\n            completion_time = compute_completion_time(drop_off_time, fill_time)\n            completion_times.append(completion_time)\n            technicians -= 1\n            if technicians == 0:\n                break\n\n        return completion_times\n\n    def process_remote_prescriptions(prescriptions: List[str], technicians: int) -> List[float]:\n        completion_times = []\n        remote_prescriptions = [p for p in prescriptions if not is_in_store(get_prescription_type(p))]\n        remote_prescriptions.sort(key=get_drop_off_time)\n\n        for prescription in remote_prescriptions:\n            drop_off_time = get_drop_off_time(prescription)\n            fill_time = get_fill_time(prescription)\n            completion_time = compute_completion_time(drop_off_time, fill_time)\n            completion_times.append(completion_time)\n            technicians -= 1\n            if technicians == 0:\n                break\n\n        return completion_times\n\n    def compute_average_completion_time(completion_times: List[float]) -> float:\n        if not completion_times:\n            return 0\n        return sum(completion_times) / len(completion_times)\n\n    def main(stdin: str) -> str:\n        n, t = map(int, input().split())\n        prescriptions = read_input(stdin)\n        in_store_completion_times = process_in_store_prescriptions(prescriptions, t)\n        remote_completion_times = process_remote_prescriptions(prescriptions, t)\n        in_store_average_completion_time = compute_average_completion_time(in_store_completion_times)\n        remote_average_completion_time = compute_average_completion_time(remote_completion_times)\n        return f\"{in_store_average_completion_time:.6f} {remote_average_completion_time:.6f}\"\n\n    return main(stdin) "
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    lines = input_str.split('\\n')\n    n, t = map(int, lines[0].split())\n    if n == 0:\n        return '0 0'\n    prescriptions = sorted([list(map(int, line.split())) for line in lines[1:]], key=lambda x: (x[0], x[1]))\n    total_time = 0\n    in_store_time = 0\n    in_store_count = 0\n    remote_time = 0\n    remote_count = 0\n    technicians = [0] * t\n    for prescription in prescriptions:\n        time, prescription_type, fill_time = prescription\n        if prescription_type == 'R':\n            remote_count += 1\n            remote_time += fill_time\n        elif prescription_type == 'S':\n            in_store_count += 1\n            in_store_time += fill_time\n        technicians[time % t] += fill_time\n    if in_store_count + remote_count > 0:\n        total_time = (in_store_time + remote_time) / (in_store_count + remote_count)\n    return f\"{total_time:.6f} {in_store_time / in_store_count:.6f}\"\n\ndef"
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    prescriptions = []\n    for _ in range(n):\n        line = stdin.split()[2:]\n        drop_off_time, type_, fill_time = map(int, line[:3])\n        prescriptions.append((drop_off_time, type_, fill_time))\n\n    in_store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n    remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n\n    in_store_prescriptions.sort(key=lambda x: x[0])\n    remote_prescriptions.sort(key=lambda x: x[0])\n\n    technicians = [None] * t\n    in_store_index = 0\n    remote_index = 0\n\n    total_completion_time = 0\n    total_in_store_prescriptions = 0\n    total_remote_prescriptions = 0\n\n    while in_store_index < len(in_store_prescriptions) or remote_index < len(remote_prescriptions):\n        if technicians == [None] * t:\n            if remote_index < len(remote_prescriptions) and (in_store_index == len(in_store_prescriptions) or remote_prescriptions[remote_index][0] <= in_store_prescriptions[in_store_index][0]):\n                technician = max(technicians, key=lambda x: x is None or x.fill_time)\n                technician.start_filling(remote_prescriptions[remote_index][2])\n                remote_index += 1\n            elif in_store_index < len(in_store_prescriptions):\n                technician = max(technicians, key=lambda x: x is None or x.fill_time)\n                technician.start_filling(in_store_prescriptions[in_store_index][2])\n                in_store_index += 1\n        else:\n            for i, technician in enumerate(technicians):\n                if technician is not None and technician.is_finished():\n                    completion_time = technician.completion_time\n                    total_completion_time += completion_time\n                    if technician.prescription_type == 'S':\n                        total_in_store_prescriptions += 1\n                    else:\n                        total_remote_prescriptions += 1\n                    technicians[i] = None\n\n    if total_in_store_prescriptions + total_remote_prescriptions == 0:\n        return \"0.0 0.0\"\n\n    avg_in_store_completion_time = total_completion_time / total_in_store_prescriptions if total_in_store_prescriptions > 0 else 0\n    avg_remote_completion_time = total_completion_time / total_remote_prescriptions if total_remote_prescriptions > 0 else 0\n\n    return f\"{avg_in_store_completion_time:.6f} {avg_remote_completion_time:.6f}\"\n\nclass Technician:\n    def __init__(self, fill_time):\n        self.fill_time = fill_time\n        self.start_time = None\n\n    def start_filling(self, fill_time):\n        self.start_time = 0\n        self.fill_time = fill_time\n\n    def is_finished(self):\n        return self.start_time is not None and self.start_time + self.fill_time <= 0\n\n    def completion_time(self):\n        return self.start_time + self.fill_time\n\n    def __repr__(self):\n        return f\"{self.fill_time}\""
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, t = map(int, input_list[0].split())\n    if n == 0:\n        return \"0 0\"\n    remote_prescriptions = []\n    in_store_prescriptions = []\n    technicians_working = [False] * t\n    for i in range(1, n+1):\n        if input_list[i].split()[1] == \"R\":\n            remote_prescriptions.append((int(input_list[i].split()[0]), int(input_list[i].split()[2]), i))\n        else:\n            in_store_prescriptions.append((int(input_list[i].split()[0]), int(input_list[i].split()[2]), i))\n    \n    remote_prescriptions.sort(key=lambda x: x[0])\n    in_store_prescriptions.sort(key=lambda x: x[0])\n\n    current_time = 0\n    remote_index = 0\n    in_store_index = 0\n    technicians_available = [False] * t\n    technicians_busy = [False] * t\n    technician_times = [0] * t\n    technician_count = 0\n\n    while remote_index < len(remote_prescriptions) or in_store_index < len(in_store_prescriptions):\n        if remote_index < len(remote_prescriptions) and in_store_index < len(in_store_prescriptions):\n            if remote_prescriptions[remote_index][0] <= in_store_prescriptions[in_store_index][0]:\n                if not technicians_available[current_time % t]:\n                    technicians_available[current_time % t] = True\n                    technician_count += 1\n                    technician_times[current_time % t] = current_time\n                    current_time += remote_prescriptions[remote_index][1]\n                    remote_index += 1\n                else:\n                    technicians_working[current_time % t] = True\n                    current_time += remote_prescriptions[remote_index][1]\n                    remote_index += 1\n            else:\n                if not technicians_available[current_time % t]:\n                    technicians_available[current_time % t] = True\n                    technician_count += 1\n                    technician_times[current_time % t] = current_time\n                    current_time += in_store_prescriptions[in_store_index][1]\n                    in_store_index += 1\n                else:\n                    technicians_working[current_time % t] = True\n                    current_time += in_store_prescriptions[in_store_index][1]\n                    in_store_index += 1\n        elif remote_index < len(remote_prescriptions):\n            if not technicians_available[current_time % t]:\n                technicians_available[current_time % t] = True\n                technician_count += 1\n                technician_times[current_time % t] = current_time\n                current_time += remote_prescriptions[remote_index][1]\n                remote_index += 1\n            else:\n                technicians_working[current_time % t] = True\n                current_time += remote_prescriptions[remote_index][1]\n                remote_index += 1\n        else:\n            if not technicians_available[current_time % t]:\n                technicians_available[current_time % t] = True\n                technician_count += 1\n                technician_times[current_time % t] = current_time\n                current_time += in_store_prescriptions[in_store_index][1]\n                in_store_index += 1\n            else:\n                technicians_working[current_time % t] = True\n                current_time += in_store_prescriptions[in_store_index][1]\n                in_store_index += 1\n\n        if technician_count == t:\n            for i in range(t):\n                if technicians_working[i]:\n                    technicians_available[i] = False\n                    technicians_bus"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, memory = 0, 0, []\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            R, C = map(int, line.split())\n        else:\n            memory.append(list(line))\n\n    def is_square_killer(i, j, size):\n        return all(memory[x][y] == memory[i][j] for x in range(i, i + size) for y in range(j, j + size))\n\n    def find_largest_killer(i, j, size):\n        if size > R or size > C or not is_square_killer(i, j, size):\n            return size - 1\n        return max(find_largest_killer(i, j + 1, size), find_largest_killer(i + 1, j, size))\n\n    largest_killer = max(find_largest_killer(0, 0, size) for size in range(1, min(R, C) + 1))\n    return largest_killer if largest_killer > 0 else -1"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    memory = [list(input().strip()) for _ in range(R)]\n\n    max_size = 0\n    for i in range(R - max_size):\n        for j in range(C - max_size):\n            for size in range(max_size + 1, min(R - i, C - j) + 1):\n                for k in range(max_size + 1, size + 1):\n                    if (memory[i + size - 1][j:j + k] ==\n                        memory[i + k - 1][j:j + size][::-1]):\n                        max_size = max(max_size, size)\n                        break\n                else:\n                    continue\n                break\n            else:\n                continue\n            break\n\n    return max_size if max_size > 0 else -1\n"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_killer_size(memory: List[str]) -> int:\n        rows = len(memory)\n        cols = len(memory[0])\n        max_size = 0\n        \n        for i in range(rows):\n            for j in range(cols):\n                if memory[i][j] == '1':\n                    size = 1\n                    for k in range(i+1, rows):\n                        if memory[k][j] == '1':\n                            size += 1\n                        else:\n                            break\n                    for k in range(j+1, cols):\n                        if memory[i][k] == '1':\n                            size += 1\n                        else:\n                            break\n                    max_size = max(max_size, size)\n                    if max_size == size:\n                        killer_memory = [row[j:j+size] for row in memory[i:i+size]]\n                        if all(row == '1' for row in killer_memory):\n                            return size\n        return -1\n    \n    R, C = map(int, stdin.split()[:2])\n    memory = [stdin.split()[2+i:2+i+C] for i in range(R)]\n    return get_killer_size(memory)"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    R, C = map(int, input_lines[0].split())\n    memory = [list(line) for line in input_lines[1:]]\n    max_size = 1\n\n    for r1 in range(R - max_size + 1):\n        for c1 in range(C - max_size + 1):\n            for size in range(max_size, R - r1 + 1):\n                if all(memory[r2][c2] == memory[r1][c1] for r2 in range(r1, r1 + size) for c2 in range(c1, c1 + size)):\n                    max_size = max(max_size, size)\n\n    return max_size if max_size != 1 else \"-1\"\n"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    memory = [list(input()) for _ in range(R)]\n\n    def rotate(matrix):\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]) - 1, -1, -1)]\n\n    def find_killers(matrix):\n        killers = []\n        for r in range(R - 2):\n            for c in range(C - 2):\n                killer_size = 0\n                for d in range(1, min(R - r, C - c)):\n                    if all(matrix[r + dr][c + dc] == matrix[r][c] for dr in range(killer_size + 1) for dc in range(d - killer_size + 1)):\n                        killer_size = d\n                    else:\n                        break\n                if killer_size > 0:\n                    killers.append(killer_size)\n        return killers\n\n    def find_largest_killer(killers):\n        if not killers:\n            return -1\n        return max(killers)\n\n    rotated_memory = rotate(memory)\n    killers = find_killers(rotated_memory)\n    largest_killer = find_largest_killer(killers)\n    return largest_killer\n"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    memory = [list(line.strip()) for line in stdin.split('\\n')[1:] if line.strip()]\n\n    def is_killer(killer_size, row, col):\n        killer_rows = memory[row:row+killer_size]\n        killer_cols = [memory[i][col:col+killer_size] for i in range(row, row+killer_size)]\n\n        killer = [['']*C for _ in range(killer_size)]\n        for i in range(killer_size):\n            for j in range(killer_size):\n                killer[i][j] = killer_rows[i][j]\n\n        for _ in range(killer_size):\n            for i in range(killer_size):\n                if killer[i] != killer_cols[i]:\n                    return False\n        return True\n\n    max_killer_size = 0\n    for row in range(R-1):\n        for col in range(C-1):\n            for killer_size in range(min(R-row, C-col)):\n                if is_killer(killer_size+1, row, col):\n                    max_killer_size = max(max_killer_size, killer_size+1)\n                    break\n\n    return max_killer_size if max_killer_size > 0 else -1"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    R, C = map(int, lines[0].split())\n    matrix = []\n    for i in range(1, R + 1):\n        matrix.append(list(lines[i]))\n\n    max_size = 0\n    for r in range(R - 1):\n        for c in range(C - 1):\n            if matrix[r][c] == '1' and matrix[r][c + 1] == '1' and matrix[r + 1][c] == '1':\n                size = 2\n                while r + size < R and c + size < C and matrix[r + size][c] == '1' and matrix[r][c + size] == '1' and matrix[r + size][c + size] == '1':\n                    size += 1\n                max_size = max(max_size, size)\n\n    for r in range(R - 1):\n        for c in range(C - 1):\n            if matrix[r][c] == '1' and matrix[r + 1][c] == '1' and matrix[r][c + 1] == '1':\n                size = 2\n                while r + size < R and c + size < C and matrix[r + size][c] == '1' and matrix[r][c + size] == '1' and matrix[r + size][c + size] == '1':\n                    size += 1\n                max_size = max(max_size, size)\n\n    if max_size == 0:\n        return \"-1\"\n    else:\n        return str(max_size)\n\nstdin = \"\"\"\n3 6\n101010\n111001\n101001\n\"\"\"\nprint(solution(stdin))\n\nstdin = \"\"\"\n4 5\n10010\n01010\n10101\n01001\n\"\"\"\nprint(solution(stdin)) "
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    matrix = [list(map(int, line.strip())) for line in stdin.split('\\n')[1:]]\n    largest_killer_size = -1\n    \n    for i in range(R - 1):\n        for j in range(C - 1):\n            killer = [matrix[i + di][j + dj] for di in range(2) for dj in range(2)]\n            if len(set(killer)) == 1:\n                killer_size = 2\n            else:\n                killer_size = 1\n            for di in range(1, R - i):\n                for dj in range(1, C - j):\n                    killer = [matrix[i + di + dii][j + dj + dji] for dii in range(2) for dji in range(2)]\n                    if len(set(killer)) == 1:\n                        killer_size = max(killer_size, di + 1)\n            largest_killer_size = max(largest_killer_size, killer_size)\n    \n    return str(largest_killer_size) if largest_killer_size != -1 else \"-1\"\n"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_square_killer(matrix: list, i: int, j: int, size: int) -> bool:\n        if size <= 1:\n            return False\n        for dx in range(size):\n            for dy in range(size):\n                if matrix[i+dx][j+dy] == 0:\n                    return False\n        return True\n\n    def find_largest_killer(matrix: list, size: int) -> int:\n        max_size = 0\n        for i in range(len(matrix) - size + 1):\n            for j in range(len(matrix[0]) - size + 1):\n                if is_square_killer(matrix, i, j, size):\n                    max_size = max(max_size, size)\n        return max_size\n\n    R, C = map(int, stdin.split())\n    matrix = []\n    for _ in range(R):\n        row = list(stdin.pop().strip())\n        matrix.append(row)\n\n    max_size = find_largest_killer(matrix, 1)\n    if max_size == 0:\n        return \"-1\"\n    else:\n        return str(max_size)\n"
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    matrix = [list(input()) for _ in range(R)]\n    max_size = 0\n    \n    for r in range(R - max_size):\n        for c in range(C - max_size):\n            for size in range(max_size + 1, max_size + C):\n                if all(matrix[r + i][c + i % C] == matrix[r + i + 1][c + i % C] for i in range(size)):\n                    max_size = max(max_size, size)\n                    \n    return str(max_size) if max_size > 0 else \"-1\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    swimmers = [[int(x), int(y)] for x, y in map(str.split, input_data[1:])]\n\n    # Find the closest swimmer to each lifeguard\n    you_closest = None\n    coworker_closest = None\n    for swimmer in swimmers:\n        x, y = swimmer\n        dx = abs(x - 0)\n        dy = abs(y - 0)\n        distance = dx ** 2 + dy ** 2\n        if you_closest is None or distance < you_closest[1]:\n            you_closest = [swimmer, distance]\n        dx = abs(x - 1)\n        dy = abs(y - 0)\n        distance = dx ** 2 + dy ** 2\n        if coworker_closest is None or distance < coworker_closest[1]:\n            coworker_closest = [swimmer, distance]\n\n    # Find the swimmers that need to be assigned to both lifeguards\n    assignable_swimmers = []\n    for swimmer in swimmers:\n        dx = abs(swimmer[0] - you_closest[0][0])\n        dy = abs(swimmer[1] - you_closest[0][1])\n        distance = dx ** 2 + dy ** 2\n        if distance == you_closest[1]:\n            assignable_swimmers.append(swimmer)\n        dx = abs(swimmer[0] - coworker_closest[0][0])\n        dy = abs(swimmer[1] - coworker_closest[0][1])\n        distance = dx ** 2 + dy ** 2\n        if distance == coworker_closest[1]:\n            assignable_swimmers.append(swimmer)\n\n    # Assign the swimmers to the lifeguards\n    you_swimmers = []\n    coworker_swimmers = []\n    for swimmer in assignable_swimmers:\n        dx = abs(swimmer[0] - 0)\n        dy = abs(swimmer[1] - 0)\n        distance = dx ** 2 + dy ** 2\n        if distance <= you_closest[1]:\n            you_swimmers.append(swimmer)\n        else:\n            coworker_swimmers.append(swimmer)\n\n    # Calculate the final positions\n    you_x = 0\n    you_y = 0\n    coworker_x = 0\n    coworker_y = 0\n    for swimmer in you_swimmers:\n        you_x += swimmer[0]\n        you_y += swimmer[1]\n    for swimmer in coworker_swimmers:\n        coworker_x += swimmer[0]\n        coworker_y += swimmer[1]\n    you_x //= len(you_swimmers)\n    you_y //= len(you_swimmers)\n    coworker_x //= len(coworker_swimmers)\n    coworker_y //= len(coworker_swimmers)\n\n    return f\"{you_x} {you_y}\\n{coworker_x} {coworker_y}\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    swimmers = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    swimmers.sort(key=lambda s: distance(s, (0, 0)))\n\n    half_n = n // 2\n    d1, d2 = 0, 0\n    p1, p2 = (0, 0), (0, 0)\n\n    for i, s in enumerate(swimmers):\n        if i < half_n:\n            d1 += distance(s, p1)\n            p1 = s\n        else:\n            d2 += distance(s, p2)\n            p2 = s\n\n        if i == half_n - 1:\n            if d1 == d2:\n                return str(p1[0]) + ' ' + str(p1[1]) + '\\n' + str(p2[0]) + ' ' + str(p2[1])\n            elif d1 < d2:\n                p2 = p1\n                d2 = d1\n\n    return str(p1[0]) + ' ' + str(p1[1]) + '\\n' + str(p2[0]) + ' ' + str(p2[1])"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    data = [list(map(int, x.split())) for x in data]\n\n    def distance(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    def find_closest(guards, swimmers):\n        closest = None\n        min_dist = float('inf')\n        for guard in guards:\n            for swimmer in swimmers:\n                dist = distance(guard, swimmer)\n                if dist < min_dist:\n                    min_dist = dist\n                    closest = guard\n\n        return closest\n\n    guards = data[:n//2]\n    swimmers = data[n//2:]\n\n    closest_guard = find_closest(guards, swimmers)\n\n    def find_balanced_groups():\n        def is_balanced(groups):\n            return abs(len(groups[0]) - len(groups[1])) <= 1\n\n        def balance_groups(groups):\n            if len(groups[0]) == len(groups[1]):\n                return groups\n            elif len(groups[0]) > len(groups[1]):\n                return [groups[0][:-1], groups[1] + [groups[0][-1]]]\n            else:\n                return [groups[0] + [groups[1][-1]], groups[1][:-1]]\n\n        groups = [[], []]\n        for swimmer in swimmers:\n            groups[distance(swimmer, closest_guard) < distance(swimmer, guards[-1])].append(swimmer)\n\n        while not is_balanced(groups):\n            groups = balance_groups(groups)\n\n        return groups\n\n    groups = find_balanced_groups()\n    print(closest_guard[0], groups[0][0][0], groups[1][0][0])\n    print(closest_guard[1], groups[0][1][0], groups[1][1][0])\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    n = int(stdin.splitlines()[0])\n    swimmers = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    swimmers.sort(key=lambda x: (x[0]**2 + x[1]**2, x[1], x[0]))\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if distance(*swimmers[i], *swimmers[j]) == 0:\n                you = swimmers[i]\n                coworker = swimmers[j]\n                return f\"{you[0]} {you[1]}\\n{coworker[0]} {coworker[1]}\"\n\n    for i in range(n):\n        for j in range(i + 2, n, 2):\n            you = swimmers[i]\n            coworker = swimmers[j]\n            if distance(*you, *coworker) == distance(*you) + distance(*coworker):\n                return f\"{you[0]} {you[1]}\\n{coworker[0]} {coworker[1]}\"\n\n    raise ValueError(\"No valid solution found.\")"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    swimmers = [tuple(map(int, input_list[i + 1].split())) for i in range(n)]\n\n    swimmers.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n\n    x_sum = 0\n    y_sum = 0\n\n    for i in range(0, n, 2):\n        x_sum += swimmers[i][0]\n        y_sum += swimmers[i][1]\n\n    x1 = -y_sum / n\n    y1 = x_sum / n\n\n    return f\"{x1} {y1}\\n{x1} {y1}\"\n\n\ndef"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dist(p1, p2):\n        return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    n = int(stdin.split(\"\\n\", 1)[0])\n    swimmers = []\n    for i in range(1, n+1):\n        x, y = map(int, stdin.split(\"\\n\", i)[i].split())\n        swimmers.append((x, y))\n\n    swimmers.sort(key=lambda p: (p[1], -p[0]))\n    p1, p2 = swimmers[n//2], swimmers[n//2 - 1]\n\n    while dist(p1, p2) != 0:\n        p1, p2 = p1 + (p2-p1)//2, p2 - (p2-p1)//2\n\n    return f\"{p1[0]} {p1[1]}\\n{p2[0]} {p2[1]}\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *swimmers = stdin.split('\\n')\n    n = int(n)\n    swimmers = [tuple(map(int, swimmer.split())) for swimmer in swimmers]\n\n    min_distance = float('inf')\n    best_positions = None\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n\n            distance = 0\n            for swimmer in swimmers:\n                distance += abs(swimmer[0] - (i - j)) + abs(swimmer[1] - (i + j))\n\n            if distance < min_distance:\n                min_distance = distance\n                best_positions = (i - j, i + j)\n\n    return f\"{best_positions[0]} {best_positions[1]}\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *swimmers = stdin.split('\\n')\n    n = int(n)\n    swimmers = [list(map(int, line.split())) for line in swimmers]\n\n    def distance(a, b):\n        return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\n\n    def min_distance(a, b):\n        return min(distance(a, swimmers[i]) + distance(b, swimmers[i]) for i in range(n))\n\n    def divide_swimmers(a, b):\n        return sum(distance(a, swimmers[i]) + distance(b, swimmers[i]) <= min_distance(a, b) for i in range(n))\n\n    min_dist = float('inf')\n    min_a, min_b = None, None\n\n    for a in swimmers:\n        for b in swimmers:\n            if a != b:\n                dist = divide_swimmers(a, b)\n                if dist < min_dist:\n                    min_dist = dist\n                    min_a, min_b = a, b\n\n    return f\"{min_a[0]} {min_a[1]}\\n{min_b[0]} {min_b[1]}\""
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    swimmers = [(int(input()), int(input())) for _ in range(n)]\n\n    def distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    swimmers.sort(key=lambda x: distance(x, (0, 0)))\n    swimmers.sort(key=lambda x: distance(x, (1, 0)))\n\n    target_distance = distance(swimmers[0], swimmers[-1])\n\n    for i in range(n - 1):\n        if distance(swimmers[i], swimmers[i + 1]) != target_distance:\n            break\n\n    you = swimmers[i]\n    your_coworker = swimmers[-i - 1]\n\n    return f\"{you[0]} {you[1]}\\n{your_coworker[0]} {your_coworker[1]}\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    swimmers = [tuple(map(int, input_line.split())) for input_line in input_data[1:]]\n\n    def distance(p1, p2):\n        return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\n    swimmers.sort(key=lambda p: distance(p, (0, 0)))\n\n    x1, y1 = swimmers[n // 2 - 1]\n    x2, y2 = swimmers[n // 2]\n\n    print(str(x1) + ' ' + str(y1))\n    print(str(x2) + ' ' + str(y2))\n\n\nstdin = \"\"\"5\n0 0\n0 1\n1 0\n0 -1\n-1 0\"\"\"\nsolution(stdin)  # Output: -3 -1, 3 1\n\nstdin = \"\"\"4\n2 4\n6 -1\n3 5\n-1 -1\"\"\"\nsolution(stdin)  # Output: 3 4, 3 -1 "
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt, atan2, pi\n\n    input_values = stdin.strip().split()\n    n, omega, w_0, v_0, theta, w, x_wall = map(float, input_values)\n    assert 3 <= n <= 20\n    assert 0 <= omega <= 10\n    assert 1 <= v_0 <= 10\n    assert 0 <= theta <= 80\n    assert 20 <= w <= 500\n\n    theta = theta * pi / 180  # convert to radians\n    v_x = v_0 * cos(theta)\n    v_y = v_0 * sin(theta)\n    w_x = w * cos(theta + pi / 2)\n    w_y = w * sin(theta + pi / 2)\n\n    def time_to_hit_wall(x_pos, y_pos, x_wall, w_x, w_y):\n        a = w_x**2 + w_y**2\n        b = 2 * (w_x * (x_wall - x_pos) + w_y * (y_pos + 1))\n        c = x_pos**2 + y_pos**2 - 2 * (x_wall - x_pos) * x_wall + x_wall**2 - 1\n        discriminant = b**2 - 4*a*c\n        if discriminant < 0:\n            return None\n        t1 = (-b + sqrt(discriminant)) / (2*a)\n        t2 = (-b - sqrt(discriminant)) / (2*a)\n        if t1 < 0:\n            return t2\n        if t2 < 0:\n            return t1\n        return min(t1, t2)\n\n    def update_positions(x_pos, y_pos, v_x, v_y, omega, dt):\n        x_pos += v_x * dt\n        y_pos += v_y * dt\n        new_v_x = v_x - omega * v_y * dt\n        new_v_y = v_y + omega * v_x * dt\n        return x_pos, y_pos, new_v_x, new_v_y\n\n    def compute_hit_corner(x_pos, y_pos, vertices):\n        closest_distance = float('inf')\n        closest_corner = None\n        for i, (x_v, y_v) in enumerate(vertices, 1):\n            distance = sqrt((x_pos - x_v)**2 + (y_pos - y_v)**2)\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_corner = i\n        return closest_corner\n\n    vertices = [(0, 0)] * n\n    for i in range(n):\n        vertices[i] = tuple(map(float, input().split()))\n\n    t = 0\n    dt = 0.001\n    while True:\n        t += dt\n        new_x_pos, new_y_pos, new_v_x, new_v_y = update_positions(*vertices[0], v_x, v_y, omega, dt)\n        if time_to_hit_wall(new_x_pos, new_y_pos, x_wall, w_x, w_y) is not None:\n            break\n        vertices[0] = (new_x_pos, new_y_pos)\n        v_x, v_y = new_v_x, new_v_y\n\n    t_hit = time_to_hit_wall(*vertices[0], x_wall, w_x, w_y)\n    if t_hit is not None:\n        hit_corner = compute_hit_corner(*vertices[0], vertices)\n        return f\"{hit_corner} {t_hit:.6f}\"\n    else:\n        return \"None\"\n\ninput_data = \"3 6 5 45 20\\n0 0\\n2 0\\n1 1.5\"\nprint(solution(input_data)) "
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def is_corner(x1, y1, x2, y2, x3, y3):\n        a = distance(x1, y1, x2, y2)\n        b = distance(x2, y2, x3, y3)\n        c = distance(x3, y3, x1, y1)\n        s = (a + b + c) / 2\n        return round((s * (s - a) * (s - b) * (s - c)) ** 0.5, 6) < 1e-3\n\n    def find_corner(x1, y1, x2, y2, x3, y3):\n        for i in range(n):\n            if is_corner(x1, y1, x2, y2, x3, y3):\n                return i\n        return None\n\n    def find_time(t1, x1, y1, v1, t2, x2, y2, v2):\n        a = (v1 + v2) / 2\n        t = (distance(x1, y1, x2, y2) - (v1 * t1 + (v1 + v2) * (t2 - t1) / 2)) / a\n        return t\n\n    input_data = stdin.splitlines()\n    n, omega, v0, theta, w = map(float, input_data.pop(0).split())\n    x1, y1 = map(float, input_data.pop(0).split())\n    x2, y2 = map(float, input_data.pop(0).split())\n    x3, y3 = map(float, input_data.pop(0).split())\n\n    omega = omega * pi / 180\n    theta = theta * pi / 180\n    t1 = 0\n    t2 = 1e-2\n\n    while t2 - t1 > 1e-6:\n        t = (t1 + t2) / 2\n        x = w * cos(theta) - v0 * t * sin(theta + omega * t)\n        y = w * sin(theta) + v0 * t * cos(theta + omega * t)\n        if distance(x1, y1, x, y) < distance(x2, y2, x, y):\n            t1 = t\n        else:\n            t2 = t\n\n    i = find_corner(x1, y1, x2, y2, x3, y3)\n    if i is not None:\n        return f\"{i} {t2}\"\n    else:\n        return \"No corner hits the wall\"\n\ndef"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    first_line = input_list[0].split()\n    n = int(first_line[0])\n    omega = float(first_line[1])\n    omega_rad = omega * pi / 180\n    v_0 = float(first_line[2])\n    theta = float(first_line[3])\n    theta_rad = theta * pi / 180\n    wall_x = float(first_line[4])\n\n    x_coords = []\n    y_coords = []\n\n    for i in range(1, n + 1):\n        vertex = input_list[i].split()\n        x_coords.append(float(vertex[0]))\n        y_coords.append(float(vertex[1]))\n\n    cookies = []\n    for i in range(n):\n        cookies.append(Polygon([(x_coords[i], y_coords[i]), (x_coords[(i + 1) % n], y_coords[(i + 1) % n]), (x_coords[(i + 2) % n], y_coords[(i + 2) % n])]))\n\n    min_time = float('inf')\n    min_corner = 0\n    min_index = 0\n\n    for i, cookie in enumerate(cookies):\n        time_list = []\n        for point in cookie.exterior.coords:\n            if point[0] > wall_x:\n                time_list.append(abs((wall_x - point[0]) / (v_0 * cos(theta_rad))))\n            else:\n                time_list.append(float('inf'))\n        time_list.sort()\n        if time_list[0] < min_time:\n            min_time = time_list[0]\n            min_corner = i + 1\n            min_index = cookie.exterior.coords.index((wall_x, 0))\n\n    return f\"{min_corner} {min_time:.6f}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def compute_initial_angle(v0: float, omega: float, theta: float) -> float:\n        return np.arcsin(v0 / omega) + np.deg2rad(theta)\n\n    def compute_trajectory(vertices: np.ndarray, initial_angle: float) -> np.ndarray:\n        points = np.zeros((len(vertices), 2))\n        points[0] = vertices[0]\n        for i in range(1, len(vertices)):\n            angle = initial_angle + np.deg2rad(i * 360 / len(vertices))\n            x, y = points[i - 1]\n            x_new = x + np.cos(angle)\n            y_new = y + np.sin(angle)\n            points[i] = np.array([x_new, y_new])\n        return points\n\n    def compute_hit_time(wall: float, points: np.ndarray) -> float:\n        x_wall = wall\n        y_wall = 0\n        min_distance = float('inf')\n        hit_time = 0\n        for i in range(len(points)):\n            x, y = points[i]\n            distance = np.sqrt((x - x_wall) ** 2 + (y - y_wall) ** 2)\n            if distance < min_distance:\n                min_distance = distance\n                hit_time = i\n        return hit_time\n\n    def parse_input(input_str: str) -> Tuple[int, float, float, float, float, float, np.ndarray]:\n        lines = input_str.split('\\n')\n        n, omega, w, v0, theta, wall = map(float, lines[0].split())\n        vertices = np.array([list(map(float, line.split())) for line in lines[1:]])\n        initial_angle = compute_initial_angle(v0, omega, theta)\n        return n, omega, w, v0, theta, wall, vertices\n\n    n, omega, w, v0, theta, wall, vertices = parse_input(stdin)\n    initial_angle = compute_initial_angle(v0, omega, theta)\n    points = compute_trajectory(vertices, initial_angle)\n    hit_time = compute_hit_time(wall, points)\n    return f\"{hit_time // n + 1} {hit_time}\" "
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.strip().split('\\n')\n    n, omega, v0, theta, w, *coordinates = [float(x) for x in inputs[0].split()]\n    vertices = [(float(x), float(y)) for x, y in zip(*[iter(coordinates)]*2)]\n    theta = radians(theta)\n    corners = [(x+w*sin(theta+2*pi*i/n), y-w*cos(theta+2*pi*i/n)) for i, (x, y) in enumerate(vertices)]\n    def g(t: float) -> float:\n        return v0*t - 0.5*9.81*t**2\n    def v(t: float) -> float:\n        return v0 - 9.81*t\n    def a(t: float) -> float:\n        return -9.81\n    def get_time_to_hit_wall(corner: Tuple[float, float], theta: float) -> float:\n        x, y = corner\n        dx = cos(theta)\n        dy = sin(theta)\n        a = -9.81\n        b = g(0)\n        c = y-g(0)*x\n        D = b**2 - 4*a*c\n        if D < 0:\n            return float('inf')\n        t1 = (-b + sqrt(D))/(2*a)\n        t2 = (-b - sqrt(D))/(2*a)\n        if t1 < t2:\n            return t1\n        else:\n            return t2\n    def get_corner_that_hits_wall_first(corner: Tuple[float, float], theta: float) -> Tuple[int, float]:\n        t = get_time_to_hit_wall(corner, theta)\n        return corner[0], t\n    corner_with_shortest_hit_time = min(get_corner_that_hits_wall_first(corner, theta) for corner in corners)\n    return f\"{corner_with_shortest_hit_time[0]} {corner_with_shortest_hit_time[1]}\""
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    lines = stdin.splitlines()\n    n, omega, v0, theta, w = map(float, lines[0].split())\n    theta_rad = np.deg2rad(theta)\n    vertices = [tuple(map(float, line.split())) for line in lines[1:]]\n    \n    # compute initial position and velocity\n    init_pos = np.array(vertices[0])\n    init_vel = np.array([v0 * np.cos(theta_rad), v0 * np.sin(theta_rad)])\n    \n    # compute parabola equation\n    g = 9.81\n    a = np.sqrt(g / omega ** 2)\n    b = g / (omega ** 2)\n    x_parabola = lambda t: a * t ** 2\n    y_parabola = lambda t: b * t ** 2\n    \n    # compute corners and their velocities\n    corners = [init_pos + np.array([v * np.cos(theta_rad + np.deg2rad(i * 360 / n)), v * np.sin(theta_rad + np.deg2rad(i * 360 / n))]) for i in range(n) for v in init_vel]\n    vels = [np.array([v0 * np.cos(theta_rad + np.deg2rad(i * 360 / n)), v0 * np.sin(theta_rad + np.deg2rad(i * 360 / n))]) for i in range(n)]\n    \n    # compute first corner to hit wall\n    min_t = np.inf\n    for i in range(n):\n        t = 0\n        while t < 10:\n            t += 0.001\n            pos = corners[i] + vels[i] * t\n            if pos[0] <= w:\n                break\n        if t < min_t:\n            min_t = t\n            min_i = i\n    \n    # compute corner that hits wall first\n    i = min_i\n    t = min_t\n    T_i = t\n    while True:\n        pos = corners[i] + vels[i] * T_i\n        if pos[0] > w:\n            break\n        T_i += 1e-3\n    \n    # format output\n    return f\"{i + 1} {T_i:.6f}\"\n\nimport numpy as np"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, omega, v0, theta, w = map(float, input_data.pop(0).split())\n    vertices = []\n    for i in range(n):\n        x, y = map(float, input_data.pop(0).split())\n        vertices.append((x, y))\n\n    def angle(v1, v2):\n        return math.atan2(v2[1] - v1[1], v2[0] - v1[0])\n\n    def velocity(v, omega, theta):\n        v = np.array(v)\n        omega = np.radians(omega)\n        theta = np.radians(theta)\n        R = np.array([[np.cos(theta), -np.sin(theta)], [np.sin(theta), np.cos(theta)]])\n        v_rotated = np.dot(R, v)\n        v_rotated[0] += v_rotated[1] * (omega * np.sin(theta))\n        v_rotated[1] -= v_rotated[0] * (omega * np.sin(theta))\n        return v_rotated\n\n    v0 = np.array([0, v0])\n    v = velocity(v0, omega, theta)\n    v_norm = np.linalg.norm(v)\n    v_angle = angle(v0, v)\n    w_vector = np.array([w, 0])\n\n    def time_to_hit_wall(v, t):\n        p = v0 + v * t\n        d = abs(np.cross(v, p - w_vector)) / np.linalg.norm(v)\n        return d\n\n    t = 0\n    while time_to_hit_wall(v, t) >= 0:\n        t += 10 ** -5\n\n    t_hit = time_to_hit_wall(v, t)\n\n    def dist(p1, p2):\n        return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    min_dist = float('inf')\n    min_corner = None\n    for i in range(n):\n        p = vertices[i]\n        q = vertices[(i + 1) % n]\n        d = dist(p, q)\n        if d < min_dist:\n            p_proj = p[0] + (p[1] - w_vector[1]) / (w_vector[0] - p[0]) * (w_vector[0] - p[0])\n            if p_proj > w:\n                min_dist = d\n                min_corner = i\n\n    return f\"{min_corner + 1} {t_hit:.6f}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    n, omega, w, v0, theta, w_ = map(float, lines.pop(0).split())\n    # Convert degrees to radians\n    theta = theta * np.pi / 180\n    # Compute the initial angle of the cookie\n    psi = np.arctan2(y_i[0] - y, x - x_i[0]) - theta\n    # Compute the time of flight for the cookie\n    t = (np.sqrt(x_i[0]**2 + y_i[0]**2) / (v0 * np.sqrt(omega**2 + np.cos(psi)**2)) + np.sqrt(w_**2 - 2 * w_ * np.cos(psi) + np.cos(psi)**2))\n    # Compute the hit time for each corner\n    hit_times = []\n    for i in range(n):\n        # Compute the angle of the cookie at each corner\n        phi = np.arctan2(y_i[i] - y, x - x_i[i]) - theta\n        # Compute the time it takes for the cookie to reach the wall from the corner\n        t_i = np.sqrt((x - x_i[i])**2 + (y - y_i[i])**2) / v0\n        # Compute the time it takes for the cookie to hit the wall\n        t_wall = (np.sqrt(w_**2 - 2 * w_ * np.cos(phi) + np.cos(phi)**2) + np.sqrt(x_i[i]**2 + y_i[i]**2)) / np.sqrt(v0**2 + w_**2 - 2 * v0 * w_ * np.cos(psi + phi))\n        # Compute the hit time for the corner\n        hit_time = t_i + t_wall\n        hit_times.append(hit_time)\n    # Find the corner that hits the wall first\n    i = hit_times.index(min(hit_times)) + 1\n    # Compute the time it takes for the corner to hit the wall\n    t_i = np.sqrt((x - x_i[i-1])**2 + (y - y_i[i-1])**2) / v0\n    t_wall = (np.sqrt(w_**2 - 2 * w_ * np.cos(phi) + np.cos(phi)**2) + np.sqrt(x_i[i-1]**2 + y_i[i-1]**2)) / np.sqrt(v0**2 + w_**2 - 2 * v0 * w_ * np.cos(psi + phi))\n    t = t_i + t_wall\n    return f'{i} {t:.6f}'"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, omega, v_0, theta, w = map(float, input_data.pop(0).split())\n    x_0, y_0 = 0, 0\n    for i in range(n):\n        x, y = map(float, input_data.pop(0).split())\n        x_0 += x\n        y_0 += y\n    x_0 /= n\n    y_0 /= n\n    theta_rad = np.deg2rad(theta)\n    w = np.deg2rad(w)\n    R = np.sqrt(x_0 ** 2 + y_0 ** 2)\n    x_w = w * np.cos(theta_rad)\n    y_w = w * np.sin(theta_rad)\n    t_max = np.inf\n    for i in range(n):\n        x, y = map(float, input_data.pop(0).split())\n        dx = x - x_0\n        dy = y - y_0\n        r = np.sqrt(dx ** 2 + dy ** 2)\n        v_i = v_0 * np.sqrt(1 - omega ** 2)\n        a_i = v_i ** 2 / r\n        a_r = a_i * (dx * dy) / (dx ** 2 + dy ** 2)\n        t_i = 2 * np.sqrt(r ** 2 / (g * a_r))\n        if t_i < t_max:\n            t_max = t_i\n            hit_corner = i + 1\n            x_hit = dx + x_0\n            y_hit = dy + y_0\n    T_hit = t_max + np.sqrt(x_hit ** 2 + y_hit ** 2) / v_i\n    return f\"{hit_corner} {T_hit:.3f}\"\n"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, omega, w, v0, theta, wall = map(float, input_data[0].split())\n    vertices = [tuple(map(float, line.split())) for line in input_data[1:]]\n\n    # Calculate the time it takes for the cookie to rotate\n    time_to_rotate = 2 * np.pi / (n * omega)\n\n    # Calculate the time it takes for the cookie to reach the wall\n    time_to_reach_wall = np.sqrt((wall - vertices[0][0]) ** 2 + (vertices[0][1]) ** 2) / v0\n\n    # Calculate the time it takes for the first corner to hit the wall\n    time_to_hit_wall = time_to_rotate + time_to_reach_wall\n\n    # Calculate the time it takes for the other corners to hit the wall\n    for i in range(1, n):\n        time_to_reach_wall = np.sqrt((wall - vertices[i][0]) ** 2 + (vertices[i][1]) ** 2) / v0\n        time_to_hit_wall += time_to_reach_wall\n\n    # Calculate the time it takes for the cookie to rotate through 360 degrees\n    time_to_rotate_full = 2 * np.pi / omega\n\n    # Calculate the index of the corner that hits the wall first\n    corner_index = np.argmin([abs(time_to_hit_wall - i * time_to_rotate_full) for i in range(1, n + 1)]) + 1\n\n    # Calculate the time it takes for the corner to hit the wall\n    time_to_hit_wall_corner = time_to_hit_wall - (corner_index - 1) * time_to_rotate_full\n\n    return f\"{corner_index} {time_to_hit_wall_corner:.6f}\""
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    trenches = []\n    for i in range(1, N+1):\n        trenches.append(list(map(int, stdin.splitlines()[i].split())))\n    \n    def count_ways(start: int, end: int, seen: set) -> int:\n        if (start, end) in seen:\n            return 0\n        seen.add((start, end))\n        if start == end:\n            return 1\n        ways = 0\n        for i in range(N):\n            if trenches[i][0] == end and trenches[i][1] <= start:\n                ways += count_ways(start, trenches[i][3], seen)\n        return ways\n    \n    ways = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            ways += count_ways(min(trenches[i][1], trenches[i][3], trenches[j][1], trenches[j][3]), max(trenches[i][1], trenches[i][3], trenches[j][1], trenches[j][3]), set())\n    return ways // 2"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n = int(input_lines[0])\n    trenches = [list(map(int, line.split())) for line in input_lines[1:]]\n\n    def count_guard_placements(trenches):\n        def is_guard_visible(guard1, guard2):\n            for trench in trenches:\n                if guard1 in trench and guard2 in trench:\n                    return False\n            return True\n\n        def count_visible_pairs(guards):\n            count = 0\n            for i in range(len(guards)):\n                for j in range(i+1, len(guards)):\n                    count += is_guard_visible(guards[i], guards[j])\n            return count\n\n        def backtrack(guards, next_guard_x, next_guard_y):\n            if len(guards) == 2:\n                return count_visible_pairs(guards)\n\n            count = 0\n            for x in range(next_guard_x-1, next_guard_x+2):\n                for y in range(next_guard_y-1, next_guard_y+2):\n                    if (x, y) != guards[-1]:\n                        count += backtrack(guards + [(x, y)], x, y)\n            return count\n\n        return backtrack([(0, 0), (0, 1)], 0, 0) // 2  # divide by 2 because we are counting pairs of guards\n\n    return str(count_guard_placements(trenches))\n\ninput_data = \"\"\"6\n0 0 1 0\n0 0 0 1\n1 0 1 1\n0 1 1 1\n0 0 1 1\n1 0 0 1\"\"\"\n\noutput_data = \"\"\"8\"\"\"\n\nprint(solution(input_data)) # 8\n\ninput_data = \"\"\"4\n5 1 7 1\n1 1 5 1\n4 0 4 4\n7 0 3 4\"\"\"\n\noutput_data = \"\"\"1\"\"\"\n\nprint(solution(input_data)) # 1 "
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    trenches = [[int(coord) for coord in line.split()] for line in input_data[1:]]\n\n    def count_guards(trenches):\n        def line_segment_intersection(line1, line2):\n            def is_on_line(point, line):\n                x1, y1, x2, y2 = line\n                return x1 <= point[0] <= x2 and y1 <= point[1] <= y2\n\n            def distance(p1, p2):\n                x1, y1 = p1\n                x2, y2 = p2\n                return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n            x1, y1, x2, y2 = line1\n            x3, y3, x4, y4 = line2\n\n            d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n            if d == 0:\n                return None\n\n            t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / d\n            u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / d\n\n            if 0 <= t <= 1 and 0 <= u <= 1:\n                point = ((x1 + t * (x2 - x1), y1 + t * (y2 - y1)))\n                if is_on_line(point, line2) and distance(point, (x3, y3)) <= distance(point, (x4, y4)):\n                    return point\n\n            return None\n\n        def count_visible_trenches(guard_pos):\n            count = 0\n            for i in range(N):\n                for j in range(i + 1, N):\n                    if line_segment_intersection([guard_pos[0], guard_pos[1], guard_pos[0], guard_pos[1] + 1], [trenches[i][0], trenches[i][1], trenches[i][2], trenches[i][3]]):\n                        count += 1\n                    elif line_segment_intersection([guard_pos[0], guard_pos[1], guard_pos[0], guard_pos[1] + 1], [trenches[j][0], trenches[j][1], trenches[j][2], trenches[j][3]]):\n                        count += 1\n            return count\n\n        total_count = 0\n        for i in range(1, 1001):\n            for j in range(1, 1001):\n                for k in range(1, 1001):\n                    if count_visible_trenches([i, j]) == count_visible_trenches([k, j]) == count_visible_trenches([k, i]) == 3:\n                        total_count += 1\n\n        return total_count\n\n    return count_guards(trenches)\n\n\nprint(solution(input())) "
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_guards(trenches):\n        def count_guard_placements(start, end):\n            if start == end:\n                return 1\n            if trenches[start] == trenches[end]:\n                return 0\n            return count_guard_placements(start + 1, end) + count_guard_placements(start + 1, end - 1)\n\n        return count_guard_placements(0, len(trenches) - 1)\n\n    def parse_trenches(input_str: str):\n        trenches = []\n        lines = input_str.split('\\n')\n        for line in lines:\n            x1, y1, x2, y2 = map(int, line.split())\n            trenches.append((x1, y1, x2, y2))\n        return trenches\n\n    n = int(stdin.split('\\n')[0])\n    trenches = parse_trenches(stdin)\n    return str(count_guards(trenches))\n"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(guard1, guard2, trenches):\n        x1, y1, x2, y2 = guard1\n        x3, y3, x4, y4 = guard2\n        for trench in trenches:\n            tx1, ty1, tx2, ty2 = trench\n            if ((x1, y1) == (x2, y2) or (x3, y3) == (x4, y4)):\n                continue\n            if line_intersection((x1, y1), (x2, y2), (tx1, ty1), (tx2, ty2)):\n                return False\n        return True\n\n    def line_intersection(p1, p2, p3, p4):\n        (x1, y1), (x2, y2) = sorted([p1, p2])\n        (x3, y3), (x4, y4) = sorted([p3, p4])\n        if x1 != x2 and x3 != x4:\n            return False\n        if x1 == x2:\n            return y1 <= y3 <= y2 or y4 <= y3 <= y1\n        if x3 == x4:\n            return y3 <= y1 <= y4 or y1 <= y2 <= y3\n        return False\n\n    def count_guard_placements(trenches):\n        count = 0\n        for i in range(len(trenches)):\n            for j in range(i + 1, len(trenches)):\n                if is_visible((0, 0), (1, 1), (trenches[i], trenches[j])):\n                    count += 1\n        return count\n\n    def parse_input(stdin: str):\n        n = int(stdin.splitlines()[0])\n        trenches = []\n        for i in range(1, n + 1):\n            x1, y1, x2, y2 = map(int, stdin.splitlines()[i].split())\n            trenches.append((x1, y1, x2, y2))\n        return n, trenches\n\n    n, trenches = parse_input(stdin)\n    count = count_guard_placements(trenches)\n    return str(count)\n\ninput1 = \"\"\"\n6\n0 0 1 0\n0 0 0 1\n1 0 1 1\n0 1 1 1\n0 0 1 1\n1 0 0 1\n\"\"\"\n\ninput2 = \"\"\"\n4\n5 1 7 1\n1 1 5 1\n4 0 4 4\n7 0 3 4\n\"\"\"\n\noutput1 = solution(input1)\noutput2 = solution(input2)\n\nprint(\"Example 1:\", output1)\nprint(\"Example 2:\", output2)"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(guard1, guard2, trenches):\n        for trench in trenches:\n            x1, y1, x2, y2 = trench\n            if x1 == x2:\n                if y1 <= guard1 <= y2 or y1 >= guard1 >= y2:\n                    if y1 < y2:\n                        if guard2 < y1 or guard2 > y2:\n                            return True\n                    else:\n                        if guard2 > y1 or guard2 < y2:\n                            return True\n            else:\n                if x1 <= guard1 <= x2 or x1 >= guard1 >= x2:\n                    if x1 < x2:\n                        if guard2 < x1 or guard2 > x2:\n                            return True\n                    else:\n                        if guard2 > x1 or guard2 < x2:\n                            return True\n        return False\n\n    N = int(stdin.split()[0])\n    trenches = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    count = 0\n\n    for i in range(N-1):\n        for j in range(i+1, N):\n            if is_visible(trenches[i][1], trenches[j][1], trenches):\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def line_intersection(a, b, c, d):\n        def is_between(p, a, b):\n            return p >= min(a, b) and p <= max(a, b)\n        return is_between(c, a, b) != is_between(d, a, b)\n\n    def count_guards(N, trenches):\n        total = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                for k in range(N):\n                    if (k != i and k != j):\n                        guard1 = trenches[i]\n                        guard2 = trenches[j]\n                        guard3 = trenches[k]\n                        if line_intersection(guard1[0], guard1[2], guard2[0], guard2[2]) and line_intersection(guard1[1], guard1[3], guard2[1], guard2[3]) and line_intersection(guard1[0], guard1[2], guard3[0], guard3[2]) and line_intersection(guard1[1], guard1[3], guard3[1], guard3[3]) and line_intersection(guard2[0], guard2[2], guard3[0], guard3[2]) and line_intersection(guard2[1], guard2[3], guard3[1], guard3[3]):\n                            total += 1\n        return total\n\n    N = int(stdin.splitlines()[0])\n    trenches = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = count_guards(N, trenches)\n    return str(result)\n"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(x1, y1, x2, y2, x, y):\n        return (x2 - x1) * (y - y1) - (y2 - y1) * (x - x1)\n\n    def count_visible_pairs(x1, y1, x2, y2):\n        count = 0\n        for x, y in points:\n            if is_visible(x1, y1, x2, y2, x, y) > 0:\n                count += 1\n        return count\n\n    def count_guard_placements(x1, y1, x2, y2):\n        count = 0\n        for x, y in points:\n            if x == x1 and y == y1:\n                count += count_visible_pairs(x2, y2, x, y)\n            if x == x2 and y == y2:\n                count += count_visible_pairs(x1, y1, x, y)\n        return count\n\n    n = int(stdin[0])\n    points = [tuple(map(int, line.split())) for line in stdin[1:n + 1]]\n    x1, y1 = points[0][:2]\n    x2, y2 = points[0][2:4]\n    result = count_guard_placements(x1, y1, x2, y2)\n    return str(result)\n"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(guard1, guard2, trenches):\n        for trench in trenches:\n            if (guard1[0] == trench[0] and guard1[1] == trench[1] and\n                guard2[0] == trench[2] and guard2[1] == trench[3]) or (\n                guard1[0] == trench[2] and guard1[1] == trench[3] and\n                guard2[0] == trench[0] and guard2[1] == trench[1]) or (\n                guard1[2] == trench[0] and guard1[3] == trench[1] and\n                guard2[2] == trench[2] and guard2[3] == trench[3]) or (\n                guard1[2] == trench[2] and guard1[3] == trench[3] and\n                guard2[2] == trench[0] and guard2[3] == trench[1]):\n                return True\n        return False\n\n    N, *data = stdin.splitlines()\n    N = int(N)\n    trenches = [tuple(map(int, line.split())) for line in data]\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                guard1 = trenches[i]\n                guard2 = trenches[j]\n                guard3 = trenches[k]\n                if is_visible(guard1, guard2, trenches) and is_visible(guard1, guard3, trenches) and is_visible(guard2, guard3, trenches):\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(start: int, end: int, trenches: list) -> int:\n        if start == end:\n            return 1\n        total = 0\n        for i in range(start, end):\n            for j in range(i + 1, end + 1):\n                x1, y1, x2, y2 = trenches[i]\n                x3, y3, x4, y4 = trenches[j]\n                if x1 == x2 == x3 == x4 or y1 == y2 == y3 == y4:\n                    total += count_ways(start, i, trenches) * count_ways(j, end, trenches)\n        return total\n\n    N = int(stdin.splitlines()[0])\n    trenches = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    return count_ways(0, N - 1, trenches)"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"impossible\"\n    elif n % 4 == 0:\n        m = k = n // 2\n        return f\"{m} {k}\"\n    else:\n        return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    sqrt_n = int(n**0.5)\n\n    # Check if n is a perfect square\n    if sqrt_n**2 == n:\n        print(sqrt_n, sqrt_n)\n    else:\n        print(\"impossible\")"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n\n    for i in range(1, n+1):\n        if i*(i+1) <= 2*n and i*(i-1) >= 2*n:\n            m = i\n            k = n - m**2 + m*m\n            if k >= m and k > 0 and m > 0:\n                return f\"{m} {k}\"\n    \n    return \"impossible\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n == 0:\n        return \"impossible\"\n    m = int(n**0.5)\n    k = n - m**2\n    if k < 0:\n        return \"impossible\"\n    return f\"{m} {k}\"\n\ndef"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    if n <= 0:\n        return \"impossible\"\n    for m in range(1, n+1):\n        k = (n - m**2)**0.5\n        if k.is_integer():\n            return f\"{m} {int(k)}\"\n    return \"impossible\" "
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    \n    # Check if n is a perfect square\n    if int(n**0.5)**2 == n:\n        return \"impossible\"\n    \n    # Find m\n    m = int(n**0.5)\n    \n    # Check if m is a perfect square\n    if m**2 == n:\n        return f\"{m} {m}\"\n    \n    # Find k\n    k = int((m**2 - n)**0.5)\n    \n    return f\"{m} {k}\"\n"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    \n    for m in range(int(n ** 0.5) + 1):\n        k = (n - m ** 2) ** 0.5\n        if k.is_integer():\n            return f\"{m} {int(k)}\"\n    \n    return \"impossible\""
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1, int(n**0.5)+1):\n        if n-i**2 > 0 and n-i**2 % (i+1) == 0:\n            return str(i) + \" \" + str(n-i**2//(i+1))\n    return \"impossible\"\n\n\ninput_str = \"10\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    m = int(n**0.5)\n    k = m - n % m\n    if k < 0:\n        return \"impossible\"\n    else:\n        return f\"{m} {k}\" "
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for i in range(1, int(n**0.5) + 1):\n        if n - i**2 > 0:\n            m, k = i, int(n - i**2)\n            return f\"{m} {k}\"\n    return \"impossible\"\n\ninput_data = \"7\"\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n\n    min_val = min(arr)\n    max_val = max(arr)\n    length = len(arr)\n\n    price = (min_val + max_val) * length\n\n    # Calculate the sum of the prices for all subsequences\n    sum_prices = 0\n    for i in range(length - 1):\n        for j in range(i + 1, length):\n            subarray = arr[i:j + 1]\n            subarray_min = min(subarray)\n            subarray_max = max(subarray)\n            subarray_length = len(subarray)\n            subarray_price = (subarray_min + subarray_max) * subarray_length\n            sum_prices += subarray_price\n\n    # Output the last 9 digits of the sum of prices\n    return str(sum_prices % (10 ** 9)).lstrip('0')[:9]"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    arr = [int(x) for x in stdin.split('\\n')[1:]]\n    min_val, max_val, length = min(arr), max(arr), len(arr)\n    cost = min_val * max_val * length\n    total_sum = 0\n    for i in range(len(arr)):\n        subseq_sum = 0\n        for j in range(i, len(arr)):\n            subseq_sum += arr[j]\n        total_sum += subseq_sum\n    required_sum = total_sum // cost * 10**9\n    return str(required_sum % (10**9))\n"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    array = [int(x) for x in input_data[1:]]\n    \n    min_num, max_num = min(array), max(array)\n    array_len = len(array)\n    array_sum = sum(array)\n    \n    prices = []\n    for i in range(1, N + 1):\n        prices.append(array_sum * min_num * max_num // (i * array_len))\n    \n    result = sum(prices)\n    result = result % (10 ** 9)\n    \n    return str(result)[:10]\n"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    array = [int(x) for x in stdin.split('\\n')[1:]]\n    max_val = max(array)\n    min_val = min(array)\n    array_len = len(array)\n    sum_of_prices = 0\n    \n    for i in range(array_len):\n        for j in range(i, array_len):\n            sum_of_prices += (j - i + 1) * min_val * max_val\n    \n    return str(sum_of_prices % (10**9))[-9:]"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0].split()[0])\n    array = [int(x) for x in stdin[1:N+1]]\n    \n    def count_kunas(array):\n        min_ = min(array)\n        max_ = max(array)\n        length = len(array)\n        return min_ * max_ * length\n    \n    total_price = 0\n    for i in range(N):\n        for j in range(i+1, N+1):\n            subarray = array[i:j]\n            price = count_kunas(subarray)\n            total_price += price\n    \n    return str(total_price % (10**9))[-9:]\n"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    array = [int(x) for x in stdin.split(\"\\n\")[1:]]\n    \n    min_value = min(array)\n    max_value = max(array)\n    array_length = len(array)\n    \n    total_price = sum(max_value - min_value + 1) * (array_length - 1)\n    \n    return str(total_price % 10**9)"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, *arr = map(int, stdin.split())\n    min_num, max_num = min(arr), max(arr)\n    array_length = len(arr)\n    subsequence_sum = 0\n    for i in range(min_num, max_num+1):\n        subsequence_sum += array_length * i\n    return str(subsequence_sum % 10**9)\n\ninput1 = \"2\\n1\\n3\"\ninput2 = \"4\\n2\\n4\\n1\\n4\"\n\nprint(solution(input1))  # Output: 16\nprint(solution(input2))  # Output: 109"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    arr = [int(input()) for _ in range(n)]\n    min_num = min(arr)\n    max_num = max(arr)\n    array_length = len(arr)\n\n    def calculate_price(start_index: int, end_index: int) -> int:\n        return (max_num - min_num) * (end_index - start_index + 1) * (array_length - end_index)\n\n    total_sum = sum(calculate_price(i, j) for i in range(array_length) for j in range(i, array_length))\n    last_9_digits = total_sum % (10**9)\n\n    return str(last_9_digits)\n"
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1:]))\n    min_num = min(array)\n    max_num = max(array)\n    length = len(array)\n    cost = min_num * max_num * length\n    result = 0\n\n    for i in range(length):\n        for j in range(i, length):\n            subsequence = array[i:j+1]\n            subsequence_min = min(subsequence)\n            subsequence_max = max(subsequence)\n            subsequence_length = len(subsequence)\n            subsequence_cost = subsequence_min * subsequence_max * subsequence_length\n            result += subsequence_cost\n\n    result_str = str(result)\n    last_9_digits = result_str[-9:]\n\n    return last_9_digits\n\ninput_data = \"\"\"\n2\n1\n3\n\"\"\"\n\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    array = list(map(int, stdin.split(\"\\n\")[1:]))\n    min_num, max_num = min(array), max(array)\n    cost = min_num * max_num * N\n    sum_prices = 0\n    for i in range(len(array)):\n        for j in range(i+1, len(array)):\n            subarray = array[i:j+1]\n            subarray.sort()\n            min_sub, max_sub = min(subarray), max(subarray)\n            subarray_cost = min_sub * max_sub * (j-i+1)\n            sum_prices += subarray_cost\n    return str(sum_prices % (10**9))[-9:]\n\n\ndef"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_total_cards(cards: list) -> int:\n        return sum(cards)\n\n    def get_total_purchases(purchases: list) -> int:\n        total_purchases = 0\n        for purchase in purchases:\n            if purchase[0] != purchase[1]:\n                total_purchases += 1\n        return total_purchases\n\n    def get_winner_cards(purchases: list, total_cards: int) -> list:\n        winner_cards = [0] * total_cards\n        for purchase in purchases:\n            if purchase[0] == purchase[1]:\n                continue\n            elif purchase[0] < purchase[1]:\n                winner_cards[purchase[0] - 1] += 1\n                winner_cards[purchase[1] - 1] += 1\n            else:\n                winner_cards[purchase[1] - 1] += 1\n        return winner_cards\n\n    def get_purchase_cards(purchases: list, winner_cards: list) -> list:\n        purchase_cards = []\n        for purchase in purchases:\n            if purchase[0] == purchase[1]:\n                continue\n            elif purchase[0] < purchase[1]:\n                purchase_cards.append([purchase[0], purchase[1], winner_cards[purchase[0] - 1]])\n                purchase_cards.append([purchase[1], purchase[0], winner_cards[purchase[1] - 1]])\n            else:\n                purchase_cards.append([purchase[1], purchase[0], winner_cards[purchase[1] - 1]])\n                purchase_cards.append([purchase[0], purchase[1], winner_cards[purchase[0] - 1]])\n        return purchase_cards\n\n    def main(stdin: str) -> str:\n        total_cards, total_purchases = map(int, stdin.split()[:2])\n        children_cards = list(map(int, stdin.split()[2:]))\n\n        purchases = []\n        for _ in range(total_purchases):\n            purchases.append(list(map(int, input().split())))\n\n        total_purchases = get_total_purchases(purchases)\n        total_cards = get_total_cards(children_cards)\n        winner_cards = get_winner_cards(purchases, total_cards)\n        purchase_cards = get_purchase_cards(purchases, winner_cards)\n\n        result = [str(total_purchases)]\n        for purchase_card in purchase_cards:\n            result.append(f\"{purchase_card[0]} {purchase_card[1]} {purchase_card[2]}\")\n        return \"\\n\".join(result)\n\n    return main(stdin)"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    counts = list(map(int, input().split()))\n    total_cards = sum(counts)\n    \n    purchases = []\n    for _ in range(M):\n        a, b = map(int, input().split())\n        purchases.append((a, b))\n    \n    purchases.sort(key=lambda x: (x[0], x[1]))\n    purchases.sort(key=lambda x: (x[0], -x[1]))\n    \n    hands = [[] for _ in range(N+1)]\n    hands[0] = counts\n    total_purchases = 0\n    \n    for i, (a, b) in enumerate(purchases):\n        if a == b:\n            if hands[a-1] or hands[b-1]:\n                if hands[a-1]:\n                    c = hands[a-1].pop(0)\n                else:\n                    c = hands[b-1].pop(0)\n                \n                hands[a-1].append(c)\n                hands[b-1].append(c)\n                total_purchases += 1\n            else:\n                hands[a-1] = [1, 1]\n                hands[b-1] = [1, 1]\n                total_purchases += 1\n        else:\n            if hands[a-1]:\n                c = hands[a-1].pop(0)\n            else:\n                c = hands[b-1].pop(0)\n            \n            hands[a-1].append(c)\n            hands[b-1].append(c)\n            total_purchases += 1\n    \n    for i in range(1, N+1):\n        if hands[i]:\n            c = hands[i].pop(0)\n            total_cards -= c\n    \n    if total_cards == 0:\n        result = f\"{total_purchases}\\n\"\n        for i in range(1, N+1):\n            for j in range(len(hands[i])):\n                result += f\"{i} {i} {hands[i][j]}\\n\"\n        return result\n    else:\n        return \"IMPOSSIBLE\"\n\ndef"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.splitlines()[0].split())\n    children_cards = list(map(int, stdin.splitlines()[1].split()))\n    purchases = []\n\n    for _ in range(M):\n        purchases.append(list(map(int, stdin.splitlines()[2 + _].split())))\n\n    total_purchases = 0\n    for purchase in purchases:\n        if purchase[0] != purchase[1]:\n            total_purchases += 1\n\n    result = [str(total_purchases)]\n    children_cards_left = [0] * N\n    for i in range(len(children_cards)):\n        children_cards_left[i] = children_cards[i]\n\n    purchases_done = 0\n    while purchases_done < total_purchases:\n        for purchase in purchases:\n            if purchase[0] != purchase[1]:\n                children_cards_left[purchase[0] - 1] += 1\n                children_cards_left[purchase[1] - 1] += 1\n                purchases_done += 1\n                if purchases_done == total_purchases:\n                    break\n                result.append(\" \".join(map(str, purchase + [1])))\n\n                for i in range(len(children_cards_left)):\n                    if children_cards_left[i] == 0:\n                        children_cards_left[i] = 1\n\n                for purchase in purchases:\n                    if purchase[0] != purchase[1]:\n                        if children_cards_left[purchase[0] - 1] == 1 and children_cards_left[purchase[1] - 1] == 1:\n                            result.append(\" \".join(map(str, purchase + [2])))\n                            children_cards_left[purchase[0] - 1] -= 1\n                            children_cards_left[purchase[1] - 1] -= 1\n                            purchases_done += 1\n                            break\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n_m = input_list[0].split()\n    n = int(n_m[0])\n    m = int(n_m[1])\n    card_counts = list(map(int, input_list[1].split()))\n    purchases = []\n    for i in range(2, 2+m):\n        a, b = map(int, input_list[i].split())\n        purchases.append((a, b))\n\n    total_purchases = 0\n    for i in range(m):\n        total_purchases += 1\n    purchase_count = 0\n    for i in range(m):\n        child1, child2 = purchases[i]\n        if child1 != child2:\n            card_counts[child1-1] += 1\n            card_counts[child2-1] += 1\n        else:\n            card_counts[child1-1] += 2\n    print(total_purchases)\n    for i in range(m):\n        child1, child2 = purchases[i]\n        print(f\"{child1} {child2} {card_counts[child1-1] % 3}\")"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N, M = map(int, input_lines[0].split())\n    children_cards = list(map(int, input_lines[1].split()))\n    total_cards = sum(children_cards)\n    purchases = []\n\n    for i in range(2, len(input_lines)):\n        child1, child2 = map(int, input_lines[i].split())\n        purchases.append((child1, child2))\n\n    for purchase in purchases:\n        child1, child2 = purchase\n        if child1 != child2:\n            children_cards[child1 - 1] += 1\n            children_cards[child2 - 1] += 1\n\n    return str(len(purchases)) + \"\\n\" + \"\\n\".join(\n        f\"{purchase[0]} {purchase[1]} 1\" for purchase in purchases\n    )"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    card_counts = list(map(int, input_list[1].split()))\n    purchases = []\n\n    for i in range(2, len(input_list)):\n        purchases.append(tuple(map(int, input_list[i].split())))\n\n    # calculate total number of purchases\n    total_purchases = 0\n    for purchase in purchases:\n        total_purchases += 1\n\n    # calculate each child's card count\n    child_card_counts = [0] * N\n    for i in range(len(card_counts)):\n        child_card_counts[i] = card_counts[i]\n\n    # calculate purchases and races\n    for purchase in purchases:\n        child1, child2, race_winner = purchase\n        if child1 == race_winner:\n            child_card_counts[child1 - 1] += 1\n        else:\n            child_card_counts[child1 - 1] += 1\n            child_card_counts[child2 - 1] += 1\n\n    # output results\n    result = f\"{total_purchases}\\n\"\n    for i in range(len(purchases)):\n        child1, child2, race_winner = purchases[i]\n        result += f\"{child1} {child2} {race_winner}\\n\"\n\n    return result\n\ninput_list = \"\"\"2 3\n5 1\n1 2\n1 2\n1 2\n\"\"\"\noutput_list = \"\"\"3\n1 2 1\n1 2 2\n1 2 2\n\"\"\"\n\ninput_list2 = \"\"\"4 3\n5 3 1 1\n1 3\n2 3\n4 1\n\"\"\"\noutput_list2 = \"\"\"5\n1 3 1\n2 3 2\n4 1 0\n2 4 1\n3 1 0\n\"\"\"\n\ninput_list3 = \"\"\"6 5\n3 2 1 1 1 1\n1 5\n2 5\n3 4\n4 5\n5 6\n6 2\n\"\"\"\noutput_list3 = \"\"\"10\n1 6 0\n1 6 1\n1 6 1\n2 6 2\n2 6 2\n3 6 2\n3 6 2\n4 6 0\n5 6 1\n6 6 0\n\"\"\"\n\nprint(solution(input_list))\nprint(solution(input_list2))\nprint(solution(input_list3)) "
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, M = map(int, stdin.splitlines()[0].split())\n    cards_counts = list(map(int, stdin.splitlines()[1].split()))\n    purchases = [list(map(int, line.split())) for line in stdin.splitlines()[2:]]\n\n    # Determine purchases and races\n    purchases_dict = {}\n    for purchase in purchases:\n        if purchase[0] not in purchases_dict:\n            purchases_dict[purchase[0]] = []\n        if purchase[1] not in purchases_dict:\n            purchases_dict[purchase[1]] = []\n        purchases_dict[purchase[0]].append(purchase[1])\n        purchases_dict[purchase[1]].append(purchase[0])\n\n    # Determine the number of purchases and the participants in each purchase\n    total_purchases = 0\n    for children in purchases_dict.values():\n        if len(children) % 2 != 0:\n            total_purchases += 1\n\n    # Determine the cards counts after all purchases\n    new_cards_counts = [0] * N\n    for i in range(N):\n        new_cards_counts[i] = cards_counts[i]\n        for child, purchase in purchases_dict.items():\n            if child == i:\n                for partner in purchase:\n                    new_cards_counts[i] += 1\n                    new_cards_counts[partner - 1] += 1\n\n    # Output the results\n    print(total_purchases)\n    for i in range(N):\n        for j in range(M):\n            print(i + 1, j + 1, 0)\n"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n\n    N, M = map(int, input_data[0].split())\n    children_cards = list(map(int, input_data[1].split()))\n\n    purchases = [tuple(map(int, input_data[i+2].split())) for i in range(M)]\n\n    total_purchases = 0\n    for purchase in purchases:\n        if purchase[0] != purchase[1]:\n            total_purchases += 1\n            children_cards[purchase[0]-1] += 1\n            children_cards[purchase[1]-1] += 1\n\n    return str(total_purchases) + '\\n' + '\\n'.join(str(purchase[0]) + ' ' + str(purchase[1]) + ' ' + str(children_cards[purchase[0]-1]-children_cards[purchase[1]-1]) for purchase in purchases)\n"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def race(a: int, b: int) -> int:\n        if a > b:\n            return 1\n        elif a < b:\n            return 2\n        else:\n            return 0\n\n    input_list = stdin.splitlines()\n    N, M = map(int, input_list[0].split())\n    card_counts = list(map(int, input_list[1].split()))\n    total_purchases = 0\n\n    for i in range(2, len(input_list)):\n        a, b = map(int, input_list[i].split())\n        total_purchases += 1\n        if race(card_counts[a - 1], card_counts[b - 1]) == 0:\n            card_counts[a - 1] += 1\n            card_counts[b - 1] += 1\n        else:\n            card_counts[a - 1] += race(card_counts[a - 1], card_counts[b - 1])\n\n    for i in range(2, len(input_list)):\n        a, b = map(int, input_list[i].split())\n        print(f\"{a} {b} {card_counts[a - 1]}\")\n\n    return str(total_purchases) + \"\\n\""
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    N, M = input_data.pop(0), input_data.pop(0)\n    card_counts = list(input_data)\n    purchases = []\n\n    for _ in range(M):\n        purchases.append(input_data.pop(0))\n\n    purchases.sort()\n    purchases = [purchases[i:i+2] for i in range(0, len(purchases), 2)]\n\n    def find_winning_child(purchases, card_counts):\n        for i, purchase in enumerate(purchases):\n            if card_counts[purchase[0]-1] < card_counts[purchase[1]-1]:\n                card_counts[purchase[0]-1] += 1\n                purchases[i+1:] = [(p, c-1) for p, c in purchases[i+1:] if p != purchase[0]]\n            else:\n                card_counts[purchase[1]-1] += 1\n                purchases[i+1:] = [(p, c-1) for p, c in purchases[i+1:] if p != purchase[1]]\n\n        return purchases, card_counts\n\n    def print_purchases(purchases):\n        for purchase in purchases:\n            print(f\"{purchase[0]} {purchase[1]} 0\")\n\n    while purchases:\n        purchases, card_counts = find_winning_child(purchases, card_counts)\n        print_purchases(purchases)\n\n    return str(len(purchases))\n"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_crying(kids, toys, toy_changes):\n        crying = False\n        for i in range(1, n + 1):\n            if not kids[i]:\n                crying = True\n                break\n        if crying:\n            return True\n        for i in range(1, n + 1):\n            if not toys[kids[i]]:\n                crying = True\n                break\n        if crying:\n            return True\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                if kids[i] == kids[j] and toys[kids[i]] == toys[kids[j]]:\n                    return True\n        for i in range(1, n + 1):\n            for j in range(1, m + 1):\n                for k in range(1, n + 1):\n                    if kids[i] != kids[k] and toys[kids[i]] == j and toys[kids[k]] == j:\n                        return True\n        return False\n\n    def is_envying(kids, toys, toy_changes, current_toy):\n        for i in range(1, n + 1):\n            if kids[i] != kids[kid] and toys[kids[i]] == current_toy and toys[kid] != current_toy and (toy_changes[kids[i]] < toy_changes[kid] or toy_changes[kids[i]] == toy_changes[kid] and kids[i] < kid):\n                return True\n        return False\n\n    def assign_toys(kids, toys, toy_changes):\n        result = [-1] * n\n        current_toy = 1\n        for kid in range(1, n + 1):\n            while not toys[kid]:\n                if current_toy > m:\n                    return False\n                toys[kid] = current_toy\n                result[kids[kid] - 1] = current_toy\n                current_toy += 1\n                if current_toy <= m and is_crying(kids, toys, toy_changes):\n                    return False\n        return result\n\n    n, m = map(int, input().split())\n    d, e = map(int, input().split())\n    toy_changes = {(k, t): s for s, k, t in map(int, stdin.split('\\n')) if t}\n\n    kids = [0] * (n + 1)\n    toys = [0] * (m + 1)\n    for s, k, t in toy_changes.items():\n        kids[k] = s\n        toys[t] = s\n\n    result = assign_toys(kids, toys, toy_changes)\n    if result:\n        return ' '.join(map(str, result))\n    else:\n        return \"impossible\"\n\ninput_data = '''2 3\n6 7\n0 1 1\n0 2 2\n1 1 3\n2 1 2\n2 2 1\n3 2 3\n4 2 1'''\n\nprint(solution(input_data))\n"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def play_time_change(s: int, k: int, t: int) -> bool:\n        if t == 0:\n            return False\n        if s < last_change[k][t]:\n            return False\n        if s == last_change[k][t]:\n            last_change[k][t] = d + 1\n        return True\n\n    def assign_toys(n: int, m: int, d: int, e: int, events: List[Tuple[int, int, int]]) -> List[int]:\n        toys = [[] for _ in range(n)]\n        last_change = [[0] * (m + 1) for _ in range(n)]\n        for s, k, t in events:\n            if play_time_change(s, k, t):\n                toys[k - 1].append(t)\n\n        for i in range(n):\n            if not toys[i]:\n                return [-1] * n\n            elif len(toys[i]) > 1:\n                toys[i].sort(key=lambda x: last_change[i].index(x))\n\n        return toys\n\n    def is_crying(n: int, m: int, d: int, e: int, events: List[Tuple[int, int, int]]) -> bool:\n        def is_envy(k1: int, k2: int, t: int) -> bool:\n            return (\n                k1 < k2\n                and t in toys[k2 - 1]\n                and last_change[k1 - 1][t] < last_change[k2 - 1][t]\n            )\n\n        def is_flexible(k: int, t: int) -> bool:\n            return (\n                k1 < k2\n                and last_change[k1 - 1][t] <= last_change[k2 - 1][t]\n            )\n\n        def is_multitasking(k: int) -> bool:\n            return len(toys[k - 1]) > 1\n\n        def is_uncooperative(k1: int, k2: int, t: int) -> bool:\n            return (\n                k1 < k2\n                and t in toys[k1 - 1]\n                and last_change[k1 - 1][t] < last_change[k2 - 1][t]\n            )\n\n        toys = assign_toys(n, m, d, e, events)\n        if -1 in toys:\n            return False\n\n        for i in range(n):\n            for t in toys[i]:\n                if is_envy(i + 1, i + 2, t) or is_flexible(i + 1, t) or is_multitasking(i + 1) or is_uncooperative(i + 1, i + 2, t):\n                    return True\n\n        return False\n\n    def find_toys(n: int, m: int, d: int, e: int, events: List[Tuple[int, int, int]]) -> List[int]:\n        low, high = 1, m\n        while low <= high:\n            mid = (low + high) // 2\n            if is_crying(n, m, d, e, events, mid):\n                high = mid - 1\n            else:\n                low = mid + 1\n        return [low] * n\n\n    def main():\n        n, m = map(int, stdin.readline().split())\n        d, e = map(int, stdin.readline().split())\n        events = [tuple(map(int, stdin.readline().split())) for _ in range(e)]\n\n        toys = find_toys(n, m, d, e, events)\n        return \" \".join(map(str, toys))\n\n    return main()\n"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d, e = map(int, input().split())\n    events = []\n    for _ in range(e):\n        s, k, t = map(int, input().split())\n        events.append((s, k, t))\n\n    # Sort events by time\n    events.sort(key=lambda x: x[0])\n\n    # Create a list to store the toys for each kid\n    kids_toys = [[] for _ in range(n)]\n\n    # Assign toys based on the events\n    for s, k, t in events:\n        if s < d:\n            if t == 0:\n                kids_toys[k - 1].pop()\n            else:\n                kids_toys[k - 1].append(t - 1)\n\n    # Check if there is an assignment of toys to kids\n    # such that no kid will start crying today\n    kids_toys_set = set(kids_toys)\n    if len(kids_toys_set) == 1:\n        result = [toy + 1 for toy in next(iter(kids_toys_set))]\n        return \" \".join(map(str, result))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data.pop(0).split())\n    d, e = map(int, input_data.pop(0).split())\n    events = [tuple(map(int, line.split())) for line in input_data]\n    events.sort()\n\n    toys_per_kid = [[] for _ in range(n)]\n    for s, k, t in events:\n        if t:\n            toys_per_kid[k - 1].append((s, t - 1))\n\n    def can_play_with(kid1, kid2, toy):\n        if not toys_per_kid[kid1 - 1]:\n            return False\n        if not toys_per_kid[kid2 - 1]:\n            return False\n\n        last_play_time1 = toys_per_kid[kid1 - 1][-1][0]\n        last_play_time2 = toys_per_kid[kid2 - 1][-1][0]\n        last_toy1 = toys_per_kid[kid1 - 1][-1][1]\n        last_toy2 = toys_per_kid[kid2 - 1][-1][1]\n\n        return last_play_time1 > last_play_time2 and last_toy1 < last_toy2 and toy < last_toy1\n\n    def envious_kid(kid, toy):\n        last_play_time = toys_per_kid[kid - 1][-1][0] if toys_per_kid[kid - 1] else 0\n        for s, t in reversed(toys_per_kid[kid - 1]):\n            if s < last_play_time and t > toy:\n                return True\n            last_play_time = s\n        return False\n\n    def is_done(kid, toy):\n        return any(t == toy for s, t in toys_per_kid[kid - 1])\n\n    def can_play_without_crying(kid, toy):\n        for other_kid in range(n):\n            if other_kid == kid:\n                continue\n            for other_toy in range(m):\n                if can_play_with(kid, other_kid, other_toy) and envious_kid(kid, other_toy) and not is_done(kid, other_toy):\n                    return False\n        return True\n\n    assignments = [0] * n\n    for i in range(n):\n        for toy in range(m):\n            if can_play_without_crying(i, toy):\n                assignments[i] = toy + 1\n                break\n        else:\n            return \"impossible\"\n\n    return ' '.join(map(str, assignments))\n\ndef"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def toy_change(kid_id, toy_id, time):\n        if toy_id not in kid_toys:\n            kid_toys[kid_id] = [toy_id]\n        else:\n            for i, t in enumerate(kid_toys[kid_id]):\n                if time < toy_change_times[t]:\n                    kid_toys[kid_id].insert(i, toy_id)\n                    break\n            else:\n                kid_toys[kid_id].append(toy_id)\n        kid_toys_change_times[kid_id] = time\n\n    def find_toy(kid_id):\n        return kid_toys[kid_id][-1]\n\n    n, m, d, e = map(int, stdin.split()[:4])\n    toy_changes = sorted([list(map(int, line.split())) for line in stdin.split('\\n')[4:]], key=lambda x: (x[0], x[1], x[2]))\n\n    kid_toys = {}\n    kid_toys_change_times = {}\n    for s, k, t in toy_changes:\n        toy_change(k, t, s)\n\n    toy_change_times = {}\n    for time, toys in sorted(kid_toys.items()):\n        for toy in toys:\n            toy_change_times[toy] = time\n\n    possible_toys = set(range(1, m + 1))\n    kid_toys_toy = {kid_id: find_toy(kid_id) for kid_id in range(1, n + 1)}\n\n    assigned_toys = [0] * n\n    for kid_id, toy in kid_toys_toy.items():\n        assigned_toys[kid_id - 1] = toy\n\n    for kid_id in range(1, n + 1):\n        if assigned_toys[kid_id - 1] == 0:\n            if not possible_toys:\n                return \"impossible\"\n            assigned_toys[kid_id - 1] = possible_toys.pop()\n\n    return \" \".join(map(str, assigned_toys))"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def toy_change(kid_id: int, toy_id: int, time: int) -> None:\n        if kid_id not in toy_owners:\n            toy_owners[kid_id] = []\n        if time not in toy_owners[kid_id]:\n            toy_owners[kid_id].append(time)\n        if toy_id > 0:\n            toys_played[kid_id] = toy_id\n            toy_last_played[kid_id] = time\n\n    def check_crying(kid_id: int, toy_id: int, time: int) -> bool:\n        if toy_id == 0:\n            return False\n        if time < toy_last_played[kid_id]:\n            return False\n        if time - toy_last_played[kid_id] > 1:\n            return False\n        if toy_id == toys_played[kid_id]:\n            return False\n        return True\n\n    # Parse input\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    total_duration, num_events = map(int, input_lines[1].split())\n    events = input_lines[2:]\n\n    # Process events\n    toy_owners = {}\n    toy_last_played = {}\n    toys_played = {}\n    for event in events:\n        s, kid_id, toy_id = map(int, event.split())\n        if s < total_duration:\n            toy_change(kid_id, toy_id, s)\n\n    # Build toy_owner_times list\n    toy_owner_times = {}\n    for kid_id in toy_owners:\n        for time in toy_owners[kid_id]:\n            if time not in toy_owner_times:\n                toy_owner_times[time] = set()\n            toy_owner_times[time].add(kid_id)\n\n    # Find best toy for each kid\n    best_toy = {}\n    for kid_id in range(1, n + 1):\n        best_score = 0\n        best_toy_id = 0\n        for toy_id in range(1, m + 1):\n            score = 0\n            for time in range(total_duration, -1, -1):\n                if check_crying(kid_id, toy_id, time):\n                    score += 1\n                else:\n                    break\n            if score > best_score:\n                best_score = score\n                best_toy_id = toy_id\n        best_toy[kid_id] = best_toy_id\n\n    # Check for crying\n    for time in range(total_duration, -1, -1):\n        if any(check_crying(kid_id, best_toy[kid_id], time) for kid_id in range(1, n + 1)):\n            return \"impossible\"\n\n    # Output result\n    return \" \".join(map(str, best_toy.values()))\n\ndef"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    d, e = map(int, input_data[1].split())\n\n    toys_played_by = [-1] * n\n    toys_played_at = [-1] * m\n\n    for i in range(e):\n        s, k, t = map(int, input_data[2 + i].split())\n\n        if t == 0:\n            toys_played_by[k - 1] = -1\n        else:\n            toys_played_by[k - 1] = t - 1\n            toys_played_at[t - 1] = k - 1\n\n    toys = [[] for _ in range(m)]\n    for i in range(n):\n        if toys_played_by[i] != -1:\n            toys[toys_played_by[i]].append(i)\n\n    toys_avail = [i for i in range(m) if len(toys[i]) == 0]\n\n    if len(toys_avail) == 0:\n        return \"impossible\"\n\n    result = []\n    for i in range(n):\n        toy = toys_avail[0]\n        result.append(toy + 1)\n\n        for j in toys[toy]:\n            if j != i:\n                toys_played_by[j] = -1\n\n        toys_avail.remove(toy)\n        toys_played_at[toy] = -1\n\n        for i in range(m):\n            if len(toys[i]) > 0:\n                toys_avail.append(i)\n\n        if len(toys_avail) == 0:\n            return \"impossible\"\n\n    return result\n\n\nstdin = \"\"\"\n2 3\n6 7\n0 1 1\n0 2 2\n1 1 3\n2 1 2\n2 2 1\n3 2 3\n4 2 1\n\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_toy(kid: int, time: int, toys: List[int]) -> int:\n        return toys[kid - 1][bisect.bisect_left(toys[kid - 1], time)]\n\n    def add_toy(kid: int, toy: int, time: int, toys: List[int]) -> None:\n        bisect.insort(toys[kid - 1], (time, toy))\n\n    n, m = map(int, stdin.readline().split())\n    d, e = map(int, stdin.readline().split())\n    events = [tuple(map(int, stdin.readline().split())) for _ in range(e)]\n\n    toys = [[] for _ in range(n)]\n    for s, k, t in events:\n        if t != 0:\n            add_toy(k, t, s, toys)\n\n    for toy in range(1, m + 1):\n        for kid in range(1, n + 1):\n            if len(toys[kid - 1]) == 0:\n                continue\n            time = toys[kid - 1][0][0]\n            add_toy(kid, toy, time, toys)\n\n    for i in range(1, n + 1):\n        if len(toys[i - 1]) == 0:\n            return \"impossible\"\n\n    result = []\n    for i in range(1, n + 1):\n        result.append(find_toy(i, d, toys))\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, d, e = map(int, input_list[0].split())\n    toy_events = {}\n    for i in range(1, e+1):\n        s, k, t = map(int, input_list[i].split())\n        if t == 0:\n            del toy_events[k]\n        else:\n            toy_events[k] = t\n    \n    toys = [0] * n\n    for k, t in toy_events.items():\n        toys[k-1] = t\n    \n    unassigned_toys = list(set(range(1, m+1)) - set(toys))\n    \n    for i in range(n):\n        if toys[i] == 0:\n            toys[i] = unassigned_toys.pop(0)\n    \n    return ' '.join(map(str, toys))"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    d, e = map(int, input_data[1].split())\n\n    events = [list(map(int, line.split())) for line in input_data[2:]]\n\n    kids = [[] for _ in range(n)]\n    toys = [[] for _ in range(m)]\n\n    for event in events:\n        if event[2] == 0:\n            for i in range(n):\n                if i + 1 == event[1]:\n                    kids[i].pop()\n            for i in range(m):\n                if i + 1 == event[2]:\n                    toys[i].pop()\n        else:\n            for i in range(n):\n                if i + 1 == event[1]:\n                    kids[i].append(event[2] - 1)\n            for i in range(m):\n                if i + 1 == event[2]:\n                    toys[i].append(event[1] - 1)\n\n    if not toys:\n        return 'impossible'\n\n    result = []\n    for i in range(n):\n        if not kids[i]:\n            result.append(toys[0].pop(0))\n        else:\n            max_toy = max(kids[i], key=kids[i].count)\n            result.append(max_toy)\n            kids[i].remove(max_toy)\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n    \n    n = 1\n    while binomial_coefficient(n, n-1) < X:\n        n += 1\n    \n    k = n - 1\n    while binomial_coefficient(n, k) > X:\n        k -= 1\n    \n    return f\"{n} {k+1}\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n    n = 1\n    k = X\n    while X > 1:\n        k -= 1\n        X = (X * (n - k)) // n\n        n += 1\n    return str(n - 1) + ' ' + str(k + 1)\n\ninput_data = '10\\n2020'\noutput_data = [solution(input_data[i]) for i in range(len(input_data))]\n\nprint('\\n'.join(output_data)) "
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    # Brute force method to find the solution\n    n = 1\n    k = 1\n    while binomial_coefficient(n, k) < X:\n        if k < n:\n            k += 1\n        else:\n            n += 1\n            k = 1\n    return f\"{n} {k}\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    def binomial_coefficient(n, k):\n        return int(factorial(n) / (factorial(k) * factorial(n - k)))\n\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        else:\n            return n * factorial(n - 1)\n\n    for n in range(X, 0, -1):\n        for k in range(n, 0, -1):\n            if binomial_coefficient(n, k) == X:\n                return f\"{n} {k}\"\n"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n\n    def binomial_coefficient(n, k):\n        if k == 0 or k == n:\n            return 1\n        else:\n            return binomial_coefficient(n - 1, k - 1) * n // k\n\n    def binomial_coefficient_range(n, k):\n        if k > n // 2:\n            k = n - k\n        result = 1\n        for i in range(1, k + 1):\n            result *= n - k + i\n            result //= i\n        return result\n\n    if X < 1:\n        return \"Invalid input\"\n\n    for n in range(X, 0, -1):\n        k = X // binomial_coefficient(n, n)\n        if k > 0:\n            if binomial_coefficient(n, k) == X:\n                return f\"{n} {k}\"\n            elif binomial_coefficient_range(n, k) == X:\n                return f\"{n} {k}\"\n\n    return \"No solution found\"\n"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin.strip())\n\n    # Initialize variables\n    n = 0\n    k = 0\n    n_min = X\n    k_min = 1\n\n    # Find the smallest possible n and k values\n    for i in range(1, X + 1):\n        for j in range(1, i + 1):\n            if binomial(i, j) == X:\n                if i < n_min:\n                    n_min = i\n                    k_min = j\n                elif i == n_min and j < k_min:\n                    k_min = j\n\n    return f\"{n_min} {k_min}\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n\n    def binomial_coefficient(n: int, k: int) -> int:\n        if k > n:\n            return 0\n        if k == 0 or k == n:\n            return 1\n        return binomial_coefficient(n - 1, k - 1) + binomial_coefficient(n - 1, k)\n\n    n = 1\n    while binomial_coefficient(n, 1) < X:\n        n += 1\n\n    k = 1\n    while binomial_coefficient(n, k) < X:\n        k += 1\n\n    return f\"{n} {k - 1}\"\n\n\ninput_data = \"10\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n\n    def binomial_coefficient(n, k):\n        if k == 0 or k == n:\n            return 1\n        return binomial_coefficient(n - 1, k - 1) * n // k\n\n    n = 1\n    k = 0\n    while binomial_coefficient(n, k) < X:\n        n += 1\n        k += 1\n\n    return f\"{n} {k}\""
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 1\n    k = 1\n    while binomial(n, k) <= X:\n        if binomial(n, k) == X:\n            return f\"{n} {k}\"\n        n += 1\n        k += 1\n    return f\"{n-1} {k-1}\"\n\ndef"
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 1\n    k = 1\n    for i in range(2, X + 1):\n        n += 1\n        if i <= 2 * n:\n            k += 1\n        if i * math.comb(n, k) > X:\n            n -= 1\n            k -= 1\n        if n > X:\n            n -= 1\n            k -= 1\n    return f\"{n} {k}\"\n\n\ninput_file = open(\"input.txt\", \"r\")\ninput_str = input_file.read()\ninput_file.close()\n\noutput = solution(input_str)\noutput_file = open(\"output.txt\", \"w\")\noutput_file.write(output)\noutput_file.close()\n"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_path_possible(inventory: dict, items: list) -> bool:\n        for item in items:\n            if item not in inventory:\n                return False\n        return True\n\n    def find_paths(inventory: dict, items: list, start: int) -> list:\n        paths = []\n        for key in inventory:\n            if key == items[start]:\n                if start == len(items) - 1:\n                    paths.append(str(inventory[key]))\n                else:\n                    paths.extend(find_paths(inventory[key], items, start + 1))\n        return paths\n\n    def has_duplicates(paths: list) -> bool:\n        return len(set(paths)) != len(paths)\n\n    n_stores, k_inventory, *inventory_data = stdin.strip().split('\\n')\n    n_stores = int(n_stores)\n    k_inventory = int(k_inventory)\n    inventory = {i: set() for i in range(n_stores)}\n    for i, data in enumerate(inventory_data):\n        i_store, item = data.split()\n        inventory[int(i_store)].add(item)\n\n    n_items, *items_data = stdin.strip().split('\\n')\n    n_items = int(n_items)\n    items = items_data[1:]\n    items = [item for item in items]\n\n    if is_path_possible(inventory, items):\n        paths = find_paths(inventory, items, 0)\n        if has_duplicates(paths):\n            return \"ambiguous\"\n        else:\n            return \"unique\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    stores = [set() for _ in range(n)]\n    for _ in range(k):\n        i, s = input().split()\n        i, s = int(i), s.lower()\n        stores[i].add(s)\n\n    m = int(input())\n    items = set()\n    for _ in range(m):\n        items.add(input().lower())\n\n    path = {}\n    for i in range(n):\n        for item in stores[i]:\n            if item in items:\n                path[item] = i\n\n    if len(items) == len(path):\n        if len(set(path.values())) == 1:\n            return \"unique\"\n        else:\n            return \"ambiguous\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_item_at_store(item: str, store_num: int) -> int:\n        for i, store_item in enumerate(items_at_stores):\n            if store_item[0] == store_num and store_item[1] == item:\n                return i\n        return -1\n\n    def check_path(path: list) -> str:\n        for i in range(len(path) - 1):\n            if path[i] == path[i + 1]:\n                return \"ambiguous\"\n        return \"unique\" if len(path) == len(set(path)) else \"impossible\"\n\n    # Read input\n    num_stores, num_items = map(int, stdin.readline().split())\n    inventory = [stdin.readline().strip().split() for _ in range(num_stores)]\n    purchased_items = [stdin.readline().strip() for _ in range(num_items)]\n\n    # Process input\n    items_at_stores = [(int(inventory[i][0]), inventory[i][1]) for i in range(num_stores)]\n\n    # Check if there is a unique path\n    path = [find_item_at_store(item, inventory[i][0]) for i, item in enumerate(purchased_items)]\n    result = check_path(path)\n\n    return result"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(item: str, store_inventory: dict, visited: set, path: list) -> bool:\n        if item in store_inventory:\n            for i in store_inventory[item]:\n                if i not in visited:\n                    visited.add(i)\n                    path.append(i)\n                    if find_path(item, store_inventory, visited, path):\n                        return True\n                    visited.remove(i)\n                    path.pop()\n        return item in visited\n\n    def bfs(graph: dict, start: int, end: int) -> bool:\n        queue = [(start, [])]\n        visited = set()\n        while queue:\n            (vertex, path) = queue.pop(0)\n            if vertex == end:\n                return True\n            visited.add(vertex)\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    new_path = path + [vertex]\n                    queue.append((neighbor, new_path))\n        return False\n\n    input_lines = stdin.split('\\n')\n    num_stores = int(input_lines[0])\n    store_inventory = {}\n    for i in range(1, num_stores + 1):\n        store, item = input_lines[i].split()\n        store = int(store)\n        if item not in store_inventory:\n            store_inventory[item] = [store]\n        else:\n            store_inventory[item].append(store)\n\n    num_items = int(input_lines[num_stores + 1])\n    item_list = input_lines[num_stores + 2:num_stores + 2 + num_items]\n\n    graph = {i: [] for i in range(num_stores + 1)}\n    for item in item_list:\n        path = find_path(item, store_inventory, set(), [])\n        if not path:\n            return \"impossible\"\n        for i in range(len(path) - 1):\n            graph[path[i]].append(path[i + 1])\n\n    for i in range(num_stores + 1):\n        graph[i].append(i)\n\n    if bfs(graph, 0, num_stores):\n        return \"unique\"\n    else:\n        return \"ambiguous\"\n"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(store_id, visited, inventory, items):\n        if store_id >= len(inventory):\n            return True\n        if visited[store_id]:\n            return False\n        visited[store_id] = True\n        for item in inventory[store_id]:\n            if item == items[0]:\n                if dfs(store_id + 1, visited, inventory, items[1:]):\n                    return True\n        return False\n\n    def check(inventory, items):\n        visited = [False] * len(inventory)\n        for i in range(len(inventory)):\n            for item in inventory[i]:\n                if item == items[0]:\n                    if dfs(i, visited, inventory, items[1:]):\n                        return True\n        return False\n\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    inventory = [[] for _ in range(N)]\n    for i in range(1, N + 1):\n        store_id, item = lines[i].split()\n        inventory[int(store_id)].append(item)\n\n    M = int(lines[N + 1])\n    items = lines[N + 2:N + 2 + M]\n\n    if check(inventory, items):\n        return \"unique\"\n    elif any(check(inventory, items[i:] + items[:i]) for i in range(M)):\n        return \"ambiguous\"\n    else:\n        return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    store_info = input_list[1:N+1]\n    item_info = input_list[N+1:]\n\n    # create a list of items for each store\n    store_items = [[] for _ in range(N)]\n    for item in item_info:\n        store, item_name = item.split()\n        store_items[int(store)].append(item_name)\n\n    # create a dictionary of stores and their items\n    store_dict = {item_name: [] for item_name in set(item_info)}\n    for i, items in enumerate(store_items):\n        for item in items:\n            store_dict[item].append(i)\n\n    # create a list of items and their order of purchase\n    item_list = [item.strip() for item in item_info[N:]]\n\n    # create a dictionary of visited stores and their items\n    visited_stores = {}\n    for i in range(N):\n        if i == 0:\n            visited_stores[0] = store_items[0]\n        else:\n            visited_stores[i] = list(set(visited_stores[i-1]) & set(store_items[i]))\n\n    # create a list of items and their order of purchase\n    item_list = [item.strip() for item in item_info[N:]]\n\n    # create a list of items purchased in order\n    purchased_items = []\n    for item in item_list:\n        if item in visited_stores[len(purchased_items)]:\n            purchased_items.append(item)\n        else:\n            return \"impossible\"\n\n    # check if there are multiple possible paths\n    if len(purchased_items) != len(set(purchased_items)):\n        return \"ambiguous\"\n\n    return \"unique\"\n"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    stores = [dict() for _ in range(N)]\n    for i in range(1, N+1):\n        line = stdin.split('\\n')[i].split()\n        if len(line) == 2:\n            stores[int(line[0])-1][line[1]] = stores[int(line[0])-1].get(line[1], 0) + 1\n    items = stdin.split('\\n')[N+1].split('\\n')[1:]\n    item_count = int(stdin.split('\\n')[N].split()[1])\n    item_dict = {}\n    for item in items:\n        if item in item_dict:\n            item_dict[item] += 1\n        else:\n            item_dict[item] = 1\n    if len(item_dict) < item_count:\n        return \"impossible\"\n    if len(item_dict) > item_count:\n        return \"ambiguous\"\n    for key in item_dict:\n        for i in range(N):\n            if key in stores[i]:\n                item_dict[key] -= stores[i][key]\n                del stores[i][key]\n                break\n        if item_dict[key] == 0:\n            del item_dict[key]\n    if not item_dict:\n        return \"unique\"\n    else:\n        return \"ambiguous\"\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    K = int(lines[1])\n    inventory = [line.split() for line in lines[2:N+2]]\n    M = int(lines[N+2])\n    items = [line.strip() for line in lines[N+3:N+3+M]]\n\n    # Initialize the graph and find the minimum number of edges needed to connect all stores\n    graph = [[] for _ in range(N)]\n    for i, store in enumerate(inventory):\n        for item in store[1:]:\n            j = items.index(item)\n            graph[i].append((j, store[0]))\n    min_edges = N * (K - 1) - sum(len(g) for g in graph)\n\n    # Check if there is a unique path through the stores\n    if min_edges == 0:\n        return \"unique\"\n    elif min_edges > 0:\n        return \"ambiguous\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list.pop(0))\n    store_items = {}\n    for _ in range(N):\n        i, s = input_list.pop(0).split()\n        i = int(i)\n        if i in store_items:\n            store_items[i].append(s)\n        else:\n            store_items[i] = [s]\n\n    M = int(input_list.pop(0))\n    items = input_list\n    possible_paths = set()\n    for i in range(M):\n        item = items[i]\n        for store, items_list in store_items.items():\n            if item in items_list:\n                possible_paths.add(store)\n\n    if len(possible_paths) == 0:\n        return \"impossible\"\n    elif len(possible_paths) == 1:\n        return \"unique\"\n    else:\n        return \"ambiguous\""
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    # Get number of stores and items\n    N, K = map(int, input_list[0].split())\n    items_available = {i: set() for i in range(N)}\n    for i in range(1, N+1):\n        store_i, item_i = input_list[i].split()\n        items_available[int(store_i)].add(item_i)\n    M = int(input_list[N+1])\n    items_bought = set(input_list[N+2:N+2+M])\n\n    # Check if all items bought are available in some store\n    if len(items_bought - set(items_available.keys())) > 0:\n        return \"impossible\"\n\n    # Find the last store visited by your sister\n    last_visited_store = -1\n    for i in range(N):\n        if i in items_available and len(items_available[i] & items_bought) > 0:\n            last_visited_store = i\n            break\n\n    # If there is no last visited store, there is no path through the stores\n    if last_visited_store == -1:\n        return \"impossible\"\n\n    # Check if all items bought can be reconstructed from the last visited store\n    path_items = set()\n    for i in range(N-1, last_visited_store-1, -1):\n        if i in items_available and len(items_available[i] & path_items) > 0:\n            path_items |= items_available[i]\n        if len(path_items) == len(items_bought):\n            return \"unique\"\n    return \"ambiguous\"\n\ninput_list = [\n    \"3\",\n    \"3\",\n    \"0 chocolate\",\n    \"1 icecream\",\n    \"2 cookies\",\n    \"3\",\n    \"chocolate\",\n    \"cookies\",\n    \"icecream\",\n    \"2 chocolate\",\n    \"2 cookies\",\n    \"1 icecream\"\n]\n\nstdin = \"\\n\".join(input_list)\n\nprint(solution(stdin)) "
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    A = 2 ** M\n    if K >= A:\n        return \"0\"\n    if N == 1:\n        return \"1\"\n    return \"1\"  # To be updated\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 1 << M\n\n    def f(word, n, k):\n        if n == 0:\n            return 0\n        return (f(word, n - 1, k) * 33 + ord(word[n - 1]) % mod) % mod\n\n    count = 0\n    for word in product('abcdefghijklmnopqrstuvwxyz', repeat=N):\n        if f(''.join(word), N, K) == K:\n            count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 2**M\n    count = 0\n    for word_length in range(1, N+1):\n        count += binomial_coefficient(N, word_length) * (33**word_length % mod)\n    count = (count * K) % mod\n    return str(count)\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    total = 0\n\n    def hash_function(word: str) -> int:\n        if not word:\n            return 0\n        result = hash_function(word[:-1])\n        letter_hash = (result * 33) % (2 ** M)\n        letter_hash ^= ord(word[-1])\n        return letter_hash % (2 ** M)\n\n    for word in itertools.product(\"abcdefghijklmnopqrstuvwxyz\", repeat=N):\n        if hash_function(\"\".join(word)) == K:\n            total += 1\n\n    return str(total)\n"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 2 ** M\n    \n    def f(word: str, k: int, m: int, mod: int) -> int:\n        if len(word) == 0:\n            return k\n        else:\n            letter = word[-1]\n            k_next = (k * 33) % mod\n            k_next = (k_next ^ ord(letter)) % mod\n            return f(word[:-1], k_next, m, mod)\n    \n    count = 0\n    for word in itertools.product(\"abcdefghijklmnopqrstuvwxyz\", repeat=N):\n        hash_value = f(\"\".join(word), 0, M, mod)\n        if hash_value == K:\n            count += 1\n    \n    return str(count)\n\n\ninput_file = \"input.txt\"\nwith open(input_file, \"r\") as file:\n    stdin = file.readline()\n\noutput = solution(stdin)\n\nwith open(\"output.txt\", \"w\") as file:\n    file.write(output) "
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 2**M\n    count = 0\n\n    def hash_function(word: str) -> int:\n        if not word:\n            return 0\n        else:\n            return (hash_function(word[:-1]) * 33) ^ ord(word[-1]) % mod\n\n    for word in itertools.product(*[['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']]*N):\n        word = ''.join(word)\n        if hash_function(word) == K:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    if K == 0:\n        return '0'\n    count = 0\n    for i in range(1, N+1):\n        K = (K * 33) % (2**M)\n        count += 1\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    def f(word: str, k: int, mod: int) -> int:\n        if not word:\n            return k % mod\n        return f(word[:-1], (k * 33) ^ ord(word[-1]) % mod, mod)\n\n    return str(f(\"\", K, 2 ** M))\n"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    A = 1\n    A = pow(A, M, 2**M)\n    if A == K:\n        return 1\n    else:\n        return 0\n\ninput_data = input()\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    MOD = 2**M\n    num_words = 0\n    for i in range(2**N):\n        word = bin(i)[2:].zfill(N)\n        hash_value = 0\n        for letter in word:\n            hash_value = (hash_value * 33) ^ ord(letter)\n            hash_value %= MOD\n        if hash_value == K:\n            num_words += 1\n    return str(num_words)\n\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def touch_vector(p1, p2, grip_point):\n        return distance(p1, grip_point) - distance(p2, grip_point)\n\n    def grip_rotation(p1, p2, grip_point):\n        return math.atan2(touch_vector(p1, p2, grip_point), distance(p1, grip_point))\n\n    lines = stdin.split('\\n')\n    images = [[0] * 30 for _ in range(15)]\n\n    for i, line in enumerate(lines):\n        for j, char in enumerate(line):\n            if char == 'X':\n                images[i][j] = 1\n\n    grip_points = []\n    touch_points = []\n    touches = 0\n\n    for i in range(15):\n        for j in range(30):\n            if images[i][j] == 1:\n                touches += 1\n                touch_points.append((i, j))\n\n    if touches == 1:\n        return f\"{touches} pan\"\n\n    grip_points.append(sum(touch_points) / len(touch_points))\n    touch_points.sort(key=lambda p: distance(p, grip_points[0]))\n\n    pan_distances = []\n    pan_directions = []\n\n    for i in range(1, len(touch_points)):\n        pan_distances.append(distance(touch_points[i - 1], touch_points[i]))\n\n    grip_points.append(sum(touch_points) / len(touch_points))\n\n    if len(pan_distances) > 0:\n        max_pan_distance = max(pan_distances)\n        for i in range(1, len(touch_points)):\n            if distance(touch_points[i - 1], touch_points[i]) == max_pan_distance:\n                pan_directions.append('left' if touch_points[i - 1][1] > touch_points[i][1] else 'right')\n                break\n\n    zoom_distances = []\n    zoom_directions = []\n\n    for i in range(1, len(grip_points)):\n        zoom_distances.append(distance(grip_points[i - 1], grip_points[i]))\n\n    for i in range(1, len(grip_points)):\n        if abs(zoom_distances[i - 1] - zoom_distances[i]) < 1e-5:\n            zoom_directions.append('out' if zoom_distances[i - 1] < zoom_distances[i] else 'in')\n\n    rotation_distances = []\n    rotation_directions = []\n\n    for i in range(1, len(touch_points)):\n        rotation_distances.append(distance(touch_points[i - 1], touch_points[i]))\n        rotation_directions.append('clockwise' if grip_rotation(touch_points[i - 1], touch_points[i], grip_points[0]) > 0 else 'counter-clockwise')\n\n    if len(rotation_distances) > 0:\n        max_rotation_distance = max(rotation_distances)\n        for i in range(1, len(touch_points)):\n            if distance(touch_points[i - 1], touch_points[i]) == max_rotation_distance:\n                rotation_directions = [rotation_directions[i - 1]] * len(rotation_directions)\n                break\n\n    if len(pan_distances) > 0:\n        return f\"{touches} pan {' '.join(pan_directions)}\"\n    elif len(zoom_distances) > 0:\n        return f\"{touches} zoom {zoom_directions[0]}\"\n    else:\n        return f\"{touches} rotate {rotation_directions[0]}\""
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_grip_point(touches: list) -> tuple:\n        x_sum, y_sum, count = 0, 0, 0\n        for touch in touches:\n            x_sum += touch[0]\n            y_sum += touch[1]\n            count += 1\n        return (x_sum / count, y_sum / count)\n\n    def get_touch_vector(grip_point: tuple, touch_point: tuple) -> float:\n        return math.sqrt((touch_point[0] - grip_point[0]) ** 2 + (touch_point[1] - grip_point[1]) ** 2)\n\n    def get_touch_rotation(initial_touch_vectors: list, final_touch_vectors: list) -> float:\n        dot_product_sum = 0\n        magnitude_sum = 0\n        for i in range(len(initial_touch_vectors)):\n            dot_product = initial_touch_vectors[i][0] * final_touch_vectors[i][0] + initial_touch_vectors[i][1] * final_touch_vectors[i][1]\n            dot_product_sum += dot_product\n            magnitude_sum += initial_touch_vectors[i][0] ** 2 + initial_touch_vectors[i][1] ** 2\n        return math.acos(dot_product_sum / math.sqrt(magnitude_sum))\n\n    def get_grip_spread(touches: list, grip_point: tuple) -> float:\n        return sum([get_touch_vector(grip_point, touch) for touch in touches]) / len(touches)\n\n    def pan(initial_grip_point: tuple, final_grip_point: tuple, initial_touches: list, final_touches: list) -> bool:\n        initial_pan_distance = get_touch_vector(initial_grip_point, final_grip_point)\n        final_pan_distance = get_touch_vector(final_grip_point, initial_grip_point)\n        return abs(initial_pan_distance - final_pan_distance) < 1e-5\n\n    def zoom(initial_grip_spread: float, final_grip_spread: float) -> str:\n        return \"out\" if final_grip_spread < initial_grip_spread else \"in\"\n\n    def rotate(initial_touch_vectors: list, final_touch_vectors: list) -> str:\n        rotation_angle = get_touch_rotation(initial_touch_vectors, final_touch_vectors)\n        if abs(rotation_angle) < 1e-5:\n            return \"none\"\n        if rotation_angle > 0:\n            return \"counter-clockwise\"\n        else:\n            return \"clockwise\"\n\n    def classify_gesture(initial_touches: list, final_touches: list) -> str:\n        initial_grip_point = get_grip_point(initial_touches)\n        final_grip_point = get_grip_point(final_touches)\n        initial_grip_spread = get_grip_spread(initial_touches, initial_grip_point)\n        final_grip_spread = get_grip_spread(final_touches, final_grip_point)\n\n        initial_touch_vectors = [(get_touch_vector(initial_grip_point, touch), initial_grip_point) for touch in initial_touches]\n        final_touch_vectors = [(get_touch_vector(final_grip_point, touch), final_grip_point) for touch in final_touches]\n\n        if pan(initial_grip_point, final_grip_point, initial_touches, final_touches):\n            return \"pan\"\n        if zoom(initial_grip_spread, final_grip_spread):\n            return f\"zoom {zoom(initial_grip_spread, final_grip_spread)}\"\n        if rotate(initial_touch_vectors, final_touch_vectors):\n            return f\"rotate {rotate(initial_touch_vectors, final_touch_vectors)}\""
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def grip_point(touches):\n        return tuple(sum(x) / len(touches) for x in zip(*touches))\n\n    def touch_vector(touch, grip):\n        return tuple(x - y for x, y in zip(touch, grip))\n\n    def rotation_angle(v1, v2):\n        cos_angle = v1[0] * v2[0] + v1[1] * v2[1]\n        sin_angle = v1[0] * v2[1] - v1[1] * v2[0]\n        return np.arctan2(sin_angle, cos_angle)\n\n    def classify_gesture(touches1, touches2, grip_spread1, grip_spread2):\n        if distance(touches1, touches2) < 1e-5:\n            return \"pan\"\n        if grip_spread2 < grip_spread1:\n            return \"zoom out\"\n        else:\n            return \"zoom in\"\n\n    image1, image2 = stdin.split(\"\\n\")\n    touches1, touches2 = [], []\n\n    for row in zip(image1, image2):\n        if row[0] == \"X\":\n            touches1.append(row[0].index(\"X\") + 1, row[0].index(\"X\") + 1)\n        if row[1] == \"X\":\n            touches2.append(row[1].index(\"X\") + 1, row[1].index(\"X\") + 1)\n\n    grip1 = grip_point(touches1)\n    grip2 = grip_point(touches2)\n\n    touch_vectors1 = [touch_vector(touch, grip1) for touch in touches1]\n    touch_vectors2 = [touch_vector(touch, grip2) for touch in touches2]\n\n    grip_rotation = rotation_angle(touch_vectors1[0], touch_vectors2[0])\n\n    result = classify_gesture(touches1, touches2, distance(grip1, grip2), distance(touch_vectors1[0], touch_vectors2[0]))\n\n    return f\"{len(touches1)} {result}\"\n\nstdin = \"\"\"\n.............................. ..............................\n.............................. ..............................\n....XXXX...................... ..............................\n....XXXX...................... ............XXXX..............\n....XXXX...................... .............XXX..............\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ................"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    images = stdin.split('\\n')\n    # Preprocess images to get touches and touch vectors\n    touches = []\n    for image in images:\n        touches_in_image = []\n        for i in range(30):\n            row = image[i*15:(i+1)*15]\n            touch_points = [(i, j) for j, c in enumerate(row) if c == 'X']\n            touches_in_image.append(touch_points)\n        touches.append(touches_in_image)\n\n    # Calculate initial and final grips\n    initial_grip = [(sum(x) / len(x), sum(y) / len(y)) for x, y in touches[0]]\n    final_grip = [(sum(x) / len(x), sum(y) / len(y)) for x, y in touches[1]]\n\n    # Calculate grip spreads and touch vectors\n    grip_spreads = [((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5 for (x1, y1), (x2, y2) in zip(initial_grip, final_grip)]\n    initial_touch_vectors = [(x - x_g, y - y_g) for (x, y), (x_g, y_g) in zip(initial_grip, touches[0])]\n    final_touch_vectors = [(x - x_g, y - y_g) for (x, y), (x_g, y_g) in zip(final_grip, touches[1])]\n\n    # Calculate pan distance\n    pan_distance = sum([(x1 - x2) ** 2 + (y1 - y2) ** 2 for (x1, y1), (x2, y2) in zip(initial_grip, final_grip)]) ** 0.5\n\n    # Calculate zoom distance\n    zoom_distance = max(grip_spreads) - min(grip_spreads)\n\n    # Calculate rotation distance\n    rotation_distance = sum([(x1 * y2 - y1 * x2) ** 2 for (x1, y1), (x2, y2) in zip(initial_touch_vectors, final_touch_vectors)]) ** 0.5\n\n    # Calculate grip rotation\n    grip_rotation = sum([(x1 * y2 - y1 * x2) for (x1, y1), (x2, y2) in zip(initial_touch_vectors, final_touch_vectors)])\n    grip_rotation /= rotation_distance\n\n    # Classify gesture based on distance\n    if pan_distance <= 1e-5:\n        gesture = 'pan'\n    elif zoom_distance <= 1e-5:\n        gesture = 'zoom'\n    else:\n        gesture = 'rotate'\n        if grip_rotation < 1e-5:\n            direction = 'counter-clockwise'\n        elif grip_rotation > 2 * np.pi - 1e-5:\n            direction = 'clockwise'\n        else:\n            direction = 'counter-clockwise' if grip_rotation > 0 else 'clockwise'\n\n    # Print result\n    num_touches = len(touches[0])\n    print(f'{num_touches} {gesture} {direction if gesture == \"rotate\" else \"\"}')\n"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    images = stdin.strip().split(\"\\n\")\n    initial_image, final_image = images\n    initial_touches = find_touches(initial_image)\n    final_touches = find_touches(final_image)\n\n    initial_grip_point = find_grip_point(initial_touches)\n    final_grip_point = find_grip_point(final_touches)\n\n    initial_grip = [(x, y, calculate_touch_vector(x, y, initial_grip_point)) for x, y in initial_touches]\n    final_grip = [(x, y, calculate_touch_vector(x, y, final_grip_point)) for x, y in final_touches]\n\n    initial_grip_spread = calculate_grip_spread(initial_grip)\n    final_grip_spread = calculate_grip_spread(final_grip)\n\n    initial_zoom_distance = final_grip_spread - initial_grip_spread\n\n    pan_distance = calculate_pan_distance(initial_grip, final_grip)\n    zoom_distance = abs(initial_zoom_distance)\n    rotation_distance = calculate_rotation_distance(initial_grip, final_grip)\n\n    distances = [pan_distance, zoom_distance, rotation_distance]\n    gestures = [\"pan\", \"zoom\", \"rotate\"]\n\n    max_distance_index = distances.index(max(distances))\n    gesture = gestures[max_distance_index]\n\n    if gesture == \"zoom\":\n        direction = \"out\" if initial_zoom_distance < 0 else \"in\"\n        return f\"{len(final_touches)} {gesture} {direction}\"\n    elif gesture == \"rotate\":\n        rotation = calculate_rotation(initial_grip, final_grip)\n        direction = \"clockwise\" if rotation > 0 else \"counter-clockwise\"\n        return f\"{len(final_touches)} {gesture} {direction}\"\n    else:\n        return f\"{len(final_touches)} {gesture}\"\n\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    img1, img2 = stdin.split(\"  \")\n    img1 = list(img1.strip())\n    img2 = list(img2.strip())\n\n    def get_touch(img: list) -> list:\n        touches = []\n        for i in range(len(img)):\n            row = img[i]\n            for j in range(len(row)):\n                if row[j] == 'X':\n                    touches.append((i, j))\n        return touches\n\n    def get_grip(touches: list) -> tuple:\n        grip_point = tuple(map(sum, zip(*touches))) // len(touches)\n        grip = [(x - grip_point[0], y - grip_point[1]) for x, y in touches]\n        return grip_point, grip\n\n    def get_touch_vector(grip_point: tuple, touch: tuple) -> tuple:\n        return (touch[0] - grip_point[0], touch[1] - grip_point[1])\n\n    def get_grip_spread(grip: list) -> float:\n        return math.sqrt(sum((x ** 2 + y ** 2 for x, y in grip)))\n\n    def get_touch_distance(img1: list, img2: list) -> float:\n        grip_point1, touches1 = get_grip(get_touch(img1))\n        grip_point2, touches2 = get_grip(get_touch(img2))\n        touches_distances = []\n        for touch1, touch2 in zip(touches1, touches2):\n            distance = math.sqrt((touch1[0] - touch2[0]) ** 2 + (touch1[1] - touch2[1]) ** 2)\n            touches_distances.append(distance)\n        return sum(touches_distances)\n\n    def get_grip_distance(grip_spread1: float, grip_spread2: float) -> float:\n        return abs(grip_spread1 - grip_spread2)\n\n    def get_touch_rotation(grip_point: tuple, touch1: tuple, touch2: tuple) -> float:\n        x1, y1 = touch1\n        x2, y2 = touch2\n        return math.atan2(y2 - y1, x2 - x1) - math.atan2(grip_point[1] - y1, grip_point[0] - x1)\n\n    def get_grip_rotation(touches: list) -> float:\n        grip_point, _ = get_grip(touches)\n        grip_rotations = [get_touch_rotation(grip_point, *touches[i], touches[(i + 1) % len(touches)]) for i in range(len(touches))]\n        return sum(grip_rotations) / len(touches)\n\n    def get_gesture(touches1: list, touches2: list) -> str:\n        grip_point1, touches1 = get_grip(touches1)\n        grip_point2, touches2 = get_grip(touches2)\n        grip_spread1 = get_grip_spread(touches1)\n        grip_spread2 = get_grip_spread(touches2)\n        grip_distance = get_grip_distance(grip_spread1, grip_spread2)\n        touch_distance = get_touch_distance(img1, img2)\n        grip_rotation = get_grip_rotation(touches1 + touches2)\n        grip_rotation_direction = 'counter-clockwise' if grip_rotation > 0 else 'clockwise'\n        grip_rotation = abs(grip_rotation)\n\n        if touch_distance / (grip_spread1 + grip_spread2) < 10 ** (-5):\n            return f\"{len(touches1)} pan\"\n        elif grip_distance / (grip_spread1 + grip_spread2) < 10 ** (-5):\n            return f\"{len("
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    img1 = lines[0]\n    img2 = lines[1]\n\n    def get_grip(img: str) -> tuple:\n        grip_points = []\n        grip_sum = [0, 0]\n        for y in range(len(img)):\n            for x in range(len(img[y])):\n                if img[y][x] == 'X':\n                    grip_points.append((x, y))\n                    grip_sum[0] += x\n                    grip_sum[1] += y\n        grip_point = (grip_sum[0] / len(grip_points), grip_sum[1] / len(grip_points))\n        return grip_points, grip_point\n\n    def get_touch_vector(img: str, grip_point: tuple) -> list:\n        vectors = []\n        for y in range(len(img)):\n            for x in range(len(img[y])):\n                if img[y][x] == 'X':\n                    vectors.append((x - grip_point[0], y - grip_point[1]))\n        return vectors\n\n    def get_grip_spread(grip_points: list, grip_point: tuple) -> float:\n        return np.mean([np.linalg.norm(np.array(p) - np.array(grip_point)) for p in grip_points])\n\n    def get_rotation(img1: str, img2: str, grip_points1: list, grip_points2: list, grip_point1: tuple, grip_point2: tuple) -> float:\n        vectors1 = get_touch_vector(img1, grip_point1)\n        vectors2 = get_touch_vector(img2, grip_point2)\n        return np.mean([np.arctan2(vectors1[i][1], vectors1[i][0]) - np.arctan2(vectors2[i][1], vectors2[i][0]) for i in range(len(vectors1))])\n\n    grip_points1, grip_point1 = get_grip(img1)\n    grip_points2, grip_point2 = get_grip(img2)\n\n    num_touches = len(grip_points1)\n\n    if len(grip_points1) != len(grip_points2):\n        raise ValueError(\"Images do not have the same number of touches\")\n\n    grip_spread1 = get_grip_spread(grip_points1, grip_point1)\n    grip_spread2 = get_grip_spread(grip_points2, grip_point2)\n\n    rotation = get_rotation(img1, img2, grip_points1, grip_points2, grip_point1, grip_point2)\n\n    if abs(grip_spread2 - grip_spread1) < 1e-5:\n        return f\"{num_touches} zoom\"\n    elif rotation < -1e-5 or rotation > 1e-5:\n        return f\"{num_touches} rotate\"\n    else:\n        return f\"{num_touches} pan\"\n\ndef"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def touch_vector(grip, touch):\n        return (touch[0] - grip[0], touch[1] - grip[1])\n\n    def grip_rotation(initial_grip, final_grip):\n        initial_vectors = [touch_vector(initial_grip, touch) for touch in initial_grip]\n        final_vectors = [touch_vector(final_grip, touch) for touch in final_grip]\n        return sum([initial_vectors[i][0]*final_vectors[i][1] - initial_vectors[i][1]*final_vectors[i][0] for i in range(len(initial_vectors))]) / len(initial_vectors)\n\n    def grip_spread(grip):\n        return sum([distance(grip[0], touch) for touch in grip]) / len(grip)\n\n    def pan(initial_grip, final_grip):\n        return distance(initial_grip, final_grip) < 1e-5\n\n    def zoom(initial_grip, final_grip):\n        return abs(grip_spread(final_grip) - grip_spread(initial_grip)) < 1e-5\n\n    def rotate(initial_grip, final_grip):\n        return abs(grip_rotation(initial_grip, final_grip)) < 1e-5\n\n    def classify_gesture(initial_grip, final_grip):\n        if pan(initial_grip, final_grip):\n            return 1, 'pan'\n        elif zoom(initial_grip, final_grip):\n            if grip_spread(final_grip) < grip_spread(initial_grip):\n                return 1, 'zoom out'\n            else:\n                return 1, 'zoom in'\n        else:\n            return 1, 'rotate'\n\n    images = stdin.split('\\n')[:-1]\n    initial_grip = []\n    final_grip = []\n    for i in range(len(images[0])):\n        if images[0][i] == 'X':\n            initial_grip.append((i//15, i%15))\n        if images[1][i] == 'X':\n            final_grip.append((i//15, i%15))\n\n    num_touches = len(initial_grip)\n    gesture_type, direction = classify_gesture(initial_grip, final_grip)\n\n    if direction == 'rotate':\n        if grip_rotation(initial_grip, final_grip) > 0:\n            direction = 'clockwise'\n        else:\n            direction = 'counter-clockwise'\n\n    return f\"{num_touches} {gesture_type} {direction}\"\n\ninput_string = \"\"\"\n.............................. ..............................\n.............................. ..............................\n....XXXX...................... ..............................\n....XXXX...................... ............XXXX..............\n....XXXX...................... .............XXX..............\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n.............................. ..............................\n\"\"\"\nprint(solution(input_string)) "
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    lines = [line.strip() for line in lines if line.strip() != '']\n    assert len(lines) == 16, \"Input must have 16 lines\"\n\n    def find_touches(image: str) -> List[Tuple[int, int]]:\n        touches = []\n        for i, row in enumerate(image.split('\\n')):\n            for j, pixel in enumerate(row):\n                if pixel == 'X':\n                    touches.append((i, j))\n        return touches\n\n    def distance(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def find_grip(touches: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n        grip_points = [touches[0]]\n        for i in range(1, len(touches)):\n            min_dist = float('inf')\n            closest_grip = (0, 0)\n            for grip_point in grip_points:\n                dist = distance(touches[i], grip_point)\n                if dist < min_dist:\n                    min_dist = dist\n                    closest_grip = grip_point\n            grip_points.append(closest_grip)\n\n        grip_points = sorted(grip_points, key=lambda x: x[0])\n        grip_points = sorted(grip_points, key=lambda x: x[1])\n\n        return (grip_points[0], grip_points[-1])\n\n    def find_touch_vectors(touches: List[Tuple[int, int]], grip: Tuple[Tuple[int, int], Tuple[int, int]]) -> List[Tuple[float, float]]:\n        grip_point = tuple(map(lambda x: (x[0] + x[1]) // 2, zip(*grip)))\n        touch_vectors = []\n        for touch in touches:\n            touch_vectors.append((touch[0] - grip_point[0], touch[1] - grip_point[1]))\n        return touch_vectors\n\n    def find_grip_spread(touches: List[Tuple[int, int]]) -> float:\n        return statistics.mean(distance(touches[0], touch) for touch in touches)\n\n    def find_zoom_distance(touches: List[Tuple[int, int]], initial_grip_spread: float, final_grip_spread: float) -> float:\n        return abs(final_grip_spread - initial_grip_spread)\n\n    def find_touch_rotation(touch_vectors: List[Tuple[float, float]]) -> float:\n        rotation = 0\n        for i in range(len(touch_vectors)):\n            rotation += math.atan2(touch_vectors[i][1], touch_vectors[i][0])\n        return rotation / len(touch_vectors)\n\n    def find_grip_rotation(touch_vectors: List[Tuple[float, float]]) -> float:\n        return math.atan2(sum(touch_vector[1] for touch_vector in touch_vectors), sum(touch_vector[0] for touch_vector in touch_vectors))\n\n    def find_rotate_distance(touch_rotation: float, grip_rotation: float) -> float:\n        rotate_distance = abs(touch_rotation - grip_rotation)\n        return rotate_distance % (2 * math.pi)\n\n    def classify_gesture(touches: List[Tuple[int, int]]) -> Tuple[str, str]:\n        initial_grip = find_grip(touches)\n        initial_grip_spread = find_grip_spread(touches)\n        final_grip = find_grip(touches)\n        final_grip_spread = find_grip_spread(touches)\n\n        initial_touch_vectors"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    images = stdin.split(\"\\n\")\n    num_touches = len(images[0]) - images[0].count(\".\")\n    initial_grip = []\n    final_grip = []\n    \n    for image in images:\n        touch_points = [i for i, x in enumerate(image) if x == \"X\"]\n        grip_point = sum(touch_points) / len(touch_points)\n        for touch in touch_points:\n            initial_grip.append((touch, grip_point, (touch - grip_point) ** 2))\n            final_grip.append((touch, grip_point, (touch - grip_point) ** 2))\n    \n    initial_grip.sort(key=lambda x: x[2])\n    final_grip.sort(key=lambda x: x[2])\n    \n    initial_grip_points = [x[1] for x in initial_grip]\n    final_grip_points = [x[1] for x in final_grip]\n    \n    initial_grip_spread = sum((x - initial_grip_points[0]) ** 2 for x in initial_grip_points) / len(initial_grip_points)\n    final_grip_spread = sum((x - final_grip_points[0]) ** 2 for x in final_grip_points) / len(final_grip_points)\n    \n    initial_grip_vector = (initial_grip_points[0], final_grip_points[0])\n    final_grip_vector = (final_grip_points[0], initial_grip_points[0])\n    \n    initial_grip_rotation = sum((x - initial_grip_vector[0]) * (y - initial_grip_vector[1]) for x, y in initial_grip) / len(initial_grip)\n    final_grip_rotation = sum((x - final_grip_vector[0]) * (y - final_grip_vector[1]) for x, y in final_grip) / len(final_grip)\n    \n    if abs(initial_grip_spread - final_grip_spread) < 1e-5:\n        distance = \"no difference\"\n    elif initial_grip_spread < final_grip_spread:\n        distance = \"out\"\n    else:\n        distance = \"in\"\n    \n    if abs(initial_grip_rotation) < 1e-5:\n        rotation = \"no rotation\"\n    elif initial_grip_rotation < 0:\n        rotation = \"clockwise\"\n    else:\n        rotation = \"counter-clockwise\"\n    \n    return f\"{num_touches} pan {distance} {rotation}\""
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    H, W = map(int, input_data[0].split())\n    web_page = input_data[1:]\n\n    def is_ad(image: str, allowed_chars: str) -> bool:\n        for char in image:\n            if char not in allowed_chars:\n                return True\n        return False\n\n    def find_min_ad(image: str, allowed_chars: str) -> int:\n        min_size = float('inf')\n        min_ad_index = -1\n        for i, char in enumerate(image):\n            if char not in allowed_chars:\n                size = sum(1 for _ in image if image.count(char))\n                if size < min_size:\n                    min_size = size\n                    min_ad_index = i\n        return min_ad_index\n\n    def process_web_page(web_page: list[str]) -> str:\n        allowed_chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789?!., \"\n        ads = set()\n        images = []\n\n        for i, row in enumerate(web_page):\n            for j, char in enumerate(row):\n                if char == '$':\n                    if i == 0 or web_page[i - 1][j] != '$':\n                        top_border = i\n                    if j == 0 or row[j - 1] != '$':\n                        left_border = j\n\n            for j in range(left_border, W):\n                if web_page[top_border][j] == '$':\n                    right_border = j\n                    break\n            for i in range(top_border, H):\n                if web_page[i][left_border] == '$':\n                    bottom_border = i\n                    break\n\n            if top_border + 1 < bottom_border and left_border + 1 < right_border:\n                image = ''.join([row[left_border + 1:right_border] for row in web_page[top_border + 1:bottom_border]])\n                if is_ad(image, allowed_chars):\n                    ad_index = find_min_ad(image, allowed_chars)\n                    ad_pos = (left_border + 1 + ad_index, top_border + 1)\n                    if ad_pos not in ads:\n                        ads.add(ad_pos)\n                        images.append(image)\n\n        for i, row in enumerate(web_page):\n            for j, char in enumerate(row):\n                if (j, i) in ads:\n                    web_page[i] = web_page[i][:j] + ' ' * len(images[ads.index((j, i))]) + web_page[i][j + 1:]\n\n        for image in images:\n            for char in image:\n                if char not in allowed_chars:\n                    web_page[image.index(char) // W + 1] = web_page[image.index(char) // W + 1][:image.index(char) % W] + ' ' + web_page[image.index(char) // W + 1][image.index(char) % W + 1:]\n\n        return ''.join(web_page)\n\n    return process_web_page(web_page)"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, input().split())\n    page = [list(input()) for _ in range(H)]\n\n    def find_image_bounds(page: list, x: int, y: int) -> tuple:\n        border = '$+$'\n        while y < H and page[y][x] == border:\n            y += 1\n        while x < W and page[y - 1][x] == border:\n            x += 1\n        while y > 0 and page[y - 1][x - 1] == border:\n            y -= 1\n        while x > 0 and page[y][x - 1] == border:\n            x -= 1\n        return x, y - 1, x + 1, y - 1\n\n    def find_image_size(page: list, x: int, y: int) -> int:\n        x1, y1, x2, y2 = find_image_bounds(page, x, y)\n        return (y2 - y1 + 1) * (x2 - x1 + 1)\n\n    def is_allowed_char(c: str) -> bool:\n        return c.isalnum() or c in ['?', '!', ',', '.', ' ']\n\n    def is_image_ad(page: list, x: int, y: int) -> bool:\n        x1, y1, x2, y2 = find_image_bounds(page, x, y)\n        for i in range(y1, y2 + 1):\n            for j in range(x1, x2 + 1):\n                if not is_allowed_char(page[i][j]):\n                    return True\n        return False\n\n    def remove_image_ad(page: list, x: int, y: int) -> None:\n        x1, y1, x2, y2 = find_image_bounds(page, x, y)\n        for i in range(y1, y2 + 1):\n            for j in range(x1, x2 + 1):\n                page[i][j] = ' ' if is_allowed_char(page[i][j]) else '+'\n\n    def remove_smallest_image_ad(page: list, x: int, y: int, ad_chars: int) -> None:\n        image_size = find_image_size(page, x, y)\n        if image_size < ad_chars:\n            remove_image_ad(page, x, y)\n\n    def remove_ads(page: list) -> list:\n        ad_chars = float('inf')\n        for y in range(H):\n            for x in range(W):\n                if page[y][x] == '$+$':\n                    image_ad = is_image_ad(page, x, y)\n                    if image_ad:\n                        remove_smallest_image_ad(page, x, y, ad_chars)\n                        ad_chars = min(ad_chars, find_image_size(page, x, y))\n        return page\n\n    page = remove_ads(page)\n\n    result = ''\n    for row in page:\n        result += ''.join(row) + '\\n'\n    return result.rstrip()\n\ndef"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, input().split())\n    page = []\n    for _ in range(H):\n        page.append(input())\n    \n    image_borders = set()\n    image_coords = {}\n    ads = set()\n    min_ads = {}\n\n    def is_valid_image(img_coords, img_chars):\n        for char_coords, char in img_chars:\n            if char not in [' ', '$', '+', '?', '!', ',', '.']:\n                return False\n        return True\n\n    def update_min_ads(min_ads, ad_coords, ad_chars):\n        for char_coords, char in ad_chars:\n            if char not in [' ', '$', '+']:\n                ad_area = (ad_coords[1] - ad_coords[0]) * (ad_coords[3] - ad_coords[2])\n                if ad_area < min_ads.get(char, float('inf')):\n                    min_ads[char] = ad_area\n\n    def remove_image(img_coords):\n        nonlocal page\n        nonlocal image_borders\n        nonlocal image_coords\n        nonlocal ads\n        nonlocal min_ads\n\n        img_height = img_coords[1] - img_coords[0]\n        img_width = img_coords[3] - img_coords[2]\n\n        img_chars = {}\n        for y in range(img_coords[0], img_coords[1]):\n            for x in range(img_coords[2], img_coords[3]):\n                char = page[y][x]\n                img_chars[(y, x)] = char\n\n        if is_valid_image(img_coords, img_chars):\n            ads.add(img_coords)\n            update_min_ads(min_ads, img_coords, img_chars)\n\n        for y in range(img_coords[0], img_coords[1]):\n            for x in range(img_coords[2], img_coords[3]):\n                char = page[y][x]\n                if char == '$':\n                    image_borders.add((y, x))\n                    image_coords[y, x] = (img_height, img_width, img_coords)\n\n    def is_neighboring(coords1, coords2):\n        return any((coords1[0] <= coords2[0] <= coords1[1], coords1[0] <= coords2[1] <= coords1[1],\n                    coords1[2] <= coords2[2] <= coords1[3], coords1[2] <= coords2[3] <= coords1[3]))\n\n    def find_borders(y, x, visited):\n        if (y, x) in visited or (y < 0 or y >= H or x < 0 or x >= W):\n            return set()\n        visited.add((y, x))\n        if page[y][x] == '$':\n            borders = {(y, x)}\n            borders |= find_borders(y - 1, x, visited)\n            borders |= find_borders(y + 1, x, visited)\n            borders |= find_borders(y, x - 1, visited)\n            borders |= find_borders(y, x + 1, visited)\n            return borders\n        return set()\n\n    for y in range(H):\n        for x in range(W):\n            if page[y][x] == '+':\n                image_borders.add((y, x))\n\n    for border in sorted(image_borders, key=lambda x: (x[1], x[0])):\n        y, x = border\n        img_coords = None\n        img_height = 0\n        img_width = 0\n\n        borders = find_borders(y, x, set())\n        for (img_y, img_x), (img_height, img_width, img_coords) in image_coords.items():\n            if (img_y, img_x)"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    H, W = map(int, input_list[0].split())\n    img_list = [list(line) for line in input_list[1:]]\n\n    def is_valid_img(img, img_list):\n        for row in img:\n            if not all(c.isalnum() or c in ('?', '!', ',', '.', ' ') for c in row):\n                return False\n        for col in zip(*img):\n            if not all(c.isalnum() or c in ('?', '!', ',', '.', ' ') for c in col):\n                return False\n        return True\n\n    def is_banned_char(img, img_list):\n        for i in range(1, len(img) - 1):\n            for j in range(1, len(img[0]) - 1):\n                if img[i][j] == '$':\n                    if img[i - 1][j] != '$' and img[i + 1][j] != '$' and img[i][j - 1] != '$' and img[i][j + 1] != '$':\n                        return True\n        return False\n\n    def remove_img(img, img_list):\n        for i in range(1, len(img) - 1):\n            for j in range(1, len(img[0]) - 1):\n                if img[i][j] == '$':\n                    img[i][j] = ' '\n                    img_list[i - 1][j] = ' '\n                    img_list[i + 1][j] = ' '\n                    img_list[i][j - 1] = ' '\n                    img_list[i][j + 1] = ' '\n\n    def find_smallest_img_containing_char(img, img_list):\n        min_size = float('inf')\n        smallest_img = None\n        for i, row in enumerate(img_list):\n            if '$' in row:\n                img = [list(line) for line in img_list[i:i + 3]]\n                if is_valid_img(img, img_list) and not is_banned_char(img, img_list):\n                    size = sum(len(row) for row in img)\n                    if size < min_size:\n                        min_size = size\n                        smallest_img = img\n        return smallest_img\n\n    def process_img(img, img_list):\n        remove_img(img, img_list)\n        smallest_img = find_smallest_img_containing_char(img, img_list)\n        if smallest_img:\n            for i in range(len(img_list)):\n                img_list[i] = ' '.join(img_list[i])\n            for img in smallest_img:\n                img_list.extend([list(line) for line in img])\n            for i in range(len(img_list)):\n                img_list[i] = ' '.join(img_list[i])\n\n    for i, img in enumerate(img_list):\n        if '$' in img:\n            img = [list(line) for line in img_list[i:i + 3]]\n            if is_valid_img(img, img_list) and not is_banned_char(img, img_list):\n                process_img(img, img_list)\n\n    return '\\n'.join([''.join(row) for row in img_list])\n"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    height = int(input_list[0].split()[0])\n    width = int(input_list[0].split()[1])\n    web_page = []\n    for line in input_list[1:]:\n        web_page.append(list(line))\n\n    def is_valid_border(border: str) -> bool:\n        for char in border:\n            if char not in ['$', '+', ' ']:\n                return False\n        return True\n\n    def find_smallest_image(image: str) -> str:\n        smallest_image = None\n        for i in range(len(image)):\n            for j in range(len(image[i])):\n                if image[i][j] == ' ' and (smallest_image is None or len(smallest_image) > i + 1):\n                    smallest_image = image[i:i+1]\n                if image[i][j] == '$':\n                    smallest_image = None\n        return smallest_image\n\n    def remove_ad(ad: str) -> str:\n        ad = list(ad)\n        for i in range(len(ad)):\n            for j in range(len(ad[i])):\n                if ad[i][j] not in [' ', '$', '+']:\n                    ad[i][j] = ' '\n        return ''.join(ad)\n\n    def process_web_page(web_page: List[List[str]]) -> str:\n        for i in range(height):\n            for j in range(width):\n                if web_page[i][j] == '$':\n                    if is_valid_border(web_page[i][max(0, j-1):min(width, j+2)]):\n                        web_page[i][j] = ' '\n                        ad = find_smallest_image(web_page[i-1:i+2])\n                        if ad is not None:\n                            ad = remove_ad(ad)\n                            web_page[i-1:i+2] = ad\n        return web_page\n\n    processed_web_page = process_web_page(web_page)\n    result = []\n    for line in processed_web_page:\n        result.append(''.join(line))\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0:2])\n    pages = [list(line.strip()) for line in stdin.split('\\n')[1:H+1]]\n    \n    def is_ad(image: List[List[str]]) -> bool:\n        return any(c in ('$', '#', '+', ',', '.', '!', '?') for row in image for c in row)\n    \n    def smallest_ad(image: List[List[str]]) -> int:\n        min_size = float('inf')\n        for i in range(1, H-1):\n            for j in range(1, W-1):\n                if image[i][j] in ('$', '#', '+', ',', '.', '!'):\n                    size = sum(len(row) for row in image)\n                    min_size = min(min_size, size)\n                    return min_size\n        return min_size\n    \n    def remove_ad(image: List[List[str]]) -> None:\n        if is_ad(image):\n            min_size = smallest_ad(image)\n            for i in range(H):\n                for j in range(W):\n                    if image[i][j] in ('$', '#', '+', ',', '.', '!'):\n                        image[i][j] = ' '\n            for i in range(1, H-1):\n                for j in range(1, W-1):\n                    if image[i][j] == ' ' and all(image[k][l] == ' ' for k in range(i-1, i+2) for l in range(j-1, j+2) if (k != i or l != j)):\n                        image[i][j] = ' '\n    \n    def process_page(pages: List[List[List[str]]]) -> str:\n        for i in range(H):\n            for j in range(W):\n                if pages[i][j] == '+':\n                    remove_ad(pages[i][j+1:H:2])\n        return ''.join(''.join(row) for row in pages)\n    \n    return process_page(pages)"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    web_page = []\n    for _ in range(H):\n        web_page.append(list(stdin.readline().strip()))\n\n    def is_border(x, y):\n        return web_page[x][y] == '$' and \\\n               (web_page[x - 1][y] == '$' or web_page[x + 1][y] == '$' or web_page[x][y - 1] == '$' or web_page[x][y + 1] == '$')\n\n    def is_ad(x, y):\n        if web_page[x][y] not in ['a', 'A', 'b', 'B', 'c', 'C', 'd', 'D', 'e', 'E', 'f', 'F', 'g', 'G', 'h', 'H', 'i', 'I', 'j', 'J', 'k', 'K', 'l', 'L', 'm', 'M', 'n', 'N', 'o', 'O', 'p', 'P', 'q', 'Q', 'r', 'R', 's', 'S', 't', 'T', 'u', 'U', 'v', 'V', 'w', 'W', 'x', 'X', 'y', 'Y', 'z', 'Z', '?', '!', ',', '.', ' ']:\n            return False\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                if web_page[x + dx][y + dy] == '$':\n                    return True\n        return False\n\n    def remove_ad(x, y):\n        if not is_border(x, y):\n            web_page[x][y] = ' '\n            for dx in range(-1, 2):\n                for dy in range(-1, 2):\n                    if web_page[x + dx][y + dy] == '+':\n                        web_page[x + dx][y + dy] = ' '\n\n    for x in range(1, H - 1):\n        for y in range(1, W - 1):\n            if web_page[x][y] == '$' and is_border(x, y):\n                if is_ad(x, y):\n                    remove_ad(x, y)\n\n    return ''.join([''.join(row) for row in web_page])\n"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0:2])\n    page = []\n    for i in range(H):\n        line = stdin.split(\"\\n\")[i+1]\n        page.append(line)\n\n    def is_image(row, col, img):\n        if not ('$' in img and '+' in img):\n            return False\n        if img.count('$') != 4 or img.count('+') != 4:\n            return False\n        if row != 0 and '$' in page[row-1][col:col+4]:\n            return False\n        if row != H-1 and '$' in page[row+1][col:col+4]:\n            return False\n        if col != 0 and '$' in [line[col-1] for line in page[row:row+2]]:\n            return False\n        if col != W-1 and '$' in [line[col+1] for line in page[row:row+2]]:\n            return False\n        return True\n\n    def find_smallest_image(img):\n        start = 0\n        smallest = float('inf')\n        for i in range(len(img)):\n            if img[i] != ' ':\n                start = i\n                break\n        for i in range(start+1, len(img)):\n            if img[i] != ' ':\n                size = 0\n                for j in range(i, len(img)):\n                    if img[j] != ' ':\n                        size += 1\n                    else:\n                        break\n                if size < smallest:\n                    smallest = size\n        return smallest\n\n    def remove_ad(row, col, img):\n        img = list(img)\n        size = find_smallest_image(img)\n        for i in range(col, col+4):\n            for j in range(row, row+4):\n                if img[i][j] != ' ':\n                    img[i] = img[i][:j] + ' ' + img[i][j+1:]\n                    img[i] = img[i][:size] + ' ' * size + img[i][size+1:]\n                    break\n        return ''.join(img)\n\n    def process_page(page):\n        for i in range(H):\n            for j in range(W):\n                if page[i][j] in '!?,. ':\n                    page[i] = page[i][:j] + ' ' + page[i][j+1:]\n        return page\n\n    page = process_page(page)\n    changed = True\n    while changed:\n        changed = False\n        for i in range(H-1):\n            for j in range(W-1):\n                img = page[i][j] + page[i][j+1] + page[i+1][j] + page[i+1][j+1]\n                if is_image(i, j, img):\n                    page[i] = page[i][:j] + ' ' * 4 + page[i][j+4:]\n                    page[i+1] = page[i+1][:j+1] + ' ' * 4 + page[i+1][j+5:]\n                    page[i+2] = page[i+2][:j+2] + ' ' * 4 + page[i+2][j+6:]\n                    page[i+3] = page[i+3][:j+3] + ' ' * 4 + page[i+3][j+7:]\n                    changed = True\n        page = process_page(page)\n    return ''.join([line.rstrip() for line in page])"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0].split(','))\n    web_page = stdin.split('\\n')\n    ad_chars = set(['?', '!', ',', '.', ' '])\n    image_chars = set(['$'])\n    ads = []\n    img_count = 0\n    min_img_count = float('inf')\n    min_img_area = float('inf')\n    min_img = None\n    min_img_border_char = None\n    img_border_char = '$'\n    for i in range(H):\n        for j in range(W):\n            if web_page[i][j] == img_border_char and web_page[i][max(j - 1, 0)] != img_border_char and web_page[i][min(j + 1, W - 1)] != img_border_char and web_page[max(i - 1, 0)][j] != img_border_char and web_page[min(i + 1, H - 1)][j] != img_border_char:\n                img_count += 1\n                img_area = 0\n                img_area += 1  # Add border\n                img_x, img_y = j + 1, i + 1\n                while img_x < min(j + 1 + W, W) and web_page[img_x][img_y] == img_border_char:\n                    img_area += 1\n                    img_x += 1\n                while img_y < min(i + 1 + H, H) and web_page[img_x][img_y] == img_border_char:\n                    img_area += 1\n                    img_y += 1\n                if img_area < min_img_area:\n                    min_img_area = img_area\n                    min_img_count = img_count\n                    min_img = (i, j, img_x - 1, img_y - 1)\n                    min_img_border_char = web_page[i][j]\n\n    if min_img_count == float('inf'):\n        return ''.join([line for line in web_page])\n\n    for i in range(min_img[0], min_img[2] + 1):\n        for j in range(min_img[1], min_img[3] + 1):\n            if web_page[i][j] in ad_chars:\n                img_count -= 1\n            if web_page[i][j] == min_img_border_char:\n                img_count = 0\n            if img_count == 0 and web_page[i][j] in image_chars:\n                ads.append((min_img[1], min_img[0], min_img[3], min_img[2]))\n                for a in range(min_img[1], min_img[3] + 1):\n                    for b in range(min_img[0], min_img[2] + 1):\n                        web_page[a][b] = ' '\n\n    for ad in ads:\n        for i in range(ad[2] - ad[0] + 1):\n            for j in range(ad[3] - ad[1] + 1):\n                web_page[ad[0] + i][ad[1] + j] = ' '\n\n    return ''.join([''.join(line) for line in web_page])\n"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from typing import List\n\n    def is_valid_image(image: List[str]) -> bool:\n        if len(image) < 3 or len(image[0]) < 3:\n            return False\n        for i in range(1, len(image) - 1):\n            if '+$' not in (image[0][1:-1], image[-1][1:-1], ''.join(row[1:-1] for row in image[1:-1])):\n                return False\n        return True\n\n    def find_smallest_ad(image: List[str]) -> int:\n        ad_pixels = set()\n        for i in range(1, len(image) - 1):\n            for j in range(1, len(image[0]) - 1):\n                if image[i][j] not in (' ', '+'):\n                    ad_pixels.add((i, j))\n        return min(ad_pixels, key=lambda x: x[0] * len(image[0]) + x[1])\n\n    def remove_ad(image: List[str], ad_coords: List[int]) -> None:\n        i, j = ad_coords\n        image[i] = image[i][:j + 1].replace(image[i][j], ' ') + image[i][j + 1:].replace(image[i][j], ' ')\n        image[i][0] = ' '\n        image[i][-1] = ' '\n        image[0] = ' ' * len(image[0])\n        image[-1] = ' ' * len(image[-1])\n        for i in range(1, len(image) - 1):\n            for j in range(1, len(image[0]) - 1):\n                if image[i][j] not in (' ', '+'):\n                    image[i] = image[i][:j + 1].replace(image[i][j], ' ') + image[i][j + 1:].replace(image[i][j], ' ')\n                    image[i][j] = ' '\n\n    lines = stdin.strip().split('\\n')\n    height, width = map(int, lines[0].split())\n    web_page = [list(line) for line in lines[1:]]\n\n    images = []\n    for i in range(height - 1):\n        for j in range(width - 1):\n            if '+$' in (web_page[i][j], web_page[i][j + 1], web_page[i + 1][j], web_page[i + 1][j + 1]) and is_valid_image(web_page[i:i + 3] + [web_page[i + 1][j:j + 3]] + web_page[i + 2:i + 4]):\n                images.append((i, j))\n\n    for i, j in images:\n        remove_ad(web_page[i:i + 3] + [web_page[i + 1][j:j + 3]] + web_page[i + 2:i + 4], find_smallest_ad(web_page[i:i + 3] + [web_page[i + 1][j:j + 3]] + web_page[i + 2:i + 4]))\n\n    return ''.join(''.join(row) for row in web_page)\n"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    h_count = stdin.count('H')\n    t_count = n - h_count\n\n    # Compute the probability of each state\n    p_h = h_count / n\n    p_t = t_count / n\n\n    # Compute the probability of stopping\n    p_stop_h = 1 - (1 - p_t)**h_count\n    p_stop_t = 1 - (1 - p_h)**t_count\n\n    # Compute the average number of operations\n    avg_ops = (h_count * p_stop_h + t_count * p_stop_t) / (p_h + p_t)\n\n    return str(avg_ops)"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    from math import sqrt\n\n    def hunt_tails(tail_coin_count):\n        if tail_coin_count == 0:\n            return 1\n        return 2 * hunt_tails(tail_coin_count - 1) - 1\n\n    def average_hunt_tails(tail_coin_count):\n        return (hunt_tails(tail_coin_count) + tail_coin_count - 1) / (tail_coin_count - 1) if tail_coin_count > 1 else 1\n\n    def hunt_coins(stdin: str):\n        coins = deque(stdin)\n        count = 0\n        while len(coins) > 0:\n            count += 1\n            if coins[0] == 'H':\n                coins.popleft()\n            else:\n                break\n        return count\n\n    def average_hunt_coins(stdin: str):\n        coins = list(stdin)\n        total_count = 0\n        total_sum = 0\n        for i in range(len(coins) - 1):\n            if coins[i] == 'H' and coins[i + 1] == 'T':\n                total_count += 1\n                total_sum += hunt_coins(coins[i:])\n        return total_sum / total_count if total_count > 0 else 1\n\n    tail_count = stdin.count('H')\n    tail_count_avg = average_hunt_tails(tail_count)\n    hunt_coin_avg = average_hunt_coins(stdin)\n\n    return tail_count_avg * hunt_coin_avg"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    pass"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def l(c: str) -> int:\n        n = len(c)\n        k = c.count(\"H\")\n        if k == 0:\n            return 0\n        return k * 2 + n - k - 1\n\n    stdin = stdin.replace(\"?\", \"T\")\n    return str(sum(l(c) for c in stdin) / len(stdin))\n"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_operations(coins: list) -> int:\n        k = 0\n        for i, coin in enumerate(coins):\n            if coin == 'H':\n                k += 1\n            else:\n                if k == 0:\n                    return i + 1\n                else:\n                    k = 0\n        return len(coins)\n\n    def average_operations(sequence: str) -> float:\n        n = len(sequence)\n        count_H = sequence.count('H')\n        count_T = sequence.count('T')\n        count_unknown = sequence.count('?')\n        if count_unknown == 0:\n            return 0\n\n        coins = ['T'] * count_T + ['H'] * count_H\n        i = 0\n        while i < n:\n            if sequence[i] == '?':\n                coins.insert(i, 'T')\n                i += 1\n            i += 1\n\n        operations = calculate_operations(coins)\n        average = operations / count_unknown\n        return average\n\n    avg = 0\n    for s in stdin.split():\n        avg += average_operations(s)\n    avg /= len(stdin.split())\n\n    return '{:.6f}'.format(avg)\n"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def L(C: str) -> int:\n        k = 0\n        for c in C:\n            if c == 'H':\n                k += 1\n            else:\n                break\n        return k\n\n    def average(total: int, count: int) -> float:\n        return total / count if count > 0 else 0\n\n    def process(C: str, k: int) -> str:\n        if k <= 0:\n            return C\n        else:\n            return C[:k - 1] + 'T' + C[k:]\n\n    def solve(S: str) -> float:\n        total_length = 0\n        total_count = 0\n\n        for i in range(len(S)):\n            if S[i] == '?':\n                continue\n            C = S[:i] + 'H' + S[i + 1:]\n            k = L(C)\n            C = process(C, k)\n            total_length += len(C)\n            total_count += 1\n\n        return average(total_length, total_count)\n\n    result = solve(stdin)\n    return str(result)\n\n\ninput_data = input()\nprint(solution(input_data)) "
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_average_L(S: str):\n        total_L = 0\n        total_count = 0\n        for i in range(len(S)):\n            if S[i] == 'H':\n                total_L += i + 1\n                total_count += 1\n            elif S[i] == 'T':\n                total_count += 1\n        if total_count == 0:\n            return 0\n        return total_L / total_count\n\n    S = stdin.strip()\n    if len(S) > 10**6:\n        return \"Error: Input string is too long\"\n\n    if '?' in S:\n        return str(find_average_L(S.replace('?', 'T')))\n    else:\n        return str(find_average_L(S))"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_h_count(seq: str) -> int:\n        return seq.count('H')\n\n    def find_operations_to_stop(n: int, k: int, stdin: str) -> int:\n        count_h = find_h_count(stdin)\n        if count_h == k:\n            return n\n        else:\n            return n - count_h - 1\n\n    def solve(stdin: str) -> float:\n        n = len(stdin)\n        result = 0\n        for k in range(n):\n            result += find_operations_to_stop(n, k, stdin)\n        return result / n\n\n    return str(solve(stdin))\n"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_operations(seq: str) -> int:\n        count = 0\n        for i, char in enumerate(seq):\n            if char == 'H':\n                count += 1\n            elif count > 0:\n                count -= 1\n                if char == 'T':\n                    return count\n        return count\n\n    total_operations = 0\n    total_count = 0\n    for char in stdin:\n        if char == 'H' or char == 'T':\n            total_operations += count_operations(stdin[:total_count+1])\n            total_count += 1\n    return total_operations / total_count if total_count > 0 else 0"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_operations(stdin: str) -> int:\n        count = 0\n        i = 0\n        while i < len(stdin):\n            if stdin[i] == '?':\n                i += 1\n            elif stdin[i] == 'T':\n                i += 1\n            else:\n                count += 1\n                i += 2\n        return count\n\n    def average_operations(stdin: str) -> float:\n        operations = []\n        for i in range(len(stdin)):\n            for j in range(i + 1, len(stdin) + 1):\n                substring = stdin[i:j]\n                operations.append(count_operations(substring))\n        return sum(operations) / len(operations)\n\n    return str(average_operations(stdin))\n"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    target = [[int(c) for c in line] for line in stdin.splitlines()[1:]]\n    picture = [[0 for _ in range(N)] for _ in range(N)]\n\n    def paint(i, j, prev_diff):\n        if i == N:\n            nonlocal diff\n            if diff > prev_diff:\n                diff = prev_diff\n            return\n\n        for k in range(4):\n            x = i + (k // 2) * ((i + 1) % 2)\n            y = j + (k % 2) * ((j + 1) % 2)\n            picture[x][y] = 1 - picture[x][y]\n            diff = paint(x, y, prev_diff + 1)\n            picture[x][y] = 1 - picture[x][y]\n\n    diff = N * N\n    for i in range(N):\n        for j in range(N):\n            picture[i][j] = 1 - target[i][j]\n            paint(0, 0, diff)\n            if diff < min_diff:\n                min_diff = diff\n                result = [['0' if picture[i][j] == 0 else '1' for j in range(N)] for i in range(N)]\n\n    result = [str(row) for row in result]\n    return f'{min_diff}\\n' + '\\n'.join(result)\n"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    target_picture = [[int(i) for i in row] for row in input_list[1:]]\n\n    def paint_picture(picture, x, y):\n        if x == 0 and y == 0:\n            return picture\n        elif x == 0:\n            picture[y][y] = 0\n            return paint_picture(picture, x, y - 1)\n        elif y == 0:\n            picture[x][x] = 1\n            return paint_picture(picture, x - 1, y)\n        else:\n            white_square = picture[x - 1][y - 1]\n            black_square = picture[x][y - 1] ^ white_square\n            if white_square == 1:\n                picture[x - 1][y - 1] = 0\n            else:\n                picture[x - 1][y - 1] = 1\n            if black_square == 1:\n                picture[x][y - 1] = 0\n            else:\n                picture[x][y - 1] = 1\n            return paint_picture(picture, x - 1, y - 1)\n\n    painted_picture = [[0 for _ in range(n)] for _ in range(n)]\n    difference = paint_picture(painted_picture, n, n)\n    output = [str(difference)]\n    output.extend([''.join(map(str, row)) for row in painted_picture])\n    return '\\n'.join(output)"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    target = [list(map(int, input_lines[i + 1].strip())) for i in range(N)]\n\n    def split_square(square: list) -> list:\n        mid = N // 2\n        top_left = square[:mid]\n        top_right = square[mid:]\n        bottom_left = square[:mid] + [0] * (N - mid)\n        bottom_right = square[mid:] + [1] * (N - mid)\n        return [top_left, top_right, bottom_left, bottom_right]\n\n    def paint_square(square: list) -> tuple:\n        white_count = sum(square.count(0))\n        black_count = sum(square.count(1))\n        if white_count > black_count:\n            square[square.index(1)] = 0\n        else:\n            square[square.index(0)] = 1\n        return square\n\n    def paint(square: list, depth: int) -> None:\n        if depth == 0:\n            return\n        split_squares = split_square(square)\n        for i in range(4):\n            if i % 2 == 0:\n                split_squares[i] = paint_square(split_squares[i])\n            else:\n                split_squares[i] = paint_square(split_squares[i])\n        for i in range(4):\n            paint(split_squares[i], depth - 1)\n\n    paint(target, N)\n\n    # Calculate the difference between the target and the painted picture\n    def calculate_difference(sq1: list, sq2: list) -> int:\n        diff_count = 0\n        for i in range(N):\n            for j in range(N):\n                if sq1[i][j] != sq2[i][j]:\n                    diff_count += 1\n        return diff_count\n\n    painted = [[target[i][j] for j in range(N)] for i in range(N)]\n    min_diff = calculate_difference(target, painted)\n\n    # Find the painted picture with the minimum difference\n    def find_painted_picture(square: list, depth: int, painted: list) -> None:\n        if depth == 0:\n            return\n        split_squares = split_square(square)\n        for i in range(4):\n            if i % 2 == 0:\n                split_squares[i] = paint_square(split_squares[i])\n            else:\n                split_squares[i] = paint_square(split_squares[i])\n        for i in range(4):\n            find_painted_picture(split_squares[i], depth - 1, painted)\n\n        # Check if the painted picture with the minimum difference has been found\n        for i in range(N):\n            for j in range(N):\n                if target[i][j] != painted[i][j]:\n                    if calculate_difference(target, painted) < min_diff:\n                        min_diff = calculate_difference(target, painted)\n                        return\n\n    find_painted_picture(target, N, painted)\n\n    # Output the minimum difference and the painted picture\n    output = [str(min_diff)]\n    for i in range(N):\n        output.append(\"\".join(map(str, painted[i])))\n    output = \"\\n\".join(output)\n    return output\n"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    target_picture = [[int(c) for c in line] for line in stdin.splitlines()[1:]]\n    painted_picture = [[0 for _ in range(N)] for _ in range(N)]\n\n    def paint_helper(painting_square: int, target_square: int, painted_square: int) -> int:\n        if N == 1:\n            return 0 if target_square == painted_square else 1\n\n        diff = 0\n        for i in range(2):\n            for j in range(2):\n                if target_square & (1 << (2 * i + j)) == 0:\n                    painted_picture[painting_square * 2 + i][painting_square * 2 + j] = 0\n                else:\n                    diff += 1\n                    painted_picture[painting_square * 2 + i][painting_square * 2 + j] = 1\n\n        if target_square == painted_square:\n            return diff\n        elif painted_square == 0:\n            return diff + paint_helper(painting_square * 2 + 1, target_square & 3, 1)\n        elif painted_square == 1:\n            return diff + paint_helper(painting_square * 2 + 1, target_square & 3 ^ 3, 0)\n\n    min_diff = N * N\n    for i in range(2):\n        for j in range(2):\n            diff = paint_helper(0, target_picture[i][j], i + 2 * j)\n            min_diff = min(min_diff, diff)\n\n    return min_diff, *([''.join(str(p) for p in row) for row in painted_picture])\n"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    target_picture = [[int(i) for i in input_list[j]] for j in range(1, n+1)]\n    white_count = sum([sum(row) for row in target_picture])\n    black_count = n*n - white_count\n    \n    def paint(picture, target_picture, white_count, black_count):\n        if len(picture) == 1:\n            for i in range(len(picture[0])):\n                picture[0][i] = target_picture[0][i]\n            return picture, white_count, black_count\n        else:\n            for i in range(len(picture)//2):\n                for j in range(len(picture[0])//2):\n                    if white_count >= black_count:\n                        picture[i][j] = 1\n                        white_count += 1\n                    else:\n                        picture[i][j] = 0\n                        black_count += 1\n            for i in range(len(picture)//2, len(picture)):\n                for j in range(len(picture[0])//2, len(picture[0])):\n                    if white_count >= black_count:\n                        picture[i][j] = 1\n                        white_count += 1\n                    else:\n                        picture[i][j] = 0\n                        black_count += 1\n            for i in range(len(picture)):\n                for j in range(len(picture[0])//2):\n                    if white_count >= black_count:\n                        picture[i][j+len(picture[0])//2] = 1\n                        white_count += 1\n                    else:\n                        picture[i][j+len(picture[0])//2] = 0\n                        black_count += 1\n            for i in range(len(picture)//2):\n                for j in range(len(picture[0])//2, len(picture[0])):\n                    if white_count >= black_count:\n                        picture[i+len(picture)//2][j] = 1\n                        white_count += 1\n                    else:\n                        picture[i+len(picture)//2][j] = 0\n                        black_count += 1\n            return paint(picture, target_picture, white_count, black_count)\n\n    painted_picture, white_count, black_count = paint([[0 for _ in range(n)] for _ in range(n)], target_picture, white_count, black_count)\n    painted_picture = [[str(i) for i in row] for row in painted_picture]\n    difference = sum([sum(row) for row in painted_picture]) - white_count\n    \n    return str(difference) + '\\n' + '\\n'.join([''.join(row) for row in painted_picture]) + '\\n'"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    target = []\n    for i in range(1, N+1):\n        target.append(list(input_list[i]))\n\n    def paint(square):\n        white_pixels = sum(1 for row in square for pixel in row if pixel == '1')\n        black_pixels = N*N - white_pixels\n        return white_pixels, black_pixels\n\n    def recurse(square, white_pixels, black_pixels):\n        if len(square) == 1:\n            return white_pixels, black_pixels\n\n        white_pixels_new, black_pixels_new = [], []\n        for i in range(2):\n            for j in range(2):\n                square_new = []\n                for row in range(len(square)//2):\n                    square_new.append(square[row][2*i:2*i+2])\n                square_new = [''.join(row) for row in square_new]\n                white_pixels_new.append(paint(square_new)[0])\n                black_pixels_new.append(paint(square_new)[1])\n\n        min_diff = min(white_pixels_new[0] + black_pixels_new[1], white_pixels_new[1] + black_pixels_new[0])\n        if white_pixels + black_pixels > min_diff:\n            return min_diff, white_pixels_new[0] * '0' + '1' + white_pixels_new[1] * '0' + '1'\n        else:\n            return min_diff, white_pixels_new[1] * '0' + '1' + white_pixels_new[0] * '0' + '1'\n\n    white_pixels, black_pixels = paint(target)\n    min_diff = white_pixels + black_pixels\n    min_diff_new, picture = recurse(target, white_pixels, black_pixels)\n\n    return min_diff, [picture]"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    target_picture = [list(line) for line in input_list[1:]]\n\n    def paint_picture(picture, i, j):\n        if picture[i][j] == \"1\":\n            return \"1\"\n        white_square = (i + 1) // 2 * 2, (j + 1) // 2 * 2\n        black_squares = [(i + 1) // 2 * 2 - 1, (i + 1) // 2 * 2, (j + 1) // 2 * 2 - 1, (j + 1) // 2 * 2]\n        for square in black_squares:\n            if picture[square[0]][square[1]] == \"0\":\n                picture[square[0]][square[1]] = \"1\"\n                return \"1\"\n        white_square = white_square[0] // 2 * 2, white_square[1] // 2 * 2\n        paint_picture(picture, white_square[0], white_square[1])\n        return \"1\"\n\n    painted_picture = []\n    for i in range(n):\n        row = []\n        for j in range(n):\n            row.append(paint_picture(target_picture, i, j))\n        painted_picture.append(\"\".join(row))\n\n    # Calculate difference\n    difference = 0\n    for i in range(n):\n        for j in range(n):\n            if painted_picture[i][j] != target_picture[i][j]:\n                difference += 1\n\n    output = str(difference) + \"\\n\" + \"\\n\".join(painted_picture)\n    return output\n\ninput_list = \"\"\"4\n0001\n0001\n0011\n1110\"\"\".split(\"\\n\")\nstdin = \"\\n\".join(input_list)\noutput = solution(stdin)\nprint(output)"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def paint_picture(N: int, picture: List[List[int]]) -> List[List[int]]:\n        if N == 1:\n            return picture\n        else:\n            new_picture = [[0] * N for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    if i == 0 or i == N - 1 or j == 0 or j == N - 1:\n                        new_picture[i][j] = picture[i][j]\n                    else:\n                        k = (i + j) % 2\n                        if picture[i][j] == 0:\n                            new_picture[i][j] = 1\n                        else:\n                            new_picture[i][j] = 0\n            return new_picture\n\n    def count_differences(picture1: List[List[int]], picture2: List[List[int]]) -> int:\n        difference = 0\n        for i in range(N):\n            for j in range(N):\n                if picture1[i][j] != picture2[i][j]:\n                    difference += 1\n        return difference\n\n    N = int(input())\n    picture = [list(map(int, input().split())) for _ in range(N)]\n\n    minimum_difference = 100000000\n    for i in range(2 ** N):\n        binary = format(i, f'0{N}b')\n        new_picture = paint_picture(N, [[int(binary[i])] * N for i in range(N)])\n        difference = count_differences(picture, new_picture)\n        if difference < minimum_difference:\n            minimum_difference = difference\n\n    return minimum_difference, *paint_picture(N, [[int(binary[i])] * N for i in range(N)])\n"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    target_picture = [[int(i) for i in input_data[j+1]] for j in range(N)]\n\n    def color_pixels(picture, steps=1):\n        if len(picture) == 1:\n            return 0, picture\n        else:\n            min_diff = float('inf')\n            min_picture = None\n            for i in range(2):\n                for j in range(2):\n                    for k in range(2):\n                        for l in range(2):\n                            new_picture = [[picture[x][y] for x in range(2*i, 2*i+2)] for y in range(2*j, 2*j+2)]\n                            new_picture[0][0] = 0\n                            new_picture[0][1] = 1\n                            new_picture[1][0] = 1\n                            new_picture[1][1] = 0\n                            diff = color_pixels(new_picture, steps+1)[0]\n                            if diff < min_diff:\n                                min_diff = diff\n                                min_picture = new_picture\n            return min_diff, min_picture\n\n    min_diff, min_picture = color_pixels(target_picture)\n    output = str(min_diff) + '\\n'\n    output += '\\n'.join([''.join([str(i) for i in row]) for row in min_picture])\n    return output\n\ninput_data = \"\"\"4\n0001\n0001\n0011\n1110\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    N = int(input_lines[0])\n    target = [[int(c) for c in input_lines[i + 1]] for i in range(N)]\n\n    def paint_picture(picture, target):\n        if N == 1:\n            return target[0][0]\n        else:\n            new_picture = [[0 for _ in range(N // 2)] for _ in range(N // 2)]\n            for i in range(N // 2):\n                for j in range(N // 2):\n                    new_picture[i][j] = 1 if (i * 2 + j) % 2 == 1 else 0\n            for i in range(N // 2):\n                for j in range(N // 2):\n                    if new_picture[i][j] == 1:\n                        picture[i][j] = 1\n                        target[i][j] = 1\n                    else:\n                        picture[i][j] = 0\n                        target[i][j] = 0\n            return new_picture\n\n    def count_differences(picture):\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if picture[i][j] != target[i][j]:\n                    count += 1\n        return count\n\n    picture = [[0 for _ in range(N)] for _ in range(N)]\n    while True:\n        new_picture = paint_picture(picture, target)\n        if new_picture == picture:\n            break\n        picture = new_picture\n\n    result = count_differences(picture)\n    picture_str = '\\n'.join([''.join(map(str, row)) for row in picture])\n    return result, picture_str\n\n\ndef"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pulses = []\n    for i in range(1, n+1):\n        pulse_info = stdin.split('\\n')[i].split(' ')\n        direction = pulse_info[0]\n        start_time = int(pulse_info[1])\n        length = int(pulse_info[2])\n        wire_number = int(pulse_info[3])\n        pulses.append((direction, start_time, length, wire_number))\n\n    grid_height = 1 + max(pulse[2] for pulse in pulses)\n    grid_width = 1 + max(pulse[3] for pulse in pulses)\n\n    grid = [['.' for _ in range(grid_width)] for _ in range(grid_height)]\n\n    for pulse in pulses:\n        direction, start_time, length, wire_number = pulse\n        if direction == 'h':\n            for i in range(start_time, start_time + length):\n                grid[wire_number][i] = 'x'\n        else:\n            for i in range(start_time, start_time + length):\n                grid[i][wire_number] = 'x'\n\n    active_pixels = sum(sum(1 for cell in row if cell == 'x') for row in grid)\n    return str(active_pixels)\n"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    pulses = [line.split() for line in stdin.split(\"\\n\")[1:]]\n\n    def pixel_activated(pulse, wire_num, wire_pos):\n        start_time, pulse_len, a = int(pulse[1]), int(pulse[2]), int(pulse[3])\n        if a == wire_num and start_time <= wire_pos <= start_time + pulse_len:\n            return True\n        return False\n\n    horizontal_wires = [1]\n    vertical_wires = [1]\n    horizontal_pos = 1\n    vertical_pos = 1\n\n    for pulse in pulses:\n        direction, start_time, pulse_len, wire_num = pulse\n\n        if direction == \"h\":\n            for i in range(horizontal_pos, len(horizontal_wires) + 1):\n                if pixel_activated(pulse, wire_num, i):\n                    break\n            horizontal_wires.append(wire_num)\n            horizontal_pos += 1\n        else:\n            for i in range(vertical_pos, len(vertical_wires) + 1):\n                if pixel_activated(pulse, wire_num, i):\n                    break\n            vertical_wires.append(wire_num)\n            vertical_pos += 1\n\n    return len(horizontal_wires) * len(vertical_wires)"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    pulses = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    pulses.sort(key=lambda x: (-x[1], x[0]))\n    grid = [[0] * 200001 for _ in range(200001)]\n    activated = set()\n\n    for pulse in pulses:\n        if pulse[0] == 'h':\n            for i in range(pulse[1], pulse[1] + pulse[2]):\n                grid[i][pulse[3]] = 1\n        else:\n            for i in range(pulse[1], pulse[1] + pulse[2]):\n                grid[pulse[3]][i] = 1\n\n    for i in range(1, 200001):\n        for j in range(1, 200001):\n            if grid[i][j] == 1 and grid[i + 1][j] == 1 and grid[i][j + 1] == 1:\n                activated.add((i, j))\n\n    return str(len(activated))\n"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_activated_pixels(rows, cols, pulses):\n        pixels = [[False for _ in range(cols + 1)] for _ in range(rows + 1)]\n        for pulse in pulses:\n            direction, start_time, length, wire = pulse\n            if direction == 'h':\n                for i in range(start_time, start_time + length):\n                    pixels[wire][i] = True\n            else:\n                for i in range(start_time, start_time + length):\n                    pixels[i][wire] = True\n        activated_pixels = 0\n        for row in pixels[:-1]:\n            for pixel in row[:-1]:\n                if pixel:\n                    activated_pixels += 1\n        return activated_pixels\n\n    def parse_input(input_str: str) -> list:\n        pulses = []\n        lines = input_str.split('\\n')\n        for line in lines:\n            direction, start_time, length, wire = line.split()\n            pulses.append((direction, int(start_time), int(length), int(wire)))\n        return pulses\n\n    rows = 200\n    cols = 200\n    pulses = parse_input(stdin)\n    activated_pixels = get_activated_pixels(rows, cols, pulses)\n    return str(activated_pixels)\n"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    activated = set()\n    for _ in range(n):\n        direction, start_time, length, wire_num = input().split()\n        start_time, length, wire_num = int(start_time), int(length), int(wire_num)\n        if direction == 'h':\n            for t in range(start_time, start_time + length):\n                activated.add((t, wire_num))\n        elif direction == 'v':\n            for t in range(start_time, start_time + length):\n                activated.add((wire_num, t))\n\n    activated_pixels = set()\n    for t in range(1, 200001):\n        for wire_num in range(1, 200001):\n            if (t, wire_num) in activated:\n                activated_pixels.add((wire_num, t))\n\n    last_pulse_time = max(activated, key=lambda x: x[1])[1]\n    remaining_pixels = set()\n    for wire_num in range(1, 200001):\n        for t in range(last_pulse_time + 1, 200001):\n            if (t, wire_num) in activated:\n                remaining_pixels.add((wire_num, t))\n\n    return len(remaining_pixels)\n\ndef"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    data = [line.split() for line in data]\n    data = [[direction, int(t), int(m), int(a)] for direction, t, m, a in data]\n\n    grid = [['#' for _ in range(n+1)] for _ in range(n+1)]\n\n    def is_activated(pixel: tuple) -> bool:\n        x, y = pixel\n        if x < 1 or y < 1:\n            return False\n        if x > n or y > n:\n            return False\n        return grid[x][y] == '#'\n\n    def activate_pixel(pixel: tuple) -> None:\n        x, y = pixel\n        grid[x][y] = ' '\n\n    def check_pixel(pixel: tuple) -> bool:\n        x, y = pixel\n        if x == n + 1 or y == n + 1:\n            return False\n        return is_activated(pixel)\n\n    def check_pixel_activation(pixel: tuple) -> bool:\n        x, y = pixel\n        return check_pixel((x+1, y)) and check_pixel((x, y+1))\n\n    def process_pulse(direction: str, t: int, m: int, a: int) -> None:\n        if direction == 'h':\n            x, y = a, t\n            for i in range(m):\n                if check_pixel_activation((x, y+i)):\n                    activate_pixel((x, y+i))\n        else:\n            x, y = t, a\n            for i in range(m):\n                if check_pixel_activation((x+i, y)):\n                    activate_pixel((x+i, y))\n\n    for _ in range(n):\n        _, *data = stdin.split('\\n')\n        direction, t, m, a = data\n        process_pulse(direction, int(t), int(m), int(a))\n\n    activated_pixels = sum(row.count('#') for row in grid)\n    return str(activated_pixels)"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *input_data = stdin.split('\\n')\n    n = int(n)\n    input_data = [line.split() for line in input_data]\n\n    def count_activated_pixels(pulses):\n        pixel_activations = [False] * (n + 1)\n        for pulse in pulses:\n            direction, t, m, a = pulse\n            if direction == 'v':\n                y = n - t\n                for x in range(m):\n                    if pixel_activations[y - x] and pixel_activations[y + x]:\n                        pixel_activations[y + x] = False\n            else:\n                x = n - t\n                for y in range(m):\n                    if pixel_activations[x - y] and pixel_activations[x + y]:\n                        pixel_activations[x + y] = False\n        return sum(pixel_activations)\n\n    activated_pixels = count_activated_pixels(input_data)\n    return str(activated_pixels)\n"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, *input_data = stdin.split('\\n')\n    n = int(n)\n    input_data = [line.split() for line in input_data]\n\n    pixels_activated = 0\n    for direction, start_time, pulse_length, wire_number in input_data:\n        direction = 1 if direction == 'h' else 2\n        start_time = int(start_time)\n        pulse_length = int(pulse_length)\n        wire_number = int(wire_number)\n\n        end_time = start_time + pulse_length\n\n        if start_time == 1 and end_time == 1:\n            pixels_activated += (wire_number - 1) * (n - 1)\n        elif start_time == 1:\n            pixels_activated += (wire_number - 1) * (n - start_time)\n        elif end_time == 1:\n            pixels_activated += (wire_number - 1) * (1 - end_time)\n        else:\n            pixels_activated += (wire_number - 1) * (end_time - start_time)\n\n    return str(pixels_activated)"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_pixel_activated(pulse_start, pulse_length, row, col):\n        leading_edge = pulse_start\n        trailing_edge = pulse_start + pulse_length\n        if row >= leading_edge and row < trailing_edge and col >= leading_edge and col < trailing_edge:\n            return True\n        return False\n\n    def count_activated_pixels(pulses):\n        rows, cols = 0, 0\n        for pulse in pulses:\n            if pulse[0] == 'h':\n                rows += pulse[2]\n            else:\n                cols += pulse[2]\n        return rows, cols\n\n    def is_valid(pulses):\n        rows, cols = count_activated_pixels(pulses)\n        if rows > cols:\n            return False\n        if rows == 1:\n            return True\n        return False\n\n    def find_last_pulse_of_current(pulses):\n        last_pulse = max(pulses, key=lambda x: x[1] + x[2])\n        return last_pulse[1] + last_pulse[2]\n\n    n = int(stdin.split('\\n')[0])\n    pulses = [list(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    if not is_valid(pulses):\n        return \"Invalid schedule\"\n\n    last_pulse_of_current = find_last_pulse_of_current(pulses)\n    rows, cols = count_activated_pixels(pulses)\n\n    activated_pixels = 0\n    for i in range(1, last_pulse_of_current + 1):\n        for j in range(1, last_pulse_of_current + 1):\n            if is_pixel_activated(i, j, rows, cols):\n                activated_pixels += 1\n\n    return activated_pixels\n\n\ndef"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_pixel_activated(row: int, col: int, pixel_rows: List[int], pixel_cols: List[int]) -> bool:\n        return row in pixel_rows and col in pixel_cols\n\n    def process_pulse(pulse: str, current_time: int, pixel_rows: List[int], pixel_cols: List[int]) -> None:\n        direction, start_time, length, wire_number = pulse.split()\n        start_time = int(start_time)\n        length = int(length)\n        wire_number = int(wire_number)\n\n        if direction == 'h':\n            pixel_rows.append(wire_number)\n            if start_time + length - 1 <= current_time:\n                pixel_rows.remove(wire_number)\n        else:\n            pixel_cols.append(wire_number)\n            if start_time + length - 1 <= current_time:\n                pixel_cols.remove(wire_number)\n\n    n = int(stdin.split('\\n')[0])\n    pulses = stdin.split('\\n')[1:]\n    pixel_rows = []\n    pixel_cols = []\n    current_time = 0\n\n    for pulse in pulses:\n        process_pulse(pulse, current_time, pixel_rows, pixel_cols)\n        current_time += 1\n\n    num_activated_pixels = sum(is_pixel_activated(row, col, pixel_rows, pixel_cols) for row in range(1, n + 1) for col in range(1, n + 1))\n\n    return str(num_activated_pixels)"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_book_count(state: str) -> int:\n        return len(set(state.replace('0', '')))\n\n    def is_valid(shelf: str, book: int) -> bool:\n        return (shelf.count(str(book)) == 1 and\n                str(book) not in shelf and\n                shelf.count('0') > 0)\n\n    def move_book(shelf: str, book: int, direction: str) -> str:\n        if direction == 'left':\n            return shelf.replace(str(book), '0').replace(str(book), str(book), 1)\n        else:\n            return shelf.replace(str(book), '0').replace(str(book), str(book), -1)\n\n    def lift_books(initial_shelves: str, final_shelves: str) -> int:\n        lifting = 0\n        for i in range(N):\n            for j in range(M):\n                initial_shelf = initial_shelves[i]\n                final_shelf = final_shelves[i]\n                if initial_shelf[j] != final_shelf[j]:\n                    lifting += 1\n                    initial_book = initial_shelf[j]\n                    final_book = final_shelf[j]\n                    initial_shelves[i] = move_book(initial_shelves[i], initial_book, 'left')\n                    final_shelves[i] = move_book(final_shelves[i], final_book, 'right')\n        return lifting\n\n    stdin = stdin.splitlines()\n    N, M = map(int, stdin.pop(0).split())\n    initial_shelves = stdin[:N]\n    final_shelves = stdin[N:]\n\n    lifting = 0\n    for i in range(N):\n        initial_shelf = initial_shelves[i]\n        final_shelf = final_shelf[i]\n        if initial_shelf != final_shelf:\n            lifting += 1\n            for j in range(M):\n                book = initial_shelf[j]\n                if is_valid(final_shelf, book):\n                    initial_shelves[i] = move_book(initial_shelf, book, 'left')\n                    final_shelves[i] = move_book(final_shelf, book, 'right')\n                    break\n            else:\n                return -1\n\n    lifting += lift_books(initial_shelves, final_shelves)\n    return lifting\n"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def min_lifting_required(current_shelf, wanted_shelf):\n        lifting_count = 0\n        for i in range(M):\n            if current_shelf[i] != wanted_shelf[i]:\n                if current_shelf[i] == 0 or wanted_shelf[i] == 0:\n                    lifting_count += 1\n                else:\n                    return -1\n        return lifting_count\n\n    input_lines = stdin.splitlines()\n    N, M = map(int, input_lines[0].split())\n\n    if N < 1 or N > 1000 or M < 1 or M > 1000:\n        return \"-1\"\n\n    current_shelves = []\n    wanted_shelves = []\n    for i in range(1, N + 1):\n        current_shelves.append(list(map(int, input_lines[i].split())))\n    for i in range(N + 1, 2 * N + 1):\n        wanted_shelves.append(list(map(int, input_lines[i].split())))\n\n    min_lifting_count = float('inf')\n    for i in range(N):\n        lifting_count = min_lifting_required(current_shelves[i], wanted_shelves[i])\n        if lifting_count >= 0 and lifting_count < min_lifting_count:\n            min_lifting_count = lifting_count\n\n    if min_lifting_count == float('inf'):\n        return \"-1\"\n    else:\n        return min_lifting_count\n"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    initial_state = [list(map(int, input().split())) for i in range(N)]\n    final_state = [list(map(int, input().split())) for i in range(N)]\n\n    def is_valid(i: int, j: int, shelf_1: list, shelf_2: list) -> bool:\n        if i == 0:\n            return shelf_2[j] == 0\n        if j == 0:\n            return shelf_2[i - 1] == 0\n        return shelf_2[j] == 0 or (shelf_2[j] == shelf_1[i - 1][j - 1] and shelf_1[i - 1][j - 1] != 0)\n\n    def count_lifting(shelf_1: list, shelf_2: list) -> int:\n        lifting = 0\n        for i in range(N):\n            for j in range(M):\n                if shelf_1[i][j] != shelf_2[i][j]:\n                    lifting += 1\n        return lifting\n\n    def lift_book(i: int, j: int, shelf_1: list, shelf_2: list) -> bool:\n        if not is_valid(i, j, shelf_1, shelf_2):\n            return False\n        if shelf_2[i][j] != 0:\n            shelf_2[i][j], shelf_1[i][j] = shelf_1[i][j], shelf_2[i][j]\n            return True\n        return False\n\n    def move_book(i: int, j: int, shelf_1: list, shelf_2: list) -> bool:\n        if not is_valid(i, j, shelf_1, shelf_2):\n            return False\n        if shelf_1[i][j] == 0:\n            return False\n        if shelf_2[i][j] == 0:\n            shelf_2[i][j] = shelf_1[i][j]\n            shelf_1[i][j] = 0\n            return True\n        return False\n\n    def put_book(i: int, j: int, shelf_1: list, shelf_2: list) -> bool:\n        if not is_valid(i, j, shelf_1, shelf_2):\n            return False\n        if shelf_1[i][j] == 0:\n            return False\n        for k in range(N):\n            for l in range(M):\n                if is_valid(k, l, shelf_1, shelf_2) and (shelf_1[k][l] == shelf_1[i][j] or (shelf_1[k][l] == 0 and shelf_2[k][l] == 0)):\n                    shelf_2[i][j] = shelf_1[i][j]\n                    shelf_1[i][j] = 0\n                    shelf_1[k][l] = 0\n                    return True\n        return False\n\n    lifting = count_lifting(initial_state, final_state)\n\n    for i in range(N):\n        for j in range(M):\n            if initial_state[i][j] != final_state[i][j]:\n                if initial_state[i][j] == 0:\n                    if not lift_book(i, j, initial_state, final_state):\n                        return \"-1\"\n                elif initial_state[i][j] == final_state[i][j]:\n                    if not move_book(i, j, initial_state, final_state):\n                        return \"-1\"\n                else:\n                    if not put_book(i, j, initial_state, final_state):\n                        return \"-1\"\n                lifting += 1\n\n    return str(lifting)\n"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split())\n    current_shelves = []\n    wanted_shelves = []\n    for i in range(N):\n        current_shelves.append(list(map(int, stdin.split()[i * 2 + 1].split())))\n        wanted_shelves.append(list(map(int, stdin.split()[i * 2 + 2].split())))\n    \n    lifting_needed = 0\n    for i in range(N):\n        for j in range(M):\n            if current_shelves[i][j] != wanted_shelves[i][j]:\n                lifting_needed += 1\n    \n    return str(lifting_needed)\n"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    shelves = [list(map(int, stdin.split()[2:6]))]\n    for _ in range(N - 1):\n        shelves.append(list(map(int, stdin.split()[6:])))\n\n    # Calculate the number of lifting needed\n    lifting_needed = 0\n    for i in range(N):\n        for j in range(M):\n            if shelves[i][j] == 0:\n                continue\n            for k in range(M):\n                if shelves[i][k] == shelves[i][j] and k != j:\n                    lifting_needed += 1\n                    break\n            for k in range(N):\n                if shelves[k][j] == shelves[i][j] and k != i:\n                    lifting_needed += 1\n                    break\n\n    return str(lifting_needed)\n"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def move_books(shelves, start, end):\n        while start <= end:\n            if shelves[start] == 0:\n                start += 1\n            elif shelves[end] == 0:\n                end -= 1\n            else:\n                shelves[start], shelves[end] = shelves[end], shelves[start]\n                start += 1\n                end -= 1\n\n    def place_book(shelves, book, new_book, start, end):\n        if book == 0:\n            shelves[start] = new_book\n        else:\n            if shelves[start] == new_book or shelves[end] == new_book:\n                return False\n            move_books(shelves, start, end - 1)\n            move_books(shelves, end + 1, len(shelves) - 1)\n            move_books(shelves, start, end - 1)\n            shelves[start] = new_book\n        return True\n\n    N, M = map(int, stdin.split()[:2])\n    shelves = [list(map(int, stdin.split()[i * M:(i + 1) * M])) for i in range(N)]\n    wanted_shelves = [list(map(int, stdin.split()[N + i * M:(N + (i + 1) * M)])) for i in range(N)]\n\n    min_lifting = 0\n    for i in range(N):\n        for j in range(M):\n            if shelves[i][j] != wanted_shelves[i][j]:\n                min_lifting += 1\n                if not place_book(shelves[i], shelves[i][j], wanted_shelves[i][j], j, M - 1):\n                    return -1\n\n    return min_lifting\n"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    initial_state = [list(map(int, input_data[i + 1].split())) for i in range(N)]\n    final_state = [list(map(int, input_data[i + N + 1].split())) for i in range(N)]\n    def dfs(shelf, book, direction):\n        nonlocal lifting_count\n        if shelf < 0 or shelf >= N or book < 0 or book >= M or initial_state[shelf][book] == 0:\n            return\n        initial_shelf, initial_book = shelf, book\n        while True:\n            lifting_count += 1\n            if direction == 0:\n                if book == 0:\n                    break\n                book -= 1\n            elif direction == 1:\n                if book == M - 1:\n                    break\n                book += 1\n            else:\n                if shelf == 0:\n                    break\n                shelf -= 1\n            initial_state[shelf][book], initial_state[initial_shelf][initial_book] = initial_state[initial_shelf][initial_book], initial_state[shelf][book]\n            if initial_state[shelf][book] == 0:\n                break\n        lifting_count += dfs(shelf + direction, book, 0) + dfs(shelf + direction, book, 1)\n        initial_state[shelf][book], initial_state[initial_shelf][initial_book] = initial_state[initial_shelf][initial_book], initial_state[shelf][book]\n        return lifting_count\n    lifting_count = 0\n    for shelf in range(N):\n        for book in range(M):\n            lifting_count = max(lifting_count, dfs(shelf, book, 0) + dfs(shelf, book, 1))\n    return str(lifting_count) if lifting_count != float('inf') else '-1'\n\ndef"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    current_shelves = []\n    wanted_shelves = []\n\n    for _ in range(N):\n        current_shelves.append(list(map(int, input().split())))\n\n    for _ in range(N):\n        wanted_shelves.append(list(map(int, input().split())))\n\n    def find_min_lifting(current_shelves: list, wanted_shelves: list) -> int:\n        lifting_count = 0\n        current_shelves = list(map(list, zip(*current_shelves)))\n        wanted_shelves = list(map(list, zip(*wanted_shelves)))\n\n        for shelf_index in range(N):\n            for book_index in range(M):\n                if current_shelves[shelf_index][book_index] != wanted_shelves[shelf_index][book_index]:\n                    if wanted_shelves[shelf_index][book_index] != 0:\n                        lifting_count += 1\n                    current_shelves[shelf_index][book_index] = wanted_shelves[shelf_index][book_index]\n\n        return lifting_count\n\n    return str(find_min_lifting(current_shelves, wanted_shelves))\n\n\ndef"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0].split(','))\n    shelves_current = []\n    shelves_wanted = []\n    for _ in range(N):\n        shelves_current.append(list(map(int, stdin.split()[1].split(','))))\n        stdin = stdin[len(stdin.split()[1])+1:]\n        shelves_wanted.append(list(map(int, stdin.split()[0].split(','))))\n        stdin = stdin[len(stdin.split()[0])+1:]\n    K = max(max(shelves_current, key=max))\n    moves = 0\n    for i in range(N):\n        for j in range(M):\n            if shelves_current[i][j] != shelves_wanted[i][j]:\n                if shelves_current[i][j] == 0:\n                    moves += 1\n                    shelves_current[i][j] = shelves_wanted[i][j]\n                else:\n                    for k in range(M):\n                        if shelves_current[i][k] == 0 and shelves_current[i][k] != shelves_wanted[i][k]:\n                            moves += 1\n                            shelves_current[i][k] = shelves_wanted[i][k]\n                            break\n    if moves > K:\n        return \"-1\"\n    else:\n        return moves"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    initial_state = [[0 for _ in range(M)] for _ in range(N)]\n    wanted_state = [[0 for _ in range(M)] for _ in range(N)]\n\n    for i in range(1, N + 1):\n        initial_state[i - 1] = list(map(int, input_list[i].split()))\n    for i in range(N + 1, 2 * N + 1):\n        wanted_state[i - N - 1] = list(map(int, input_list[i].split()))\n\n    def is_empty_place(shelf, place):\n        return shelf[place] == 0\n\n    def move_book(shelf, from_place, to_place):\n        shelf[from_place], shelf[to_place] = shelf[to_place], shelf[from_place]\n\n    def lift(shelf, place):\n        return min(range(len(shelf)), key=lambda x: abs(x - place))\n\n    def minimize_lifting():\n        lifting_count = 0\n        for i in range(N):\n            for j in range(M):\n                if wanted_state[i][j] != 0 and initial_state[i][j] != wanted_state[i][j]:\n                    if is_empty_place(initial_state[i], j):\n                        move_book(initial_state[i], j, lift(wanted_state[i], j))\n                        lifting_count += abs(j - lift(wanted_state[i], j))\n                    elif is_empty_place(initial_state[lift(wanted_state[i], j)], lift(wanted_state[i], j)):\n                        move_book(initial_state[i], j, lift(wanted_state[i], j))\n                        lifting_count += abs(j - lift(wanted_state[i], j))\n                    else:\n                        return -1\n        return lifting_count\n\n    return str(minimize_lifting())\n"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    arr = list(map(int, input_list[1].split()))\n    # sliding window approach\n    max_length = 0\n    for i in range(n):\n        if arr[i] in arr[i+1:]:\n            continue\n        left, right = i, i\n        while right < n-1 and arr[right+1] == arr[right]+1:\n            right += 1\n        while right < n-1 and arr[right+1] == arr[right]-1:\n            right += 1\n        max_length = max(max_length, right-left+1)\n        left, right = i, i\n        while left > 0 and arr[left-1] == arr[left]-1:\n            left -= 1\n        while left > 0 and arr[left-1] == arr[left]+1:\n            left -= 1\n        max_length = max(max_length, right-left+1)\n    return str(max_length)\n"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n\n    N = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    # Find the longest consecutive sub-array so that each element appears exactly once using sliding window\n    counter = Counter(numbers)\n    longest_subarray_length = 0\n\n    for num in counter:\n        if counter[num] > 1:\n            window_size = 0\n            while counter[num] > 0:\n                counter[num] -= 1\n                window_size += 1\n                counter[num - 1] -= 1\n\n            longest_subarray_length = max(longest_subarray_length, window_size)\n\n    # Find the longest consecutive sub-array so that each element appears exactly twice using the same sliding window approach\n    longest_subarray_length2 = 0\n\n    for num in numbers:\n        counter[num] += 1\n        if counter[num] > 1:\n            window_size = 0\n            while counter[num] > 1:\n                counter[num] -= 1\n                window_size += 1\n                counter[num - 1] -= 1\n\n            longest_subarray_length2 = max(longest_subarray_length2, window_size)\n\n    return str(max(longest_subarray_length, longest_subarray_length2))\n"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    nums = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Create a dictionary to store the frequency of each number\n    freq = {}\n    for num in nums:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    # Iterate through the dictionary and find the longest consecutive sub-array\n    max_len = 0\n    start = 0\n    end = 0\n    for i in range(N):\n        if freq[nums[i]] == 2:\n            freq[nums[i]] -= 1\n            start = i\n            while end < N and freq[nums[end]] == 2:\n                freq[nums[end]] -= 1\n                end += 1\n            max_len = max(max_len, end - start)\n    \n    return max_len"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_subarray(arr: list[int]) -> int:\n        from collections import Counter\n        counter = Counter(arr)\n        longest_subarray = 0\n        current_subarray = 0\n        for _, count in counter.items():\n            if count % 2 == 1:\n                current_subarray += count\n            else:\n                while count % 2 == 0:\n                    current_subarray += count // 2\n                    if current_subarray > longest_subarray:\n                        longest_subarray = current_subarray\n                    counter[count // 2] -= count // 2\n                    count //= 2\n        return longest_subarray\n\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    arr = list(map(int, input_data[1].split()))\n    return str(find_longest_subarray(arr))\n"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    nums = list(map(int, input_list[1].split()))\n\n    count_dict = {}\n    for num in nums:\n        if num not in count_dict:\n            count_dict[num] = 1\n        else:\n            count_dict[num] += 1\n\n    longest_subarray_length = 0\n    current_subarray_length = 0\n    prev_num = None\n\n    for num in nums:\n        if count_dict[num] > 0:\n            count_dict[num] -= 2\n        if prev_num is not None and count_dict[prev_num] == 0:\n            current_subarray_length -= 1\n            if prev_num == num - 1:\n                current_subarray_length += 1\n                longest_subarray_length = max(longest_subarray_length, current_subarray_length)\n        current_subarray_length += 1\n        prev_num = num\n\n    return longest_subarray_length\n"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(arr: list) -> bool:\n        for num in arr:\n            if arr.count(num) % 2 != 0:\n                return False\n        return True\n\n    def find_sub_array(arr: list) -> int:\n        max_length = 0\n        for i in range(len(arr)):\n            for j in range(i + 1, len(arr) + 1):\n                sub_arr = arr[i:j]\n                if len(sub_arr) > max_length and is_valid(sub_arr):\n                    max_length = len(sub_arr)\n        return max_length\n\n    def process_input(stdin: str) -> list:\n        lines = stdin.split('\\n')\n        arr = list(map(int, lines[1].split()))\n        return arr\n\n    arr = process_input(stdin)\n    max_length = find_sub_array(arr)\n    return str(max_length)\n\n\ninput_str = '''6\n1 2 3 3 4 2\n8\n1 2 1 3 1 3 1 2\n'''\n\noutput_str = '''2\n4'''\n\nn = 2\nfor i in range(n):\n    input_data = input_str.split('\\n')[i * 2:(i + 1) * 2]\n    input_str = '\\n'.join(input_data)\n    expected_output = output_str.split('\\n')[i]\n\n    result = solution(input_str)\n    if result != expected_output:\n        print(f\"Input: \\n{input_str}\\n\\nExpected output: {expected_output}\\n\\nActual output: {result}\\n\") "
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = list(map(int, stdin.split('\\n')[1].split()))\n    input_set = set(input_list)\n    max_length = 0\n    \n    for num in input_set:\n        num_count = input_list.count(num)\n        if num_count % 2 != 0:\n            continue\n        new_num = 2 * num\n        if new_num in input_set:\n            max_length = max(max_length, input_list.count(num) + input_list.count(new_num))\n    return str(max_length)"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_consecutive_subarray(nums: list) -> int:\n        num_count = {}\n        for num in nums:\n            if num not in num_count:\n                num_count[num] = 1\n            else:\n                num_count[num] += 1\n        \n        max_length = 0\n        current_length = 0\n        for num, count in num_count.items():\n            if count == 1:\n                current_length += 1\n            else:\n                current_length += count // 2\n            max_length = max(max_length, current_length)\n        \n        return max_length\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    nums = list(map(int, input_list[1].split()))\n\n    return str(find_longest_consecutive_subarray(nums))"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    nums = list(map(int, stdin.split('\\n')[1].split()))\n    \n    count = {}\n    for num in nums:\n        count[num] = count.get(num, 0) + 1\n    \n    longest_subarray = 0\n    for num in nums:\n        if count.get(num, 0) >= 2:\n            count[num] = count.get(num, 0) - 2\n            i, j = 0, 1\n            while count.get(nums[i], 0) >= 2:\n                count[nums[i]] -= 2\n                i += 1\n            while count.get(nums[j], 0) >= 2:\n                count[nums[j]] -= 2\n                j += 1\n            longest_subarray = max(longest_subarray, j - i)\n            \n    return str(longest_subarray)"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    input_array = list(map(int, input_list[1].split()))\n\n    # Create a dictionary to store the count of each element in the array\n    element_count = {}\n    for element in input_array:\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n\n    # Initialize variables for the longest sub-array and the current sub-array\n    max_length = 0\n    current_length = 0\n    current_subarray = []\n\n    # Iterate through the input array\n    for element in input_array:\n        # If the element is in the current sub-array, increment the current length\n        if element in current_subarray:\n            current_length += 1\n        # If the element is not in the current sub-array, add it to the current sub-array and reset the current length\n        else:\n            current_subarray = [element]\n            current_length = 1\n        # If the current sub-array length is even and greater than the current max length, update the max length\n        if current_length % 2 == 0 and current_length > max_length:\n            max_length = current_length\n\n    # Check if the elements in the input array can form a sub-array of length 2 with each element appearing twice\n    if all(count % 2 == 0 for count in element_count.values()):\n        max_length = 2\n\n    # Return the longest sub-array length\n    return str(max_length)\n"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split()[:3])\n    board = [[0] * N for _ in range(N)]\n    rooks = [tuple(map(int, stdin.split()[3+3*k:6+3*k])) for k in range(K)]\n    for rook in rooks:\n        r, c, x = rook\n        board[r-1][c-1] = x\n\n    def get_power(i, j):\n        return sum(board[x][y] for x in range(max(0, i-1), min(i+1, N)) for y in range(max(0, j-1), min(j+1, N)) if board[x][y])\n\n    def count_attacked_fields(board):\n        attacked = 0\n        for i in range(N):\n            for j in range(N):\n                if board[i][j]:\n                    power = board[i][j]\n                    xor_power = 0\n                    for k in range(N):\n                        if k != i:\n                            xor_power ^= get_power(k, j)\n                        if k != j:\n                            xor_power ^= get_power(i, k)\n                    if xor_power > 0:\n                        attacked += 1\n        return attacked\n\n    for _ in range(P):\n        r1, c1, r2, c2 = map(int, stdin.split()[6+3*P:9+3*P])\n        board[r2-1][c2-1] = board[r1-1][c1-1]\n        board[r1-1][c1-1] = 0\n        print(count_attacked_fields(board))\n"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    rooks = {}\n    attacked_fields = set()\n    for _ in range(K):\n        R, C, X = map(int, stdin.split())\n        rooks[(R, C)] = X\n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, stdin.split())\n        R1 -= 1\n        C1 -= 1\n        R2 -= 1\n        C2 -= 1\n        if (R1, C1) in rooks:\n            del rooks[(R1, C1)]\n        if (R2, C2) in rooks:\n            del rooks[(R2, C2)]\n        rooks[(R2, C2)] = rooks.get((R2, C2), 0) ^ X\n        for R, C in rooks:\n            for DR in range(-N+1, N):\n                for DC in range(-N+1, N):\n                    if DR == 0 and DC == 0:\n                        continue\n                    RR, CC = R + DR, C + DC\n                    if 1 <= RR <= N and 1 <= CC <= N:\n                        attacked_fields.add((RR, CC))\n    return len(attacked_fields)\n"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    board = [[0] * N for _ in range(N)]\n    rook_pos = []\n\n    for _ in range(K):\n        R, C, X = map(int, input().split())\n        board[R - 1][C - 1] = X\n        rook_pos.append((R - 1, C - 1, X))\n\n    for move in range(P):\n        R1, C1, R2, C2 = map(int, input().split())\n        R1, C1, R2, C2 = R1 - 1, C1 - 1, R2 - 1, C2 - 1\n\n        # Move the rook\n        board[R1][C1], board[R2][C2] = board[R2][C2], board[R1][C1]\n        rook_pos[C1 * N + R1], rook_pos[C2 * N + R2] = (R2, C2, board[R2][C2]), (R1, C1, board[R1][C1])\n\n    # Calculate the attacked fields\n    def is_attacked(R, C, X):\n        for r in range(N):\n            for c in range(N):\n                if board[r][c] ^ X > 0:\n                    yield (r, c)\n\n    attacked_fields = 0\n    for R, C, X in rook_pos:\n        attacked_fields += sum(1 for _ in is_attacked(R, C, X))\n\n    return str(attacked_fields)\n"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, input().split())\n    rooks = []\n    for _ in range(K):\n        R, C, X = map(int, input().split())\n        rooks.append((R, C, X))\n\n    board = [[0 for _ in range(N)] for _ in range(N)]\n    for R, C, X in rooks:\n        board[R-1][C-1] = X\n\n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, input().split())\n        R1 -= 1\n        C1 -= 1\n        R2 -= 1\n        C2 -= 1\n\n        if R1 == R2 and C1 == C2:\n            continue\n\n        if R1 == R2:\n            if C1 < C2:\n                board[R1][C1] = 0\n                board[R1][C2] = 0\n                for i in range(C1+1, C2):\n                    board[R1][i] = 0\n            else:\n                board[R2][C2] = 0\n                board[R2][C1] = 0\n                for i in range(C1, C2-1, -1):\n                    board[R2][i] = 0\n        else:\n            if R1 < R2:\n                board[R1][C1] = 0\n                board[R2][C2] = 0\n                for i in range(R1+1, R2):\n                    board[i][C1] = 0\n            else:\n                board[R2][C2] = 0\n                board[R1][C1] = 0\n                for i in range(R1, R2-1, -1):\n                    board[i][C2] = 0\n\n    attacked_fields = 0\n    for row in board:\n        for field in row:\n            if field > 0:\n                attacked_fields += 1\n\n    return str(attacked_fields) + '\\n'\n\ninput_data = '''2 2 2\n1 1 1\n2 2 1\n2 2 2 1\n1 1 1 2'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    N, K, P = map(int, input_values[0].split())\n    board = [[0 for _ in range(N)] for _ in range(N)]\n    rooks_powers = {}\n    rooks_positions = {}\n\n    for i in range(1, K + 1):\n        R, C, X = map(int, input_values[i].split())\n        board[R - 1][C - 1] = X\n        rooks_powers[i] = X\n        rooks_positions[i] = (R - 1, C - 1)\n\n    result = []\n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, input_values[K + _].split())\n        old_rook = board[R1 - 1][C1 - 1]\n        new_rook = board[R2 - 1][C2 - 1]\n        board[R1 - 1][C1 - 1] = new_rook\n        board[R2 - 1][C2 - 1] = old_rook\n        rooks_positions[old_rook] = (R2 - 1, C2 - 1)\n        rooks_positions[new_rook] = (R1 - 1, C1 - 1)\n        num_attacked_fields = count_attacked_fields(board, N, rooks_powers, rooks_positions)\n        result.append(num_attacked_fields)\n\n    return '\\n'.join(map(str, result))\n\ndef"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K, P = map(int, input_list[0].split())\n    rook_positions = [list(map(int, input_list[i].split())) for i in range(1, K+1)]\n    board = [[0 for _ in range(N)] for _ in range(N)]\n\n    # place rooks on board\n    for rook in rook_positions:\n        R, C, X = rook\n        board[R-1][C-1] = X\n\n    # make moves\n    for i in range(1, P+1):\n        moves = list(map(int, input_list[K+i].split()))\n        R1, C1, R2, C2 = moves\n        # move rook\n        board[R1-1][C1-1], board[R2-1][C2-1] = board[R2-1][C2-1], board[R1-1][C1-1]\n\n    # count attacked fields\n    attacked_fields = [0] * P\n    for R in range(N):\n        for C in range(N):\n            if board[R][C] > 0:\n                powers = [board[i][j] for i in range(N) for j in range(N) if i != R or j != C]\n                attacked_fields = [sum(bin(p1^p2)[:1]) for p1, p2 in zip(powers, board[R][C] ^ powers)]\n\n    # output attacked fields\n    result = '\\n'.join(map(str, attacked_fields))\n    return result"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split()[:3])\n    K = [[int(x) for x in input().split()] for _ in range(K)]\n    moves = [list(map(int, input().split())) for _ in range(P)]\n    \n    board = [[0 for _ in range(N)] for _ in range(N)]\n    \n    # Place rooks\n    for rook in K:\n        board[rook[0] - 1][rook[1] - 1] = rook[2]\n    \n    # Perform moves\n    for move in moves:\n        rook = board[move[0] - 1][move[1] - 1]\n        board[move[2] - 1][move[3] - 1] = rook\n        board[move[0] - 1][move[1] - 1] = 0\n    \n    # Count attacked fields\n    result = 0\n    for row in board:\n        for field in row:\n            if field > 0:\n                result += field\n    \n    return str(result)"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    board = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(K):\n        R, C, X = map(int, input().split())\n        board[R-1][C-1] = X\n\n    rooks = [(i, j, board[i][j]) for i in range(N) for j in range(N) if board[i][j] > 0]\n\n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, input().split())\n        rook_to_move = next((rook for rook in rooks if rook[0] == R1-1 and rook[1] == C1-1), None)\n        if rook_to_move:\n            rooks.remove(rook_to_move)\n            rooks.append((R2-1, C2-1, rook_to_move[2]))\n\n    def is_attacked(row, col):\n        powers = [rook[2] for rook in rooks if rook[0] == row or rook[1] == col]\n        return any(bin(XOR(powers[i], powers[j])).count('1') > 0 for i in range(len(powers)) for j in range(i+1, len(powers)))\n\n    attacks = []\n    for _ in range(P):\n        attacks.append(sum(is_attacked(row, col) for row in range(N) for col in range(N)))\n\n    result = '\\n'.join(map(str, attacks))\n    return result"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split()[:3])\n    N, K, P = 100000, 100000, 100000\n    matrix = [[0 for _ in range(N)] for _ in range(N)]\n    rooks = []\n    \n    for i in range(K):\n        r, c, x = map(int, stdin.split()[3 + i * 3: 3 + (i + 1) * 3])\n        matrix[r - 1][c - 1] = x\n        rooks.append((r - 1, c - 1, x))\n        \n    for _ in range(P):\n        r1, c1, r2, c2 = map(int, stdin.split()[3 + K * 3:])\n        r1, c1, r2, c2 = r1 - 1, c1 - 1, r2 - 1, c2 - 1\n        \n        rooks.append((r2, c2, matrix[r2][c2]))\n        matrix[r2][c2] = matrix[r1][c1]\n        matrix[r1][c1] = 0\n        \n        attacked = 0\n        for r in range(N):\n            for c in range(N):\n                powers = [rooks[i][2] for i in range(len(rooks)) if rooks[i][0] == r or rooks[i][1] == c]\n                if powers:\n                    attacked += int(bin(reduce(lambda x, y: x ^ y, powers)) > bin(0), 2))\n        \n        print(attacked)\n        \n    return 0\n"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    board = [[0] * N for _ in range(N)]\n    rooks = []\n    \n    for _ in range(K):\n        R, C, X = map(int, stdin.split())\n        board[R - 1][C - 1] = X\n        rooks.append((R - 1, C - 1))\n    \n    for _ in range(P):\n        R1, C1, R2, C2 = map(int, stdin.split())\n        R1, C1, R2, C2 = R1 - 1, C1 - 1, R2 - 1, C2 - 1\n        \n        if (R1, C1) in rooks:\n            rooks.remove((R1, C1))\n        rooks.append((R2, C2))\n    \n    attacked = 0\n    for i in range(N):\n        for j in range(N):\n            xor_power = 0\n            for R, C in rooks:\n                xor_power ^= board[R][C]\n            if xor_power > 0:\n                attacked += 1\n    \n    result = [str(attacked)]\n    for _ in range(P - 1):\n        stdin = input()\n        R1, C1, R2, C2 = map(int, stdin.split())\n        R1, C1, R2, C2 = R1 - 1, C1 - 1, R2 - 1, C2 - 1\n        \n        board[R2][C2] = board[R1][C1]\n        board[R1][C1] = 0\n        attacked -= 1 if (R1, C1) in rooks else 0\n        rooks.remove((R1, C1))\n        rooks.append((R2, C2))\n        attacked += 1 if (R2, C2) in rooks else 0\n        \n        result.append(str(attacked))\n    \n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    players = [[0] * n for _ in range(n)]\n    for i in range(1, n + 1):\n        players[i - 1] = list(map(int, input_data[i].split()))\n    disqualified = list(map(int, input_data[-1].split()))\n\n    for i in range(n):\n        for j in range(n):\n            players[i][j] = not (players[i][j] or players[j][i])\n\n    players = [player for player in players if player[disqualified.index(1)]]\n\n    def is_valid(S: set[int]) -> bool:\n        for player in S:\n            if not all(players[player][other] for other in range(n) if other not in S):\n                return False\n        return True\n\n    S = set(disqualified)\n    min_k = min(S)\n    max_k = max(S)\n\n    while min_k <= max_k:\n        mid_k = (min_k + max_k) // 2\n        if is_valid(set(range(n)) - set(range(mid_k + 1))):\n            min_k = mid_k + 1\n        else:\n            max_k = mid_k - 1\n\n    return min_k if min_k <= k else \"impossible\""
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    matrix = [[int(num) for num in line.split()] for line in input_list[1:n+1]]\n    disqualified_players = list(map(int, input_list[n+1].split()))\n    num_players = n - k\n\n    # Create a graph\n    graph = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            graph[i][j] = matrix[i][j]\n\n    # Find the maximum independent set\n    max_independent_set = []\n    while graph:\n        node = None\n        for i in range(n):\n            if i not in max_independent_set and len(graph[i]) > 0:\n                if node is None or graph[i][0] > graph[node][0]:\n                    node = i\n        if node is not None:\n            max_independent_set.append(node)\n            for i in range(n):\n                if i != node and graph[i][node] == 1:\n                    graph[i].pop(node)\n        else:\n            break\n\n    # Check if the disqualified players are in the maximum independent set\n    for disqualified_player in disqualified_players:\n        if disqualified_player in max_independent_set:\n            return \"impossible\"\n\n    # Remove disqualified players from the maximum independent set\n    max_independent_set = [player for player in max_independent_set if player not in disqualified_players]\n\n    # Find the smallest set to disqualify\n    k_prime = num_players - len(max_independent_set)\n\n    return k_prime"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data[0].split())\n    matrix = [list(map(int, input_data[i+1].split())) for i in range(n)]\n    S = list(map(int, input_data[-1].split()))\n\n    # Check if there is a fair ranking without the disqualified players\n    for i in range(n):\n        for j in range(n):\n            if matrix[i][j] == 1 and matrix[j][i] == 0:\n                return \"impossible\"\n\n    # Find the minimum number of players to disqualify to make a fair ranking\n    k_prime = k\n    while True:\n        for i in range(n):\n            if S[i] == 1:\n                k_prime -= 1\n        if k_prime < k:\n            return k_prime\n        k_prime += 1"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    adj_matrix = [list(map(int, stdin.split()[2:6])) for _ in range(n)]\n    disqualified = set(map(int, stdin.split()[6:]))\n\n    def dfs(player, visited, adj_list, depth):\n        visited.add(player)\n        for neighbor in adj_list[player]:\n            if neighbor not in visited and neighbor not in disqualified:\n                dfs(neighbor, visited, adj_list, depth + 1)\n        return depth\n\n    for player in range(n):\n        if player not in disqualified:\n            if dfs(player, set(), adj_matrix, 0) < n - k:\n                return k - dfs(player, set(), adj_matrix, 0)\n\n    return \"impossible\"\n"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    matrix = [list(map(int, input().split())) for _ in range(n)]\n    disqualified_players = list(map(int, input().split()))\n\n    def is_fair_ranking(stdin: str) -> bool:\n        n, k = map(int, input().split())\n        matrix = [list(map(int, input().split())) for _ in range(n)]\n        disqualified_players = list(map(int, input().split()))\n\n        # Check if the matrix is square\n        if n != len(matrix):\n            return False\n\n        # Check if the matrix is symmetric\n        for i in range(n):\n            for j in range(n):\n                if matrix[i][j] != matrix[j][i]:\n                    return False\n\n        # Check if the disqualified players are the same\n        for player in disqualified_players:\n            if player not in disqualified_players:\n                return False\n\n        return True\n\n    # Check if the matrix is fair\n    if not is_fair_ranking(stdin):\n        return \"impossible\"\n\n    # Try all possible sets of disqualified players\n    min_k = k\n    for i in range(k):\n        # Disqualify player i and check if the matrix is still fair\n        disqualified_players[i], disqualified_players[k-1] = disqualified_players[k-1], disqualified_players[i]\n        k -= 1\n\n        if is_fair_ranking(stdin):\n            min_k = k\n\n        disqualified_players[i], disqualified_players[k] = disqualified_players[k], disqualified_players[i]\n        k += 1\n\n    return min_k\n"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0].split()[0])\n    k = int(input_list[0].split()[1])\n    n_players = []\n    for i in range(1, n + 1):\n        n_players.append([int(x) for x in input_list[i].split()])\n\n    disqualified_players = [int(x) for x in input_list[-1].split()]\n\n    # Remove disqualified players from the list\n    n_players = [x for i, x in enumerate(n_players) if i not in disqualified_players]\n\n    # Generate all possible combinations of players to disqualify\n    combinations = []\n    for i in range(1, n + 1):\n        combinations.extend(list(itertools.combinations(range(n), i)))\n\n    # Find the minimum number of players to disqualify\n    min_players = float('inf')\n    for comb in combinations:\n        # Check if the combination covers all the players\n        if len(comb) == n - k:\n            # Check if the combination is disjoint from the disqualified players\n            if set(comb).isdisjoint(disqualified_players):\n                # Check if the combination is a fair ranking\n                is_fair = True\n                for i in range(n):\n                    for j in range(n):\n                        if i != j:\n                            if n_players[i][j] == 1 and i in comb and j not in comb:\n                                is_fair = False\n                                break\n                if is_fair:\n                    min_players = min(min_players, len(comb))\n\n    # Return the minimum number of players to disqualify or impossible\n    if min_players < float('inf'):\n        return str(min_players)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    scores = [list(map(int, stdin.split()[i+2:i+2+n])) for i in range(0, n*(n+1), n+1)]\n    disqualified = set(map(int, stdin.split()[-k:]))\n    \n    def is_fair(scores, disqualified):\n        for i in range(n):\n            for j in range(n):\n                if (i, j) not in disqualified and scores[i][j] == 1:\n                    return False\n        return True\n    \n    # BFS to find the smallest set to disqualify\n    queue = [(set(), k)]\n    while queue:\n        current, remaining = queue.pop(0)\n        if len(current) == k:\n            return remaining\n        for i in range(n):\n            if i not in current:\n                new_current = current | {i}\n                new_remaining = remaining - scores[i].count(1)\n                if new_remaining >= 0 and is_fair(scores, new_current):\n                    queue.append((new_current, new_remaining))\n    return \"impossible\""
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    mat = [list(map(int, line.split())) for line in stdin.split('\\n')[2:-1]]\n    disqualified = list(map(int, stdin.split('\\n')[-1].split()))\n\n    # Generate a graph from the matrix\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if mat[i][j] == 1:\n                graph[i].append(j)\n\n    # Find all connected components\n    visited = [False] * n\n    components = []\n    def dfs(node):\n        if not visited[node]:\n            visited[node] = True\n            components[-1].append(node)\n            for neighbor in graph[node]:\n                dfs(neighbor)\n    for i in range(n):\n        if not visited[i]:\n            components.append([])\n            dfs(i)\n\n    # Check if all connected components have a fair ranking\n    for component in components:\n        scores = [0] * n\n        for i in component:\n            for j in graph[i]:\n                if j in component:\n                    scores[i] += 1\n        if any(score < k for score in scores):\n            return \"impossible\"\n\n    # Find the smallest set of players to disqualify\n    disqualified_players = set(disqualified)\n    for component in components:\n        if set(component) & disqualified_players:\n            return \"impossible\"\n\n    k_prime = k\n    for component in components:\n        if len(set(component) & disqualified_players) < k_prime:\n            k_prime = len(set(component) & disqualified_players)\n\n    return k_prime"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    adj_matrix = [list(map(int, stdin.split()[2:6]))]\n\n    for i in range(1, n):\n        adj_matrix.append(list(map(int, stdin.split()[6+i*4:6+(i+1)*4])))\n\n    disqualified_players = list(map(int, stdin.split()[-k:]))\n    remaining_players = set(range(n)) - set(disqualified_players)\n\n    def find_subset_with_min_size(remaining_players: set, k: int) -> int:\n        if len(remaining_players) < k:\n            return len(remaining_players)\n\n        return 0\n\n    min_size = find_subset_with_min_size(remaining_players, k)\n\n    return str(min_size) if min_size > 0 else \"impossible\""
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.splitlines()[0].split())\n    adj_mat = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n    adj_mat = [[adj_mat[i][j] for j in range(n)] for i in range(n)]\n    disqualified = [int(x) for x in stdin.splitlines()[-1].split()]\n\n    # Build the disqualified set\n    disqualified_set = set(disqualified)\n\n    # Initialize the minimum disqualified set size\n    k_min = k\n\n    # Iterate over the adjacency matrix\n    for i in range(n):\n        if i not in disqualified_set:\n            for j in range(i+1, n):\n                if i not in disqualified_set and j not in disqualified_set:\n                    if adj_mat[i][j] == 1 and adj_mat[j][i] == 0:\n                        # Check if removing i from the disqualified set improves the ranking\n                        if (i not in disqualified_set) and (adj_mat[i][:i] + adj_mat[i][i+1:]).count(0) <= adj_mat[:i].count(1) + adj_mat[i+1:].count(1):\n                            k_min -= 1\n                            disqualified_set.add(i)\n                        else:\n                            # Check if removing j from the disqualified set improves the ranking\n                            if (j not in disqualified_set) and (adj_mat[j][:j] + adj_mat[j][j+1:]).count(0) <= adj_mat[:j].count(1) + adj_mat[j+1:].count(1):\n                                k_min -= 1\n                                disqualified_set.add(j)\n\n    if k_min < k:\n        return str(k_min)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    X = list(map(int, input_list[1].split()))\n    Q = int(input_list[2])\n    L_R = [list(map(int, input_list[i].split())) for i in range(3, len(input_list))]\n\n    seq = [0] * N\n    for x in X:\n        something(x, seq)\n\n    result = []\n    for l, r in L_R:\n        result.append(sum(seq[l:r+1]))\n\n    return '\\n'.join(map(str, result))\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, K = map(int, input_data[0].split())\n    X = list(map(int, input_data[1].split()))\n    Q = int(input_data[2])\n    L_R = [list(map(int, input_data[i+3].split())) for i in range(Q)]\n\n    seq = [0] * N\n    for x in X:\n        something(x)\n\n    result = []\n    for l, r in L_R:\n        result.append(sum(seq[l:r+1]))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    Q = int(input())\n    LR = [list(map(int, input().split())) for _ in range(Q)]\n\n    seq = [0] * N\n\n    for i in range(K):\n        jump = X[i]\n        current_i = 0\n        while current_i < N:\n            seq[current_i] += 1\n            current_i += jump\n\n    result = []\n    for L, R in LR:\n        result.append(sum(seq[L:R+1]))\n\n    return '\\n'.join(map(str, result))\n\n\ninput_stdin = \"\"\"10 4\n1 1 2 1\n3\n0 9\n2 6\n7 7\n\"\"\"\n\noutput_stdout = \"\"\"35\n18\n3\"\"\"\n\nprint(solution(input_stdin))\n"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    X = list(map(int, input_list[1].split()))\n    Q = int(input_list[2])\n    L_R = [list(map(int, input_list[i].split())) for i in range(3, 3 + Q)]\n    \n    seq = [0] * N\n    for x in X:\n        something(x)\n    \n    for l_r in L_R:\n        L, R = l_r\n        result = sum(seq[L:R+1])\n        print(result)\n        \n    return '\\n'.join([str(result) for result in L_R])"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def something(seq, jump, N):\n        i = 0\n        while i < N:\n            seq[i] = seq[i] + 1\n            i = i + jump\n\n    N, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    Q = int(input())\n    LR = []\n    for _ in range(Q):\n        LR.append(list(map(int, input().split())))\n\n    seq = [0] * N\n    for x in X:\n        something(seq, x, N)\n\n    result = []\n    for l, r in LR:\n        result.append(sum(seq[l:r+1]))\n\n    return '\\n'.join(map(str, result))\n\ndef"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    X = list(map(int, input().split()))\n    Q = int(input())\n    L = []\n    R = []\n    for i in range(Q):\n        L.append(int(input()))\n        R.append(int(input()))\n\n    seq = [0] * N\n    for x in X:\n        something(x)\n\n    result = []\n    for i in range(Q):\n        result.append(sum(seq[L[i]:R[i]+1]))\n\n    return \"\\n\".join(str(x) for x in result)\n"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def something(seq, jump):\n        i = 0\n        while i < N:\n            seq[i] = seq[i] + 1\n            i = i + jump\n\n    N, K = map(int, stdin.split()[:2])\n    X = list(map(int, stdin.split()[2:2+K]))\n    Q = int(stdin.split()[-1])\n    L_R = [list(map(int, stdin.split()[2+K+i:2+K+i+2])) for i in range(Q)]\n\n    seq = [0] * N\n    for x in X:\n        something(seq, x)\n\n    result = [sum(seq[l:r+1]) for l, r in L_R]\n    return '\\n'.join(map(str, result))\n\n\ninput_1 = \"10 4\\n1 1 2 1\\n3\\n0 9\\n2 6\\n7 7\"\ninput_2 = \"11 3\\n3 7 10\\n3\\n0 10\\n2 6\\n7 7\"\n\nprint(\"Sample Input 1:\")\nprint(input_1)\nprint(\"Sample Output 1:\")\nprint(solution(input_1))\nprint(\"\\nSample Input 2:\")\nprint(input_2)\nprint(\"Sample Output 2:\")\nprint(solution(input_2)) "
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def something(seq, jump, N):\n        i = 0\n        while i < N:\n            seq[i] += 1\n            i = i + jump\n\n    # Read input\n    input_lines = stdin.splitlines()\n    N, K = map(int, input_lines[0].split())\n    X = list(map(int, input_lines[1].split()))\n    Q = int(input_lines[2])\n    L = [list(map(int, input_lines[i].split())) for i in range(3, 3 + Q)]\n\n    # Initialize sequence\n    seq = [0] * N\n\n    # Call something procedure\n    for x in X:\n        something(seq, x, N)\n\n    # Compute sum for each special part\n    result = []\n    for li, ri in L:\n        result.append(sum(seq[li:ri+1]))\n\n    # Output result\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, Q = map(int, input().split())\n    X = list(map(int, input().split()))\n    special_parts = []\n    for _ in range(Q):\n        special_parts.append(list(map(int, input().split())))\n\n    seq = [0] * N\n    for x in X:\n        something(x)\n\n    result = []\n    for L, R in special_parts:\n        result.append(sum(seq[L:R+1]))\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, K = map(int, input_data[0].split())\n    X = list(map(int, input_data[1].split()))\n    Q = int(input_data[2])\n    LR = [list(map(int, input_data[i].split())) for i in range(3, 3 + Q)]\n\n    seq = [0] * N\n\n    for x in X:\n        something(x, seq)\n\n    result = []\n\n    for lr in LR:\n        result.append(sum(seq[lr[0]:lr[1] + 1]))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    input_list = input_list[1:]\n    tree = {}\n    count = 0\n    for num in input_list:\n        node = tree\n        while True:\n            count += 1\n            if num < node:\n                if 'left' not in node:\n                    node['left'] = num\n                    break\n                else:\n                    node = node['left']\n            else:\n                if 'right' not in node:\n                    node['right'] = num\n                    break\n                else:\n                    node = node['right']\n        print(count)\n    return count\n"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node: TreeNode, value: int, depth: int):\n        nonlocal counter\n        if not node:\n            node = TreeNode(value)\n            counter += depth\n            return node, depth\n        if value < node.val:\n            node.left, depth = insert(node.left, value, depth)\n        else:\n            node.right, depth = insert(node.right, value, depth)\n        return node, depth\n\n    def inorder(node: TreeNode):\n        if node:\n            inorder(node.left)\n            print(counter)\n            inorder(node.right)\n\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    # Read input\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    sequence = [int(x) for x in input_lines[1:]]\n\n    # Build binary search tree\n    root = TreeNode(sequence[0])\n    counter = 0\n    for i in range(1, N):\n        root, depth = insert(root, sequence[i], 1)\n\n    # Inorder traversal\n    inorder(root)\n\n    # Output last counter value\n    print(counter)\n"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_node(root, key):\n        if root is None or root.key == key:\n            return root\n        if root.key > key:\n            return find_node(root.left, key)\n        return find_node(root.right, key)\n\n    def insert(root, key):\n        if root is None:\n            return Node(key)\n        if root.key > key:\n            root.left = insert(root.left, key)\n        else:\n            root.right = insert(root.right, key)\n        return root\n\n    def get_depth(root, key, depth):\n        if root is None:\n            return None\n        if root.key == key:\n            return depth\n        left_depth = get_depth(root.left, key, depth + 1)\n        if left_depth is not None:\n            return left_depth\n        return get_depth(root.right, key, depth + 1)\n\n    def inorder_traversal(root):\n        if root is not None:\n            inorder_traversal(root.left)\n            print(root.key, end=' ')\n            print(root.counter, end=' ')\n            root.counter += 1\n            inorder_traversal(root.right)\n\n    N = int(stdin)\n    sequence = list(map(int, stdin.split()[1:]))\n    root = Node(sequence[0])\n    counter = 0\n    for num in sequence[1:]:\n        root = insert(root, num)\n        depth = get_depth(root, num, 0)\n        root.counter += depth\n        counter = root.counter\n    inorder_traversal(root)\n    return stdin\n\n\nclass Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        self.counter = 0\n"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, value: int) -> int:\n        if node is None:\n            return 0\n        if node.value < value:\n            node.right = TreeNode(value)\n            return node.right.count + 1\n        else:\n            node.left = TreeNode(value)\n            return node.left.count + 1\n    \n    def construct_bst(sequence: List[int], start: int, end: int) -> Tuple[TreeNode, int]:\n        if start > end:\n            return None, 0\n        mid = (start + end) // 2\n        root = TreeNode(sequence[mid])\n        root.count = 0\n        root.left, left_count = construct_bst(sequence, start, mid - 1)\n        root.right, right_count = construct_bst(sequence, mid + 1, end)\n        return root, left_count + right_count + root.count\n\n    N = int(stdin[0])\n    sequence = list(map(int, stdin[1:].split()))\n    root, _ = construct_bst(sequence, 0, N - 1)\n    return '\\n'.join(str(insert(root, value)) for value in sequence)\n\ndef"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, value):\n        if node is None:\n            nonlocal depth, counter\n            depth += 1\n            counter += depth\n            return Node(value)\n        elif value < node.data:\n            node.left = insert(node.left, value)\n        else:\n            node.right = insert(node.right, value)\n        return node\n\n    class Node:\n        def __init__(self, data):\n            self.data = data\n            self.left = None\n            self.right = None\n\n    n = int(stdin.splitlines()[0])\n    depth = 0\n    counter = 0\n    root = None\n    nodes = [int(x) for x in stdin.splitlines()[1:]]\n    for node in nodes:\n        root = insert(root, node)\n        print(counter)\n"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n = int(input_lines[0])\n    numbers = list(map(int, input_lines[1:]))\n    root = numbers[0]\n    tree = {root: {\"left\": None, \"right\": None, \"depth\": 1}}\n    counter = 0\n    for number in numbers[1:]:\n        current_node = root\n        while True:\n            if number < current_node:\n                if tree[current_node][\"left\"] is None:\n                    tree[current_node][\"left\"] = number\n                    tree[number] = {\"left\": None, \"right\": None, \"depth\": tree[current_node][\"depth\"] + 1}\n                    break\n                else:\n                    current_node = tree[current_node][\"left\"]\n            else:\n                if tree[current_node][\"right\"] is None:\n                    tree[current_node][\"right\"] = number\n                    tree[number] = {\"left\": None, \"right\": None, \"depth\": tree[current_node][\"depth\"] + 1}\n                    break\n                else:\n                    current_node = tree[current_node][\"right\"]\n        counter += 1\n        print(counter)\n    return str(counter)"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    num_list = list(map(int, input_list[1:]))\n    tree = BinarySearchTree()\n    C = 0\n    for num in num_list:\n        tree.insert(num)\n        C += tree.height()\n        print(C)\n\nclass Node:\n    def __init__(self, val):\n        self.val = val\n        self.left = None\n        self.right = None\n        self.height = 1\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, val):\n        if not self.root:\n            self.root = Node(val)\n        else:\n            self.root = self._insert(self.root, val)\n\n    def _insert(self, node, val):\n        if val < node.val:\n            if not node.left:\n                node.left = Node(val)\n            else:\n                node.left = self._insert(node.left, val)\n        else:\n            if not node.right:\n                node.right = Node(val)\n            else:\n                node.right = self._insert(node.right, val)\n        node.height = 1 + max(self._get_height(node.left), self._get_height(node.right))\n        return self._balance(node)\n\n    def _get_height(self, node):\n        if not node:\n            return 0\n        return node.height\n\n    def height(self):\n        return self._get_height(self.root)\n\n    def _balance(self, node):\n        if self._get_balance_factor(node) > 1:\n            if self._get_balance_factor(node.left) < 0:\n                node.left = self._rotate_left(node.left)\n            node = self._rotate_right(node)\n        elif self._get_balance_factor(node) < -1:\n            if self._get_balance_factor(node.right) > 0:\n                node.right = self._rotate_right(node.right)\n            node = self._rotate_left(node)\n        return node\n\n    def _get_balance_factor(self, node):\n        if not node:\n            return 0\n        return self._get_height(node.left) - self._get_height(node.right)\n\n    def _rotate_left(self, z):\n        y = z.right\n        T2 = y.left\n        y.left = z\n        z.right = T2\n        z.height = 1 + max(self._get_height(z.left), self._get_height(z.right))\n        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))\n        return y\n\n    def _rotate_right(self, y):\n        x = y.left\n        T2 = x.right\n        x.right = y\n        y.left = T2\n        y.height = 1 + max(self._get_height(y.left), self._get_height(y.right))\n        x.height = 1 + max(self._get_height(x.left), self._get_height(x.right))\n        return x\n\nsolution(\"4\\n1\\n2\\n3\\n4\") "
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    root = TreeNode(int(input_list[1]))\n    counter = 0\n    \n    for i in range(2, len(input_list)):\n        curr_node = root\n        while curr_node:\n            if curr_node.val < int(input_list[i]):\n                if curr_node.right:\n                    curr_node = curr_node.right\n                else:\n                    curr_node.right = TreeNode(int(input_list[i]))\n                    counter += abs(int(input_list[i]) - curr_node.val)\n                    break\n            elif curr_node.val > int(input_list[i]):\n                if curr_node.left:\n                    curr_node = curr_node.left\n                else:\n                    curr_node.left = TreeNode(int(input_list[i]))\n                    counter += abs(int(input_list[i]) - curr_node.val)\n                    break\n            else:\n                break\n    return '\\n'.join([str(counter)])"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    input_list = input_list[1:]\n    num_list = list(map(int, input_list))\n\n    class TreeNode:\n        def __init__(self, val=0, left=None, right=None):\n            self.val = val\n            self.left = left\n            self.right = right\n\n    def insert(node: TreeNode, val: int) -> int:\n        if not node:\n            return 1\n        if val < node.val:\n            node.left = TreeNode(val)\n            return node.left.val + 1\n        else:\n            node.right = TreeNode(val)\n            return node.right.val + 1\n\n    def build_tree(num_list: list) -> TreeNode:\n        root = TreeNode(num_list[0])\n        counter = 0\n        for num in num_list[1:]:\n            counter += insert(root, num)\n            print(counter)\n        return root\n\n    root = build_tree(num_list)\n\n    return '\\n'.join(map(str, num_list))"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def insert_node(node, value):\n        if node is None:\n            return TreeNode(value)\n        elif value < node.val:\n            node.left = insert_node(node.left, value)\n        else:\n            node.right = insert_node(node.right, value)\n        return node\n\n    def get_depth(node):\n        if node is None:\n            return 0\n        left_depth = get_depth(node.left)\n        right_depth = get_depth(node.right)\n        return max(left_depth, right_depth) + 1\n\n    def build_tree(sequence):\n        root = TreeNode(sequence[0])\n        for value in sequence[1:]:\n            root = insert_node(root, value)\n        return root\n\n    N, *sequence = stdin.split()\n    N = int(N)\n\n    root = build_tree(sequence)\n    counter = 0\n\n    for value in sequence:\n        root = insert_node(root, int(value))\n        counter += get_depth(root)\n        print(counter)\n\n    return '\\n'.join(str(counter) for _ in range(N))\n\n\ndef"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(path):\n        for i in range(len(path) - 1):\n            if path[i] == path[i + 1]:\n                return False\n        return True\n\n    def shortest_distance(x1, y1, x2, y2):\n        distance = abs(x2 - x1) + abs(y2 - y1)\n        return distance\n\n    def shortest_path(x1, y1, x2, y2):\n        path = []\n        while x1 != x2 or y1 != y2:\n            if x1 < x2:\n                x1 += 1\n            elif x1 > x2:\n                x1 -= 1\n            if y1 < y2:\n                y1 += 1\n            elif y1 > y2:\n                y1 -= 1\n            path.append((x1, y1))\n        path.append((x2, y2))\n        return path\n\n    def move_stick(x, y, path):\n        min_distance = 10001\n        min_path = []\n        for i in range(len(path)):\n            for j in range(i + 1, len(path)):\n                if is_valid(path[i:j + 1]):\n                    distance = sum([shortest_distance(x, y, p[0], p[1]) for p in path[i:j + 1]])\n                    if distance < min_distance:\n                        min_distance = distance\n                        min_path = path[i:j + 1]\n        return min_path\n\n    def table_cleaning(sticks):\n        path = []\n        for x1, y1, x2, y2 in sticks:\n            path.extend(shortest_path(x1, y1, x2, y2))\n        return path\n\n    input_lines = stdin.split(\"\\n\")\n    N = int(input_lines[0])\n    sticks = [tuple(map(int, input_lines[i].split())) for i in range(1, N + 1)]\n\n    path = table_cleaning(sticks)\n    order = []\n    for i in range(N):\n        stick_path = move_stick(0, i, path)\n        order.append(stick_path.index((0, i)))\n\n    return \" \".join(map(str, order))\n"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    sticks = [tuple(map(int, input_data[i+1].split())) for i in range(n)]\n\n    def is_valid(stick, direction):\n        x, y, x2, y2 = stick\n        if direction == 'left':\n            if x - 1 == x2 and y == y2:\n                return True\n        elif direction == 'right':\n            if x + 1 == x2 and y == y2:\n                return True\n        elif direction == 'up':\n            if y - 1 == y2 and x == x2:\n                return True\n        elif direction == 'down':\n            if y + 1 == y2 and x == x2:\n                return True\n        return False\n\n    def shortest_path(stick, direction, visited):\n        x, y, x2, y2 = stick\n        if is_valid(stick, direction):\n            if direction == 'left' and (x-1, y) not in visited:\n                return (x-1, y, x2, y2)\n            elif direction == 'right' and (x+1, y) not in visited:\n                return (x+1, y, x2, y2)\n            elif direction == 'up' and (x, y-1) not in visited:\n                return (x, y-1, x2, y2)\n            elif direction == 'down' and (x, y+1) not in visited:\n                return (x, y+1, x2, y2)\n        return None\n\n    def remove_stick(stick_to_remove, visited):\n        for direction in ['left', 'right', 'up', 'down']:\n            new_stick = shortest_path(stick_to_remove, direction, visited)\n            if new_stick:\n                visited.add(stick_to_remove)\n                return remove_stick(new_stick, visited)\n        return visited\n\n    stick_labels = [i+1 for i in range(n)]\n    for i in range(n):\n        stick_to_remove = sticks[i]\n        visited = set()\n        result = remove_stick(stick_to_remove, visited)\n        if result:\n            stick_labels[i] = ' '.join(str(label) for label in result)\n\n    return ' '.join(str(label) for label in stick_labels)\n\ninput_data = \"4\\n1 3 2 2\\n1 1 3 2\\n2 4 7 3\\n3 3 5 3\"\nprint(solution(input_data)) "
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_path(x1, y1, x2, y2):\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        if dx == 0:\n            return 0, dx * (dy + 1)\n        if dy == 0:\n            return 0, dx * (dy + 1)\n        if dx == dy:\n            return dx, 0\n        if dx > dy:\n            return dy, 0\n        else:\n            return dx, 0\n\n    N = int(stdin.splitlines()[0])\n    sticks = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    labels = list(range(1, N + 1))\n\n    # Sort sticks based on shortest path from (0, 0)\n    sticks.sort(key=lambda x: shortest_path(0, 0, x[0], x[1]))\n\n    # Determine order of stick movements\n    for x1, y1, x2, y2 in sticks:\n        dx, dy = shortest_path(x1, y1, x2, y2)\n        if dx != 0:\n            labels.append(labels.pop(0))\n\n    return \" \".join(map(str, labels))"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    n = int(stdin.readline())\n    sticks = [list(map(int, stdin.readline().strip().split())) for _ in range(n)]\n\n    # calculate shortest path lengths\n    shortest_path_lengths = [float('inf')] * n\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1, x2, y2 = sticks[i] + sticks[j]\n            dx, dy = abs(x2 - x1), abs(y2 - y1)\n            if dx == 0:\n                shortest_path_lengths[i] = min(shortest_path_lengths[i], dy)\n                shortest_path_lengths[j] = min(shortest_path_lengths[j], dy)\n            elif dy == 0:\n                shortest_path_lengths[i] = min(shortest_path_lengths[i], dx)\n                shortest_path_lengths[j] = min(shortest_path_lengths[j], dx)\n            else:\n                shortest_path_lengths[i] = min(shortest_path_lengths[i], dx + dy)\n                shortest_path_lengths[j] = min(shortest_path_lengths[j], dx + dy)\n\n    # find path\n    path = []\n    while len(path) < n:\n        i = shortest_path_lengths.index(min(shortest_path_lengths))\n        path.append(i)\n        shortest_path_lengths[i] = float('inf')\n        for j in range(i + 1, n):\n            if shortest_path_lengths[j] > min(shortest_path_lengths[i:j] + shortest_path_lengths[j+1:n]):\n                shortest_path_lengths[j] = float('inf')\n\n    # output path\n    return ' '.join(map(str, path))"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    sticks = []\n    for line in stdin.split('\\n')[1:]:\n        x1, y1, x2, y2 = map(int, line.split())\n        sticks.append(((x1, y1), (x2, y2)))\n\n    def shortest_path(start, end):\n        if start == end:\n            return 0\n        dx = abs(start[0] - end[0])\n        dy = abs(start[1] - end[1])\n        return dx + dy\n\n    def remove_stick(x, y, stick):\n        x1, y1, x2, y2 = stick\n        if x == x1 and y == y1:\n            return (x2, y2), 0\n        elif x == x2 and y == y2:\n            return (x1, y1), 0\n        else:\n            return stick, 1\n\n    def get_best_move(x, y, sticks):\n        best_move = None\n        best_score = float('inf')\n        for i, stick in enumerate(sticks):\n            x1, y1, x2, y2 = stick\n            if x == x1 and y == y1:\n                new_x, new_y = x2, y2\n            elif x == x2 and y == y2:\n                new_x, new_y = x1, y1\n            else:\n                continue\n            new_score = shortest_path(x, new_x) + shortest_path(new_x, new_y)\n            if new_score < best_score:\n                best_move = i\n                best_score = new_score\n        return best_move\n\n    def solve(x, y, sticks):\n        if not sticks:\n            return []\n        best_move = get_best_move(x, y, sticks)\n        if best_move is None:\n            return None\n        stick = sticks.pop(best_move)\n        x1, y1, x2, y2 = stick\n        new_x, new_y, status = remove_stick(x, y, stick)\n        if status == 1:\n            return None\n        return [best_move] + solve(new_x, new_y, sticks)\n\n    result = solve(0, 0, sticks)\n    if result is None:\n        return \"No solution\"\n    return ' '.join(map(str, result))"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    sticks = []\n    \n    for i in range(1, N+1):\n        x1, y1, x2, y2 = map(int, input_data[i].split())\n        stick = (x1, y1, x2, y2, i)\n        sticks.append(stick)\n    \n    # Sort the sticks by the order in which they need to be taken off\n    sticks.sort(key=lambda x: (x[0], x[1]))\n    \n    # The output string\n    output = ''\n    \n    # While there are still sticks left on the table\n    while len(sticks) > 0:\n        # Initialize the shortest path length and the stick with the shortest path\n        shortest_path_length = float('inf')\n        shortest_stick = None\n        \n        # For each stick that is currently on the table\n        for stick in sticks:\n            x1, y1, x2, y2, label = stick\n            \n            # Calculate the shortest path length from the current position of the stick\n            path_length = abs(x2 - x1) + abs(y2 - y1)\n            \n            # If the path length is shorter than the current shortest path length\n            if path_length < shortest_path_length:\n                shortest_path_length = path_length\n                shortest_stick = stick\n        \n        # Add the shortest stick to the output string\n        output += str(shortest_stick[4]) + ' '\n        \n        # Remove the shortest stick from the list of sticks on the table\n        sticks.remove(shortest_stick)\n    \n    return output.strip()"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def min_distance(x, y, x_list, y_list):\n        min_d = float('inf')\n        for i in range(len(x_list)):\n            d = distance(x, y, x_list[i], y_list[i])\n            if d < min_d:\n                min_d = d\n        return min_d\n\n    def shortest_path(x, y, x_list, y_list):\n        min_x = min(x_list)\n        min_y = min(y_list)\n        max_x = max(x_list)\n        max_y = max(y_list)\n\n        shortest_x = 0\n        shortest_y = 0\n\n        if x <= min_x and y <= min_y:\n            shortest_x = min_x - x\n            shortest_y = min_y - y\n        elif x >= max_x and y >= max_y:\n            shortest_x = x - max_x\n            shortest_y = y - max_y\n        elif x <= min_x:\n            shortest_x = min_x - x\n            shortest_y = 0\n        elif y <= min_y:\n            shortest_x = 0\n            shortest_y = min_y - y\n        elif x >= max_x:\n            shortest_x = x - max_x\n            shortest_y = 0\n        elif y >= max_y:\n            shortest_x = 0\n            shortest_y = y - max_y\n\n        return shortest_x, shortest_y\n\n    def is_valid(x, y):\n        return 0 <= x <= 10000 and 0 <= y <= 10000\n\n    n = int(input())\n    sticks = [tuple(map(int, input().split())) for _ in range(n)]\n    sticks.sort(key=lambda x: x[1])\n    labels = [i + 1 for i in range(n)]\n    taken_sticks = set()\n\n    for i, (x1, y1, x2, y2) in enumerate(sticks):\n        shortest_x, shortest_y = shortest_path(x1, y1, x_list=[x[0] for x in sticks if x[1] < y1], y_list=[x[1] for x in sticks if x[1] < y1])\n        x, y = x1 + shortest_x, y1 + shortest_y\n\n        while not is_valid(x, y):\n            shortest_x -= 1\n            x -= 1\n\n        if (x, y) in taken_sticks:\n            labels[i], labels[labels.index((x, y))] = labels[labels.index((x, y))], labels[i]\n            taken_sticks.remove((x, y))\n        else:\n            taken_sticks.add((x, y))\n\n    return ' '.join(map(str, labels))\n\nprint(solution(input())) "
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    n = int(stdin)\n    sticks = [tuple(map(int, stdin.split())) for _ in range(n)]\n\n    # sort sticks by x_1\n    sticks.sort(key=lambda stick: stick[0])\n\n    # determine order of stick movements\n    labels = []\n    for i, stick in enumerate(sticks):\n        x1, y1, x2, y2 = stick\n        if x1 == x2:\n            # stick is vertical\n            labels.append(i)\n        elif y1 == y2:\n            # stick is horizontal\n            labels.append(i)\n        else:\n            # stick is diagonal\n            min_x = min(x1, x2)\n            min_y = min(y1, y2)\n            max_x = max(x1, x2)\n            max_y = max(y1, y2)\n            if abs(max_x - min_x) > abs(max_y - min_y):\n                # stick is more horizontal than vertical\n                labels.append(i)\n            else:\n                # stick is more vertical than horizontal\n                labels.append(i)\n\n    # return output\n    return ' '.join(map(str, labels))"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list.pop(0))\n    sticks = [tuple(map(int, input_list[i].split())) for i in range(N)]\n\n    def shortest_path(x1, y1, x2, y2):\n        if x1 == x2:\n            return abs(y1 - y2)\n        elif y1 == y2:\n            return abs(x1 - x2)\n        else:\n            return 10000\n\n    def sort_sticks(sticks):\n        stick_labels = [i for i in range(1, N+1)]\n        stick_labels.sort(key=lambda x: shortest_path(sticks[x-1][0], sticks[x-1][1], 10000, 10000))\n        return stick_labels\n\n    stick_labels = sort_sticks(sticks)\n    return ' '.join(map(str, stick_labels))\n"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_path(a, b):\n        dx = abs(b[0] - a[0])\n        dy = abs(b[1] - a[1])\n        if dx == dy:\n            return ((dx ** 2 + dy ** 2) ** 0.5)\n        elif dx > dy:\n            return dx + (dx - dy)\n        else:\n            return dy + (dy - dx)\n\n    def clean_sticks(sticks):\n        stick_order = []\n        for i in range(len(sticks)):\n            stick_order.append((i, sticks[i][1]))\n\n        stick_order.sort(key=lambda x: x[1])\n        return [x[0] for x in stick_order]\n\n    def main(sticks):\n        stick_labels = clean_sticks(sticks)\n        return \" \".join(map(str, stick_labels))\n\n    def parse_input(input_data):\n        sticks = []\n        n = int(input_data[0])\n        for i in range(1, n + 1):\n            x1, y1, x2, y2 = map(int, input_data[i].split())\n            sticks.append(((x1, y1), (x2, y2)))\n        return sticks\n\n    input_data = stdin.split(\"\\n\")\n    sticks = parse_input(input_data)\n    return main(sticks)\n\n\ninput1 = \"\"\"4\n1 3 2 2\n1 1 3 2\n2 4 7 3\n3 3 5 3\"\"\"\n\ninput2 = \"\"\"4\n0 0 1 1\n1 2 0 3\n2 2 3 3\n4 0 3 1\"\"\"\n\nprint(solution(input1))  # Output: 2 4 1 3\nprint(solution(input2))  # Output: 4 3 1 2 "
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Initialize the decks and the players' hands\n    deck = list(stdin)\n    Theta_hand = deck[:10]\n    Theta_hand.sort()\n    Theta_slots = ['', '', '', '', '']\n    Theta_j_count = 0\n\n    Theta_friend_hand = deck[10:20]\n    Theta_friend_hand.sort()\n    Theta_friend_slots = ['', '', '', '', '']\n    Theta_friend_j_count = 0\n\n    # Initialize the discard pile and the drawing pile\n    discard_pile = []\n    drawing_pile = deck[20:]\n\n    # Function to place a card in a slot, update the slots, and check for a win\n    def place_card(player, card, slot_num):\n        player_slots = Theta_slots if player == 'Theta' else Theta_friend_slots\n        if card in ['A', 'J', 'Q', 'K']:\n            if player_slots[slot_num] == '':\n                player_slots[slot_num] = card\n                return True\n            else:\n                return False\n        else:\n            if player_slots[slot_num] == '':\n                player_slots[slot_num] = card\n                return True\n            elif player_slots[slot_num] == card:\n                player_slots[slot_num] = ''\n                return True\n            else:\n                return False\n\n    # Function to update the jack count for each player\n    def update_j_count(player):\n        nonlocal Theta_j_count, Theta_friend_j_count\n        if player == 'Theta':\n            Theta_j_count += Theta_hand.count('J')\n        else:\n            Theta_friend_j_count += Theta_friend_hand.count('J')\n\n    # Function to check if a card can be placed in a slot\n    def can_place_card(player, card, slot_num):\n        player_slots = Theta_slots if player == 'Theta' else Theta_friend_slots\n        if card in ['A', 'J', 'Q', 'K']:\n            if player_slots[slot_num] == '':\n                return True\n            else:\n                return False\n        else:\n            if player_slots[slot_num] == '':\n                return True\n            elif player_slots[slot_num] == card:\n                return False\n            else:\n                return False\n\n    # Function to check if a player has won\n    def check_win(player):\n        player_slots = Theta_slots if player == 'Theta' else Theta_friend_slots\n        return all(slot != '' for slot in player_slots)\n\n    # Play the game\n    turn = 'Theta'\n    while True:\n        # Theta's turn\n        if turn == 'Theta':\n            # Draw a card\n            if len(drawing_pile) == 0:\n                print('Delta has run out of cards, Theta wins!')\n                return 'Theta wins'\n            drawn_card = drawing_pile.pop(0)\n            Theta_hand.append(drawn_card)\n            Theta_hand.sort()\n            update_j_count('Theta')\n\n            # Place the card\n            for slot_num in range(len(Theta_slots)):\n                if can_place_card('Theta', drawn_card, slot_num):\n                    if place_card('Theta', drawn_card, slot_num):\n                        break\n\n            # Check for a win\n            if check_win('Theta'):\n                print('Theta wins!')\n                return 'Theta wins'\n\n            # Switch to Delta's turn\n            turn = 'Delta'\n\n        # Delta's turn\n        else:\n            # Draw a card\n            if len(drawing_pile) == 0:\n                print('Theta has run out of cards, Delta wins!')\n                return 'Delta wins'\n            drawn_card = drawing_pile.pop(0)\n            Theta_friend_hand.append(drawn_card)\n            Theta_friend_hand.sort()\n"
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_card_value(card: str) -> int:\n        if card == 'A':\n            return 1\n        if card == 'J':\n            return 11\n        if card == 'Q':\n            return 12\n        if card == 'K':\n            return 13\n        return int(card)\n\n    def get_card_suit(card: str) -> str:\n        return card[1:]\n\n    def place_card(player_cards: list, card: str) -> bool:\n        value = get_card_value(card)\n        suit = get_card_suit(card)\n\n        if suit == 'T' or suit == 'J':\n            suit = 'A'\n\n        for slot_value, slot_suit in player_cards:\n            if slot_suit == suit and slot_value == value:\n                slot_value = -1\n                return True\n        return False\n\n    def get_lowest_unfilled_slot(player_cards: list, suit: str) -> int:\n        for i, (slot_value, slot_suit) in enumerate(player_cards):\n            if slot_suit == suit and slot_value == -1:\n                return i\n        return -1\n\n    def get_player_cards(player_face_down: list, player_discard: list) -> list:\n        player_cards = []\n        for card in player_face_down:\n            player_cards.append((get_card_value(card), get_card_suit(card)))\n        for card in player_discard:\n            player_cards.append((get_card_value(card), get_card_suit(card)))\n        return player_cards\n\n    player_cards = []\n    player_face_down = stdin[:10]\n    player_friend_cards = stdin[10:20]\n    player_discard = []\n    player_turn = 0\n\n    # First player takes the first 10 cards\n    for i, card in enumerate(player_face_down):\n        if place_card(player_cards, card):\n            player_cards.remove((get_card_value(card), get_card_suit(card)))\n            player_cards.append((-1, 'A'))\n            player_turn = 0\n        else:\n            player_turn = 1\n            break\n\n    # Second player takes the remaining cards\n    for card in player_friend_cards:\n        if place_card(player_cards, card):\n            player_cards.remove((get_card_value(card), get_card_suit(card)))\n            player_cards.append((-1, 'A'))\n            player_turn = 0\n        else:\n            player_turn = 1\n\n    # First player's turn\n    while True:\n        card = player_discard[-1]\n        suit = get_card_suit(card)\n        lowest_unfilled_slot = get_lowest_unfilled_slot(player_cards, suit)\n\n        if lowest_unfilled_slot != -1:\n            player_cards.remove((get_card_value(card), get_card_suit(card)))\n            player_cards.insert(lowest_unfilled_slot, (-1, 'A'))\n            player_turn = 0\n        else:\n            player_discard.pop()\n            player_turn = 1\n\n        # Second player's turn\n        if not player_discard:\n            break\n\n    if player_turn == 0:\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin[:52]\n    \n    # Deal the cards to Theta and her friend\n    th1 = []\n    th2 = []\n    for i in range(10):\n        th1.append(deck[i])\n        th2.append(deck[i+10])\n    \n    # Play the game\n    while th1 and th2:\n        # Turn a card from Theta's hand and play it\n        turn1 = th1.pop(0)\n        if turn1 == 'J':\n            slot1 = th1.index('A') if 'A' in th1 else 10\n            th1.pop(slot1) if slot1 < 10 else None\n            th2.append(turn1)\n        elif turn1 in ('A', 'Q', 'K'):\n            slot1 = th1.index(str(int(turn1) + 1)) if str(int(turn1) + 1) in th1 else 10\n            th1.pop(slot1) if slot1 < 10 else None\n            th2.append(turn1)\n        elif turn1 in ('2', '3', '4', '5', '6', '7', '8', '9', 'T'):\n            slot1 = th1.index(str(int(turn1) + 1)) if str(int(turn1) + 1) in th1 else 10\n            th1.pop(slot1) if slot1 < 10 else None\n            th2.append(turn1)\n        \n        # Turn a card from Theta's friend's hand and play it\n        turn2 = th2.pop(0)\n        if turn2 == 'J':\n            slot2 = th2.index('A') if 'A' in th2 else 10\n            th1.append(turn2)\n        elif turn2 in ('A', 'Q', 'K'):\n            slot2 = th2.index(str(int(turn2) + 1)) if str(int(turn2) + 1) in th2 else 10\n            th1.append(turn2)\n        elif turn2 in ('2', '3', '4', '5', '6', '7', '8', '9', 'T'):\n            slot2 = th2.index(str(int(turn2) + 1)) if str(int(turn2) + 1) in th2 else 10\n            th1.append(turn2)\n        \n        # Check if Theta can win\n        if len(th1) == 0:\n            return \"Theta loses\"\n        if len(th2) == 0:\n            return \"Theta wins\"\n    \n    # Check if Theta can win when the deck runs out\n    if len(th1) == 0:\n        return \"Theta loses\"\n    else:\n        return \"Theta wins\""
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    deck = [c for c in stdin]\n    n = len(deck)\n    Theta_cards = deck[:20]\n    friend_cards = deck[20:]\n    Theta_slots = [-1] * 10\n    friend_slots = [-1] * 10\n\n    # Deal cards\n    for i in range(10):\n        Theta_slots[i] = int(Theta_cards[i])\n\n    for i in range(10, 20):\n        friend_slots[i - 10] = int(friend_cards[i])\n\n    Theta_cards = Theta_cards[10:]\n    friend_cards = friend_cards[10:]\n\n    # Play Trash\n    while Theta_cards or friend_cards:\n        if Theta_cards:\n            card = Theta_cards.pop(0)\n        else:\n            card = friend_cards.pop(0)\n\n        # Theta's turn\n        if card in \"23456789T\":\n            for i, slot in enumerate(Theta_slots):\n                if slot == -1:\n                    Theta_slots[i] = int(card)\n                    break\n\n        # Theta's friend's turn\n        elif card in \"AJQK\":\n            for i, slot in enumerate(friend_slots):\n                if slot == -1:\n                    friend_slots[i] = int(card)\n                    break\n\n        # Jack\n        elif card == \"J\":\n            for i, slot in enumerate(Theta_slots):\n                if slot == -1:\n                    Theta_slots[i] = int(card)\n                    break\n\n            for i, slot in enumerate(friend_slots):\n                if slot == -1:\n                    friend_slots[i] = int(card)\n                    break\n\n    # Determine winner\n    if all(slot != -1 for slot in Theta_slots):\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\"\n"
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(stdin)\n    remaining_cards = deck.copy()\n    Theta_cards = []\n    Theta_slots = [0] * 10\n    friend_slots = [0] * 10\n    \n    for _ in range(10):\n        Theta_cards.append(remaining_cards.pop(0))\n        friend_slots.append(remaining_cards.pop(0))\n    \n    for _ in range(20):\n        remaining_cards.pop(0)\n    \n    while Theta_slots.count(0) > 0:\n        drawn_card = remaining_cards.pop(0)\n        \n        if drawn_card == 'J':\n            for i in range(len(Theta_slots)):\n                if Theta_slots[i] == 0:\n                    Theta_slots[i] = 1\n                    break\n        \n        if drawn_card.isnumeric():\n            num_drawn = int(drawn_card)\n            for i in range(len(Theta_slots)):\n                if Theta_slots[i] == 0:\n                    Theta_slots[i] = num_drawn\n                    break\n        \n        elif drawn_card in ['A', 'K', 'Q', 'J', 'T']:\n            for i in range(len(Theta_slots)):\n                if Theta_slots[i] == 0:\n                    Theta_slots[i] = 1\n                    break\n    \n    if Theta_slots.count(0) == 0:\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(stdin)\n    deck_size = len(deck)\n    thota_cards = [0] * 21\n    friend_cards = [0] * 21\n    thota_score = 0\n    friend_score = 0\n    \n    for i in range(21):\n        thota_cards[i], friend_cards[i] = deck.pop(0), deck.pop(0)\n        \n    for _ in range(10):\n        thota_cards.pop(0), friend_cards.pop(0)\n    \n    while deck:\n        thota_card, friend_card = deck.pop(0), deck.pop(0)\n        \n        if thota_card == \"J\":\n            thota_cards.append(thota_card)\n        else:\n            thota_cards.append(int(thota_card))\n        \n        if friend_card == \"J\":\n            friend_cards.append(friend_card)\n        else:\n            friend_cards.append(int(friend_card))\n        \n        if thota_cards.count(\"J\") > friend_cards.count(\"J\"):\n            thota_score += 1\n        elif thota_cards.count(\"J\") < friend_cards.count(\"J\"):\n            friend_score += 1\n        else:\n            if thota_cards.count(1) > friend_cards.count(1):\n                thota_score += 1\n            elif thota_cards.count(1) < friend_cards.count(1):\n                friend_score += 1\n            else:\n                thota_score += 1\n                friend_score += 1\n    \n    if thota_score > friend_score:\n        return \"Theta wins\"\n    else:\n        return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_score(cards: str, used_jacks: int) -> int:\n        score = 0\n        for card in cards:\n            if card == \"A\":\n                score += 1\n            elif card == \"J\":\n                score += used_jacks\n            elif card == \"Q\":\n                score += 10\n            elif card == \"K\":\n                score += 10\n            else:\n                score += int(card)\n        return score\n\n    def get_used_jacks(cards: str) -> int:\n        return cards.count(\"J\")\n\n    def is_valid_move(cards: str, used_jacks: int) -> bool:\n        score = get_score(cards, used_jacks)\n        score = score % 10\n        return score == 0\n\n    def is_winning_move(cards: str, used_jacks: int) -> bool:\n        score = get_score(cards, used_jacks)\n        if score % 10 == 0:\n            return True\n        return False\n\n    def find_winning_move(cards: str, used_jacks: int) -> int:\n        for i in range(len(cards)):\n            if is_winning_move(cards[:i] + \"J\" + cards[i + 1:], used_jacks + 1):\n                return i\n        return -1\n\n    stdin = stdin.replace(\"T\", \"10\")\n    deck = stdin[:52]\n    face_down_cards = deck[:20]\n    face_up_cards = deck[20:]\n    discard_pile = \"\"\n\n    for i in range(10):\n        if is_valid_move(face_up_cards[:10], 0):\n            if is_winning_move(face_up_cards[:10], 0):\n                return \"Theta wins\"\n        else:\n            discard_pile += face_up_cards[i]\n\n    while True:\n        if len(face_up_cards) == 0:\n            face_up_cards = face_down_cards\n            face_down_cards = \"\"\n\n        for i in range(10):\n            if is_valid_move(face_up_cards[:10], get_used_jacks(discard_pile)):\n                if is_winning_move(face_up_cards[:10], get_used_jacks(discard_pile)):\n                    return \"Theta wins\"\n            else:\n                discard_pile += face_up_cards[i]\n\n        face_up_cards = face_up_cards[10:]\n        face_down_cards = face_down_cards[10:]\n\n        if find_winning_move(face_up_cards, get_used_jacks(discard_pile)) != -1:\n            return \"Theta loses\""
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(stdin)\n    players = [\"Theta\", \"Friend\"]\n    hands = {player: list(deck[:10]) for player in players}\n    discard_pile = []\n    \n    # shuffle and deal cards\n    for player in players:\n        random.shuffle(hands[player])\n        hands[player].sort()\n    \n    # determine who starts the game\n    if hands[\"Theta\"][0] < hands[\"Friend\"][0]:\n        current_player = \"Theta\"\n    else:\n        current_player = \"Friend\"\n    \n    # play the game\n    while len(discard_pile) < 52:\n        # draw a card\n        drawn_card = hands[current_player].pop(0)\n        discard_pile.append(drawn_card)\n        \n        # check if the card can be placed in a slot\n        for slot in range(10):\n            if len(hands[current_player]) < slot+1:\n                break\n            if hands[current_player][slot] == 'A':\n                if drawn_card == 'A':\n                    hands[current_player][slot] = drawn_card\n                    break\n            elif hands[current_player][slot] == 'J':\n                if drawn_card == 'J':\n                    hands[current_player][slot] = drawn_card\n                    break\n            elif int(hands[current_player][slot]) == int(drawn_card):\n                hands[current_player][slot] = drawn_card\n                break\n        \n        # if no slot was filled, discard the card and continue with the next player\n        if len(hands[current_player]) == 0:\n            discard_pile.pop()\n            if current_player == \"Theta\":\n                current_player = \"Friend\"\n            else:\n                current_player = \"Theta\"\n        \n        # if all slots are filled, determine the winner and return the result\n        elif all(hands[current_player][slot] == drawn_card for slot in range(10)):\n            return \"Theta wins\"\n    \n    # if the deck runs out before a winner is determined, Theta wins\n    return \"Theta wins\""
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_card_value(card: str) -> int:\n        if card in \"23456789\":\n            return int(card)\n        elif card == \"T\":\n            return 10\n        elif card == \"J\":\n            return 1\n        elif card == \"Q\":\n            return 1\n        elif card == \"K\":\n            return 1\n        else:\n            return 0\n\n    def count_filled_slots(hand: str) -> int:\n        filled_slots = 0\n        for i in range(10):\n            if hand[i] != \" \":\n                filled_slots += 1\n        return filled_slots\n\n    def is_valid_move(card: str, hand: str) -> bool:\n        for i in range(10):\n            if hand[i] == \" \":\n                return True\n        return False\n\n    def is_wildcard(card: str) -> bool:\n        return card == \"J\"\n\n    def play_card(hand: str, card: str) -> str:\n        for i in range(10):\n            if hand[i] == \" \":\n                return hand[:i] + card + hand[i + 1 :]\n        return hand\n\n    def discard_card(hand: str, card: str) -> str:\n        if card in hand:\n            return hand.replace(card, \" \", 1)\n        return hand\n\n    def can_win(hand: str, deck: str) -> bool:\n        for card in deck:\n            if is_valid_move(card, hand) and get_card_value(card) <= 10 - count_filled_slots(hand):\n                return True\n        return False\n\n    def play_game(hand1: str, hand2: str, deck: str) -> str:\n        deck = list(deck)\n        while can_win(hand1, deck):\n            card = deck.pop(0)\n            if is_wildcard(card):\n                for i in range(10):\n                    if hand1[i] == \" \":\n                        hand1 = play_card(hand1, card)\n                        break\n            else:\n                if is_valid_move(card, hand1):\n                    hand1 = play_card(hand1, card)\n\n        while can_win(hand2, deck):\n            card = deck.pop(0)\n            if is_wildcard(card):\n                for i in range(10):\n                    if hand2[i] == \" \":\n                        hand2 = play_card(hand2, card)\n                        break\n            else:\n                if is_valid_move(card, hand2):\n                    hand2 = play_card(hand2, card)\n\n        if count_filled_slots(hand1) < count_filled_slots(hand2):\n            return \"Theta loses\"\n        else:\n            return \"Theta wins\"\n\n    hand1 = stdin[:10]\n    hand2 = stdin[10:20]\n    deck = stdin[20:]\n\n    return play_game(hand1, hand2, deck)"
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    deck = stdin\n    # Shuffle the deck\n    random.shuffle(deck)\n\n    # Deal the cards\n    theta_cards = deck[:10]\n    friend_cards = deck[10:20]\n\n    # Initialize the game\n    theta_slots = [\"\" for _ in range(10)]\n    friend_slots = [\"\" for _ in range(10)]\n    discard_pile = []\n\n    # Game loop\n    while True:\n        # Theta's turn\n        theta_card = theta_cards.pop(0)\n        if not theta_card.isdigit():\n            # Discard the Jack and play the next card\n            discard_pile.append(theta_card)\n            continue\n        theta_slot = int(theta_card) - 1\n        if not theta_slots[theta_slot]:\n            theta_slots[theta_slot] = theta_card\n        else:\n            # Discard the card and play the next card\n            discard_pile.append(theta_card)\n            continue\n\n        # Check if Theta has won\n        if all(theta_slot for theta_slot in theta_slots if theta_slot):\n            return \"Theta wins\"\n\n        # Friend's turn\n        friend_card = friend_cards.pop(0)\n        if not friend_card.isdigit():\n            # Discard the Jack and play the next card\n            discard_pile.append(friend_card)\n            continue\n        friend_slot = int(friend_card) - 1\n        if not friend_slots[friend_slot]:\n            friend_slots[friend_slot] = friend_card\n        else:\n            # Discard the card and play the next card\n            discard_pile.append(friend_card)\n            continue\n\n        # Check if Theta has won\n        if all(friend_slot for friend_slot in friend_slots if friend_slot):\n            return \"Theta wins\"\n\nimport random"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N, K = map(int, input_lines[0].split())\n    candidates = {i: \"charlatan\" for i in range(1, N+1)}\n\n    for i in range(1, K+1):\n        speaker, uttered_statement = input_lines[i].split(maxsplit=1)\n        if uttered_statement.startswith(\"truther\"):\n            candidates[int(uttered_statement[7:])] = \"truther\"\n        elif uttered_statement.startswith(\"fabulist\"):\n            candidates[int(uttered_statement[8:])] = \"fabulist\"\n        elif uttered_statement.startswith(\"charlatan\"):\n            candidates[int(uttered_statement[8:])] = \"charlatan\"\n        elif uttered_statement.startswith(\"not\"):\n            assert uttered_statement[3:].startswith(\"charlatan\")\n            candidates[int(uttered_statement[7:])] = \"truther\" if candidates[int(uttered_statement[7:])] == \"charlatan\" else \"fabulist\"\n        elif uttered_statement.startswith(\"and\"):\n            p, q = uttered_statement[3:].split(\" \")\n            if candidates[int(p[7:])] == \"charlatan\" or candidates[int(q[7:])] == \"charlatan\":\n                candidates[int(p[7:])] = \"charlatan\"\n                candidates[int(q[7:])] = \"charlatan\"\n            elif candidates[int(p[7:])] == \"truther\" and candidates[int(q[7:])] == \"truther\":\n                candidates[int(p[7:])] = \"truther\"\n                candidates[int(q[7:])] = \"truther\"\n            else:\n                candidates[int(p[7:])] = \"fabulist\"\n                candidates[int(q[7:])] = \"fabulist\"\n        elif uttered_statement.startswith(\"xor\"):\n            p, q = uttered_statement[3:].split(\" \")\n            if candidates[int(p[7:])] == \"truther\" and candidates[int(q[7:])] == \"truther\":\n                candidates[int(p[7:])] = \"fabulist\"\n                candidates[int(q[7:])] = \"fabulist\"\n            elif candidates[int(p[7:])] == \"fabulist\" and candidates[int(q[7:])] == \"fabulist\":\n                candidates[int(p[7:])] = \"truther\"\n                candidates[int(q[7:])] = \"truther\"\n            else:\n                candidates[int(p[7:])] = \"charlatan\"\n                candidates[int(q[7:])] = \"charlatan\"\n\n    return \"\\n\".join(candidates[i] for i in range(1, N+1))"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, K = map(int, stdin.split()[0:2])\n    lines = stdin.split(\"\\n\")[1:]\n    \n    # Initialize character types\n    types = [\"truther\"] * N\n    \n    # Process utterances\n    for line in lines:\n        tokens = line.split()\n        if len(tokens) == 3 and tokens[1] == \"charlatan\":\n            types[int(tokens[2]) - 1] = \"fabulist\"\n        elif len(tokens) == 3 and tokens[1] == \"not\":\n            types[int(tokens[2]) - 1] = \"charlatan\"\n    \n    # Output character types\n    return \"\\n\".join(types)"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_truther(utterance):\n        return utterance.startswith(\"truther\")\n\n    def is_fabulist(utterance):\n        return utterance.startswith(\"fabulist\")\n\n    def is_charlatan(utterance):\n        return utterance.startswith(\"charlatan\")\n\n    def is_not(utterance):\n        return utterance.startswith(\"not \")\n\n    def is_and(utterance):\n        return utterance.startswith(\"and \")\n\n    def is_xor(utterance):\n        return utterance.startswith(\"xor \")\n\n    candidates = {}\n    n, k = map(int, stdin.split()[:2])\n    for i in range(n):\n        candidates[i + 1] = \"truther\"\n\n    for i in range(k):\n        utterance = stdin.split()[i + 2]\n        if is_truther(utterance):\n            candidate, _, other_candidate = utterance.split()\n            if candidates[int(candidate)] != \"charlatan\":\n                candidates[int(candidate)] = \"truther\"\n            if candidates[int(other_candidate)] != \"charlatan\":\n                candidates[int(other_candidate)] = \"truther\"\n        elif is_fabulist(utterance):\n            candidate, _, other_candidate = utterance.split()\n            if candidates[int(candidate)] != \"charlatan\":\n                candidates[int(candidate)] = \"fabulist\"\n            if candidates[int(other_candidate)] != \"charlatan\":\n                candidates[int(other_candidate)] = \"fabulist\"\n        elif is_charlatan(utterance):\n            candidate, _, other_candidate = utterance.split()\n            if candidates[int(candidate)] != \"charlatan\":\n                candidates[int(candidate)] = \"charlatan\"\n            if candidates[int(other_candidate)] != \"charlatan\":\n                candidates[int(other_candidate)] = \"charlatan\"\n        elif is_not(utterance):\n            candidate, _, other_candidate = utterance.split()\n            if candidates[int(candidate)] != \"charlatan\":\n                candidates[int(candidate)] = \"not \" + candidates[int(candidate)]\n            if candidates[int(other_candidate)] != \"charlatan\":\n                candidates[int(other_candidate)] = \"not \" + candidates[int(other_candidate)]\n        elif is_and(utterance):\n            candidate, _, other_candidate, _, other_other_candidate = utterance.split()\n            if candidates[int(candidate)] != \"charlatan\" and candidates[int(other_candidate)] != \"charlatan\":\n                candidates[int(candidate)] = \"and \" + candidates[int(candidate)] + \" \" + candidates[int(other_candidate)]\n            if candidates[int(other_other_candidate)] != \"charlatan\":\n                candidates[int(other_other_candidate)] = \"and \" + candidates[int(other_other_candidate)] + \" \" + candidates[int(other_candidate)]\n        elif is_xor(utterance):\n            candidate, _, other_candidate, _, other_other_candidate = utterance.split()\n            if candidates[int(candidate)] != \"charlatan\" and candidates[int(other_candidate)] != \"charlatan\":\n                candidates[int(candidate)] = \"xor \" + candidates[int(candidate)] + \" \" + candidates[int(other_candidate)]\n            if candidates[int(other_other_candidate)] != \"charlatan\":\n                candidates[int(other_other_candidate)] = \"xor \" + candidates[int(other_other_candidate)] + \" \" + candidates[int(other_candidate)]\n\n    return \" \".join(candidates[i] for i in range(1, n + 1))"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    candidates = [None] * N\n    \n    for _ in range(K):\n        speaker, uttered = input().split()\n        speaker = int(speaker)\n        \n        if uttered.startswith('truther'):\n            candidates[int(uttered[7:-1]) - 1] = 'truther'\n        elif uttered.startswith('fabulist'):\n            candidates[int(uttered[8:-1]) - 1] = 'fabulist'\n        elif uttered.startswith('charlatan'):\n            candidates[int(uttered[9:-1]) - 1] = 'charlatan'\n        else:\n            uttered = uttered.split()\n            for i in range(len(uttered)):\n                if uttered[i] == 'not':\n                    if candidates[speaker - 1] == uttered[i + 1]:\n                        candidates[speaker - 1] = None\n                elif uttered[i] == 'and':\n                    if (candidates[int(uttered[i + 1]) - 1] == candidates[int(uttered[i + 2]) - 1]):\n                        candidates[speaker - 1] = None\n                elif uttered[i] == 'xor':\n                    if (candidates[int(uttered[i + 1]) - 1] != candidates[int(uttered[i + 2]) - 1]) and (candidates[int(uttered[i + 1]) - 1] != None and candidates[int(uttered[i + 2]) - 1] != None):\n                        candidates[speaker - 1] = None\n                    \n    for i in range(N):\n        if candidates[i] != None:\n            print(candidates[i])\n        else:\n            print(\"charlatan\")\n            \n"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    candidates = [None] * N\n    \n    for i in range(K):\n        speaker, uttered = input().split()\n        speaker = int(speaker)\n        \n        if uttered.startswith('truther') or uttered.startswith('fabulist') or uttered.startswith('charlatan'):\n            candidates[speaker-1] = uttered.split()[0]\n    \n    for candidate in candidates:\n        if candidate is None:\n            candidates[0] = 'truther'\n    \n    result = [None] * N\n    for i in range(N):\n        result[i] = candidates[i]\n    \n    return '\\n'.join(result)"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def get_candidate_type(candidate: int, transcript: list) -> str:\n        for utterance in transcript:\n            if utterance[0] == candidate:\n                proposition = utterance[1]\n                if proposition.startswith('truther '):\n                    return 'truther'\n                elif proposition.startswith('fabulist '):\n                    return 'fabulist'\n                elif proposition.startswith('charlatan '):\n                    return 'charlatan'\n\n    stdin_list = stdin.split('\\n')\n    N, K = map(int, stdin_list[0].split())\n    transcript = stdin_list[1:]\n    output = [get_candidate_type(i, transcript) for i in range(1, N+1)]\n    return '\\n'.join(output)"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, *transcript = stdin.split('\\n')\n    N, K = map(int, N.split())\n    candidates = [None] * N\n    for i, candidate in enumerate(transcript):\n        name, *statements = candidate.split()\n        name = int(name)\n        statements = ' '.join(statements)\n        candidates[name-1] = statements\n    \n    for i in range(N):\n        charlatan = False\n        truther = False\n        fabulist = False\n        for j in range(N):\n            if f\"charlatan {j+1}\" in candidates[i]:\n                charlatan = True\n            if f\"truther {j+1}\" in candidates[i]:\n                truther = True\n            if f\"fabulist {j+1}\" in candidates[i]:\n                fabulist = True\n        if charlatan:\n            print(\"charlatan\")\n        elif truther:\n            print(\"truther\")\n        elif fabulist:\n            print(\"fabulist\")\n            \ndef"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    candidates = [\"truther\", \"fabulist\", \"charlatan\"]\n    candidates_index = {i + 1: c for i, c in enumerate(candidates)}\n    transcript = stdin.split(\"\\n\")[1:]\n    for utterance in transcript:\n        speaker, statement = utterance.split()\n        speaker = int(speaker)\n        for i, c in candidates_index.items():\n            if f\"charlatan {i}\" in statement:\n                candidates_index[i] = \"charlatan\"\n            if f\"truther {i}\" in statement:\n                candidates_index[i] = \"truther\"\n            if f\"fabulist {i}\" in statement:\n                candidates_index[i] = \"fabulist\"\n    output = [candidates_index[i] for i in range(1, N+1)]\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, K = map(int, stdin.split()[0:2])\n    utterances = stdin.split(\"\\n\")[1:]\n    \n    # initialize candidate types\n    types = [\"charlatan\"] * N\n    \n    # analyze utterances\n    for utterance in utterances:\n        speaker, statement = utterance.split()\n        speaker = int(speaker)\n        statement = statement.replace(\" \", \"\")\n        \n        # resolve propositions\n        if statement.startswith(\"truther\"):\n            types[int(statement.split(\"truther\")[1])-1] = \"truther\"\n        elif statement.startswith(\"fabulist\"):\n            types[int(statement.split(\"fabulist\")[1])-1] = \"fabulist\"\n        elif statement.startswith(\"charlatan\"):\n            types[int(statement.split(\"charlatan\")[1])-1] = \"charlatan\"\n        elif statement.startswith(\"not\"):\n            types[int(statement.split(\"not\")[1])-1] = \"not\"\n        elif statement.startswith(\"and\"):\n            types[int(statement.split(\"and\")[1])-1] = types[int(statement.split(\"and\")[2])-1]\n        elif statement.startswith(\"xor\"):\n            types[int(statement.split(\"xor\")[1])-1] = \"not\"\n    \n    # return results\n    return \"\\n\".join(types)"
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N, K = map(int, lines[0].split())\n    candidates = {}\n    for line in lines[1:]:\n        name, utterance = line.split(' ', 1)\n        if name not in candidates:\n            candidates[name] = {}\n        candidate = candidates[name]\n        for part in utterance.split():\n            if part.startswith('truther') or part.startswith('fabulist') or part.startswith('charlatan'):\n                prop = part.split('<')[1][:-1]\n                if prop not in candidate:\n                    candidate[prop] = None\n                if part.startswith('truther'):\n                    candidate[prop] = 'truther'\n                elif part.startswith('fabulist'):\n                    candidate[prop] = 'fabulist'\n                elif part.startswith('charlatan'):\n                    candidate[prop] = 'charlatan'\n            elif part == 'not':\n                candidate['not'] = not candidate['not'] if 'not' in candidate else False\n            elif part == 'and':\n                candidate['and'] = candidate.get('and', True) and candidate.get(utterance.split()[1], False)\n            elif part == 'xor':\n                candidate['xor'] = candidate.get('xor', False) != candidate.get(utterance.split()[1], False)\n    result = [candidates[str(i)].get('truther', candidates[str(i)].get('fabulist', candidates[str(i)].get('charlatan', 'unknown'))) for i in range(1, N+1)]\n    return '\\n'.join(result)"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    fruits = [list(map(float, line.split())) for line in stdin.split('\\n')[1:]]\n    \n    max_slices = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1 = fruits[i]\n            x2, y2 = fruits[j]\n            distance = ((x2 - x1)**2 + (y2 - y1)**2)**0.5\n            max_slices = max(max_slices, distance)\n            \n    return int(max_slices)\n\ndef"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def line_intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n        \"\"\"\n        Check if the line defined by (x1, y1) and (x2, y2) intersects the line defined by (x3, y3) and (x4, y4).\n        \"\"\"\n        denom = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3)\n        if denom == 0:  # lines are parallel\n            return False\n        ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom\n        ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom\n        return 0 <= ua <= 1 and 0 <= ub <= 1\n\n    n = int(stdin.splitlines()[0])\n    fruits = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n    max_slices = 0\n\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                x1, y1 = fruits[i]\n                x2, y2 = fruits[j]\n                for k in range(n):\n                    if k != i and k != j:\n                        x3, y3 = fruits[k]\n                        x4, y4 = fruits[k - 1] if k > 0 else fruits[n - 1]\n                        if line_intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n                            max_slices += 1\n\n    return str(max_slices)\n\n\ndef"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    fruits = [tuple(map(float, input_data[i].split())) for i in range(1, n+1)]\n    \n    max_slices = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1 = fruits[i]\n            x2, y2 = fruits[j]\n            if (x2-x1)**2 + (y2-y1)**2 <= 2:\n                max_slices += 1\n    \n    return str(max_slices)\n\ninput_data = \"\"\"5\n1.00 5.00\n3.00 3.00\n4.00 2.00\n6.00 4.50\n7.00 1.00\"\"\"\n\noutput = solution(input_data)\nprint(output)\n\ninput_data = \"\"\"3\n-1.50 -1.00\n1.50 -1.00\n0.00 1.00\"\"\"\n\noutput = solution(input_data)\nprint(output)"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin)\n    fruits = []\n    for i in range(n):\n        x, y = map(float, stdin.split())\n        fruits.append((x, y))\n\n    # Calculate the maximum number of fruits that can be sliced\n    max_fruits = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = fruits[i]\n            x2, y2 = fruits[j]\n            slope = (y2 - y1) / (x2 - x1)\n            intercept = y1 - slope * x1\n            max_x = 10\n            min_x = -10\n            max_y = slope * max_x + intercept\n            min_y = slope * min_x + intercept\n            if max_y < min_y:\n                max_y, min_y = min_y, max_y\n            for k in range(n):\n                x3, y3 = fruits[k]\n                if x3 <= max_x and x3 >= min_x and y3 >= min_y and y3 <= max_y:\n                    max_fruits = max(max_fruits, k - i - 1)\n    return str(max_fruits)"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    fruits = []\n    for i in range(1, n+1):\n        x, y = map(float, input_list[i].split())\n        fruits.append((x, y))\n\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_slice_possible(start, end):\n        start_x, start_y = start\n        end_x, end_y = end\n        for fruit in fruits:\n            if cross_product(start, end, fruit) != 0:\n                return True\n            elif distance(fruit, start) > distance(fruit, end):\n                return False\n        return False\n\n    def count_fruits(fruits):\n        count = 0\n        for i in range(len(fruits)):\n            start_x, start_y = fruits[i]\n            for j in range(i + 1, len(fruits)):\n                end_x, end_y = fruits[j]\n                if is_slice_possible((start_x, start_y), (end_x, end_y)):\n                    count += 1\n        return count\n\n    fruit_count = count_fruits(fruits)\n    return str(fruit_count)"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, *fruits = stdin.split('\\n')\n    n = int(n)\n    fruits = [tuple(map(float, fruit.split())) for fruit in fruits]\n\n    def intersect(a, b, c, d):\n        return min(a, b) <= max(c, d) and min(c, d) <= max(a, b)\n\n    def distance(a, b, c, d):\n        return (a - c)**2 + (b - d)**2\n\n    def slope(a, b, c, d):\n        return (d - b) / (c - a)\n\n    def point_line_distance(x, y, a, b, c, d):\n        if intersect(a, b, c, d):\n            if a == c:\n                return abs(y - a)\n            return abs(slope(a, b, c, d) * (x - a) + y - b) / sqrt(1 + slope(a, b, c, d)**2)\n        return min(distance(a, b, x, y), distance(c, d, x, y))\n\n    max_fruits = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            x1, y1 = fruits[i]\n            x2, y2 = fruits[j]\n            line_distance = point_line_distance(x1, y1, x2, y2, 0, 1)\n            if line_distance < 1:\n                max_fruits += 1\n\n    return str(max_fruits)\n"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n        denominator = ((x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4))\n        if denominator == 0:\n            return False\n        ua = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator\n        ub = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator\n        return 0 <= ua <= 1 and 0 <= ub <= 1\n\n    n = int(stdin.splitlines()[0])\n    fruits = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n\n    max_count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            x1, y1 = fruits[i]\n            x2, y2 = fruits[j]\n            for k in range(n):\n                if k != i and k != j:\n                    x3, y3 = fruits[k]\n                    dx = x2 - x1\n                    dy = y2 - y1\n                    d = distance(x1, y1, x2, y2)\n                    if d == 0:\n                        continue\n                    a = dy / dx\n                    b = y1 - a * x1\n                    y3_1 = a * x3 + b\n                    y3_2 = -a * x3 + b\n                    if intersect(x1, y1, x2, y2, x3, y3_1, x3, y3_2):\n                        max_count = max(max_count, 2)\n    return str(max_count)\n"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    fruits = []\n    for i in range(1, n+1):\n        x, y = list(map(float, input_list[i].split()))\n        fruits.append((x, y))\n\n    def is_point_inside(fruit, point):\n        x1, y1 = fruit\n        x2, y2 = point\n        distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n        return distance <= 1\n\n    def is_intersect(line1, line2):\n        x1, y1, x2, y2 = line1\n        x3, y3, x4, y4 = line2\n        denominator = ((x1 - x2) * (y3 - y4)) - ((y1 - y2) * (x3 - x4))\n        if denominator == 0:\n            return False\n        ua = ((x1 * (y3 - y4)) + (y1 * (x4 - x3)) + (x4 * y3) - (x3 * y4)) / denominator\n        if not (0 <= ua <= 1):\n            return False\n        ub = ((x1 * (y3 - y4)) + (y1 * (x4 - x3)) + (x3 * y4) - (x4 * y3)) / denominator\n        if not (0 <= ub <= 1):\n            return False\n        return True\n\n    def count_slices(fruit_list):\n        count = 0\n        for i in range(len(fruit_list)):\n            for j in range(i + 1, len(fruit_list)):\n                line1 = (fruit_list[i][0], fruit_list[i][1], fruit_list[j][0], fruit_list[j][1])\n                for k in range(len(fruit_list)):\n                    if k != i and k != j:\n                        line2 = (fruit_list[k][0], fruit_list[k][1], fruit_list[k][0], fruit_list[k][1] + 1)\n                        if is_intersect(line1, line2):\n                            count += 1\n                            break\n                if count > 0:\n                    break\n            if count > 0:\n                break\n        return count\n\n    def count_slices_with_point(point):\n        count = 0\n        for i in range(len(fruits)):\n            if is_point_inside(fruits[i], point):\n                count += 1\n        return count\n\n    best_count = 0\n    for fruit in fruits:\n        best_count = max(best_count, count_slices_with_point(fruit))\n    return best_count "
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_intersect(fruit, line):\n        x1, y1, x2, y2 = line\n        r = 1\n        return (x1 - fruit[0]) ** 2 + (y1 - fruit[1]) ** 2 <= r ** 2\n\n    def count_slices(fruits, line):\n        return sum(1 for fruit in fruits if is_intersect(fruit, line))\n\n    n = int(input())\n    fruits = [tuple(map(float, input().split())) for _ in range(n)]\n    line = tuple(map(float, input().split()))\n\n    return max(count_slices(fruits, line), count_slices(fruits, (line[1], line[0], line[3], line[2])))\n"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    del input_list[0]\n    fruits = []\n    for i in range(n):\n        x, y = map(float, input_list[i].split())\n        fruits.append((x, y))\n    \n    max_slice = 0\n    for i in range(n):\n        x1, y1 = fruits[i]\n        for j in range(i+1, n):\n            x2, y2 = fruits[j]\n            m = (y2-y1) / (x2-x1)\n            if m == 0:\n                if abs(x1-x2) <= 1:\n                    max_slice = max(max_slice, 2)\n            else:\n                b = y1 - m * x1\n                x_int = (b / (m-1)) if m-1 != 0 else float('inf')\n                if abs(x1-x_int) <= 1 and abs(x2-x_int) <= 1:\n                    max_slice = max(max_slice, 2)\n    return str(max_slice)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    R, C, K = map(int, input_lines[0].split())\n    grid = [list(input_lines[i]) for i in range(1, R + 1)]\n    scores = list(map(int, input_lines[-1].split()))\n\n    def is_valid(x, y, direction):\n        if direction == \"L\":\n            return x > 0 and grid[y][x] != \"X\"\n        elif direction == \"R\":\n            return x < C - 1 and grid[y][x] != \"X\"\n        else:\n            return False\n\n    def set_conveyor_belt(x, y, direction):\n        if direction == \"L\":\n            grid[y][x] = \"L\"\n        elif direction == \"R\":\n            grid[y][x] = \"R\"\n\n    def get_score(x, y):\n        return scores[x]\n\n    def drop_ball(x, y):\n        while y > 0:\n            y -= 1\n            if grid[y][x] == \"R\":\n                set_conveyor_belt(x, y, \"R\")\n            elif grid[y][x] == \"L\":\n                set_conveyor_belt(x, y, \"L\")\n            elif grid[y][x] == \"?\":\n                set_conveyor_belt(x, y, \"L\")\n            elif grid[y][x] == \".\":\n                continue\n            else:\n                return get_score(x, y)\n\n    max_score = 0\n    for x in range(C):\n        max_score = max(max_score, drop_ball(x, R))\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = [list(line.strip()) for line in stdin.strip().split('\\n')[1:-1]]\n    scores = list(map(int, stdin.strip().split('\\n')[-1].split()))\n    \n    def is_valid(x, y):\n        if x < 0 or x >= R+1 or y < 0 or y >= C:\n            return False\n        if grid[x][y] == 'X':\n            return False\n        return True\n    \n    def move_right(x, y):\n        if not is_valid(x+1, y):\n            return False\n        if grid[x][y] == 'R':\n            return False\n        if grid[x][y] == 'L':\n            return True\n        if grid[x][y] == '?':\n            grid[x][y] = 'R'\n            return True\n        return False\n    \n    def move_left(x, y):\n        if not is_valid(x-1, y):\n            return False\n        if grid[x][y] == 'R':\n            return True\n        if grid[x][y] == 'L':\n            return False\n        if grid[x][y] == '?':\n            grid[x][y] = 'L'\n            return True\n        return False\n    \n    max_score = 0\n    for i in range(C):\n        for j in range(R+1):\n            if grid[j][i] == '.':\n                x, y = j, i\n                while is_valid(x, y):\n                    if move_right(x, y):\n                        x += 1\n                    elif move_left(x, y):\n                        x -= 1\n                    if x >= R+1:\n                        break\n                    if x == 0:\n                        x = 1\n                    if x == R:\n                        max_score = max(max_score, scores[y])\n                        break\n    \n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = [line.rstrip() for line in stdin.split('\\n')[1:-1]]\n    scores = list(map(int, stdin.split('\\n')[-1].split()))\n\n    # Set conveyor belts and find the initial position of the ball\n    conveyor_belts = {(row, col): direction for row, line in enumerate(grid) for col, char in enumerate(line) if char in 'RL'}\n    ball_pos = (R, C - 1)\n\n    # Helper function to find the next position of the ball\n    def next_pos(pos, direction):\n        next_pos = pos\n        while True:\n            next_pos = (next_pos[0] - 1, next_pos[1]) if direction == 'R' else (next_pos[0] + 1, next_pos[1])\n            if 0 <= next_pos[0] < R and 0 <= next_pos[1] < C:\n                if grid[next_pos[0]][next_pos[1]] == '.':\n                    return next_pos\n                elif grid[next_pos[0]][next_pos[1]] == 'X':\n                    return None\n                elif grid[next_pos[0]][next_pos[1]] in 'RL':\n                    return next_pos\n            else:\n                return None\n\n    # Helper function to calculate the score at a position\n    def score_at_pos(pos):\n        return scores[pos[1]] if pos[0] == R - 1 else 0\n\n    # Iterate through all possible positions of the ball\n    max_score = 0\n    for direction in 'RL':\n        if (0, C - 1) in conveyor_belts and conveyor_belts[(0, C - 1)] != direction:\n            continue  # Skip invalid initial positions\n        ball_pos = (0, C - 1)\n        current_score = 0\n        next_positions = [(ball_pos, direction)]\n        while next_positions:\n            pos, direction = next_positions.pop(0)\n            next_pos = next_pos_func(pos, direction)\n            if next_pos is not None and (0 <= next_pos[0] < R and 0 <= next_pos[1] < C):\n                current_score += score_at_pos(pos)\n                if grid[next_pos[0]][next_pos[1]] == 'X':\n                    current_score = 0  # The ball falls through the obstacle, so the score resets\n                elif grid[next_pos[0]][next_pos[1]] in 'RL':\n                    current_score += score_at_pos(next_pos)\n                    next_positions.append((next_pos, direction))\n                elif grid[next_pos[0]][next_pos[1]] == '.':\n                    if max_score < current_score:\n                        max_score = current_score\n            else:\n                break  # The ball falls through the grid or an obstacle, so the exam ends\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, input().split())\n    grid = []\n    for i in range(R):\n        grid.append(input())\n    scores = list(map(int, input().split()))\n\n    # Calculate the maximum final score\n    pass"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, input().split())\n    grid = []\n    for _ in range(R + 1):\n        grid.append(list(input()))\n    score_matrix = []\n    for _ in range(C):\n        score_matrix.append(list(map(int, input().split())))\n\n    # Implement the solution here\n    max_score = 0\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = [list(stdin.split()[3 + C * i:3 + C * (i + 1)]) for i in range(R)]\n    scores = list(map(int, stdin.split()[3 + R * C:]))\n\n    def is_valid(r, c, direction):\n        if 0 <= r < R and 0 <= c < C:\n            if grid[r][c] == '.' or grid[r][c] == 'X':\n                return True\n            elif grid[r][c] == 'R' and direction == 'R':\n                return True\n            elif grid[r][c] == 'L' and direction == 'L':\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def is_out_of_bounds(r, c):\n        return not (0 <= r < R and 0 <= c < C)\n\n    def get_max_score(ball_r, ball_c, belt_r, belt_c, direction):\n        max_score = 0\n        if direction == 'R':\n            belt_c += 1\n        else:\n            belt_c -= 1\n        for r in range(ball_r + 1, R):\n            if is_valid(r, ball_c, direction):\n                max_score += scores[ball_c]\n                ball_r, ball_c = r, ball_c\n            elif not is_out_of_bounds(r, ball_c):\n                if grid[r][ball_c] == 'X':\n                    return 0\n                elif grid[r][ball_c] == 'R' and direction == 'R':\n                    max_score += scores[ball_c]\n                    ball_r, ball_c = r, ball_c\n                elif grid[r][ball_c] == 'L' and direction == 'L':\n                    max_score += scores[ball_c]\n                    ball_r, ball_c = r, ball_c\n                elif grid[r][ball_c] == '?':\n                    max_score += scores[ball_c]\n                    ball_r, ball_c = r, ball_c\n                else:\n                    return 0\n            else:\n                return 0\n        if ball_c != belt_c:\n            max_score += scores[ball_c]\n        return max_score\n\n    max_score = 0\n    for r in range(R):\n        for c in range(C):\n            if grid[r][c] == '?':\n                for direction in ['R', 'L']:\n                    max_score = max(max_score, get_max_score(r, c, r, c, direction))\n                return str(max_score)\n    return \"0\"  # no more belts to set\n\ninput1 = \"2 5 2\\nR..?.\\n.X...\\n100 100 7 100 8\"\ninput2 = \"2 3 1\\nX..\\n.?.\\n10 1000 1\"\ninput3 = \"1 1 1\\n?\"\ninput4 = \"2 2 2\\nRX\\nXR\\n10 10\"\n\nprint(solution(input1))  # Output: 16\nprint(solution(input2))  # Output: 10\nprint(solution(input3))  # Output: 0\nprint(solution(input4))  # Output: 0 "
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = [line.strip() for line in stdin.split('\\n')[1:-1]]\n    scores = list(map(int, stdin.split('\\n')[-1].split()))\n\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C\n\n    def move_ball(x, y, direction):\n        new_x = x + 1\n        new_y = y + direction\n        if is_valid(new_x, new_y) and grid[new_x][new_y] != 'X':\n            grid[x][y] = '.'\n            grid[new_x][new_y] = '.'\n            move_ball(new_x, new_y, direction)\n        else:\n            return\n\n    def set_conveyor_belts(x, y, direction, belts_left):\n        if grid[x][y] != '?':\n            return\n        grid[x][y] = direction\n        if direction == 'R':\n            move_ball(x, y, 1)\n        elif direction == 'L':\n            move_ball(x, y, -1)\n        belts_left -= 1\n        if belts_left > 0:\n            for i in range(x + 1, R):\n                if grid[i][y] == '?':\n                    set_conveyor_belts(i, y, direction, belts_left)\n                    break\n\n    def max_score():\n        max_score = 0\n        for i in range(R):\n            for j in range(C):\n                if grid[i][j] == '.':\n                    move_ball(i, j, 1)\n                elif grid[i][j] == 'R':\n                    move_ball(i, j, 1)\n                elif grid[i][j] == 'L':\n                    move_ball(i, j, -1)\n                max_score = max(max_score, scores[j])\n        return max_score\n\n    belts_left = 0\n    for row in grid:\n        belts_left += row.count('R') + row.count('L')\n    set_conveyor_belets(0, 0, 'R', belts_left)\n    max_score()\n\n\ndef"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1:R+1]\n    scores = list(map(int, stdin.split('\\n')[-1].split()))\n    \n    conveyor_belts = []\n    for i, row in enumerate(grid):\n        for j, cell in enumerate(row):\n            if cell == '?':\n                conveyor_belts.append((i, j, '?'))\n            elif cell == 'R':\n                conveyor_belts.append((i, j, 'R'))\n            elif cell == 'L':\n                conveyor_belts.append((i, j, 'L'))\n    \n    def set_conveyor_belts(conveyor_belts, direction, i, j, grid):\n        for belt in conveyor_belts:\n            belt_i, belt_j, belt_direction = belt\n            if belt_direction == '?' and belt_i == i:\n                if belt_j < j:\n                    belt_direction = 'R'\n                else:\n                    belt_direction = 'L'\n                belt = belt_i, belt_j, belt_direction\n                grid[belt_i][belt_j] = belt_direction\n                conveyor_belts.remove(belt)\n        return grid\n    \n    def find_max_score(scores, i, j, grid):\n        max_score = 0\n        for belt_direction in ['R', 'L']:\n            if grid[i][j] == '?' and belt_direction in ['R', 'L']:\n                grid[i][j] = belt_direction\n                score = scores[j]\n                grid[i][j] = '?'\n                max_score = max(max_score, score)\n        return max_score\n    \n    max_score = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == '.':\n                grid = set_conveyor_belts(conveyor_belts, '?', i, j, grid)\n                max_score = max(max_score, find_max_score(scores, i, j, grid))\n                grid = set_conveyor_belts(conveyor_belts, '?', i, j, grid)\n    \n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[:R]\n    last_row = grid[-1]\n    last_row_scores = list(map(int, stdin.split()[R * C:]))\n\n    def is_valid(row, col, direction):\n        if direction == 'R':\n            return col + 1 < C and last_row[col + 1] not in ('X', 'L')\n        else:\n            return col - 1 >= 0 and last_row[col - 1] not in ('X', 'R')\n\n    def score(row, col, direction):\n        if direction == 'R':\n            return last_row_scores[col + 1] if col + 1 < C else 0\n        else:\n            return last_row_scores[col - 1] if col - 1 >= 0 else 0\n\n    max_score = 0\n\n    for i in range(R):\n        for j in range(C):\n            if last_row[j] == 'R':\n                max_score = max(max_score, score(i, j, 'R'))\n            elif last_row[j] == 'L':\n                max_score = max(max_score, score(i, j, 'L'))\n\n    return str(max_score)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    input_grid = stdin.split()[3:]\n    \n    grid = [[None for _ in range(C)] for _ in range(R+1)]\n    conveyor_belts = []\n    \n    for i in range(R+1):\n        for j in range(C):\n            if input_grid[i*C+j] == 'R':\n                grid[i][j] = 'R'\n            elif input_grid[i*C+j] == 'L':\n                grid[i][j] = 'L'\n            elif input_grid[i*C+j] == '?':\n                conveyor_belts.append((i,j))\n            elif input_grid[i*C+j] == '.':\n                grid[i][j] = '.'\n            elif input_grid[i*C+j] == 'X':\n                grid[i][j] = 'X'\n    \n    scores = [int(x) for x in input_grid[R*C:]]\n    \n    def is_valid(x: int, y: int, direction: str) -> bool:\n        if grid[x][y] == 'X':\n            return False\n        if direction == 'R' and y == C-1:\n            return False\n        if direction == 'L' and y == 0:\n            return False\n        return True\n    \n    def count_score(x: int, y: int) -> int:\n        if x == R:\n            return scores[y]\n        return 0\n    \n    def move_ball(x: int, y: int, direction: str) -> int:\n        if direction == 'R':\n            return x+1, y\n        elif direction == 'L':\n            return x-1, y\n        return x, y\n    \n    def find_max_score() -> int:\n        max_score = 0\n        for x in range(R+1):\n            for y in range(C):\n                if grid[x][y] == '.':\n                    for direction in ['R', 'L']:\n                        if is_valid(x, y, direction):\n                            nx, ny = move_ball(x, y, direction)\n                            if is_valid(nx, ny, direction):\n                                score = count_score(nx, ny)\n                                max_score = max(max_score, score)\n        return max_score\n    \n    def set_conveyor_belts() -> int:\n        max_score = 0\n        for x, y in conveyor_belts:\n            if is_valid(x, y, 'R'):\n                grid[x][y] = 'R'\n                max_score = max(max_score, find_max_score())\n                grid[x][y] = '.'\n            if is_valid(x, y, 'L'):\n                grid[x][y] = 'L'\n                max_score = max(max_score, find_max_score())\n                grid[x][y] = '.'\n        return max_score\n    \n    return str(set_conveyor_belts())"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_happy(cities, k):\n        total_residents = sum(cities[city][2] for city in cities)\n        for i in range(1, len(cities)):\n            if total_residents % k == 0:\n                return True\n            total_residents -= cities[i][2]\n        return False\n\n    N, K = map(int, stdin.splitlines()[0].split())\n    cities = {}\n    for i in range(N):\n        x, y, k = map(int, stdin.splitlines()[i+1].split())\n        cities[(x, y)] = (x, y, k)\n\n    # Compute the minimal distance D for which it is possible to build roads with the condition that the prime minister is happy\n    D = 1\n    while True:\n        # Check if there exists a county with a subset of cities with sum(residents) divisible by K\n        for c1 in cities:\n            for c2 in cities:\n                if c1 != c2 and distance(c1, c2) <= D:\n                    if is_happy({c1, c2}, K):\n                        D = (D + 1) * 1.414\n                        break\n            if D > 100000:\n                return \"100000\"\n        else:\n            break\n\n    return f\"{D:.3f}\""
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from math import sqrt\n\n    def distance(p1, p2):\n        x1, y1, k1 = p1\n        x2, y2, k2 = p2\n        return sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    def is_divisible(subset):\n        return all(k % K == 0 for _, _, k in subset)\n\n    def count_residents(subset):\n        return sum(k for _, _, k in subset)\n\n    N, K = map(int, stdin.split()[:2])\n    cities = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    min_distance = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            d = distance(cities[i], cities[j])\n            if d <= D:\n                subset = [cities[i], cities[j]]\n                for k in range(N):\n                    if k not in (i, j) and distance(cities[k], cities[i]) <= D and distance(cities[k], cities[j]) <= D:\n                        subset.append(cities[k])\n                if is_divisible(subset):\n                    min_distance = min(min_distance, d)\n\n    return f'{min_distance:.3f}'\n"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_valid_partition(partition):\n        return sum(residents % K) == 0\n\n    def min_distance(cities):\n        min_dist = float('inf')\n        for i in range(len(cities)):\n            for j in range(i+1, len(cities)):\n                dist = distance(cities[i], cities[j])\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n\n    N, K = map(int, stdin.split()[:2])\n    cities = [tuple(map(int, stdin.split()[i].split(','))) for i in range(2, 2 + N*3, 3)]\n    cities = [(x, y, k) for x, y, k in cities if k % K == 0]\n\n    valid_partitions = []\n    for partition in itertools.combinations(cities, 2):\n        if is_valid_partition([city[2] for city in partition]):\n            valid_partitions.append(partition)\n\n    if not valid_partitions:\n        return f'{0:.3f}'\n\n    min_dist = min_distance([(city[0], city[1]) for city in cities])\n    while min_dist <= D:\n        D *= 1.1\n        for partition in valid_partitions:\n            if sum(distance((city[0], city[1]), (partition[0][0], partition[0][1])) for city in partition) <= D:\n                if sum(distance((city[0], city[1]), (partition[1][0], partition[1][1])) for city in partition) <= D:\n                    return f'{D:.3f}'\n            if sum(distance((city[0], city[1]), (partition[1][0], partition[1][1])) for city in partition) <= D:\n                if sum(distance((city[0], city[1]), (partition[0][0], partition[0][1])) for city in partition) <= D:\n                    return f'{D:.3f}'\n\n    return f'{0:.3f}'\n"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, K = map(int, input_data.pop(0).split())\n    cities = []\n\n    for i in range(N):\n        x, y, k = map(int, input_data.pop(0).split())\n        cities.append((x, y, k))\n\n    cities.sort(key=lambda x: x[0])\n    max_dist = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = ((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2) ** 0.5\n            max_dist = max(max_dist, dist)\n\n    D = max_dist\n\n    while D > 0:\n        counties = []\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = ((cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2) ** 0.5\n                if dist <= D:\n                    for county in counties:\n                        if cities[i] in county or cities[j] in county:\n                            county.add(cities[i])\n                            county.add(cities[j])\n                            break\n                    else:\n                        new_county = {cities[i], cities[j]}\n                        counties.append(new_county)\n\n        for county in counties:\n            residents = sum(city[2] for city in county)\n            if residents % K == 0:\n                return f\"{D:.3f}\"\n\n        D -= 0.001\n\n    return \"0\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_divisible(subset_sum, k):\n        return subset_sum % k == 0\n\n    N, K = map(int, stdin.split()[:2])\n    cities = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    distances = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            distances.append(calculate_distance(*cities[i], *cities[j]))\n\n    distances.sort(reverse=True)\n\n    counties = []\n    current_county = []\n    total_residents = 0\n    for i in range(N):\n        city, _, residents = cities[i]\n        if not current_county or calculate_distance(current_county[-1][0], current_county[-1][1], city, cities[i][1]) <= distances[0]:\n            current_county.append(cities[i])\n            total_residents += residents\n        else:\n            counties.append(current_county)\n            current_county = [cities[i]]\n            total_residents = residents\n\n    counties.append(current_county)\n\n    min_distance = float('inf')\n    for county in counties:\n        subset_sum = sum(residents for _, _, residents in county)\n        if is_divisible(subset_sum, K):\n            distance = sum(distances[i] for i in range(len(distances)) if all(calculate_distance(*cities[j], *cities[i]) <= distances[i] for j in range(N) if j != i))\n            min_distance = min(min_distance, distance)\n\n    return f'{min_distance:.3f}'"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    cities = []\n    for _ in range(N):\n        x, y, k = map(int, input().split())\n        cities.append((x, y, k))\n\n    roads = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = (cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2\n            roads.append((dist, (i, j)))\n\n    roads.sort()\n\n    def is_happy(county, D):\n        total_residents = sum(cities[city][2] for city in county)\n        return total_residents % K == 0\n\n    def min_D(counties):\n        min_D = float('inf')\n        for county in counties:\n            for road in roads:\n                if road[1][0] not in county and road[1][1] not in county:\n                    continue\n                for new_road in roads:\n                    if new_road[1][0] in county and new_road[1][1] not in county:\n                        if road[0] + new_road[0] <= D ** 2:\n                            new_county = set(county)\n                            new_county.add(new_road[1][1])\n                            if is_happy(new_county, D):\n                                return D\n                    elif new_road[1][1] in county and new_road[1][0] not in county:\n                        if road[0] + new_road[0] <= D ** 2:\n                            new_county = set(county)\n                            new_county.add(new_road[1][0])\n                            if is_happy(new_county, D):\n                                return D\n        return -1\n\n    counties = [set() for _ in range(N)]\n    for i in range(N):\n        counties[cities[i][2] - 1].add(i)\n\n    D = 1\n    while True:\n        new_D = D + 1\n        new_counties = [set(county) for county in counties]\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = (cities[i][0] - cities[j][0]) ** 2 + (cities[i][1] - cities[j][1]) ** 2\n                if dist <= D ** 2:\n                    for k in range(K):\n                        if k not in counties[cities[i][2] - 1] and k not in counties[cities[j][2] - 1]:\n                            new_counties[k].add(i)\n                            new_counties[k].add(j)\n                            if is_happy(new_counties[k], D):\n                                return round(D, 3)\n        if min_D(new_counties) != -1:\n            return round(min_D(new_counties), 3)\n        D = new_D\n\n\ninput_data = '''\n3 3\n0 4 4\n1 5 1\n2 6 1\n'''\n\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    cities = []\n    for _ in range(N):\n        x, y, k = map(int, input().split())\n        cities.append((x, y, k))\n\n    min_distance = float('inf')\n    found = False\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            dist = distance(cities[i][:2], cities[j][:2])\n            if dist <= min_distance:\n                min_distance = dist\n                found = True\n\n    if found:\n        min_distance *= 1000\n        for i in range(N):\n            total = sum(cities[j][2] for j in range(N) if cities[j][:2] == cities[i][:2])\n            if total % K == 0:\n                min_distance = min(min_distance, total / K)\n\n    return f\"{min_distance:.3f}\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    cities = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    \n    def distance(city1, city2):\n        return ((city1[0] - city2[0]) ** 2 + (city1[1] - city2[1]) ** 2) ** 0.5\n    \n    def can_connect(city1, city2):\n        return distance(city1, city2) <= D\n    \n    def sum_of_residents(cities):\n        return sum(city[2] for city in cities)\n    \n    def count_of_subsets_divisible_by_K(cities):\n        return sum(sum_of_residents(cities[:i+1]) % K == 0 for i in range(len(cities)))\n    \n    def min_D(cities):\n        D = 0\n        while count_of_subsets_divisible_by_K(cities) == 0:\n            D += 1\n            if D > 100000:\n                return \"Impossible\"\n        return D\n    \n    return f\"{min_D(cities):.3f}\"\n\ndef"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, K = map(int, input_data[0].split())\n    cities = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def min_distance(p1, p2):\n        d = distance(p1, p2)\n        return min(d, 2 * K / d)\n\n    def max_distance(p1, p2):\n        d = distance(p1, p2)\n        return min(d, 2 * K / d)\n\n    def is_happy(cities, K):\n        subsets = []\n        for i in range(1, len(cities) + 1):\n            subsets += list(itertools.combinations(cities, i))\n        return any(sum(c[2] for c in s) % K == 0 for s in subsets)\n\n    cities.sort(key=lambda c: c[2])\n    p1, p2 = cities[0][:2], cities[1][:2]\n    D = min_distance(p1, p2)\n\n    while not is_happy(cities, K):\n        p1, p2 = p2, (p2[0] + D, p2[1] + D)\n        D = min_distance(p1, p2)\n\n    return f\"{D:.3f}\"\n"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    cities = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    min_D = float('inf')\n\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                x1, y1, k1 = cities[i]\n                x2, y2, k2 = cities[j]\n                D = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n                if D <= min_D:\n                    min_D = D\n\n    min_D = min_D / 1000\n    min_D = round(min_D, 3)\n\n    return f\"{min_D}\"\n\n\ninput1 = \"3 3\\n0 4 4\\n1 5 1\\n2 6 1\"\noutput1 = \"1.414\"\n\ninput2 = \"6 11\\n0 0 1\\n0 1 2\\n1 0 3\\n1 1 4\\n5 5 1\\n20 20 10\"\noutput2 = \"5.657\"\n\nprint(solution(input1))  # Output: 1.414\nprint(solution(input2))  # Output: 5.657 "
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def area(points):\n        return 0.5 * abs(points[0][0] * points[1][1] - points[1][0] * points[0][1])\n\n    n, *fence_lengths = map(int, stdin.split())\n    fence_lengths = sorted(fence_lengths, reverse=True)\n\n    max_area = 0\n    for i in range(n):\n        for j in range(i + 2, n):\n            for k in range(j + 2, n):\n                fence_lengths[i] -= 1\n                fence_lengths[j] -= 1\n                fence_lengths[k] -= 1\n                if fence_lengths[i] <= 0 or fence_lengths[j] <= 0 or fence_lengths[k] <= 0:\n                    continue\n                points = [(0, 0), (fence_lengths[i], 0), (fence_lengths[j], fence_lengths[j]), (fence_lengths[k], 0)]\n                current_area = area(points)\n                if current_area > max_area:\n                    max_area = current_area\n                fence_lengths[i] += 1\n                fence_lengths[j] += 1\n                fence_lengths[k] += 1\n\n    return max_area if max_area > 0 else 0\n"
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    input_list = input_str.split()\n    n = int(input_list[0])\n    fence_lengths = [int(x) for x in input_list[1:]]\n\n    def is_valid(fence_lengths, total_length):\n        fence_lengths.sort(reverse=True)\n        length = 0\n        for fence in fence_lengths:\n            if length + fence > total_length:\n                return False\n            length += fence\n        return True\n\n    def get_area(fence_lengths):\n        fence_lengths.sort()\n        area = 0\n        length = 0\n        for fence in fence_lengths:\n            area += length * fence\n            length += fence\n        return area\n\n    total_length = sum(fence_lengths)\n    if total_length % n != 0:\n        return 0\n\n    total_length //= n\n    if not is_valid(fence_lengths, total_length):\n        return 0\n\n    return str(get_area(fence_lengths))"
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    n = int(input_data[0])\n    fence_lengths = sorted(list(map(int, input_data[1:])))\n\n    def is_valid(segment_indices):\n        area = 0\n        prev_i = -1\n        for i in segment_indices:\n            if prev_i == -1:\n                area += fence_lengths[i] * fence_lengths[i + 1]\n            else:\n                area += fence_lengths[i] * fence_lengths[prev_i]\n            prev_i = i\n        return area\n\n    def max_area(segment_indices):\n        max_area = 0\n        for i in range(len(segment_indices) - 1):\n            max_area = max(max_area, is_valid(segment_indices[i:i + 2]))\n        return max_area\n\n    max_area_sum = 0\n    for i in range(n):\n        max_area_sum = max(max_area_sum, max_area([i]))\n\n    return str(max_area_sum) if max_area_sum != 0 else \"0\""
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    fence_lengths = list(map(int, input_list[1:]))\n    max_area = 0\n    for i in range(1, 1 << n):\n        segments = [fence_lengths[j] for j in range(n) if (i & (1 << j))]\n        if len(set(segments)) == len(segments):\n            segments.sort(reverse=True)\n            area = 0\n            for i in range(len(segments)):\n                area += segments[i] * segments[i]\n                if i < len(segments) - 1 and segments[i] == segments[i + 1]:\n                    continue\n                area -= segments[i] * segments[i]\n            if area > max_area:\n                max_area = area\n    if max_area > 0:\n        return f\"{max_area:.3f}\"\n    else:\n        return \"0.0\"\n"
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    fence_lengths = list(map(int, input_list[1:]))\n\n    def get_area(fence_lengths):\n        if len(fence_lengths) <= 1:\n            return 0\n        fence_lengths = sorted(fence_lengths)\n        area = 0\n        for i in range(len(fence_lengths) - 1):\n            area += fence_lengths[i] * fence_lengths[i + 1]\n        return area\n\n    fence_lengths.sort()\n    area = get_area(fence_lengths)\n    return str(area)\n"
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    fence_lengths = list(map(int, input_list[1:]))\n\n    def area_of_polygon(lengths):\n        fence_counts = [0] * 100\n        for length in lengths:\n            fence_counts[length - 1] += 1\n\n        total_area = 0\n        for i in range(1, 100):\n            total_area += i * fence_counts[i]\n\n        return total_area\n\n    fence_lengths.sort(reverse=True)\n    max_area = area_of_polygon(fence_lengths)\n\n    return f\"{max_area:.3f}\"\n\ninput_1 = \"4 1 1 1 1\"\noutput_1 = solution(input_1)\nprint(output_1)  # Expected output: 1.0\n\ninput_2 = \"3 1 1 1\"\noutput_2 = solution(input_2)\nprint(output_2)  # Expected output: 0.433 "
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    fence_lengths = [int(length) for length in input_list[1:]]\n    \n    # Helper function to check if a fence segment can be used in a polygon\n    def is_valid(length, used_lengths):\n        for used_length in used_lengths:\n            if used_length == length:\n                return False\n            if used_length > length:\n                return True\n        return True\n    \n    # Helper function to find the maximum area of a polygon\n    def max_area(fence_lengths):\n        fence_lengths.sort(reverse=True)\n        max_area = 0\n        for i in range(n):\n            used_lengths = [fence_lengths[j] for j in range(i)]\n            for length in fence_lengths:\n                if is_valid(length, used_lengths):\n                    area = length * (sum(used_lengths) + length) / 2\n                    max_area = max(max_area, area)\n        return max_area\n    \n    # Compute the maximum area\n    max_area = max_area(fence_lengths)\n    \n    # Check if there is a polygon that can be built with all the fence segments\n    is_valid_polygon = True\n    for i in range(n):\n        used_lengths = [fence_lengths[j] for j in range(i)]\n        for length in fence_lengths:\n            if not is_valid(length, used_lengths):\n                is_valid_polygon = False\n                break\n        if not is_valid_polygon:\n            break\n    \n    # Output the result\n    if is_valid_polygon:\n        return f\"{max_area:.3f}\"\n    else:\n        return \"0\""
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_polygon(points: list) -> bool:\n        # checks if the polygon is valid\n        # sum of the angles of a polygon is 180 degrees\n        # if the polygon has n sides, then the sum of (n-2) angles is 180 degrees\n        # so we need to check if the sum of the angles is equal to 180 for all possible combinations of sides\n        n = len(points)\n        angles = []\n        for i in range(n):\n            a, b = points[i], points[(i + 1) % n]\n            angles.append(math.degrees(math.atan2(b[1] - a[1], b[0] - a[0])))\n        return all(abs(sum(angles) - 180) < 0.005 for angles in itertools.permutations(angles))\n\n    def area(points: list) -> float:\n        # calculates the area of the polygon formed by the given points\n        # uses the shoelace formula\n        n = len(points)\n        return 0.5 * abs(sum(points[i][0] * points[(i + 1) % n][1] - points[(i + 1) % n][0] * points[i][1] for i in range(n)))\n\n    # read input\n    n, *segments = stdin.split()\n    n = int(n)\n    segments = list(map(int, segments))\n\n    # create all possible combinations of segments\n    combinations = itertools.combinations(segments, n)\n\n    # find the optimal solution\n    max_area = 0\n    for combination in combinations:\n        points = sorted(zip(combination, itertools.cycle([0])), key=lambda x: x[0])\n        if is_valid_polygon(points):\n            max_area = max(max_area, area(points))\n\n    return \"{:.3f}\".format(max_area) if max_area > 0 else \"0\""
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    fence_lengths = sorted([int(x) for x in input_list[1:]], reverse=True)\n    max_area = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            fence_1 = fence_lengths[i]\n            fence_2 = fence_lengths[j]\n            area = 0.5 * fence_1 * fence_2\n            if area > max_area:\n                max_area = area\n\n    return round(max_area, 3)\n"
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split()\n    n = int(input_values[0])\n    fence_segments = sorted(map(int, input_values[1:]), reverse=True)\n    \n    def is_valid_area(area: float) -> bool:\n        for segment in fence_segments:\n            if area > segment:\n                return False\n        return True\n    \n    def get_polygon_area(sides: List[int]) -> float:\n        return 0.5 * sum(sides[i] * sides[i+1] for i in range(len(sides)-1))\n    \n    def get_max_area(fence_segments: List[int]) -> float:\n        max_area = 0.0\n        n = len(fence_segments)\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    area = fence_segments[i] * fence_segments[j] * fence_segments[k]\n                    if is_valid_area(area):\n                        max_area = max(max_area, area)\n        return max_area\n    \n    sides = [2 * fence_segments[0], fence_segments[0] + fence_segments[1]]\n    max_area = get_max_area(fence_segments)\n    \n    if max_area == 0.0:\n        return \"0.0\"\n    else:\n        return f\"{max_area:.3f}\"\n"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_next_plant(x, y, plants):\n        for i, plant in enumerate(plants):\n            if plant[0] == x and plant[1] > y:\n                return i, plant[2]\n            if plant[1] == y and plant[0] > x:\n                return i, plant[2]\n        return None, None\n\n    def calculate_energy(energy, flies, jump_cost):\n        return energy + flies * jump_cost\n\n    def get_energy(x, y, plants, jump_cost):\n        energy = 0\n        while True:\n            next_plant_i, next_plant_flies = get_next_plant(x, y, plants)\n            if next_plant_i is None:\n                break\n            x, y = next_plant_i + 1, y + 1\n            energy = calculate_energy(energy, next_plant_flies, jump_cost)\n        return energy\n\n    N, K = map(int, input().split())\n    plants = []\n    for i in range(N):\n        x, y, flies = map(int, input().split())\n        plants.append((x, y, flies))\n\n    start_energy = get_energy(1, 1, plants, K)\n    sequence = [1]\n    for i in range(2, N + 1):\n        energy = get_energy(i - 1, 1, plants, K)\n        if energy > start_energy:\n            start_energy = energy\n            sequence = [i]\n        elif energy == start_energy:\n            sequence.append(i)\n\n    return str(start_energy) + \"\\n\" + str(len(sequence)) + \"\\n\" + \"\\n\".join(map(str, sequence))\n\n\ninput_data = \"\"\"6 5\n1 1 5\n2 1 5\n1 2 4\n2 3 5\n3 2 30\n3 3 5\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_jump(x1, y1, x2, y2) -> bool:\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    def get_neighbor_plants(x, y) -> List[Tuple[int, int, int]]:\n        neighbors = []\n        for i in range(max(0, x - 1), min(x + 2, X + 1)):\n            for j in range(max(0, y - 1), min(y + 2, Y + 1)):\n                if (i, j) != (x, y) and (i, j) in plant_positions:\n                    neighbors.append(plant_positions[(i, j)])\n        return neighbors\n\n    N, K = map(int, stdin.split()[0:2])\n    X, Y, F = map(int, stdin.split()[2:5])\n    plant_positions = {}\n    total_energy = 0\n    for i in range(N):\n        x, y, f = map(int, stdin.split()[5 + i * 3:8 + i * 3])\n        plant_positions[(x, y)] = (x, y, f)\n        if is_valid_jump(0, 0, x, y):\n            total_energy += f\n\n    current_pos = (0, 0)\n    current_energy = 0\n    visited_plants = set()\n    queue = [(0, current_pos)]\n\n    while queue:\n        energy_cost, current_pos = heapq.heappop(queue)\n        x, y = current_pos\n\n        if current_pos not in visited_plants:\n            visited_plants.add(current_pos)\n            if len(visited_plants) == N:\n                break\n\n            current_energy += f\n            if current_energy >= K:\n                neighbors = get_neighbor_plants(x, y)\n                for n in neighbors:\n                    next_energy = n[2] + energy_cost\n                    heapq.heappush(queue, (next_energy, (n[0], n[1])))\n\n    if len(visited_plants) == N:\n        sequence = [f\"{p[0]} {p[1]}\" for p in sorted(visited_plants, key=lambda p: (p[1], p[0]))]\n        return f\"{total_energy}\\n{len(sequence)}\\n\" + \"\\n\".join(sequence)\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split())\n    flies = []\n    for _ in range(N):\n        line = stdin.split('\\n')[int(_)]\n        x, y, f = map(int, line.split())\n        flies.append((x, y, f))\n\n    # sort flies by value, then by x, then by y\n    flies.sort(key=lambda x: (-x[2], x[0], x[1]))\n\n    # build graph with nodes as coordinates and edges as allowed jumps\n    graph = {}\n    for i in range(1, N + 1):\n        x1, y1 = flies[i - 1][:2]\n        graph[flies[i - 1]] = set()\n        for j in range(i - 1, -1, -1):\n            x2, y2 = flies[j][:2]\n            if (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1):\n                graph[flies[i - 1]].add(flies[j])\n\n    # Dijkstra's algorithm to find shortest path\n    dist = [float('inf')] * len(flies)\n    dist[0] = 0\n    prev = [None] * len(flies)\n    Q = list(range(len(flies)))\n    while Q:\n        u = min(Q, key=lambda x: dist[x])\n        if dist[u] == float('inf'):\n            break\n        Q.remove(u)\n        for v in graph[flies[u]]:\n            alt = dist[u] + flies[u][2] + flies[v[0]][2]\n            if alt < dist[v[0]]:\n                dist[v[0]] = alt\n                prev[v[0]] = u\n\n    # Backtrack path from last node to first node\n    path = []\n    u = len(flies) - 1\n    while prev[u] is not None:\n        path.append(flies[u])\n        u = prev[u]\n    path.append(flies[0])\n    path = path[::-1]\n\n    # Calculate energy and output\n    energy = dist[len(flies) - 1]\n    output = str(energy) + '\\n' + str(len(path)) + '\\n'\n    for p in path:\n        output += str(p[0]) + ' ' + str(p[1]) + '\\n'\n    return output"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    plants = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    flies = [p[2] for p in plants]\n    max_flies = max(flies)\n    \n    def can_jump(from_plant, to_plant):\n        if from_plant[0] < to_plant[0] and from_plant[1] == to_plant[1]:\n            return True\n        if from_plant[1] < to_plant[1] and from_plant[0] == to_plant[0]:\n            return True\n        return False\n    \n    def get_energy(from_plant, to_plant):\n        return from_plant[2] + to_plant[2]\n    \n    def jump_to_next_plant(plants, current_plant, current_energy, visited):\n        next_energy = current_energy - plants[current_plant][2]\n        if next_energy < 0:\n            return 0, visited\n        \n        next_visited = visited.copy()\n        next_visited[current_plant] = True\n        \n        max_energy = 0\n        max_plant = 0\n        for i, next_plant in enumerate(plants):\n            if next_visited[i] or not can_jump(plants[current_plant], next_plant):\n                continue\n            energy = get_energy(plants[current_plant], next_plant)\n            next_energy = next_energy - energy\n            if next_energy < 0:\n                continue\n            if energy + jump_to_next_plant(plants, i, next_energy, next_visited)[1] > max_energy:\n                max_energy = energy + jump_to_next_plant(plants, i, next_energy, next_visited)[1]\n                max_plant = i\n        return max_energy, max_plant\n    \n    final_energy, next_plant = jump_to_next_plant(plants, 0, max_flies, [False] * N)\n    print(final_energy)\n    \n    visited = [False] * N\n    visited[0] = True\n    for i in range(N-1):\n        max_energy = 0\n        max_plant = 0\n        for j, plant in enumerate(plants):\n            if visited[j] or not can_jump(plants[i], plant):\n                continue\n            energy = get_energy(plants[i], plant)\n            if energy + jump_to_next_plant(plants, j, energy, visited)[1] > max_energy:\n                max_energy = energy + jump_to_next_plant(plants, j, energy, visited)[1]\n                max_plant = j\n        visited[max_plant] = True\n        print(max_plant + 1)\n    \n    return \"\"\n\ninput_data = \"6 5\\n1 1 5\\n2 1 5\\n1 2 4\\n2 3 5\\n3 2 30\\n3 3 5\\n\"\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_jump(x1, y1, x2, y2):\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    N, K = map(int, stdin.split()[0:2])\n    plants = [tuple(map(int, input().split())) for _ in range(N)]\n    max_energy = 0\n    min_energy = 0\n    energy = 0\n    visited = [False] * N\n    current_plant = 0\n    current_position = (0, 0)\n    sequence = []\n\n    while not visited[N - 1]:\n        for plant in range(N):\n            if visited[plant]:\n                continue\n\n            x1, y1, flies = plants[plant]\n            distance = abs(x1 - current_position[0]) + abs(y1 - current_position[1])\n            if energy >= distance * flies:\n                if is_valid_jump(current_position[0], current_position[1], x1, y1):\n                    energy -= distance * flies\n                    current_plant = plant\n                    current_position = (x1, y1)\n                    sequence.append(current_plant + 1)\n                    visited[current_plant] = True\n\n    max_energy = energy\n    energy = 0\n    visited = [False] * N\n    current_plant = 0\n    current_position = (0, 0)\n    sequence = []\n\n    while not visited[0]:\n        for plant in range(N):\n            if visited[plant]:\n                continue\n\n            x1, y1, flies = plants[plant]\n            distance = abs(x1 - current_position[0]) + abs(y1 - current_position[1])\n            if energy >= distance * flies:\n                if is_valid_jump(current_position[0], current_position[1], x1, y1):\n                    energy -= distance * flies\n                    current_plant = plant\n                    current_position = (x1, y1)\n                    sequence.append(current_plant + 1)\n                    visited[current_plant] = True\n\n    min_energy = energy\n\n    return f\"{min_energy}\\n{len(sequence)}\\n\" + \"\\n\".join(map(str, sequence)) + \"\\n\"\n\n\ndef"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    frog = [(0, 0, 0)] + [(int(x), int(y), int(f)) for x, y, f in [line.split() for line in stdin.split('\\n')[1:]]]\n    visited = set()\n    energy = 0\n    path = []\n\n    def is_valid(x, y):\n        return 0 <= x <= 100000 and 0 <= y <= 100000\n\n    def jump(x, y):\n        nonlocal energy\n        dx, dy = 1, 1\n        while is_valid(x + dx, y + dy) and (dx != 0 or dy != 0) and (dx, dy) != (0, 0):\n            if (x + dx, y + dy) not in visited:\n                visited.add((x + dx, y + dy))\n                f = frog[frog.index((x, y)) + (dx, dy)]\n                energy += f\n                if energy >= K:\n                    energy -= K\n                    path.append((x, y))\n                    return (x + dx, y + dy)\n            dx += 1\n            dy += 1\n        dx, dy = -1, -1\n        while is_valid(x + dx, y + dy) and (dx != 0 or dy != 0) and (dx, dy) != (0, 0):\n            if (x + dx, y + dy) not in visited:\n                visited.add((x + dx, y + dy))\n                f = frog[frog.index((x, y)) + (dx, dy)]\n                energy += f\n                if energy >= K:\n                    energy -= K\n                    path.append((x, y))\n                    return (x + dx, y + dy)\n            dx -= 1\n            dy -= 1\n        return None\n\n    current_pos = (0, 0)\n    visited.add(current_pos)\n    target_pos = (N, 0)\n\n    while current_pos != target_pos:\n        next_pos = jump(*current_pos)\n        if next_pos is None:\n            current_pos = jump(current_pos[0], current_pos[1] - 1)\n            continue\n        current_pos = next_pos\n\n    return str(energy) + '\\n' + str(len(path)) + '\\n' + '\\n'.join(str(p) for p in path)\n\ndef"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    plants = [tuple(map(int, line.split()[:2])) for line in stdin.split('\\n')[1:N+1]]\n    flies = [int(line.split()[2]) for line in stdin.split('\\n')[1:N+1]]\n\n    def is_valid_jump(x1, y1, x2, y2):\n        return (x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)\n\n    def can_reach(x, y):\n        for i in range(N):\n            if plants[i][0] == x and plants[i][1] == y:\n                return True\n        return False\n\n    def dfs(x, y, energy, visited):\n        visited.add((x, y))\n        for i in range(N):\n            if is_valid_jump(x, y, plants[i][0], plants[i][1]) and can_reach(plants[i][0], plants[i][1]) and (x, y) not in visited and energy >= K:\n                energy -= K\n                visited.add((x, y))\n                dfs(plants[i][0], plants[i][1], energy, visited)\n                energy += K\n        return energy\n\n    final_energy = dfs(plants[0][0], plants[0][1], flies[0], set())\n    sequence = []\n    x, y = plants[0]\n    for i in range(N):\n        sequence.append((x, y))\n        for j in range(N):\n            if is_valid_jump(x, y, plants[j][0], plants[j][1]) and can_reach(plants[j][0], plants[j][1]) and sequence[-1] != (plants[j][0], plants[j][1]):\n                x, y = plants[j]\n                sequence.append((x, y))\n                break\n    return f\"{final_energy}\\n{N}\\n\" + \"\\n\".join(str(x) for x in sequence)"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_energy(plant, flies):\n        return flies * plant[2]\n\n    def get_max_energy(energy, plants):\n        max_energy = 0\n        for i in range(1, len(plants)):\n            energy -= plants[i - 1][2]\n            if energy >= 0:\n                max_energy = max(max_energy, get_energy(plants[i], plants[i][2] + get_energy(plants[i - 1], plants[i - 1][2])))\n        return max_energy\n\n    def can_jump(plant1, plant2):\n        return (plant2[0] > plant1[0] and plant2[1] == plant1[1]) or (plant2[1] > plant1[1] and plant2[0] == plant1[0])\n\n    def get_jumps(energy, plants, start_plant):\n        jumps = []\n        energy -= plants[start_plant - 1][2]\n        if energy >= 0:\n            for i in range(start_plant, len(plants)):\n                if can_jump(plants[start_plant - 1], plants[i]):\n                    jumps.append((start_plant, i + 1))\n                    energy -= plants[i][2]\n                    if energy >= 0:\n                        jumps.extend(get_jumps(energy, plants, i + 1))\n        return jumps\n\n    def find_sequence(energy, plants, start_plant, end_plant, sequence):\n        if start_plant == end_plant:\n            return sequence\n        jumps = get_jumps(energy, plants, start_plant)\n        if not jumps:\n            return None\n        max_energy = 0\n        max_sequence = None\n        for i, j in jumps:\n            energy -= plants[i - 1][2]\n            energy -= plants[j - 1][2]\n            if energy >= 0:\n                sequence_copy = sequence.copy()\n                sequence_copy.append((i, j))\n                energy_copy = get_max_energy(energy, plants)\n                if energy_copy > max_energy:\n                    max_energy = energy_copy\n                    max_sequence = sequence_copy\n        return find_sequence(energy, plants, jumps[0][1], end_plant, max_sequence)\n\n    n, k = map(int, input().split())\n    plants = []\n    for i in range(n):\n        x, y, f = map(int, input().split())\n        plants.append((x, y, f))\n\n    start_plant = 1\n    end_plant = n\n    energy = k\n    sequence = find_sequence(energy, plants, start_plant, end_plant, [])\n\n    if sequence:\n        print(get_max_energy(k, plants))\n        for plant in sequence:\n            print(f\"{plant[0]} {plant[1]}\")\n    else:\n        print(\"No sequence found\")"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_jump(x1, y1, x2, y2, k):\n        if x1 < x2 and y1 == y2:\n            return True\n        if y1 < y2 and x1 == x2:\n            return True\n        return False\n\n    def get_next_plant(x, y, plants):\n        next_plant = None\n        min_distance = float('inf')\n        for plant in plants:\n            distance = abs(x - plant[0]) + abs(y - plant[1])\n            if distance < min_distance and is_valid_jump(x, y, plant[0], plant[1], k):\n                min_distance = distance\n                next_plant = plant\n        return next_plant\n\n    def solve(plants, k, energy):\n        if not plants:\n            return 0\n\n        next_plant = get_next_plant(plants[0][0], plants[0][1], plants[1:])\n        if next_plant:\n            energy -= abs(plants[0][0] - next_plant[0]) + abs(plants[0][1] - next_plant[1])\n            if energy < 0:\n                return 0\n            return solve(plants[1:], k, energy)\n        else:\n            return 0\n\n    N, K = map(int, stdin.split()[0:2])\n    plants = [tuple(map(int, stdin.split()[i:i + 3])) for i in range(2, 2 * N + 1, 3)]\n\n    energy = solve(plants, K, 0)\n    result = 1 if energy > 0 else 0\n    for plant in plants:\n        result += 1\n        if energy <= 0:\n            break\n        energy -= plant[2]\n\n    return f\"{energy}\\n{result}\"\n"
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, K = map(int, input_data.pop(0).split())\n    plants = [list(map(int, line.split())) for line in input_data]\n\n    def is_valid_jump(x1, y1, x2, y2):\n        return ((x2 > x1 and y2 == y1) or (y2 > y1 and x2 == x1)) and (x2 != x1 or y2 != y1)\n\n    def get_closest_plant(x, y):\n        closest_distance = float('inf')\n        closest_plant = None\n        for i, (x_p, y_p, f_p) in enumerate(plants, 1):\n            distance = abs(x_p - x) + abs(y_p - y)\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_plant = i\n        return closest_plant\n\n    energy = 0\n    visited_plants = set()\n    current_plant = 1\n    while current_plant <= N:\n        if current_plant in visited_plants:\n            current_plant = get_closest_plant(plants[current_plant - 1][0], plants[current_plant - 1][1])\n            continue\n        visited_plants.add(current_plant)\n        for i, (x_p, y_p, f_p) in enumerate(plants, 1):\n            if i != current_plant and is_valid_jump(plants[current_plant - 1][0], plants[current_plant - 1][1], x_p, y_p):\n                energy += f_p\n                if energy >= K:\n                    energy -= K\n                    current_plant = i\n                    break\n        if current_plant == N:\n            break\n\n    return str(energy) + '\\n' + str(len(visited_plants)) + '\\n' + '\\n'.join([f'{i} {p[0]} {p[1]}' for i, p in enumerate(plants, 1) if i in visited_plants]) "
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    initial_sequence = list(map(int, stdin.split()[2:2+N]))\n    allowed_swaps = []\n\n    for i in range(2 + N, 2 + N + M, 2):\n        a, b = map(int, stdin.split()[i:i+2])\n        allowed_swaps.append((a, b))\n\n    swaps = 0\n    for i in range(N):\n        if initial_sequence[i] != i + 1:\n            for j in range(N):\n                if initial_sequence[j] == i + 1 and (i, j) not in allowed_swaps:\n                    initial_sequence[i], initial_sequence[j] = initial_sequence[j], initial_sequence[i]\n                    swaps += 1\n                    break\n\n    return swaps"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0].split()[0])\n    M = int(input_list[0].split()[1])\n    perm = list(map(int, input_list[1].split()))\n    swaps = []\n    for i in range(2, len(input_list)):\n        swaps.append(list(map(int, input_list[i].split())))\n    \n    min_swaps = 0\n    for i in range(M):\n        for j in range(i+1, M):\n            if swaps[i][0] == swaps[j][0] and swaps[i][1] == swaps[j][1]:\n                min_swaps += 1\n    \n    return str(min_swaps)"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def swap(arr: list, i: int, j: int):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def find_swap(arr: list, i: int, j: int) -> tuple:\n        for k in range(len(arr)):\n            if arr[k] == i:\n                return (k, j)\n            elif arr[k] == j:\n                return (i, k)\n        return None\n\n    N, M = map(int, input().split())\n    arr = list(map(int, input().split()))\n    swaps = []\n\n    for _ in range(M):\n        a, b = map(int, input().split())\n        swaps.append((a, b))\n\n    swaps.sort(key=lambda x: (x[1], x[0]))\n    visited = [False] * N\n    min_swaps = 0\n\n    for i in range(N):\n        if arr[i] != i + 1:\n            visited[i] = True\n            min_swaps += 1\n\n    if min_swaps == N:\n        return str(min_swaps)\n\n    for a, b in swaps:\n        if not visited[a - 1]:\n            swap(arr, a - 1, b - 1)\n            visited[a - 1] = True\n            visited[b - 1] = True\n            min_swaps += 1\n            break\n\n    for i in range(N):\n        if arr[i] != i + 1:\n            a, b = find_swap(arr, i + 1, arr[i])\n            swap(arr, a - 1, b - 1)\n            visited[a - 1] = True\n            visited[b - 1] = True\n            min_swaps += 1\n            break\n\n    return str(min_swaps)"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0].split(\" \")[0])\n    M = int(input_list[0].split(\" \")[1])\n    initial_perm = list(map(int, input_list[1].split(\" \")))\n    allowed_swaps = [(int(input_list[i+2].split(\" \")[0]), int(input_list[i+2].split(\" \")[1])) for i in range(M)]\n\n    # Initialize the graph with edges for allowed swaps\n    graph = {i: [] for i in range(1, N+1)}\n    for i, j in allowed_swaps:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    # Find the number of connected components\n    visited = [0] * (N+1)\n    components = 0\n    for i in range(1, N+1):\n        if visited[i] == 0:\n            components += 1\n            dfs(i, visited, graph)\n\n    return components - 1\n\ndef"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split('\\n')[0].split())\n    initial_permutation = list(map(int, stdin.split('\\n')[1].split()))\n    allowed_swaps = [tuple(map(int, stdin.split('\\n')[i+2].split())) for i in range(M)]\n\n    def is_valid_swap(swap):\n        return (swap[0] != swap[1] and swap[0] > 0 and swap[1] > 0 and swap[0] <= N and swap[1] <= N)\n\n    def perform_swaps(swaps):\n        for swap in swaps:\n            initial_permutation[swap[0] - 1], initial_permutation[swap[1] - 1] = initial_permutation[swap[1] - 1], initial_permutation[swap[0] - 1]\n\n    valid_swaps = [swap for swap in allowed_swaps if is_valid_swap(swap)]\n    min_swaps = len(valid_swaps)\n\n    while valid_swaps:\n        perform_swaps(valid_swaps)\n        valid_swaps = [swap for swap in allowed_swaps if is_valid_swap(swap)]\n        min_swaps = min(min_swaps, len(valid_swaps))\n\n    return min_swaps\n"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    initial_sequence = list(map(int, stdin.split()[2:2+N]))\n    allowed_swaps = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:2+M]]\n\n    def swap(i, j):\n        initial_sequence[i], initial_sequence[j] = initial_sequence[j], initial_sequence[i]\n\n    def is_valid():\n        return all(initial_sequence[i] < initial_sequence[j] for i, j in allowed_swaps)\n\n    min_swaps = 0\n    while not is_valid():\n        min_swaps += 1\n        swaps_made = 0\n        while swaps_made < len(allowed_swaps):\n            i, j = allowed_swaps[swaps_made]\n            swap(i, j)\n            swaps_made += 1\n\n    return str(min_swaps)\n"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def count_swaps(arr):\n        swaps = 0\n        n = len(arr)\n        for i in range(n):\n            if arr[i] != i+1:\n                swaps += 1\n                j = arr.index(i+1)\n                swap(arr, i, j)\n        return swaps\n\n    N, M = map(int, stdin.split()[:2])\n    arr = list(map(int, stdin.split()[2:2+N]))\n    for i in range(M):\n        A, B = map(int, stdin.split()[2+N+i:2+N+i+2])\n        swap(arr, A-1, B-1)\n    return count_swaps(arr)\n"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    initial_permutation = list(map(int, input_list[1].split()))\n    allowed_swaps = [tuple(map(int, input_list[i+2].split())) for i in range(M)]\n\n    def swap(arr, i, j):\n        arr[i], arr[j] = arr[j], arr[i]\n\n    def check_swap(arr, swap_i, swap_j):\n        for i in range(swap_i, swap_j):\n            if arr[i] != i+1:\n                return False\n        return True\n\n    current_permutation = initial_permutation.copy()\n    swaps = []\n\n    for swap_i, swap_j in allowed_swaps:\n        if swap_i == swap_j:\n            continue\n\n        if current_permutation[swap_i-1] == swap_i and current_permutation[swap_j-1] == swap_j:\n            continue\n\n        if current_permutation[swap_i-1] == swap_j and current_permutation[swap_j-1] == swap_i:\n            swap(current_permutation, swap_i-1, swap_j-1)\n            swaps.append((swap_i, swap_j))\n            continue\n\n        if current_permutation[swap_i-1] == swap_j and check_swap(current_permutation, swap_i, swap_j):\n            current_permutation[swap_i-1], current_permutation[swap_j-1] = current_permutation[swap_j-1], current_permutation[swap_i-1]\n            swaps.append((swap_i, swap_j))\n            continue\n\n        if current_permutation[swap_j-1] == swap_i and check_swap(current_permutation, swap_i, swap_j):\n            current_permutation[swap_i-1], current_permutation[swap_j-1] = current_permutation[swap_j-1], current_permutation[swap_i-1]\n            swaps.append((swap_i, swap_j))\n            continue\n\n    return len(swaps)\n"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # parse input\n    N, M = map(int, stdin.split(\"\\n\")[0].split())\n    perm = list(map(int, stdin.split(\"\\n\")[1].split()))\n    swaps = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[2:]]\n\n    # build graph of allowed swaps\n    adj = {i: [] for i in range(1, N + 1)}\n    for a, b in swaps:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # perform minimum number of swaps to transform perm to 1, 2, ..., N\n    queue = [(0, 1)]  # (node, depth)\n    visited = set()\n    while queue:\n        node, depth = queue.pop(0)\n        if node == N:\n            return depth\n        if node in visited:\n            continue\n        visited.add(node)\n        for neighbor in adj[node]:\n            queue.append((neighbor, depth + 1))"
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    initial_permutation = list(map(int, input_list[1].split()))\n    allowed_swaps = []\n    for i in range(2, len(input_list)):\n        allowed_swaps.append(tuple(map(int, input_list[i].split())))\n    swaps = {(i, i) for i in range(1, N+1)}\n    for swap in allowed_swaps:\n        a, b = swap\n        swaps.remove((a, b))\n        swaps.add((b, a))\n    return len(swaps)\n"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end, graph, visited, costs):\n        queue = [(start, 0)]\n        visited[start] = True\n        while queue:\n            node, cost = queue.pop(0)\n            if node == end:\n                return cost\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, cost+costs[neighbor]))\n        return -1\n\n    def dfs(start, end, graph, visited, costs):\n        stack = [(start, 0)]\n        while stack:\n            node, cost = stack.pop()\n            if node == end:\n                return cost\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    stack.append((neighbor, cost+costs[neighbor]))\n        return -1\n\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list.pop(0).split())\n    graph = [[] for _ in range(n)]\n    costs = [0] * n\n\n    for _ in range(m):\n        a, b = map(int, input_list.pop(0).split())\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if not graph[i] or not graph[j] or i in graph[j] or j in graph[i]:\n                continue\n            if (costs[i]+costs[j]) % 3 == 1:\n                costs[i] += 1\n                costs[j] += 1\n                graph[i].append(j)\n                graph[j].append(i)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if not graph[i] or not graph[j] or i in graph[j] or j in graph[i]:\n                continue\n            if bfs(i, j, graph, [False] * n, costs) % 2 == 1:\n                costs[i] += 1\n                costs[j] += 1\n                graph[i].append(j)\n                graph[j].append(i)\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if not graph[i] or not graph[j] or i in graph[j] or j in graph[i]:\n                continue\n            if dfs(i, j, graph, [False] * n, costs) % 2 == 1:\n                costs[i] += 1\n                costs[j] += 1\n                graph[i].append(j)\n                graph[j].append(i)\n\n    min_cost = min(costs)\n    return min_cost if min_cost >= 0 else -1"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_cycle_odd(cycle: List[int], edges: List[Tuple[int, int]], visited: List[bool]) -> bool:\n        total_cost = 0\n        for i in range(len(cycle)):\n            a, b = cycle[i-1], cycle[i]\n            total_cost += edges[a][b]\n        return total_cost % 2 == 1\n\n    def dfs(start: int, visited: List[bool], edges: List[List[int]]) -> Tuple[int, bool]:\n        if visited[start]:\n            return 0, False\n        visited[start] = True\n        cost = 0\n        for neighbor in edges[start]:\n            c, visited_neighbor = dfs(neighbor, visited, edges)\n            if c == -1 or (cost % 3 != 1) != ((c + cost) % 3 != 1):\n                return -1, False\n            cost += c\n            if visited_neighbor:\n                cycle = [start, neighbor]\n                cycle_cost = cost\n                for i in range(2, len(cycle)):\n                    a, b = cycle[i-1], cycle[i]\n                    if edges[a][b] == -1 or (cycle_cost % 3 != 1) != ((cycle_cost + edges[a][b]) % 3 != 1):\n                        return -1, False\n                    cycle.append(b)\n                    cycle_cost += edges[a][b]\n                if not is_cycle_odd(cycle, edges, visited):\n                    return -1, False\n                return cycle_cost, True\n        return cost, True\n\n    n, m = map(int, stdin.split()[:2])\n    edges = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.split()[:2])\n        edges[a-1].append(b-1)\n        edges[b-1].append(a-1)\n\n    min_cost = float('inf')\n    for i in range(n):\n        visited = [False] * n\n        visited[i] = True\n        c, cycle_found = dfs(i, visited, edges)\n        if c != -1:\n            min_cost = min(min_cost, c)\n\n    return str(min_cost) if min_cost != float('inf') else '-1'\n"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_cycle_sum(area: int, visited: list[bool], costs: list[int]) -> int:\n        start, stack = area, []\n        while not visited[area]:\n            stack.append(area)\n            visited[area] = True\n            area = next_areas[area]\n        cycle_sum = 0\n        while stack:\n            cycle_sum += costs[stack.pop()]\n        return cycle_sum\n\n    def dfs(area: int, visited: list[bool], costs: list[int]) -> tuple[int, int]:\n        if visited[area]:\n            return 0, 0\n        visited[area] = True\n        min_cost, cycle_sum = float('inf'), 0\n        for neighbor in next_areas[area]:\n            if not visited[neighbor]:\n                cost, cycle_sum = dfs(neighbor, visited, costs)\n                cycle_sum += costs[area]\n                if (cycle_sum - cost) % 3 != 1:\n                    min_cost = min(min_cost, cost + costs[area])\n        return min_cost, cycle_sum\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines.pop(0).split())\n    next_areas = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b = map(int, lines.pop(0).split())\n        next_areas[a].append(b)\n        next_areas[b].append(a)\n    min_cost = float('inf')\n    for area in range(1, n + 1):\n        visited = [False] * (n + 1)\n        costs = [0] * (n + 1)\n        cycle_sum = get_cycle_sum(area, visited, costs)\n        if cycle_sum % 2 == 1:\n            min_cost = min(min_cost, dfs(area, visited, costs)[0])\n        if min_cost == 0:\n            break\n    return min_cost if min_cost != float('inf') else -1"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def neighbors(node: int, adj: list) -> list:\n        return [edge[1] for edge in adj if edge[0] == node]\n\n    def dfs(node: int, adj: list, visited: set, cycle: list, visited_from: dict, cost: int) -> bool:\n        visited.add(node)\n        cycle.append(node)\n        for neighbor in neighbors(node, adj):\n            if neighbor not in visited_from:\n                visited_from[neighbor] = node\n                if not dfs(neighbor, adj, visited, cycle, visited_from, cost):\n                    return False\n            elif neighbor != visited_from[node]:\n                cycle.append(neighbor)\n                cycle.append(visited_from[node])\n                cycle.append(visited_from[neighbor])\n                return False\n        return True\n\n    def check_cycle(cycle: list, adj: list) -> bool:\n        start = cycle[0]\n        visited = set()\n        visited_from = {}\n        for node in cycle:\n            if node in visited_from:\n                return False\n            visited.add(node)\n            for neighbor in neighbors(node, adj):\n                if neighbor not in visited_from:\n                    visited_from[neighbor] = node\n        return True\n\n    def min_cost(adj: list, costs: list) -> int:\n        min_cost = float('inf')\n        for i in range(len(adj)):\n            for j in range(i, len(adj)):\n                a = costs[i]\n                b = costs[j]\n                if (a + b) % 3 != 1:\n                    cycle = []\n                    if dfs(adj[i][0], adj, set(), cycle, {}, a) and dfs(adj[j][0], adj, set(), cycle, {}, b):\n                        if check_cycle(cycle, adj):\n                            min_cost = min(min_cost, a + b)\n        return min_cost\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[0:2])\n        adj = [list(map(int, input().split())) for _ in range(m)]\n        costs = [0] * n\n        for i in range(n):\n            costs[i] = int(input())\n        min_cost_value = min_cost(adj, costs)\n        return str(min_cost_value) if min_cost_value != float('inf') else '-1'\n\n    return main(stdin)\n"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(cycle: set, costs: List[int]) -> bool:\n        total_cost = 0\n        for i in range(len(cycle)):\n            a = cycle[i]\n            b = cycle[(i + 1) % len(cycle)]\n            total_cost += costs[a - 1] + costs[b - 1]\n        return total_cost % 2 == 1\n\n    def dfs(adj: List[List[int]], visited: List[bool], costs: List[int], current: int, cycle: set, path: List[int]) -> int:\n        visited[current - 1] = True\n        path.append(current)\n        for neighbor in adj[current - 1]:\n            if not visited[neighbor - 1]:\n                if not is_valid(cycle, costs):\n                    return float('inf')\n                if dfs(adj, visited, costs, neighbor, cycle, path) < result:\n                    result = dfs(adj, visited, costs, neighbor, cycle, path)\n        cycle.add(current)\n        if is_valid(cycle, costs):\n            for i in range(len(cycle)):\n                a = cycle[i]\n                b = cycle[(i + 1) % len(cycle)]\n                costs[a - 1] += 1\n                costs[b - 1] += 1\n                if costs[a - 1] % 3 == 1 or costs[b - 1] % 3 == 1:\n                    costs[a - 1] -= 1\n                    costs[b - 1] -= 1\n        cycle.remove(current)\n        path.pop()\n        return result\n\n    n, m = map(int, stdin.readline().split())\n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, stdin.readline().split())\n        adj[a - 1].append(b)\n        adj[b - 1].append(a)\n\n    costs = [0] * n\n    result = float('inf')\n    for i in range(n):\n        visited = [False] * n\n        path = []\n        cycle = set()\n        if is_valid({i}, costs):\n            if dfs(adj, visited, costs, i, cycle, path) < result:\n                result = dfs(adj, visited, costs, i, cycle, path)\n\n    return str(result) if result != float('inf') else '-1'\n"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    adjacency_list = [[] for _ in range(n)]\n    for road in input_list[1:]:\n        a, b = map(int, road.split())\n        adjacency_list[a-1].append(b-1)\n        adjacency_list[b-1].append(a-1)\n\n    def dfs(start, visited, cost):\n        visited[start] = True\n        for neighbor in adjacency_list[start]:\n            if not visited[neighbor]:\n                if (cost + 1) % 3 == 0:\n                    return -1, cost + 1\n                elif (cost + 1) % 3 == 1:\n                    return -1, cost + 2\n                else:\n                    new_cost, new_cycle_sum = dfs(neighbor, visited, cost + 1)\n                    if new_cycle_sum % 2 == 1:\n                        return min(new_cycle_sum, cost + 1)\n        return cost\n\n    cost = 0\n    for i in range(n):\n        visited = [False] * n\n        new_cost, new_cycle_sum = dfs(i, visited, 0)\n        if new_cycle_sum % 2 == 1:\n            cost = max(cost, new_cycle_sum)\n        else:\n            return -1\n\n    return cost"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_cycle_cost(cycle: set, cost: list) -> int:\n        total_cost = 0\n        for i in range(len(cycle)):\n            a, b = cycle[i-1], cycle[i]\n            total_cost += cost[a] + cost[b]\n        return total_cost\n\n    def is_valid_cycle(cycle: set, cost: list) -> bool:\n        total_cost = get_cycle_cost(cycle, cost)\n        return total_cost % 2 != 0\n\n    def find_cycle(visited: set, start: int, cost: list) -> tuple:\n        cycle = {start}\n        i = start\n        while i not in visited:\n            visited.add(i)\n            j = next((j for j in range(len(adj[i])) if adj[i][j] and j not in visited), -1)\n            if j == -1:\n                return None\n            cycle.add(j)\n            i = j\n        return cycle\n\n    def dfs(visited: set, start: int, cost: list) -> int:\n        min_cost = float('inf')\n        cycle = find_cycle(visited, start, cost)\n        if cycle:\n            for decoration in [0, 1, 2]:\n                new_cost = get_cycle_cost(cycle, [decoration] * len(cycle))\n                if new_cost % 2 != 0 and is_valid_cycle(cycle, [decoration] * len(cycle)):\n                    min_cost = min(min_cost, dfs(visited, start, [decoration] * len(cycle)) + new_cost)\n        return min_cost\n\n    def min_cost(n: int, m: int, adj: list, cost: list) -> int:\n        visited = set()\n        min_cost = float('inf')\n        for i in range(n):\n            if i not in visited:\n                min_cost = min(min_cost, dfs(visited, i, cost))\n        return min_cost if min_cost != float('inf') else -1\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    adj = [[] for _ in range(n)]\n    cost = [float('inf')] * n\n    for line in lines[1:]:\n        a, b = map(int, line.split())\n        adj[a-1].append(b-1)\n        adj[b-1].append(a-1)\n    return str(min_cost(n, m, adj, cost))"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Check if it's possible to decorate the city\n    if len(set(sum(roads, ()))) != n:\n        return \"-1\"\n\n    # Compute the cost of decorating each road\n    costs = [0] * m\n    for i in range(m):\n        for j in range(i + 1, m):\n            if roads[i][1] == roads[j][0]:\n                costs[i] = 1\n                costs[j] = 1\n                break\n            elif roads[i][1] == roads[j][1]:\n                costs[i] = 2\n                costs[j] = 2\n                break\n        else:\n            costs[i] = 0\n\n    # Check if the properties are satisfied\n    for i in range(m):\n        for j in range(i + 1, m):\n            if (costs[i] + costs[j]) % 3 == 1 and roads[i][1] == roads[j][0]:\n                return \"-1\"\n\n    # Compute the cost of decorating the entire city\n    min_cost = 0\n    for cycle in get_cycles(roads):\n        cycle_cost = sum(costs[roads.index(edge)] for edge in cycle)\n        min_cost += cycle_cost if cycle_cost % 2 == 1 else cycle_cost - 2\n\n    return str(min_cost)\n\n\ndef"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_cycle_valid(cycle: List[int]) -> bool:\n        # Check if the sum of costs along the cycle is an odd number\n        cost_sum = sum(costs[i][j] for i, j in zip(cycle, cycle[1:]))\n        if cost_sum % 2 != 1:\n            return False\n\n        # Check if the decorations meet the properties\n        for i, j in zip(cycle, cycle[1:]):\n            if (costs[i][j] + costs[j][i]) % 3 == 1:\n                return False\n        return True\n\n    def find_min_cost(n: int, m: int) -> int:\n        costs = [[0] * n for _ in range(n)]\n        for a, b in map(int, stdin.split()):\n            costs[a - 1][b - 1] = 1\n\n        # Iterate through all possible cycles\n        for cycle in itertools.permutations(range(n), n):\n            if is_cycle_valid(cycle):\n                return min(costs[i][j] + costs[j][i] for i, j in zip(cycle, cycle[1:]))\n\n        return -1\n\n    # Read input\n    n, m = map(int, stdin.split())\n\n    # Solve the problem\n    result = find_min_cost(n, m)\n\n    return str(result)"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    roads = [(a, b) for a, b in map(int, line.split())]\n\n    def dfs(start, visited, stack, cycle, path_cost):\n        visited[start] = True\n        stack.append(start)\n        for a, b in roads:\n            if a == start:\n                next_node = b\n            elif b == start:\n                next_node = a\n            else:\n                continue\n            if not visited[next_node]:\n                if not cycle:\n                    path_cost[0] = (path_cost[0] + 1) % 3\n                cycle = dfs(next_node, visited, stack, cycle or (next_node in stack), path_cost)\n        if cycle:\n            for i, c in enumerate(cycle):\n                if not visited[c]:\n                    cycle = cycle[i:] + cycle[:i]\n                    break\n            cycle_cost = sum(path_cost[a-1] for a in cycle)\n            if cycle_cost % 2 == 1:\n                return cycle\n        stack.pop()\n        return cycle\n\n    cycle = dfs(1, [False] * (n+1), [], False, [0] * n)\n    if cycle:\n        return -1\n    return sum(path_cost[a-1] for a in range(1, n+1)) % 3"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def area(points):\n        area = 0.0\n        for i in range(len(points)):\n            j = (i + 1) % len(points)\n            area += points[i][0] * points[j][1] - points[j][0] * points[i][1]\n        return abs(area) / 2\n\n    n, k = map(int, stdin.readline().split())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n    points.append(points[0])\n\n    if area(points) == 0:\n        raise ValueError(\"Invalid polygon\")\n\n    def greedy(points):\n        sorted_points = sorted(points, key=lambda p: p[0])\n        min_side = distance(sorted_points[0][0], sorted_points[0][1], sorted_points[1][0], sorted_points[1][1])\n        for i in range(1, len(sorted_points) - 1):\n            min_side = min(min_side, distance(sorted_points[i - 1][0], sorted_points[i - 1][1], sorted_points[i + 1][0], sorted_points[i + 1][1]))\n        return min_side\n\n    min_side = greedy(points)\n    for i in range(k):\n        print(\"{:.2f}\".format(min_side))\n\n\ndef"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def perimeter(points):\n        total = 0\n        for i in range(len(points)):\n            total += ((points[i][0] - points[(i + 1) % len(points)][0]) ** 2 + (points[i][1] - points[(i + 1) % len(points)][1]) ** 2) ** 0.5\n        return total\n\n    def area(points):\n        return 0.5 * abs(sum(points[i][0] * points[(i + 1) % len(points)][1] - points[(i + 1) % len(points)][0] * points[i][1] for i in range(len(points))))\n\n    def side_length(points):\n        return round(2 * ((area(points) / (k * k)) ** 0.5), 2)\n\n    n, k = map(int, stdin.readline().split())\n    points = [tuple(map(int, stdin.readline().split())) for _ in range(n)]\n\n    perimeter_length = perimeter(points)\n    side_lengths = []\n    for i in range(k):\n        side_lengths.append(side_length(points))\n\n    for i in range(len(side_lengths)):\n        for j in range(i + 1, len(side_lengths)):\n            if side_lengths[i] * side_lengths[j] > perimeter_length:\n                return \"Impossible\"\n\n    min_side_length = min(side_lengths)\n    return f\"{min_side_length:.2f}\"\n"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def sign(x):\n        if x == 0:\n            return 0\n        return x > 0 and 1 or -1\n\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        return sign(val)\n\n    def convex_hull(points):\n        points.sort()\n        upper_hull = []\n        for point in points:\n            while len(upper_hull) > 1 and orientation(upper_hull[-2], upper_hull[-1], point) <= 0:\n                upper_hull.pop()\n            upper_hull.append(point)\n        lower_hull = []\n        for point in reversed(points):\n            while len(lower_hull) > 1 and orientation(lower_hull[-2], lower_hull[-1], point) <= 0:\n                lower_hull.pop()\n            lower_hull.append(point)\n        return upper_hull[:-1] + lower_hull[:-1]\n\n    def min_side_length(points, k):\n        hull = convex_hull(points)\n        min_length = float('inf')\n        for i in range(len(hull) - k + 1):\n            h = hull[i:i + k]\n            area = 0\n            for j in range(len(h)):\n                area += h[j][0] * (h[(j + 1) % k][1] - h[(j + (k - 1)) % k][1])\n            min_length = min(min_length, abs(area) ** 0.5)\n        return min_length\n\n    def main(stdin: str) -> str:\n        n, k = map(int, stdin.split()[0:2])\n        points = []\n        for _ in range(n):\n            x, y = map(int, stdin.split()[2:4])\n            points.append((x, y))\n        side_length = min_side_length(points, k)\n        return f\"{side_length:.2f}\"\n\n    return main(stdin)"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    polygon = [tuple(map(int, line.split())) for line in input_data[1:n+1]]\n\n    # calculate the area of the polygon\n    def polygon_area(polygon):\n        area = 0\n        j = polygon[-1]\n        for i in polygon:\n            area += i[0] * j[1] - j[0] * i[1]\n            j = i\n        return abs(area) // 2\n\n    # calculate the perimeter of the polygon\n    def polygon_perimeter(polygon):\n        perimeter = 0\n        for i in range(len(polygon)):\n            perimeter += ((polygon[i-1][0] - polygon[i][0])**2 + (polygon[i-1][1] - polygon[i][1])**2)**0.5\n        return perimeter\n\n    # calculate the minimum side length with respect to the canyon for each square map in the mapping system\n    def min_side_length(polygon, perimeter, area):\n        side_length = int((2 * area / k) ** 0.5)\n        if side_length * k > perimeter:\n            return 0.0\n        return side_length\n\n    area = polygon_area(polygon)\n    perimeter = polygon_perimeter(polygon)\n    min_side_lengths = [min_side_length(polygon, perimeter, area)] * k\n    min_side_lengths.sort(reverse=True)\n\n    # output the minimum side length for each square map in the mapping system\n    return ' '.join('{:.2f}'.format(side_length) for side_length in min_side_lengths)"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def are_collinear(p1, p2, p3):\n        return distance(p1, p2) * distance(p1, p3) == distance(p1, p2) * distance(p1, p3)\n\n    def min_side_length(points, k):\n        area = 0\n        for i in range(len(points)):\n            area += points[i][0] * (points[(i + 1) % len(points)][1] - points[(i - 1) % len(points)][1])\n        area /= 2\n\n        min_side = area / k\n        if min_side == 0:\n            return 0\n\n        current_side = min_side\n        while current_side >= min_side / 2:\n            if is_valid_side(points, current_side):\n                return current_side\n            current_side /= 2\n\n        return 0\n\n    def is_valid_side(points, side_length):\n        for i in range(len(points)):\n            p1 = points[i]\n            p2 = points[(i + 1) % len(points)]\n            p3 = points[(i - 1) % len(points)]\n\n            if are_collinear(p1, p2, p3):\n                return False\n\n            if distance(p1, p2) <= side_length and distance(p1, p3) <= side_length:\n                return True\n\n        return False\n\n    def is_valid_polygon(points):\n        for i in range(len(points)):\n            p1 = points[i]\n            p2 = points[(i + 1) % len(points)]\n            p3 = points[(i - 1) % len(points)]\n\n            if are_collinear(p1, p2, p3):\n                return False\n\n        return True\n\n    n, k = map(int, stdin.split()[:2])\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n\n    if not is_valid_polygon(points):\n        return \"0.00\"\n\n    return f\"{min_side_length(points, k):.2f}\""
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    vertices = [tuple(map(int, input_data[i+1].split())) for i in range(n)]\n    \n    # compute the bounding box\n    min_x = min(v[0] for v in vertices)\n    max_x = max(v[0] for v in vertices)\n    min_y = min(v[1] for v in vertices)\n    max_y = max(v[1] for v in vertices)\n    width = max_x - min_x\n    height = max_y - min_y\n    \n    # compute the area\n    area = 0.5 * width * height\n    \n    # compute the side length for each square map\n    if k == 1:\n        side_length = round(math.sqrt(area), 2)\n    else:\n        # compute the total number of squares\n        total_squares = 3 * area\n        side_length = round(math.sqrt(total_squares / k), 2)\n    \n    return f'{side_length:.2f}'"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_polygon(coords: list) -> bool:\n        n = len(coords)\n        for i in range(n):\n            p1, p2 = coords[i], coords[(i + 1) % n]\n            for j in range(n):\n                if i != j:\n                    p3 = coords[j]\n                    if is_collinear(p1, p2, p3):\n                        return False\n        return True\n\n    def is_collinear(p1, p2, p3) -> bool:\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    def calculate_area(coords: list) -> float:\n        n = len(coords)\n        area = 0.0\n        for i in range(n):\n            j = (i + 1) % n\n            area += coords[i][0] * coords[j][1] - coords[j][0] * coords[i][1]\n        return abs(area) / 2\n\n    def calculate_side_length(coords: list, num_maps: int) -> float:\n        area = calculate_area(coords)\n        return (area / num_maps) ** 0.5\n\n    n, k = map(int, stdin.split()[:2])\n    coords = []\n    for _ in range(n):\n        x, y = map(int, stdin.split()[:2])\n        coords.append((x, y))\n\n    if not is_valid_polygon(coords):\n        return \"Invalid polygon.\"\n\n    side_length = calculate_side_length(coords, k)\n    return f\"{side_length:.2f}\"\n"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def orientation(p, q, r):\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def intersect(p1, q1, p2, q2):\n        o1 = orientation(p1, q1, p2)\n        o2 = orientation(p1, q1, q2)\n        o3 = orientation(p2, q2, p1)\n        o4 = orientation(p2, q2, q1)\n        if o1 != o2 and o3 != o4:\n            return True\n        if o1 == 0 and is_on_segment(p1, p2, q1):\n            return True\n        if o2 == 0 and is_on_segment(p1, q2, q1):\n            return True\n        if o3 == 0 and is_on_segment(p2, p1, q2):\n            return True\n        if o4 == 0 and is_on_segment(p2, q1, q2):\n            return True\n        return False\n\n    def is_on_segment(p, q, r):\n        if (q[0] <= max(p[0], r[0])) and (q[0] >= min(p[0], r[0])) and (q[1] <= max(p[1], r[1])) and (q[1] >= min(p[1], r[1])):\n            return True\n        return False\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def min_distance(p, q1, q2):\n        return min(distance(p, q1), distance(p, q2))\n\n    n, k = map(int, input().split())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    points.sort()\n\n    min_length = min_distance(points[0], points[-1], points[1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            for l in range(j + 1, n):\n                if not intersect(points[i], points[j], points[l], points[l + 1]):\n                    length = min_distance(points[i], points[j], points[l])\n                    min_length = min(min_length, length)\n\n    print(round(min_length / k, 2))\n"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    def is_inside(p, hull):\n        n = len(hull)\n        inside = False\n        px, py = p\n        for i in range(n):\n            ax, ay = hull[i]\n            bx, by = hull[(i + 1) % n]\n            if (min(ax, bx) <= px <= max(ax, bx)) and (min(ay, by) <= py <= max(ay, by)):\n                inside = not inside\n        return inside\n\n    def minimum_side_length(n, hull, k):\n        def f(x):\n            if x <= 0:\n                return 0\n            hull_poly = [p + (x, 0) for p in hull]\n            total_area = sum((p[0] * (p[1] - q[1]) + q[0] * (p[1] - q[1])) / 2 for p, q in zip(hull_poly, hull_poly[1:] + hull_poly[:1]))\n            min_side_length = total_area / k\n            return min_side_length\n\n        return binary_search(f, 0, 100000)\n\n    def binary_search(f, left, right):\n        while left <= right:\n            mid = (left + right) / 2\n            if f(mid) == 0:\n                return mid\n            elif f(mid) < 0:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    def main(stdin: str):\n        n, k = map(int, stdin.split()[:2])\n        hull = [tuple(map(int, input().split())) for _ in range(n)]\n\n        min_side_length = minimum_side_length(hull, k)\n        return f\"{min_side_length:.2f}\"\n\n    return main(stdin)"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, k = map(int, inputs.pop(0).split())\n    points = [tuple(map(int, line.split())) for line in inputs[:n]]\n    polygon = Polygon(points)\n\n    # Compute the side length of each square map\n    map_side_length = polygon.area / k\n\n    # Round to two decimal places\n    map_side_length = round(map_side_length, 2)\n\n    return str(map_side_length)"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.splitlines()[0].split())\n    commands = stdin.splitlines()[1:]\n    \n    canvas = [[1] * N for _ in range(N)]\n    def paint_checkerboard(x1, y1, x2, y2, color):\n        for i in range(x1, x2+1):\n            for j in range(y1, y2+1):\n                if (i+j) % 2 == 0:\n                    canvas[i][j] = color\n                else:\n                    canvas[i][j] = 3 - color\n                    \n    for i in range(M):\n        command = commands[i].split()\n        if command[0] == 'PAINT':\n            color, x1, y1, x2, y2 = map(int, command[1:])\n            paint_checkerboard(x1, y1, x2, y2, color)\n        elif command[0] == 'SAVE':\n            pass\n        elif command[0] == 'LOAD':\n            pass\n            \n    result = '\\n'.join(map(lambda row: ' '.join(map(str, row)), canvas))\n    return result"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    commands = stdin.split(\"\\n\")[3:]\n\n    canvas = [[1] * N for _ in range(N)]\n\n    for i in range(M):\n        command = commands[i].split()\n\n        if command[0] == \"PAINT\":\n            c, x1, y1, x2, y2 = map(int, command[1:])\n            if 0 <= x1 < x2 < N and 0 <= y1 < y2 < N:\n                for j in range(x1, x2 + 1):\n                    for k in range(y1, y2 + 1):\n                        canvas[j][k] = c\n\n        elif command[0] == \"SAVE\":\n            pass\n\n        elif command[0] == \"LOAD\":\n            pass\n\n    for row in canvas:\n        print(\" \".join(map(str, row)))"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    commands = stdin.split(\"\\n\")[2:]\n\n    canvas = [[1] * N for _ in range(N)]\n\n    def paint_rectangle(c, x1, y1, x2, y2):\n        for x in range(x1, x2 + 1):\n            for y in range(y1, y2 + 1):\n                canvas[x][y] = c\n\n    for command in commands:\n        if command.startswith(\"PAINT\"):\n            c, x1, y1, x2, y2 = map(int, command.split()[1:])\n            paint_rectangle(c, x1, y1, x2, y2)\n        elif command.startswith(\"SAVE\"):\n            pass\n        elif command.startswith(\"LOAD\"):\n            pass\n\n    for row in canvas:\n        print(*row)\n"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, K, M = map(int, stdin.split()[:3])\n    commands = stdin.split('\\n')[1:]\n\n    # Initialize canvas\n    canvas = [[1 for _ in range(N)] for _ in range(N)]\n\n    # Helper function to check if a cell is in the checkerboard pattern\n    def is_checkerboard(x, y):\n        return (x + y) % 2 == 0\n\n    # Helper function to paint a rectangle\n    def paint_rectangle(c, x1, y1, x2, y2):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                canvas[i][j] = c\n\n    # Execute commands\n    for command in commands:\n        if command.startswith('PAINT'):\n            c, x1, y1, x2, y2 = map(int, command.split()[1:])\n            if 0 <= c <= K and 0 <= x1 <= x2 < N and 0 <= y1 <= y2 < N:\n                paint_rectangle(c, x1, y1, x2, y2)\n        elif command.startswith('SAVE'):\n            pass  # Not implemented\n        elif command.startswith('LOAD'):\n            ordinal, = map(int, command.split()[1:])\n            if 1 <= ordinal <= M:\n                pass  # Not implemented\n\n    # Print canvas\n    return '\\n'.join([' '.join(map(str, row)) for row in canvas])"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K, M = map(int, input_list[0].split())\n    canvas = [[1] * N for _ in range(N)]\n    command_list = input_list[1:]\n    for command in command_list:\n        if command.startswith('PAINT'):\n            color, x1, y1, x2, y2 = map(int, command.split()[1:])\n            if color > K or color < 1:\n                raise ValueError(\"Invalid color value\")\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = color\n        elif command.startswith('SAVE'):\n            pass\n        elif command.startswith('LOAD'):\n            pass\n        else:\n            raise ValueError(\"Invalid command\")\n    result = [' '.join(map(str, row)) for row in canvas]\n    return '\\n'.join(result)"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N, K, M = map(int, input_list[0].split())\n    canvas = [[1] * N for _ in range(N)]\n    commands = input_list[1:]\n\n    for command in commands:\n        if command.startswith(\"PAINT\"):\n            _, color, x1, y1, x2, y2 = command.split()\n            color = int(color)\n            x1, y1, x2, y2 = map(int, [x1, y1, x2, y2])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    if canvas[i][j] == 1:\n                        canvas[i][j] = color\n        elif command.startswith(\"SAVE\"):\n            pass\n        elif command.startswith(\"LOAD\"):\n            _, save_index = command.split()\n            save_index = int(save_index) - 1\n            # reconstruct the canvas from the saved states\n\n    for row in canvas:\n        print(*row)"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    canvas = [[1] * N for _ in range(N)]\n    commands = []\n    \n    for _ in range(M):\n        line = input().split()\n        if line[0] == 'PAINT':\n            c, x1, y1, x2, y2 = map(int, line[1:])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = c\n        elif line[0] == 'SAVE':\n            commands.append(('SAVE', -1, -1, -1, -1))\n        elif line[0] == 'LOAD':\n            commands.append(('LOAD', int(line[1])))\n    \n    for command, x1, y1, x2, y2 in commands:\n        if command == 'SAVE':\n            pass\n        elif command == 'LOAD':\n            canvas = commands[x1][3]\n    \n    result = []\n    for row in canvas:\n        result.append(' '.join(map(str, row)))\n    \n    return '\\n'.join(result)"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.splitlines()[0].split())\n    commands = stdin.splitlines()[1:]\n\n    canvas = [[1] * N for _ in range(N)]\n\n    for command in commands:\n        if command.startswith('PAINT'):\n            c, x1, y1, x2, y2 = map(int, command.split()[1:])\n            for i in range(x1, x2 + 1):\n                for j in range(y1, y2 + 1):\n                    canvas[i][j] = c\n        elif command.startswith('SAVE'):\n            pass\n        elif command.startswith('LOAD'):\n            pass\n\n    result = '\\n'.join([' '.join(map(str, row)) for row in canvas])\n    return result"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    commands = []\n    for _ in range(M):\n        commands.append(input().split())\n\n    canvas = [[1] * N for _ in range(N)]\n\n    def paint_checkerboard(x1, y1, x2, y2, col):\n        for x in range(x1, x2 + 1):\n            for y in range(y1, y2 + 1):\n                if (x + y) % 2 == 0:\n                    canvas[x][y] = col\n\n    for c, x1, y1, x2, y2 in commands:\n        if c == \"PAINT\":\n            col = int(x1)\n            paint_checkerboard(int(x1), int(y1), int(x2), int(y2), col)\n        elif c == \"SAVE\":\n            pass\n        elif c == \"LOAD\":\n            pass\n\n    for row in canvas:\n        print(\" \".join(str(col) for col in row))"
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    commands = stdin.split('\\n')[1:]\n\n    canvas = [[1] * N for _ in range(N)]\n\n    for i in range(M):\n        cmd = commands[i].split()\n        if cmd[0] == 'PAINT':\n            color, x1, y1, x2, y2 = map(int, cmd[1:])\n            for x in range(x1, x2 + 1):\n                for y in range(y1, y2 + 1):\n                    if canvas[x][y] == 1:\n                        canvas[x][y] = color\n        elif cmd[0] == 'SAVE':\n            pass\n        elif cmd[0] == 'LOAD':\n            pass\n\n    for row in canvas:\n        print(' '.join(map(str, row)))\n"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if N < K or (K == 1 and N > 1) or (K == 2 and N > 2):\n        return '-1'\n\n    if K == 1:\n        return ' '.join([str(i) for i in range(1, N + 1)])\n\n    if K == 2:\n        if N % 2 == 0:\n            return ' '.join([str(i) for i in range(1, N + 1, 2)] + [str(i) for i in range(2, N + 1, 2)])\n        else:\n            return ' '.join([str(i) for i in range(1, N + 1, 2)] + [str(i) for i in range(2, N + 1, 2)])[:-1] + [str(N)])\n\n    if K == 3:\n        if N % 3 == 0:\n            return ' '.join([str(i) for i in range(1, N + 1, 3)] + [str(i) for i in range(2, N + 1, 3)])\n        else:\n            return ' '.join([str(i) for i in range(1, N + 1, 3)] + [str(i) for i in range(2, N + 1, 3)])[:-1] + [str(N)])\n\n    if K == N:\n        return ' '.join([str(i) for i in range(1, N + 1)])\n\n    return '-1'\n\ninput_str = \"4 3\"\nprint(solution(input_str)) # Output: 1 4 2 3 "
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1 or K == N:\n        return \" \".join(map(str, range(1, N+1)))\n    \n    for i in range(2, N):\n        if K % i == 0:\n            if K // i <= i:\n                return \" \".join(map(str, range(1, N+1)))\n            else:\n                return \" \".join(map(str, range(1, K+1) + list(range(K+1, N+1, i))))\n    \n    return \" \".join(map(str, range(1, K+1) + list(range(K+1, N+1, 2))))\n\ndef"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K > N:\n        return \"-1\"\n    \n    sequence = list(range(1, N+1))\n    for i in range(len(sequence) - 1):\n        for j in range(i+1, len(sequence)):\n            if sequence[i] > sequence[j]:\n                sequence[i], sequence[j] = sequence[j], sequence[i]\n    \n    monotone_subsequences = []\n    for i in range(len(sequence)):\n        for j in range(i+1, len(sequence)):\n            if sequence[j] > sequence[i] and sequence[j] - sequence[i] < K:\n                for k in range(j+1, len(sequence)):\n                    if sequence[k] > sequence[j] and sequence[k] - sequence[j] < K:\n                        monotone_subsequences.append([sequence[i], sequence[j], sequence[k]])\n    \n    longest_subsequence = max(monotone_subsequences, key=len)\n    if len(longest_subsequence) != K:\n        return \"-1\"\n    \n    return \" \".join(map(str, longest_subsequence))\n"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n\n    if N < K:\n        return \"-1\"\n\n    if K == 1:\n        return \"1\"\n\n    if N == K:\n        return \" \".join(str(i) for i in range(1, N + 1))\n\n    sequence = [None] * N\n    sequence[0] = 1\n    sequence[1] = N\n\n    for i in range(2, N):\n        if sequence[i - 1] < sequence[i - 2]:\n            sequence[i] = sequence[i - 1] + 1\n        else:\n            sequence[i] = sequence[i - 2] + 1\n\n    longest_monotone_subsequence_length = 2\n\n    for i in range(3, N + 1):\n        if sequence[i - 1] < sequence[i - 2]:\n            longest_monotone_subsequence_length = 2\n        elif sequence[i - 1] == sequence[i - 2]:\n            longest_monotone_subsequence_length += 1\n        else:\n            longest_monotone_subsequence_length = 2\n\n        if longest_monotone_subsequence_length == K:\n            return \" \".join(str(sequence[i - 1]) for i in range(1, N + 1))\n\n    return \"-1\"\n"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1 or K == N:\n        return ' '.join(map(str, range(1, N+1)))\n    if K == N-1:\n        return ' '.join(map(str, range(N, 0, -1)))\n    return -1"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K > N:\n        return \"-1\"\n    \n    sequence = []\n    for i in range(1, N+1):\n        if i % K == 0:\n            sequence.append(i)\n    \n    return \" \".join(map(str, sequence))\n"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    \n    if K == 1:\n        return ' '.join(str(i) for i in range(1, N+1))\n    \n    if N % K != 0:\n        return '-1'\n    \n    result = []\n    for i in range(1, K+1):\n        result.append(i)\n        if i != N:\n            result.append(N-i+1)\n    \n    return ' '.join(str(i) for i in result)\n"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1 or N == K:\n        return \" \".join(map(str, range(1, N+1)))\n    if N - K + 1 > K:\n        return \" \".join(map(str, range(1, K+1) + range(N-K+2, N+1)))\n    return \"-1\"\n\n\ninput_str = \"4 3\"  # Sample Input 1\noutput_str = solution(input_str)\nprint(output_str)  # Sample Output 1\n\n\ninput_str = \"5 1\"  # Sample Input 2\noutput_str = solution(input_str)\nprint(output_str)  # Sample Output 2"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_monotone(seq: list) -> bool:\n        for i in range(len(seq) - 1):\n            if seq[i] > seq[i + 1]:\n                return False\n        return True\n\n    def find_longest_monotone_subsequence(seq: list) -> int:\n        dp = [1] * len(seq)\n        for i in range(len(seq) - 1):\n            for j in range(i + 1, len(seq)):\n                if seq[j] > seq[i]:\n                    dp[j] = max(dp[j], dp[i] + 1)\n        return max(dp)\n\n    def find_sequence(N: int, K: int) -> str:\n        if N == K:\n            return ' '.join(str(i) for i in range(1, N + 1))\n\n        seq = list(range(1, N + 1))\n        random.shuffle(seq)\n\n        while not is_monotone(seq):\n            seq = sorted(seq)\n            random.shuffle(seq)\n\n        longest_monotone_subsequence = find_longest_monotone_subsequence(seq)\n        if longest_monotone_subsequence != K:\n            return '-1'\n\n        return ' '.join(str(i) for i in seq)\n\n    N, K = map(int, stdin.split())\n    return find_sequence(N, K)"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    if K > N or K <= 0:\n        return \"-1\"\n    if K == 1:\n        return \"1\"\n    sequence = [1] * N\n    for i in range(2, N + 1):\n        for j in range(1, i):\n            if sequence[j - 1] < i and sequence[j] > i:\n                sequence[j - 1] = i\n                break\n        if sequence[i - 1] == i:\n            return \" \".join(map(str, sequence))\n    return \"-1\"\n\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    triangles = 0\n    \n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                for k in range(N):\n                    if k != i and k != j:\n                        p, q, r = points[i], points[j], points[k]\n                        if p[0] != q[0] and p[0] != r[0] and p[1] != q[1] and p[1] != r[1]:\n                            if p[0] == r[0]:\n                                if (p[1] - q[1])**2 + (r[1] - q[1])**2 == (p[0] - q[0])**2:\n                                    triangles += 1\n                            elif p[1] == r[1]:\n                                if (p[0] - q[0])**2 + (r[0] - q[0])**2 == (p[1] - q[1])**2:\n                                    triangles += 1\n                            else:\n                                if (p[0] - q[0])**2 + (p[1] - q[1])**2 == (r[0] - q[0])**2 + (r[1] - q[1])**2:\n                                    triangles += 1\n                \n    return triangles"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n\n    N = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n\n    count = 0\n    for a, b, c in combinations(points, 3):\n        if a != b and a != c and b != c:\n            x1, y1 = a\n            x2, y2 = b\n            x3, y3 = c\n\n            # check if any two points form a straight line\n            if (x1 - x2) * (y3 - y2) == (x3 - x2) * (y1 - y2):\n                # check if the other point is the hypotenuse\n                if (x1 - x2) ** 2 + (y1 - y2) ** 2 == (x3 - x2) ** 2 + (y3 - y2) ** 2:\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    points = []\n    for i in range(1, N+1):\n        x, y = map(int, input_list[i].split())\n        points.append((x, y))\n\n    def is_right_triangle(p1, p2, p3):\n        a, b, c = p1, p2, p3\n        if a == b or b == c or c == a:\n            return False\n        if a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2:\n            return True\n        return False\n\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if is_right_triangle(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, *points = stdin.split(\"\\n\")\n    N = int(N)\n    points = [tuple(map(int, point.split())) for point in points]\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                x3, y3 = points[k]\n\n                if is_right_triangle(x1, y1, x2, y2, x3, y3):\n                    count += 1\n\n    return str(count)\n\ndef"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    points = []\n    for i in range(1, N+1):\n        x, y = map(int, input_list[i].split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                a, b = points[i], points[j]\n                c, d = points[k], points[j]\n                if abs(a[0] - b[0]) / (b[1] - a[1]) == abs(c[0] - d[0]) / (d[1] - c[1]):\n                    count += 1\n    return count"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def valid_triangle(p1, p2, p3):\n        sides = sorted([distance(p1, p2), distance(p1, p3), distance(p2, p3)])\n        if sides[0] + sides[1] <= sides[2]:\n            return False\n        return True\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    N = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if valid_triangle(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        return a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2\n\n    N = int(stdin.splitlines()[0])\n    points = []\n\n    for i in range(1, N + 1):\n        x, y = map(int, stdin.splitlines()[i].split())\n        points.append((x, y))\n\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                a, b, c = points[i], points[j], points[k]\n                if is_right_triangle(a[0] - b[0], a[1] - b[1], c[0] - b[0]) or \\\n                   is_right_triangle(a[0] - c[0], a[1] - c[1], b[0] - c[0]) or \\\n                   is_right_triangle(b[0] - c[0], b[1] - c[1], a[0] - c[0]):\n                    count += 1\n\n    return count\n"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    points = []\n    for i in range(1, N+1):\n        x, y = input_list[i].split()\n        points.append((int(x), int(y)))\n\n    def is_right_triangle(p1, p2, p3):\n        a, b, c = sorted([distance(p1, p2), distance(p2, p3), distance(p1, p3)])\n        return a**2 + b**2 == c**2\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    count = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            for k in range(j+1, N):\n                if is_right_triangle(points[i], points[j], points[k]):\n                    count += 1\n\n    return str(count)"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    points = [(int(x), int(y)) for x, y in [line.split() for line in stdin.split('\\n')[1:]]]\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                x1, y1 = points[i]\n                x2, y2 = points[j]\n                x3, y3 = points[k]\n\n                if x1 == x2 and x1 == x3 and y1 == y2 and y1 == y3:\n                    continue\n\n                if x1 == x2 or x1 == x3 or x2 == x3:\n                    continue\n\n                if y1 == y2 or y1 == y3 or y2 == y3:\n                    continue\n\n                if x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) == 0:\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        return a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or a**2 + c**2 == b**2\n\n    N, *points = stdin.splitlines()\n    N = int(N)\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                x1, y1 = map(int, points[i].split())\n                x2, y2 = map(int, points[j].split())\n                x3, y3 = map(int, points[k].split())\n\n                a = abs(x2 - x1)\n                b = abs(y2 - y1)\n                c = abs(x3 - x2)\n\n                if is_right_triangle(a, b, c):\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_augmenting_path(graph: list, visited: list, parent: list, source: int, target: int) -> bool:\n        visited[source] = True\n        for node in range(len(graph)):\n            if graph[source][node] > 0 and not visited[node]:\n                parent[node] = source\n                if node == target or find_augmenting_path(graph, visited, parent, node, target):\n                    return True\n        return False\n\n    def max_flow(graph: list, source: int, target: int) -> int:\n        max_flow = 0\n        while find_augmenting_path(graph, [False] * len(graph), [-1] * len(graph), source, target):\n            current_path_flow = float(\"inf\")\n            current_node = target\n            while current_node != source:\n                parent_node = parent[current_node]\n                residual_capacity = graph[parent_node][current_node] - flow[parent_node][current_node]\n                current_path_flow = min(current_path_flow, residual_capacity)\n                current_node = parent[current_node]\n            max_flow += current_path_flow\n            current_node = target\n            while current_node != source:\n                parent_node = parent[current_node]\n                flow[parent_node][current_node] += current_path_flow\n                flow[current_node][parent_node] -= current_path_flow\n                current_node = parent[current_node]\n        return max_flow\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    graph = [[0] * n for _ in range(n)]\n    flow = [[0] * n for _ in range(n)]\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split()[4:])\n        graph[u][v] = c\n        graph[v][u] = 0\n        flow[u][v] = float(\"inf\")\n        flow[v][u] = 0\n\n    min_cost_flow = max_flow(graph, s, t)\n    min_cost = sum(sum(flow[u][v] * w for v in range(n)) for u in range(n))\n\n    return f\"{min_cost_flow} {min_cost}\" "
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    from heapq import heappush, heappop, heapify\n\n    def dijkstra(graph: list, source: int, n: int) -> list:\n        dist = [float('inf')] * n\n        dist[source] = 0\n        queue = deque([(0, source)])\n\n        while queue:\n            d, v = queue.popleft()\n\n            if d > dist[v]:\n                continue\n\n            for neighbor, weight in graph[v]:\n                new_dist = d + weight\n\n                if new_dist < dist[neighbor]:\n                    dist[neighbor] = new_dist\n                    queue.append((new_dist, neighbor))\n\n        return dist\n\n    def ford_fulkerson(graph: list, capacities: list, source: int, sink: int, n: int) -> int:\n        residual_capacities = capacities.copy()\n        flow = 0\n\n        while True:\n            # Compute distances using Dijkstra algorithm\n            distances = dijkstra(graph, source, n)\n\n            # If there is no path from source to sink, break the loop\n            if distances[sink] == float('inf'):\n                break\n\n            # Find the minimum residual capacity of the edges along the path\n            path_flow = float('inf')\n            v = sink\n\n            while v != source:\n                path_flow = min(path_flow, residual_capacities[v])\n                v = graph[v].index((v - 1, graph[v][v - 1][1]))\n\n            # Update the flow and residual capacities\n            flow += path_flow\n            v = sink\n\n            while v != source:\n                u = v - 1\n                residual_capacities[u] -= path_flow\n                residual_capacities[v] += path_flow\n                v = graph[v].index((v - 1, graph[v][v - 1][1]))\n\n        return flow\n\n    def min_cost_flow_approx(graph: list, capacities: list, source: int, sink: int, n: int, m: int) -> int:\n        # Create an auxiliary graph with two additional nodes\n        auxiliary_graph = [[] for _ in range(n + 2)]\n\n        # Add edges to the auxiliary graph\n        for u in range(n):\n            for v, (_, w) in enumerate(graph[u]):\n                auxiliary_graph[u].append((v, w))\n                auxiliary_graph[v + n].append((u, w))\n\n        auxiliary_graph[source].append((n, m))\n        auxiliary_graph[sink].append((n + 1, m))\n\n        # Compute the minimum cost flow using Ford-Fulkerson algorithm\n        return ford_fulkerson(auxiliary_graph, capacities, source, sink + n, n + 2)\n\n    # Read the input\n    n, m, s, t = map(int, stdin.split()[:4])\n    capacities = list(map(int, stdin.split()[4:]))\n\n    # Create the graph\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        u, v, c, w = map(int, stdin.split()[4 + m * i:4 + m * (i + 1)])\n        graph[u].append((v, w))\n\n    # Compute the minimum cost flow\n    flow = min_cost_flow_approx(graph, capacities, s, t, n, m)\n\n    # Compute the cost of the maximum flow\n    cost = sum(w for u, v, c, w in zip(stdin.split()[4:]) if u != s and u != t and v != s and v != t and graph[u].index((v, w)) == 0)\n\n    return f\"{flow} {cost}\""
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    def bfs(graph: dict, visited: set, queue: deque, source: int, sink: int, flow: int) -> int:\n        while queue:\n            node = queue.popleft()\n            if node == sink:\n                return flow\n            for neighbor, capacity in graph[node].items():\n                if capacity > 0 and neighbor not in visited:\n                    new_flow = min(flow, capacity)\n                    if bfs(graph, visited | {node, neighbor}, queue, source, sink, new_flow):\n                        return new_flow\n        return 0\n\n    def ford_fulkerson(graph: dict, source: int, sink: int) -> int:\n        max_flow = 0\n        while True:\n            visited = set()\n            queue = deque([source])\n            curr_flow = bfs(graph, visited, queue, source, sink, float('inf'))\n            if curr_flow == 0:\n                return max_flow\n            max_flow += curr_flow\n            for node in graph:\n                for neighbor, capacity in graph[node].items():\n                    if capacity < float('inf') and graph[neighbor][node] < float('inf'):\n                        graph[node][neighbor] -= curr_flow\n                        graph[neighbor][node] += curr_flow\n\n    def min_cost_flow(graph: dict, source: int, sink: int) -> int:\n        total_cost = sum(capacity * w for u, v, capacity, w in graph if u == source)\n        max_flow = ford_fulkerson(graph, source, sink)\n        return max_flow, total_cost * max_flow\n\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data.pop(0).split())\n    s, t = s, t\n    graph = {u: {} for u in range(n)}\n    for _ in range(m):\n        u, v, c, w = map(int, input_data.pop(0).split())\n        graph[u][v] = c\n        graph[v][u] = 0\n\n    flow, cost = min_cost_flow(graph, s, t)\n    return f'{flow} {cost}'\n"
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_flow(flow_net: List[List[int]], source: int, sink: int) -> int:\n        n = len(flow_net)\n        max_flow = 0\n        flow_in = [0] * n\n        flow_out = [0] * n\n        while True:\n            # Finding the augmenting path\n            curr_flow = [float('inf')] * n\n            curr_flow[source] = 10**9\n            parent = [-1] * n\n            visited = [False] * n\n            visited[source] = True\n            while visited[sink] == False:\n                if visited[sink] == True:\n                    break\n                u = sink\n                while visited[u] == False:\n                    parent[u] = curr_node\n                    curr_node = u\n                    u = parent[u]\n                    if visited[u] == True:\n                        break\n                visited[u] = True\n            # Updating the flow\n            if parent[sink] == -1:\n                break\n            curr_flow[sink] = 10**9\n            curr_node = sink\n            while curr_node != source:\n                curr_flow[parent[curr_node]] = min(curr_flow[parent[curr_node]], curr_flow[curr_node])\n                curr_node = parent[curr_node]\n            curr_flow[source] = 10**9\n            curr_node = source\n            while curr_node != sink:\n                curr_flow[curr_node] = min(curr_flow[curr_node], curr_flow[parent[curr_node]])\n                curr_node = parent[curr_node]\n            # Updating the flow and the capacities\n            curr_node = source\n            while curr_node != sink:\n                curr_node = parent[curr_node]\n                flow_in[curr_node] += curr_flow[curr_node]\n                flow_out[curr_node] -= curr_flow[curr_node]\n                flow_in[parent[curr_node]] -= curr_flow[curr_node]\n                flow_out[parent[curr_node]] += curr_flow[curr_node]\n            max_flow += curr_flow[source]\n        return max_flow\n\n    def find_min_cost_flow(flow_net: List[List[int]], source: int, sink: int, max_flow: int) -> int:\n        n = len(flow_net)\n        cost = 0\n        while max_flow > 0:\n            # Finding the augmenting path\n            curr_flow = [0] * n\n            curr_flow[source] = max_flow\n            parent = [-1] * n\n            visited = [False] * n\n            visited[source] = True\n            while visited[sink] == False:\n                if visited[sink] == True:\n                    break\n                u = sink\n                while visited[u] == False:\n                    parent[u] = curr_node\n                    curr_node = u\n                    u = parent[u]\n                    if visited[u] == True:\n                        break\n                visited[u] = True\n            # Updating the flow\n            if parent[sink] == -1:\n                break\n            curr_flow[sink] = max_flow\n            curr_node = sink\n            while curr_node != source:\n                curr_flow[parent[curr_node]] = min(curr_flow[parent[curr_node]], curr_flow[curr_node])\n                curr_node = parent[curr_node]\n            curr_flow[source] = max_flow\n            curr_node = source\n            while curr_node != sink:\n                curr_flow[curr_node] = min(curr_flow[curr_node], curr_flow[parent[curr_node]])\n                curr_node = parent[curr_node]\n            # Updating the flow and the capacities\n            curr_node = source\n            while curr_node != sink:\n                curr_node = parent[curr_node]\n                flow_in[curr_node] += curr_flow[curr_node]\n                flow_out[curr_node] -= curr_flow[curr_node]\n                flow_in[parent[curr_node]] -= curr_flow[curr_node]\n                flow_out["
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, s, t = map(int, input_data[0].split())\n    edges = []\n    for line in input_data[1:]:\n        u, v, c, w = map(int, line.split())\n        edges.append((u, v, c, w))\n\n    # Build the graph\n    graph = [[] for _ in range(n)]\n    for u, v, c, w in edges:\n        graph[u].append((v, c, w))\n\n    # Find the maximum flow using Ford-Fulkerson algorithm\n    max_flow = 0\n    flow = [0] * n\n    while True:\n        # Relabel nodes with distances from source\n        dist = [float('inf')] * n\n        dist[s] = 0\n        parent = [None] * n\n        queue = [s]\n        while queue:\n            u = queue.pop(0)\n            for v, c, w in graph[u]:\n                if dist[u] + w < dist[v] and flow[u] < c:\n                    dist[v] = dist[u] + w\n                    parent[v] = u\n                    queue.append(v)\n\n        # If there is no path from source to target, break the loop\n        if parent[t] is None:\n            break\n\n        # Calculate the flow through the path\n        v = t\n        while v != s:\n            flow[parent[v]] += 1\n            flow[v] -= 1\n            v = parent[v]\n\n        # Update the maximum flow\n        max_flow += 1\n\n    # Calculate the minimum cost flow\n    min_cost_flow = sum(w for u, v, c, w in edges if u < s and flow[u] > 0)\n\n    return f\"{max_flow} {min_cost_flow}\""
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_flow(graph: dict, residual_graph: dict, source: int, sink: int, flow: int) -> int:\n        if source == sink:\n            return flow\n\n        for node in residual_graph:\n            if residual_graph[node][1] > 0 and (node in graph[source] or node in graph[node]):\n                new_flow = find_max_flow(graph, residual_graph, node, sink, min(flow, residual_graph[node][1]))\n                if new_flow > 0:\n                    residual_graph[node][1] -= new_flow\n                    residual_graph[node][0] += new_flow\n                    residual_graph[source][1] -= new_flow\n                    residual_graph[source][0] += new_flow\n                    return new_flow\n\n        return 0\n\n    def find_min_cost_flow(graph: dict, flow: int) -> int:\n        min_cost = 0\n        for node in graph:\n            for neighbor in graph[node]:\n                min_cost += graph[node][neighbor][\"w\"] * graph[node][neighbor][\"c\"]\n        return min_cost * flow\n\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    graph = {i: {} for i in range(n)}\n    for i in range(1, m + 1):\n        u, v, c, w = map(int, lines[i].split())\n        graph[u][v] = {\"c\": c, \"w\": w}\n        graph[v][u] = {\"c\": c, \"w\": w}\n\n    residual_graph = {i: [0, float(\"inf\")] for i in range(n)}\n    residual_graph[s][1] = float(\"inf\")\n    residual_graph[t][1] = float(\"inf\")\n\n    max_flow = 0\n    while find_max_flow(graph, residual_graph, s, t, max_flow) > 0:\n        max_flow += find_max_flow(graph, residual_graph, s, t, max_flow)\n\n    return f\"{max_flow} {find_min_cost_flow(graph, max_flow)}\" "
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from heapq import heappush, heappop\n\n    def dijkstra(graph, source, n):\n        dist = [float('inf')] * n\n        dist[source] = 0\n        heap = [(0, source)]\n        while heap:\n            d, u = heappop(heap)\n            if d > dist[u]:\n                continue\n            for v, weight in graph[u]:\n                new_dist = dist[u] + weight\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    heappush(heap, (new_dist, v))\n        return dist\n\n    def edmonds_karp(graph, source, sink, n):\n        max_flow = 0\n        residual_graph = deepcopy(graph)\n        while True:\n            dist = dijkstra(residual_graph, source, n)\n            if dist[sink] == float('inf'):\n                break\n            path_flow = float('inf')\n            v = sink\n            while v != source:\n                u = prev[v]\n                path_flow = min(path_flow, residual_graph[u][v][1])\n                v = u\n            max_flow += path_flow\n            v = sink\n            while v != source:\n                u = prev[v]\n                residual_graph[u][v][1] -= path_flow\n                residual_graph[v][u][1] += path_flow\n                v = u\n        return max_flow\n\n    def max_cost_min_flow_heuristic(graph, source, sink, n, m, s, t):\n        min_cost = 100000\n        min_cost_flow_size = 0\n        for u, v, c, w in graph:\n            if u == s or v == s:\n                continue\n            if u == t or v == t:\n                continue\n            if c <= min_cost_flow_size * w:\n                min_cost = float('inf')\n                break\n            min_cost = min(min_cost, w)\n            min_cost_flow_size = min(min_cost_flow_size, c // w)\n        return min_cost_flow_size, min_cost * min_cost_flow_size\n\n    def deepcopy(graph):\n        return [[[v, c] for v, c in u] for u in graph]\n\n    def main(stdin: str) -> str:\n        lines = stdin.split('\\n')\n        n, m, s, t = map(int, lines[0].split())\n        graph = [[] for _ in range(n)]\n        for i in range(1, m + 1):\n            u, v, c, w = map(int, lines[i].split())\n            graph[u].append((v, c))\n            graph[v].append((u, 0))\n        max_flow, min_cost_flow = max_cost_min_flow_heuristic(graph, s, t, n, m, s, t)\n        return f\"{max_flow} {min_cost_flow}\"\n\n    stdin = \"4 4 0 3\\n0 1 4 10\\n1 2 2 10\\n0 2 4 30\\n2 3 4 10\"\n    return main(stdin)\n\nprint(solution(\"\")) "
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    first_line = list(map(int, input_values[0].split()))\n    n, m, s, t = first_line\n    edges = []\n    for i in range(1, m + 1):\n        line = list(map(int, input_values[i].split()))\n        u, v, c, w = line\n        edges.append((u, v, c, w))\n    \n    # Build the residual graph\n    residual_graph = [[0 for _ in range(n)] for _ in range(n)]\n    capacities = [[0 for _ in range(n)] for _ in range(n)]\n    for u, v, c, w in edges:\n        residual_graph[u][v] = w\n        capacities[u][v] = c\n    \n    # Find the maximum flow using BFS\n    max_flow = 0\n    queue = [(s, s, 0, float('inf'))]\n    while queue:\n        u, v, flow, level = queue.pop(0)\n        if v == t:\n            max_flow += flow\n            continue\n        for neighbor, capacity in enumerate(residual_graph[u][:n]):\n            if capacity > 0 and level == residual_graph[u][neighbor] - capacities[u][neighbor]:\n                queue.append((neighbor, v, min(flow, capacity), level))\n                residual_graph[u][neighbor] -= capacity\n                residual_graph[neighbor][u] += capacity\n                capacities[u][neighbor] += capacity\n                capacities[neighbor][u] -= capacity\n    \n    # Find the minimum cost flow\n    min_cost = float('inf')\n    for u in range(n):\n        min_cost = min(min_cost, sum(residual_graph[u][:n]))\n    return max_flow, max_flow * min_cost\n\ninput_values = '''4 4 0 3\n0 1 4 10\n1 2 2 10\n0 2 4 30\n2 3 4 10'''\noutput_values = solution(input_values)\nprint(output_values)\n\ninput_values = '''2 1 0 1\n0 1 1000 100'''\noutput_values = solution(input_values)\nprint(output_values) "
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_bottleneck(graph: dict) -> int:\n        bottleneck = float('inf')\n        for u in graph:\n            for v in graph[u]:\n                bottleneck = min(bottleneck, graph[u][v])\n        return bottleneck\n\n    def max_flow(graph: dict, source: int, sink: int, flow: dict, capacity: dict, residual: dict) -> int:\n        if source == sink:\n            return flow[source][source]\n        if not flow[source]:\n            bottleneck = find_bottleneck(residual)\n            for u in flow[source]:\n                for v in flow[source][u]:\n                    flow[source][u][v] -= bottleneck\n                    flow[v][u][v] += bottleneck\n                    residual[u][v] -= bottleneck\n                    residual[v][u] += bottleneck\n            return max_flow(graph, source, sink, flow, capacity, residual)\n        for v in flow[source]:\n            if not flow[source][v] or flow[source][v][sink] == capacity[source][v]:\n                continue\n            for u in residual[v]:\n                if not residual[v][u]:\n                    continue\n                flow[source][v][sink] = min(flow[source][v][sink], residual[v][u])\n                flow[v][u][sink] -= flow[source][v][sink]\n                flow[v][u][source] += flow[source][v][sink]\n                flow[source][v][u] += flow[source][v][sink]\n                residual[v][u] -= flow[source][v][sink]\n                residual[u][v] += flow[source][v][sink]\n                if not flow[v][u]:\n                    flow[v][u] = {}\n                flow[v][u][source] = flow[v][u].get(source, 0)\n                flow[v][u][u] = flow[v][u].get(u, 0)\n                flow[v][u][sink] = flow[v][u].get(sink, 0)\n        return max_flow(graph, source, sink, flow, capacity, residual)\n\n    n, m, s, t = map(int, stdin.split())\n    graph = {u: {} for u in range(n)}\n    capacity = {u: {} for u in range(n)}\n    residual = {u: {} for u in range(n)}\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split())\n        graph[u][v] = c\n        capacity[u][v] = c\n        residual[u][v] = c\n        residual[v][u] = 0\n    flow = {u: {} for u in range(n)}\n    flow[s] = {u: 0 for u in range(n)}\n    flow[s][s] = 0\n    flow[s][t] = 0\n    flow[t] = {u: 0 for u in range(n)}\n    flow[t][t] = 0\n    flow[t][s] = 0\n    total_flow = max_flow(graph, s, t, flow, capacity, residual)\n    min_cost = sum(flow[s][u] * w for u in graph[s])\n    return f\"{total_flow} {min_cost}\"\n"
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent: list, i: int) -> int:\n        if parent[i] != i:\n            parent[i] = find_parent(parent, parent[i])\n        return parent[i]\n\n    def union_parent(parent: list, i: int, j: int) -> None:\n        parent[find_parent(parent, i)] = find_parent(parent, j)\n\n    n, m, s, t = map(int, stdin.split()[:4])\n    parent = list(range(n))\n    max_flow = 0\n    cost = 0\n\n    for _ in range(m):\n        u, v, c, w = map(int, stdin.split()[4:])\n        u -= 1\n        v -= 1\n\n        while find_parent(parent, u) != find_parent(parent, v):\n            union_parent(parent, u, v)\n            max_flow += c\n            cost += w * c\n\n    return str(max_flow) + \" \" + str(cost)\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    walls = [set() for _ in range(n)]\n    cameras = set()\n\n    for i in range(1, k+1):\n        a, b = map(int, input_list[i].split())\n        if a <= b:\n            for j in range(a, b+1):\n                walls[j-1].add(i)\n        else:\n            for j in range(a, n+1):\n                walls[j-1].add(i)\n            for j in range(1, b+1):\n                walls[j-1].add(i)\n\n    for wall in walls:\n        if not wall:\n            return \"impossible\"\n\n    min_cameras = min(len(wall) for wall in walls)\n    return str(min_cameras)\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    walls = [set() for _ in range(n)]\n    for i in range(1, k+1):\n        a, b = map(int, input_data[i].split())\n        for j in range(min(a, b), max(a, b)+1):\n            walls[j-1].add(i-1)\n    covered_walls = set()\n    for w in walls:\n        if len(w) == 0:\n            return \"impossible\"\n        elif len(w) == 1:\n            covered_walls.add(list(w)[0])\n    return str(len(covered_walls))\n\ndef"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    walls = []\n    for i in range(1, k + 1):\n        a, b = map(int, input_list[i].split())\n        walls.append((a, b))\n    \n    def cover_walls(walls: list, a: int, b: int) -> bool:\n        for wall in walls:\n            if wall[0] <= a <= wall[1] or wall[0] <= b <= wall[1]:\n                return True\n        return False\n    \n    def find_camera_places(walls: list, k: int) -> list:\n        for i in range(1, k + 1):\n            a, b = walls[i - 1]\n            if not cover_walls(walls[:i], a, b):\n                return i\n        return -1\n    \n    camera_places = find_camera_places(walls, k)\n    if camera_places == -1:\n        return \"impossible\"\n    else:\n        return str(camera_places)"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def cover_wall(a, b, i):\n        if a <= b:\n            return max(a, i) <= j <= min(b, n)\n        else:\n            return max(a, i) <= j <= b or 1 <= j <= min(b, n)\n\n    def count_cameras(walls, n):\n        count = 0\n        for i in range(1, n + 1):\n            covered = False\n            for j in range(1, n + 1):\n                if cover_wall(walls[i - 1][0], walls[i - 1][1], j):\n                    covered = True\n                    break\n            if not covered:\n                count += 1\n        return count\n\n    input_lines = stdin.splitlines()\n    n, k = map(int, input_lines[0].split())\n    walls = [tuple(map(int, line.split())) for line in input_lines[1:]]\n\n    if n == 1:\n        return 1\n    elif k >= n:\n        return count_cameras(walls, n)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def cover(x: int, y: int) -> bool:\n        return x <= j <= y if a_i <= b_i else x <= j <= n or 1 <= j <= b_i\n\n    n, k = map(int, stdin.split()[:2])\n    walls = set(range(1, n + 1))\n    cameras = []\n\n    for _ in range(k):\n        a_i, b_i = map(int, stdin.split()[1:3])\n        cameras.append((a_i, b_i))\n\n    for j in range(1, n + 1):\n        for a_i, b_i in cameras:\n            if cover(a_i, b_i):\n                walls.discard(j)\n                break\n\n    return \"impossible\" if walls else len(cameras)\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    walls_covered = [0] * n\n    cameras_needed = 0\n    max_coverage = 0\n    \n    for i in range(1, k + 1):\n        a, b = map(int, input_list[i].split())\n        if a > b:\n            walls_covered[a - 1: b] = [1] * (b - a + 1)\n        else:\n            walls_covered[a - 1: b] = [1] * (b - a + 1)\n    \n    for coverage in walls_covered:\n        if coverage > 0:\n            cameras_needed += 1\n        elif coverage > max_coverage:\n            max_coverage = coverage\n    \n    if cameras_needed > 0:\n        return str(cameras_needed)\n    else:\n        return 'impossible'\n\ninput_string = '''100 7\n1 50\n50 70\n70 90\n90 40\n20 60\n60 80\n80 20'''\n\nprint(solution(input_string))\n\n\ninput_string = '''8 2\n8 3\n5 7'''\n\nprint(solution(input_string))"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_minimal_camera_count(n: int, walls: list) -> int:\n        max_length = max(max(wall) for wall in walls)\n        camera_count = [0] * (max_length + 1)\n        for wall in walls:\n            for i in range(wall[0], wall[1] + 1):\n                camera_count[i] += 1\n\n        for i in range(max_length, 0, -1):\n            if camera_count[i] == 0:\n                continue\n            for j in range(1, i + 1):\n                if camera_count[j] == 0:\n                    return -1\n            return i\n        return 0\n\n    lines = stdin.splitlines()\n    n, k = map(int, lines[0].split())\n    walls = []\n    for _ in range(k):\n        a, b = map(int, lines[_].split())\n        walls.append((a, b))\n\n    result = find_minimal_camera_count(n, walls)\n    return result if result != -1 else \"impossible\"\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def cover_walls(cameras: list, walls: list) -> int:\n        covered_walls = set()\n        for camera in cameras:\n            for wall in walls[camera[0]-1:camera[1]]:\n                covered_walls.add(wall)\n        return len(covered_walls)\n\n    def check_coverage(cameras: list, walls: list) -> bool:\n        return len(walls) <= cover_walls(cameras, walls)\n\n    def is_valid_coverage(cameras: list, walls: list) -> bool:\n        covered_walls = set()\n        for camera in cameras:\n            for wall in walls[camera[0]-1:camera[1]]:\n                covered_walls.add(wall)\n        return len(covered_walls) == len(walls)\n\n    def find_minimal_cameras(cameras: list, walls: list) -> int:\n        cameras.sort(key=lambda x: x[1] - x[0])\n        min_cameras = 1\n        current_coverage = cover_walls([cameras[0]], walls)\n        for camera in cameras[1:]:\n            if current_coverage == len(walls):\n                return min_cameras\n            new_coverage = cover_walls([camera], walls)\n            if new_coverage > current_coverage:\n                min_cameras += 1\n                current_coverage = new_coverage\n        return min_cameras\n\n    def main(stdin: str) -> str:\n        n, k = map(int, stdin.split()[0:2])\n        walls = [[] for _ in range(n)]\n        for i in range(k):\n            a, b = map(int, stdin.split()[i+2:i+4])\n            walls[a-1].append(i+1)\n            walls[b-1].append(i+1)\n        if not is_valid_coverage(list(range(1, k+1)), walls):\n            return \"impossible\"\n        return find_minimal_cameras(list(range(1, k+1)), walls)\n\n    return main(stdin)\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def convex_polygon_area(walls):\n        area = 0\n        for i in range(len(walls)):\n            next_i = (i + 1) % len(walls)\n            area += walls[i][0] * walls[next_i][1]\n            area -= walls[i][1] * walls[next_i][0]\n        return abs(area) // 2\n\n    def camera_coverage(camera_walls, polygon_walls):\n        coverage = set()\n        for wall in polygon_walls:\n            for camera_wall in camera_walls:\n                if (camera_wall[0] <= wall[0] <= camera_wall[1]) or (camera_wall[0] <= wall[1] <= camera_wall[1]):\n                    coverage.add(wall)\n                    break\n        return len(coverage)\n\n    n, k = map(int, stdin.split()[0:2])\n    walls = []\n    for _ in range(k):\n        a, b = map(int, stdin.split()[2:4])\n        walls.append([a, b])\n    walls.sort(key=lambda x: x[0])\n\n    polygon_area = convex_polygon_area(walls)\n    min_walls = 2\n    while True:\n        min_walls += 1\n        cameras = [walls[i:i+2] for i in range(0, len(walls), 2)]\n        coverage = camera_coverage(cameras, walls)\n        if coverage >= polygon_area // 2:\n            break\n\n    return min_walls\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, k = map(int, input_data[0].split())\n    if n < 3:\n        return \"impossible\"\n    walls = []\n    for i in range(1, k + 1):\n        a, b = map(int, input_data[i].split())\n        walls.append((a, b))\n    walls.sort(key=lambda x: x[1])\n    cover = 1\n    current_end = walls[0][1]\n    for i in range(1, n):\n        if walls[i][0] <= current_end:\n            cover += 1\n            current_end = max(current_end, walls[i][1])\n        else:\n            cover += 1\n            current_end = walls[i][1]\n    return str(cover) if cover <= n else \"impossible\""
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Remove leading zeros from the input string\n    stdin = stdin.lstrip('0')\n    \n    # Convert the input string to an integer\n    factorial = int(stdin)\n    \n    # Initialize the value of n\n    n = 1\n    \n    # Calculate the value of n!\n    while factorial > 1:\n        n += 1\n        factorial //= n\n    \n    return str(n)"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n_factorial = int(stdin)\n    n = 1\n    factorial = 1\n    while factorial < n_factorial:\n        n += 1\n        factorial *= n\n    return str(n - 1)\n"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = 1\n    for digit in stdin:\n        n *= int(digit)\n        if n > 10**6:\n            return \"Error: factorial is too large.\"\n    return str(n)\n\nn_factorial = input(\"Enter the factorial of a positive integer: \")\nprint(\"The value of n is:\", solution(n_factorial)) "
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Convert the input string to a number\n    n_factorial = int(stdin)\n\n    # Initialize n to 1\n    n = 1\n\n    # Loop through all possible values of n\n    while n_factorial > 1:\n        n += 1\n        n_factorial //= n\n\n    return str(n)\n"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n_factorial = int(stdin)\n    n = 0\n    while n_factorial > 1:\n        n += 1\n        n_factorial //= n\n    return str(n)\n\ndef"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    factorial = int(stdin)\n    n = 1\n    while factorial // n > 1:\n        n += 1\n        factorial //= n\n    return str(n)\n\n\ndef"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n_fact = int(stdin)\n    n = 0\n    n_factorial = 1\n    while n_factorial < n_fact:\n        n += 1\n        n_factorial *= n\n    return str(n)"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n_factorial = int(stdin)\n    n = 0\n\n    while n_factorial != 1:\n        n += 1\n        if n_factorial % n == 0:\n            n_factorial //= n\n        else:\n            n_factorial //= (n + 1)\n\n    return str(n)"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = 1\n    while stdin:\n        n *= int(stdin[0])\n        stdin = stdin[1:]\n    return str(n)\n"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n_factorial = int(stdin)\n    n = 1\n    while n_factorial > 1:\n        n += 1\n        n_factorial //= n\n    return str(n)"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**6 + 7\n    def C(n, k):\n        if k == 0 or k == n:\n            return 1\n        if k > n or k < 0:\n            return 0\n        num = 1\n        den = 1\n        for i in range(k):\n            num = (num * (n - i)) % MOD\n            den = (den * (i + 1)) % MOD\n        return (num * pow(den, MOD - 2, MOD)) % MOD\n    \n    result = C(N, K) * pow(M, K, MOD)\n    return str(result)\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    modulo = 10**6 + 7\n    if K > M:\n        return 0\n    dp = [1] * (K + 1)\n    for i in range(2, M + 1):\n        temp = [0] * (K + 1)\n        for j in range(1, K + 1):\n            temp[j] = (temp[j - 1] + dp[j]) % modulo\n        dp = temp\n    return dp[K]\n"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**6 + 7\n    dp = [0] * (K + 1)\n    dp[0] = 1\n    for i in range(K):\n        for j in range(M):\n            dp[i + 1] += dp[i]\n            dp[i + 1] %= MOD\n    return dp[K]\n\ninput_string = \"10 1 2\"\nprint(solution(input_string))\n\ninput_string = \"3 3 3\"\nprint(solution(input_string)) "
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**6 + 7\n    \n    def count_ways(N, M, K, memo={}):\n        if (N, M, K) in memo:\n            return memo[(N, M, K)]\n        \n        if K == 0:\n            return 1\n        if N == 0:\n            return 0\n        \n        if K == 1:\n            return M\n        \n        if K > M:\n            return 0\n        \n        res = count_ways(N-1, M, K, memo) + count_ways(N-1, M-1, K-1, memo)\n        memo[(N, M, K)] = res\n        \n        return res % mod\n    \n    return str(count_ways(N, M, K))"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N, M, K = map(int, input_list)\n    result = 0\n    MOD = 10**6 + 7\n\n    if K > N:\n        return str(0)\n\n    for i in range(K + 1):\n        for j in range(N - K + i + 1):\n            if i == 0:\n                result = (result + 1) % MOD\n            elif i == 1:\n                result = (result + M) % MOD\n            else:\n                result = (result + (M**(i - 1) * (N - i + 1)) % MOD) % MOD\n\n    return str(result)\n"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**6 + 7\n    \n    if K > M:\n        return 0\n    \n    dp = [1] * (K + 1)\n    \n    for i in range(2, M + 1):\n        for j in range(K, i - 1, -1):\n            dp[j] = (dp[j] + dp[j - i]) % MOD\n    \n    return dp[K]\n"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    if K > M:\n        return \"0\"\n    else:\n        return str((M - K) * (M - K + 1) // 2)"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**6 + 7\n    if K > M:\n        return 0\n    elif K == 0 or K == M:\n        return 1\n    else:\n        C = [0] * (M + 1)\n        C[0] = 1\n        for i in range(1, M + 1):\n            C[i] = (C[i - 1] * i) % mod\n        \n        num = C[M] * C[M - K] % mod\n        den = 1\n        for i in range(1, M - K + 1):\n            den = (den * i) % mod\n        return num * pow(den, mod - 2, mod) % mod\n\n\ndef"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    MOD = 10**6 + 7\n    if K > M:\n        return \"0\"\n    if K == M:\n        return str((N * (N - 1)) // 2 % MOD)\n    else:\n        return str(N ** K % MOD)"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    if K > M:\n        return 0\n    elif K == M:\n        return 1\n    elif K == 0 or K == 1:\n        return 1\n\n    MOD = 10**6 + 7\n    dp = [1] * (K + 1)\n\n    for i in range(2, M + 1):\n        for j in range(1, K + 1):\n            dp[j] = (dp[j] + dp[j - 1]) % MOD\n\n    return dp[K]\n\n\nn_cases = int(input())\n\nfor _ in range(n_cases):\n    stdin = input()\n    result = solution(stdin)\n    print(result) "
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x, y, x_inter, y_inter):\n        return abs(x - x_inter) + abs(y - y_inter)\n\n    n, d = map(int, stdin.splitlines()[0].split())\n    houses = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:n+1]]\n\n    min_dist = float('inf')\n    for x in range(d+1):\n        for y in range(d+1):\n            total_dist = sum(distance(x, y, h[0], h[1]) for h in houses)\n            if total_dist <= min_dist:\n                min_dist = total_dist\n\n    return min_dist if min_dist != float('inf') else \"impossible\"\n"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def closest_intersection(houses, max_distance):\n        min_distance = float('inf')\n        closest_intersection = None\n\n        for x in range(min(houses)[0] - max_distance, max(houses)[0] + max_distance + 1):\n            for y in range(min(houses)[1] - max_distance, max(houses)[1] + max_distance + 1):\n                total_distance = sum(distance((x, y), house) for house in houses)\n                if total_distance < min_distance:\n                    min_distance = total_distance\n                    closest_intersection = (x, y)\n\n        if min_distance == float('inf'):\n            return \"impossible\"\n        else:\n            return min_distance\n\n    input_data = [line.strip() for line in stdin.split('\\n')]\n    n = int(input_data[0])\n    houses = [tuple(map(int, line.split())) for line in input_data[1:n+1]]\n    d = int(input_data[n+1])\n\n    result = closest_intersection(houses, d)\n    return str(result)\n"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid_intersection(x, y, d):\n        for i in range(n):\n            if distance(x, y, x_houses[i], y_houses[i]) > d:\n                return False\n        return True\n\n    def calculate_total_distance():\n        total_distance = 0\n        for i in range(n):\n            total_distance += distance(x_houses[i], y_houses[i], x_star, y_star)\n        return total_distance\n\n    n, stdin = int(stdin.splitlines()[0]), '\\n'.join(stdin.splitlines()[1:])\n    x_houses, y_houses, d = [], [], int(stdin.splitlines()[-1])\n\n    for i in range(n):\n        x, y = map(int, stdin.splitlines()[i].split())\n        x_houses.append(x)\n        y_houses.append(y)\n\n    min_distance = float('inf')\n    for x in range(max(x_houses) + 1):\n        for y in range(max(y_houses) + 1):\n            if is_valid_intersection(x, y, d):\n                total_distance = calculate_total_distance()\n                min_distance = min(min_distance, total_distance)\n\n    return min_distance if min_distance != float('inf') else \"impossible\""
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(x, y):\n        return abs(x - x_star) + abs(y - y_star)\n\n    def is_valid_intersection(x, y):\n        for i in range(n):\n            if get_distance(x, y) > d:\n                return False\n        return True\n\n    def find_min_distance():\n        min_distance = float('inf')\n        for x in range(max_x + 1):\n            for y in range(max_y + 1):\n                if is_valid_intersection(x, y):\n                    distance = sum(get_distance(x, y) for x, y in points)\n                    min_distance = min(min_distance, distance)\n        return min_distance\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    points = []\n    max_x = 0\n    max_y = 0\n    d = int(lines[-1])\n\n    for i in range(1, n + 1):\n        x, y = map(int, lines[i].split())\n        points.append((x, y))\n        max_x = max(max_x, x)\n        max_y = max(max_y, y)\n\n    if max_x + max_y <= d:\n        return str(sum(get_distance(x, y) for x, y in points))\n    else:\n        x_star, y_star = max_x // 2, max_y // 2\n        min_distance = find_min_distance()\n        if min_distance == float('inf'):\n            return \"impossible\"\n        else:\n            return str(min_distance) "
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def min_distance(x, y, n, x_coords, y_coords, d):\n        min_dist = float('inf')\n        for i in range(n):\n            dist = distance(x, y, x_coords[i], y_coords[i])\n            if dist <= d:\n                min_dist = min(min_dist, dist)\n        return min_dist\n\n    n = int(stdin[0])\n    x_coords, y_coords = [], []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin[i].split())\n        x_coords.append(x)\n        y_coords.append(y)\n\n    d = int(stdin[n + 1])\n\n    min_dist = float('inf')\n    for x in range(max(x_coords) + 1):\n        for y in range(max(y_coords) + 1):\n            dist = min_distance(x, y, n, x_coords, y_coords, d)\n            if dist != float('inf') and dist < min_dist:\n                min_dist = dist\n\n    if min_dist == float('inf'):\n        return \"impossible\"\n    else:\n        return min_dist\n"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list.pop(0))\n    citizen_list = []\n    for i in range(n):\n        x, y = input_list.pop(0).split()\n        citizen_list.append((int(x), int(y)))\n    d = int(input_list.pop(0))\n\n    max_x = max(citizen_list, key=lambda x: x[0])[0]\n    min_x = min(citizen_list, key=lambda x: x[0])[0]\n    max_y = max(citizen_list, key=lambda x: x[1])[1]\n    min_y = min(citizen_list, key=lambda x: x[1])[1]\n\n    def is_valid(x, y):\n        return all(abs(x - citizen[0]) + abs(y - citizen[1]) <= d for citizen in citizen_list)\n\n    def calculate_distance(x, y):\n        return sum(abs(x - citizen[0]) + abs(y - citizen[1]) for citizen in citizen_list)\n\n    x_range = range(min_x, max_x + 1)\n    y_range = range(min_y, max_y + 1)\n\n    result = \"impossible\"\n    min_distance = float('inf')\n\n    for x in x_range:\n        for y in y_range:\n            if is_valid(x, y):\n                distance = calculate_distance(x, y)\n                if distance < min_distance:\n                    min_distance = distance\n                    result = (x, y)\n\n    if min_distance != float('inf'):\n        return str(min_distance)\n    else:\n        return result\n\ndef"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    d = int(input_list[-1])\n    x_coords = [int(x) for x in input_list[1].split()]\n    y_coords = [int(y) for y in input_list[2].split()]\n    # Compute the minimum distance between two parallel streets\n    min_distance = min(abs(x_coords[i] - x_coords[i+1]) for i in range(len(x_coords)-1))\n    \n    # Compute the minimum distance for each citizen\n    min_distances = [min(abs(x_coords[i] - x_coords[j]) + abs(y_coords[i] - y_coords[j]) for j in range(n)) for i in range(n)]\n    \n    # Compute the maximum distance for each citizen\n    max_distances = [min_distance + 2*d for i in range(n)]\n    \n    # Find the intersection that minimizes the total distance\n    total_distance = sum(min_distances)\n    if total_distance <= sum(max_distances):\n        return str(total_distance)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    citizens = [tuple(map(int, line.split())) for line in input_data[1:n + 1]]\n    d = int(input_data[n + 1])\n\n    min_distance = float('inf')\n    for x, y in citizens:\n        distance = sum(manhattan_distance(x, y, x2, y2) for x2, y2 in citizens)\n        min_distance = min(min_distance, distance)\n\n    if min_distance <= d:\n        return str(min_distance)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_close_enough(x, y, x_star, y_star, d):\n        return distance(x, y, x_star, y_star) <= d\n\n    n, x_y_list, d = stdin.split(\"\\n\")\n    n = int(n)\n    x_y_list = x_y_list.split()\n    x_y_list = [list(map(int, x_y_list[i:i+2])) for i in range(0, len(x_y_list), 2)]\n    d = int(d)\n\n    min_dist = float(\"inf\")\n    x_star, y_star = 0, 0\n\n    for x in range(d+1):\n        for y in range(d+1):\n            dist = sum(distance(x, y, x_h, y_h) for x_h, y_h in x_y_list)\n            if dist <= min_dist:\n                min_dist = dist\n                x_star = x\n                y_star = y\n\n    if min_dist == float(\"inf\"):\n        return \"impossible\"\n    else:\n        return min_dist"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from typing import List\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    city_coordinates = [[int(x), int(y)] for x, y in [line.split() for line in input_list[1:n+1]]]\n    d = int(input_list[n+1])\n    \n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def min_distance(city_coordinates, d):\n        min_dist = float('inf')\n        for x in range(d + 1):\n            for y in range(d + 1):\n                dist = sum(distance(x, y, x1, y1) for x1, y1 in city_coordinates)\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n\n    min_dist = min_distance(city_coordinates, d)\n    return str(min_dist) if min_dist != float('inf') else 'impossible'\n\ninput_str = '''5\n3 1\n4 1\n5 9\n2 6\n5 3\n10'''\n\nprint(solution(input_str)) "
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *coords = stdin.split()\n    N = int(N)\n    \n    if N < 2:\n        return \"0\"\n    \n    coords = [list(map(int, coords[i:i+3])) for i in range(0, len(coords), 3)]\n    \n    cost = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            c = abs(coords[i][0] - coords[j][0]) + abs(coords[i][1] - coords[j][1]) + abs(coords[i][2] - coords[j][2])\n            cost = min(cost, c)\n            \n    return str(cost)"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    planets = [list(map(int, input_list[i+1].split())) for i in range(N)]\n    \n    min_cost = float('inf')\n    for i in range(N):\n        for j in range(i+1, N):\n            cost = min(abs(planets[i][0] - planets[j][0]),\n                       abs(planets[i][1] - planets[j][1]),\n                       abs(planets[i][2] - planets[j][2]))\n            min_cost = min(min_cost, cost)\n            \n    return str(min_cost)\n\ndef"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(x1, y1, z1, x2, y2, z2):\n        return min(abs(x1 - x2), abs(y1 - y2), abs(z1 - z2))\n\n    N = int(stdin.split(\"\\n\")[0])\n    planets = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n\n    total_cost = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_cost += tunnel_cost(*planets[i], *planets[j])\n\n    return str(total_cost)\n"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    N = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    cost = 0\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            cost += tunnel_cost(points[i], points[j])\n\n    return str(cost)\n\ndef"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(x, y):\n        return min(abs(x[0] - y[0]), abs(x[1] - y[1]), abs(x[2] - y[2]))\n\n    N = int(stdin)\n    coordinates = []\n    for _ in range(N):\n        x, y, z = map(int, stdin.readline().split())\n        coordinates.append((x, y, z))\n\n    total_cost = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            total_cost += tunnel_cost(coordinates[i], coordinates[j])\n\n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(x1, y1, z1, x2, y2, z2):\n        return min(abs(x2 - x1), abs(y2 - y1), abs(z2 - z1))\n\n    N = int(stdin)\n    planets = []\n    for _ in range(N):\n        x, y, z = map(int, input().split())\n        planets.append((x, y, z))\n\n    cost = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            cost += tunnel_cost(*planets[i], *planets[j])\n\n    return str(cost)\n"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    planets = [[int(coord) for coord in input_data[i+1].split()] for i in range(N)]\n    \n    def tunnel_cost(p1, p2):\n        return min(abs(p1[0] - p2[0]), abs(p1[1] - p2[1]), abs(p1[2] - p2[2]))\n    \n    total_cost = 0\n    for i in range(N-1):\n        for j in range(i+1, N):\n            total_cost += tunnel_cost(planets[i], planets[j])\n    \n    return str(total_cost)"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(A, B):\n        return min(abs(A[0] - B[0]), abs(A[1] - B[1]), abs(A[2] - B[2]))\n\n    N = int(stdin.splitlines()[0])\n    planets = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_cost = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            min_cost += tunnel_cost(planets[i], planets[j])\n\n    return str(min_cost)\n\n\ndef"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    def distance(a, b):\n        return sum(abs(a - b))\n\n    def shortest_path(graph, start, end):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            (vertex, dist) = queue.pop(0)\n            if vertex not in visited:\n                visited.add(vertex)\n                if vertex == end:\n                    return dist\n                for neighbor in graph[vertex]:\n                    queue.append((neighbor, dist + 1))\n        return -1\n\n    N = int(stdin.splitlines()[0])\n    points = []\n    for i in range(1, N + 1):\n        x, y, z = map(int, stdin.splitlines()[i].split())\n        points.append((x, y, z))\n\n    graph = {}\n    for i in range(N):\n        graph[i] = []\n        for j in range(N):\n            if i != j:\n                cost = tunnel_cost(points[i], points[j])\n                graph[i].append((j, cost))\n\n    total_cost = 0\n    for i in range(N):\n        for j in range(N):\n            if i != j:\n                total_cost += graph[i][j][1]\n\n    minimum_cost = float('inf')\n    for i in range(N):\n        minimum_cost = min(minimum_cost, total_cost - shortest_path(graph, i, N - 1))\n\n    return str(minimum_cost)\n"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def tunnel_cost(x1, y1, z1, x2, y2, z2):\n        return min(abs(x1 - x2), abs(y1 - y2), abs(z1 - z2))\n\n    N = int(stdin.split('\\n')[0])\n    planets = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    cost = 0\n\n    for i in range(N-1):\n        x1, y1, z1 = planets[i]\n        x2, y2, z2 = planets[i+1]\n        cost += tunnel_cost(x1, y1, z1, x2, y2, z2)\n\n    return str(cost)"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    photos = []\n    for _ in range(m):\n        first_photo, second_photo = stdin.split(maxsplit=m)[1:3]\n        photos.append((first_photo, second_photo))\n\n    def count_wirings(n: int) -> int:\n        if n == 1:\n            return 2\n        if n == 2:\n            return 3\n        return 4 * count_wirings(n - 1)\n\n    total_wirings = count_wirings(n)\n    consistent_wirings = 0\n    for first_photo, second_photo in photos:\n        for switch in first_photo:\n            if switch == '1':\n                consistent_wirings += int(second_photo[first_photo.index(switch)] == '1')\n            else:\n                consistent_wirings += int(second_photo[first_photo.index(switch)] == '0')\n        consistent_wirings %= 1000003\n    return str(total_wirings - consistent_wirings)\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_wires(photos: list) -> int:\n        wire_count = 1\n        for photo in photos:\n            if photo[0] != photo[1]:\n                wire_count *= 2\n        return wire_count\n\n    def count_wires_with_switch_on_light(photos: list) -> int:\n        wire_count = 0\n        for photo in photos:\n            if photo[0] == photo[1]:\n                wire_count += 1\n        return wire_count\n\n    def count_wires_with_switch_off_light(photos: list) -> int:\n        wire_count = 1\n        for photo in photos:\n            if photo[0] != photo[1]:\n                wire_count *= 2\n        return wire_count\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def solve(photos: list) -> int:\n        count_switch_on_light = count_wires_with_switch_on_light(photos)\n        count_switch_off_light = count_wires_with_switch_off_light(photos)\n        return lcm(count_switch_on_light, count_switch_off_light)\n\n    n, m = map(int, stdin.split()[:2])\n    photos = [stdin.split()[2:]]\n    for _ in range(m - 1):\n        photos.append(stdin.split()[2:])\n\n    return str(solve(photos) % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    photos = []\n    for _ in range(m):\n        switches, lights = map(int, stdin.splitlines()[1 + i].split())\n        photos.append((switches, lights))\n\n    # Compute the number of possible wiring combinations\n    total_wirings = 2 ** n\n\n    # Compute the number of possible wiring combinations that are consistent with all the photos\n    for switches, lights in photos:\n        total_wirings = total_wirings // 2 if switches != lights else total_wirings\n\n    # Compute the result modulo 1000003\n    result = total_wirings % 1000003\n\n    return str(result)\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def switch_light_map(photo: str) -> str:\n        switch_light_map = \"\"\n        for i in range(len(photo)):\n            if photo[i] == \"1\":\n                switch_light_map += \"0\" if i % 2 == 0 else \"1\"\n            else:\n                switch_light_map += \"1\" if i % 2 == 0 else \"0\"\n        return switch_light_map\n\n    def count_wirings(n: int, photos: list[str]) -> int:\n        count = 1\n        for photo in photos:\n            switch_light_map_photo = switch_light_map(photo)\n            count = count * 2 ** (n - len(set(switch_light_map_photo))) % 1000003\n        return count\n\n    n, m = map(int, input().split())\n    photos = []\n    for _ in range(m):\n        photos.append(input())\n        photos.append(input())\n\n    result = count_wirings(n, photos)\n    return str(result % 1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    photos = [input_list[i + 1].split() for i in range(m)]\n\n    lights = [0] * n\n    switches = [0] * n\n\n    for photo in photos:\n        for i in range(n):\n            if photo[0][i] == '1':\n                switches[i] ^= 1\n            if photo[1][i] == '1':\n                lights[i] ^= 1\n\n    count = 1\n    for i in range(n):\n        count *= 2\n        count %= 1000003\n\n    for i in range(n):\n        if switches[i] == 0:\n            count //= 2\n            count %= 1000003\n\n    return str(count)\n\n\ndef"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *photos = stdin.split('\\n')\n    n, m = int(n), int(m)\n    light_configs = set()\n    switch_configs = set()\n\n    for photo in photos:\n        lights = photo[0]\n        switches = photo[1]\n        light_configs.add(lights)\n        switch_configs.add(switches)\n\n    result = len(light_configs) * len(switch_configs)\n    return str(result % 1000003)"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, photos = 0, 0, []\n    photos_set = set()\n\n    stdin = stdin.split('\\n')\n    n, m = map(int, stdin[0].split())\n\n    for i in range(1, m + 1, 2):\n        switches = stdin[i]\n        lights = stdin[i + 1]\n        photo = (switches + lights).encode()\n\n        if photo in photos_set:\n            return \"0\"\n\n        photos_set.add(photo)\n        photos.append((switches, lights))\n\n    count = 1\n    switches = [\"0\"] * n\n    lights = [\"0\"] * n\n\n    for i in range(n):\n        for j in range(2):\n            switches[i] = str(j)\n            lights[i] = str(j)\n            if switches[i] != lights[i]:\n                break\n        else:\n            count = 0\n            break\n\n    for photo in photos:\n        for i in range(n):\n            if photo[0][i] != switches[i] or photo[1][i] != lights[i]:\n                count = 0\n                break\n        else:\n            count = 0\n            break\n\n    return str(count % 1000003)\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def cross_out(light: int, switch: int, seen: set) -> None:\n        if light in seen:\n            return\n        seen.add(light)\n        for i, v in enumerate(wiring):\n            if v == switch:\n                cross_out(i, light, seen)\n    \n    n, m, photos = 0, 0, []\n    for line in stdin.split(\"\\n\"):\n        if not n and not m:\n            n, m = map(int, line.split())\n        elif m > 0:\n            m -= 1\n            photos.append(list(map(int, line)))\n    \n    def count_wirings() -> int:\n        wiring = [0] * n\n        seen = set()\n        cross_out(0, 0, seen)\n        return len(seen)\n    \n    total = 1\n    for _ in range(m):\n        total *= count_wirings()\n        total %= 1000003\n    return total\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_consistent(photos, switches, lights):\n        for photo in photos:\n            switch_photo = photo[0]\n            light_photo = photo[1]\n            for switch in switch_photo:\n                if switch == '1':\n                    if lights[switches.index(switch)] == '1':\n                        return False\n            for light in light_photo:\n                if light == '1':\n                    if switches[lights.index(light)] == '1':\n                        return False\n        return True\n\n    n, m = map(int, input().split())\n    photos = []\n    for _ in range(m):\n        photo_1 = input()\n        photo_2 = input()\n        photos.append([photo_1, photo_2])\n\n    switches = [str(i) for i in range(n)]\n    lights = [str(i) for i in range(n)]\n\n    consistent_wirings = 0\n    while consistent_wirings == 0:\n        if is_consistent(photos, switches, lights):\n            consistent_wirings += 1\n        switches.append(switches.pop(0))\n        lights.append(lights.pop(0))\n        consistent_wirings %= 1000003\n\n    return str(consistent_wirings)\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_wirings(n: int, photos: list) -> int:\n        def is_wiring_consistent(wiring: list) -> bool:\n            for photo in photos:\n                consistent = True\n                for i in range(n):\n                    if wiring[i] != photo[i]:\n                        consistent = False\n                        break\n                if consistent:\n                    return True\n            return False\n\n        wiring_count = 1\n        possible_wirings = [list(range(n))]\n        for photo in photos:\n            new_possible_wirings = []\n            for wiring in possible_wirings:\n                for i in range(n):\n                    new_wiring = wiring.copy()\n                    new_wiring[i] = 1 - new_wiring[i]\n                    if new_wiring not in new_possible_wirings and is_wiring_consistent(new_wiring):\n                        new_possible_wirings.append(new_wiring)\n            possible_wirings = new_possible_wirings\n            wiring_count *= len(new_possible_wirings)\n            wiring_count %= 1000003\n        return wiring_count\n\n    n, m = map(int, stdin.split()[0:2])\n    photos = []\n    for _ in range(m):\n        photo = stdin.split()[2:]\n        photos.append([int(photo[i]) for i in range(n)])\n\n    result = count_wirings(n, photos)\n    return str(result)\n"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def consecutive_subsequences(N, a, P):\n        count = 0\n        for i in range(N):\n            if sum(a[i:j]) >= P:\n                count += 1\n        return count\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    P = int(lines[2])\n    return str(consecutive_subsequences(N, a, P))\n"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    prices = list(map(int, input_list[1].split()))\n    p = int(input_list[2])\n\n    subsequences = 0\n    current_sum = sum(prices[:n-1])\n    for i in range(n-1):\n        current_sum += prices[i] - prices[i+1]\n        if current_sum >= p*(n-i):\n            subsequences += 1\n\n    return str(subsequences)"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def count_subsequences(prices: List[int], p: int) -> int:\n        n = len(prices)\n        subsequences = 0\n        for i in range(n):\n            if i + 2 < n and sum(prices[i:i+2]) >= p:\n                if sum(prices[i+1:i+3]) >= p:\n                    subsequences += 1\n            if i + 3 < n and sum(prices[i:i+3]) >= p:\n                if sum(prices[i+1:i+4]) >= p:\n                    subsequences += 1\n            if i + 4 < n and sum(prices[i:i+4]) >= p:\n                if sum(prices[i+1:i+5]) >= p:\n                    subsequences += 1\n        return subsequences\n\n    def parse_input(input_str: str) -> Tuple[int, List[int], int]:\n        lines = input_str.split('\\n')\n        N = int(lines[0])\n        prices = [int(x) for x in lines[1].split()]\n        P = int(lines[2])\n        return N, prices, P\n\n    N, prices, P = parse_input(stdin)\n    subsequences = count_subsequences(prices, P)\n    return str(subsequences)\n"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    p = int(input_list[2])\n    count = 0\n\n    for i in range(n-1):\n        if sum(a[i:i+2])/2 >= p:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_subsequences(prices, P):\n        count = 0\n        current_sum = 0\n        for price in prices:\n            current_sum += price\n            if current_sum >= P:\n                count += 1\n                current_sum -= prices[0]\n        return count\n\n    N, *prices = map(int, stdin.strip().split('\\n')[1].split())\n    P = int(stdin.strip().split('\\n')[2])\n\n    prices = [prices[i:i + N] for i in range(0, len(prices), N)]\n\n    result = 0\n    for prices_list in prices:\n        result += count_subsequences(prices_list, P)\n\n    return str(result)"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_subsequences(price_list: list, P: int) -> int:\n        n = len(price_list)\n        dp = [[0] * 3 for _ in range(n)]\n\n        for i in range(n):\n            dp[i][0] = 1\n            dp[i][1] = 1\n            dp[i][2] = 1\n\n            for j in range(i):\n                if price_list[j] <= price_list[i]:\n                    dp[i][0] += dp[j][0]\n                    dp[i][1] += dp[j][1]\n                    dp[i][2] += dp[j][2]\n\n        count = 0\n        for i in range(n):\n            if price_list[i] >= P:\n                count += dp[i][0] + dp[i][1]\n\n        return count\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    a = list(map(int, lines[1].split()))\n    P = int(lines[2])\n\n    return str(count_subsequences(a, P))\n"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    a = list(map(int, input().split()))\n    P = int(input())\n    \n    count = 0\n    for i in range(N - 1):\n        avg = (a[i] + a[i+1]) / 2\n        if avg >= P:\n            count += 1\n    \n    subsequences = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            avg = sum(a[i:j+1]) / (j - i + 1)\n            if avg >= P:\n                subsequences += 1\n    \n    return str(subsequences - count)\n"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    price_list = list(map(int, input().split()))\n    P = int(input())\n\n    count = 0\n    for i in range(N):\n        if sum(price_list[i:i+3])/3 >= P:\n            count += 1\n\n    for i in range(N-2):\n        if sum(price_list[i:i+4])/4 >= P:\n            count += 1\n\n    print(count)\n\n    return str(count)\n\n\ninput_stdin = \"\"\"\n3\n1 2 3\n3\n\"\"\"\n\noutput_stdout = \"\"\"\n1\n\"\"\"\n\ninput_stdin2 = \"\"\"\n3\n1 3 2\n2\n\"\"\"\n\noutput_stdout2 = \"\"\"\n5\n\"\"\"\n\nprint(solution(input_stdin))\nprint(solution(input_stdin2)) "
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, a, P = input_processing(stdin)\n    subsequences = []\n    total_price = sum(a)\n    average_price = total_price / N\n\n    if average_price >= P:\n        subsequences.append([0])\n        subsequences.append([N - 1])\n\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            subsequence = list(range(i, j + 1))\n            if check_condition(a, subsequence, P):\n                subsequences.append(subsequence)\n\n    return str(len(subsequences))\n\n\ndef"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    a_i = list(map(int, input_list[1].split()))\n    P = int(input_list[2])\n\n    count = 0\n    for i in range(N - 1):\n        if sum(a_i[i:i + 2]) / 2 >= P:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def worst_case_time(n: int, r: int, p: int) -> int:\n        if p >= r:\n            return 0\n        else:\n            return 2 * (n // 2) * p + r\n\n    def binary_search(n: int, r: int, p: int, low: int, high: int) -> int:\n        if low == high:\n            return worst_case_time(low, r, p)\n\n        mid = (low + high) // 2\n        time = worst_case_time(mid, r, p)\n\n        if time == 0:\n            return binary_search(mid, r, p, low, mid)\n        else:\n            return binary_search(mid, r, p, mid, high)\n\n    n, r, p = map(int, stdin.split())\n    return binary_search(n, r, p, 1, n)\n"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return str(r)\n    else:\n        return str(r + (n-1) * p)\n\ndef"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return str(r + p)\n    else:\n        return str(2 * r + 1 * p + p)\n\nn, r, p = map(int, input().split())\nprint(solution(f\"{n} {r} {p}\")) "
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    return r * n // (n - 1) + p * (n - 1) // 2\n\n\ndef"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    return r + p + r * (n - 1)\n\ndef"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    \n    # Calculate the time to find the crashing line\n    t = r\n    \n    # Place a printf statement in the middle of the code\n    t += n // 2 * p\n    \n    return str(t)\n\n\ninput_data = \"10 10 1\"\nprint(solution(input_data)) "
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split()\n    n, r, p = int(input_str[0]), int(input_str[1]), int(input_str[2])\n    if n <= 2:\n        return str(0)\n    total_time = (n - 1) * r + p\n    # if there is only one line, the program will crash in the first iteration\n    if n == 2:\n        return str(r)\n    # if there are more than 2 lines, the program will crash in the middle\n    if n > 2:\n        return str(total_time // 2 + r)\n\ninput_str = \"10 10 1\"\nprint(solution(input_str))"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def compute_time(n: int, r: int, p: int) -> int:\n        total_time = 0\n        for i in range(n):\n            total_time += r\n        total_time += p * n // 2\n        return total_time\n\n    n, r, p = map(int, stdin.split())\n    return str(compute_time(n, r, p))\n"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return str(r)\n    \n    worst_case_time = r + p * (n // 2) + (n // 2) * (n // 2 - 1) // 2 * p\n    return str(worst_case_time)"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, r, p = input_data\n\n    # Calculate the worst-case time to find the crashing line\n    worst_case_time = (n - 1) * p + r\n\n    return str(worst_case_time)"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n\n    def topological_sort(dependencies):\n        degrees = {name: 0 for name in dependencies}\n        for name, imports in dependencies.items():\n            for import_name in imports:\n                degrees[import_name] += 1\n        queue = deque([name for name, degree in degrees.items() if degree == 0])\n        sorted_names = []\n\n        while queue:\n            name = queue.popleft()\n            sorted_names.append(name)\n            for import_name in dependencies[name]:\n                degrees[import_name] -= 1\n                if degrees[import_name] == 0:\n                    queue.append(import_name)\n\n        return sorted_names\n\n    def find_cycle(dependencies):\n        visited = set()\n        stack = []\n        cycles = []\n        for name in dependencies:\n            if name in visited:\n                continue\n            visited.add(name)\n            stack.append(name)\n            while stack:\n                top = stack[-1]\n                if top in dependencies:\n                    for import_name in dependencies[top]:\n                        if import_name in visited:\n                            continue\n                        visited.add(import_name)\n                        stack.append(import_name)\n                        break\n                    else:\n                        cycle = []\n                        while stack[-1] != top:\n                            cycle.append(stack.pop())\n                        cycle.append(top)\n                        cycle.reverse()\n                        cycles.append(cycle)\n                        visited.remove(top)\n                else:\n                    stack.pop()\n        return cycles\n\n    def shortest_cycle(cycles):\n        shortest = min(cycles, key=len)\n        return shortest\n\n    lines = stdin.splitlines()\n    num_files = int(lines[0])\n    files = lines[1:num_files + 1]\n    dependencies = {}\n\n    for i, file in enumerate(files):\n        imports = lines[num_files + 2 + i].split(', ')\n        dependencies[file] = imports\n\n    sorted_names = topological_sort(dependencies)\n\n    if sorted_names[-1] == 'SHIP IT':\n        return sorted_names[-1]\n\n    cycles = find_cycle(dependencies)\n    shortest_cycle = shortest_cycle(cycles)\n\n    return ', '.join(shortest_cycle)\n"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    n, file_names = map(str.strip, stdin.split('\\n')[0].split())\n    n = int(n)\n    file_names = file_names.split()\n    imports = {name: set() for name in file_names}\n    for i in range(1, n + 1):\n        name, k = map(str.strip, stdin.split('\\n')[i].split())\n        k = int(k)\n        deps = stdin.split('\\n')[i + 1:i + k + 1]\n        for dep in deps:\n            imports[name].update(dep.split(', ')[1:])\n\n    # Find the shortest cycle\n    visited = set()\n    shortest_cycle = None\n    for file_name in file_names:\n        if file_name in visited:\n            continue\n        cycle = find_cycle(file_name, imports, visited)\n        if cycle:\n            if shortest_cycle is None or len(cycle) < len(shortest_cycle):\n                shortest_cycle = cycle\n\n    # Output the result\n    if shortest_cycle is None:\n        return \"SHIP IT\"\n    else:\n        return ' '.join(shortest_cycle)\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import combinations\n\n    # Parse the input\n    n, file_names = map(int, stdin.splitlines()[0].split())\n    files = {name: [] for name in file_names}\n    for file_name in file_names:\n        _, k = map(int, stdin.splitlines()[file_names.index(file_name) + 1].split())\n        for _ in range(k):\n            line = stdin.splitlines()[file_names.index(file_name) + 1 + k]\n            files[file_name].extend(line.split(', ')[1:])\n\n    # Build the dependency graph\n    graph = defaultdict(list)\n    for file_name, dependencies in files.items():\n        for dependency in dependencies:\n            graph[dependency].append(file_name)\n\n    # Find the shortest dependency cycle\n    for i in range(n):\n        for file_names in combinations(file_names, i + 1):\n            cycle = [file_name for file_name in file_names]\n            for file_name in file_names:\n                if file_name in cycle:\n                    cycle.append(cycle[cycle.index(file_name) - 1])\n                else:\n                    cycle.append(graph[file_name][0])\n            if len(set(cycle)) == len(cycle) and cycle[0] == cycle[-1]:\n                return cycle\n\n    # No shortest cycle found\n    return \"SHIP IT\"\n\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def build_graph(files: set, import_list: list, file_name: str) -> set:\n        imports = set()\n        for line in import_list:\n            for imp_file in line.split(', '):\n                imports.add(imp_file)\n        for imp_file in imports:\n            if imp_file not in files:\n                files.add(imp_file)\n                build_graph(files, import_dict[imp_file], imp_file)\n        import_dict[file_name] = import_list\n\n    def find_shortest_cycle(file_dict: dict, file_name: str) -> list:\n        current_file = file_name\n        cycle = [current_file]\n        while True:\n            import_list = file_dict[current_file]\n            for line in import_list:\n                for imp_file in line.split(', '):\n                    if imp_file == current_file:\n                        cycle.append(imp_file)\n                        return cycle\n            current_file = imp_file\n            cycle.append(imp_file)\n\n    n = int(stdin.readline().strip())\n    files = set()\n    file_dict = {}\n    import_dict = {}\n    for i in range(n):\n        file_name, k = stdin.readline().strip().split()\n        import_list = []\n        for j in range(int(k)):\n            import_list.append(stdin.readline().strip())\n        files.add(file_name)\n        file_dict[file_name] = import_list\n        build_graph(files, import_list, file_name)\n\n    shortest_cycle = []\n    for file_name in files:\n        cycle = find_shortest_cycle(file_dict, file_name)\n        if len(cycle) < len(shortest_cycle) or not shortest_cycle:\n            shortest_cycle = cycle\n\n    return ', '.join(shortest_cycle) if shortest_cycle else 'SHIP IT'\n"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n = int(stdin.readline())\n    file_names = stdin.readline().split()\n    file_deps = {}\n\n    for i in range(n):\n        file_name, dep_count = stdin.readline().split()\n        file_deps[file_name] = set()\n        for j in range(int(dep_count)):\n            dep_file = stdin.readline().strip()\n            file_deps[file_name].add(dep_file)\n\n    # Find shortest dependency cycle\n    visited = set()\n    cycle = []\n    for file_name in file_names:\n        if file_name not in visited:\n            if detect_cycle(file_name, file_deps, visited, cycle):\n                break\n\n    if not cycle:\n        return \"SHIP IT\"\n    else:\n        return \" \".join(cycle)\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(node: str, seen: set, visited: set, current_path: list, cycles: list):\n        seen.add(node)\n        visited.add(node)\n        current_path.append(node)\n\n        for dep in dependencies[node]:\n            if dep not in seen:\n                find_cycle(dep, seen, visited, current_path, cycles)\n            elif dep in visited:\n                cycle = [node]\n                while current_path[-1] != dep:\n                    cycle.append(current_path.pop())\n                cycle.append(dep)\n                cycle.reverse()\n                cycles.append(cycle)\n\n        seen.remove(node)\n        current_path.pop()\n\n    n = int(stdin.split(\"\\n\")[0])\n    files = stdin.split(\"\\n\")[1].split()\n    dependencies = {file: [] for file in files}\n\n    for i in range(2, len(stdin.split(\"\\n\")), n + 1):\n        file, k = stdin.split(\"\\n\")[i].split()\n        assert file in files\n        assert k.isdigit()\n        deps = stdin.split(\"\\n\")[i + 1:i + int(k) + 1]\n        for dep in deps:\n            assert dep.startswith(\"import \")\n            dep = dep[7:].strip()\n            assert dep in files\n            dependencies[file].append(dep)\n\n    cycles = []\n    for file in files:\n        seen = set()\n        visited = set()\n        current_path = []\n        find_cycle(file, seen, visited, current_path, cycles)\n\n    if len(cycles) == 0:\n        return \"SHIP IT\"\n    else:\n        cycle = cycles[0]\n        return \", \".join(cycle)\n"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph: dict, start: str) -> list:\n        visited = set()\n        cycle = []\n        def dfs(node: str):\n            nonlocal cycle\n            if node in cycle:\n                return\n            if node in visited:\n                cycle = [node]\n                return\n            visited.add(node)\n            cycle.append(node)\n            for neighbor in graph[node]:\n                dfs(neighbor)\n                cycle.append(neighbor)\n        dfs(start)\n        return cycle\n\n    n = int(stdin.splitlines()[0])\n    file_names = stdin.splitlines()[1].split()\n    graph = {file_name: set() for file_name in file_names}\n    for i in range(2, len(stdin.splitlines()), n + 1):\n        file_name, dependencies = stdin.splitlines()[i].split(maxsplit=1)\n        dependencies = dependencies.split(', ')\n        graph[file_name] = dependencies\n    shortest_cycle = []\n    for file_name in file_names:\n        cycle = find_cycle(graph, file_name)\n        if len(cycle) < len(shortest_cycle) or not shortest_cycle:\n            shortest_cycle = cycle\n    if not shortest_cycle:\n        return \"SHIP IT\"\n    else:\n        return ' '.join(shortest_cycle)\n"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict, deque\n\n    def find_cycle(graph: defaultdict, visited: set, vertex: str) -> bool:\n        if vertex in visited:\n            return True\n        visited.add(vertex)\n        for neighbor in graph[vertex]:\n            if find_cycle(graph, visited, neighbor):\n                return True\n        return False\n\n    def shortest_cycle(graph: defaultdict, vertex: str) -> str:\n        visited = set()\n        cycle = deque()\n        while True:\n            if find_cycle(graph, visited, vertex):\n                cycle.appendleft(vertex)\n                break\n            visited.add(vertex)\n            vertex = list(graph[vertex])[0]\n        while vertex not in cycle:\n            cycle.appendleft(vertex)\n            vertex = list(graph[vertex])[0]\n        return ' '.join(cycle)\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    files = lines[1].split()\n    graph = defaultdict(set)\n    for file in files:\n        graph[file]\n    for i in range(2, len(lines), 2):\n        file = lines[i]\n        imports = lines[i + 1].split()\n        graph[file] |= set(imports)\n\n    if len(graph) == len(set().union(*graph.values())):\n        return \"SHIP IT\"\n\n    shortest = float('inf')\n    cycle = \"\"\n    for file in files:\n        if shortest_cycle(graph, file) in files:\n            cycle = shortest_cycle(graph, file)\n            shortest = len(cycle.split()) - 1\n            break\n\n    if shortest == float('inf'):\n        return \"SHIP IT\"\n    else:\n        return cycle.split()[shortest:] + cycle.split()[:shortest]\n"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def read_input():\n        n = int(stdin.readline().strip())\n        files = [line.strip() for line in stdin.readline().strip().split()]\n        file_to_deps = {}\n        for i in range(n):\n            file, k = stdin.readline().strip().split()\n            file_to_deps[file] = set(stdin.readline().strip().split(\", \"))\n        return n, files, file_to_deps\n\n    def find_shortest_cycle(file_to_deps):\n        def dfs(file, visited, stack, cycle):\n            visited.add(file)\n            stack.append(file)\n            for dep in file_to_deps[file]:\n                if dep in visited:\n                    cycle.append(dep)\n                    return dep\n                cycle_dep = dfs(dep, visited, stack, cycle)\n                if cycle_dep:\n                    cycle.append(cycle_dep)\n                    return cycle_dep\n            stack.pop()\n            return None\n\n        for file in file_to_deps:\n            visited = set()\n            stack = []\n            cycle = []\n            dfs(file, visited, stack, cycle)\n            if cycle:\n                return cycle\n        return None\n\n    n, files, file_to_deps = read_input()\n    cycle = find_shortest_cycle(file_to_deps)\n    if cycle:\n        return \" \".join(cycle)\n    else:\n        return \"SHIP IT\"\n\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    import heapq\n\n    def shortest_cycle(graph, start):\n        visited = set()\n        distances = defaultdict(lambda: float('inf'))\n        distances[start] = 0\n        queue = [(0, start)]\n\n        while queue:\n            distance, node = heapq.heappop(queue)\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor, weight in graph[node].items():\n                if neighbor not in visited:\n                    distance = min(distance, distances[node] + weight)\n                    heapq.heappush(queue, (distance, neighbor))\n                    distances[neighbor] = min(distances[neighbor], distance)\n\n        return [node for node, distance in distances.items() if distance != float('inf')]\n\n    files, file_dependencies = stdin.split('\\n')\n    n_files = int(files.split()[0])\n    file_names = files.split()[1:]\n    file_dependencies = file_dependencies.split('\\n')\n\n    graph = defaultdict(lambda: {})\n    for file_name, dependencies in zip(file_names, file_dependencies):\n        if dependencies.startswith('import'):\n            dependencies = dependencies.split('import ')[1].split(', ')\n            for dep in dependencies:\n                graph[file_name][dep] = 1\n\n    shortest_cycle_files = shortest_cycle(graph, file_names[0])\n    return ' '.join(shortest_cycle_files) if shortest_cycle_files else 'SHIP IT'\n\n\ndef"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = input().split()\n    A = list(A)\n    P = int(P)\n    M = int(M)\n\n    x = 0\n    i = 0\n    while i < len(A):\n        if A[i] == 'x':\n            A[i] = x\n            x += 1\n        elif A[i] == '+':\n            A[i] = '+'\n        elif A[i] == '-':\n            A[i] = '-'\n        elif A[i] == '*':\n            A[i] = '*'\n        i += 1\n\n    A = ''.join(A)\n\n    while x > 0:\n        try:\n            index = A.index('x')\n            A = A[:index] + str(x) + A[index + 1:]\n            x -= 1\n        except ValueError:\n            break\n\n    if eval(A) % M == P:\n        return str(0)\n\n    for i in range(1, M):\n        if eval(A) % M == (P - i) % M:\n            return str(i)\n\n    return str(M)"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    A = stdin.splitlines()[0]\n    P, M = map(int, stdin.splitlines()[1].split())\n\n    # Define helper functions\n    def evaluate(A: str, x: int) -> int:\n        stack = []\n        for i, c in enumerate(A):\n            if c == 'x':\n                stack.append(x)\n            elif c == '+':\n                if len(stack) < 2:\n                    raise ValueError(\"Invalid expression\")\n                a, b = stack.pop(), stack.pop()\n                stack.append(a + b)\n            elif c == '-':\n                if len(stack) < 2:\n                    raise ValueError(\"Invalid expression\")\n                a, b = stack.pop(), stack.pop()\n                stack.append(a - b)\n            elif c == '*':\n                if len(stack) < 2:\n                    raise ValueError(\"Invalid expression\")\n                a, b = stack.pop(), stack.pop()\n                stack.append(a * b)\n            elif c == '(':\n                pass\n            elif c == ')':\n                pass\n            else:\n                stack.append(int(c))\n        if len(stack) != 1:\n            raise ValueError(\"Invalid expression\")\n        return stack[0]\n\n    def is_polynomial(A: str) -> bool:\n        for i, c in enumerate(A):\n            if c == 'x' and (i == 0 or A[i - 1] != '(' or i == len(A) - 1 or A[i + 1] != ')'):\n                return False\n        return True\n\n    # Solve the problem\n    x = 0\n    while evaluate(A, x) % M != P:\n        x += 1\n    return str(x)"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def calculate(a: str) -> int:\n        stack = []\n        for i in range(len(a)):\n            if a[i] == '(':\n                stack.append(i)\n            elif a[i] == ')':\n                j = stack.pop()\n                expr = a[j:i+1]\n                value = calculate(expr[1:-1])\n                a = a[:j] + str(value) + a[i+1:]\n        a = a.replace('x', '1')\n        return int(a) % M\n\n    A, P, M = stdin.split()\n    P, M = int(P), int(M)\n    A = A.replace(' ', '')\n\n    # Find the minimal non-negative value of x\n    x = 0\n    while calculate(A.replace('x', str(x))) != P:\n        x += 1\n\n    return str(x)\n"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.splitlines()\n    P = int(P)\n    M = int(M)\n\n    A = list(A)\n    i = 0\n    while i < len(A):\n        if A[i] == 'x':\n            if A[i+1] == '(':\n                j = i + 1\n                depth = 1\n                while depth > 0:\n                    j += 1\n                    if A[j] == '(':\n                        depth += 1\n                    elif A[j] == ')':\n                        depth -= 1\n                A = A[:i] + A[j:]\n                i -= 1\n            else:\n                A[i] = '*'\n        i += 1\n\n    A = ''.join(A)\n    A = eval(A)\n\n    x = 0\n    while A % M != P:\n        x += 1\n        A += 1\n\n    return str(x)\n"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    expression, P, M = stdin.split('\\n')\n    P, M = int(P), int(M)\n    \n    def is_valid(expression: str) -> bool:\n        stack = []\n        for char in expression:\n            if char in '0123456789':\n                if stack and stack[-1] == '*':\n                    return False\n                stack.append(char)\n            elif char in '+-(':\n                stack.append(char)\n            elif char == ')':\n                while stack and stack[-1] != '(':\n                    if stack[-1] == '*':\n                        return False\n                    stack.pop()\n                if not stack:\n                    return False\n                stack.pop()\n            elif char == '*':\n                while stack and stack[-1] != '*':\n                    if stack[-1] == '+':\n                        return False\n                    stack.pop()\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n    \n    def f(x: int) -> int:\n        return (eval(expression.replace('x', str(x))) % M) == P\n    \n    if not is_valid(expression):\n        return \"Invalid expression\"\n    \n    left = 0\n    right = 100000\n    \n    while left < right:\n        mid = (left + right + 1) // 2\n        if f(mid):\n            right = mid\n        else:\n            left = mid\n    \n    return str(left)\n\ndef"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = [int(x) for x in input().split()]\n    x = 0\n    while A % M != P:\n        x += 1\n        A += 1\n    return str(x)\n\ninput_data = '''5+3+x\n9 10\n20+3+x\n0 5'''\n\ninput_data = input_data.split('\\n')\n\nfor i in range(0, len(input_data), 2):\n    expression = input_data[i].split()\n    result = solution(input_data[i+1])\n    print(f\"Expression: {' '.join(expression)}\\nResult: {result}\")"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split('\\n')\n    P, M = int(P), int(M)\n    x = 0\n\n    while (A, P, M, x) not in seen:\n        seen.add((A, P, M, x))\n        x += 1\n        if A.count('x') > 1:\n            break\n\n        A_eval = eval(A.replace('x', '{}'.format(x)))\n        if (A_eval % M) == P:\n            return str(x)\n\n    return str(x)\n"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = input(stdin).split()\n    P, M = int(P), int(M)\n    x = 0\n    while A.count(\"x\") > 1:\n        x += 1\n        A = A.replace(\"x\", str(x), 1)\n    A = eval(A)\n    while A % M != P:\n        x += 1\n        A = eval(A + \" + \" + str(x))\n    return str(x)\n\n\ninput_1 = \"5+3+x\\n9 10\"\ninput_2 = \"20+3+x\\n0 5\"\n\nprint(solution(input_1))  # Output: 1\nprint(solution(input_2))  # Output: 2 "
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = input().split()\n    P = int(P)\n    M = int(M)\n\n    def is_valid(expression: str) -> bool:\n        stack = []\n        for char in expression:\n            if char == 'x':\n                return True\n            elif char in '()+*':\n                stack.append(char)\n            elif char == '-':\n                if not stack or stack[-1] == '(':\n                    stack.append(char)\n                else:\n                    stack.pop()\n                    stack.append('+')\n                    stack.append(char)\n            else:\n                return False\n        return not stack or stack[-1] == '('\n\n    def count_multiplications(expression: str) -> int:\n        count = 0\n        stack = []\n        for char in expression:\n            if char == 'x':\n                count += len(stack)\n                stack = []\n            elif char == '*':\n                count += len(stack)\n                stack = [char]\n            elif char in '+-)':\n                stack.append(char)\n            elif char == '(':\n                stack.append(char)\n            else:\n                raise ValueError(\"Invalid expression\")\n        return count\n\n    def evaluate(expression: str, x: int) -> int:\n        stack = []\n        for char in expression:\n            if char == 'x':\n                stack.append(x)\n            elif char == '*':\n                stack.append(stack.pop() * x)\n            elif char == '(':\n                stack.append(char)\n            elif char in '+-':\n                a = stack.pop()\n                b = stack.pop()\n                if char == '+':\n                    stack.append(a + b)\n                else:\n                    stack.append(a - b)\n            else:\n                stack.append(int(char))\n        if len(stack) != 1:\n            raise ValueError(\"Invalid expression\")\n        return stack[0]\n\n    if not is_valid(A):\n        raise ValueError(\"Invalid expression\")\n    multiplications = count_multiplications(A)\n    if multiplications % 2 != 0:\n        raise ValueError(\"Invalid expression\")\n\n    left, right = divmod(M, 2)\n    for i in range(left + right):\n        x = i\n        value = evaluate(A, x)\n        if value % M == P:\n            return str(x)\n\n    raise ValueError(\"No solution found\")\n"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from math import floor, ceil\n\n    def is_valid_expression(expression: str) -> bool:\n        stack = []\n        for char in expression:\n            if char == '(':\n                stack.append(char)\n            elif char == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n            elif char in ('+', '-', '*'):\n                if not stack or stack[-1] == '(':\n                    stack.append(char)\n            elif char == 'x':\n                if not stack or stack[-1] != '*':\n                    return False\n            elif char.isdigit():\n                if not stack or stack[-1] != '*':\n                    return False\n        return not stack\n\n    def compute_remainder(a: int, m: int, p: int) -> int:\n        return a - p * floor(a / m)\n\n    def compute_x(a: int, m: int, p: int) -> int:\n        return ceil(a / m)\n\n    expression, P, M = stdin.splitlines()\n    P, M = int(P), int(M)\n\n    if not is_valid_expression(expression):\n        return \"Invalid expression\"\n\n    A = sum(int(char) * (10 ** i) for i, char in enumerate(reversed(expression)))\n    remainder = compute_remainder(A, M, P)\n\n    if remainder == 0:\n        return \"0\"\n\n    x = compute_x(A, M, P)\n\n    while remainder != 0 and x > 0:\n        x -= 1\n        remainder = compute_remainder(A, M, P)\n\n    if remainder == 0:\n        return str(x)\n    else:\n        return \"No solution\"\n"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n, t = map(int, input_list[:2])\n    time_list = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n    time_list.sort(key=lambda x: x[0])\n\n    for i in range(n-1):\n        if time_list[i][1] > time_list[i+1][0] + t:\n            return \"no\"\n    return \"yes\"\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list.pop(0).split())\n    for i in range(n):\n        a, b = map(int, input_list.pop(0).split())\n        if a + t > b:\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list.pop(0).split())\n    \n    for i in range(n):\n        a, b = map(int, input_list.pop(0).split())\n        if a + t > b:\n            return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, t = map(int, input_list[0].split())\n    time_list = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n    earliest_time = min(start for start, end in time_list)\n    latest_time = max(end for start, end in time_list)\n\n    if earliest_time + t <= latest_time:\n        return \"yes\"\n    else:\n        return \"no\"\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, t = map(int, inputs[0].split())\n    available_times = [map(int, inputs[i].split()) for i in range(1, n+1)]\n\n    for start, end in available_times:\n        if start + t > end:\n            return 'no'\n    return 'yes'\n"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    input_list = input_list[1:]\n\n    for i in range(n):\n        a, b = map(int, input_list[i].split())\n        if a + t > b:\n            return \"no\"\n\n    return \"yes\""
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list.pop(0).split())\n    time_periods = [tuple(map(int, input_line.split())) for input_line in input_list]\n\n    time_periods.sort(key=lambda x: x[1] - x[0])\n    current_time = 0\n\n    for a, b in time_periods:\n        if current_time >= a:\n            return \"no\"\n        current_time = max(current_time, a) + t\n        if current_time > b:\n            return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    features = []\n    for i in range(1, n+1):\n        a, b = map(int, input_list[i].split())\n        features.append((a, b))\n    \n    features.sort(key=lambda x: x[0])\n    \n    max_time = features[0][1]\n    for i in range(1, n):\n        if max_time + t <= features[i][0]:\n            return \"no\"\n        max_time = max(max_time, features[i][1])\n    \n    if max_time + t <= 10**9:\n        return \"yes\"\n    else:\n        return \"no\"\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(start: int, end: int, time_limit: int) -> bool:\n        return end - start >= time_limit\n\n    n, t = map(int, stdin.split()[:2])\n    time_periods = [tuple(map(int, input().split())) for _ in range(n)]\n    for start, end in time_periods:\n        if not is_possible(start, end, t):\n            return \"no\"\n    return \"yes\"\n\n\ndef"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(n: int, t: int, times: list) -> bool:\n        # sort the times by their start time\n        times.sort(key=lambda x: x[0])\n        # initialize the end time of the last photograph to 0\n        end_time = 0\n        for a, b in times:\n            # check if there is enough time left for the next photograph\n            if a - end_time < t:\n                return False\n            # update the end time of the last photograph\n            end_time = max(end_time, b)\n        return True\n\n    n, t = map(int, stdin.split()[:2])\n    times = [tuple(map(int, input().split())) for _ in range(n)]\n    return \"yes\" if is_possible(n, t, times) else \"no\"\n"
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, input().split())\n    n = int(input())\n    observations = []\n    for _ in range(n):\n        observation = input().split()\n        t = int(observation[0])\n        c = observation[1]\n        observations.append((t, c))\n    t_q, c_q = map(int, input().split())\n\n    def count_possible_ts(t_q):\n        count = 0\n        t_g, T_g = 0, 0\n        t_y, T_y = 0, 0\n        t_r, T_r = 0, 0\n        for t, c in observations:\n            if c == \"green\":\n                t_g = t\n                T_g = T_g_prev\n                T_g_prev = T_g\n            elif c == \"yellow\":\n                t_y = t\n                T_y = T_y_prev\n                T_y_prev = T_y\n            else:\n                t_r = t\n                T_r = T_r_prev\n                T_r_prev = T_r\n            if t_q >= t_g and t_q < t_g + T_g:\n                count += 1\n            elif t_q >= t_y and t_q < t_y + T_y:\n                count += 1\n            elif t_q >= t_r and t_q < t_r + T_r:\n                count += 1\n        return count\n\n    total_count = count_possible_ts(t_q)\n    green_count = count_possible_ts(t_q + T_g)\n    yellow_count = count_possible_ts(t_q + T_g + T_y)\n    red_count = count_possible_ts(t_q + T_g + T_y + T_r)\n    if c_q == \"green\":\n        return str(green_count / total_count)\n    elif c_q == \"yellow\":\n        return str(yellow_count / total_count)\n    else:\n        return str(red_count / total_count)\n\ninput_string = \"\"\"4 4 4\n3\n2 green\n18 yellow\n34 red\n5 green\"\"\"\n\noutput_string = \"\"\"0.25\"\"\"\n\nassert(solution(input_string) == output_string)\n\ninput_string = \"\"\"4 4 4\n4\n2 green\n6 yellow\n10 red\n14 green\n4 red\"\"\"\n\noutput_string = \"\"\"0\"\"\"\n\nassert(solution(input_string) == output_string)\n\ninput_string = \"\"\"10000 10000 10000\n300\n2 green\n18 yellow\n34 red\n5 green\n20000 10000\n30000 10000\n35000 10000\n40000 10000\n45000 10000\n50000 10000\n55000 10000\n60000 10000\n65000 10000\n70000 10000\n75000 10000\n80000 10000\n85000 10000\n90000 10000\n95000 10000\n100000 10000\n105000 10000\n110000 10000\n115000 10000\n120000 10000\n125000 10000\n130000 10000\n135000 10000\n140000 10000\n145000 10000\n150000 10000\n155000 10000\n1600"
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, input().split())\n    n = int(input())\n    times = []\n    colors = []\n    for _ in range(n):\n        time, color = input().split()\n        times.append(int(time))\n        colors.append(color)\n    t_q, c_q = input().split()\n    t_q, c_q = int(t_q), c_q\n\n    if c_q == 'green':\n        start_time = times[0]\n        end_time = times[0] + T_g\n        probability = 0\n        for i in range(n):\n            if colors[i] == 'red':\n                break\n            if times[i] >= start_time and times[i] < end_time:\n                probability += 1 / n\n            if colors[i] == 'yellow':\n                start_time = times[i] + T_g + T_y\n                end_time = start_time + T_g\n        return f\"{probability:.3f}\"\n    elif c_q == 'yellow':\n        start_time = times[0]\n        end_time = times[0] + T_g\n        probability = 0\n        for i in range(n):\n            if colors[i] == 'red':\n                break\n            if times[i] >= start_time and times[i] < end_time:\n                probability += 1 / n\n            if colors[i] == 'green':\n                start_time = times[i] + T_g + T_y\n                end_time = start_time + T_g\n        return f\"{probability:.3f}\"\n    elif c_q == 'red':\n        start_time = times[0]\n        end_time = times[0] + T_g\n        probability = 0\n        for i in range(n):\n            if colors[i] == 'green':\n                break\n            if times[i] >= start_time and times[i] < end_time:\n                probability += 1 / n\n            if colors[i] == 'yellow':\n                start_time = times[i] + T_g + T_y\n                end_time = start_time + T_g\n        return f\"{probability:.3f}\""
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    T_g, T_y, T_r = map(int, input_list[0].split())\n    n = int(input_list[1])\n    observations = [(int(i), c) for i, c in [line.split() for line in input_list[2:n+2]]]\n    t_q, c_q = map(int, input_list[-1].split())\n\n    possible_t = [T_g, T_g + T_y, T_g + T_y + T_r]\n    total_time = possible_t[2] - possible_t[0]\n    probabilities = [0, 0, 0]\n\n    for t, c in observations:\n        if c == 'green':\n            probabilities[0] += (t - possible_t[0]) / total_time\n        elif c == 'yellow':\n            probabilities[1] += (t - possible_t[1]) / total_time\n        elif c == 'red':\n            probabilities[2] += (t - possible_t[2]) / total_time\n\n    if c_q == 'green':\n        p = probabilities[0]\n    elif c_q == 'yellow':\n        p = probabilities[1]\n    else:\n        p = probabilities[2]\n\n    return f\"{p:.6f}\"\n"
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(T: int, t: int, color: str) -> bool:\n        if color == \"green\":\n            return T <= t <= T + T_g\n        elif color == \"yellow\":\n            return T + T_g <= t <= T + T_g + T_y\n        else:\n            return T + T_g + T_y <= t <= T + T_g + T_y + T_r\n\n    T_g, T_y, T_r = map(int, input().split())\n    n = int(input())\n    observations = [(int(input()), input()) for _ in range(n)]\n    t_q, c_q = map(int, input().split())\n\n    possible_Ts = []\n    for T in range(t_q - 10**9, t_q + 10**9, T_g + T_y + T_r):\n        if all(is_possible(T, t, c) for t, c in observations):\n            possible_Ts.append(T)\n\n    if not possible_Ts:\n        return \"0\"\n\n    p = len(possible_Ts) / (t_q - (t_q % (T_g + T_y + T_r)))\n    return f\"{p:.3f}\""
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    T_g, T_y, T_r = map(int, input_data[0].split())\n    n = int(input_data[1])\n    observations = [(int(t), c) for t, c in zip(input_data[2:-1], input_data[3:])]\n    t_q, c_q = map(int, input_data[-1].split())\n\n    probabilities = []\n    for t, c in observations:\n        if c == \"green\":\n            probabilities.append((t, 1.0))\n            probabilities.append((t + T_g, 0.0))\n        elif c == \"yellow\":\n            probabilities.append((t, 0.0))\n            probabilities.append((t + T_g + T_y, 1.0))\n        else:\n            probabilities.append((t, 0.0))\n            probabilities.append((t + T_g + T_y + T_r, 1.0))\n\n    probabilities.sort(key=lambda x: x[0])\n\n    prob = 0.0\n    for i in range(len(probabilities) - 1):\n        t, p = probabilities[i]\n        if t <= t_q < probabilities[i + 1][0]:\n            prob += p\n\n    return f\"{prob:.3f}\"\n\ndef"
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    T_g, T_y, T_r = [int(x) for x in input_data[0].split()]\n    n = int(input_data[1])\n    lights = [tuple(map(int, line.split())) for line in input_data[2:n+2]]\n    t_q, c_q = map(int, input_data[n+2].split())\n\n    # initialize variables\n    T = 0\n    green_count = 0\n    yellow_count = 0\n    red_count = 0\n\n    # count the number of green, yellow, and red cycles that Sarah observed\n    for t, c in lights:\n        if c == 1:\n            green_count += 1\n        elif c == 2:\n            yellow_count += 1\n        elif c == 3:\n            red_count += 1\n\n    # compute the total number of possible cycles\n    total_cycles = (T_g + T_y + T_r) * green_count * yellow_count * red_count\n\n    # compute the probability of the lights being green at time t_q\n    if t_q % T_g == 0:\n        green_cycle = 1\n    else:\n        green_cycle = 0\n\n    if t_q % (T_g + T_y) == 0:\n        yellow_cycle = 1\n    else:\n        yellow_cycle = 0\n\n    if t_q % (T_g + T_y + T_r) == 0:\n        red_cycle = 1\n    else:\n        red_cycle = 0\n\n    if c_q == 1:\n        p = green_cycle / total_cycles\n    elif c_q == 2:\n        p = yellow_cycle / total_cycles\n    elif c_q == 3:\n        p = red_cycle / total_cycles\n    else:\n        p = 0\n\n    return f\"{p:.6f}\"\n"
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    T_g, T_y, T_r = map(int, input().split())\n    n = int(input())\n    observations = []\n    for i in range(n):\n        t, c = input().split()\n        observations.append((int(t), c))\n    t_q, c_q = input().split()\n    t_q, c_q = int(t_q), c_q\n\n    def calculate_probability(t_q, c_q):\n        green_count = 0\n        yellow_count = 0\n        red_count = 0\n        for t, c in observations:\n            if t < t_q:\n                if c == 'green':\n                    green_count += 1\n                elif c == 'yellow':\n                    yellow_count += 1\n                elif c == 'red':\n                    red_count += 1\n            elif t == t_q:\n                if c_q == 'green':\n                    green_count += 1\n                elif c_q == 'yellow':\n                    yellow_count += 1\n                elif c_q == 'red':\n                    red_count += 1\n                break\n            else:\n                break\n        total_count = green_count + yellow_count + red_count\n        if c_q == 'green':\n            return green_count / total_count\n        elif c_q == 'yellow':\n            return yellow_count / total_count\n        elif c_q == 'red':\n            return red_count / total_count\n\n    probability = calculate_probability(t_q, c_q)\n    return f\"{probability:.6f}\"\n\ninput_data = \"\"\"4 4 4\n3\n2 green\n18 yellow\n34 red\n5 green\n0 green\n4 red\n10 yellow\n15 green\n18 red\n2 green\n34 yellow\n5 red\n10 yellow\n15 green\n18 red\n2 green\n34 yellow\n5 red\n\"\"\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    T_g, T_y, T_r = map(int, input_list[0].split())\n    n = int(input_list[1])\n    observations = [(int(t), c) for t, c in (line.split() for line in input_list[2:n+2])]\n    t_q, c_q = map(int, input_list[-1].split())\n\n    possible_ts = []\n    current_t = 0\n    for t, c in observations:\n        if c == c_q:\n            possible_ts.append(current_t)\n        current_t = t\n    possible_ts.append(current_t)\n\n    # Calculate the probability of the lights being green at time t_q\n    if t_q < possible_ts[0] or t_q > possible_ts[-1]:\n        p = 0\n    else:\n        p = sum(t_q % T_g == 0 for T_g in (T_g, T_g + T_y, T_g + T_y + T_r)) / len(observations)\n\n    return f\"{p:.6f}\""
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    # Parse the input\n    T_g, T_y, T_r = map(int, stdin.split()[:3])\n    n = int(stdin.split()[3])\n    observations = []\n    for _ in range(n):\n        time, color = map(int, stdin.split()[4 + _ * 2: 5 + _ * 2])\n        observations.append((time, color))\n    t_q, c_q = map(int, stdin.split()[-2:])\n    \n    # Compute the probability\n    prob = 0\n    for time, color in observations:\n        if time == t_q:\n            if color == c_q:\n                prob += 1 / n\n            break\n    \n    return str(prob)"
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    T_g, T_y, T_r = map(int, input_list[0].split())\n    n = int(input_list[1])\n    lights = [(int(t), c) for t, c in [line.split() for line in input_list[2:n+2]]]\n    t_q, c_q = map(int, input_list[-1].split())\n\n    # Compute the probability of the lights being green at time t_q\n    if c_q == \"green\":\n        total_time = T_g + T_y + T_r\n        probability = (T_g + T_y * t_q // total_time + T_r * t_q * t_q // total_time) / total_time\n    # Compute the probability of the lights being yellow at time t_q\n    elif c_q == \"yellow\":\n        total_time = T_g + T_y + T_r\n        probability = (T_y + T_g * t_q // total_time + T_r * t_q * t_q // total_time) / total_time\n    # Compute the probability of the lights being red at time t_q\n    elif c_q == \"red\":\n        total_time = T_g + T_y + T_r\n        probability = (T_r + T_g * t_q // total_time + T_y * t_q * t_q // total_time) / total_time\n    else:\n        raise ValueError(\"Invalid color: must be green, yellow, or red\")\n\n    return str(probability)\n"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    road_map = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    visited = set()\n\n    def dfs(node, path):\n        if node == 2:\n            visited.add(tuple(path + [2]))\n            return\n\n        for road in filter(lambda r: r[0] == node, road_map):\n            dfs(road[1], path + [road[1]])\n\n    dfs(1, [1])\n\n    if len(visited) == float('inf'):\n        return \"inf\"\n    else:\n        return str(len(visited)).zfill(9)\n"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    adjacency_list = [[] for _ in range(N + 1)]\n\n    for road in roads:\n        adjacency_list[road[0]].append(road[1])\n        adjacency_list[road[1]].append(road[0])\n\n    def count_routes(town: int, visited: set[int]) -> int:\n        if town == 2:\n            return 1\n        if town in visited:\n            return 0\n        visited.add(town)\n        routes = 0\n        for next_town in adjacency_list[town]:\n            routes += count_routes(next_town, visited.copy())\n        return routes\n\n    if M >= 1000000:\n        return \"inf\"\n    else:\n        return str(count_routes(1, set())).zfill(9)"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    adj = [[] for _ in range(N+1)]\n    \n    for _ in range(M):\n        a, b = map(int, stdin.split()[2:4])\n        adj[a].append(b)\n        adj[b].append(a)\n        \n    # Count the number of routes\n    def count_routes(town: int, visited: list[int]) -> int:\n        if visited[town]:\n            return 0\n        visited[town] = True\n        \n        count = 0\n        for next_town in adj[town]:\n            if next_town == 2:\n                count += 1\n            else:\n                count += count_routes(next_town, visited)\n                \n        visited[town] = False\n        return count\n    \n    count = count_routes(1, [False] * (N+1))\n    \n    if count == float('inf'):\n        return \"inf\"\n    else:\n        return str(count)[-9:]"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    adj_list = [[] for _ in range(N + 1)]\n    for a, b in roads:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    # Use depth-first search to count the number of unique routes\n    visited = [False] * (N + 1)\n    count = 0\n\n    def dfs(node, prev_node):\n        nonlocal count\n        visited[node] = True\n        for neighbor in adj_list[node]:\n            if neighbor != prev_node:\n                dfs(neighbor, node)\n        count += 1\n        visited[node] = False\n\n    dfs(1, 0)\n    if count == 2**N - 1:\n        return \"inf\"\n    else:\n        return str(count)[-9:]"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_visited(visited: set, road: tuple) -> bool:\n        return road in visited or (road[1], road[0]) in visited\n\n    def dfs(start: int, visited: set, roads: list, result: int):\n        visited.add((start, 0))\n        for i in range(len(roads)):\n            if not is_visited(visited, (start, roads[i])):\n                dfs(roads[i], visited, roads, result)\n        visited.remove((start, 0))\n        return result + 1\n\n    N, M = map(int, stdin.split()[0:2])\n    roads = []\n    visited = set()\n    result = 0\n    for _ in range(M):\n        a, b = map(int, stdin.split()[2:4])\n        roads.append((a, b))\n    if not (1, 2) in roads:\n        return \"inf\"\n    result = dfs(1, visited, roads, result)\n    return str(result)[-9:]\n"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, input().split())) for _ in range(M)]\n\n    # Initialize the graph with edges between towns\n    graph = {i: [] for i in range(1, N + 1)}\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Use a depth-first search to count the number of distinct routes\n    def dfs(town, visited):\n        visited.add(town)\n        if town == 2:\n            return 1\n        count = 0\n        for n in graph[town]:\n            if n not in visited:\n                count += dfs(n, visited.copy())\n        return count\n\n    if N == 2:\n        return \"2\"\n    elif N == 3:\n        return \"3\"\n    else:\n        count = dfs(1, set())\n        if count == 0:\n            return \"0\"\n        elif count == 1:\n            return \"1\"\n        elif count == 2:\n            return \"3\"\n        elif count == 3:\n            return \"5\"\n        else:\n            return \"inf\"\n"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n\n    def find_routes(town, visited, routes):\n        visited.add(town)\n        if town == 2:\n            routes.append(visited.copy())\n        else:\n            for neighbor in [road[1] for road in roads if road[0] == town]:\n                if neighbor not in visited:\n                    find_routes(neighbor, visited.copy(), routes)\n        visited.remove(town)\n\n    routes = []\n    find_routes(1, set(), routes)\n\n    if not routes:\n        return \"inf\"\n    else:\n        return str(len(routes))[-9:]\n"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if M == 0:\n        return \"1\"\n\n    adjacency_list = {}\n    for _ in range(M):\n        u, v = map(int, stdin.split())\n        if u not in adjacency_list:\n            adjacency_list[u] = [v]\n        else:\n            adjacency_list[u].append(v)\n\n    def dfs(u, visited, route, routes):\n        visited[u] = True\n        route.append(u)\n\n        if u == 2:\n            routes.append(route.copy())\n\n        for v in adjacency_list.get(u, []):\n            if not visited[v]:\n                dfs(v, visited, route, routes)\n\n        route.pop()\n        visited[u] = False\n\n    routes = []\n    dfs(1, [False] * (N + 1), [], routes)\n\n    if len(routes) == 0:\n        return \"1\"\n    else:\n        return str(len(routes))"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = {}\n    \n    for i in range(M):\n        u, v = map(int, stdin.split()[2+i:4+i])\n        if u not in roads:\n            roads[u] = set()\n        if v not in roads:\n            roads[v] = set()\n        roads[u].add(v)\n        roads[v].add(u)\n    \n    if N == 2:\n        return \"1\" if 1 in roads and 2 in roads else \"0\"\n    \n    q = [(1, set(), 1)]\n    seen = set()\n    \n    while q:\n        u, used, count = q.pop(0)\n        if u == 2:\n            seen.add(tuple(sorted(used)))\n            count += 1\n        \n        for v in roads[u] - used:\n            q.append((v, used | {u}, count))\n    \n    if not seen:\n        return \"0\"\n    else:\n        result = len(seen)\n        if result > 10**9:\n            return str(result)[-9:]\n        else:\n            return str(result)"
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    adj_list = [set() for _ in range(N + 1)]\n\n    for _ in range(M):\n        a, b = map(int, stdin.split())\n        adj_list[a].add(b)\n        adj_list[b].add(a)\n\n    def count_routes(visited, start, end):\n        if start == end:\n            return 1\n\n        if visited[start]:\n            return 0\n\n        visited[start] = True\n\n        routes = 0\n        for neighbor in adj_list[start]:\n            routes += count_routes(visited, neighbor, end)\n\n        visited[start] = False\n        return routes\n\n    routes = count_routes([False] * N, 1, 2)\n\n    if routes == float('inf'):\n        return \"inf\"\n    else:\n        return str(routes)[-9:]"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    preferences = list(map(int, stdin.split()[2:]))\n    preferences.sort(reverse=True)\n\n    count = 0\n    for i in range(n):\n        if count >= k:\n            break\n        for j in range(i, n):\n            if preferences[i] == preferences[j]:\n                count += 1\n                if count > k:\n                    count -= 1\n                    break\n            else:\n                break\n\n    return str(count)"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split(\"\\n\")\n    n, k = map(int, input_str[0].split())\n    preferences = list(map(int, input_str[1].split()))\n\n    # Create a graph to store the preferences\n    graph = [[] for _ in range(n + 1)]\n    for i in range(n):\n        graph[preferences[i]].append(i + 1)\n\n    # Perform a topological sort to find the maximum number of participants\n    visited = [False] * (n + 1)\n    stack = []\n\n    def dfs(node: int):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n        stack.append(node)\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i)\n\n    # The maximum number of participants is the number of nodes in the topological sort\n    return len(stack)"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k = map(int, input_list[0].split())\n    preferences = list(map(int, input_list[1].split()))\n\n    participant_count = 0\n    for i in range(1, n+1):\n        if preferences.count(i) <= k:\n            participant_count += 1\n\n    return str(participant_count)"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    preferences = list(map(int, input_list[1].split()))\n\n    max_participants = 0\n    visited = set()\n\n    def dfs(visited: set, index: int, count: int) -> int:\n        if index == n:\n            nonlocal max_participants\n            max_participants = max(max_participants, count)\n            return\n\n        if index not in visited and count + 1 <= k:\n            visited.add(index)\n            dfs(visited, preferences[index], count + 1)\n            visited.remove(index)\n\n        dfs(visited, index + 1, count)\n\n    dfs(visited, 0, 0)\n\n    return str(max_participants)\n"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    preferences = list(map(int, input_list[1].split()))\n\n    # Initialize a dictionary to store the number of people who want to join with each person\n    participation = {}\n    for i in range(1, n + 1):\n        participation[i] = 0\n\n    # Count the number of people who want to join with each person\n    for preference in preferences:\n        if preference != 0:\n            participation[preference] += 1\n\n    # Sort the dictionary by value (number of people who want to join) in descending order\n    sorted_participation = sorted(participation.items(), key=lambda x: x[1], reverse=True)\n\n    # Initialize the maximum number of participants\n    max_participants = 0\n\n    # Traverse the sorted dictionary and add the people who want to join with the maximum number of people\n    for person, preference in sorted_participation:\n        if preference < k:\n            max_participants += preference\n        else:\n            max_participants += k\n            break\n\n    return str(max_participants)\n"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    preferences = list(map(int, input().split()))\n    \n    # create a list of unique preferences\n    unique_preferences = list(set(preferences))\n    \n    # sort the unique preferences in ascending order\n    unique_preferences.sort()\n    \n    # initialize a counter for the number of participants\n    count = 0\n    \n    # iterate through the unique preferences\n    for i in unique_preferences:\n        # if the number of participants is less than or equal to the capacity of the bus, add the count of participants with preference equal to i\n        if count + preferences.count(i) <= k:\n            count += preferences.count(i)\n        # otherwise, break the loop\n        else:\n            break\n    \n    return count"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    preferences = list(map(int, stdin.split()[2:]))\n\n    # Count the number of participants who want to join with someone with a specific index.\n    preferences_count = [0] * n\n    for p in preferences:\n        if p != n:\n            preferences_count[p - 1] += 1\n\n    # Iterate through the participants, and add them to the list until the bus capacity is reached.\n    max_participants = 0\n    for i, count in enumerate(preferences_count):\n        if count > 0:\n            max_participants += 1\n            k -= 1\n        if k == 0:\n            break\n\n    return str(max_participants)"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    n, k = map(int, inputs[0].split())\n    preferences = list(map(int, inputs[1].split()))\n\n    preferences_count = [0] * n\n    for i in range(n):\n        preferences_count[preferences[i] - 1] += 1\n\n    count = 0\n    for i in range(n):\n        if preferences_count[i] == 0:\n            count += 1\n        if count == k:\n            break\n\n    return count\n\ndef"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    preferences = list(map(int, stdin.split()[2:]))\n\n    # Initialize a dictionary to store the participants with their preferences\n    preferences_dict = {}\n    for i in range(1, n + 1):\n        preferences_dict[i] = preferences[i - 1]\n\n    # Initialize a list to store the participants who have already been assigned a place\n    assigned = [False] * (n + 1)\n\n    # Initialize a list to store the participants who have not yet been assigned a place\n    unassigned = [True] * (n + 1)\n\n    # Initialize a variable to store the maximum number of participants that can join\n    max_participants = 0\n\n    # Iterate through all the participants\n    for i in range(1, n + 1):\n        # If the current participant has already been assigned a place, skip them\n        if assigned[i]:\n            continue\n\n        # Initialize a variable to store the number of participants who have not yet been assigned a place\n        unassigned_count = sum(unassigned)\n\n        # If the number of unassigned participants is greater than the capacity of the bus, break the loop\n        if unassigned_count > k:\n            break\n\n        # Add the current participant to the list of assigned participants\n        assigned[i] = True\n        unassigned[i] = False\n        max_participants += 1\n\n        # Iterate through the participants who have not yet been assigned a place\n        for j in range(1, n + 1):\n            # If the current participant is already assigned a place, skip them\n            if assigned[j]:\n                continue\n\n            # If the current participant has a preference for the current participant, add them to the list of assigned participants\n            if preferences_dict[j] == i:\n                assigned[j] = True\n                unassigned[j] = False\n                max_participants += 1\n\n    return str(max_participants)"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str, k = stdin.splitlines()\n    n, k = map(int, input_str.split())\n    x = list(map(int, input_str.split()[1:]))\n\n    def dfs(cur: int, visited: set[int], res: int):\n        if visited == set(range(1, n+1)):\n            return max(res, n)\n        if cur in visited:\n            return res\n        visited.add(cur)\n        res = max(res, dfs(x[cur-1], visited, res) + 1)\n        return res\n\n    return str(dfs(1, set(), 0))\n\ndef"
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input and split into lines\n    n, *words = stdin.split('\\n')\n    n = int(n)\n    \n    # Create dictionary\n    dictionary = set(words)\n    \n    # Find typos\n    typos = []\n    for word in dictionary:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                typos.append(word)\n                break\n                \n    # Output typos or NO TYPOS\n    return 'NO TYPOS' if not typos else '\\n'.join(typos)"
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                return True\n        return False\n\n    n, dictionary = stdin.split(\"\\n\", 1)\n    dictionary = set(dictionary.split(\"\\n\")[:int(n)])\n    typos = [word for word in dictionary if is_typo(word)]\n\n    if typos:\n        return \"\\n\".join(typos)\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str, dictionary: set) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                return True\n        return False\n\n    n = int(stdin.readline().strip())\n    dictionary = set()\n    for _ in range(n):\n        word = stdin.readline().strip()\n        dictionary.add(word)\n\n    typos = [word for word in dictionary if is_typo(word, dictionary)]\n\n    if typos:\n        return '\\n'.join(typos)\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    dictionary = set(stdin.split(\"\\n\")[1:])\n    typos = []\n    \n    for word in dictionary:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                typos.append(word)\n                break\n                \n    if typos:\n        return \"\\n\".join(typos)\n    else:\n        return \"NO TYPOS\"\n\ndef"
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str, dictionary: set) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                return True\n        return False\n\n    n = int(stdin.splitlines()[0])\n    dictionary = set(stdin.splitlines()[1:])\n    typos = [word for word in dictionary if is_typo(word, dictionary)]\n\n    if len(typos) == 0:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(typos)\n\n\ninput_str = \"\"\"5\nhoose\nhose\nnose\nnoises\nnoise\"\"\"\nprint(solution(input_str)) "
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    dictionary = set(input_list[1:])\n    typos = []\n\n    for word in dictionary:\n        for i in range(len(word)):\n            if word[:i] + word[i + 1:] in dictionary:\n                typos.append(word)\n                break\n\n    if len(typos) == 0:\n        return \"NO TYPOS\"\n    else:\n        return \"\\n\".join(typos)"
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    dictionary = set(stdin.splitlines()[1:])\n    \n    typos = set()\n    \n    for word in dictionary:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                typos.add(word)\n                break\n                \n    if typos:\n        return \"\\n\".join(typos)\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str, dictionary: set[str]) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                return True\n        return False\n\n    n = int(stdin[0])\n    words = set(stdin[1:].split('\\n'))\n    typos = [word for word in words if is_typo(word, words)]\n\n    if typos:\n        return '\\n'.join(typos)\n    else:\n        return \"NO TYPOS\"\n\ninput_1 = '''5\nhoose\nhose\nnose\nnoises\nnoise'''\n\ninput_2 = '''4\nhose\nhoose\noose\nmoose'''\n\nprint(solution(input_1))\nprint(solution(input_2))\n"
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_typo(word: str, dictionary: set) -> bool:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                return True\n        return False\n\n    n = int(stdin.split(\"\\n\")[0])\n    dictionary = set(stdin.split(\"\\n\")[1:])\n    typos = [word for word in dictionary if is_typo(word, dictionary)]\n\n    if typos:\n        return \"\\n\".join(typos)\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    words = set()\n    typos = set()\n\n    for i in range(n):\n        word = stdin.readline().strip()\n        words.add(word)\n\n        for j in range(len(word)):\n            typo = word[:j] + word[j+1:]\n            if typo in words:\n                typos.add(word)\n                break\n\n    return typos if typos else \"NO TYPOS\"\n\n\ndef"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    A, B = map(int, input_list[0].split())\n    L = int(input_list[1])\n    \n    # Number of insecure vaults\n    insecure = L * (A + 1 + B) - (A + 1) - (B + 1)\n    \n    # Number of secure vaults\n    secure = A * B\n    \n    # Number of super secure vaults\n    super_secure = (L * (A + 1 + B) - (A + 1) - (B + 1)) - secure\n    \n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    A, B = map(int, input_list[0].split())\n    L = int(input_list[1])\n\n    insecure = A * (A + 1 + B)\n    secure = L * (A + 1 + B) - insecure\n    super_secure = L * (A + 1 + B) - secure\n\n    return f\"{insecure}\\n{secure}\\n{super_secure}\"\n"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n\n    # Calculate the total number of vaults\n    total_vaults = L * (A + 1 + B)\n\n    # Calculate the number of insecure vaults\n    insecure_vaults = min(A, B) * (A + B - 2)\n\n    # Calculate the number of secure vaults\n    secure_vaults = (A + B - 2) * (A + B - 3)\n\n    # Calculate the number of super secure vaults\n    super_secure_vaults = (A + B - 2) * (A + B - 3)\n\n    return f\"{insecure_vaults}\\n{secure_vaults}\\n{super_secure_vaults}\"\n"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_secure_vaults(L, A, B):\n        insecure = 0\n        secure = 0\n        super_secure = 0\n        \n        for x in range(1, L+1):\n            for y in range(-A, B+1):\n                if (x != 0) and (y != -A) and (y != B):\n                    continue\n                elif (x, y) == (0, -A):\n                    if (x-1, y) != (0, -A):\n                        insecure += 1\n                    else:\n                        super_secure += 1\n                elif (x, y) == (0, B):\n                    if (x+1, y) != (0, B):\n                        insecure += 1\n                    else:\n                        super_secure += 1\n                else:\n                    if (x+1, y) != (0, -A) and (x-1, y) != (0, B):\n                        secure += 1\n        \n        return insecure, secure, super_secure\n\n    A, B = map(int, stdin.split())\n    L = int(input())\n    insecure, secure, super_secure = count_secure_vaults(L, A, B)\n    return f\"{insecure}\\n{secure}\\n{super_secure}\"\n"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = (L * (A + 1 + B) - (A + 1) * (A + 2) // 2) // 2\n    secure = L * (A + 1 + B) - insecure\n    super_secure = L * (A + 1 + B) - secure\n    return f\"{insecure}\\n{secure}\\n{super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure, secure, super_secure = 0, 0, 0\n\n    for i in range(1, L + 1):\n        for j in range(-A, B + 1):\n            if i == j == 0:\n                continue\n            if j == -A or j == B:\n                super_secure += 1\n            else:\n                if (i - 1, j - 1) in [(i - 1, j), (i, j - 1)]:\n                    secure += 1\n                else:\n                    insecure += 1\n\n    return str(insecure) + \"\\n\" + str(secure) + \"\\n\" + str(super_secure)\n"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    count_insecure = count_secure = count_super_secure = 0\n    for i in range(1, L+1):\n        for j in range(1, L+1):\n            vault_coords = (i, j)\n            guard_1 = (0, -A)\n            guard_2 = (0, B)\n            if guard_1[1] <= vault_coords[1] <= guard_2[1]:\n                count_insecure += 1\n                if guard_1[1] < vault_coords[1] < guard_2[1]:\n                    count_super_secure += 1\n                else:\n                    count_secure += 1\n    return f\"{count_insecure}\\n{count_secure}\\n{count_super_secure}\"\n"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, input().split())\n    guard_1_x, guard_1_y = 0, -A\n    guard_2_x, guard_2_y = 0, B\n\n    def count_secure_vaults(x, y):\n        count = 0\n        for i in range(1, L + 1):\n            for j in range(-A, B + 1):\n                if ((i, j) != (x, y) and (guard_1_x, guard_1_y) != (i, j) and (guard_2_x, guard_2_y) != (i, j)):\n                    count += 1\n        return count\n\n    insecure_vaults = count_secure_vaults(1, -A) + count_secure_vaults(L, B)\n    secure_vaults = (L - 1) * (A + 1 + B) - insecure_vaults\n    super_secure_vaults = count_secure_vaults(2, -A) + count_secure_vaults(L - 1, B)\n\n    return f\"{insecure_vaults}\\n{secure_vaults}\\n{super_secure_vaults}\"\n"
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    num_insecure = 0\n    num_secure = 0\n    num_super_secure = 0\n\n    for x in range(1, L+1):\n        for y in range(-A, B+1):\n            vault_is_secure = False\n            vault_is_super_secure = False\n\n            if (x, y-1) not in [(i, j) for i in range(1, L+1) for j in range(-A, B+1)]:\n                vault_is_secure = True\n\n            if (x, y+1) not in [(i, j) for i in range(1, L+1) for j in range(-A, B+1)]:\n                vault_is_super_secure = True\n\n            if not vault_is_secure and not vault_is_super_secure:\n                num_insecure += 1\n            elif vault_is_secure and not vault_is_super_secure:\n                num_secure += 1\n            elif not vault_is_secure and vault_is_super_secure:\n                num_super_secure += 1\n\n    return f\"{num_insecure}\\n{num_secure}\\n{num_super_secure}\""
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    \n    vaults = L * (A + 1 + B)\n    guards = A + B\n    \n    insecure = 0\n    secure = 0\n    super_secure = 0\n    \n    for i in range(1, L + 1):\n        for j in range(-A, B + 1):\n            count = 0\n            if i == 0 or j == 0 or i == L or j == -A or j == B:\n                count += 1\n            if i - 1 >= 1 and j + 1 <= B:\n                count += 1\n            if i + 1 <= L and j + 1 <= B:\n                count += 1\n            if i - 1 >= 1 and j - 1 >= -A:\n                count += 1\n            if i + 1 <= L and j - 1 >= -A:\n                count += 1\n            if count == 0:\n                insecure += 1\n            if count == 1:\n                secure += 1\n            if count == 2:\n                super_secure += 1\n    \n    return str(insecure) + '\\n' + str(secure) + '\\n' + str(super_secure)\n"
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    lights = []\n    \n    for i in range(n-1):\n        t, g, r = map(int, input().split())\n        lights.append((t, g, r))\n    \n    lights.sort()\n    \n    time = 0\n    for light in lights:\n        time += light[0] - time\n        time += max(0, light[1] - light[2] - time)\n    \n    time += n - 1\n    \n    return f\"{time:.9f}\""
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    data = [list(map(int, line.split())) for line in data]\n\n    def time_to_reach_light(i: int) -> float:\n        t, g, r = data[i]\n        if t <= r:\n            return (g + r) / 2 + t\n        else:\n            return g + t\n\n    if n == 1:\n        return \"0.0\"\n\n    time_at_start = 0\n    time_at_end = time_to_reach_light(n - 2)\n    min_time = time_at_end - time_at_start\n\n    for i in range(n - 2):\n        time_at_light_i = time_to_reach_light(i)\n        time_at_light_i_plus_one = time_to_reach_light(i + 1)\n        min_time = min(min_time, time_at_light_i_plus_one - time_at_light_i)\n\n    return f\"{min_time:.6f}\"\n\ninput1 = \"1\\n\"\noutput1 = \"44.72135955\\n\"\nprint(solution(input1))\nassert solution(input1) == output1\n\ninput2 = \"2\\n50 45 45\\n\"\noutput2 = \"68.52419365\\n\"\nprint(solution(input2))\nassert solution(input2) == output2 "
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> List[Tuple[int, int, int]]:\n        lines = input_str.split('\\n')[:-1]\n        return [tuple(map(int, line.split())) for line in lines]\n\n    def calculate_time(lights: List[Tuple[int, int, int]], i: int) -> float:\n        t, g, r = lights[i]\n        return t + g / 1000.0\n\n    def search_minimum_time(lights: List[Tuple[int, int, int]]) -> float:\n        min_time = float('inf')\n        for i in range(len(lights) - 1):\n            time_to_next_light = calculate_time(lights, i + 1)\n            time_to_end = time_to_next_light - (lights[i][0] + lights[i][1]) / 1000.0\n            min_time = min(min_time, time_to_end)\n        return min_time\n\n    input_str = stdin.strip()\n    lights = parse_input(input_str)\n    min_time = search_minimum_time(lights)\n    return f\"{min_time:.9f}\""
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(i: int, t: int) -> int:\n        return ((t - t_i) % g_i + r_i - (t - t_i) % r_i) * (i + 1)\n\n    def time(i: int) -> float:\n        return ((i + 1) / acceleration + start_time) * 1000\n\n    n = int(stdin)\n    start_time = 0\n    acceleration = 1\n    t_i = [int(stdin[i + 1].strip()) for i in range(n - 1)]\n    g_i = [int(stdin[i + 1].strip()) for i in range(n - 1, 2 * n - 2, 3)]\n    r_i = [int(stdin[i + 1].strip()) for i in range(n - 1, 2 * n - 3, 3)]\n\n    for i in range(n - 1):\n        if t_i[i] > r_i[i]:\n            start_time = time(i)\n            break\n\n    if start_time == 0:\n        start_time = time(0)\n        acceleration = 0\n\n    end_time = start_time + sum([distance(i, t) for i, t in enumerate(t_i)]) / 3.6\n\n    return round(end_time / 1000, 11)\n"
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> List[Tuple[int, int, int]]:\n        lines = input_str.split('\\n')\n        n = int(lines[0])\n        input_data = []\n        for line in lines[1:]:\n            t, g, r = map(int, line.split())\n            input_data.append((t, g, r))\n        return input_data\n\n    def calculate_time(lights: List[Tuple[int, int, int]], v: float) -> float:\n        total_time = 0\n        for t, g, r in lights:\n            total_time += (t - total_time) / v\n            total_time += g\n        return total_time\n\n    input_data = parse_input(stdin)\n    v = 1 / 10  # Acceleration\n    time = calculate_time(input_data, v)\n    return f\"{time:.6f}\"\n"
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    traffic_lights = []\n\n    for _ in range(n - 1):\n        t, g, r = map(int, input().split())\n        traffic_lights.append((t, g, r))\n\n    max_time = 0\n\n    for i in range(n - 1):\n        start_time = traffic_lights[i][0]\n        next_start_time = traffic_lights[i + 1][0]\n\n        max_time = max(max_time, next_start_time - start_time)\n\n    return f\"{max_time:.9f}\"\n\ninput_string = \"4\\n120 50 50\\n150 45 45\\n200 40 40\\n250 50 50\"\nprint(solution(input_string)) "
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def traffic_light(t, g, r):\n        return max(0, t - r)\n\n    def time_to_car(g, r):\n        return g / 10  # Assuming the car can accelerate at 10 m/s^2\n\n    def total_time(n, t, g, r):\n        return sum(time_to_car(traffic_light(t[i], g[i], r[i]), r[i]) for i in range(n - 1))\n\n    n, *data = stdin.split()\n    n = int(n)\n\n    t = [int(data[3 * i]) for i in range(n - 1)]\n    g = [int(data[3 * i + 1]) for i in range(n - 1)]\n    r = [int(data[3 * i + 2]) for i in range(n - 1)]\n\n    result = total_time(n, t, g, r)\n\n    return f\"{result:.9f}\"\n"
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    traffic_lights = [[int(x) for x in line.split()] for line in input_data[1:]]\n\n    def time_to_pass_light(light, start_time):\n        time_to_pass = light[0] - start_time\n        if time_to_pass > 0:\n            return time_to_pass\n        else:\n            return light[0] + (light[1] + light[2]) - start_time\n\n    def distance_to_next_light(light):\n        return light[0] - (light[1] + light[2])\n\n    def time_to_next_light(light, start_time):\n        return distance_to_next_light(light) / 1000\n\n    def time_to_reach_end(start_time):\n        total_distance = n * 1000\n        travel_time = 0\n        for light in traffic_lights:\n            travel_time += time_to_pass_light(light, start_time)\n            total_distance -= distance_to_next_light(light)\n            if total_distance <= 0:\n                break\n        return travel_time\n\n    start_time = 0\n    min_travel_time = float('inf')\n    while start_time < 40:\n        travel_time = time_to_reach_end(start_time)\n        if travel_time < min_travel_time:\n            min_travel_time = travel_time\n        start_time += 1\n\n    return round(min_travel_time, 9)"
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def dist(t: int, i: int, L: List[int]) -> float:\n        return L[i] + (t - L[i] - R[i]) / A[i]\n\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    L, R, A = [], [], []\n\n    for i in range(n - 1):\n        t, g, r = map(int, data[i].split())\n        L.append(t)\n        R.append(r)\n        A.append(1)\n\n    L.append(float('inf'))\n    R.append(0)\n    A.append(0)\n\n    dp = [0] * n\n    for i in range(1, n):\n        dp[i] = min(dp[j] + dist(L[i], j, L) for j in range(i - 1, -1, -1) if L[i] - L[j] > R[j])\n\n    return round(dp[-1], 9)\n\n\ninput1 = \"1\\n\"\ninput2 = \"2\\n50 45 45\"\n\nprint(solution(input1))\nprint(solution(input2)) "
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lights = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n\n    def distance(light):\n        return light[0] + light[1] + light[2] - 1\n\n    def time_to_pass(light):\n        return light[0]\n\n    def acceleration_time(distance):\n        return distance / 1\n\n    total_distance = n * distance(lights[-1])\n    time = 0\n\n    for i, light in enumerate(lights):\n        distance_to_light = distance(light)\n        time_to_light = time_to_pass(light)\n\n        distance_to_next_light = distance(lights[i+1]) if i+1 < n else 0\n\n        acceleration_distance = (distance_to_next_light - distance_to_light) / 2 if i+1 < n else 0\n\n        time_to_accelerate = acceleration_time(acceleration_distance)\n\n        time_to_reach_light = time_to_light + time_to_accelerate\n\n        time += time_to_reach_light\n\n    return f'{time:.10f}'\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n    q = 2**N - 1\n    \n    def s(i, j):\n        return a[:i] + a[j:]\n    \n    s_q = sorted(s(i, j) for i in range(N) for j in range(i+1, N))\n    \n    h = lambda s: (sum(a[i] * (B ** (len(a) - 1 - i)) for i in range(len(a))) % M)\n    \n    result = [h(s_q[i]) * h(s_q[i+1]) % M for i in range(0, q-1, 2)]\n    \n    return '\\n'.join(map(str, result[:K]))\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_hash(arr: list, B: int, M: int) -> int:\n        hash_value = 0\n        for i in range(len(arr)):\n            hash_value = (hash_value * B + arr[i]) % M\n        return hash_value\n\n    def generate_subsequences(arr: list) -> list:\n        if len(arr) == 0:\n            return [[]]\n        subseq = generate_subsequences(arr[1:])\n        new_subseq = []\n        for seq in subseq:\n            new_subseq.append([arr[0]] + seq)\n            new_subseq.append(seq)\n        return new_subseq\n\n    N, K, B, M = map(int, stdin.readline().split())\n    arr = list(map(int, stdin.readline().split()))\n\n    subsequences = generate_subsequences(arr)\n    subsequences.sort(key=lambda x: x)\n\n    result = []\n    for i in range(K):\n        result.append(calculate_hash(subsequences[i], B, M))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def subsequence(a: list):\n        n = len(a)\n        p = 1\n        for i in range(n - 1):\n            p *= (n - i)\n        res = []\n        for i in range(n):\n            for j in range(p):\n                res.append(a[i:])\n        return res\n\n    def h(s: list, B: int, M: int) -> int:\n        p = len(s)\n        value = 0\n        for i in range(p):\n            value += s[i] * B**(p - i - 1)\n        return value % M\n\n    N, K, B, M = map(int, input().split())\n    a = list(map(int, input().split()))\n    sub = subsequence(a)\n    sub.sort()\n    result = [h(sub[i], B, M) for i in range(K)]\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from math import pow\n    N, K, B, M = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n\n    def generate_subsequences(arr):\n        if len(arr) == 0:\n            return []\n        if len(arr) == 1:\n            return [[arr[0]]]\n        subsequences = []\n        for i in range(len(arr)):\n            for subsequence in generate_subsequences(arr[:i] + arr[i+1:]):\n                subsequences.append([arr[i]] + subsequence)\n        return subsequences\n\n    def h(arr):\n        result = 0\n        for i, v in enumerate(arr):\n            result += v * pow(B, len(arr) - 1 - i)\n        return result % M\n\n    subsequences = generate_subsequences(a)\n    sorted_subsequences = sorted(subsequences)\n    hash_values = [h(subseq) for subseq in sorted_subsequences]\n\n    output = []\n    for i in range(K):\n        output.append(str(hash_values[i]))\n\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def generate_subsequences(arr: list) -> list:\n        def helper(start: int, end: int, subseq: list) -> None:\n            if start > end:\n                subsequences.append(subseq)\n                return\n            helper(start + 1, end, subseq)\n            helper(start + 1, end, subseq + [arr[start]])\n\n        subsequences = []\n        helper(0, len(arr) - 1, [])\n        return subsequences\n\n    def hash_function(subseq: list) -> int:\n        product = 1\n        for i in range(len(subseq)):\n            product *= B\n        return sum(subseq) * product % M\n\n    N, K, B, M = map(int, stdin.split()[:4])\n    arr = list(map(int, stdin.split()[4:]))\n\n    subsequences = generate_subsequences(arr)\n    subsequences.sort()\n\n    result = []\n    for i in range(K):\n        result.append(hash_function(subsequences[i]))\n\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def calc_hash(subsequence: List[int]) -> int:\n        total = 0\n        modulus = 1\n        for num in subsequence:\n            total += num * modulus\n            modulus *= B\n            modulus %= M\n        return total % M\n\n    N, K, B, M = map(int, stdin.split()[:4])\n    input_array = list(map(int, stdin.split()[4:]))\n    subsequences = sorted(list(set(permutations(input_array))))\n\n    result = []\n    for subsequence in subsequences:\n        hash_value = calc_hash(subsequence)\n        result.append(hash_value)\n\n    return \"\\n\".join(map(str, result[:K]))\n\n\ndef"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    N, K, B, M = input_data[:4]\n    A = input_data[4:]\n    p = 2 ** N\n    q = p - 1\n\n    def h(s):\n        result = 0\n        for i, v in enumerate(s):\n            result += v * B ** (N - i - 1)\n        return result % M\n\n    def subsets(arr):\n        if len(arr) == 0:\n            return [[]]\n        smaller_subsets = subsets(arr[1:])\n        return smaller_subsets + [[arr[0]] + s for s in smaller_subsets]\n\n    s = subsets(A)\n    s.sort(key=lambda x: (len(x), x))\n\n    hashes = [h(subset) for subset in s[:q]]\n    hashes.sort()\n\n    result = [hashes[i // 2] if i % 2 == 0 else 0 for i in range(K)]\n    return '\\n'.join(str(h) for h in result)"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, B, M, *a = map(int, stdin.split())\n    MOD = 10**9 + 7\n    a = sorted(set(a))\n    n = len(a)\n    s = []\n    for i in range(1, 2**n):\n        subseq = []\n        for j in range(n):\n            if i & (1 << j):\n                subseq.append(a[j])\n        s.append(subseq)\n    \n    h = lambda x: (x[0] * B**(len(x)-1) + sum(v * B**(len(x)-i-2) for i, v in enumerate(x[1:]))) % M\n    \n    hs = [h(subseq) for subseq in s if len(subseq) > 0]\n    hs.sort()\n    \n    result = []\n    for i in range(K):\n        result.append(hs[i])\n    \n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def hash(s, b, m):\n        h = 0\n        p = 1\n        for i in range(len(s) - 1, -1, -1):\n            h += s[i] * p\n            h %= m\n            p *= b\n            p %= m\n        return h\n\n    N, K, B, M = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n    s = sorted(set(a))\n    subsequences = []\n    for subsequence in itertools.product(*(s for _ in range(N))):\n        subsequences.append(list(subsequence))\n\n    result = [hash(sub, B, M) for sub in subsequences]\n    result = [result[i] * result[i + 1] for i in range(0, len(result), 2)]\n\n    return \"\\n\".join(map(str, result[:K]))\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, K, B, M = map(int, input_list[0].split())\n    input_list = input_list[1].split()\n    A = list(map(int, input_list))\n\n    def lexicographically_sorted_subsequences(A):\n        subsequences = []\n        for i in range(len(A) + 1):\n            for j in range(i + 1, len(A) + 1):\n                subsequences.append(A[i:j])\n        return sorted(subsequences)\n\n    def hash_subsequences(subsequences, B, M):\n        hash_values = []\n        for subsequence in subsequences:\n            hash_values.append(calculate_hash(subsequence, B, M))\n        return hash_values\n\n    def calculate_hash(subsequence, B, M):\n        hash_value = 0\n        for value in subsequence:\n            hash_value = (hash_value * B + value) % M\n        return hash_value\n\n    subsequences = lexicographically_sorted_subsequences(A)\n    hash_values = hash_subsequences(subsequences, B, M)\n\n    return \" \".join(map(str, hash_values[:K]))\n\n\ndef"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    colors = list(map(int, input_list[1].split()))\n\n    max_color = max(colors)\n    max_count = 0\n\n    for i in range(1, n):\n        if colors[i] == colors[i - 1]:\n            max_count += 1\n        else:\n            max_count = 1\n        if max_count >= k - 1:\n            max_count = 0\n        else:\n            max_color = max(max_color, colors[i])\n\n    return max_color + 1\n\n\ninput_list = \"\"\"2 5\n1 1\n5 3\n2 2 3 2 2\"\"\".split(\"\\n\")\n\nfor stdin in input_list:\n    print(solution(stdin)) "
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.splitlines()[0].split())\n    marbles = list(map(int, stdin.splitlines()[1].split()))\n    \n    groups = [0] * 101\n    for marble in marbles:\n        groups[marble] += 1\n    \n    insert_count = 0\n    for i in range(1, 101):\n        if groups[i] >= K:\n            insert_count += 2\n        elif groups[i] > 0:\n            insert_count += 1\n    \n    return str(insert_count)\n\ndef"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, input().split())\n    marbles = list(map(int, input().split()))\n    count = 0\n    for i in range(1, N):\n        if marbles[i] == marbles[i-1]:\n            count += 1\n        else:\n            count = 0\n        if count >= K-1:\n            marbles.insert(i, marbles[i-1])\n            count = 0\n    return str(count+1)\n"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    marbles = list(map(int, input_list[1].split()))\n    \n    insert_count = 0\n    for i in range(N-K+1):\n        if len(set(marbles[i:i+K])) == 1:\n            insert_count += 1\n    \n    return str(insert_count)\n"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, K = map(int, input_data[0].split())\n    marbles = list(map(int, input_data[1].split()))\n\n    if N == 1:\n        return 1\n\n    count = 1\n    for i in range(1, N):\n        if marbles[i] != marbles[i - 1]:\n            count += 1\n\n    return count\n\n\ndef"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, K = map(int, input_data[0].split())\n    marble_colors = list(map(int, input_data[1].split()))\n\n    # Find the largest index of the same color\n    max_index = 0\n    current_color = marble_colors[0]\n    for i, color in enumerate(marble_colors):\n        if color == current_color:\n            max_index = i\n        else:\n            current_color = color\n\n    # Check if the last marble can be twinkled\n    if marble_colors[-1] == marble_colors[max_index]:\n        max_index = len(marble_colors) - 1\n\n    # Calculate the minimum number of marbles to insert\n    insert_count = 1\n    if max_index >= K - 1:\n        insert_count = 0\n    else:\n        for i in range(max_index + 1, len(marble_colors) - K + 2):\n            if marble_colors[i] == marble_colors[i - 1]:\n                insert_count += 1\n            else:\n                break\n\n    return str(insert_count)"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, K = map(int, input_list[0].split())\n    colors = input_list[1].split()\n    colors = list(map(int, colors))\n    count = 0\n    twinkle_count = 0\n    for i in range(len(colors)):\n        if i == 0:\n            if colors[i] == colors[i+1]:\n                count += 1\n                twinkle_count += 1\n        elif i == len(colors)-1:\n            if colors[i] == colors[i-1]:\n                count += 1\n                twinkle_count += 1\n        else:\n            if colors[i] == colors[i-1] and colors[i] == colors[i+1]:\n                count += 1\n                twinkle_count += 1\n            elif colors[i] == colors[i-1] or colors[i] == colors[i+1]:\n                count += 1\n            else:\n                continue\n            if twinkle_count >= K-1:\n                break\n        if twinkle_count >= K:\n            twinkle_count = 0\n    if twinkle_count < K-1:\n        count += 1\n    return count"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    N, K = map(int, stdin.split()[0:2])\n    marbles = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    insertions = 0\n    current_color = marbles[0]\n    max_consecutive = 0\n    max_color = marbles[0]\n\n    # Iterate through the marbles\n    for marble in marbles:\n        # Update current color and consecutive counter\n        if marble == current_color:\n            max_consecutive += 1\n        else:\n            current_color = marble\n            max_consecutive = 1\n\n        # Update max consecutive and max color\n        if max_consecutive >= K:\n            insertions += 1\n            if max_color == marble:\n                insertions += 1\n            max_consecutive = 1\n        else:\n            max_color = marble\n\n    # Insert a marble at the end to make all marbles vanish\n    insertions += 1\n\n    # Return the minimum number of insertions\n    return str(insertions)\n"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, K = map(int, input_data[0].split())\n    marbles = list(map(int, input_data[1].split()))\n\n    inserted_marbles = 0\n    for i in range(N - 1, -1, -1):\n        if marbles[i] == marbles[i + 1]:\n            inserted_marbles += 1\n            if inserted_marbles >= K:\n                return inserted_marbles + 1\n        else:\n            inserted_marbles = 0\n\n    return inserted_marbles + 1\n"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, K = map(int, input_data[0].split())\n    marbles = list(map(int, input_data[1].split()))\n\n    current_color = marbles[0]\n    count = 1\n    insertions = 0\n\n    for i in range(1, N):\n        if marbles[i] == current_color:\n            count += 1\n        else:\n            current_color = marbles[i]\n            count = 1\n\n        if count >= K:\n            insertions += 1\n\n    return insertions + 1\n\n\ndef"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    probabilities = [list(map(int, input_data[i+1].split())) for i in range(n)]\n    max_probability = 0\n    \n    for assignments in itertools.permutations(range(n)):\n        current_probability = 1\n        for i in range(n):\n            current_probability *= probabilities[assignments[i]][assignments.index(i)]\n        max_probability = max(max_probability, current_probability)\n    \n    return f'{max_probability:.6f}%'"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_probability(mission_probabilities: list) -> float:\n        return 1.0 * reduce(lambda x, y: x * y, mission_probabilities)\n\n    def calculate_maximum_probability(probabilities: list, n: int) -> float:\n        max_probability = 0.0\n        for permutation in itertools.permutations(probabilities, n):\n            max_probability = max(max_probability, calculate_probability(permutation))\n        return max_probability\n\n    N, *data = map(int, stdin.split())\n    probabilities = [data[i:i + N] for i in range(0, len(data), N)]\n\n    result = [calculate_maximum_probability(probabilities[i], N) for i in range(N)]\n    return round(100 * max(result), 6)\n\n\ndef"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    probability_matrix = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(1, len(input_list)):\n        row = input_list[i].split()\n        for j in range(N):\n            probability_matrix[i-1][j] = float(row[j]) / 100\n\n    max_probability = 0\n    for permutation in itertools.permutations(range(N)):\n        probability = 1\n        for i in range(N):\n            j = permutation[i]\n            probability *= probability_matrix[i][j]\n        max_probability = max(max_probability, probability)\n\n    return f\"{max_probability:.6f}\"\n\n\ndef"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    data = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n    max_prob = 1.0\n\n    for i in range(N):\n        row_sum = 0\n        for j in range(N):\n            row_sum += data[j][i]\n        max_prob *= row_sum / 100\n\n    return round(max_prob * 100, 6)\n\ndef"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n    \n    probabilities = [[0.0]*N for _ in range(N)]\n    \n    for i in range(N):\n        for j in range(N):\n            probabilities[i][j] = float(data[i].split()[j]) / 100\n    \n    max_prob = 1.0\n    for permutation in itertools.permutations(range(N)):\n        cur_prob = 1.0\n        for i in range(N):\n            j = permutation[i]\n            cur_prob *= probabilities[i][j]\n        max_prob = max(max_prob, cur_prob)\n    \n    return round(max_prob * 100)\n\n\ninput_data = \"\"\"\n2\n100 100\n50 50\n\"\"\"\n\nprint(solution(input_data))\n\n\ninput_data = \"\"\"\n2\n0 50\n50 0\n\"\"\"\n\nprint(solution(input_data))\n\n\ninput_data = \"\"\"\n3\n100 100 100\n50 50 50\n100 100 0\n\"\"\"\n\nprint(solution(input_data))\n\n\ninput_data = \"\"\"\n2\n50 10\n10 50\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, List[List[int]]]:\n        N = int(input())\n        probabilities = []\n        for _ in range(N):\n            line = input().split()\n            probabilities.append([int(p) for p in line])\n        return N, probabilities\n\n    def write_output(result: float) -> None:\n        print(f\"{result:.6f}\")\n\n    def calculate_probability(probabilities: List[List[int]]) -> float:\n        product = 1\n        for i in range(N):\n            for j in range(N):\n                if i != j:\n                    product *= probabilities[j][i]\n        return product\n\n    N, probabilities = read_input()\n    write_output(calculate_probability(probabilities))\n"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    input_list = input_list[1:]\n    probabilities = []\n    for i in range(N):\n        probabilities.append([int(j)/100 for j in input_list[i].split()])\n    dp = [[0.0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        dp[i][i] = 1.0\n        for j in range(i+1, N):\n            dp[i][j] = max(dp[i][k] * probabilities[k][j] for k in range(i, j)) * probabilities[i][j]\n    result = 1.0\n    for i in range(N):\n        result *= dp[0][i]\n    return round(result*100)"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    probabilities = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        probabilities[i] = list(map(int, stdin.split('\\n')[i+1].split()))\n\n    dp = [[0 for _ in range(N)] for _ in range(N+1)]\n    for length in range(1, N+1):\n        for i in range(N-length+1):\n            j = i+length-1\n            for k in range(i, j+1):\n                if k == i:\n                    dp[length][k] = probabilities[k][j]\n                else:\n                    dp[length][k] += dp[length-1][k] * probabilities[k][j] / N\n            if dp[length][k] > 1:\n                dp[length][k] = 1\n\n    answer = max([dp[N][i] for i in range(N)])\n    return f\"{int(answer*100)}\"\n"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    prob_matrix = []\n    for i in range(1, N+1):\n        prob_list = list(map(int, input_list[i].split()))\n        prob_matrix.append(prob_list)\n\n    max_prob = 1\n    for i in range(N):\n        for j in range(N):\n            if i == j:\n                max_prob *= 1\n            else:\n                max_prob *= prob_matrix[i][j]\n\n    return round(max_prob, 6)\n"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    probabilities = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(1, N + 1):\n        row = list(map(int, input_list[i].split()))\n        for j in range(N):\n            probabilities[i - 1][j] = row[j]\n\n    max_prob = 0\n    for p in itertools.permutations(probabilities):\n        probability = 1\n        for i in range(N):\n            probability *= p[i][i]\n        max_prob = max(max_prob, probability)\n\n    return '{:.6f}'.format(max_prob)\n\n\ninput_list = [\n    \"2\",\n    \"100 100\",\n    \"50 50\",\n    \"0 50\",\n    \"50 0\",\n]\n\noutput_list = [\n    \"50.000000\",\n    \"25.000000\",\n]\n\nfor i in range(len(input_list)):\n    input_str = '\\n'.join(input_list[i].split())\n    output = solution(input_str)\n    assert round(float(output), 6) == round(float(output_list[i]), 6), f\"Input: {input_str}, Output: {output}, Expected: {output_list[i]}\" "
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    T = [int(t) for t in input_list[1:]]\n    \n    T.sort()\n    total_time = 0\n    for i in range(N):\n        if i == 0:\n            total_time += T[i] + 20\n        else:\n            total_time += max(T[i] - total_time - 60, 0) * 60\n            total_time += T[i] + 20\n    \n    return str(total_time)\n\n\ninput_list = [\n    \"2\",\n    \"100\",\n    \"200\",\n]\nstdin = '\\n'.join(input_list)\nprint(solution(stdin)) "
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    arrival_times = list(map(int, input_data[1:]))\n    arrival_times.sort()\n    \n    total_time = 0\n    for i in range(N):\n        # Raise the bridge\n        total_time += 60\n        \n        # Calculate time until next boat\n        next_arrival = arrival_times[i]\n        time_until_next_arrival = next_arrival - total_time\n        \n        # Wait if necessary\n        if time_until_next_arrival > 0:\n            total_time += time_until_next_arrival\n        \n        # Sail the boat\n        total_time += 20\n        \n        # Lower the bridge\n        total_time += 60\n    \n    return str(total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    num_boats = int(input_data[0])\n    arrival_times = [int(t) for t in input_data[1:]]\n\n    arrival_times.sort()\n\n    bridge_open = False\n    current_time = 0\n    total_time = 0\n\n    while arrival_times:\n        next_arrival = arrival_times.pop(0)\n\n        if next_arrival - current_time >= 30:\n            if not bridge_open:\n                total_time += 60\n                bridge_open = True\n            total_time += next_arrival - current_time - 20\n            current_time = next_arrival + 20\n            bridge_open = False\n        else:\n            if bridge_open:\n                total_time += 60\n                bridge_open = False\n            total_time += next_arrival - current_time + 20\n            current_time = next_arrival + 20\n\n    if not bridge_open:\n        total_time += 60\n\n    return str(total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_closest_arrival_time(arrival_times: list, time: int) -> int:\n        closest_arrival_time = arrival_times[0]\n        for arrival_time in arrival_times:\n            if arrival_time > time and arrival_time < closest_arrival_time:\n                closest_arrival_time = arrival_time\n        return closest_arrival_time\n\n    def get_bridge_operation_time(arrival_time: int, next_arrival_time: int) -> int:\n        if arrival_time + 60 < next_arrival_time:\n            return 60\n        else:\n            return next_arrival_time - arrival_time\n\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    arrival_times = sorted([int(input_list[i]) for i in range(1, N + 1)])\n    total_operation_time = 0\n\n    for i in range(N):\n        closest_arrival_time = find_closest_arrival_time(arrival_times, arrival_times[i] + 20)\n        next_arrival_time = find_closest_arrival_time(arrival_times, arrival_times[i] + 60)\n\n        bridge_operation_time = get_bridge_operation_time(arrival_times[i], closest_arrival_time)\n        total_operation_time += bridge_operation_time\n        arrival_times.remove(arrival_times[i])\n\n    return str(total_operation_time)\n"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    arrival_times = list(map(int, input_list[1:]))\n    arrival_times.sort()\n    total_time = 0\n    bridge_status = \"closed\"\n    for arrival_time in arrival_times:\n        if bridge_status == \"closed\":\n            bridge_status = \"opening\"\n            total_time += (arrival_time - total_time) * 2 + 60\n        else:\n            if bridge_status == \"opening\":\n                if arrival_time - total_time < 60:\n                    bridge_status = \"open\"\n                    total_time = arrival_time\n                else:\n                    bridge_status = \"opening\"\n            if bridge_status == \"open\":\n                boats_waiting = 1\n                total_time += 60\n                bridge_status = \"closing\"\n        if bridge_status == \"open\" and arrival_time - total_time < 30:\n            total_time += arrival_time - total_time\n    return total_time"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    T = [int(x) for x in input_data[1:N+1]]\n    T.sort()\n\n    bridge_time = 0\n    bridge_raised = False\n    waiting_boats = []\n    waiting_time = 0\n\n    for t in T:\n        if not bridge_raised:\n            bridge_raised = True\n            bridge_time += (t - bridge_time) * 2\n\n        if bridge_raised:\n            waiting_time += (t - bridge_time) * 2\n            bridge_time = t\n            bridge_raised = False\n            waiting_boats.append(t)\n\n        if waiting_time > 30 * 60:\n            bridge_raised = True\n            bridge_time += 60\n            waiting_boats = []\n            waiting_time = 0\n\n    bridge_time += 60\n\n    return str(bridge_time)\n\ndef"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    T = [int(x) for x in input_list[1:]]\n    T.sort()\n    bridge_available = True\n    time_bridge_unavailable = 0\n    for i in range(N):\n        if bridge_available:\n            time_bridge_unavailable += max(T[i] - 40, 0) * 60\n            bridge_available = False\n        time_bridge_unavailable += 40 * 60\n        if i < N-1 and T[i+1] - T[i] < 20:\n            continue\n        time_bridge_unavailable += (T[i+1] - T[i] - 20) * 20\n        time_bridge_unavailable += 20 * 20\n        bridge_available = True\n    return str(time_bridge_unavailable)"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    T = [int(x) for x in input_data[1:]]\n    T.sort()\n\n    total_time = 0\n    bridge_status = \"CLOSED\"\n    last_boat_time = -1\n    next_boat_time = T[0]\n    for t in T:\n        if bridge_status == \"CLOSED\":\n            bridge_status = \"OPENED\"\n            total_time += (t - last_boat_time - 60)\n            last_boat_time = t\n            next_boat_time = t + 20\n        else:\n            while t >= next_boat_time:\n                bridge_status = \"CLOSED\"\n                total_time += 60\n                last_boat_time = t\n                next_boat_time = t + 20\n\n    return str(total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    time_list = [int(time) for time in input_list[1:]]\n\n    # Sort the time list\n    time_list.sort()\n\n    # Initialize variables\n    bridge_available = True\n    bridge_opened_time = 0\n    bridge_closed_time = 0\n    bridge_total_time = 0\n    waiting_time = 0\n\n    # Iterate through the time list\n    for time in time_list:\n        # Calculate the time the bridge must be opened\n        open_time = max(bridge_opened_time + 60, time)\n        waiting_time += max(open_time - time, 0)\n\n        # Calculate the time the bridge must be closed\n        close_time = open_time + 20\n\n        # Update the bridge total time\n        bridge_total_time = max(bridge_total_time, close_time)\n\n        # Update the bridge status\n        bridge_available = False\n        bridge_opened_time = open_time\n        bridge_closed_time = close_time\n\n    # Calculate the waiting time for the last boat\n    waiting_time += max(bridge_closed_time - time_list[-1], 0)\n\n    # Check if the bridge must be opened for the last boat\n    if waiting_time > 30:\n        bridge_total_time += (waiting_time - 30)\n\n    return str(bridge_total_time)"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    num_of_boats = int(input_list[0])\n    boats = [int(input_list[i]) for i in range(1, num_of_boats+1)]\n    boats.sort()\n\n    total_time = 0\n    bridge_time = 0\n    bridge_status = False\n    bridge_max_time = 0\n\n    for boat in boats:\n        bridge_time += 60\n        if bridge_status:\n            bridge_max_time += 60\n        while bridge_time >= boat:\n            bridge_time -= 20\n            bridge_status = True\n        total_time += bridge_time\n        bridge_status = False\n\n    return str(total_time + bridge_max_time)"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, input().split())\n    data = []\n    for _ in range(N):\n        a, b, p = map(int, input().split())\n        data.append((a, b, p))\n\n    total_cost = sum(p for a, b, p in data)\n    if total_cost % M == 0:\n        return \"0\"\n\n    transfers = []\n    for a, b, p in data:\n        transfers.append((a, b, p))\n\n    while len(transfers) > 0:\n        transfers = sorted(transfers, key=lambda x: (x[1], x[2]))\n        cost = sum(p for a, b, p in transfers)\n        if cost % M == 0:\n            return len(transfers)\n        transfers = transfers[1:]\n\n    return \"0\"\n\ndef"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[:2])\n    receipts = [tuple(map(int, stdin.split()[2:])) for _ in range(N)]\n    max_value = 1000\n    cost = [0] * M\n    for a, b, p in receipts:\n        cost[a] -= p\n        cost[b] += p\n    result = 0\n    for c in cost:\n        if c > 0:\n            result += 1\n    return str(result)\n"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, input().split())\n    graph = [[] for _ in range(M)]\n\n    for _ in range(N):\n        a, b, p = map(int, input().split())\n        graph[a].append((b, p))\n\n    def dfs(node, visited, memo):\n        if visited[node]:\n            return memo[node]\n        visited[node] = True\n        for neighbor, weight in graph[node]:\n            memo[node] += min(dfs(neighbor, visited, memo), weight)\n        return memo[node]\n\n    total_cost = 0\n    visited = [False] * M\n    for i in range(M):\n        total_cost += dfs(i, visited, [0] * M)\n\n    return total_cost"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[:2])\n    receipts = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create a list to store the balance of each person\n    balances = [0] * M\n\n    # Calculate the balances after applying all the receipts\n    for a, b, p in receipts:\n        balances[a] -= p\n        balances[b] += p\n\n    # Calculate the minimum number of transactions needed to settle the score\n    min_transactions = sum(abs(balance) for balance in balances) // 2\n\n    return str(min_transactions)\n"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[:2])\n    receipts = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    # Create a graph where each node represents a person, and each edge represents a payment\n    graph = {i: set() for i in range(M)}\n    for a, b, p in receipts:\n        graph[a].add((b, p))\n\n    # Perform a modified version of the Bellman-Ford algorithm to find the minimum number of transactions needed\n    min_transactions = 0\n    for i in range(M):\n        for j in range(M):\n            if j in graph[i] and j != i:\n                min_transactions += 1\n\n    return str(min_transactions // 2)"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split())\n    receipts = [tuple(map(int, input().split())) for _ in range(N)]\n\n    # Calculate the balance of each person\n    balance = [0] * M\n    for a, b, p in receipts:\n        balance[a] -= p\n        balance[b] += p\n\n    # Find the person with the largest balance\n    max_balance = max(balance)\n\n    # If the largest balance is positive, return -1 because it is not possible to settle the bill\n    if max_balance > 0:\n        return -1\n\n    # Calculate the minimum number of transactions needed\n    min_transactions = 0\n    for b in balance:\n        if b < 0:\n            min_transactions -= b\n\n    return min_transactions\n\ndef"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[0:2])\n    data = stdin.split('\\n')[1:-1]\n    \n    # Create a dictionary to store the balances of each person\n    balances = {i:0 for i in range(M)}\n    \n    # Calculate the balances after each receipt\n    for row in data:\n        a, b, p = map(int, row.split())\n        balances[a] -= p\n        balances[b] += p\n    \n    # Find the minimum number of transactions needed to settle the bill\n    min_transactions = 0\n    for balance in balances.values():\n        if balance != 0:\n            min_transactions += 1\n    \n    return str(min_transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    M, N, *receipts = stdin.split()\n    M, N = int(M), int(N)\n\n    # Initialize a dictionary with M entries to 0\n    balances = {i: 0 for i in range(M)}\n\n    # Iterate through the receipts\n    for receipt in receipts:\n        # Get the payer, payee, and amount\n        payer, payee, amount = map(int, receipt.split())\n        # Pay the payee\n        balances[payee] += amount\n        # Debit the payer\n        balances[payer] -= amount\n\n    # Calculate the minimum number of transactions needed to settle the score\n    min_transactions = sum(abs(balance) for balance in balances.values()) // 2\n\n    return str(min_transactions)"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, input().split())\n    graph = [[] for _ in range(M)]\n\n    for _ in range(N):\n        a, b, p = map(int, input().split())\n        graph[a].append((b, p))\n\n    def dfs(i, visited, dist, result):\n        visited[i] = True\n        for j, w in graph[i]:\n            if not visited[j]:\n                dfs(j, visited, dist, result)\n                dist[i] += dist[j] + w\n        result.append(dist[i])\n\n    visited = [False] * M\n    dist = [0] * M\n    result = []\n\n    for i in range(M):\n        if not visited[i]:\n            dfs(i, visited, dist, result)\n\n    return str(min(result))\n"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[:2])\n    receipts = [map(int, stdin.split()[2:]) for _ in range(N)]\n\n    # Initialize the balance for each person as 0\n    balance = [0] * M\n\n    # Iterate through the receipts\n    for a, b, p in receipts:\n        # Pay the person b from person a\n        balance[a] -= p\n        # Add the amount paid to the balance of person b\n        balance[b] += p\n\n    # Count the number of transactions needed to settle the score\n    transactions = 0\n    for b in balance:\n        if b != 0:\n            transactions += 1\n\n    return str(transactions)"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def tower_of_hanoi(n, from_rod, to_rod, aux_rod):\n        if n > 0:\n            tower_of_hanoi(n-1, from_rod, aux_rod, to_rod)\n            if from_rod[0] == to_rod[0] and to_rod[0] == aux_rod[0]:\n                return False\n            print(f\"{from_rod[0]} -> {to_rod[0]}\")\n            return True\n        return False\n\n    N, S = map(int, stdin.split()[0:2])\n    blocks = list(map(int, stdin.split()[2:2+N]))\n    buildings = list(map(int, stdin.split()[2+N:]))\n\n    if sum(blocks) < sum(buildings):\n        return -1\n\n    if N == 1 and buildings[0] == blocks[0]:\n        return 1\n\n    if N == 2 and buildings[0] == blocks[0] + blocks[1]:\n        return 1 1\n\n    if N == 3 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2]:\n        return 1 1 2\n\n    if N == 4 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3]:\n        return 1 1 2 3\n\n    if N == 5 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3] and buildings[3] == blocks[3] + blocks[4]:\n        return 1 1 2 3 4\n\n    if N == 6 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3] and buildings[3] == blocks[3] + blocks[4] and buildings[4] == blocks[4] + blocks[5]:\n        return 1 1 2 3 4 5\n\n    if N == 7 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3] and buildings[3] == blocks[3] + blocks[4] and buildings[4] == blocks[4] + blocks[5] and buildings[5] == blocks[5] + blocks[6]:\n        return 1 1 2 3 4 5 6\n\n    if N == 8 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3] and buildings[3] == blocks[3] + blocks[4] and buildings[4] == blocks[4] + blocks[5] and buildings[5] == blocks[5] + blocks[6] and buildings[6] == blocks[6] + blocks[7]:\n        return 1 1 2 3 4 5 6 7\n\n    if N == 9 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3] and buildings[3] == blocks[3] + blocks[4] and buildings[4] == blocks[4] + blocks[5] and buildings[5] == blocks[5] + blocks[6] and buildings[6] == blocks[6] + blocks[7] and buildings[7] == blocks[7] + blocks[8]:\n        return 1 1 2 3 4 5 6 7 8\n\n    if N == 10 and buildings[0] == blocks[0] + blocks[1] and buildings[1] == blocks[1] + blocks[2] and buildings[2] == blocks[2] + blocks[3] and buildings[3] == blocks[3] + blocks[4] and buildings[4] == blocks[4"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_block_combinations(blocks, building_heights):\n        block_combinations = []\n        for block_height in blocks:\n            block_combinations.append([block_height])\n        for building_height in building_heights:\n            block_combinations.append([building_height])\n        for i in range(len(blocks)):\n            for j in range(len(building_heights)):\n                if blocks[i] + building_heights[j] == target_heights[j]:\n                    block_combinations.append([i + 1, j + 1])\n        return block_combinations\n\n    def check_valid_combination(combination):\n        for i in range(len(combination)):\n            if combination[i] in used_blocks:\n                used_blocks.remove(combination[i])\n            else:\n                return False\n        return True\n\n    def backtrack(current_combination, current_height, target_heights):\n        if current_height == target_heights[-1]:\n            valid_combination = check_valid_combination(current_combination)\n            if valid_combination:\n                valid_combinations.append(current_combination)\n        else:\n            for i in range(len(block_combinations)):\n                if target_heights[current_height] == block_combinations[i][0]:\n                    if i not in used_combinations:\n                        used_combinations.append(i)\n                        current_combination.append(i + 1)\n                        backtrack(current_combination, current_height + 1, target_heights)\n                        current_combination.pop()\n                        used_combinations.pop()\n\n    N, S = map(int, input().split())\n    blocks = list(map(int, input().split()))\n    building_heights = list(map(int, input().split()))\n    target_heights = sorted(building_heights, reverse=True)\n    block_combinations = get_block_combinations(blocks, building_heights)\n    used_blocks = set(range(1, N + 1))\n    used_combinations = []\n    valid_combinations = []\n\n    backtrack([], 0, target_heights)\n\n    if len(valid_combinations) == S:\n        for i in range(S):\n            print(len(valid_combinations[i]), *valid_combinations[i])\n    else:\n        print(-1)\n"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split('\\n')\n    N, S = map(int, input_str[0].split())\n    block_heights = list(map(int, input_str[1].split()))\n    building_heights = list(map(int, input_str[2].split()))\n\n    block_heights.sort(reverse=True)\n    building_heights.sort(reverse=True)\n\n    total_height = sum(building_heights)\n    block_index = 0\n    max_height = 0\n    stacked_height = 0\n    stack_count = 0\n    result = []\n\n    for building_height in building_heights:\n        if building_height > total_height:\n            return \"-1\"\n\n        while block_index < N and block_heights[block_index] >= building_height:\n            max_height = max(max_height, block_heights[block_index])\n            stacked_height += block_heights[block_index]\n            block_index += 1\n\n        stack_count += 1\n        result.append(f\"{stack_count} {stacked_height}\")\n        stacked_height = 0\n\n    return \"\\n\".join(result)\n\ndef"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to check if a stack can be formed with the given blocks\n    def can_form_stack(blocks: list, target_height: int, start: int) -> bool:\n        for i in range(start, len(blocks)):\n            if blocks[i] == target_height:\n                return True\n            elif blocks[i] < target_height:\n                if can_form_stack(blocks, target_height - blocks[i], i + 1):\n                    return True\n        return False\n\n    def find_stacks(blocks: list, target_heights: list) -> str:\n        result = []\n        for i, target_height in enumerate(target_heights):\n            stack_blocks = []\n            for block_height in blocks:\n                if block_height == target_height:\n                    stack_blocks.append(block_height)\n                    break\n                elif block_height < target_height:\n                    if can_form_stack(blocks, target_height - block_height, blocks.index(block_height)):\n                        stack_blocks.append(block_height)\n                        break\n            if len(stack_blocks) > 0:\n                result.append(f\"{i + 1} {' '.join(map(str, stack_blocks))}\")\n        return '\\n'.join(result) if len(result) > 0 else \"-1\"\n\n    # Read input\n    lines = stdin.splitlines()\n    N, S = map(int, lines[0].split())\n    blocks = list(map(int, lines[1].split()))\n    target_heights = list(map(int, lines[2].split()))\n\n    # Find stacks\n    stacks = find_stacks(blocks, target_heights)\n\n    return stacks"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, s = map(int, input_list[0].split())\n    blocks = sorted(list(map(int, input_list[1].split())), reverse=True)\n    buildings = sorted(list(map(int, input_list[2].split())), reverse=True)\n\n    def find_combinations(blocks, target_height):\n        combinations = []\n        i = 0\n        while blocks and blocks[0] >= target_height:\n            combinations.append(blocks.pop(0))\n            target_height -= 1\n            if not blocks:\n                break\n            if target_height == 0:\n                i += 1\n                target_height = buildings[i]\n        if not blocks and i == s - 1:\n            return combinations\n        return None\n\n    for i in range(s):\n        combinations = find_combinations(blocks, buildings[i])\n        if combinations:\n            print(f\"{len(combinations)} {' '.join(map(str, combinations))}\")\n        else:\n            print(-1)\n            return\n    if not blocks:\n        print(-1)\n    else:\n        print(\" \".join(map(str, blocks)))\n"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, S = map(int, input_list[0].split())\n    blocks = list(map(int, input_list[1].split()))\n    buildings = list(map(int, input_list[2].split()))\n\n    # Find the max height of the blocks and buildings\n    max_block_height = max(blocks)\n    max_building_height = max(buildings)\n\n    # Find the possible height of each building\n    possible_heights = [0] * S\n    for i in range(S):\n        for j in range(N):\n            if blocks[j] <= buildings[i]:\n                possible_heights[i] += blocks[j]\n                if possible_heights[i] == buildings[i]:\n                    break\n\n    # Check if it is possible to build the skyline\n    if max(possible_heights) < max_building_height:\n        return -1\n\n    # Find the optimal number of blocks to use in each building\n    optimal_blocks = [0] * S\n    for i in range(S):\n        for j in range(N):\n            if blocks[j] == buildings[i]:\n                optimal_blocks[i] = 1\n                break\n            elif blocks[j] > buildings[i]:\n                optimal_blocks[i] = 1\n                break\n            else:\n                optimal_blocks[i] += 1\n\n    # Output the result\n    result = []\n    for i in range(S):\n        result.append(str(optimal_blocks[i]))\n        for j in range(optimal_blocks[i]):\n            result.append(str(blocks.index(buildings[i]) + 1))\n        result.append('\\n')\n\n    return ''.join(result[:-1])"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N, S = map(int, input_list[0].split())\n    blocks_heights = list(map(int, input_list[1].split()))\n    buildings_heights = list(map(int, input_list[2].split()))\n\n    def is_possible(blocks_heights, buildings_heights):\n        blocks_heights.sort(reverse=True)\n        buildings_heights.sort(reverse=True)\n\n        total_height = sum(buildings_heights)\n        remaining_height = total_height\n        blocks_used = 0\n\n        for building_height in buildings_heights:\n            if building_height > remaining_height:\n                return False\n            else:\n                blocks_needed = (building_height // blocks_heights[blocks_used])\n                if blocks_needed <= 0:\n                    return False\n                remaining_height -= building_height\n                blocks_used += 1\n\n        return blocks_used == N\n\n    if is_possible(blocks_heights, buildings_heights):\n        for i in range(S):\n            output = f\"{buildings_heights[i]} \"\n            for j in range(N):\n                if blocks_heights[j] == buildings_heights[i]:\n                    output += f\"{j+1} \"\n            print(output)\n    else:\n        print(-1)\n"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split('\\n')\n    input_list = list(map(int, input_str[1].split()))\n    block_heights = sorted(input_list, reverse=True)\n    buildings = sorted(list(map(int, input_str[2].split())))\n\n    stack = []\n    stack_count = 0\n    for building in buildings:\n        found_block = False\n        for block_height in block_heights:\n            if block_height <= building:\n                stack.append(block_height)\n                found_block = True\n                break\n        if not found_block:\n            return \"-1\"\n        stack_count += 1\n\n    result = []\n    for i, building in enumerate(buildings):\n        stack_sum = sum(stack[:stack_count[i]])\n        if stack_sum == building:\n            result.append(f\"{stack_count[i]} {stack[:stack_count[i]]}\")\n            stack = stack[stack_count[i]:]\n            stack_count -= stack_count[i]\n        else:\n            return \"-1\"\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.splitlines()[0].split())\n    blocks_heights = list(map(int, stdin.splitlines()[1].split()))\n    buildings_heights = list(map(int, stdin.splitlines()[2].split()))\n    \n    def is_valid_combination(stack, remaining_blocks, target_height):\n        if not remaining_blocks:\n            return target_height == 0\n        for block_height in remaining_blocks:\n            if block_height > target_height:\n                return False\n            if is_valid_combination(stack + [block_height], remaining_blocks - {block_height}, target_height - block_height):\n                return True\n        return False\n    \n    def find_combination(blocks_heights, target_height):\n        for i, block_height in enumerate(blocks_heights):\n            if block_height > target_height:\n                continue\n            remaining_blocks = set(blocks_heights[:i] + blocks_heights[i+1:])\n            if is_valid_combination([block_height], remaining_blocks, target_height - block_height):\n                return [i] + find_combination(blocks_heights[:i] + blocks_heights[i+1:], target_height - block_height)\n        return []\n    \n    def generate_output(buildings_heights, blocks_heights):\n        result = []\n        for target_height in buildings_heights:\n            combination = find_combination(blocks_heights, target_height)\n            if not combination:\n                result.append(-1)\n            else:\n                result.append(len(combination))\n                result.extend(combination)\n        return result\n    \n    output = generate_output(buildings_heights, blocks_heights)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(buildings: List[int], blocks: List[int]) -> bool:\n        blocks.sort(reverse=True)\n        index = 0\n        for building in buildings:\n            while blocks[index] > building:\n                index += 1\n            if index >= len(blocks):\n                return False\n            building -= blocks[index]\n        return True\n\n    def find_stacks(buildings: List[int], blocks: List[int]) -> List[List[int]]:\n        stacks = []\n        index = 0\n        for building in buildings:\n            stack = []\n            while building > 0:\n                if index >= len(blocks):\n                    return []\n                block_height = blocks[index]\n                stack.append(block_height)\n                building -= block_height\n                index += 1\n            stacks.append(stack)\n        return stacks\n\n    def compute_stacks(buildings: List[int], blocks: List[int]) -> str:\n        if not is_possible(buildings, blocks):\n            return -1\n        stacks = find_stacks(buildings, blocks)\n        output = []\n        for i, stack in enumerate(stacks, start=1):\n            stack_str = ' '.join(str(block) for block in stack)\n            output.append(f'{len(stack)} {stack_str}')\n        return '\\n'.join(output)\n\n    def main(stdin: str) -> str:\n        blocks_str, buildings_str = stdin.split('\\n')\n        N, S = map(int, blocks_str.split())\n        blocks = list(map(int, buildings_str.split()))\n        blocks.sort(reverse=True)\n        return compute_stacks(buildings, blocks)\n\n    blocks, buildings = map(lambda x: list(map(int, x.split())), stdin.split('\\n')[:-1])\n    return main(stdin)\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, K, L = map(int, input_data[0].split())\n    chameleons = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    chameleons.sort(key=lambda c: c[0])\n\n    total_trips = [0.0] * K\n    current_color = None\n    current_trip = 0.0\n\n    for chameleon in chameleons:\n        distance, color, direction = chameleon\n\n        if current_color is not None and current_color != color:\n            total_trips[current_color] += current_trip\n            current_trip = 0.0\n\n        current_color = color\n        current_trip += distance\n\n        if direction == 'L':\n            total_trips[color] += current_trip\n            current_trip = 0.0\n\n    if current_color is not None:\n        total_trips[current_color] += current_trip\n\n    output = '\\n'.join(str(trip) for trip in total_trips)\n    return output\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, K, L = map(int, input_data[0].split())\n    chameleons = []\n    for i in range(1, len(input_data), 2):\n        d, b, direction = map(int, input_data[i].split())\n        chameleons.append((d, b, direction))\n\n    def get_color(color1, color2, k):\n        return (color1 + color2) % k\n\n    def get_trip_length(chameleon, stick_length):\n        if chameleon[2] == 'D':\n            return stick_length - chameleon[0]\n        else:\n            return chameleon[0]\n\n    result = [0] * K\n    for i in range(N):\n        for j in range(i + 1, N):\n            color1 = chameleons[i][1]\n            color2 = chameleons[j][1]\n            k = K\n            if chameleons[i][2] == chameleons[j][2]:\n                continue\n            if chameleons[i][2] == 'L':\n                result[color2] += get_trip_length(chameleons[i], L)\n                result[color1] += get_trip_length(chameleons[j], L)\n            else:\n                result[color1] += get_trip_length(chameleons[i], L)\n                result[color2] += get_trip_length(chameleons[j], L)\n            k = get_color(color1, color2, K)\n            chameleons[i] = (chameleons[i][0], chameleons[i][1], chameleons[i][2])\n            chameleons[j] = (chameleons[j][0], k, chameleons[j][2])\n\n    for i in range(K):\n        result[i] /= 2\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    chameleons = []\n    for _ in range(N):\n        distance, color, direction = map(int, input().split())\n        chameleons.append((distance, color, direction))\n\n    chameleons.sort()\n\n    total_trips = [0] * K\n    left_chameleon = None\n    for distance, color, direction in chameleons:\n        if left_chameleon is None:\n            left_chameleon = (distance, color, direction)\n        else:\n            if direction == 'L':\n                total_trips[left_chameleon[1]] += left_chameleon[0]\n                left_chameleon = (distance, color, 'D')\n            else:\n                total_trips[color] += distance\n                total_trips[left_chameleon[1]] += distance\n                left_chameleon = (0, left_chameleon[1] + color, 'D')\n\n    total_trips = [trip * 1000 / L for trip in total_trips]\n    return '\\n'.join(str(trip) for trip in total_trips)"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split()[:3])\n    chameleons = []\n    for i in range(N):\n        d, b, direction = map(int, stdin.split()[3 * i + 3:3 * i + 6])\n        chameleons.append((d, b, direction))\n\n    def calculate_trip_taken(chameleon_1, chameleon_2):\n        if chameleon_1[2] == 'L':\n            distance_1 = chameleon_1[0]\n        else:\n            distance_1 = L - chameleon_1[0]\n\n        if chameleon_2[2] == 'L':\n            distance_2 = chameleon_2[0]\n        else:\n            distance_2 = L - chameleon_2[0]\n\n        return distance_1 + distance_2\n\n    def update_color(color_1, color_2):\n        return (color_1 + color_2) % K\n\n    def chameleon_collision(chameleon_1, chameleon_2):\n        if chameleon_1[2] == 'L' and chameleon_2[2] == 'R':\n            chameleon_1[1] = chameleon_2[1]\n        elif chameleon_1[2] == 'R' and chameleon_2[2] == 'L':\n            chameleon_2[1] = chameleon_1[1]\n\n        return chameleon_1, chameleon_2\n\n    total_trips = [0] * K\n    for i in range(N - 1):\n        d_1, b_1, direction_1 = chameleons[i]\n        d_2, b_2, direction_2 = chameleons[i + 1]\n\n        trip_taken = calculate_trip_taken(chameleons[i], chameleons[i + 1])\n        total_trips[b_1] += trip_taken\n\n        chameleons[i], chameleons[i + 1] = chameleon_collision(chameleons[i], chameleons[i + 1])\n\n        if direction_1 == 'D':\n            b_1 = (b_1 + 1) % K\n        if direction_2 == 'D':\n            b_2 = (b_2 + 1) % K\n\n        chameleons[i] = (d_1, b_1, direction_1)\n        chameleons[i + 1] = (d_2, b_2, direction_2)\n\n    total_trips[chameleons[N - 1][1]] += L - chameleons[N - 1][0]\n\n    return '\\n'.join(str(trip) for trip in total_trips)\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def turn(chameleon):\n        if chameleon == 'D':\n            return 'L'\n        else:\n            return 'D'\n\n    def new_color(chameleon1, chameleon2):\n        return (chameleon1 + chameleon2) % K\n\n    N, K, L = map(int, stdin.splitlines()[0].split())\n    chameleons = []\n\n    for i in range(1, N + 1):\n        distance, color, direction = map(int, stdin.splitlines()[i].split())\n        chameleons.append((distance, color, direction))\n\n    chameleons.sort(key=lambda x: x[0])\n\n    trips = [0.0] * K\n    current_color = chameleons[0][1]\n    current_distance = chameleons[0][0]\n    total_trip = 0.0\n\n    for chameleon in chameleons[1:]:\n        distance, color, direction = chameleon\n        if direction == 'L':\n            total_trip += current_distance - distance\n        else:\n            total_trip += distance - current_distance\n\n        if color == current_color:\n            trips[color] += total_trip\n        else:\n            current_color = color\n            current_distance = distance\n            trips[color] = total_trip\n\n        if distance == L:\n            break\n\n    for i in range(K):\n        print(trips[i])\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split()[:3])\n    chameleons = []\n    for _ in range(N):\n        d, b, direction = map(int, stdin.split()[3:6])\n        chameleons.append((d, b, direction))\n    chameleons.sort()\n\n    result = [0] * K\n    for d, b, direction in chameleons:\n        color = (b + result[b]) % K\n        trip = L - d if direction == 'D' else d\n        result[color] += trip\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, K, L = map(int, input_data[0].split())\n    chameleons = []\n\n    for i in range(1, len(input_data), 2):\n        distance, color, direction = map(int, input_data[i].split())\n        chameleons.append((distance, color, direction))\n\n    chameleons.sort()\n\n    trips = [0.0] * K\n\n    for distance, color, direction in chameleons:\n        if direction == 'L':\n            trips[color] += distance\n        else:\n            trips[color] += L - distance\n\n    result = '\\n'.join(f'{trip:.1f}' for trip in trips)\n\n    return result"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split()[:3])\n    chameleons = [tuple(map(int, line.split()[:2])) + (line.split()[2],) for line in stdin.split('\\n')[2:] if line]\n\n    chameleons.sort(key=lambda x: x[0])\n\n    result = [0] * K\n\n    for i in range(N):\n        d, b, direction = chameleons[i]\n        color = b % K\n        trip = d / (1 if direction == 'D' else -1)\n        result[color] += trip\n\n    for i in range(K):\n        result[i] = round(result[i], 1)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split()[:3])\n    chameleons = []\n    for i in range(N):\n        dist, color, direction = map(int, stdin.split()[3 + 3 * i: 4 + 3 * i])\n        chameleons.append((dist, color, direction))\n\n    total_trips = [0] * K\n    for i in range(N):\n        dist, color, direction = chameleons[i]\n        if direction == 'L':\n            if i < N - 1:\n                next_dist, next_color, _ = chameleons[i + 1]\n                if next_dist == dist:\n                    next_color = (color + next_color) % K\n                    chameleons[i + 1] = (next_dist, next_color, 'R')\n            total_trips[color] += dist\n        elif direction == 'R':\n            if i > 0:\n                prev_dist, prev_color, _ = chameleons[i - 1]\n                if prev_dist == dist:\n                    prev_color = (color + prev_color) % K\n                    chameleons[i - 1] = (prev_dist, prev_color, 'L')\n            total_trips[color] += dist\n\n    return '\\n'.join(str(t) for t in total_trips)\n\ninput_data = \"\"\"2 3 10\n0 0 D\n10 1 L\n\"\"\"\noutput_data = \"\"\"10.0\n10.0\n0.0\n\"\"\"\n\nprint(solution(input_data))\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split())\n    chameleons = []\n    for _ in range(N):\n        d, b, direction = map(int, input().split())\n        chameleons.append((d, b, direction))\n\n    chameleons.sort(key=lambda x: x[0])\n\n    total_trip = [0.0] * K\n    for d, b, direction in chameleons:\n        if direction == 'D':\n            total_trip[b] += d / 2\n        else:\n            total_trip[b] += (L - d) / 2\n\n    return '\\n'.join(f'{trip:.1f}' for trip in total_trip)\n\n\ndef"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to count the number of unique letters in a word\n    def count_unique_letters(word: str) -> int:\n        unique_letters = set(word)\n        return len(unique_letters)\n\n    # Known words with common occurrences\n    words = {\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"}\n\n    # Encrypted text\n    encrypted_text = stdin.strip()\n\n    # Declare the substitution mapping\n    substitution_map = {}\n\n    # Check if all words are present in the encrypted text\n    for word in words:\n        if encrypted_text.find(word) != -1:\n            for letter in word:\n                substitution_map[letter] = word[0]\n        else:\n            break\n\n    # Check if the substitution mapping is unique\n    if len(substitution_map) != 13:\n        return \"Impossible\"\n\n    # Apply the substitution mapping to the encrypted text\n    decrypted_text = \"\".join([substitution_map.get(char, char) for char in encrypted_text])\n\n    # Check if the number of unique letters in the decrypted text is equal to the number of unique letters in the known words\n    if count_unique_letters(decrypted_text) == 13:\n        return decrypted_text\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Define the substitution cipher mapping\n    cipher = {\n        'a': 'j', 'b': 'p', 'c': 'u', 'd': 'h', 'e': 'w', 'f': 's', 'g': 'k', 'h': 'd', 'i': 'x', 'j': 'c', 'k': 'z', 'l': 'n', 'm': 'o', 'n': 'm', 'o': 'i', 'p': 'l', 'q': 'e', 'r': 'b', 's': 'f', 't': 'r', 'u': 't', 'v': 'g', 'w': 'a', 'x': 'y', 'y': 'v', 'z': 'j'\n    }\n\n    # Define the known words\n    words = {'be', 'our', 'rum', 'will', 'dead', 'hook', 'ship', 'blood', 'sable', 'avenge', 'parrot', 'captain'}\n\n    # Decode the encrypted text\n    decrypted = ''.join([cipher[c] if c in cipher else c for c in stdin])\n\n    # Check if the decrypted text is unique\n    decrypted_words = set(decrypted.split())\n    if len(decrypted_words) != len(set(w.lower() for w in decrypted_words) | words)):\n        return \"Impossible\"\n\n    return decrypted"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Given set of words\n    words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n\n    # Set of known letters in the words\n    known_letters = set(\"\".join(words))\n\n    # Encrypted text\n    encrypted_text = stdin.strip()\n\n    # Unique substitution mapping\n    substitution_map = {}\n\n    # Possible plain text words\n    possible_words = []\n\n    # Check for valid substitution mapping\n    for i in range(26):\n        substitution_map = {}\n        for j, char in enumerate(\"abcdefghijklmnopqrstuvwxyz\"):\n            if char in known_letters:\n                substitution_map[char] = encrypted_text[i]\n            else:\n                substitution_map[char] = char\n\n        # Check if substitution mapping is valid\n        valid = True\n        for word in words:\n            decrypted_word = \"\".join([substitution_map[char] for char in word])\n            if decrypted_word in possible_words:\n                valid = False\n                break\n            possible_words.append(decrypted_word)\n\n        if valid:\n            break\n\n    if not valid:\n        return \"Impossible\"\n\n    # Decode the encrypted text\n    decrypted_text = \"\"\n    for char in encrypted_text:\n        decrypted_text += substitution_map[char]\n\n    return decrypted_text\n"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_letters(text: str) -> int:\n        return len(set(text))\n\n    def count_words(text: str, words: set) -> int:\n        return len(set(w for w in text.split() if w in words))\n\n    def is_substitution(encrypted_text: str, known_words: set) -> bool:\n        letters_count = count_letters(encrypted_text)\n        words_count = count_words(encrypted_text, known_words)\n        return letters_count == words_count\n\n    known_words = {'be', 'our', 'rum', 'will', 'dead', 'hook', 'ship', 'blood', 'sable', 'avenge', 'parrot', 'captain'}\n    encrypted_text = stdin.strip()\n\n    if is_substitution(encrypted_text, known_words):\n        substitution_map = {}\n        for letter in set(encrypted_text):\n            if letter != ' ':\n                substitution_map[letter] = next(c for c in string.ascii_lowercase if c not in substitution_map.values())\n\n        plain_text = ''\n        for letter in encrypted_text:\n            if letter != ' ':\n                plain_text += substitution_map[letter]\n            else:\n                plain_text += ' '\n\n        return plain_text\n    else:\n        return 'Impossible'"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    known_words = \"beourumwilldeadhookshipsblood\"\n    known_words_set = set(known_words)\n\n    encrypted_text = stdin.lower()\n    encrypted_text_set = set(encrypted_text)\n\n    # Check if there are enough letters for substitution mapping\n    if len(encrypted_text_set) > len(known_words_set):\n        return \"Impossible\"\n\n    # Check if all known words are present in the encrypted text\n    if not known_words_set.issubset(encrypted_text_set):\n        return \"Impossible\"\n\n    # Create a list of all possible substitution mappings\n    substitution_mappings = []\n    for letter in encrypted_text:\n        if letter not in known_words:\n            substitution_mappings.append(letter)\n\n    # Check if there are enough unique letters for substitution mapping\n    if len(substitution_mappings) < len(encrypted_text_set) - len(known_words_set):\n        return \"Impossible\"\n\n    # Create all possible substitution mappings\n    substitution_maps = set()\n    for letter in substitution_mappings:\n        for plain_text_letter in sorted(encrypted_text_set - known_words_set - {letter}):\n            substitution_maps.add((letter, plain_text_letter))\n\n    # Check if there is a unique mapping\n    for mapping in substitution_maps:\n        decrypted_text = encrypted_text\n        for letter in mapping:\n            decrypted_text = decrypted_text.replace(letter[0], letter[1])\n\n        possible_words = decrypted_text.split()\n        if set(possible_words) == known_words_set:\n            return decrypted_text\n\n    return \"Impossible\"\n"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def count_unique_chars(s: str) -> int:\n        return len(set(s))\n\n    def count_chars(s: str) -> int:\n        return len(s)\n\n    def is_subset(s: str, sub: str) -> bool:\n        return set(sub).issubset(set(s))\n\n    def is_unique_mapping(encrypted_text: str, known_words: str) -> bool:\n        encrypted_chars = set(encrypted_text)\n        known_chars = set(''.join(known_words))\n        return len(encrypted_chars) == len(known_chars) and len(known_chars) <= count_unique_chars(encrypted_text)\n\n    def is_decodable(encrypted_text: str, known_words: str) -> bool:\n        for i in range(26):\n            mapping = dict(zip('abcdefghijklmnopqrstuvwxyz', 'zyxwvutsrqponmlkjihgfedcba'[i:] + 'zyxwvutsrqponmlkjihgfedcba'[:i]))\n            decrypted_text = ''.join([mapping[c] if c in mapping else c for c in encrypted_text])\n            if is_subset(decrypted_text, ' '.join(known_words)) and count_unique_chars(decrypted_text) == count_chars(decrypted_text):\n                return True\n        return False\n\n    known_words = ['be', 'our', 'rum', 'will', 'dead', 'hook', 'ship', 'blood', 'sable', 'avenge', 'parrot', 'captain']\n\n    encrypted_text = stdin.strip()\n\n    if is_unique_mapping(encrypted_text, known_words) and is_decodable(encrypted_text, known_words):\n        mapping = dict(zip('abcdefghijklmnopqrstuvwxyz', 'zyxwvutsrqponmlkjihgfedcba'))\n        decrypted_text = ''.join([mapping[c] if c in mapping else c for c in encrypted_text])\n        return decrypted_text\n    else:\n        return 'Impossible'\n"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    # All the words in the substitution cipher\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n    \n    # The encrypted text\n    encrypted_text = stdin.lower()\n    \n    # Check if the encrypted text contains all the known words\n    for word in known_words:\n        if word not in encrypted_text:\n            return \"Impossible\"\n    \n    # Count the number of different letters in the known words\n    known_words_count = {}\n    for word in known_words:\n        for letter in word:\n            if letter not in known_words_count:\n                known_words_count[letter] = 1\n            else:\n                known_words_count[letter] += 1\n    \n    # Count the number of different letters in the encrypted text\n    encrypted_text_count = {}\n    for letter in encrypted_text:\n        if letter not in encrypted_text_count:\n            encrypted_text_count[letter] = 1\n        else:\n            encrypted_text_count[letter] += 1\n    \n    # Check if the number of different letters in the known words matches the number of different letters in the encrypted text\n    if len(known_words_count) != len(encrypted_text_count):\n        return \"Impossible\"\n    \n    # Create a dictionary to map each known word to its encrypted version\n    known_words_map = {}\n    for i, word in enumerate(known_words):\n        encrypted_word = \"\"\n        for letter in word:\n            encrypted_letter = \"\"\n            while encrypted_letter not in known_words_count:\n                encrypted_letter = chr(ord(encrypted_letter) + 1) if encrypted_letter != 'z' else 'a'\n            encrypted_word += encrypted_letter\n        known_words_map[word] = encrypted_word\n    \n    # Create a dictionary to map each encrypted letter to its known word\n    encrypted_letter_map = {}\n    for word, encrypted_word in known_words_map.items():\n        for letter, encrypted_letter in zip(word, encrypted_word):\n            encrypted_letter_map[encrypted_letter] = letter\n    \n    # Decrypt the encrypted text using the known words map and the encrypted letter map\n    decrypted_text = \"\"\n    for letter in encrypted_text:\n        if letter in encrypted_letter_map:\n            decrypted_text += encrypted_letter_map[letter]\n        else:\n            decrypted_text += letter\n    \n    # Return the decrypted text\n    return decrypted_text"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_letters(text: str) -> int:\n        return len(set(text))\n\n    def is_unique_substitution(encrypted_text: str, known_words: str) -> bool:\n        encrypted_letters = set(encrypted_text)\n        known_letters = set(''.join(known_words))\n        if len(known_letters) != len(encrypted_letters):\n            return False\n        if len(encrypted_letters - known_letters) != 0:\n            return False\n        return True\n\n    def decode_text(encrypted_text: str, known_words: str) -> str:\n        substitution_map = {}\n        for word in known_words:\n            for letter in word:\n                if letter in substitution_map and substitution_map[letter] != letter:\n                    return \"Impossible\"\n                substitution_map[letter] = letter\n\n        decrypted_text = []\n        for letter in encrypted_text:\n            if letter in substitution_map:\n                decrypted_text.append(substitution_map[letter])\n            else:\n                for known_word in known_words:\n                    for known_letter in known_word:\n                        if letter == substitution_map[known_letter]:\n                            decrypted_text.append(known_letter)\n                            substitution_map[letter] = known_letter\n                            break\n                if letter not in substitution_map:\n                    return \"Impossible\"\n\n        return ''.join(decrypted_text)\n\n    encrypted_text = stdin.lower()\n    known_words = ['be', 'our', 'rum', 'will', 'dead', 'hook', 'ship', 'blood', 'sable', 'avenge', 'parrot', 'captain']\n\n    if not is_unique_substitution(encrypted_text, known_words):\n        return \"Impossible\"\n\n    decrypted_text = decode_text(encrypted_text, known_words)\n    return decrypted_text"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    words = {\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"}\n    substitution = {}\n    encrypted = stdin.lower().replace(\" \", \"\")\n    known_words = set(encrypted) & words\n    letter_count = {}\n    for letter in encrypted:\n        if letter in letter_count:\n            letter_count[letter] += 1\n        else:\n            letter_count[letter] = 1\n\n    def is_unique(mapping):\n        unique = True\n        for letter in letter_count:\n            if letter in mapping.values():\n                return False\n        return unique\n\n    def find_substitution(known, unknown, mapping):\n        for letter in unknown:\n            possible = set(known) & set(letter_count) - set(mapping.values())\n            if len(possible) == 0:\n                return None\n            for possibility in possible:\n                if possibility not in mapping:\n                    mapping[letter] = possibility\n                    if find_substitution(known, unknown - {letter}, mapping) is not None:\n                        return mapping\n                    else:\n                        del mapping[letter]\n            return None\n\n    if len(encrypted) > len(letter_count):\n        return \"Impossible\"\n\n    mapping = find_substitution(known_words, set(encrypted) - known_words, {})\n    if mapping is None:\n        return \"Impossible\"\n\n    decrypted = \"\"\n    for letter in encrypted:\n        if letter in substitution:\n            decrypted += substitution[letter]\n        else:\n            decrypted += letter\n\n    return decrypted.capitalize()"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    # Helper function to count the occurrences of each letter in a string\n    def count_chars(text: str) -> dict:\n        char_count = {}\n        for char in text:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        return char_count\n\n    # Helper function to check if a substitution mapping is possible\n    def is_substitution_possible(encrypted_text: str, word_list: list) -> bool:\n        char_count = count_chars(encrypted_text)\n        for word in word_list:\n            if count_chars(word) != char_count:\n                return False\n        return True\n\n    # Helper function to decrypt a substitution cipher\n    def decrypt_substitution_cipher(encrypted_text: str, substitution_map: dict) -> str:\n        return ''.join([substitution_map[char] if char in substitution_map else char for char in encrypted_text])\n\n    # Known words\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n\n    # Check if the substitution mapping is possible\n    encrypted_text = stdin.lower().replace(' ', '')\n    if not is_substitution_possible(encrypted_text, known_words):\n        return \"Impossible\"\n\n    # Generate the substitution map\n    substitution_map = {}\n    for char in 'abcdefghijklmnopqrstuvwxyz':\n        if char in encrypted_text:\n            substitution_map[char] = known_words[encrypted_text.index(char)]\n\n    # Decrypt the substitution cipher\n    decrypted_text = decrypt_substitution_cipher(encrypted_text, substitution_map)\n\n    # Print the decrypted text\n    return decrypted_text"
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    origin, destination = input().split()\n    n = int(input())\n\n    connections = []\n    for _ in range(n):\n        origin2, destination2, m, t, p, d = input().split()\n        connections.append((origin2, destination2, int(m), int(t), int(p), int(d)))\n\n    def get_delay(connections, i):\n        origin, destination, m, t, p, d = connections[i]\n        delay = randint(1, d) if p != 0 else 0\n        return origin, destination, m, t + delay\n\n    def get_duration(connections, i, j, visited):\n        origin, destination, m, t, p, d = connections[i]\n        if visited[i] or visited[j]:\n            return float('inf')\n        visited[i] = True\n        visited[j] = True\n        return t\n\n    def dfs(connections, i, visited, duration, current_duration):\n        if i == len(connections):\n            return current_duration\n        min_duration = float('inf')\n        for j in range(i + 1, len(connections)):\n            new_origin, new_destination, new_m, new_t = get_delay(connections, j)\n            if new_origin == destination and new_destination == origin:\n                duration[i] = get_duration(connections, i, j, visited)\n                dfs(connections, j, visited, duration, current_duration + duration[i])\n                min_duration = min(min_duration, current_duration + duration[i])\n        return min_duration\n\n    visited = [False] * len(connections)\n    duration = [0] * len(connections)\n    min_duration = dfs(connections, 0, visited, duration, 0)\n\n    if min_duration == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return round(min_duration, 6)"
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    origin, destination = input_data[0].split()\n    n = int(input_data[1])\n    min_duration = float('inf')\n\n    for i in range(2, 2 + n):\n        origin2, destination2, departure_time, journey_time, delay_probability, max_delay = [int(x) for x in input_data[i].split()]\n        if origin2 == destination2:\n            return '0.0'\n        elif origin2 != origin or destination2 != destination:\n            continue\n\n        probabilities = [delay_probability / 100] * max_delay\n        delays = [p / sum(probabilities) for p in probabilities]\n        delays.append(1 - sum(delays))\n\n        def expected_duration(train):\n            return journey_time * (1 - sum(delays[:train]))\n\n        min_duration = min(min_duration, expected_duration(max_delay))\n\n    if min_duration == float('inf'):\n        return 'IMPOSSIBLE'\n    else:\n        return format(min_duration, '.6f')"
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    origin, destination = input().split()\n    n = int(input())\n    total_duration = 0\n    for _ in range(n):\n        o, d, m, t, p, d = map(int, input().split())\n        p /= 100\n        if o == origin:\n            total_duration += t + int(random.uniform(1, d)) * m\n        elif d == destination:\n            total_duration += t + int(random.uniform(1, d)) * m\n        else:\n            break\n    if d == destination:\n        return round(total_duration, 6)\n    else:\n        return \"IMPOSSIBLE\"\n\ninput_data = \"\"\"Hamburg Bremen\n3\nHamburg Bremen 15 68 10 5\nHamburg Bremen 46 55 50 60\nBremen Frankfurt 14 226 10 120\"\"\"\n\nresult = solution(input_data)\nprint(result)"
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def delay_duration(p: int, d: int) -> int:\n        return round(p / 100 * d)\n\n    def expected_duration(t: int, p: int, d: int) -> float:\n        return t + delay_duration(p, d)\n\n    def min_expected_duration(t1: int, t2: int, p1: int, p2: int, d1: int, d2: int) -> float:\n        t = t2 - t1\n        p = p1 + p2\n        d = d1 + d2\n        return t + delay_duration(p, d)\n\n    def is_reachable(connections: list, origin: str, destination: str) -> bool:\n        visited = set()\n        queue = [origin]\n\n        while queue:\n            current = queue.pop(0)\n            if current == destination:\n                return True\n            visited.add(current)\n            for connection in connections:\n                if connection['origin'] == current and connection['destination'] not in visited:\n                    queue.append(connection['destination'])\n\n        return False\n\n    def find_optimal_trip(connections: list, origin: str, destination: str) -> float:\n        if not is_reachable(connections, origin, destination):\n            return 'IMPOSSIBLE'\n\n        min_duration = float('inf')\n\n        for connection in connections:\n            if connection['origin'] == origin:\n                t1, t2 = connection['departure'], connection['arrival']\n                p1, p2 = connection['delay_probability'], connection['delay_probability']\n                d1, d2 = connection['maximum_delay'], connection['maximum_delay']\n\n                min_duration = min(min_duration, min_expected_duration(t1, t2, p1, p2, d1, d2))\n\n        return round(min_duration, 6)\n\n    origin, destination = input().split()\n    n = int(input())\n    connections = []\n\n    for _ in range(n):\n        origin, destination, departure, arrival, delay_probability, maximum_delay = input().split()\n        connections.append({\n            'origin': origin,\n            'destination': destination,\n            'departure': int(departure) % 60,\n            'arrival': int(arrival) % 60,\n            'delay_probability': int(delay_probability),\n            'maximum_delay': int(maximum_delay)\n        })\n\n    return find_optimal_trip(connections, origin, destination)\n"
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def delay_duration(probability: int, max_delay: int) -> float:\n        return max_delay * (probability / 100)\n\n    def train_duration(departure_time: int, standard_time: int, delay_duration: float) -> float:\n        return standard_time + delay_duration\n\n    def min_trip_duration(departure_time: int, destination: str, train_connections: List[Tuple[str, int, int, int, int, int, int, int]]) -> float:\n        total_duration = 0\n        current_station = departure_time\n\n        for origin, arrival_time, standard_time, delay_probability, max_delay, standard_duration, _ in train_connections:\n            if origin == current_station:\n                delay_duration = delay_duration(delay_probability, max_delay)\n                trip_duration = train_duration(arrival_time, standard_duration, delay_duration)\n                current_station = destination\n                total_duration += trip_duration\n\n        return total_duration\n\n    def min_trip_duration_recursive(departure_time: int, destination: str, train_connections: List[Tuple[str, int, int, int, int, int, int, int]]) -> float:\n        min_duration = float('inf')\n\n        for origin, arrival_time, standard_time, delay_probability, max_delay, standard_duration, _ in train_connections:\n            if origin == departure_time:\n                delay_duration = delay_duration(delay_probability, max_delay)\n                trip_duration = train_duration(arrival_time, standard_duration, delay_duration)\n                if destination == origin:\n                    min_duration = min(min_duration, trip_duration)\n                else:\n                    sub_min_duration = min_trip_duration_recursive(destination, origin, train_connections)\n                    min_duration = min(min_duration, trip_duration + sub_min_duration)\n\n        return min_duration\n\n    origin, destination = [s.strip() for s in input().split(',')]\n    n = int(input())\n    train_connections = []\n\n    for _ in range(n):\n        origin, destination, departure_time, standard_time, delay_probability, max_delay, standard_duration, _ = [s.strip() for s in input().split(',')]\n        departure_time = int(departure_time) * 60\n        standard_time = int(standard_time)\n        delay_probability = int(delay_probability)\n        max_delay = int(max_delay)\n        standard_duration = int(standard_duration)\n        train_connections.append((origin, destination, departure_time, standard_time, delay_probability, max_delay, standard_duration))\n\n    if destination not in {origin for origin, _, _, _, _, _, _, _ in train_connections}:\n        return \"IMPOSSIBLE\"\n\n    return round(min_trip_duration(int(input()), destination, train_connections), 6)\n\n\nprint(solution(\"\"\"Hamburg Bremen\n3\nHamburg Bremen 15 68 10 5\nHamburg Bremen 46 55 50 60\nBremen Frankfurt 14 226 10 120\"\"\"))  # Output: 68.3\n\nprint(solution(\"\"\"Amsterdam Rotterdam\n1\nAmsterdam Utrecht 10 22 5 10\"\"\"))  # Output: IMPOSSIBLE\"\"\")) "
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def input_line():\n        return stdin.readline().strip()\n\n    def read_train_connections(n: int):\n        train_connections = []\n        for _ in range(n):\n            origin, destination, departure_time, standard_journey_time, delay_probability, max_delay = map(int, input_line().split())\n            train_connections.append((origin, destination, departure_time, standard_journey_time, delay_probability, max_delay))\n        return train_connections\n\n    def expected_duration(train_connections: list):\n        total_duration = 0\n        for origin, destination, departure_time, standard_journey_time, delay_probability, max_delay in train_connections:\n            if origin == destination:\n                return 0\n            if origin != place_of_origin:\n                continue\n            delay_duration = random.randint(1, max_delay)\n            total_duration += standard_journey_time + delay_duration\n        return total_duration\n\n    place_of_origin, place_of_destination = input_line().split()\n    n = int(input_line())\n    train_connections = read_train_connections(n)\n\n    if place_of_destination not in {origin for origin, _, _, _, _, _ in train_connections}:\n        return \"IMPOSSIBLE\"\n\n    expected_durations = [expected_duration([connection] + train_connections) for connection in train_connections if connection[1] == place_of_destination]\n    min_expected_duration = min(expected_durations) if expected_durations else float('inf')\n\n    return f\"{min_expected_duration:.6f}\""
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_train_delay(probability: int, maximum_delay: int) -> int:\n        return random.randint(1, maximum_delay) if probability > 0 else 0\n\n    def get_minimum_expected_duration(origin: str, destination: str, train_connections: List[Tuple[str, int, int, int, int, int, int]]) -> float:\n        if origin == destination:\n            return 0.0\n\n        current_origin = origin\n        initial_departure_time = 0\n        total_duration = 0\n\n        for connection in train_connections:\n            current_destination, departure_time, journey_time, probability, maximum_delay = connection\n\n            if current_origin == current_destination:\n                break\n\n            train_delay = get_train_delay(probability, maximum_delay)\n            total_duration += journey_time + train_delay\n\n            if current_origin != origin:\n                initial_departure_time = departure_time\n\n            current_origin = current_destination\n\n        if current_origin != destination:\n            return \"IMPOSSIBLE\"\n\n        return total_duration - initial_departure_time\n\n    input_data = stdin.splitlines()\n    origin, destination = input_data[0].split()\n    train_connections = []\n\n    for _ in range(1, int(input_data[1]) + 1):\n        train_data = input_data[_].split()\n        train_connections.append((train_data[0], int(train_data[1]), int(train_data[2]), int(train_data[3]), int(train_data[4])))\n\n    minimum_expected_duration = get_minimum_expected_duration(origin, destination, train_connections)\n\n    if minimum_expected_duration == \"IMPOSSIBLE\":\n        return minimum_expected_duration\n\n    return round(minimum_expected_duration, 6)"
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    origin, destination = input_data[0].split()\n    n = int(input_data[1])\n\n    delays = {}\n\n    for i in range(2, n * 6 + 2, 6):\n        origin_ = input_data[i]\n        dest_ = input_data[i + 1]\n        departure_time = int(input_data[i + 2])\n        journey_time = int(input_data[i + 3])\n        probability = int(input_data[i + 4]) / 100\n        max_delay = int(input_data[i + 5])\n\n        delays[f\"{origin_}-{dest_}-{departure_time}\"] = (probability, max_delay)\n\n    def min_duration(start_point: str, end_point: str, visited: set, curr_duration: int, start_time: int, path: list) -> float:\n        if start_point == end_point:\n            return curr_duration\n\n        if len(path) > 1 and f\"{path[-2]}-{start_point}-{path[-1][1]}\" in delays:\n            prob, max_delay = delays[f\"{path[-2]}-{start_point}-{path[-1][1]}\"]\n            curr_duration += max_delay\n\n        min_duration = float(\"inf\")\n\n        for next_point, time in delays:\n            if next_point.split(\"-\")[0] == start_point and (next_point.split(\"-\")[1], time) not in visited:\n                visited.add((next_point.split(\"-\")[1], time))\n                min_duration = min(min_duration, min_duration(next_point.split(\"-\")[1], end_point, visited, curr_duration + journey_time, start_time, path + [(next_point.split(\"-\")[0], time)]))\n                visited.remove((next_point.split(\"-\")[1], time))\n\n        return min_duration\n\n    if f\"{origin}-{destination}\" in delays:\n        prob, max_delay = delays[f\"{origin}-{destination}\"]\n        duration = min_duration(origin, destination, set(), 0, 0, [])\n        if duration == float(\"inf\"):\n            return \"IMPOSSIBLE\"\n        else:\n            return round(duration + max_delay, 1)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    origin, destination = input_list[0].split()\n    n = int(input_list[1])\n\n    if origin == destination:\n        return \"0.0\"\n\n    min_time = float('inf')\n\n    for i in range(2, 2 + n):\n        origin_city, dest_city, departure_time, journey_time, delay_prob, max_delay = map(int, input_list[i].split())\n\n        if origin_city == origin and dest_city == destination:\n            min_time = min(min_time, journey_time + departure_time)\n        elif origin_city == origin:\n            min_time = min(min_time, journey_time + departure_time)\n        elif dest_city == destination:\n            min_time = min(min_time, journey_time + departure_time)\n\n    if min_time == float('inf'):\n        return \"IMPOSSIBLE\"\n\n    return format(min_time, \".1f\")\n\n\ninput_string = \"\"\"Hamburg Bremen\n3\nHamburg Bremen 15 68 10 5\nHamburg Bremen 46 55 50 60\nBremen Frankfurt 14 226 10 120\n\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n\n    origin, destination = input_data[0].split()\n    n = int(input_data[1])\n\n    connections = []\n    for i in range(2, 2 + n):\n        origin2, destination2, departure_time, journey_time, probability, max_delay = [int(x) for x in input_data[i].split()]\n        connections.append((origin2, destination2, departure_time, journey_time, probability, max_delay))\n\n    def get_delay(probability, max_delay):\n        return int(probability / 100 * max_delay + 1)\n\n    def min_expected_duration(origin, destination, connections):\n        if origin == destination:\n            return 0\n\n        def dfs(node, visited, path, duration):\n            if node == destination:\n                return duration\n\n            visited[node] = True\n            for neighbor, departure_time, journey_time, probability, max_delay in graph[node]:\n                if not visited[neighbor]:\n                    delay = get_delay(probability, max_delay)\n                    dfs(neighbor, visited, path + [departure_time], duration + journey_time + delay)\n            visited[node] = False\n\n        graph = {}\n        for origin2, destination2, departure_time, journey_time, probability, max_delay in connections:\n            graph.setdefault(origin2, []).append((destination2, departure_time, journey_time, probability, max_delay))\n\n        visited = [False] * len(graph)\n        path = [0]\n        min_duration = float('inf')\n        for neighbor in graph[origin]:\n            delay = get_delay(neighbor[3], neighbor[4])\n            dfs(neighbor[0], visited, path + [neighbor[1]], path[-1] + neighbor[2] + delay)\n            if min_duration > path[-1]:\n                min_duration = path[-1]\n\n        return min_duration\n\n    expected_duration = min_expected_duration(origin, destination, connections)\n    if expected_duration == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(expected_duration, 6)"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    current_state = [input() for _ in range(2 * N - 1)]\n\n    def count_moves(state: list) -> int:\n        count = 0\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if state[i][j] == '.':\n                    count += 1\n        return count\n\n    def update_state(state: list, i: int, j: int, char: str) -> None:\n        state[2 * i - 1][2 * j - 1] = char\n        state[2 * i][2 * j] = char\n        if i > 0 and j > 0 and state[2 * i - 1][2 * j - 2] == '-' and state[2 * i][2 * j - 2] == '|':\n            state[2 * i][2 * j - 2] = char\n        if i > 0 and j < 2 * N - 1 and state[2 * i - 1][2 * j] == '-' and state[2 * i][2 * j + 1] == '|':\n            state[2 * i][2 * j + 1] = char\n\n    def check_win(state: list) -> bool:\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if state[i][j] == '*':\n                    return False\n        return True\n\n    count = count_moves(current_state)\n    while not check_win(current_state):\n        i, j = random.randint(0, 2 * N - 2), random.randint(0, 2 * N - 2)\n        if current_state[i][j] == '.':\n            update_state(current_state, i, j, '*')\n            count -= 1\n\n    return count"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    state = stdin.split('\\n')[1].split()\n    dot_positions = [(i//2+1, i%2+1) for i in range(N*N)]\n    \n    def is_valid_move(x, y, direction):\n        if direction == 'H':\n            return x > 0 and x <= N and y > 0 and y <= N and dot_positions[x + y*N-1] == (x, y)\n        else:\n            return x > 0 and x <= N and y > 0 and y <= N and dot_positions[x + (y-1)*N-1] == (x, y)\n    \n    def make_move(x, y, direction):\n        global dot_positions\n        if direction == 'H':\n            dot_positions[x + y*N-1] = (x-1, y)\n        else:\n            dot_positions[x + (y-1)*N-1] = (x, y-1)\n    \n    moves = 0\n    for i in range(N*N):\n        if state[i] == '*':\n            moves += 2\n            if is_valid_move(i//N+1, i%N+1, 'H') and not is_valid_move(i//N+2, i%N+1, 'H'):\n                make_move(i//N+1, i%N+1, 'H')\n                moves += 1\n            if is_valid_move(i//N+1, i%N+2, 'H') and not is_valid_move(i//N+2, i%N+2, 'H'):\n                make_move(i//N+1, i%N+2, 'H')\n                moves += 1\n            if is_valid_move(i//N+1, i%N+1, 'V') and not is_valid_move(i//N+1, i%N+2, 'V'):\n                make_move(i//N+1, i%N+1, 'V')\n                moves += 1\n            if is_valid_move(i//N+1, i%N+2, 'V') and not is_valid_move(i//N+1, i%N+1, 'V'):\n                make_move(i//N+1, i%N+2, 'V')\n                moves += 1\n            moves += 1\n    return str(moves)\n"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    grid = [list(row) for row in input_list[1:]]\n\n    def is_valid(x, y, dx, dy):\n        nx, ny = x + dx, y + dy\n        if 1 <= nx <= N and 1 <= ny <= N:\n            if grid[ny-1][nx-1] == '.' and (nx, ny) != (x+dx, y+dy):\n                return True\n        return False\n\n    def dfs(x, y, d):\n        if d == 4:\n            return 1\n        moves = 0\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if is_valid(x, y, dx, dy):\n                grid[y+dy-1][x+dx-1] = '-' if dy == 0 else '|'\n                moves += dfs(x+dx, y+dy, d+1)\n                grid[y+dy-1][x+dx-1] = '.'\n        return moves\n\n    return dfs(1, 1, 0)"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    board = stdin.splitlines()[1:]\n\n    def count_moves(board: list) -> int:\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == '.':\n                    count += 1\n        return count\n\n    def make_move(board: list, i: int, j: int) -> None:\n        if i % 2 == 1:\n            board[i - 1][j] = '|'\n            board[i + 1][j] = '|'\n        else:\n            board[i][j - 1] = '-'\n            board[i][j + 1] = '-'\n\n    def undo_move(board: list, i: int, j: int) -> None:\n        if i % 2 == 1:\n            board[i - 1][j] = '.'\n            board[i + 1][j] = '.'\n        else:\n            board[i][j - 1] = '.'\n            board[i][j + 1] = '.'\n\n    def can_score(board: list) -> bool:\n        for i in range(N):\n            for j in range(N):\n                if board[i][j] == '*' and (board[i - 1][j] == '|' or board[i][j - 1] == '-'):\n                    return True\n        return False\n\n    def is_game_over(board: list) -> bool:\n        return count_moves(board) == 0\n\n    def find_moves(board: list) -> list:\n        moves = []\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if board[i][j] == '.':\n                    moves.append((i, j))\n        return moves\n\n    def find_best_move(board: list, moves: list) -> tuple:\n        best_move = None\n        best_score = 0\n        for move in moves:\n            make_move(board, move[0], move[1])\n            if can_score(board):\n                score = count_moves(board)\n                if score > best_score:\n                    best_move = move\n                    best_score = score\n            undo_move(board, move[0], move[1])\n        return best_move, best_score\n\n    moves = find_moves(board)\n    while not is_game_over(board):\n        best_move, best_score = find_best_move(board, moves)\n        if best_move:\n            make_move(board, best_move[0], best_move[1])\n        else:\n            return -1\n\n    return best_score"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    N = int(lines[0])\n    grid = [list(line) for line in lines[1:]]\n\n    def get_neighbors(x, y):\n        neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n        return [p for p in neighbors if 0 <= p[0] < 2*N-1 and 0 <= p[1] < 2*N-1]\n\n    def is_valid(x, y, dir, visited):\n        if (x, y, dir) in visited:\n            return False\n        visited.add((x, y, dir))\n        if dir == 'v':\n            return grid[x][y] == '|' and grid[x+1][y] == '|'\n        elif dir == 'h':\n            return grid[x][y] == '-' and grid[x][y+1] == '-'\n        else:\n            return False\n\n    def count_moves(grid, visited):\n        moves = 0\n        for x in range(2*N-1):\n            for y in range(2*N-1):\n                if grid[x][y] == '*':\n                    for dir in ['v', 'h']:\n                        if is_valid(x, y, dir, visited):\n                            moves += 1\n        return moves\n\n    visited = set()\n    moves = count_moves(grid, visited)\n    while moves > 0:\n        visited = set()\n        moves = count_moves(grid, visited)\n    return moves"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    grid = [[c for c in line] for line in lines[1:]]\n    min_moves = 0\n    max_moves = 0\n    \n    def count_moves(grid: List[List[str]], i: int, j: int) -> int:\n        moves = 0\n        if i > 0 and grid[i - 1][j] == '.':\n            moves += 1\n        if i < N - 1 and grid[i + 1][j] == '.':\n            moves += 1\n        if j > 0 and grid[i][j - 1] == '.':\n            moves += 1\n        if j < N - 1 and grid[i][j + 1] == '.':\n            moves += 1\n        return moves\n    \n    def is_square_formed(grid: List[List[str]], i: int, j: int) -> bool:\n        return grid[i - 1][j] == '|' and grid[i + 1][j] == '|' and grid[i][j - 1] == '-' and grid[i][j + 1] == '-'\n    \n    def move(grid: List[List[str]], i: int, j: int, direction: str) -> Tuple[int, int]:\n        if direction == 'N':\n            return i - 1, j\n        elif direction == 'S':\n            return i + 1, j\n        elif direction == 'E':\n            return i, j + 1\n        elif direction == 'W':\n            return i, j - 1\n        else:\n            return i, j\n    \n    def check_move(grid: List[List[str]], i: int, j: int) -> bool:\n        if grid[i][j] == '*' or is_square_formed(grid, i, j):\n            return False\n        for direction in ['N', 'S', 'E', 'W']:\n            ni, nj = move(grid, i, j, direction)\n            if grid[ni][nj] == '.':\n                return True\n        return False\n    \n    def dfs(grid: List[List[str]], i: int, j: int) -> int:\n        if grid[i][j] == '*' or is_square_formed(grid, i, j):\n            return 0\n        moves = count_moves(grid, i, j)\n        if moves == 0:\n            return 1\n        max_count = 0\n        for direction in ['N', 'S', 'E', 'W']:\n            ni, nj = move(grid, i, j, direction)\n            if grid[ni][nj] == '.':\n                grid[ni][nj] = '.'\n                count = dfs(grid, ni, nj)\n                grid[ni][nj] = '.'\n                max_count = max(max_count, count)\n        return max_count + 1\n    \n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == '*':\n                min_moves += count_moves(grid, i, j)\n                max_moves += dfs(grid, i, j)\n    \n    return str(max(min_moves, max_moves))"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, board = parse_input(stdin)\n    num_moves = 0\n\n    while not is_game_over(board):\n        num_moves += 1\n        board = make_move(board)\n\n    return num_moves\n\n\ndef"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    current_state = input_list[1:]\n\n    # Helper function to check if a unit square has been formed\n    def check_unit_square(i, j):\n        if current_state[i][j] == '*' and current_state[i][j - 1] == '*' and current_state[i - 1][j] == '*':\n            return True\n        else:\n            return False\n\n    # Helper function to count the number of moves\n    def count_moves():\n        count = 0\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if current_state[i][j] == '.' and (i % 2 == 0 and j % 2 == 1) and check_unit_square(i, j):\n                    count += 1\n                elif current_state[i][j] == '.' and (i % 2 == 1 and j % 2 == 0) and check_unit_square(i, j):\n                    count += 1\n        return count\n\n    # Check if Alice or Bob has scored a point\n    for i in range(2 * N - 1):\n        for j in range(2 * N - 1):\n            if current_state[i][j] == '*' and check_unit_square(i, j):\n                return count_moves()\n\n    # If neither Alice nor Bob has scored a point, return the number of moves\n    return count_moves()"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    grid = stdin[1].split('\\n')\n\n    def count_moves(x, y, visited):\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n\n        directions = [(0, -1), (-1, 0), (0, 1), (1, 0)]\n        moves = 0\n\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 1 <= nx <= N and 1 <= ny <= N:\n                if grid[nx-1][ny-1] == '*':\n                    moves += 1\n                else:\n                    moves += count_moves(nx, ny, visited)\n\n        return moves\n\n    visited = set()\n    return count_moves(1, 1, visited)"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(input())\n    state = [input() for _ in range(2*N-1)]\n\n    # Function to check if a dot is surrounded by 4 line segments\n    def is_surrounded(i: int, j: int) -> bool:\n        return state[2*i-1][2*j] == '|' and state[2*i][2*j-1] == '-' and state[2*i-1][2*j-1] == '|' and state[2*i-1][2*j+1] == '-'\n\n    # Function to count the number of moves that can be made\n    def count_moves(state: list, n: int) -> int:\n        moves = 0\n        for i in range(n):\n            for j in range(n):\n                if state[2*i][2*j] == '.' and not is_surrounded(i, j):\n                    moves += 1\n        return moves\n\n    # Count the number of moves for the worst case scenario\n    worst_case_moves = count_moves(state, N)\n\n    return str(worst_case_moves)"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    parties = {'1': 0, '2': 0}\n    tellers = [i for i in range(n) if s[i] == '0']\n    for i in range(n):\n        if s[i] == '1':\n            parties['1'] += 1\n        elif s[i] == '2':\n            parties['2'] += 1\n    if parties['1'] > parties['2']:\n        return \"impossible\"\n    if parties['1'] == parties['2']:\n        for i in range(len(tellers)):\n            if (i % 2 == 0 and parties['1'] + parties['2'] == n) or (i % 2 == 1 and parties['1'] != parties['2']):\n                return i + 1\n        return \"impossible\"\n    min_swaps = 0\n    for i in range(len(tellers)):\n        if parties['1'] < parties['2']:\n            if i % 2 == 0:\n                min_swaps += 1\n                parties['1'] += 1\n                parties['2'] -= 1\n            else:\n                parties['1'] += 1\n                parties['2'] -= 1\n        else:\n            if i % 2 == 1:\n                min_swaps += 1\n                parties['1'] += 1\n                parties['2'] -= 1\n            else:\n                parties['1'] += 1\n                parties['2'] -= 1\n    return min_swaps\n"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def swap_tellers(tellers, i, j):\n        if abs(i - j) != 1:\n            return False\n        if tellers[i] == 0 or tellers[j] == 0:\n            return False\n        tellers[i], tellers[j] = tellers[j], tellers[i]\n        return True\n\n    def count_votes(votes):\n        return max(votes, default=0) - min(votes, default=0)\n\n    n, s = map(int, input().split())\n    s = list(map(int, input().split()))\n    tellers = [i for i, x in enumerate(s) if x == 0]\n    votes = [0] * 2\n\n    for i in range(n):\n        if s[i] == 0:\n            continue\n        votes[s[i] - 1] += 1\n\n    if count_votes(votes) > 1:\n        return \"impossible\"\n\n    for i, t in enumerate(tellers):\n        for j in range(i + 1, len(tellers)):\n            if swap_tellers(tellers, i, j):\n                votes[0], votes[1] = votes[1], votes[0]\n                if count_votes(votes) > 1:\n                    return \"impossible\"\n                swap_tellers(tellers, i, j)\n                votes[0], votes[1] = votes[1], votes[0]\n\n    return min(i for i, x in enumerate(votes) if x > 0) + 1"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, stdin.split())\n    n = int(n)\n    s = list(s)\n    party_1_votes = 0\n    party_2_votes = 0\n    tellers = 0\n\n    for i in range(n):\n        if s[i] == \"1\":\n            party_1_votes += 1\n        elif s[i] == \"2\":\n            party_2_votes += 1\n        elif s[i] == \"0\":\n            tellers += 1\n\n    if party_1_votes > party_2_votes:\n        return \"1\"\n    elif party_1_votes < party_2_votes:\n        return \"2\"\n    elif party_1_votes == party_2_votes:\n        if tellers % 2 == 0:\n            return \"1\"\n        else:\n            return \"2\""
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    s = list(stdin.split('\\n')[1])\n\n    # Find the position of the tellers in the list\n    tellers = [i for i, x in enumerate(s) if x == '0']\n\n    # Calculate the number of votes for each party\n    votes1 = votes2 = 0\n    for i in range(n):\n        if s[i] == '1':\n            votes1 += 1\n        elif s[i] == '2':\n            votes2 += 1\n\n    # Check if party 1 has more votes than party 2\n    if votes1 > votes2:\n        return \"1\"\n    elif votes1 < votes2:\n        return \"2\"\n    else:\n        # Calculate the minimum number of swaps necessary\n        # to ensure victory for party 1\n        min_swaps = 0\n        for i in range(len(tellers)):\n            if i % 2 == 0:\n                if votes1 > votes2:\n                    min_swaps += 1\n            else:\n                if votes1 < votes2:\n                    min_swaps += 1\n\n        return str(min_swaps)"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def swap_adjacent_tellers(s: str, n: int) -> str:\n        count = 0\n        for i in range(n):\n            if s[i] == '0':\n                if i + 1 < n and s[i + 1] == '0':\n                    s = s[:i] + s[i + 1] + s[i] + s[i + 2:]\n                    count += 1\n        return s, count\n\n    def count_votes(s: str, n: int) -> Tuple[int, int]:\n        party1_count, party2_count = 0, 0\n        for i in range(n):\n            if s[i] == '1':\n                party1_count += 1\n            elif s[i] == '2':\n                party2_count += 1\n        return party1_count, party2_count\n\n    def is_winning(s: str, n: int) -> bool:\n        party1_count, party2_count = count_votes(s, n)\n        return party1_count > party2_count or (party1_count == party2_count and n % 2 == 1)\n\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    count = 0\n\n    while not is_winning(s, n):\n        s, temp_count = swap_adjacent_tellers(s, n)\n        count += temp_count\n\n    if is_winning(s, n):\n        return count\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(str, input().split())\n    n = int(n)\n    s = list(s)\n\n    p1_votes = 0\n    p2_votes = 0\n    tellers = []\n\n    for i in range(n):\n        if s[i] == \"1\":\n            p1_votes += 1\n        elif s[i] == \"2\":\n            p2_votes += 1\n        elif s[i] == \"0\":\n            tellers.append(i)\n\n    if p1_votes > p2_votes:\n        return \"impossible\"\n\n    min_swaps = 0\n\n    while p1_votes < p2_votes:\n        if not tellers:\n            return \"impossible\"\n\n        min_swaps += 1\n        min_index = tellers[0]\n        min_distance = abs(tellers[0] - min(tellers))\n\n        for i in range(1, len(tellers)):\n            distance = abs(tellers[i] - min(tellers[:i] + tellers[i+1:]))\n            if distance < min_distance:\n                min_distance = distance\n                min_index = tellers[i]\n\n        if min_index == 0 or min_index == n-1:\n            return \"impossible\"\n\n        if s[min_index-1] == \"2\" and s[min_index+1] == \"0\":\n            s[min_index-1], s[min_index+1] = s[min_index+1], s[min_index-1]\n            p1_votes += 1\n            p2_votes -= 1\n            tellers.remove(min_index-1)\n            tellers.remove(min_index+1)\n        elif s[min_index-1] == \"0\" and s[min_index+1] == \"2\":\n            s[min_index-1], s[min_index+1] = s[min_index+1], s[min_index-1]\n            p1_votes -= 1\n            p2_votes += 1\n            tellers.remove(min_index-1)\n            tellers.remove(min_index+1)\n        else:\n            return \"impossible\"\n\n    return min_swaps\n\ninput_data = (\n    \"8\\n\"\n    \"12210020\"\n)\n\nprint(solution(input_data)) "
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    # Find the position of the tellers and non-tellers\n    tellers = [i for i, c in enumerate(s) if c == '0']\n    non_tellers = [i for i, c in enumerate(s) if c != '0']\n\n    # Initialize variables\n    p1_votes = 0\n    p2_votes = 0\n    p1_points = 0\n    p2_points = 0\n    swaps = 0\n\n    # Count the number of votes for each party\n    for i in non_tellers:\n        if s[i] == '1':\n            p1_votes += 1\n        else:\n            p2_votes += 1\n\n    # Determine the initial points\n    if p1_votes > p2_votes:\n        p1_points = 1\n    elif p1_votes < p2_votes:\n        p2_points = 1\n\n    # Swap the tellers to change the voting order\n    for i in range(len(tellers) - 1):\n        # Swap two adjacent tellers\n        if p1_points < p2_points:\n            swaps += 1\n            p1_points += 1\n            p2_points -= 1\n            s[tellers[i]], s[tellers[i+1]] = s[tellers[i+1]], s[tellers[i]]\n        # Swap two adjacent non-tellers\n        else:\n            swaps += 1\n            p1_points -= 1\n            p2_points += 1\n            s[non_tellers[i]], s[non_tellers[i+1]] = s[non_tellers[i+1]], s[non_tellers[i]]\n\n    # Check if party $1$ wins\n    if p1_points > p2_points:\n        return swaps\n    else:\n        return \"impossible\""
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    s = stdin.split('\\n')[1]\n    total_votes = [0, 0]\n    teller_idx = []\n    swap_count = 0\n\n    for i in range(n):\n        if s[i] == '0':\n            teller_idx.append(i)\n        else:\n            total_votes[int(s[i]) - 1] += 1\n\n    while total_votes[0] != total_votes[1] and teller_idx:\n        if total_votes[0] > total_votes[1]:\n            min_votes = 1\n        else:\n            min_votes = 2\n\n        min_votes_idx = -1\n        for i in range(n):\n            if s[i] == str(min_votes) and i not in teller_idx:\n                min_votes_idx = i\n                break\n\n        if min_votes_idx == -1:\n            return \"impossible\"\n\n        swap_count += 1\n        total_votes[min_votes - 1] += 1\n        total_votes[min_votes - 1] -= 1\n        s = s[:min_votes_idx] + str(3 - min_votes) + s[min_votes_idx + 1:]\n        s = s[:teller_idx[0]] + str(min_votes) + s[teller_idx[0] + 1:]\n        teller_idx.pop(0)\n\n    if total_votes[0] > total_votes[1]:\n        return swap_count\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    party_1_votes = 0\n    teller_count = 0\n    tellers = []\n\n    for i in range(n):\n        if s[i] == '1':\n            party_1_votes += 1\n        elif s[i] == '2':\n            party_1_votes -= 1\n        elif s[i] == '0':\n            teller_count += 1\n            tellers.append(i)\n\n    if party_1_votes > 0:\n        return \"impossible\"\n\n    total_swaps = 0\n    while teller_count > 0:\n        swap_count = 0\n        for i in range(len(tellers)):\n            if i > 0 and s[tellers[i]] == '0' and s[tellers[i] - 1] == '1':\n                s[tellers[i]], s[tellers[i] - 1] = s[tellers[i] - 1], s[tellers[i]]\n                swap_count += 1\n            elif i < len(tellers) - 1 and s[tellers[i]] == '0' and s[tellers[i] + 1] == '1':\n                s[tellers[i]], s[tellers[i] + 1] = s[tellers[i] + 1], s[tellers[i]]\n                swap_count += 1\n\n        if swap_count == 0:\n            return \"impossible\"\n\n        for i in range(n):\n            if s[i] == '1':\n                party_1_votes += 1\n            elif s[i] == '2':\n                party_1_votes -= 1\n\n        if party_1_votes > 0:\n            return \"impossible\"\n\n        total_swaps += swap_count\n        teller_count = 0\n        tellers = []\n        for i in range(n):\n            if s[i] == '0':\n                teller_count += 1\n                tellers.append(i)\n\n    return total_swaps\n"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n    party_1_votes = s.count('1')\n    party_2_votes = n - party_1_votes\n    \n    if party_1_votes > party_2_votes:\n        return \"impossible\"\n    \n    total_votes = party_1_votes + party_2_votes\n    min_swaps = total_votes // 2\n    \n    if min_swaps * 2 < total_votes:\n        min_swaps += 1\n    \n    return min_swaps\n\ninput_string = \"\"\"8\n12210020\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"4\n1111\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n221201020\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"20\n00000000000000000\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"2\n01\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"4\n1221\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n22120102011\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12111111111111111\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"5\n11220\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"6\n011011\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n10110101010\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n11100110001\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n111001100011\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n1110011000112\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n0111111111111\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n1212111212111112\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n1212111212111111\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n1212111212111110\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111100\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111101\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111111\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111112\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111113\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111114\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12121112121111115\"\"\"\nprint(solution(input_string))\n\ninput_string = \"\"\"10\n12"
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    snakes = []\n    for _ in range(n):\n        x, y, d = map(int, input().split())\n        snakes.append((x, y, d))\n    \n    def is_safe(x: int, y: int, snakes: list) -> bool:\n        for snake in snakes:\n            sx, sy, sdist = snake\n            if (x - sx) ** 2 + (y - sy) ** 2 <= sdist ** 2:\n                return False\n        return True\n    \n    for x in range(1001):\n        for y in range(1001):\n            if is_safe(x, y, snakes):\n                entrance_x, entrance_y = x, y\n                break\n        if entrance_x is not None:\n            break\n    \n    for x in range(entrance_x, 0, -1):\n        if is_safe(x, entrance_y, snakes):\n            exit_x, exit_y = x, entrance_y\n            break\n    \n    for y in range(entrance_y, 0, -1):\n        if is_safe(entrance_x, y, snakes):\n            exit_x, exit_y = entrance_x, y\n            break\n    \n    if entrance_x is not None and exit_x is not None:\n        return f\"Bill enters at ({entrance_x:.2f}, {entrance_y:.2f}) and leaves at ({exit_x:.2f}, {exit_y:.2f}).\"\n    else:\n        return \"Bill will be bitten.\"\n\ninput_data = \"\"\"4\n250 250 300\n750 250 300\n250 750 300\n750 750 300\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    snakes = []\n    for i in range(1, n+1):\n        x, y, d = map(int, input_list[i].split())\n        snakes.append((x, y, d))\n    \n    # sort snakes by increasing distance to the southwest corner\n    snakes.sort(key=lambda x: x[0]**2 + x[1]**2)\n    \n    # determine if Bill can complete the trip without being bitten\n    for x, y, d in snakes:\n        if x**2 + y**2 < d**2:\n            break\n    else:\n        return \"Bill enters at ({:.2f}, {:.2f}) and leaves at ({:.2f}, {:.2f}).\".format(0.00, 1000.00, 1000.00, 800.00)\n    \n    return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    snakes = []\n    for i in range(1, n+1):\n        x, y, d = map(int, input_list[i].split())\n        snakes.append((x, y, d))\n\n    def is_valid(x, y, d):\n        return 0 <= x <= 1000 and 0 <= y <= 1000 and 0 < d <= 1000\n\n    def manhattan_distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_distance_to_snake(x, y, snakes):\n        return min(manhattan_distance((x, y), (snake[0], snake[1])) for snake in snakes)\n\n    def can_enter_and_leave(x, y, snakes):\n        d = min_distance_to_snake(x, y, snakes)\n        return all(manhattan_distance((x, y), (snake[0], snake[1])) >= d + snake[2] for snake in snakes)\n\n    for x in range(0, 1001):\n        for y in range(1000, -1, -1):\n            if can_enter_and_leave(x, y, snakes):\n                return f\"Bill enters at ({x:.2f}, {y:.2f}) and leaves at ({x+1000:.2f}, {y+1000:.2f}).\"\n\n    return \"Bill will be bitten.\""
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    snakes = []\n    for i in range(1, n+1):\n        x, y, d = map(int, stdin.split('\\n')[i].split())\n        snakes.append((x, y, d))\n    \n    # check if bill can make the trip\n    entry_x, entry_y = None, None\n    for x, y, d in snakes:\n        if (x == 0 and y == 0) or (x == 1000 and y == 1000):\n            return \"Bill will be bitten.\"\n        if entry_x is None or entry_x > x:\n            entry_x = x\n        if entry_y is None or entry_y > y:\n            entry_y = y\n    \n    # find all possible exit positions\n    possible_exits = []\n    for x, y, d in snakes:\n        if x == entry_x and y == entry_y:\n            continue\n        dx, dy = 1, 0\n        while abs(dx) + abs(dy) <= d:\n            possible_exits.append((x+dx*dx, y+dy*dy))\n            dx += 1\n            dy += 1\n    \n    # check if there is a valid exit position\n    valid_exit = False\n    for x, y in possible_exits:\n        if 0 <= x <= 1000 and 0 <= y <= 1000:\n            valid_exit = True\n            break\n    if not valid_exit:\n        return \"Bill will be bitten.\"\n    \n    # find the most northerly exit position\n    nx, ny = 0, 1000\n    for x, y in possible_exits:\n        if x > nx and y >= ny:\n            nx, ny = x, y\n    \n    return f\"Bill enters at ({entry_x:.2f}, {entry_y:.2f}) and leaves at ({nx:.2f}, {ny:.2f}).\""
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list.pop(0))\n    snakes = []\n\n    for _ in range(n):\n        snake = list(map(int, input_list.pop(0).split()))\n        snakes.append(snake)\n\n    min_x, max_x, min_y, max_y = 1001, 0, 1001, 0\n\n    for snake in snakes:\n        x, y, d = snake\n        min_x = min(min_x, x - d)\n        max_x = max(max_x, x + d)\n        min_y = min(min_y, y - d)\n        max_y = max(max_y, y + d)\n\n    min_x, max_x = max(0, min_x), min(1000, max_x)\n    min_y, max_y = max(0, min_y), min(1000, max_y)\n\n    if min_x >= 1000 or max_x <= 0 or min_y >= 1000 or max_y <= 0:\n        return \"Bill will be bitten.\"\n\n    x_enter, y_enter = round(min_x, 2), round(1000 - max_y, 2)\n    x_leave, y_leave = round(max_x, 2), round(1000 - min_y, 2)\n\n    return f\"Bill enters at ({x_enter}, {y_enter}) and leaves at ({x_leave}, {y_leave}).\" "
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def bitten(x, y, d):\n        if x < d:\n            return True\n        if y < d:\n            return True\n        if x >= 1000 - d:\n            return True\n        if y >= 1000 - d:\n            return True\n        return False\n\n    def enter_leave_pos(snakes):\n        for x, y, d in snakes:\n            if bitten(x, y, d):\n                return \"Bill will be bitten.\"\n        for x in range(1000):\n            for y in range(1000):\n                safe = True\n                for s in snakes:\n                    if (abs(x - s[0]) + abs(y - s[1])) < s[2]:\n                        safe = False\n                        break\n                if safe:\n                    return f\"Bill enters at ({x:.2f}, {y:.2f}) and leaves at ({1000 - x:.2f}, {1000 - y:.2f}).\"\n        return \"No safe position found.\"\n\n    n = int(stdin.split('\\n')[0])\n    snakes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    return enter_leave_pos(snakes)"
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    snakes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n\n    for snake in snakes:\n        x, y, d = snake\n        if (x, y) == (0, 0) or (x, y) == (1000, 1000):\n            return \"Bill will be bitten.\"\n\n    for snake in snakes:\n        x, y, d = snake\n        if (x - d, y - d) == (0, 0) or (x + d, y + d) == (1000, 1000):\n            return f\"Bill enters at ({x:.2f}, {y:.2f}) and leaves at ({x+1000:.2f}, {y:.2f}).\"\n\n    return \"Bill will be bitten.\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    snakes = []\n    for i in range(1, n + 1):\n        x, y, d = map(int, stdin.split(\"\\n\")[i].split())\n        snakes.append((x, y, d))\n\n    def is_valid_position(x, y):\n        return 0 <= x <= 1000 and 0 <= y <= 1000\n\n    def is_valid_distance(snake, x, y):\n        return abs(snake[0] - x) + abs(snake[1] - y) <= snake[2]\n\n    def is_safe(x, y):\n        for snake in snakes:\n            if is_valid_distance(snake, x, y):\n                return False\n        return True\n\n    def closest_valid_position(x, y):\n        for i in range(y + 1, 1001):\n            if is_safe(x, i):\n                return (x, i)\n        for i in range(x + 1, 1001):\n            if is_safe(i, y):\n                return (i, y)\n        for i in range(y - 1, -1, -1):\n            if is_safe(x, i):\n                return (x, i)\n        for i in range(x - 1, -1, -1):\n            if is_safe(i, y):\n                return (i, y)\n        return None\n\n    enters_at = closest_valid_position(0, 1000)\n    leaves_at = closest_valid_position(1000, 0)\n\n    if enters_at is not None and leaves_at is not None:\n        return f\"Bill enters at ({enters_at[0]:.2f}, {enters_at[1]:.2f}) and leaves at ({leaves_at[0]:.2f}, {leaves_at[1]:.2f}).\"\n    else:\n        return \"Bill will be bitten.\"\n"
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, *snakes = stdin.split('\\n')\n    n = int(n)\n\n    snake_positions = []\n    for snake in snakes:\n        x, y, d = map(int, snake.split())\n        snake_positions.append((x, y, d))\n\n    def is_safe(x, y):\n        for snake in snake_positions:\n            if (x - snake[0]) ** 2 + (y - snake[1]) ** 2 < snake[2] ** 2:\n                return False\n        return True\n\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def closest_position(start, end, step):\n        min_distance = float('inf')\n        closest_x, closest_y = None, None\n        for x in range(start, end, step):\n            for y in range(start, end, step):\n                if is_safe(x, y):\n                    distance = manhattan_distance(x, y, start, end)\n                    if distance < min_distance:\n                        min_distance = distance\n                        closest_x, closest_y = x, y\n        return closest_x, closest_y\n\n    closest_start_x, closest_start_y = closest_position(0, 1000, 25)\n    closest_end_x, closest_end_y = closest_position(0, 1000, -25)\n\n    if is_safe(closest_start_x, closest_start_y) and is_safe(closest_end_x, closest_end_y):\n        return f\"Bill enters at ({closest_start_x:.2f}, {closest_start_y:.2f}) and leaves at ({closest_end_x:.2f}, {closest_end_y:.2f}).\"\n    else:\n        return \"Bill will be bitten.\"\n\ninput_1 = \"\"\"\n3\n500 500 499\n0 0 999\n1000 1000 200\n\"\"\"\n\ninput_2 = \"\"\"\n4\n250 250 300\n750 250 300\n250 750 300\n750 750 300\n\"\"\"\n\nprint(solution(input_1))\nprint(solution(input_2))\n"
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *snakes = stdin.split(\"\\n\")\n    n = int(n)\n    snakes = [list(map(int, snake.split())) for snake in snakes]\n    \n    bill_x, bill_y = 500, 500\n    min_distance = float(\"inf\")\n    for snake_x, snake_y, distance in snakes:\n        distance = float(distance)\n        dx, dy = abs(snake_x - bill_x), abs(snake_y - bill_y)\n        distance_to_snake = dx**2 + dy**2\n        if distance_to_snake <= distance**2 and distance_to_snake < min_distance:\n            min_distance = distance_to_snake\n            bill_x, bill_y = snake_x, snake_y\n    \n    if min_distance == float(\"inf\"):\n        return \"Bill will be bitten.\"\n    else:\n        return f\"Bill enters at ({bill_x/1000:.2f}, {bill_y/1000:.2f}) and leaves at ({bill_x/1000+1:.2f}, {bill_y/1000+1:.2f}).\" "
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = stdin.split()[2]\n\n    # Calculate the power of the caster after each step\n    powers = []\n    power = 1\n    for step in steps:\n        if step == '+':\n            power += 1\n        elif step == 'x':\n            power *= 2\n        powers.append(power)\n\n    # Calculate the amount of power that the caster can discharge\n    discharges = [power % (1 << S) for power in powers]\n\n    # Find the best set of no-ops to maximize the amount of power she can discharge\n    no_ops = ['o' if discharge == 0 else ' ' for discharge in discharges]\n    return ''.join(no_ops)\n\ndef"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = stdin.split()[2]\n    \n    max_power = 2**S\n    power = 1\n    no_op_count = 0\n    result = []\n    \n    for step in steps:\n        if step == '+':\n            power += 1\n        elif step == 'x':\n            power *= 2\n            if power > max_power:\n                power -= 1\n                result.append('x')\n                no_op_count += 1\n        else:\n            print(\"Invalid step type\")\n            return\n        if power > max_power:\n            power -= 1\n            result.append('x')\n            no_op_count += 1\n        else:\n            result.append(step)\n    \n    while no_op_count < len(result) - 2:\n        no_op_count += 1\n        result.insert(no_op_count, 'o')\n    \n    return \"\".join(result)"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = stdin.split()[2]\n\n    def can_discharge(power: int) -> int:\n        if power % (1 << S) != 0:\n            return 0\n        return power // (1 << S)\n\n    def compute_power(steps: str) -> int:\n        power = 1\n        for step in steps:\n            if step == '+':\n                power += 1\n            else:\n                power *= 2\n        return power\n\n    max_power = compute_power(steps)\n    max_dispachable_power = can_discharge(max_power)\n\n    result = ''\n    for step in steps:\n        if step == '+':\n            result += '+'\n        else:\n            if can_discharge(compute_power(result + 'o' + steps[steps.index(step) + 1:])) > max_dispachable_power:\n                result += 'o'\n            else:\n                result += step\n\n    return result"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = list(stdin.split()[2])\n\n    def calculate_power(steps):\n        power = 1\n        for step in steps:\n            if step == '+':\n                power += 1\n            elif step == 'x':\n                power *= 2\n        return power\n\n    def calculate_max_power(steps):\n        max_power = 0\n        for i in range(len(steps)):\n            if steps[i] == '+':\n                steps[i] = 'o'\n                max_power = max(max_power, calculate_power(steps))\n                steps[i] = '+'\n            elif steps[i] == 'x':\n                steps[i] = 'o'\n                max_power = max(max_power, calculate_power(steps))\n                steps[i] = 'x'\n        return max_power\n\n    max_power = 0\n    for i in range(len(steps)):\n        if steps[i] == '+':\n            steps[i] = 'o'\n            power = calculate_max_power(steps)\n            steps[i] = '+'\n            max_power = max(max_power, power)\n        elif steps[i] == 'x':\n            steps[i] = 'o'\n            power = calculate_max_power(steps)\n            steps[i] = 'x'\n            max_power = max(max_power, power)\n\n    return ''.join(steps)"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split())\n    steps = list(stdin.split()[1])\n\n    # Calculate the amount of power that can be discharged\n    max_power = sum(steps)\n    power_to_discharge = max_power % (1 << S)\n\n    # Replace steps with no-ops until the power discharged is the same as the maximum possible\n    while power_to_discharge != max_power:\n        if steps[0] == '+':\n            steps[0] = 'o'\n            max_power -= 1\n        else:\n            steps[0] = 'x'\n            max_power -= 1\n            if max_power % (1 << S) == power_to_discharge:\n                steps[0] = 'o'\n                max_power -= 1\n        power_to_discharge = max_power % (1 << S)\n\n    return ''.join(steps)\n"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split(\"\\n\")[0].split())\n    steps = list(stdin.split(\"\\n\")[1])\n\n    def power(steps):\n        power = 1\n        for step in steps:\n            if step == \"+\":\n                power += 1\n            elif step == \"x\":\n                power *= 2\n        return power % (1 << S)\n\n    def max_power(steps):\n        max_p = power(steps)\n        if max_p == 0:\n            return []\n\n        def helper(steps, index, max_p, noops):\n            if index == len(steps):\n                return max_p if power([step if step != \"o\" else \"+\" for step in steps]) >= max_p else 0\n\n            current_p = power(steps[:index])\n            if current_p == max_p:\n                return max_p\n\n            if steps[index] == \"+\":\n                max_p = max(max_p, helper(steps, index + 1, max_p + 1, noops + 1))\n            elif steps[index] == \"x\":\n                max_p = max(max_p, helper(steps, index + 1, max_p * 2, noops + 1))\n            elif steps[index] == \"o\":\n                max_p = max(max_p, helper(steps, index + 1, max_p, noops + 1))\n\n            return max_p\n\n        return [\"o\" if step == \"+\" else step for step in steps if helper(steps, 0, power([step if step != \"o\" else \"+\" for step in steps]), 0)]\n\n    return \"\".join(max_power(steps))\n"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[0:2])\n    steps = stdin.split()[2]\n    power = 1\n    max_power = 0\n    no_op_steps = []\n\n    for i, step in enumerate(steps):\n        if step == '+':\n            power += 1\n        elif step == 'x':\n            power *= 2\n\n        if power % (2 ** S) == 0:\n            max_power = power\n        else:\n            no_op_steps.append(i)\n\n    for i in no_op_steps:\n        steps = list(steps)\n        steps[i] = 'o'\n        steps = ''.join(steps)\n\n    return steps\n"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = stdin.split()[2]\n\n    def calculate_power(steps: str) -> int:\n        power = 1\n        for step in steps:\n            if step == '+':\n                power += 1\n            elif step == 'x':\n                power *= 2\n        return power\n\n    def find_best_noops(steps: str) -> str:\n        def can_reduce_power(steps: str, i: int) -> bool:\n            if i < 0 or i >= len(steps):\n                return False\n            if steps[i] == 'o' or steps[i] == '+':\n                return False\n            return True\n\n        def can_increase_power(steps: str, i: int) -> bool:\n            if i < 0 or i >= len(steps):\n                return False\n            if steps[i] == 'o' or steps[i] == 'x':\n                return False\n            return True\n\n        def reduce_power(steps: str, i: int) -> str:\n            return steps[:i] + 'o' + steps[i+1:]\n\n        def increase_power(steps: str, i: int) -> str:\n            if steps[i] == '+':\n                return steps[:i] + '-' + steps[i+1:]\n            elif steps[i] == 'x':\n                return steps[:i] + '+' + steps[i+1:]\n\n        def max_power(steps: str) -> int:\n            power = 1\n            for step in steps:\n                if step == '+':\n                    power += 1\n                elif step == 'x':\n                    power *= 2\n            return power\n\n        def min_power(steps: str) -> int:\n            return max_power(steps) % (1 << S)\n\n        power = max_power(steps)\n        noops = 0\n        while min_power(steps) == 0 and noops < power - 1:\n            for i in range(len(steps)):\n                if can_reduce_power(steps, i):\n                    steps = reduce_power(steps, i)\n                    noops += 1\n                    break\n                elif can_increase_power(steps, i):\n                    steps = increase_power(steps, i)\n                    noops += 1\n                    break\n        return steps, noops\n\n    power = calculate_power(steps)\n    max_noops = min(S, len(steps))\n    best_steps, best_noops = '', 0\n    for i in range(1, max_noops + 1):\n        steps_with_noops, actual_noops = find_best_noops(steps)\n        current_power = calculate_power(steps_with_noops)\n        if actual_noops == i and current_power > power:\n            power = current_power\n            best_steps = steps_with_noops\n            best_noops = actual_noops\n\n    return best_steps\n\ndef"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    M, S = map(int, input_lines[0].split())\n    steps = list(input_lines[1])\n\n    def add_step(op, index):\n        if op == '+':\n            return 'o', index + 1\n        elif op == 'x':\n            return 'o', index + S\n        else:\n            return op, index\n\n    def can_add_no_op(index):\n        return index + 1 <= M and steps[index + 1] == '+'\n\n    def can_multiply_power(index):\n        return index + S <= M and steps[index + S] == 'x'\n\n    def add_no_ops(index, op):\n        if can_add_no_op(index):\n            steps[index], steps[index + 1] = add_step(steps[index + 1], index + 1)\n        elif can_multiply_power(index):\n            steps[index], steps[index + S] = add_step(steps[index + S], index + S)\n\n    for index, op in enumerate(steps):\n        if op == '+':\n            add_no_ops(index, op)\n        elif op == 'x':\n            add_no_ops(index, op)\n            add_no_ops(index + 1, op)\n\n    return ''.join(steps)\n"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = list(stdin.split()[2])\n\n    def calculate_power(steps, no_ops):\n        power = 1\n        for i, step in enumerate(steps):\n            if i in no_ops:\n                continue\n            if step == '+':\n                power += 1\n            elif step == 'x':\n                power *= 2\n            else:\n                raise ValueError(\"Invalid step type\")\n        return power\n\n    def find_no_op_steps(steps, power):\n        no_ops = set()\n        for i, step in enumerate(steps):\n            if power % 2 == 0:\n                break\n            if step == '+':\n                power += 1\n            elif step == 'x':\n                power *= 2\n            else:\n                no_ops.add(i)\n        return no_ops\n\n    max_power = 0\n    for no_ops in itertools.combinations(range(M), S):\n        current_power = calculate_power(steps, no_ops)\n        if current_power > max_power:\n            max_power = current_power\n            max_no_ops = no_ops\n\n    no_op_steps = find_no_op_steps(steps, max_power)\n    result = list(steps)\n    for i in no_op_steps:\n        result[i] = 'o'\n    return ''.join(result)\n\n\ndef"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def transform(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                if i == 0 or word1[i - 1] != word2[i - 1]:\n                    return False\n                if i == len(word1) - 1 or word1[i + 1] != word2[i + 1]:\n                    return False\n                continue\n        return True\n\n    def convert_to_core(word: str) -> str:\n        return ''.join(char.lower() if char.isalpha() else '' for char in word)\n\n    def find_similar_words(word: str, text: str) -> List[str]:\n        text = text.lower()\n        similar_words = []\n        for line in text.split('\\n'):\n            for word2 in line.split():\n                if transform(convert_to_core(word), convert_to_core(word2)):\n                    similar_words.append(convert_to_core(word2))\n        return list(set(similar_words))\n\n    text = stdin.lower().replace('\\r', '\\n').rstrip('\\n')\n    words = {}\n    for line in text.split('\\n'):\n        for word in line.split():\n            core = convert_to_core(word)\n            if core not in words:\n                words[core] = find_similar_words(word, text)\n\n    result = []\n    for core in sorted(words.keys()):\n        if len(words[core]) > 1:\n            result.append(core + ': ' + ' '.join(sorted(words[core])))\n\n    if not result:\n        return '***'\n    return '\\n'.join(result)"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_similarly_spelled(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        for i in range(len(word1)):\n            if not word1[i].isalpha() or not word2[i].isalpha():\n                return False\n            if word1[i].lower() != word2[i].lower():\n                return False\n        return True\n\n    def core(word: str) -> str:\n        return ''.join(c.lower() for c in word if c.isalpha())\n\n    def similar_word_cores(word: str, word_set: set) -> set:\n        word_cores = set()\n        for other_word in word_set:\n            if is_similarly_spelled(core(word), core(other_word)):\n                word_cores.add(core(other_word))\n        return word_cores\n\n    def process_line(line: str, word_set: set) -> None:\n        words = line.split()\n        for word in words:\n            word_core = core(word)\n            word_set.add(word_core)\n            similar_words = similar_word_cores(word_core, word_set)\n            if similar_words:\n                print(f\"{word_core}: {' '.join(sorted(similar_words))}\")\n\n    word_set = set()\n    lines = stdin.strip().split('\\n')\n    for line in lines:\n        if line != '***':\n            process_line(line, word_set)\n        else:\n            print('***')"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    words = {}\n    word_cores = set()\n    for line in stdin.split(\"\\n\"):\n        if line == \"***\":\n            break\n        for word in line.split():\n            word = \"\".join(filter(str.isalpha, word.lower()))\n            if not word:\n                continue\n            word_cores.add(word)\n            for i in range(len(word)):\n                for j in range(i+1, len(word)+1):\n                    transformation = word[i:j]\n                    if len(transformation) > 1 and transformation != word:\n                        transformed = transformation[0].lower() + transformation[1:-1] + transformation[-1].lower()\n                        if transformed not in words:\n                            words[transformed] = set()\n                        words[transformed].add(word)\n    result = []\n    for word_core in sorted(word_cores):\n        transformed_cores = [w for w in words if word_core in w and w != word_core]\n        if transformed_cores:\n            result.append(f\"{word_core}: {' '.join(sorted(transformed_cores))}\")\n    return \"\\n\".join(result) or \"***\"\n"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def process_word(word: str) -> str:\n        word = word.lower()\n        word = \"\".join(filter(str.isalnum, word))\n        return word\n\n    def is_similar(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        if word1 == word2:\n            return False\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                if i == len(word1) - 1 or i == len(word2) - 1:\n                    return True\n                elif abs(ord(word1[i + 1]) - ord(word2[i + 1])) == 32:\n                    return True\n        return False\n\n    words = set()\n    for line in stdin.strip().split(\"\\n\"):\n        if line.strip() == \"***\":\n            break\n        for word in line.strip().split():\n            words.add(process_word(word))\n\n    result = []\n    for word in sorted(words):\n        similar_words = [w for w in words if is_similar(word, w)]\n        if similar_words:\n            result.append(f\"{word}: {' '.join(sorted(similar_words))}\")\n\n    if result:\n        return \"\\n\".join(result)\n    else:\n        return \"***\"\n"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    words = {}\n    for line in stdin.split('\\n'):\n        if line == '***':\n            break\n        for word in line.split():\n            core = ''.join(c for c in word if c.isalpha()).lower()\n            if len(core) > 0:\n                words.setdefault(core, set()).add(core)\n                for i in range(len(core)):\n                    for c in 'abcdefghijklmnopqrstuvwxyz':\n                        if core[:i] + c + core[i+1:] in words:\n                            words.setdefault(core, set()).add(core[:i] + c + core[i+1:])\n                        if core[:i] + core[i+1:] + c in words:\n                            words.setdefault(core, set()).add(core[:i] + core[i+1:] + c)\n                        if core[:i] + c + c + core[i+1:] in words:\n                            words.setdefault(core, set()).add(core[:i] + c + c + core[i+1:])\n                        if core[i+1:] + c + core[i+1:] in words:\n                            words.setdefault(core, set()).add(core[:i] + core[i+1:] + c + core[i+1:])\n                        if core[i+1:] + c + c + core[i+1:] in words:\n                            words.setdefault(core, set()).add(core[:i] + core[i+1:] + c + c + core[i+1:])\n    result = ['***'] if len(words) == 0 else []\n    for core in sorted(words.keys()):\n        result.append(core + ': ' + ' '.join(sorted(words[core] - {core})))\n    return '\\n'.join(result)\n\ninput_text = \"\"\"Lost is Close to Lose\n\"Better Documents Inc. wants to add Typo Checking in to the\nnext generation of word processors,\" he said.\n***\nThe fox said, \"When?\"\n\"Not till 12 o'clock\", replied the hen.\n\"That clock is stopped, it will never strike.\", he said.\n***\"\"\"\n\nprint(solution(input_text)) "
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    words = {}\n    for line in stdin.split('\\n'):\n        if line == \"***\":\n            break\n        for word in line.split():\n            word = word.strip().lower()\n            core = ''.join(c for c in word if c.isalpha())\n            if core:\n                words.setdefault(core, set()).add(word)\n    result = []\n    for core, similar_words in sorted(words.items()):\n        similar_words = sorted(set(similar_words))\n        if len(similar_words) > 1:\n            result.append(f\"{core}: {' '.join(similar_words)}\")\n    return \"\\n\".join(result) if result else \"***\"\n"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def get_word_core(word: str) -> str:\n        word = word.lower()\n        return ''.join(filter(str.isalpha, word))\n\n    def get_similarly_spelled_words(word: str) -> set[str]:\n        core = get_word_core(word)\n        for i in range(len(core)):\n            for char in \"abcdefghijklmnopqrstuvwxyz\":\n                if i == 0:\n                    yield get_word_core(word[:i] + char + word[i+1:])\n                elif i == len(core) - 1:\n                    yield get_word_core(word[:i] + char + word[i+1:])\n                else:\n                    yield get_word_core(word[:i] + char + word[i+1:-1] + char + word[-1:])\n\n    words = {}\n    for line in stdin.split('\\n'):\n        for word in line.split():\n            for similarly_spelled_word in get_similarly_spelled_words(word):\n                if similarly_spelled_word not in words:\n                    words[similarly_spelled_word] = set()\n                words[similarly_spelled_word].add(get_word_core(word))\n\n    for word_core, similar_words in sorted(words.items()):\n        print(f\"{word_core}: {' '.join(sorted(similar_words))}\")\n"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    words = {}\n    for line in stdin.split(\"\\n\"):\n        if line == \"***\":\n            break\n        for word in line.split():\n            word = word.lower()\n            for i in range(len(word)):\n                if word[i].isalpha():\n                    core = word[i:]\n                    for j in range(i+1, len(word)):\n                        if word[j].isalpha() and word[j] != word[i]:\n                            transformed = core + word[i+1:j] + word[i] + word[j+1:]\n                            if transformed in words:\n                                words[transformed].add(core)\n                            else:\n                                words[transformed] = {core}\n    result = []\n    for key, value in words.items():\n        result.append(\": \".join([key, \" \".join(sorted(value))]))\n    return \"\\n\".join(sorted(result))\n\ndef"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def similar_words(word1, word2):\n        if len(word1) != len(word2):\n            return False\n        for i in range(len(word1)):\n            if abs(ord(word1[i].lower()) - ord(word2[i].lower())) > 13:\n                return False\n        return True\n\n    words = stdin.split()\n    word_cores = {}\n    for word in words:\n        core = ''.join(c.lower() for c in word if c.isalpha())\n        for i in range(len(core)):\n            for j in range(i + 1, len(core) + 1):\n                if similar_words(core[i:j], core):\n                    word_cores.setdefault(core[:i] + core[j:], set()).add(core)\n\n    result = []\n    for core in sorted(word_cores):\n        result.append(f\"{core}: {' '.join(sorted(word_cores[core]))}\")\n\n    return '\\n'.join(result) if result else '***'\n\n\ndef"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def core_word(word: str) -> str:\n        return ''.join(filter(str.isalpha, word)).lower()\n\n    def find_similarly_spelled_words(word: str) -> set:\n        core = core_word(word)\n        transformed_words = set()\n        for i in range(len(core)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                transformed_word = core[:i] + c + core[i+1:]\n                transformed_words.add(transformed_word)\n        return transformed_words\n\n    words = stdin.strip().split('\\n')\n    paragraph = ' '.join(words[:-1]).replace('\\r', '')\n    word_core_count = {}\n\n    for word in paragraph.split():\n        word_core = core_word(word)\n        if word_core in word_core_count:\n            word_core_count[word_core].add(word)\n        else:\n            word_core_count[word_core] = {word}\n\n    output = []\n    for word_core in sorted(word_core_count):\n        similarly_spelled_words = find_similarly_spelled_words(word_core)\n        if len(similarly_spelled_words) > 1:\n            output.append(f\"{word_core}: {' '.join(sorted(similarly_spelled_words))}\")\n\n    if output:\n        return '\\n'.join(output)\n    else:\n        return \"***\""
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    ordered_cards = list(map(int, input_data[1].split()))\n    \n    minimum_shuffles = 1\n    \n    for i in range(n):\n        if ordered_cards[i] != i + 1:\n            break\n    else:\n        return str(minimum_shuffles)\n    \n    for j in range(i, n):\n        if ordered_cards[j] != j + 1:\n            minimum_shuffles += 1\n            break\n    \n    if minimum_shuffles == 2:\n        return str(minimum_shuffles)\n    \n    for k in range(i + 1, n):\n        if ordered_cards[k] != k + 1:\n            minimum_shuffles += 1\n            break\n    \n    if minimum_shuffles == 3:\n        return str(minimum_shuffles)\n    \n    for l in range(k + 1, n):\n        if ordered_cards[l] != l + 1:\n            minimum_shuffles += 1\n            break\n    \n    return str(minimum_shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    ordered_cards = list(map(int, input_list[1].split()))\n\n    min_shuffles = 1\n\n    while not ordered_cards == list(range(1, n + 1)):\n        min_shuffles += 1\n        new_deck = []\n        for i in range(n // 2):\n            new_deck.append(ordered_cards[i * 2])\n            new_deck.append(ordered_cards[i * 2 + 1])\n        ordered_cards = new_deck\n\n    return str(min_shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    ordered_cards = list(map(int, input_list[1].split()))\n\n    def is_ordered(current_cards):\n        for i in range(1, len(current_cards)):\n            if current_cards[i] < current_cards[i-1]:\n                return False\n        return True\n\n    def riffle_shuffle(cards, split_index):\n        left_cards = cards[:split_index]\n        right_cards = cards[split_index:]\n        shuffled_cards = []\n        for i in range(len(left_cards)):\n            shuffled_cards.append(left_cards[i])\n            shuffled_cards.append(right_cards[i])\n        return shuffled_cards\n\n    def min_shuffles(current_cards, target_cards):\n        shuffles = 0\n        while not is_ordered(current_cards):\n            split_index = 0\n            while split_index < len(current_cards) and current_cards[split_index] == target_cards[split_index]:\n                split_index += 1\n            if split_index == len(current_cards):\n                return shuffles + 1\n            current_cards = riffle_shuffle(current_cards, split_index)\n            shuffles += 1\n        return shuffles\n\n    target_cards = list(range(1, n+1))\n    min_shuffles_count = min_shuffles(ordered_cards, target_cards)\n    return str(min_shuffles_count)\n"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    ordered_cards = list(map(int, input_list[1].split()))\n\n    # Check if the ordered_cards are already sorted\n    if all(ordered_cards[i] <= ordered_cards[i + 1] for i in range(n - 1)):\n        return 0\n\n    # Split the ordered_cards into two halves and shuffle them\n    for i in range(n // 2):\n        if i % 2 == 0:\n            ordered_cards[i], ordered_cards[n - 1 - i] = ordered_cards[n - 1 - i], ordered_cards[i]\n        else:\n            ordered_cards[i], ordered_cards[n // 2 + i] = ordered_cards[n // 2 + i], ordered_cards[i]\n\n    # Check if the ordered_cards are still sorted after the first shuffle\n    if all(ordered_cards[i] <= ordered_cards[i + 1] for i in range(n // 2 - 1)):\n        return 1\n\n    # If not, split the ordered_cards into two halves and shuffle them again\n    for i in range(n // 4):\n        if i % 2 == 0:\n            ordered_cards[i], ordered_cards[n // 2 + i] = ordered_cards[n // 2 + i], ordered_cards[i]\n        else:\n            ordered_cards[i], ordered_cards[n // 2 + n // 4 + i] = ordered_cards[n // 2 + n // 4 + i], ordered_cards[i]\n\n    # Check if the ordered_cards are still sorted after the second shuffle\n    if all(ordered_cards[i] <= ordered_cards[i + 1] for i in range(n // 4 - 1)):\n        return 2\n\n    return 3\n\n\ndef"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # read the input\n    n, deck = input_parser(stdin)\n    min_shuffles = min_shuffles_count(deck, n)\n    return str(min_shuffles)\n\ndef"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    ordered_cards = list(map(int, stdin.split('\\n')[1].split()))\n    \n    # Check if ordered_cards is a permutation of 1...n\n    if set(range(1, n+1)) != set(ordered_cards):\n        return \"Invalid input\"\n    \n    min_shuffles = 0\n    while ordered_cards != list(range(1, n+1)):\n        min_shuffles += 1\n        new_ordered_cards = [0] * n\n        for i in range(n//2):\n            new_ordered_cards[2*i] = ordered_cards[i]\n            new_ordered_cards[2*i+1] = ordered_cards[n//2+i]\n        ordered_cards = new_ordered_cards\n    \n    return str(min_shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    ordered_cards = list(map(int, input_data[1].split()))\n\n    def riffle_shuffle(deck):\n        half_deck = len(deck) // 2\n        return deck[:half_deck] + deck[half_deck:]\n\n    def merge_shuffle(deck):\n        mid_deck = len(deck) // 2\n        return deck[:mid_deck] + deck[mid_deck + 1:] + [deck[mid_deck]]\n\n    def get_min_shuffles(deck, ordered_cards):\n        if deck == ordered_cards:\n            return 0\n\n        min_shuffles = float('inf')\n        for shuffle in (riffle_shuffle, merge_shuffle):\n            new_deck = shuffle(deck)\n            shuffles_needed = get_min_shuffles(new_deck, ordered_cards)\n            if shuffles_needed < min_shuffles:\n                min_shuffles = shuffles_needed\n\n        return min_shuffles + 1\n\n    min_shuffles = get_min_shuffles(list(range(1, n + 1)), ordered_cards)\n    return str(min_shuffles)"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def riffle_shuffle(cards: List[int], start: int, mid: int, end: int) -> None:\n        for i in range(start, mid):\n            card = cards[i]\n            new_i = i + (card - start) // (end - start)\n            cards[i], cards[new_i] = cards[new_i], card\n\n    n = int(stdin.split(\"\\n\")[0])\n    ordered_cards = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    min_shuffles = 0\n    for i in range(1, n):\n        if ordered_cards[i] < ordered_cards[i - 1]:\n            min_shuffles += 1\n            riffle_shuffle(ordered_cards, 0, i, n)\n            riffle_shuffle(ordered_cards, i, n, n)\n\n    return str(min_shuffles)\n"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    ordering = list(map(int, input_list[1:]))\n\n    def count_shuffles(ordering):\n        count = 0\n        for i in range(1, n):\n            if ordering[i] <= ordering[i-1]:\n                count += 1\n        return count\n\n    shuffles = count_shuffles(ordering)\n    while shuffles != 0:\n        ordering = sorted(ordering[:n//2] + ordering[n//2+1:])\n        shuffles = count_shuffles(ordering)\n\n    return str(shuffles)\n"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, cards = input().split()\n    n = int(n)\n    cards = list(map(int, cards))\n    \n    # Determine the minimum number of shuffles required\n    num_shuffles = 1\n    while cards != list(range(1, n+1)):\n        num_shuffles += 1\n        first_half = cards[:n//2]\n        second_half = cards[n//2:]\n        cards = [second_half[i%(n//2)] for i in range(n)]\n        cards[n//2:] = first_half\n    \n    return str(num_shuffles)\n"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeats = stdin.split()\n    repeats = int(repeats)\n    integer_part, decimal_part = input_str.split('.')\n    integer_part = int(integer_part)\n    decimal_part = int(decimal_part[:repeats])\n    numerator = integer_part * 10 ** repeats + decimal_part\n    denominator = 10 ** repeats\n\n    gcd = lambda x, y: y if x == 0 else gcd(y % x, x)\n    greatest_common_divisor = gcd(numerator, denominator)\n\n    if greatest_common_divisor > 1:\n        numerator //= greatest_common_divisor\n        denominator //= greatest_common_divisor\n\n    return f\"{numerator}/{denominator}\"\n\ninput_str = \"0.142857 6\"\nprint(solution(input_str))\n\ninput_str = \"1.6 1\"\nprint(solution(input_str)) "
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_string = stdin.strip()\n    decimal_part, repeat_part = input_string.split()\n    decimal_part = decimal_part.strip()\n    repeat_part = int(repeat_part.strip())\n    \n    if decimal_part.startswith('0.'):\n        decimal_part = decimal_part[2:]\n    else:\n        decimal_part = decimal_part[1:]\n    \n    integer_part = int(decimal_part[:-repeat_part])\n    fraction_part = decimal_part[-repeat_part:]\n    denominator = 10 ** repeat_part\n    \n    numerator = integer_part * denominator + int(fraction_part)\n    \n    gcd = find_gcd(numerator, denominator)\n    \n    return f\"{numerator // gcd}/{denominator // gcd}\"\n\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.strip().split(\" \")\n    decimal_part = input_values[0]\n    repeating_digits = int(input_values[1])\n\n    # Split the decimal part into integer and repeating part\n    integer_part, repeating_part = decimal_part.split(\".\")\n\n    # Combine the integer and repeating part\n    combined_part = integer_part + \".\" + repeating_part\n\n    # Convert the combined part to a float\n    float_value = float(combined_part)\n\n    # Calculate the denominator\n    denominator = int(\"1\" + repeating_part)\n\n    # Calculate the numerator\n    numerator = int(float_value * denominator)\n\n    # Calculate the GCD of numerator and denominator\n    gcd_value = gcd(numerator, denominator)\n\n    # Reduce the fraction\n    reduced_numerator = numerator // gcd_value\n    reduced_denominator = denominator // gcd_value\n\n    # Print the result\n    return f\"{reduced_numerator}/{reduced_denominator}\"\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    decimal_part = input_data[0].split(\".\")[1]\n    repeating_part = int(input_data[1])\n    repeating_digits = int(decimal_part[:repeating_part])\n    left_part = int(decimal_part[repeating_part:])\n    numerator = left_part * (10 ** repeating_part) + repeating_digits\n    denominator = 10 ** repeating_part\n\n    if numerator == 0:\n        return \"0\"\n\n    # Find the greatest common divisor (GCD) using Euclidean algorithm\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    # Reduce the fraction to its simplest form\n    def reduce_fraction(numerator, denominator):\n        gcd_value = gcd(numerator, denominator)\n        return numerator // gcd_value, denominator // gcd_value\n\n    return \"/\".join(map(str, reduce_fraction(numerator, denominator)))\n"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    decimal, repeats = stdin.split()\n    decimal = float(decimal)\n    repeats = int(repeats)\n    \n    whole_part = int(decimal)\n    decimal -= whole_part\n    \n    numerator = 1\n    denominator = 1\n    for _ in range(repeats):\n        numerator *= 10\n        denominator *= 10\n    \n    numerator *= int(decimal * numerator)\n    denominator *= whole_part + 1\n    \n    gcd = math.gcd(numerator, denominator)\n    return f\"{numerator // gcd}/{denominator // gcd}\""
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.rstrip()\n    input_list = input_str.split()\n    numerator_str = input_list[0]\n    denominator_str = input_list[1]\n\n    numerator = int(numerator_str[:numerator_str.find('.')])\n    denominator = int(denominator_str)\n\n    if numerator % denominator == 0:\n        return str(numerator // denominator)\n\n    common_divisor = gcd(numerator, denominator)\n    return str(numerator // common_divisor) + '/' + str(denominator // common_divisor)\n\ndef"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_line = stdin.strip().split()\n    decimal_part = input_line[0]\n    repeat_count = int(input_line[1])\n\n    decimal_part_float = float(decimal_part)\n    integer_part = int(decimal_part_float)\n    repeat_part = int(10 ** repeat_count)\n\n    repeating_decimal_part = (decimal_part_float - integer_part) * repeat_part\n\n    numerator = integer_part * repeat_part + repeating_decimal_part\n    denominator = repeat_part\n\n    gcd = lambda a, b: b if a == 0 else gcd(b % a, a)\n    g = gcd(numerator, denominator)\n\n    if numerator % 2 == 0 and denominator % 2 == 0:\n        numerator //= 2\n        denominator //= 2\n        g = gcd(numerator, denominator)\n\n    return f\"{numerator // g}/{denominator // g}\"\n"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_line = stdin.strip()\n    input_list = input_line.split()\n    numerator = int(input_list[0].replace('.', ''))\n    denominator = int(input_list[1])\n\n    result = f\"{numerator}/{denominator}\"\n\n    while denominator > 0:\n        remainder = numerator % denominator\n        numerator, denominator = denominator, remainder\n\n    result = f\"{numerator}/{denominator}\"\n\n    return result\n\ninput_line = \"0.142857 6\"\nprint(solution(input_line)) "
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.strip().split()\n    decimal_part = input_values[0]\n    repeats = int(input_values[1])\n\n    # Find the fraction\n    numerator = int(decimal_part[:repeats])\n    denominator = 10**repeats\n    if numerator == 0:\n        numerator = 1\n        denominator *= 10\n\n    # Reduce the fraction\n    gcd = 1\n    while denominator % gcd == 0 and numerator % gcd == 0:\n        gcd = math.gcd(gcd, denominator)\n        denominator //= gcd\n        numerator //= gcd\n\n    return f\"{numerator}/{denominator}\""
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str, digit_count = stdin.split()\n    numerator = int(input_str.split('.')[0])\n    denominator = int('1' + input_str.split('.')[1])\n    repeated_digits = int(digit_count)\n\n    if repeated_digits > 0:\n        divisor = 10 ** repeated_digits\n        numerator *= divisor\n        common_divisor = gcd(numerator, denominator * divisor)\n        numerator //= common_divisor\n        denominator //= common_divisor\n\n    return f\"{numerator}/{denominator}\"\n\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_enclosures(grid, defective_cells):\n        def count_enclosures(cell):\n            count = 0\n            for i in range(cell[2] - 1, -1, -1):\n                if i == 0 or grid[cell[0]][cell[1]][i - 1]:\n                    count += 1\n                    break\n            for j in range(cell[1] - 1, -1, -1):\n                if j == 0 or grid[cell[0]][j - 1][cell[2]]:\n                    count += 1\n                    break\n            for k in range(cell[0] - 1, -1, -1):\n                if k == 0 or grid[k - 1][cell[1]][cell[2]]:\n                    count += 1\n                    break\n            return count\n\n        enclosures = 0\n        for cell in defective_cells:\n            count = count_enclosures(cell)\n            if count > enclosures:\n                enclosures = count\n        return enclosures\n\n    n = int(stdin.split(\"\\n\")[0])\n    defective_cells = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, stdin.split(\"\\n\")[i].split())\n        defective_cells.append((x, y, z))\n\n    grid = [[[False for _ in range(10)] for _ in range(10)] for _ in range(10)]\n    for cell in defective_cells:\n        grid[cell[0]][cell[1]][cell[2]] = True\n\n    result = find_enclosures(grid, defective_cells)\n    return str(result)"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    defective_cells = []\n    for i in range(1, n + 1):\n        defective_cells.append(tuple(map(int, input_list[i].split())))\n    \n    # Calculate the minimum number of panels required\n    min_panels = 0\n    for x, y, z in defective_cells:\n        min_panels += 1\n        if x > 0:\n            min_panels += 1\n        if y > 0:\n            min_panels += 1\n        if z > 0:\n            min_panels += 1\n    \n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    num_cells = int(inputs[0])\n    defective_cells = []\n    for i in range(1, num_cells + 1):\n        x, y, z = map(int, inputs[i].split())\n        defective_cells.append((x, y, z))\n\n    # find enclosures\n    min_panels = float('inf')\n    for dx in range(10):\n        for dy in range(10):\n            for dz in range(10):\n                # check if any cell is outside enclosure\n                enclosed = True\n                for cell in defective_cells:\n                    x, y, z = cell\n                    if x < dx or x >= dx + 1 or y < dy or y >= dy + 1 or z < dz or z >= dz + 1:\n                        enclosed = False\n                        break\n                if enclosed:\n                    # calculate number of panels required\n                    panels = 0\n                    for x in range(dx):\n                        for y in range(dy):\n                            for z in range(dz):\n                                if (x, y, z) not in defective_cells:\n                                    panels += 1\n                    min_panels = min(min_panels, panels)\n    return str(min_panels)\n"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_adjacent_cells(x, y, z):\n        adjacent_cells = []\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                for k in range(z - 1, z + 2):\n                    if (i, j, k) != (x, y, z) and 0 <= i <= 9 and 0 <= j <= 9 and 0 <= k <= 9:\n                        adjacent_cells.append((i, j, k))\n        return adjacent_cells\n\n    def contains_cells(enclosures, cells):\n        for x, y, z in cells:\n            for enclosure in enclosures:\n                if enclosure[0] <= x <= enclosure[2] and enclosure[1] <= y <= enclosure[3] and enclosure[4] <= z <= enclosure[5]:\n                    break\n            else:\n                return False\n        return True\n\n    def get_min_panels(defective_cells):\n        panels = []\n        for x, y, z in defective_cells:\n            adjacent_cells = get_adjacent_cells(x, y, z)\n            for cell in adjacent_cells:\n                if not contains_cells(panels, [cell]):\n                    for other_cell in adjacent_cells:\n                        if not contains_cells(panels, [cell, other_cell]):\n                            enclosure = (x, y, z, cell[0], cell[1], cell[2])\n                            panels.append(enclosure)\n        return len(panels)\n\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    defective_cells = []\n    for i in range(1, n + 1):\n        x, y, z = tuple(map(int, input_list[i].split()))\n        defective_cells.append((x, y, z))\n\n    min_panels = get_min_panels(defective_cells)\n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(node, visited, graph, color):\n        queue = [node]\n        visited[node] = color\n        while queue:\n            curr = queue.pop(0)\n            for neighbor in graph[curr]:\n                if visited[neighbor] == -1:\n                    visited[neighbor] = color\n                    queue.append(neighbor)\n\n    n, *coords = stdin.split('\\n')\n    n = int(n)\n    coords = [tuple(map(int, coord.split())) for coord in coords]\n\n    visited = [-1] * 1000\n    graph = [[] for _ in range(1000)]\n\n    for i in range(1000):\n        for j in range(1000):\n            for k in range(1000):\n                if i % 10 == 0 or i % 10 == 9 or j % 10 == 0 or j % 10 == 9 or k % 10 == 0 or k % 10 == 9:\n                    graph[i * 1000 + j * 10 + k].append((i, j, k))\n\n    for coord in coords:\n        i, j, k = coord\n        bfs(i * 1000 + j * 10 + k, visited, graph, 1)\n\n    count = 0\n    for i in range(10):\n        for j in range(10):\n            count += sum(1 for k in range(10) if visited[i * 1000 + j * 10 + k] == 1)\n\n    return count"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n = int(inputs[0])\n    coords = []\n    for i in range(1, n+1):\n        x, y, z = map(int, inputs[i].split())\n        coords.append((x, y, z))\n\n    # Enclosures are formed by square panels which fit perfectly between adjacent cells, or can be placed along the sides of the cells on the edges of the grid.\n    # Each panel is exactly the size and shape of a face of one of the cubic cells.\n    # For full containment, each enclosure must be completely closed.\n    min_panels = 0\n    for x, y, z in coords:\n        min_panels += 2*x + 2*y + 2*z + 1\n\n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    defective_cells = []\n    for i in range(n):\n        x, y, z = map(int, input().split())\n        defective_cells.append((x, y, z))\n\n    # Create a 3D list to store the grid\n    grid = [[[0 for k in range(10)] for j in range(10)] for i in range(10)]\n\n    # Mark the defective cells as -1\n    for x, y, z in defective_cells:\n        grid[x][y][z] = -1\n\n    # Initialize variables for the minimum number of panels\n    min_panels = 0\n    for x in range(10):\n        for y in range(10):\n            for z in range(10):\n                if grid[x][y][z] == -1:\n                    min_panels += 1\n                    break\n\n    # Check if each adjacent cell is also defective\n    for x in range(10):\n        for y in range(10):\n            for z in range(10):\n                if grid[x][y][z] == -1:\n                    for i in range(-1, 2):\n                        for j in range(-1, 2):\n                            for k in range(-1, 2):\n                                if i == 0 and j == 0 and k == 0:\n                                    continue\n                                nx, ny, nz = x + i, y + j, z + k\n                                if 0 <= nx < 10 and 0 <= ny < 10 and 0 <= nz < 10 and grid[nx][ny][nz] == -1:\n                                    min_panels -= 1\n                                    break\n\n    return str(min_panels)"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def add_neighbors(cells: set, x: int, y: int, z: int) -> None:\n        for dx, dy, dz in [(-1, 0, 0), (1, 0, 0), (0, -1, 0), (0, 1, 0), (0, 0, -1), (0, 0, 1)]:\n            if (x + dx, y + dy, z + dz) not in cells:\n                cells.add((x + dx, y + dy, z + dz))\n\n    def cell_count(cells: set) -> int:\n        visited = set()\n        queue = cells.copy()\n        while queue:\n            x, y, z = queue.pop()\n            if (x, y, z) in visited:\n                continue\n            visited.add((x, y, z))\n            add_neighbors(queue, x, y, z)\n        return len(visited)\n\n    n = int(stdin.splitlines()[0])\n    defects = []\n    for i in range(1, n + 1):\n        x, y, z = map(int, stdin.splitlines()[i].split())\n        defects.append((x, y, z))\n\n    enclosures = set()\n    for x, y, z in defects:\n        add_neighbors(enclosures, x, y, z)\n\n    return cell_count(enclosures)\n"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_panels(x: int, y: int, z: int) -> int:\n        # Assuming a cubic grid of size n, each cell can be enclosed by n-1 panels in each dimension\n        return (n-x-1)*(n-y-1)*(n-z-1)\n\n    # Read input\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    defective_cells = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    # Find the size of the cubic grid\n    max_coords = max(defective_cells, key=lambda x: x[0]+x[1]+x[2])\n    n = max_coords[0]+1\n\n    # Calculate the minimum number of panels required\n    panels = sum(count_panels(x, y, z) for x, y, z in defective_cells)\n\n    return str(panels)\n"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    x_coords = [int(x) for x in input_list[1:n+1]]\n    y_coords = [int(x) for x in input_list[n+1:2*n+1]]\n    z_coords = [int(x) for x in input_list[2*n+1:]]\n\n    def count_panels(coords):\n        panels = 0\n        for i in range(len(coords)):\n            x = coords[i][0]\n            y = coords[i][1]\n            z = coords[i][2]\n            if x > 0:\n                panels += 1\n            if y > 0:\n                panels += 1\n            if z > 0:\n                panels += 1\n        return panels\n\n    return str(max(count_panels(x_coords), count_panels(y_coords), count_panels(z_coords)))"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, col: int, visited: set, adj: list, color: list):\n        visited.add(v)\n        color[v] = col\n        for u in adj[v]:\n            if u not in visited and color[u] == -1:\n                dfs(u, (col + 1) % 7, visited, adj, color)\n\n    def check_coloring(n: int, a: list) -> bool:\n        adj = [[] for _ in range(n * 2 - 1)]\n        for i in range(1, n + 1):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if a[i][j] != -1:\n                    if a[i][j] > 0:\n                        for d in range(1, a[i][j] + 1):\n                            adj[2 * i - 2 + (d - 1) // 2].append(2 * i - 2 + (d - 1) // 2 + (d % 2) * (d - 1))\n                            adj[2 * i - 2 + (d - 1) // 2 + (d % 2)].append(2 * i - 2 + (d - 1) // 2 - (d % 2) * (d - 1))\n                    else:\n                        adj[2 * i - 2].append(2 * i - 2 + 1)\n                        adj[2 * i - 2 + 1].append(2 * i - 2)\n        visited = set()\n        color = [-1] * (2 * n - 1)\n        dfs(0, 0, visited, adj, color)\n        for i in range(1, n + 1):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if a[i][j] != -1:\n                    if a[i][j] != color[2 * i - 2 + (a[i][j] - 1) // 2]:\n                        return False\n        return True\n\n    def count_colorings(n: int, a: list) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if a[i][j] != -1:\n                    if a[i][j] > 0:\n                        count += 1\n                    else:\n                        count += 2\n        return count\n\n    n = int(stdin.splitlines()[0])\n    a = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n    if n % 2 == 0:\n        return \"0\"\n    count = 0\n    for i in range(1, n + 1):\n        for j in range(n if i % 2 == 1 else n - 1):\n            for k in range(7):\n                a[i][j] = k\n                if check_coloring(n, a):\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = []\n    for i in range(1, n * 2, 2):\n        a.append([int(x) for x in stdin.splitlines()[i].split()])\n    for i in range(2, n * 2, 2):\n        a.append([int(x) for x in stdin.splitlines()[i].split()[:-1]])\n    def is_valid(adj: list, visited: list) -> bool:\n        stack = [(0, 0)]\n        visited[0][0] = True\n        while stack:\n            cur, v = stack.pop()\n            if v == 0:\n                return False\n            if v == n:\n                if cur > 0 and a[cur - 1][v - 1] != adj[cur - 1][v - 1]:\n                    return False\n                if v < n - 1 and a[cur - 1][v] != adj[cur - 1][v]:\n                    return False\n                return True\n            for i in range(v - 1, n):\n                if not visited[cur][i]:\n                    visited[cur][i] = True\n                    if adj[cur][i] == 0:\n                        stack.append((cur, i + 1))\n                    else:\n                        stack.append((cur + adj[cur][i], 0))\n        return False\n    cnt = 0\n    for adj in a:\n        visited = [[False] * n for _ in range(n)]\n        if is_valid(adj, visited):\n            cnt += 1\n    return str(cnt)\n"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    a = []\n    for i in range(n):\n        row = list(map(int, stdin.split()[i+1].split()))\n        a.append(row)\n\n    def count_colored_edges(i, j):\n        return a[i][j]\n\n    def is_valid_coloring():\n        visited = [False] * n\n        def dfs(node, prev=None):\n            visited[node] = True\n            for neighbor in range(n):\n                if neighbor != prev and not visited[neighbor]:\n                    if count_colored_edges(node, neighbor) != -1:\n                        if count_colored_edges(node, neighbor) != count_colored_edges(neighbor, node):\n                            return False\n                        if not dfs(neighbor, node):\n                            return False\n            return True\n\n        for i in range(n):\n            for j in range(n):\n                if a[i][j] != -1:\n                    if not dfs(i, j):\n                        return False\n        return True\n\n    valid_colorings = 0\n    for i in range(n):\n        for j in range(n):\n            for k in range(7):\n                a[i][j] = k\n                if is_valid_coloring():\n                    valid_colorings += 1\n\n    return str(valid_colorings)\n"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    a = [list(map(int, line.split())) for line in stdin.split('\\n')[1:] if line.strip() != '']\n\n    def is_valid(edges_count):\n        for i in range(n):\n            for j in range(len(a[i])):\n                if a[i][j] != -1 and a[i][j] != edges_count[i][j]:\n                    return False\n        return True\n\n    def dfs(v, color, graph, edges_count, visited, loops):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u, (color + 1) % 2, graph, edges_count, visited, loops)\n            elif loops[u][v] == -1 and color != loops[u][v]:\n                loops[u][v] = color\n                loops[v][u] = color\n\n    def has_valid_loops(loops):\n        for i in range(n):\n            for j in range(n):\n                if loops[i][j] == -1 or loops[j][i] == -1:\n                    return False\n        return True\n\n    def count_valid_colorings():\n        edges_count = [[0] * n for _ in range(n)]\n        for i in range(n):\n            for j in range(len(a[i])):\n                if a[i][j] != -1:\n                    edges_count[i][j] = a[i][j]\n\n        count = 0\n        for color in range(2):\n            visited = [False] * n\n            loops = [[-1] * n for _ in range(n)]\n            for i in range(n):\n                for j in range(len(a[i])):\n                    if a[i][j] != -1:\n                        loops[i][j] = color\n                        loops[j][i] = color\n            dfs(0, color, a, edges_count, visited, loops)\n            if is_valid(edges_count) and has_valid_loops(loops):\n                count += 1\n        return count\n\n    return str(count_valid_colorings())"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_coloring(grid, color_edges):\n        for i in range(n):\n            for j in range(n if i % 2 == 0 else n - 1):\n                if grid[i][j] != -1 and grid[i][j] != color_edges[i][j]:\n                    return False\n        return True\n\n    def count_valid_colorings(grid, color_edges):\n        loops = []\n        visited = set()\n        for i in range(n):\n            for j in range(n if i % 2 == 0 else n - 1):\n                if grid[i][j] != -1 and grid[i][j] != color_edges[i][j]:\n                    return 0\n                elif color_edges[i][j] == -1:\n                    continue\n\n                edge = (i, j)\n                if edge in visited:\n                    continue\n\n                visited.add(edge)\n                stack = [edge]\n                while stack:\n                    u, v = stack[-1]\n                    if color_edges[u][v] == -1:\n                        stack.pop()\n                        continue\n\n                    for x, y in [(u + 1, v), (u, v + 1), (u - 1, v), (u, v - 1)]:\n                        if 0 <= x < n and 0 <= y < n if x % 2 == 0 else n - 1:\n                            if grid[x][y] == color_edges[x][y]:\n                                edge = (x, y)\n                                if edge not in visited:\n                                    visited.add(edge)\n                                    stack.append(edge)\n                                    break\n                    else:\n                        loop = [(u, v)]\n                        while stack and stack[-1] != (u, v):\n                            loop.append(stack.pop())\n                        loop.append((u, v))\n                        loops.append(loop)\n\n        for i in range(len(loops)):\n            for j in range(i + 1, len(loops)):\n                if loops[i][0] == loops[j][0] or loops[i][0] in loops[j][1:]:\n                    return 0\n        return 1\n\n    n = int(stdin[0])\n    grid = [[int(x) for x in stdin[i + 1].split()] for i in range(n)]\n    color_edges = [[-1 for j in range(n if i % 2 == 0 else n - 1)] for i in range(n)]\n\n    for i in range(n):\n        for j in range(n if i % 2 == 0 else n - 1):\n            if grid[i][j] != -1:\n                color_edges[i][j] = grid[i][j]\n\n    return count_valid_colorings(grid, color_edges)\n"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    grid = []\n    for i in range(1, n + 1):\n        row = list(map(int, stdin.split('\\n')[i].split()))\n        if i % 2 == 1:\n            grid.append(row)\n        else:\n            grid.append(row[:-1])\n\n    def count_edges(i, j):\n        if i == 0:\n            return 2\n        if i % 2 == 0:\n            return 2 * (j + 1) - grid[i][j]\n        else:\n            return 2 * j - grid[i][j]\n\n    def dfs(v, adj):\n        visited[v] = True\n        for u in adj[v]:\n            if not visited[u]:\n                dfs(u, adj)\n\n    def is_valid(adj):\n        for v in range(n):\n            if grid[v][-1] != -1 and grid[v][-1] != count_edges(v, n - 1):\n                return False\n        for i in range(n):\n            for j in range(n - 1):\n                if grid[i][j] != -1 and grid[i][j] != count_edges(i, j):\n                    return False\n                if grid[i][j] != -1 and grid[i][j] != grid[i][j + 1]:\n                    return False\n        return True\n\n    def color_grid():\n        adj = [[] for _ in range(n)]\n        for i in range(n):\n            for j in range(n - 1):\n                if grid[i][j] == grid[i][j + 1]:\n                    adj[i].append(j + 1)\n                    adj[i + 1].append(j)\n            if i % 2 == 0:\n                adj[i].append(i + 1)\n                adj[i + 1].append(i)\n\n        visited = [False] * n\n        for v in range(n):\n            if not visited[v]:\n                dfs(v, adj)\n\n        if not is_valid(adj):\n            return 0\n\n        return 1\n\n    return str(color_grid())\n"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = []\n    for i in range(1, len(input_list)):\n        row = input_list[i].split()\n        a.append([int(num) for num in row])\n\n    def color_edges(a, visited, start_index, current_color, color_map, loop_map):\n        visited[start_index[0]][start_index[1]] = True\n        current_loop = []\n        for i in range(len(a[start_index[0]][start_index[1]].edges)):\n            neighbor = a[start_index[0]][start_index[1]].edges[i]\n            if neighbor not in visited:\n                if not color_edges(a, visited, neighbor, current_color, color_map, loop_map):\n                    return False\n                current_color = color_map[neighbor]\n            elif color_map[neighbor] != current_color and neighbor not in current_loop:\n                return False\n            current_loop.append(neighbor)\n        loop_map[start_index] = current_loop\n        return True\n\n    def validate_coloring(color_map, loop_map):\n        visited = [[False for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            for j in range(n):\n                if not visited[i][j]:\n                    color_edges(a, visited, (i, j), 0, color_map, loop_map)\n        for i in range(n):\n            for j in range(n):\n                if a[i][j].color != -1 and a[i][j].color != len(a[i][j].edges):\n                    return False\n        return True\n\n    valid_colorings = 0\n    for i in range(n):\n        for j in range(n):\n            for color in range(7):\n                for edge in range(len(a[i][j].edges)):\n                    a[i][j].edges[edge] = color\n                a[i][j].color = color\n                if validate_coloring({}, {}):\n                    valid_colorings += 1\n                for edge in range(len(a[i][j].edges)):\n                    a[i][j].edges[edge] = -1\n    return str(valid_colorings)"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def valid_coloring(grid, colors):\n        rows, cols = len(grid), len(grid[0])\n        edges = [[None for _ in range(cols)] for _ in range(rows)]\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] != -1:\n                    edges[i][j] = 0\n\n        def dfs(i, j, color):\n            if edges[i][j] is not None:\n                return edges[i][j] == color\n            edges[i][j] = color\n            if i > 0:\n                edges[i-1][(j+cols-1) % cols] = color\n            if i < rows-1:\n                edges[i+1][(j+1) % cols] = color\n            for dj in range(-1, 2):\n                if 0 <= j+dj < cols and grid[i][(j+dj+cols) % cols] != -1:\n                    if not dfs(i, (j+dj+cols) % cols, (color+1) % 2):\n                        return False\n            return True\n\n        for i in range(rows):\n            for j in range(cols):\n                if grid[i][j] != -1:\n                    if not dfs(i, j, 0):\n                        return False\n        return True\n\n    def count_colorings(n, grid):\n        rows = len(grid)\n        cols = len(grid[0])\n        total_colorings = 0\n\n        for i in range(rows):\n            for j in range(cols):\n                for k in range(7):\n                    grid[i][j] = k\n                    if valid_coloring(grid, i, j):\n                        total_colorings += 1\n        return total_colorings\n\n    def read_input(stdin):\n        n = int(stdin.readline().strip())\n        grid = []\n        for _ in range(n):\n            row = list(map(int, stdin.readline().strip().split()))\n            grid.append(row)\n        return n, grid\n\n    def write_output(stdout, count):\n        stdout.write(str(count) + \"\\n\")\n\n    n, grid = read_input(StringIO(stdin))\n    count = count_colorings(n, grid)\n    write_output(StringIO(stdin), count)"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_colored_edges(a, n):\n        count = 0\n        for i in range(n):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if a[i][j] != -1:\n                    count += a[i][j]\n        return count\n\n    def is_valid_coloring(a, n):\n        for i in range(n):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if a[i][j] != -1 and a[i][j] != count_colored_edges(a, n):\n                    return False\n        return True\n\n    def count_valid_colorings(n):\n        count = 0\n        for a in product(range(-1, 7), repeat=n * n):\n            a = list(a)\n            a = [a[i:i + n] for i in range(0, len(a), n)]\n            if is_valid_coloring(a, n):\n                count += 1\n        return count\n\n    n = int(stdin[0])\n    a = [[int(x) for x in stdin[i + 1].split()] for i in range(n * n)]\n    result = count_valid_colorings(n)\n    return str(result)\n\ndef"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    grid = [list(map(int, stdin.split(\"\\n\")[i+1].split())) for i in range(n)]\n    def valid_coloring(grid: list) -> bool:\n        def dfs(node: tuple, visited: set, color: int) -> bool:\n            i, j = node\n            if (i, j) in visited:\n                return True\n            visited.add((i, j))\n            if grid[i][j] != -1 and grid[i][j] != color:\n                return False\n            if i > 0:\n                if (i-1, j) in visited:\n                    return True\n                visited.add((i-1, j))\n                if not dfs((i-1, j), visited, (color+1) % 7):\n                    return False\n            if i < n-1:\n                if (i+1, j) in visited:\n                    return True\n                visited.add((i+1, j))\n                if not dfs((i+1, j), visited, (color+1) % 7):\n                    return False\n            if j > 0:\n                if (i, j-1) in visited:\n                    return True\n                visited.add((i, j-1))\n                if not dfs((i, j-1), visited, (color+1) % 7):\n                    return False\n            if j < n-1:\n                if (i, j+1) in visited:\n                    return True\n                visited.add((i, j+1))\n                if not dfs((i, j+1), visited, (color+1) % 7):\n                    return False\n            return True\n\n        visited = set()\n        for i in range(n):\n            for j in range(len(grid[i])):\n                if not dfs((i, j), visited, 0):\n                    return False\n        return True\n\n    valid_colorings = 0\n    for coloring in product(range(-1, 7), repeat=n*n):\n        grid_copy = deepcopy(grid)\n        for i in range(n):\n            for j in range(n if i % 2 == 1 else n-1):\n                grid_copy[i][j] = coloring.pop(0)\n        if valid_coloring(grid_copy):\n            valid_colorings += 1\n\n    return str(valid_colorings)"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_binary_representations(num: int) -> int:\n        count = 1\n        for i in range(1, num + 1):\n            if bin(i).count('1') == bin(num).count('1'):\n                count += 1\n            if bin(i).count('1') > bin(num).count('1'):\n                break\n        return count % 1000000009\n\n    binary_number = int(stdin, 2)\n    return count_binary_representations(binary_number)"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    modulo = 1000000009\n    N = int(stdin, 2)\n    count = 0\n    \n    for i in range(3):\n        if N % 3 == i:\n            count += 1\n            \n    count = count * 2 + (N // 3) % 2 + (N // 3) % 4 // 2 + (N // 3) % 8 // 4\n    \n    return str(count % modulo)"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    count = 0\n    for i in range(1, n + 1):\n        if len(bin(i)[2:]) == len(stdin):\n            count += 1\n    return str(count % (10**9))"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_binary_representations(N: int) -> int:\n        count = 0\n        for i in range(3):\n            if (N & 1) == i:\n                count += 1\n            N >>= 1\n        return count\n\n    binary = bin(int(stdin, 2))[2:]\n    result = count_binary_representations(int(binary, 2))\n    return str(result % 1000000009)"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[::-1], 2)\n    count = 0\n    for i in range(3):\n        if (N // i) % 3 == 2:\n            count += 1\n    return str(count % 1000000009)"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin, 2)\n    count = 0\n    for i in range(N+1):\n        binary_representation = bin(i)[2:]\n        has_2 = False\n        for digit in binary_representation:\n            if digit == '2':\n                has_2 = True\n                break\n        if has_2:\n            count += 1\n    return str(count % 1000000009)"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    num = int(stdin, 2)\n    count = 0\n    for i in range(3):\n        count += bin(num ^ i).count('1')\n    return count % 1000000009\n\nn = input()\nprint(solution(n)) "
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    count = 0\n\n    for i in range(1, 2**n):\n        binary = format(i, f'0{n}b')\n        if '2' in binary:\n            count += 1\n\n    return count % 1000000009"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_binary_representations(n: int) -> int:\n        if n == 0:\n            return 1\n        elif n % 2 == 0:\n            return count_binary_representations(n // 2) * 2\n        else:\n            return count_binary_representations(n // 2) * 2 + 1\n\n    n = int(stdin, 2)\n    return str((count_binary_representations(n) + 999999) % 1000000009)\n"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def count_binary_representations(num: str) -> int:\n        # Count the number of representations that use 2 as a digit\n        count = 0\n        for i in range(1, len(num) + 1):\n            # Find the maximum power of 2 that can be added without exceeding the number\n            power = 0\n            while 2 ** power <= i:\n                power += 1\n            power -= 1\n\n            # Check if the remainder after division by 2^power is 2\n            remainder = int(num[:i], 2) % (2 ** power)\n            if remainder == 2:\n                count += 1\n\n        return count % 1000000009\n\n    return str(count_binary_representations(stdin))"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Initialize the first move\n    if p[0] == 1:\n        move = 'L'\n    else:\n        move = 'R'\n        \n    # Loop through the rest of the moves\n    for i in range(1, N):\n        # If the next move would cause a collision, rotate the ring\n        if (p[i] - p[i-1]) % N == 0:\n            move = 'L' if move == 'R' else 'R'\n        # Otherwise, continue with the current move\n        else:\n            move += 'L' if move == 'L' else 'R'\n    \n    # If there is a valid solution, return it, otherwise return no dance\n    if move == 'L' * N:\n        return move\n    else:\n        return \"no dance\" "
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    \n    # Check if there is a valid solution\n    for i in range(N):\n        if p[i] % 2 == 0:\n            continue\n        if p[i] == 1:\n            if i == N - 1:\n                return \"no dance\"\n            else:\n                continue\n        else:\n            if p[i] > i:\n                return \"no dance\"\n            else:\n                for j in range(i+1, N):\n                    if p[i] + j == p[j]:\n                        break\n                else:\n                    return \"no dance\"\n                \n    # Find the solution\n    result = []\n    for i in range(N):\n        if p[i] % 2 == 0:\n            result.append('R')\n        else:\n            result.append('L')\n            for j in range(i):\n                if p[i] == p[j] + (N - i + j) % N:\n                    result[i] = 'R'\n                    break\n    return ''.join(result)"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_next(curr_pos: int, move: int) -> int:\n        next_pos = (curr_pos + move) % N\n        if next_pos == 0:\n            next_pos = N\n        return next_pos\n\n    N, *pairs = stdin.split()\n    N = int(N)\n    pairs = list(map(int, pairs))\n\n    if any(pairs.count(p) > 1 for p in pairs):\n        return \"no dance\"\n\n    pos = [0] * N\n    moves = sorted(set(pairs))\n    move_index = 0\n    result = ['L'] * N\n\n    while move_index < len(moves):\n        curr_move = moves[move_index]\n        next_pos = [find_next(p, curr_move) for p in pos]\n\n        if all(next_pos[i] != i for i in range(N)):\n            pos = next_pos\n            move_index += 1\n        else:\n            result[next_pos.index(i)] = 'R'\n            for i in range(N):\n                if result[i] == 'L':\n                    result[i] = 'R'\n                else:\n                    result[i] = 'L'\n\n    return ''.join(result)\n"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N = int(input_data[0])\n    p = list(map(int, input_data[1].split()))\n\n    if sum(p) % N != 0:\n        return \"no dance\"\n\n    target = sum(p) // N\n    pos = [i + 1 for i in range(N)]\n\n    result = [\"L\"] * N\n\n    for i in range(N):\n        p_i = p[i]\n        p_i_pos = (pos[i] + p_i - 1) % N\n\n        if p_i_pos < pos[i]:\n            pos = pos[p_i_pos:] + pos[:p_i_pos]\n        elif p_i_pos > pos[i]:\n            pos = pos[:p_i_pos] + pos[p_i_pos+1:]\n\n        result[i] = \"R\" if pos[i] > p_i_pos else \"L\"\n\n    return \"\".join(result)\n\ninput_data = \"\"\"3\n1 1 1\"\"\"\noutput = solution(input_data)\nprint(output) "
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    p_list = list(map(int, input_list[1].split()))\n\n    # Calculate the number of positions each wizard can teleport\n    positions = [0] * N\n    for i in range(N):\n        positions[i] = N - p_list[i] - 1 if p_list[i] < N - 1 else p_list[i] - 1\n\n    # Calculate the minimum number of swaps required to avoid collisions\n    swaps = [0] * N\n    for i in range(N):\n        swaps[i] = abs(positions[i] - positions[(i + 1) % N])\n\n    # Determine the direction each wizard should teleport\n    directions = [\"L\"] * N\n    min_swap = min(swaps)\n    if min_swap > 0:\n        for i in range(N):\n            if swaps[(i + 1) % N] == min_swap:\n                directions[i] = \"R\"\n                directions[(i + 1) % N] = \"L\"\n                break\n\n    # Output the directions\n    result = \"\"\n    for direction in directions:\n        result += direction\n\n    return result"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, *p = map(int, stdin.split())\n    p = list(enumerate(p))\n    \n    def is_valid(move):\n        return all(p[i][1] + move != p[(i+1) % N][1] for i in range(N))\n\n    valid_moves = [1, -1]\n    for move in valid_moves:\n        if is_valid(move):\n            return ''.join('L' if p[i][1] + move > 0 else 'R' for i in range(N))\n    \n    return 'no dance'"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, ps = map(int, stdin.split('\\n'))\n    ps = list(ps)\n\n    if N == 1:\n        return 'L'\n\n    if 2 * N - 1 > 360:\n        return 'no dance'\n\n    def is_valid(ps):\n        seen = [False] * N\n        for p in ps:\n            if seen[p % N]:\n                return False\n            seen[p % N] = True\n        return True\n\n    def lexicographically_smallest(ps):\n        return ''.join(['L' if p % 2 == 0 else 'R' for p in ps])\n\n    left_turns = [p for p in range(N) if ps[p] % 2 == 1]\n    right_turns = [p for p in range(N) if ps[p] % 2 == 0]\n\n    if is_valid(left_turns):\n        return lexicographically_smallest(left_turns)\n    elif is_valid(right_turns):\n        return lexicographically_smallest(right_turns)\n    else:\n        return 'no dance'\n\ninput1 = \"3\\n1 1 1\"\ninput2 = \"5\\n1 2 2 1 2\"\n\noutput1 = solution(input1)\noutput2 = solution(input2)\n\nprint(\"Sample Input 1:\")\nprint(input1)\nprint(\"Sample Output 1:\")\nprint(output1)\n\nprint(\"\\nSample Input 2:\")\nprint(input2)\nprint(\"Sample Output 2:\")\nprint(output2) "
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    p_list = list(map(int, stdin.splitlines()[1].split()))\n    \n    if not (1 <= N <= 300000):\n        return \"no dance\"\n    \n    if len(set(p_list)) != N:\n        return \"no dance\"\n    \n    if not all(0 <= p_list[i] < N for i in range(N)):\n        return \"no dance\"\n    \n    result = []\n    for i in range(N):\n        if p_list[(i - p_list[i]) % N] == i:\n            result.append('L')\n        else:\n            result.append('R')\n    \n    return ''.join(result)\n\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n    answer = []\n    for i in range(N):\n        if p[i] == 1:\n            answer.append('L')\n        elif p[i] == N:\n            answer.append('R')\n        else:\n            for j in range(i, i + p[i]):\n                if j % N == i:\n                    answer.append('R')\n                elif j % N == (i + 1) % N:\n                    answer.append('L')\n                elif j % N == (i - 1) % N:\n                    answer.append('R')\n                else:\n                    answer.append('L')\n            break\n    if len(answer) < N:\n        return \"no dance\"\n    return ''.join(sorted(answer))\n\ndef"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    p_list = list(map(int, stdin.split('\\n')[1].split()))\n    d = {}\n    result = []\n    \n    for i in range(N):\n        for j in range(i+1, N):\n            diff = (p_list[i] - p_list[j]) % N\n            if diff in d:\n                d[diff].append((i, j))\n            else:\n                d[diff] = [(i, j)]\n    \n    if sum(d.keys()) % 2 != 0:\n        return \"no dance\"\n    \n    visited = [False] * N\n    for i in range(N):\n        visited[i] = True\n        for diff in sorted(d.keys(), reverse=True):\n            if len(d[diff]) > 0 and not visited[d[diff][0][0]] and not visited[d[diff][0][1]]:\n                visited[d[diff][0][0]] = True\n                visited[d[diff][0][1]] = True\n                result.append('R' if p_list[i] < p_list[d[diff][0][0]] else 'L')\n                break\n        visited[i] = False\n    \n    return ''.join(result)"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.split()[:3])\n    roads = [map(int, stdin.split()[3+i*3:6+i*3]) for i in range(M)]\n\n    def find_path(start, end, visited):\n        if start == end:\n            return 0\n        if visited[start]:\n            return float('inf')\n        visited[start] = True\n        min_energy = float('inf')\n        for road in roads:\n            if road[0] == start:\n                min_energy = min(min_energy, find_path(road[1], end, visited) + road[2])\n        return min_energy\n\n    min_energy = float('inf')\n    for i in range(1, N+1):\n        min_energy = min(min_energy, find_path(i, i, [False]*N))\n\n    if min_energy == float('inf'):\n        return \"Poor girl\"\n    else:\n        return str(int(min_energy + alpha * (M-1)))\n\ninput_data = \"\"\"7 7 10\n1 2 1000000\n2 3 2000000\n3 4 3000000\n4 5 4000000\n5 6 5000000\n6 7 6000000\n7 1 7000000\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"6 6 7\n1 3 1000000\n3 5 3000000\n5 1 5000000\n2 4 2000000\n4 6 4000000\n6 2 6000000\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(graph: list, start: int, visited: set, ways: int) -> int:\n        if visited.intersection(visited_at_start) != set():\n            return float('inf')\n        if len(visited) == N - 1:\n            return ways * (L + 1)\n        if not graph[start]:\n            return float('inf')\n        visited.add(start)\n        visited_at_start.add(start)\n        min_ways = float('inf')\n        for i, j, c in graph[start]:\n            if i not in visited:\n                min_ways = min(min_ways, count_ways(graph, i, visited, ways + c))\n        visited.remove(start)\n        return min_ways\n\n    N, M, alpha = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    visited_at_start = set()\n    for _ in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        graph[u].append((v, c))\n        graph[v].append((u, c))\n\n    min_ways = float('inf')\n    for start in range(1, N + 1):\n        min_ways = min(min_ways, count_ways(graph, start, set(), 0))\n\n    return min_ways if min_ways != float('inf') else 'Poor girl'\n"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.split()[:3])\n    roads = []\n    for _ in range(M):\n        u, v, c = map(int, stdin.split()[3:6])\n        roads.append((u, v, c))\n\n    def dfs(start, visited, total_candies, current_energy, graph, max_candies):\n        if current_energy > max_candies:\n            return max_candies, current_energy\n        if visited[start]:\n            return max_candies, current_energy\n        visited[start] = True\n        current_energy += 1\n        max_candies = max(max_candies, total_candies)\n        for u, v, c in graph[start]:\n            if not visited[u]:\n                max_candies, current_energy = dfs(u, visited, total_candies + c, current_energy, graph, max_candies)\n            if not visited[v]:\n                max_candies, current_energy = dfs(v, visited, total_candies + c, current_energy, graph, max_candies)\n        visited[start] = False\n        return max_candies, current_energy\n\n    graph = [[] for _ in range(N + 1)]\n    for u, v, c in roads:\n        graph[u].append((u, v, c))\n        graph[v].append((u, v, c))\n\n    max_candies = -1\n    for start in range(1, N + 1):\n        visited = [False] * (N + 1)\n        max_candies, _ = dfs(start, visited, 0, 0, graph, max_candies)\n\n    if max_candies == -1:\n        return \"Poor girl\"\n    else:\n        return max_candies + alpha * (M - 1)\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.split()[:3])\n    roads = [map(int, stdin.split()[3 + i * 3: 3 + i * 3 + 3]) for i in range(M)]\n    roads = [(u - 1, v - 1, c) for u, v, c in roads]  # Convert junction numbers to 0-indexed\n    max_candies_in_a_road = max(c for u, v, c in roads)\n    max_roads = (max_candies_in_a_road + alpha) ** 2\n\n    # Determine the minimum energy spent\n    min_energy = float('inf')\n    for start_junction in range(N):\n        for end_junction in range(N):\n            if start_junction == end_junction:\n                continue\n            visited = set()\n            energy = 0\n            for u, v, c in roads:\n                if u == start_junction and v == end_junction:\n                    energy += c ** 2\n                    break\n                if v == start_junction and u == end_junction:\n                    energy += c ** 2\n                    break\n                visited.add((u, v))\n                visited.add((v, u))\n            else:\n                continue\n            for i in range(len(visited) - 1):\n                if (visited[i][0], visited[i + 1][1]) in visited:\n                    energy += alpha\n            min_energy = min(min_energy, energy)\n            if min_energy <= max_roads:\n                return str(min_energy)\n    return \"Poor girl\""
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    N, M, alpha = map(int, input_values[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_values[1:]]\n\n    def is_valid(path: list) -> bool:\n        return len(set(path)) == len(path) and len(path) <= M\n\n    def calculate_energy(path: list) -> int:\n        return sum(roads[i - 1][2] * roads[i - 1][2] for i in path) + alpha * (len(path) - 1)\n\n    def find_path(used: set, start: int, target: int) -> list:\n        if start == target:\n            return [start]\n        for i in range(1, N + 1):\n            if i not in used and i != start:\n                path = find_path(used | {i}, i, target)\n                if path:\n                    return [start] + path\n        return []\n\n    min_energy = float('inf')\n    for start in range(1, N + 1):\n        for target in range(1, N + 1):\n            if start != target:\n                path = find_path(set(), start, target)\n                if path and is_valid(path):\n                    energy = calculate_energy(path)\n                    min_energy = min(min_energy, energy)\n\n    return str(min_energy) if min_energy != float('inf') else 'Poor girl'\n\n\nstdin = \"\"\"7 7 10\n1 2 1000000\n2 3 2000000\n3 4 3000000\n4 5 4000000\n5 6 5000000\n6 7 6000000\n7 1 7000000\"\"\"\n\nprint(solution(stdin))\n\nstdin = \"\"\"6 6 7\n1 3 1000000\n3 5 3000000\n5 1 5000000\n2 4 2000000\n4 6 4000000\n6 2 6000000\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.split()[:3])\n    roads = {}\n    for _ in range(M):\n        u, v, c = map(int, stdin.split()[3:])\n        roads[u, v] = c\n\n    def count_visited_roads(path):\n        visited_roads = set()\n        for i in range(len(path) - 1):\n            visited_roads.add(frozenset(path[i:i+2]))\n        return visited_roads\n\n    def dfs(start, end, visited_roads, path, current_candies, energy):\n        if start == end:\n            if current_candies == 0:\n                return energy\n            return -1\n\n        if len(path) > 2 * N:\n            return -1\n\n        if current_candies < 0:\n            return -1\n\n        energy += alpha * len(path)\n\n        for neighbor, candies in roads.items():\n            if start in neighbor and neighbor not in visited_roads:\n                new_energy = dfs(neighbor[0], end, visited_roads | {frozenset(path + neighbor)}, path + neighbor, current_candies + candies, energy)\n                if new_energy >= 0:\n                    return new_energy\n\n        return -1\n\n    min_energy = dfs(1, 1, set(), [1], 0, 0)\n    if min_energy == -1:\n        return \"Poor girl\"\n    else:\n        return min_energy"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph, visited, start, end, candies):\n        if start == end:\n            return 0\n        if visited[start]:\n            return float('inf')\n        visited[start] = True\n        res = float('inf')\n        for node in graph[start]:\n            res = min(res, find_path(graph, visited, node, end, candies) + candies[start - 1])\n        visited[start] = False\n        return res\n\n    N, M, alpha = map(int, stdin.split())\n    graph = [[] for _ in range(N + 1)]\n    candies = list(map(int, stdin.split()))\n    for i in range(M):\n        u, v, c = map(int, stdin.split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (N + 1)\n    energy = find_path(graph, visited, 1, N, candies)\n    if energy == float('inf'):\n        return \"Poor girl\"\n    else:\n        return energy + alpha * (M - 1)\n"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph: list, visited: list, start: int, end: int, path: list) -> bool:\n        visited[start] = True\n        path.append(start)\n        if start == end:\n            return True\n        for i in range(len(graph)):\n            if not visited[i] and graph[start][i] == 1:\n                if find_path(graph, visited, i, end, path):\n                    return True\n        path.pop()\n        visited[start] = False\n        return False\n\n    def min_energy(graph: list, candies: list, K: int) -> int:\n        max_candy = max(candies)\n        return max_candy ** 2 + K * 20\n\n    N, M, alpha = map(int, stdin.readline().split())\n    graph = [[] for _ in range(N + 1)]\n    candies = []\n\n    for _ in range(M):\n        u, v, c = map(int, stdin.readline().split())\n        graph[u].append(v)\n        graph[v].append(u)\n        candies.append(c)\n\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if j not in graph[i]:\n                graph[i].append(j)\n\n    for i in range(1, N + 1):\n        graph[i].sort()\n\n    visited = [False] * (N + 1)\n    path = []\n    start = 1\n    end = 1\n    min_e = float('inf')\n\n    for i in range(1, N + 1):\n        if not visited[i] and find_path(graph, visited, i, end, path):\n            visited = [False] * (N + 1)\n            energy = min_energy(graph, candies, len(path))\n            if energy < min_e:\n                min_e = energy\n\n    return min_e if min_e != float('inf') else \"Poor girl\"\n\n\ndef"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(start: int, end: int, visited: set, roads: list, candies: list) -> int:\n        min_cost = float('inf')\n        for i, road in enumerate(roads):\n            if road[0] == start and road[1] == end and i not in visited:\n                visited.add(i)\n                min_cost = min(min_cost, get_min_cost(end, road[1], visited, roads, candies) + candies[i])\n                visited.remove(i)\n        return min_cost\n\n    N, M, alpha = map(int, stdin.readline().split())\n    roads = [list(map(int, stdin.readline().split())) for _ in range(M)]\n    candies = [roads[i][2] for i in range(M)]\n\n    min_cost = float('inf')\n    for start in range(1, N + 1):\n        for end in range(1, N + 1):\n            if start != end:\n                visited = set()\n                min_cost = min(min_cost, get_min_cost(start, end, visited, roads, candies))\n\n    if min_cost == float('inf'):\n        return \"Poor girl\"\n    else:\n        return min_cost + alpha * M"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(start, end, visited):\n        queue = [(start, 0, 0)]\n        while queue:\n            node, k, energy = queue.pop(0)\n            if node == end:\n                return k, energy\n            for i in range(len(graph)):\n                if visited[i] == 0 and graph[i][0] == node:\n                    visited[i] = 1\n                    queue.append((graph[i][1], k + 1, energy + graph[i][2]))\n                    visited[i] = 0\n        return -1, -1\n\n    N, M, alpha = map(int, stdin.split()[:3])\n    graph = [tuple(map(int, stdin.split()[3 * i:3 * i + 3])) for i in range(1, M + 1)]\n    max_candies = max(graph, key=lambda x: x[2])[2]\n    L = int(max_candies**0.5)\n    k = 0\n    visited = [0] * M\n    energy = 0\n    for i in range(len(graph)):\n        if visited[i] == 0:\n            k += 1\n            start, energy = bfs(graph[i][0], graph[i][1], visited)\n            if start == -1:\n                return \"Poor girl\"\n            visited = [0] * M\n            visited[i] = 1\n            energy += graph[i][2]\n            energy += (alpha * (k - 1))**2\n            if k > L:\n                energy += (alpha * k)**2\n    return energy"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph: list, visited: list, current: int, trip: list, result: list):\n        visited[current] = True\n        trip.append(current)\n        if len(trip) == N:\n            result.append(trip.copy())\n            return\n        for i in range(N):\n            if not visited[i] and graph[current][i]:\n                dfs(graph, visited, i, trip, result)\n        visited[current] = False\n        trip.pop()\n\n    def check_cycles(graph: list, visited: list, current: int, parent: int) -> bool:\n        visited[current] = True\n        for i in range(N):\n            if not visited[i] and graph[current][i]:\n                if check_cycles(graph, visited, i, current):\n                    return True\n        return parent != -1 and graph[parent][current]\n\n    N, M = map(int, stdin.split()[:2])\n    graph = [[False] * N for _ in range(N)]\n    visited = [False] * N\n    for i in range(M):\n        f, t = map(int, stdin.split()[i*2:i*2+2])\n        graph[f][t] = graph[t][f] = True\n\n    result = []\n    for i in range(N):\n        if not visited[i]:\n            dfs(graph, visited, i, [], result)\n        visited = [False] * N\n\n    if not result:\n        return \"Yeah!\"\n\n    for trip in result:\n        print(len(trip))\n        for place in trip:\n            print(place, end=\" \")\n        print()\n    return len(result)\n"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M = map(int, input_data[0].split())\n    edges = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # create graph\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u].append(v)\n\n    # find number of connected components\n    visited = [False] * N\n    count = 0\n    for i in range(N):\n        if not visited[i]:\n            count += 1\n            dfs(graph, i, visited)\n\n    # split places into trips\n    trips = []\n    for i in range(count):\n        trip = []\n        visited = [False] * N\n        stack = [(0, 0)]\n        while stack:\n            u, step = stack.pop()\n            if not visited[u]:\n                trip.append(u)\n                visited[u] = True\n                for v in graph[u]:\n                    if not visited[v]:\n                        stack.append((v, step + 1))\n        trips.append(trip)\n\n    # output result\n    if all(len(trip) == 1 for trip in trips):\n        return \"Yeah!\"\n    else:\n        return str(count) + \"\\n\" + \"\\n\".join(str(len(trip)) + \"\\n\" + \" \".join(map(str, trip)) for trip in trips)\n"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, visited, start, end):\n        queue = [(start, [start])]\n        while queue:\n            (vertex, path) = queue.pop(0)\n            if vertex == end:\n                return path\n            for neighbor in graph[vertex]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    new_path = path + [neighbor]\n                    queue.append((neighbor, new_path))\n        return []\n\n    def find_trips(places, roads):\n        graph = [[] for _ in range(places)]\n        for road in roads:\n            graph[road[0]].append(road[1])\n            graph[road[1]].append(road[0])\n        visited = set()\n        trips = []\n        for start in range(places):\n            if start in visited:\n                continue\n            visited.add(start)\n            for end in range(places):\n                if end in visited:\n                    continue\n                path = bfs(graph, visited, start, end)\n                if path:\n                    visited.add(end)\n                    trips.append(path)\n                    break\n        return trips\n\n    def find_trip_order(places, trips):\n        order = []\n        for trip in trips:\n            order.append(len(trip))\n            order.extend(trip)\n        return order\n\n    stdin = stdin.strip()\n    input_data = list(map(int, stdin.split()))\n    places, roads = input_data[0], input_data[1:]\n    roads = [(road[0], road[1]) for road in roads]\n\n    trips = find_trips(places, roads)\n    if not trips:\n        return \"Yeah!\"\n    else:\n        trip_order = find_trip_order(places, trips)\n        return f\"{len(trips)}\\n{' '.join(map(str, trip_order))}\\n\""
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    streets = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    def dfs(current, places_visited, trip_count, trips):\n        places_visited.add(current)\n        trip_count += 1\n\n        if len(places_visited) == N:\n            trips.append(list(places_visited))\n            return trip_count\n\n        for street in streets:\n            if current in street:\n                next_place = street[0] if street[1] == current else street[1]\n                if next_place not in places_visited:\n                    trip_count = dfs(next_place, places_visited, trip_count, trips)\n\n        places_visited.remove(current)\n        return trip_count\n\n    places_visited = set()\n    trips = []\n    trip_count = dfs(0, places_visited, 0, trips)\n\n    if trip_count < N:\n        return \"Yeah!\"\n\n    print(trip_count)\n    for trip in trips:\n        print(len(trip))\n        for place in trip:\n            print(place)\n\n    return \"\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Check if there's a loop in the graph\n    for i in range(M):\n        for j in range(i+1, M):\n            if roads[i][1] == roads[j][0]:\n                return \"Yeah!\"\n\n    # Check if the graph is a tree\n    visited = [False] * N\n    def dfs(node):\n        visited[node] = True\n        for road in roads:\n            if road[0] == node and not visited[road[1]]:\n                dfs(road[1])\n\n    dfs(0)\n    if sum(visited) == N:\n        return \"Yeah!\"\n\n    # Split the graph into trips\n    trips = []\n    for i in range(N):\n        if visited[i]:\n            continue\n        trip = [i]\n        j = i\n        while True:\n            found_road = False\n            for road in roads:\n                if road[0] == j:\n                    if road[1] in trip:\n                        j = road[0]\n                        trip.append(road[0])\n                        break\n                    else:\n                        j = road[1]\n                        trip.append(road[1])\n                        found_road = True\n                        break\n            if not found_road:\n                break\n        trips.append(trip)\n\n    # Output the trips\n    output = []\n    for trip in trips:\n        output.append(str(len(trip)))\n        for place in trip:\n            output.append(str(place))\n    return \"\\n\".join(output)"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    lines = stdin.split(\"\\n\")\n    N, M = map(int, lines[0].split())\n    roads = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    # Initialize the graph\n    graph = [[] for _ in range(N)]\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Perform DFS to find all connected components\n    visited = [False] * N\n    components = []\n    for i in range(N):\n        if not visited[i]:\n            component = []\n            stack = [i]\n            while stack:\n                u = stack.pop()\n                if not visited[u]:\n                    component.append(u)\n                    visited[u] = True\n                    for v in graph[u]:\n                        stack.append(v)\n            components.append(component)\n\n    # Check if all places are reachable\n    if len(components) == 1 and len(components[0]) == N:\n        # All places are in one connected component, we can split into trips\n        trips = []\n        for i in range(N):\n            if i == 0:\n                trips.append([0])\n            else:\n                trips.append([])\n        for u, v in roads:\n            trips[u].append(v)\n            trips[v].append(u)\n        for trip in trips:\n            print(len(trip))\n            print(\"\\n\".join(map(str, trip)))\n        return len(trips)\n    else:\n        # It's impossible to split into trips\n        return \"Yeah!\"\n"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0].split()[0])\n    M = int(input_list[0].split()[1])\n    roads = [(int(i.split()[0]), int(i.split()[1])) for i in input_list[1:]]\n\n    # Check if it's possible to split the places into trips\n    def is_possible(trip_list):\n        visited = set()\n        for trip in trip_list:\n            for place in trip:\n                if place in visited:\n                    return False\n                visited.add(place)\n        return True\n\n    # Find the trips using a recursive approach\n    def find_trips(road_list, current_trip, trip_list):\n        if len(current_trip) == N:\n            if is_possible(trip_list):\n                trip_list.append(current_trip)\n                return trip_list\n            else:\n                return []\n\n        for i in range(len(road_list)):\n            if road_list[i][0] == current_trip[-1]:\n                new_trip = current_trip.copy()\n                new_trip.append(road_list[i][1])\n                new_roads = road_list.copy()\n                del new_roads[i]\n                result = find_trips(new_roads, new_trip, trip_list)\n                if len(result) > 0:\n                    return result\n\n        return []\n\n    trips = find_trips(roads, [], [])\n\n    if len(trips) == 0:\n        return \"Yeah!\"\n    else:\n        return len(trips)"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    adjacency_list = [[] for _ in range(N)]\n    visited = [False] * N\n    for _ in range(M):\n        u, v = map(int, stdin.split()[2:4])\n        adjacency_list[u].append(v)\n\n    trips = []\n    for i in range(N):\n        if not visited[i]:\n            visited[i] = True\n            trip = []\n            dfs(i, visited, trip, adjacency_list)\n            trips.append(trip)\n\n    if len(trips) == 1:\n        return \"Yeah!\"\n    else:\n        output = [len(trips)]\n        for trip in trips:\n            output.append(len(trip))\n            output.extend(trip)\n        return \"\\n\".join(map(str, output))\n\ndef"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def dfs(start, visited, current_trip):\n        if len(current_trip) == N:\n            trips.append(current_trip)\n            return\n\n        for i, road in enumerate(roads):\n            if road[0] == start and i not in visited:\n                dfs(road[1], visited | {i}, current_trip + [road[1]])\n\n    trips = []\n    dfs(0, set(), [0])\n\n    if len(trips) == 0:\n        return \"Yeah!\"\n\n    return len(trips), '\\n'.join(map(str, sum(trips, [])))\n\ninput_data = '''4 4\n0 1\n1 0\n2 3\n3 2\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, curr, target, path, res, ans):\n        if curr == target:\n            res.append(path.copy())\n            return\n        for node in range(len(graph)):\n            if node not in visited and graph[curr][node]:\n                visited.add(node)\n                path.append(node)\n                dfs(graph, visited, node, target, path, res, ans)\n                visited.remove(node)\n                path.pop()\n\n    def eulerian_tour(graph):\n        start = 0\n        visited = set()\n        res = []\n        ans = []\n        path = [start]\n        dfs(graph, visited, start, len(graph) - 1, path, res, ans)\n        return ans if ans else None\n\n    def split_trips(places, roads):\n        graph = [[0] * len(places) for _ in range(len(places))]\n        for road in roads:\n            graph[road[0]][road[1]] = 1\n            graph[road[1]][road[0]] = 1\n        tour = eulerian_tour(graph)\n        if tour is None:\n            return \"Yeah!\"\n        trips = []\n        for i in range(len(tour) - 1):\n            trip = [tour[i]]\n            for j in range(i + 1, len(tour)):\n                if tour[j] not in trip:\n                    trip.append(tour[j])\n            trips.append(trip)\n        return len(trips), trips\n\n    def main(input_data):\n        N, M = map(int, input_data.pop(0).split())\n        roads = [list(map(int, line.split())) for line in input_data]\n        return split_trips(range(N), roads)\n\n    return main(stdin.split('\\n')) "
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    V, *degrees = map(int, stdin.split())\n    degrees = list(degrees)\n\n    # Check if it is possible to construct the forest\n    if any(d > V for d in degrees):\n        return \"IMPOSSIBLE\\n\"\n\n    # Compute the total number of edges\n    E = sum(degrees) // 2\n\n    # Compute the maximum degree\n    max_degree = max(degrees)\n\n    # Construct the forest\n    forest = []\n    for d in degrees:\n        tree = [i + 1 for i in range(V) if degrees[i] == d]\n        forest.append(tree)\n\n    # Check if the forest is valid\n    for tree in forest:\n        for i in range(1, len(tree)):\n            for j in range(i):\n                if tree[i] in forest[j]:\n                    return \"IMPOSSIBLE\\n\"\n\n    # Return the edges of the forest\n    result = []\n    for i in range(len(forest)):\n        for j in range(1, len(forest[i])):\n            result.append((forest[i][j], forest[i][j-1]))\n    result = sorted(result)\n\n    return \"POSSIBLE\\n\" + \"\\n\".join(f\"{a} {b}\" for a, b in result) + \"\\n\" "
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    num_vertices = int(input_list[0])\n    vertex_degrees = list(map(int, input_list[1].split()))\n\n    # Check if it is possible to construct such a forest\n    total_degree = sum(vertex_degrees)\n    if total_degree % 2 != 0:\n        return \"IMPOSSIBLE\"\n\n    # Create a list to keep track of the remaining vertices and degrees\n    remaining_vertices = list(range(1, num_vertices + 1))\n    remaining_degrees = vertex_degrees.copy()\n\n    # Construct the forest\n    edges = []\n    for i in range(1, num_vertices // 2 + 1):\n        for j in range(i + 1, num_vertices + 1):\n            if remaining_degrees[i - 1] >= 1 and remaining_degrees[j - 1] >= 1:\n                edges.append((i, j))\n                remaining_degrees[i - 1] -= 1\n                remaining_degrees[j - 1] -= 1\n                remaining_vertices.remove(i)\n                remaining_vertices.remove(j)\n                if len(remaining_vertices) == 0:\n                    return \"POSSIBLE\"\n    return \"POSSIBLE\" if len(remaining_vertices) == 0 else \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(V: int, degrees: List[int]) -> bool:\n        if sum(degrees) % 2 != 0:\n            return False\n        max_degree = max(degrees)\n        if max_degree > len(degrees) - max_degree:\n            return False\n        return True\n\n    def graph_theoretical_forest(V: int, degrees: List[int]) -> str:\n        adj_list = [[] for _ in range(V)]\n        in_degree = [0] * V\n        for i, degree in enumerate(degrees):\n            if degree > 0:\n                adj_list[i].append(i)\n                in_degree[i] = degree\n\n        def add_edge(u: int, v: int):\n            adj_list[u].append(v)\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                q.append(v)\n\n        q = deque()\n        for i, degree in enumerate(degrees):\n            if degree == 1:\n                q.append(i)\n\n        while q:\n            u = q.popleft()\n            for v in adj_list[u]:\n                add_edge(u, v)\n\n        if len(q) < V:\n            return \"IMPOSSIBLE\"\n\n        edges = []\n        for u in range(V):\n            for v in adj_list[u]:\n                edges.append((u + 1, v + 1))\n\n        return \"POSSIBLE\\n\" + \"\\n\".join(str(e) for e in edges)\n\n    V, *degrees = map(int, stdin.strip().split())\n    degrees = list(degrees)\n    if not is_possible(V, degrees):\n        return \"IMPOSSIBLE\"\n    else:\n        return graph_theoretical_forest(V, degrees) "
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    V, *degree = map(int, stdin.split())\n    degree = list(degree)\n    if any(d > 100 for d in degree):\n        return \"IMPOSSIBLE\"\n\n    forest = []\n    for v, d in enumerate(degree, start=1):\n        if d == 0:\n            return \"IMPOSSIBLE\"\n        tree = [v]\n        for _ in range(d):\n            tree.append(len(forest) + 1)\n            forest.append(tree)\n\n    return \"POSSIBLE\\n\" + \"\\n\".join(f\"{a} {b}\" for tree in forest for a, b in zip(tree, tree[1:]))"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    V, *degrees = map(int, stdin.split())\n\n    # Calculate total degree\n    total_degree = sum(degrees)\n\n    # Check if total degree is even or odd\n    if total_degree % 2 == 0:\n        # Even total degree\n        even_degrees = [d for d in degrees if d % 2 == 0]\n        odd_degrees = [d for d in degrees if d % 2 == 1]\n\n        if len(even_degrees) % 2 != 0:\n            # Odd number of even degrees, impossible\n            return \"IMPOSSIBLE\\n\"\n\n        if len(odd_degrees) % 2 != 0:\n            # Odd number of odd degrees, impossible\n            return \"IMPOSSIBLE\\n\"\n\n        # Even number of even and odd degrees, possible\n        return \"POSSIBLE\\n\" + \"\\n\".join(f\"{i} {i+1}\" for i in range(0, V-1, 2)) + \"\\n\" + \"\\n\".join(f\"{i} {i+2}\" for i in range(1, V, 2))\n    else:\n        # Odd total degree, impossible\n        return \"IMPOSSIBLE\\n\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    num_vertices = int(input_lines[0])\n    degrees = list(map(int, input_lines[1].split()))\n    \n    if len(degrees) != num_vertices or any(d < 0 or d > 100 for d in degrees):\n        return \"IMPOSSIBLE\"\n    \n    # Create a graph where each vertex has the required degree\n    graph = [[] for _ in range(num_vertices)]\n    for i in range(num_vertices):\n        for _ in range(degrees[i]):\n            graph[i].append(len(graph))\n    \n    # Check if the graph is a forest\n    visited = [False] * num_vertices\n    def dfs(v):\n        visited[v] = True\n        for neighbor in graph[v]:\n            if not visited[neighbor]:\n                dfs(neighbor)\n    \n    connected_components = 0\n    for i in range(num_vertices):\n        if not visited[i]:\n            dfs(i)\n            connected_components += 1\n    \n    if connected_components == 1:\n        # There is only one connected component, so it is a forest\n        edges = []\n        for i in range(num_vertices):\n            for neighbor in graph[i]:\n                if neighbor != i:\n                    edges.append((i+1, neighbor+1))\n        return \"POSSIBLE\\n\" + \"\\n\".join(map(str, edges))\n    else:\n        return \"IMPOSSIBLE\"\n\ninput_example1 = \"\"\"3\n1 1 2\"\"\"\ninput_example2 = \"\"\"2\n1 2\"\"\"\n\nprint(solution(input_example1)) # Output: POSSIBLE\n1 3\n2 3\n\nprint(solution(input_example2)) # Output: IMPOSSIBLE"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    vertices = int(input_list[0])\n    degrees = list(map(int, input_list[1].split()))\n\n    # Check if the forest is possible\n    for degree in degrees:\n        if degree <= 0 or degree > 100:\n            return \"IMPOSSIBLE\"\n\n    # Construct the forest\n    adjacency_list = [[] for _ in range(vertices)]\n\n    for vertex, degree in enumerate(degrees):\n        while degree > 0:\n            for neighbor in range(vertex + 1, vertices):\n                adjacency_list[vertex].append(neighbor)\n                if degree == 1:\n                    break\n                degree -= 1\n            else:\n                continue\n            break\n\n    # Check if there is a cycle in the forest\n    visited = [False] * vertices\n    recursion_stack = [False] * vertices\n\n    def dfs(vertex: int) -> bool:\n        visited[vertex] = True\n        recursion_stack[vertex] = True\n\n        for neighbor in adjacency_list[vertex]:\n            if visited[neighbor]:\n                if recursion_stack[neighbor]:\n                    return True\n            elif not dfs(neighbor):\n                return False\n\n        recursion_stack[vertex] = False\n        return True\n\n    for vertex in range(vertices):\n        if dfs(vertex):\n            return \"IMPOSSIBLE\"\n\n    # Print the edges of the forest\n    output = \"POSSIBLE\\n\"\n    for vertex in range(vertices):\n        for neighbor in adjacency_list[vertex]:\n            output += f\"{vertex + 1} {neighbor + 1}\\n\"\n\n    return output\n"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    V = int(input_data[0])\n    degrees = list(map(int, input_data[1].split()))\n    \n    # Check if it's impossible to construct the forest\n    for degree in degrees:\n        if degree < 1:\n            return \"IMPOSSIBLE\"\n    \n    # Construct the forest\n    forest = []\n    for i in range(V):\n        tree = [i + 1] * degrees[i]\n        forest.append(tree)\n    \n    # Check if there are any cycles in the forest\n    def has_cycle(forest: list, parent: int, visited: set) -> bool:\n        visited.add(parent)\n        for child in forest[parent - 1]:\n            if child - 1 not in visited:\n                if has_cycle(forest, child - 1, visited):\n                    return True\n        return False\n    \n    for i in range(V):\n        if has_cycle(forest, i + 1, set()):\n            return \"IMPOSSIBLE\"\n    \n    # Construct the edges\n    edges = []\n    for i in range(V):\n        for j in range(degrees[i]):\n            edges.append((i + 1, forest[i][j]))\n    \n    # Print the result\n    result = \"POSSIBLE\\n\"\n    for edge in edges:\n        result += f\"{edge[0]} {edge[1]}\\n\"\n    return result"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    n = int(inputs[0])\n    if n <= 0:\n        return \"IMPOSSIBLE\"\n    degrees = list(map(int, inputs[1].split()))\n    if len(degrees) != n:\n        return \"IMPOSSIBLE\"\n\n    tree_sizes = [1] * n\n    for i in range(n):\n        if degrees[i] <= 0:\n            return \"IMPOSSIBLE\"\n        if degrees[i] > 2 * n:\n            return \"IMPOSSIBLE\"\n        tree_sizes[i] = degrees[i]\n\n    result = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            if tree_sizes[i] + tree_sizes[j] <= 2 * n:\n                result.append((i + 1, j + 1))\n                tree_sizes[i] += 1\n                tree_sizes[j] += 1\n                break\n        else:\n            return \"IMPOSSIBLE\"\n\n    return \"POSSIBLE\" if len(result) == n else \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_forest(vertices: list, degrees: list) -> bool:\n        if sum(degrees) % 2 != 0:\n            return False\n        for degree in degrees:\n            if degree < 1 or degree > 2:\n                return False\n        for i in range(1, len(degrees)):\n            if degrees[i] != degrees[i - 1] + 1:\n                return False\n        return True\n\n    def construct_forest(vertices: int, degrees: list) -> str:\n        result = \"\"\n        for i in range(vertices - 1):\n            result += f\"{i + 1} {i + 2}\\n\"\n        result += f\"{vertices} 1\\n\"\n        return result\n\n    V, *degrees = map(int, stdin.split())\n    if not is_valid_forest([1] + degrees, degrees):\n        return \"IMPOSSIBLE\"\n    else:\n        return \"POSSIBLE\\n\" + construct_forest(V, degrees)\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_coplanar(points):\n        return len(set(points)) == 1\n\n    def compute_center(points):\n        x, y, z = 0, 0, 0\n        for point in points:\n            x += point[0]\n            y += point[1]\n            z += point[2]\n        return x / len(points), y / len(points), z / len(points)\n\n    def distance(point1, point2):\n        return ((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2 + (point1[2] - point2[2]) ** 2) ** 0.5\n\n    def compute_sphere(points):\n        center = compute_center(points)\n        radius = 0\n        for point in points:\n            radius = max(radius, distance(point, center))\n        return center, radius\n\n    def main():\n        points = []\n        for i in range(4):\n            x, y, z = map(int, input().split())\n            points.append((x, y, z))\n\n        if is_coplanar(points):\n            print(\"Coplanar points, cannot find a sphere\")\n            return\n\n        center, radius = compute_sphere(points)\n        print(f\"{center[0]:.5f} {center[1]:.5f} {center[2]:.5f}\")\n\n    if stdin:\n        input_data = stdin.split(\"\\n\")\n        sys.stdin = StringIO(\"\\n\".join(input_data[:-1]))\n\n    main()\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def dist(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    points = []\n    for line in stdin.splitlines():\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    A, B, C, D = points\n\n    # Find the equation of the plane containing the three points A, B, C\n    v1 = [B[i] - A[i] for i in range(3)]\n    v2 = [C[i] - A[i] for i in range(3)]\n    n = cross(v1, v2)\n\n    # Find the equation of the plane containing the three points A, B, D\n    v1 = [B[i] - A[i] for i in range(3)]\n    v2 = [D[i] - A[i] for i in range(3)]\n    m = cross(v1, v2)\n\n    # Find the intersection point of the two planes\n    k = cross(n, m)\n    a, b, c = k\n    d = dot(k, A)\n\n    # Check if the sphere passes through all the four points\n    if all(dist((a * x ** 2 + b * y ** 2 + c * z ** 2 + d), A) < 10 ** -4 for x, y, z in points):\n        return f\"{a / 2} {b / 2} {c / 2}\"\n    else:\n        return \"The points do not belong to a unique sphere.\"\n\n\ndef"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from itertools import combinations\n    from math import sqrt\n\n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2)\n\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split()[i * 3:i * 3 + 3])\n        points.append((x, y, z))\n\n    combs = combinations(points, 3)\n    for c in combs:\n        a, b, c = c\n        d = (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]) / distance(a, b)\n        if abs(d - distance(a, c)) < 1e-4:\n            x_c, y_c, z_c = (a[0] + b[0] + c[0]) / 3, (a[1] + b[1] + c[1]) / 3, (a[2] + b[2] + c[2]) / 3\n            return f\"{x_c} {y_c} {z_c}\"\n\n    # if no sphere found, return the centroid of the points\n    x_c, y_c, z_c = (sum(points[i][j] for i in range(4)) / 4 for j in range(3))\n    return f\"{x_c} {y_c} {z_c}\"\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x: int, y: int, z: int, c: int) -> float:\n        return sqrt((x - c)**2 + (y - c)**2 + (z - c)**2)\n\n    def compute_center(points: List[Tuple[int, int, int]]) -> Tuple[int, int, int]:\n        x_sum = y_sum = z_sum = 0\n        for x, y, z in points:\n            x_sum += x\n            y_sum += y\n            z_sum += z\n        return x_sum // 4, y_sum // 4, z_sum // 4\n\n    points = [(int(x.strip()) for x in line.split()) for line in stdin.split('\\n')]\n    if len(points) != 4:\n        raise ValueError(\"Input must contain four points\")\n\n    center = compute_center(points)\n    min_distance = min(distance(x, y, z, center[0]) for x, y, z in points)\n    return f\"{center[0]:.6f} {center[1]:.6f} {center[2]:.6f}\"\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    points = []\n    for i in range(4):\n        x, y, z = map(int, input_list[i].split())\n        points.append((x, y, z))\n\n    x_sum = sum(x for x, _, _ in points)\n    y_sum = sum(y for _, y, _ in points)\n    z_sum = sum(z for _, _, z in points)\n\n    center = (x_sum / 4, y_sum / 4, z_sum / 4)\n\n    return \" \".join(map(str, center))\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    points = []\n    for i in range(4):\n        x, y, z = map(int, stdin.split())\n        points.append((x, y, z))\n\n    # Find the center of the sphere\n    x_c, y_c, z_c = 0, 0, 0\n    for p in points:\n        x_c += p[0]\n        y_c += p[1]\n        z_c += p[2]\n    x_c /= 4\n    y_c /= 4\n    z_c /= 4\n\n    # Check if the sphere passes the test cases\n    for p in points:\n        if abs(sqrt((x_c - p[0])**2 + (y_c - p[1])**2 + (z_c - p[2])**2) - 1) > 1e-4:\n            return \"The sphere does not pass the test cases.\"\n\n    # Return the center of the sphere\n    return f\"{x_c} {y_c} {z_c}\""
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(a, b):\n        return [a[1]*b[2] - a[2]*b[1], a[2]*b[0] - a[0]*b[2], a[0]*b[1] - a[1]*b[0]]\n\n    def dot_product(a, b):\n        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2]\n\n    def distance(p1, p2):\n        return ((p1[0]-p2[0])**2 + (p1[1]-p2[1])**2 + (p1[2]-p2[2])**2)**0.5\n\n    def circumcenter(p1, p2, p3):\n        a = p1\n        b = p2\n        c = p3\n\n        # Compute the directing vectors u and v\n        u = cross_product(cross_product(b-a, c-a), b-a)\n        v = cross_product(cross_product(c-a, b-a), c-a)\n\n        # Compute the orthogonal complement of (u, v)\n        p = cross_product(u, v)\n        p = [p[0]/distance(p1, p2), p[1]/distance(p1, p2), p[2]/distance(p1, p2)]\n\n        # Compute the circumcenter\n        return [(a[0]+b[0]+c[0]+p[0])/4, (a[1]+b[1]+c[1]+p[1])/4, (a[2]+b[2]+c[2]+p[2])/4]\n\n    def main(stdin: str) -> str:\n        points = []\n        for i in range(4):\n            x, y, z = map(int, stdin.readline().split())\n            points.append((x, y, z))\n\n        center = circumcenter(points[0], points[1], points[2])\n        if distance(center, points[3]) > 1e-4:\n            center = circumcenter(points[0], points[1], points[3])\n\n        return '{:.10f} {:.10f} {:.10f}'.format(center[0], center[1], center[2])\n\n    return main(stdin) "
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_collinear(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        return (x1 * (y2 - y3) + y1 * (z3 - z2) + z1 * (x2 - x3)) == 0\n\n    def distance(p1, p2):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2 + (z1 - z2) ** 2) ** 0.5\n\n    def center_of_sphere(p1, p2, p3):\n        x1, y1, z1 = p1\n        x2, y2, z2 = p2\n        x3, y3, z3 = p3\n        x_center = (x1 * 2 + x2 + x3) / 4\n        y_center = (y1 * 2 + y2 + y3) / 4\n        z_center = (z1 * 2 + z2 + z3) / 4\n        return (x_center, y_center, z_center)\n\n    lines = stdin.splitlines()\n    points = [tuple(map(int, line.split())) for line in lines]\n\n    if len(points) != 4:\n        raise ValueError(\"Input must contain exactly four points\")\n\n    if not all(is_collinear(points[i], points[j], points[k]) for i in range(4) for j in range(i + 1, 4) for k in range(j + 1, 4)):\n        raise ValueError(\"Points must be coplanar\")\n\n    center = center_of_sphere(points[0], points[1], points[2])\n\n    min_distance = distance(points[3], center)\n    if min_distance < 10 ** -4:\n        return f\"{center[0]:.3f} {center[1]:.3f} {center[2]:.3f}\"\n    else:\n        raise ValueError(\"Points must be coplanar and collinear\")"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def find_centre(points):\n        \"\"\"\n        Given four points in 3D space, find the centre of the sphere that passes through them.\n        \"\"\"\n        x = y = z = 0\n        for point in points:\n            x += point[0]\n            y += point[1]\n            z += point[2]\n        x /= 4\n        y /= 4\n        z /= 4\n        return x, y, z\n\n    def is_sphere(points, centre):\n        \"\"\"\n        Given four points in 3D space and the centre of a sphere, check if the sphere passes through all the points.\n        \"\"\"\n        for point in points:\n            dist = sum((p - c) ** 2 for p, c in zip(point, centre)) ** 0.5\n            if dist >= 10**-4:\n                return False\n        return True\n\n    points = []\n    for line in stdin.split('\\n'):\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    while not is_sphere(points, find_centre(points)):\n        points[0] = (points[0][0] + 10**-4, points[0][1], points[0][2])\n        points[1] = (points[1][0] - 10**-4, points[1][1], points[1][2])\n        points[2] = (points[2][0], points[2][1] + 10**-4, points[2][2])\n        points[3] = (points[3][0], points[3][1] - 10**-4, points[3][2])\n\n    return ' '.join(str(c) for c in find_centre(points))\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    points = []\n    for line in stdin.splitlines():\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    max_distance = 0\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            max_distance = max(max_distance, distance(points[i], points[j]))\n\n    sphere_radius = max_distance / 2\n    sphere_center = (sum(x for x, _, _ in points) / len(points),\n                    sum(y for _, y, _ in points) / len(points),\n                    sum(z for _, _, z in points) / len(points))\n\n    return f\"{sphere_center[0]:.3f} {sphere_center[1]:.3f} {sphere_center[2]:.3f}\"\n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N = int(input_list[0])\n    V = list(map(int, input_list[1].split()))\n\n    queue = V.copy()\n    M = 0\n\n    while len(set(queue)) > 1:\n        M += 1\n        next_queue = []\n        for i in range(len(queue)):\n            if i > 0 and queue[i] < queue[i - 1]:\n                queue.pop(i)\n            elif i < len(queue) - 1 and queue[i] < queue[i + 1]:\n                queue.pop(i)\n            else:\n                next_queue.append(queue[i])\n        queue = next_queue.copy()\n\n    return f\"{M}\\n{queue}\\n{queue}\""
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    values = list(map(int, input_list[1].split()))\n    left_neighbors = [values[i-1] if i > 0 else float('inf') for i in range(n)]\n    right_neighbors = [values[i+1] if i < n-1 else float('inf') for i in range(n)]\n    \n    minutes = 0\n    left_leaving = []\n    right_leaving = []\n    while True:\n        left_leaving.append(values[0])\n        right_leaving.append(values[-1])\n        for i in range(n):\n            if left_neighbors[i] > values[i] or right_neighbors[i] > values[i]:\n                values.pop(i)\n                left_neighbors.pop(i)\n                right_neighbors.pop(i)\n                n -= 1\n                minutes += 1\n                break\n        else:\n            break\n    \n    result = f\"{minutes}\\n\"\n    for i in range(minutes):\n        result += f\"{left_leaving[i]} \"\n    result += \"\\n\"\n    for i in range(minutes):\n        result += f\"{right_leaving[minutes-i-1]} \"\n    result += \"\\n\"\n    result += \" \".join(str(x) for x in values)\n    \n    return result\n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    v = list(map(int, input_list[1].split()))\n\n    queue = v\n    M = 0\n    while len(queue) > 1:\n        for i in range(1, len(queue)):\n            if queue[i] > queue[i-1]:\n                queue.pop(i)\n                M += 1\n                break\n        else:\n            continue\n        break\n\n    result = []\n    for i in range(M):\n        result.append(\" \".join(map(str, queue[i:])))\n\n    result.append(\" \".join(map(str, queue)))\n\n    return \"\\n\".join(map(str, [M] + result))\n\ndef"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, *v = map(int, stdin.split())\n    v = sorted(enumerate(v), key=lambda x: x[1], reverse=True)\n    queue = [i for i, _ in v]\n    M = 0\n    while queue:\n        M += 1\n        candidates = [queue[0], queue[-1]]\n        for i in range(1, len(queue) - 1):\n            if v[i][1] < v[i - 1][1] or v[i][1] < v[i + 1][1]:\n                candidates.append(queue[i])\n                candidates.sort()\n                break\n        for candidate in candidates:\n            queue.remove(candidate)\n        print(' '.join(map(str, [c[1] for c in v if c[0] in candidates])))\n    print(M)\n    print(' '.join(map(str, [v[i][1] for i in range(N)])))\n\ninput_str = \"\"\"\n10\n3 6 2 3 2 2 2 1 5 6\n\"\"\"\noutput_str = \"\"\"\n2\n3 2 2 1 5\n3 2 2\n6 6\n\"\"\""
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbor_value(resumes, i, n):\n        if i == 0:\n            return resumes[i+1]\n        elif i == n-1:\n            return resumes[i-1]\n        else:\n            return max(resumes[i-1], resumes[i+1])\n\n    def print_queue(queue, n):\n        result = []\n        for i, candidate in enumerate(queue):\n            if candidate:\n                result.append(candidate[1])\n            else:\n                result.append(0)\n        return \" \".join(map(str, result))\n\n    N, *v = map(int, stdin.split())\n    resumes = sorted(enumerate(v), key=lambda x: x[1])\n    queue = [None] * N\n    n = 0\n    M = 0\n\n    while n < N:\n        M += 1\n        to_leave = set()\n        for i in range(N):\n            if not queue[i]:\n                neighbor_value = get_neighbor_value(resumes, i, N)\n                if neighbor_value > resumes[i][1]:\n                    to_leave.add(i)\n                    queue[i] = resumes[i]\n\n        n += len(to_leave)\n        print(print_queue(queue, N))\n        for i in to_leave:\n            queue[i] = None\n\n    print(M)\n    print(print_queue(queue, N))\n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    values = list(map(int, input_data[1].split()))\n\n    queue = values[:]\n    minutes = 0\n    left_neighbors = []\n\n    while True:\n        left_neighbors = [queue[i] for i in range(len(queue)) if i == 0 or queue[i - 1] > queue[i]]\n        right_neighbors = [queue[i] for i in range(len(queue)) if i == len(queue) - 1 or queue[i + 1] > queue[i]]\n\n        if not left_neighbors and not right_neighbors:\n            break\n\n        for i in range(len(queue)):\n            if left_neighbors and queue[i] < left_neighbors[0]:\n                queue[i] = -1\n            if right_neighbors and queue[i] < right_neighbors[0]:\n                queue[i] = -1\n\n        queue = [v for v in queue if v != -1]\n        minutes += 1\n\n    output = \"\"\n    output += str(minutes) + \"\\n\"\n\n    for i in range(len(queue)):\n        output += str(queue[i])\n        if i < len(queue) - 1:\n            output += \" \"\n\n    output += \"\\n\" + \" \".join(str(v) for v in values)\n    return output\n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    values = list(map(int, input_list[1].split()))\n\n    queue = values[:N]\n    M = 0\n    while True:\n        M += 1\n        leave = []\n        for i in range(N):\n            if queue[i] < queue[(i+1)%N]:\n                leave.append(i)\n\n        if not leave:\n            break\n\n        for i in leave:\n            queue.pop(i)\n        N -= len(leave)\n\n    if M == 0:\n        M = 1\n\n    result = []\n    for i in range(M):\n        result.append(str(queue[i:N+i]))\n\n    return str(M) + \"\\n\" + \"\\n\".join(result) + \"\\n\" + \" \".join(map(str, queue))\n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    v = list(map(int, input_list[1].split()))\n    \n    def is_better(i):\n        if i == 0 or i == N - 1:\n            return False\n        else:\n            return v[i] > v[i - 1] and v[i] > v[i + 1]\n    \n    m = 0\n    while True:\n        left = 0\n        right = N - 1\n        while left < right:\n            if is_better(left):\n                left += 1\n            elif is_better(right):\n                right -= 1\n            else:\n                break\n        if left == right:\n            break\n        else:\n            m += 1\n            print(\" \".join(map(str, [v[i] for i in range(left, right + 1)])))\n            v = v[:left] + v[right + 1:]\n    \n    print(m)\n    print(\" \".join(map(str, v)))\n    \n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    V = list(map(int, input_list[1].split()))\n\n    def get_neighbors(index: int) -> List[int]:\n        neighbors = []\n        if index > 0:\n            neighbors.append(V[index - 1])\n        if index < N - 1:\n            neighbors.append(V[index + 1])\n        return neighbors\n\n    def leave_queue(index: int) -> None:\n        nonlocal V\n        V[index] = -1\n\n    M = 0\n    while True:\n        num_leaves = 0\n        for i in range(N):\n            if V[i] == -1:\n                continue\n            neighbors = get_neighbors(i)\n            if any(neighbor > V[i] for neighbor in neighbors):\n                leave_queue(i)\n                num_leaves += 1\n        if num_leaves == 0:\n            break\n        M += 1\n\n    result = []\n    for i in range(N):\n        if V[i] != -1:\n            result.append(V[i])\n\n    return f\"{M}\\n\" + '\\n'.join(map(str, result)) + '\\n' + ' '.join(map(str, V))\n"
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, *v = map(int, stdin.split())\n    value = [v[i] for i in range(N)]\n    queue = list(range(N))\n    removed = []\n    minute = 0\n\n    while len(queue) > 1:\n        min_value = min(value[queue[0]], value[queue[-1]])\n        for i in range(len(queue)):\n            if value[queue[i]] > min_value:\n                removed.append(queue.pop(i))\n                break\n\n        if removed:\n            minute += 1\n            for i in range(len(removed)):\n                print(value[removed[i]], end=\" \")\n            print()\n            removed.sort(reverse=True)\n            for i in range(len(removed)):\n                value.pop(removed[i])\n            removed = []\n            for i in range(len(queue)):\n                queue[i] -= len(removed)\n\n    for i in range(len(queue)):\n        print(value[queue[i]], end=\" \")\n    print()\n    print(minute)\n"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e, b, p = map(int, stdin.split()[:5])\n    roads = {}\n    for _ in range(m):\n        a, b, l = map(int, stdin.split()[5:8])\n        roads[f\"{a}-{b}\"] = l\n\n    # Find minimal speed\n    minimal_speed = find_minimal_speed(roads, n, e, b, p)\n    if minimal_speed is None:\n        return \"IMPOSSIBLE\"\n    else:\n        return round(minimal_speed, 6)\n\ndef"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, e = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:m+1]]\n    highway_exits = list(map(int, input_data[m+1].split()))\n    start_brothers, start_police = map(int, input_data[-1].split())\n\n    # Create a graph where vertices are intersections and edges are roads\n    graph = defaultdict(set)\n    for a, b, l in roads:\n        graph[a].add((b, l))\n        graph[b].add((a, l))\n\n    # Find the shortest path from the brothers' starting point to the police car's starting point\n    queue = [(start_brothers, 0)]\n    visited = set()\n    while queue:\n        node, dist = queue.pop(0)\n        if node == start_police:\n            return \"IMPOSSIBLE\"\n        if node not in visited:\n            visited.add(node)\n            for neighbor, length in graph[node]:\n                queue.append((neighbor, dist + length))\n\n    # Calculate the speed required to escape from the city using the in-car escape system\n    escape_speed = 0\n    for a, b, l in roads:\n        if a == start_brothers and b == start_police:\n            escape_speed = l\n            break\n\n    return escape_speed / 100"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, e = map(int, input_data[0].split())\n    road_data = [list(map(int, line.split())) for line in input_data[1:m+1]]\n    highway_exits = [int(i) for i in input_data[m+1].split()]\n    start_brothers, start_police = map(int, input_data[-1].split())\n    \n    # Create a graph where each vertex represents an intersection and each edge represents a road\n    graph = [[] for _ in range(n)]\n    for road in road_data:\n        graph[road[0]-1].append((road[1]-1, road[2]))\n        graph[road[1]-1].append((road[0]-1, road[2]))\n    \n    # BFS to find the shortest distance from each exit to the police station\n    distances = [float('inf')] * n\n    distances_from_exits = [float('inf')] * n\n    for exit_index in highway_exits:\n        distances[exit_index-1] = 0\n        distances_from_exits[exit_index-1] = 0\n    queue = [(exit_index, 0) for exit_index in highway_exits]\n    while queue:\n        intersection, distance = queue.pop(0)\n        for neighbor, length in graph[intersection]:\n            if distances[neighbor] > distance + length:\n                distances[neighbor] = distance + length\n                queue.append((neighbor, distance + length))\n    \n    # Calculate the minimal speed needed to escape\n    brothers_distance = distances[start_brothers-1]\n    police_distance = distances[start_police-1]\n    if brothers_distance == float('inf') or police_distance == float('inf'):\n        return \"IMPOSSIBLE\"\n    escape_speed = (brothers_distance + police_distance) / (police_distance - brothers_distance)\n    \n    return round(escape_speed, 6)"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(intersections, a, b):\n        return sum(intersections[i][1] for i in range(a, b))\n\n    def shortest_path(intersections, a, b):\n        dist = [float('inf')] * len(intersections)\n        dist[a] = 0\n\n        queue = [(a, 0)]\n        while queue:\n            curr, dist_to_curr = queue.pop(0)\n\n            for next_node, length in intersections[curr]:\n                new_dist = dist_to_curr + length\n                if new_dist < dist[next_node]:\n                    dist[next_node] = new_dist\n                    queue.append((next_node, new_dist))\n\n        return dist[b]\n\n    def escape_speed(intersections, a, b, p):\n        distance_a_p = shortest_path(intersections, a, p)\n        distance_b_p = shortest_path(intersections, b, p)\n        distance = distance_a_p + distance_b_p\n\n        speed = 160 / distance\n        return speed\n\n    def min_escape_speed(intersections, a, b, p):\n        min_speed = float('inf')\n\n        for road_a, road_b, length in intersections:\n            if road_a == p or road_b == p:\n                continue\n\n            speed = escape_speed(intersections, road_a, road_b, p)\n            if speed < min_speed:\n                min_speed = speed\n\n        if min_speed == float('inf'):\n            return \"IMPOSSIBLE\"\n        else:\n            return min_speed\n\n    lines = stdin.split('\\n')\n    n, m, e = map(int, lines[0].split())\n    intersections = [[] for _ in range(n)]\n\n    for i in range(1, m + 1):\n        a, b, l = map(int, lines[i].split())\n        intersections[a - 1].append((b - 1, l))\n        intersections[b - 1].append((a - 1, l))\n\n    for i in range(e):\n        intersections[i] = sorted(intersections[i], key=lambda x: x[1])\n\n    a, p = map(int, lines[-2].split())\n    b, _ = map(int, lines[-1].split())\n\n    return min_escape_speed(intersections, a - 1, b - 1, p - 1)"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: int, b: int, c: int) -> float:\n        return abs(a - b) + abs(b - c)\n\n    def min_speed(a: int, b: int, c: int, d: int) -> float:\n        return 2 * distance(a, b, d) / (distance(a, b, c) + distance(b, c, d))\n\n    def is_possible(a: int, b: int, c: int, d: int, speed: float) -> bool:\n        return min_speed(a, b, c, d) <= speed\n\n    def escape_route(a: int, b: int, c: int, d: int) -> bool:\n        return distance(a, b, d) <= distance(a, b, c)\n\n    n, m, e = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    highway_exits = list(map(int, stdin.readline().split()))\n    a, p = map(int, stdin.readline().split())\n\n    for i in range(m):\n        for j in range(i + 1, m):\n            if roads[i][1] == roads[j][0]:\n                roads[i], roads[j] = roads[j], roads[i]\n\n    road_lengths = [roads[i][2] for i in range(m)]\n\n    road_groups = {}\n    for i in range(m):\n        for j in range(i + 1, m):\n            if roads[i][1] == roads[j][0]:\n                if roads[i][0] not in road_groups:\n                    road_groups[roads[i][0]] = [i]\n                else:\n                    road_groups[roads[i][0]].append(i)\n\n                if roads[j][0] not in road_groups:\n                    road_groups[roads[j][0]] = [j]\n                else:\n                    road_groups[roads[j][0]].append(j)\n\n    for i in range(n):\n        if i not in road_groups:\n            road_groups[i] = [k for k in range(m) if roads[k][0] == i or roads[k][1] == i]\n\n    total_length = sum(road_lengths)\n\n    p_distances = {}\n    for i in range(n):\n        p_distances[i] = sum(distance(i, j, p) for j in highway_exits)\n\n    b_distances = {}\n    for i in range(n):\n        b_distances[i] = sum(distance(a, i, p) for a in highway_exits)\n\n    for speed in range(1, 161):\n        possible = True\n        for i in range(n):\n            for j in range(i + 1, n):\n                if not is_possible(i, j, p, p, speed):\n                    possible = False\n                    break\n            if not possible:\n                break\n\n        if possible:\n            escape_speed = speed\n            break\n\n    for i in range(n):\n        if not escape_route(a, b, p, i):\n            return \"IMPOSSIBLE\"\n\n    return round(escape_speed, 6)"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def distance(start, end, roads):\n        if start == end:\n            return 0\n        for road in roads:\n            if start in road and end in road:\n                return road[road.index(start)+1:].index(end) * 0.01 + distance(road[road.index(start)+1], end, roads)\n        return None\n\n    def min_speed(start, end, roads, speed):\n        if start == end:\n            return 0\n        if distance(start, end, roads) < speed * 0.01:\n            return min_speed(start, end, roads, speed-1)\n        return min_speed(start, end, roads, speed)\n\n    n, m, e = map(int, stdin.readline().split())\n    roads = []\n    for _ in range(m):\n        a, b, l = map(int, stdin.readline().split())\n        roads.append((a, b, l))\n    exits = list(map(int, stdin.readline().split()))\n    start, police = map(int, stdin.readline().split())\n\n    # Set up the graph\n    G = []\n    for i in range(n):\n        G.append([])\n    for a, b, l in roads:\n        G[a-1].append((b-1, l))\n        G[b-1].append((a-1, l))\n\n    # Set up the priority queue\n    pq = [(distance(start-1, start-1, G), start-1, [start-1], 0)]\n\n    while pq:\n        d, v, path, speed = heappop(pq)\n        if v == police-1:\n            break\n        for u, l in G[v]:\n            if u not in path:\n                heappush(pq, (distance(u, u, G)+l+d, u, path+[v], speed))\n\n    return f\"IMPOSSIBLE\" if not pq else f\"{min_speed(start-1, police-1, G, 160):.6f}\" "
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m, e = map(int, input_list[0].split())\n    roads = []\n    for i in range(1, m + 1):\n        a, b, l = map(int, input_list[i].split())\n        roads.append((a, b, l))\n    highway_exits = list(map(int, input_list[m + 1].split()))\n    brothers_start, police_start = map(int, input_list[-1].split())\n    \n    # Create a graph\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b, l in roads:\n        graph[a].append((b, l))\n        graph[b].append((a, l))\n    \n    # Find the shortest path from each highway exit to the brother's start\n    shortest_paths = {i: float('inf') for i in range(1, n + 1)}\n    for highway_exit in highway_exits:\n        shortest_paths[highway_exit] = 0\n        queue = [(highway_exit, 0)]\n        while queue:\n            node, dist = queue.pop(0)\n            if dist < shortest_paths[node]:\n                shortest_paths[node] = dist\n                for neighbor, length in graph[node]:\n                    if shortest_paths[node] + length < shortest_paths[neighbor]:\n                        queue.append((neighbor, shortest_paths[node] + length))\n    \n    # Find the shortest path from the police start to the brother's start\n    shortest_path = float('inf')\n    queue = [(police_start, 0)]\n    while queue:\n        node, dist = queue.pop(0)\n        if dist < shortest_path:\n            shortest_path = dist\n            for neighbor, length in graph[node]:\n                if neighbor == brothers_start and shortest_path + length < shortest_path:\n                    shortest_path = shortest_path + length\n                    break\n                elif neighbor != police_start:\n                    queue.append((neighbor, shortest_path + length))\n    \n    # Calculate the minimal speed\n    if shortest_path == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(shortest_paths[brothers_start] / shortest_path * 160, 6)"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_distance(a: int, b: int, intersections: list) -> int:\n        return sum(intersections[a:b])\n\n    def get_min_speed(a: int, b: int, l: int, speed: int, max_speed: int) -> int:\n        time = l / speed\n        max_time = l / max_speed\n        return min(speed, max_speed) if time <= max_time else max_speed\n\n    def escape_route(n: int, m: int, e: int, intersections: list, highway_exits: list, brothers_start: int, police_start: int) -> str:\n        min_speed = float('inf')\n        for i in range(1, n):\n            if i != brothers_start and i != police_start:\n                dist = get_distance(brothers_start, i, intersections)\n                min_speed = min(min_speed, get_min_speed(brothers_start, i, dist, 160, 160))\n\n                dist = get_distance(police_start, i, intersections)\n                min_speed = min(min_speed, get_min_speed(police_start, i, dist, 160, 160))\n\n        for exit in highway_exits:\n            dist = get_distance(brothers_start, exit, intersections)\n            min_speed = min(min_speed, get_min_speed(brothers_start, exit, dist, 160, 160))\n\n            dist = get_distance(police_start, exit, intersections)\n            min_speed = min(min_speed, get_min_speed(police_start, exit, dist, 160, 160))\n\n        return str(min_speed) if min_speed != float('inf') else 'IMPOSSIBLE'\n\n    lines = stdin.split('\\n')\n    n, m, e = map(int, lines[0].split())\n    intersections = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, m + 1):\n        a, b, l = map(int, lines[i].split())\n        intersections[a][b] += l\n\n    highway_exits = list(map(int, lines[-e:]))\n    brothers_start, police_start = map(int, lines[-2:])\n\n    return escape_route(n, m, e, intersections, highway_exits, brothers_start, police_start)"
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, e = map(int, stdin.split()[:3])\n    roads = [map(int, stdin.split()[3 + i * 3: 3 + (i + 1) * 3]) for i in range(m)]\n    highway_exits = list(map(int, stdin.split()[-e:]))\n    b, p = map(int, stdin.split()[-2:])\n\n    def min_speed(start_a, start_b):\n        # Initialize variables\n        speed = 0\n        road_used = set()\n        road_length = 0\n\n        # Find the shortest path from start_a to start_b\n        stack = [start_a]\n        visited = {start_a}\n        while stack:\n            current = stack[-1]\n\n            # If we have reached the destination, calculate the speed\n            if current == start_b:\n                road_used.add(current)\n                speed = road_length / (visited - {start_a, start_b}).pop() * 3.6\n                return speed\n\n            # Add the unvisited adjacent roads to the stack\n            for a, b, l in roads:\n                if a == current and b not in visited:\n                    visited.add(b)\n                    stack.append(b)\n                    road_used.add(b)\n                    road_length += l\n\n            # If all roads have been visited and we have not reached the destination, there is no solution\n            if len(visited) == n:\n                return None\n\n    # Calculate the minimal speed\n    speed = min_speed(b, p)\n\n    # Check if the brothers can escape\n    for exit in highway_exits:\n        speed_exit = min_speed(exit, p)\n        if speed_exit is not None and (speed is None or speed_exit < speed):\n            speed = speed_exit\n\n    # Check if there is a solution\n    if speed is not None:\n        return round(speed, 6)\n    else:\n        return \"IMPOSSIBLE\""
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, e = map(int, input_list[0].split())\n    roads = [list(map(int, line.split())) for line in input_list[1:m+1]]\n    highway_exits = list(map(int, input_list[m+1].split()))\n    start_brothers, start_police = map(int, input_list[-1].split())\n\n    def get_distance(a: int, b: int) -> float:\n        for road in roads:\n            if a == road[0] and b == road[1]:\n                return road[2]\n        return float('inf')\n\n    def get_speed(a: int, b: int) -> float:\n        distance = get_distance(a, b)\n        if distance == float('inf'):\n            return float('inf')\n        speed = (distance * 1000) / (distance / 160)\n        return min(speed, 160)\n\n    brothers_speed = get_speed(start_brothers, start_police)\n    police_speed = 160\n\n    if brothers_speed == float('inf'):\n        return 'IMPOSSIBLE'\n    return f'{brothers_speed:.6f}'"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, input().split())\n    roads = []\n\n    for _ in range(E):\n        a, b = map(int, input().split())\n        roads.append((a, b))\n\n    def find_roads_to(city: int, chains: list) -> list:\n        result = [0] * E\n        for i, (a, b) in enumerate(roads):\n            if a == city or b == city:\n                result[i] = chains[0]\n                result[i ^ 1] = chains[1]\n        return result\n\n    if N == 1:\n        return \"0\"\n\n    first_chain_roads = find_roads_to(1, [1, 2])\n    if all(x == 0 for x in first_chain_roads):\n        second_chain_roads = find_roads_to(1, [2, 1])\n        return \"\\n\".join(map(str, second_chain_roads))\n    else:\n        return \"\\n\".join(map(str, first_chain_roads)) "
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, E = map(int, input_data[0].split())\n    if N == 1:\n        return \"1\\n\"\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n    road_chains = [-1] * len(roads)\n\n    def is_valid(chain_assignment):\n        for road_index, chain_id in enumerate(chain_assignment):\n            if chain_id == -1:\n                continue\n            for road_index_2, chain_id_2 in enumerate(chain_assignment):\n                if chain_id_2 == -1 or chain_id_2 == chain_id or road_index == road_index_2:\n                    continue\n                for city_1, city_2 in ((roads[road_index][0], roads[road_index_2][0]), (roads[road_index][1], roads[road_index_2][1])):\n                    if (city_1, city_2) not in zip(roads[road_index], roads[road_index_2]):\n                        return False\n        return True\n\n    def assign_roads(chain_assignment):\n        for road_index, chain_id in enumerate(chain_assignment):\n            if chain_id != -1:\n                continue\n            for chain_id_2 in range(1, 3):\n                if chain_id_2 == chain_assignment[road_index - 1] and roads[road_index][0] == roads[road_index - 1][0]:\n                    continue\n                if is_valid(chain_assignment[:road_index] + [chain_id_2] + chain_assignment[road_index:]):\n                    assign_roads(chain_assignment[:road_index] + [chain_id_2] + chain_assignment[road_index:])\n\n    for chain_id in range(1, 3):\n        assign_roads([chain_id] * E)\n\n    for road_index, chain_id in enumerate(road_chains):\n        output = \"1\" if chain_id == 1 else \"2\" if chain_id == 2 else \"0\"\n        yield output + \"\\n\"\n"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_city(graph, visited, start, chain):\n        for neighbor in graph[start]:\n            if visited[neighbor] == -1:\n                visited[neighbor] = chain\n                if find_next_city(graph, visited, neighbor, chain):\n                    return True\n        return False\n\n    N, E = map(int, stdin.split()[:2])\n    graph = [[] for _ in range(N + 1)]\n    roads = list(map(int, stdin.split()[2:]))\n\n    for road in roads:\n        a, b = road\n        graph[a].append(b)\n        graph[b].append(a)\n\n    visited = [-1] * (N + 1)\n\n    for i in range(1, N + 1):\n        if visited[i] == -1 and not find_next_city(graph, visited, i, 1):\n            return \"0\"\n\n    return \" \".join(str(visited[i]) for i in range(1, N + 1))\n"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, E = map(int, input_data[0].split())\n    roads = [list(map(int, line.split())) for line in input_data[1:]]\n\n    # Initialize the matrix for the adjacency graph\n    adjacency_matrix = [[0 for _ in range(N + 1)] for _ in range(N + 1)]\n\n    # Build the adjacency matrix\n    for road in roads:\n        a, b = road\n        adjacency_matrix[a][b] = adjacency_matrix[b][a] = 1\n\n    # Check if there is a way to fairly assign the roads\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if adjacency_matrix[i][j] == 1:\n                adjacency_matrix[i][j] = adjacency_matrix[j][i] = 2\n\n    # Check if the solution is unique\n    if sum(adjacency_matrix[i][i] == 1 for i in range(1, N + 1)) < N:\n        return \"0\\n\"\n\n    # Output the solution\n    return '\\n'.join(str(1 if adjacency_matrix[i][j] == 1 else 2) for i, j in roads) + '\\n'"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, stdin.split()[2 * i + 2:2 * i + 4])) for i in range(E)]\n\n    # Determine chains for each city\n    chains = [set() for _ in range(N)]\n    for a, b in roads:\n        chains[a].add(1)\n        chains[b].add(2)\n\n    # Determine chains for each road\n    roads_chains = []\n    for a, b in roads:\n        if len(chains[a]) == len(chains[b]) == 2:\n            # Both chains have rights to build in this city\n            if 1 in chains[a] and 2 in chains[b]:\n                roads_chains.append(1)\n            elif 2 in chains[a] and 1 in chains[b]:\n                roads_chains.append(2)\n            else:\n                return \"0\"\n        elif len(chains[a]) == len(chains[b]) + 1:\n            # The chain with rights to build has one more city\n            roads_chains.append(chains[a].difference(chains[b]).pop())\n        elif len(chains[a]) + 1 == len(chains[b]):\n            # The chain with rights to build has one more city\n            roads_chains.append(chains[b].difference(chains[a]).pop())\n        else:\n            # The chain with rights to build has no cities in this city\n            roads_chains.append(chains[a].pop())\n\n    return \"\\n\".join(map(str, roads_chains))\n"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    N, E = map(int, input_list[0].split())\n    adj_list = {i + 1: [] for i in range(N)}\n    for i in range(1, N + 1):\n        adj_list[i].append(i)\n    for edge in input_list[1:]:\n        u, v = map(int, edge.split())\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Find all connected components\n    visited = [False] * (N + 1)\n    components = []\n    for i in range(1, N + 1):\n        if not visited[i]:\n            component = []\n            dfs(i, adj_list, visited, component)\n            components.append(component)\n\n    # Check if there is a way to assign the roads\n    if len(components) == 1 and len(components[0]) == N:\n        return \"0\"\n\n    # Assign the roads\n    for edge in input_list[1:]:\n        u, v = map(int, edge.split())\n        u_component = [i for i in components if u in i][0]\n        v_component = [i for i in components if v in i][0]\n        if u_component == v_component:\n            return \"0\"\n        if len(u_component) == 1 and len(v_component) == 1:\n            return \"0\"\n        if len(u_component) == 1:\n            if u_component[0] == u:\n                yield 1\n            else:\n                yield 2\n        elif len(v_component) == 1:\n            if v_component[0] == v:\n                yield 1\n            else:\n                yield 2\n        else:\n            if len(u_component) % 2 == 0:\n                yield 1\n            else:\n                yield 2\n\ndef"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, E = map(int, input_data[0].split())\n    road_data = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Create a graph representing the roads\n    graph = [[] for _ in range(N + 1)]\n    for a, b in road_data:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Determine the fair allocation of roads\n    allocation = [-1] * E\n    for i, (a, b) in enumerate(road_data):\n        chain_a, chain_b = None, None\n        for neighbor in graph[a]:\n            if neighbor != b:\n                chain_a = 1 if chain_a is None else 2\n        for neighbor in graph[b]:\n            if neighbor != a:\n                chain_b = 1 if chain_b is None else 2\n        if chain_a is not None and chain_b is not None:\n            allocation[i] = chain_a if chain_a != chain_b else 3\n\n    if allocation.count(-1) == E:\n        return \"0\"\n\n    return \"\\n\".join(str(allocation[i]) for i in range(E))\n"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, E = map(int, input_list.pop(0).split())\n\n    adj_list = [[] for _ in range(N + 1)]\n    for _ in range(E):\n        a, b = map(int, input_list.pop(0).split())\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    result = []\n    for v in range(1, N + 1):\n        visited = [False] * (N + 1)\n        que = [v]\n        visited[v] = True\n        chain1, chain2 = 0, 0\n\n        while que:\n            u = que.pop(0)\n            for adj in adj_list[u]:\n                if not visited[adj]:\n                    visited[adj] = True\n                    que.append(adj)\n                    if adj in adj_list[v]:\n                        chain1 += 1\n                        chain2 += 1\n                    elif chain1 > 0:\n                        chain2 += 1\n                    elif chain2 > 0:\n                        chain1 += 1\n\n        if chain1 > 0 and chain2 > 0:\n            for adj in adj_list[v]:\n                if adj in adj_list[v]:\n                    if chain1 > 0:\n                        result.append(1)\n                        chain1 -= 1\n                    else:\n                        result.append(2)\n                        chain2 -= 1\n                else:\n                    if chain2 > 0:\n                        result.append(2)\n                        chain2 -= 1\n                    else:\n                        result.append(1)\n                        chain1 -= 1\n        else:\n            result.append(0)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, input().split())\n    roads = [tuple(map(int, input().split())) for _ in range(E)]\n\n    # Check if there is only one or no roads connecting each city\n    if len(set(road[0] for road in roads)) < N or len(set(road[1] for road in roads)) < N:\n        return \"0\\n\"\n\n    # Create a dictionary to store the number of roads connecting each city\n    city_roads = {city: 0 for city in range(1, N + 1)}\n    for road in roads:\n        city_roads[road[0]] += 1\n        city_roads[road[1]] += 1\n\n    # Determine the chain that should build the restaurant for each road\n    solution = []\n    for road in roads:\n        if city_roads[road[0]] == 1 or city_roads[road[1]] == 1:\n            solution.append(\"1\\n\")\n        else:\n            solution.append(\"2\\n\")\n\n    return \"\".join(solution)\n"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, E = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, stdin.split()[2 * i:2 * i + 2])) for i in range(E)]\n\n    adjacency_list = [[] for _ in range(N + 1)]\n    for a, b in roads:\n        adjacency_list[a].append(b)\n        adjacency_list[b].append(a)\n\n    def dfs(v: int, parent: int, visited: set[int], chains: list[int]):\n        visited.add(v)\n        for u in adjacency_list[v]:\n            if u == parent:\n                continue\n            if u not in visited:\n                dfs(u, v, visited, chains)\n\n    first_chain = None\n    for i in range(1, N + 1):\n        visited = set()\n        chains = [0, 0]\n        dfs(i, -1, visited, chains)\n        if chains[0] == 0:\n            first_chain = 1\n        elif chains[1] == 0:\n            first_chain = 2\n\n    if first_chain is None:\n        return \"0\\n\"\n\n    output = \"\"\n    for a, b in roads:\n        if a != b:\n            if adjacency_list[a][0] == b:\n                output += str(first_chain) + \"\\n\"\n            else:\n                output += str(first_chain % 2 + 1) + \"\\n\"\n        else:\n            output += \"0\\n\"\n\n    return output"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, input().split())\n    arrival_times = sorted(map(int, stdin.split()[3:]))\n\n    def get_waiting_time(start_time, end_time, availability_start, availability_end):\n        if start_time < availability_start:\n            start_time = availability_start\n        if end_time > availability_end:\n            end_time = availability_end\n        return end_time - start_time\n\n    def get_total_waiting_time(arrival_times, gondola_availability):\n        total_waiting_time = 0\n        for i in range(len(arrival_times)):\n            for j in range(i, len(arrival_times)):\n                if arrival_times[j] - arrival_times[i] <= T:\n                    total_waiting_time += get_waiting_time(arrival_times[i], arrival_times[j], gondola_availability[i], gondola_availability[i+1])\n                else:\n                    break\n        return total_waiting_time\n\n    gondola_availability = [(i * T, (i+1) * T) for i in range(G)]\n    total_waiting_time = get_total_waiting_time(arrival_times, gondola_availability)\n\n    return str(total_waiting_time)"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_waiting_time(arrivals: list) -> int:\n        arrivals.sort()\n        gondolas = []\n        waiting_time = 0\n        for arrival in arrivals:\n            if len(gondolas) < gondolas_available:\n                gondolas.append(arrival)\n            else:\n                waiting_time += (arrival - gondolas.pop(0))\n                gondolas.append(arrival)\n        return waiting_time\n\n    def get_avg_waiting_time(arrivals: list) -> float:\n        arrivals.sort()\n        gondolas = []\n        total_waiting_time = 0\n        total_time = 0\n        for arrival in arrivals:\n            if len(gondolas) < gondolas_available:\n                gondolas.append(arrival)\n            else:\n                total_waiting_time += (arrival - gondolas.pop(0))\n                total_time += (arrival - gondolas.pop(0))\n                gondolas.append(arrival)\n        return total_waiting_time / total_time * 100\n\n    N, T, gondolas_available, *arrivals_str = stdin.split()\n    arrivals = [int(arrival) for arrival in arrivals_str]\n\n    waiting_time = get_min_waiting_time(arrivals)\n    avg_waiting_time = get_avg_waiting_time(arrivals)\n\n    return str(waiting_time) + \"\\n\" + \"{:.2f}%\".format(avg_waiting_time)\n"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split(\"\\n\")\n    N, T, G = map(int, inputs[0].split())\n    arrival_times = sorted(map(int, inputs[1:N+1]))\n    waiting_times = []\n\n    for i, time in enumerate(arrival_times):\n        if i < G - 1:\n            next_time = arrival_times[i+1]\n            waiting_times.append(next_time - time)\n        else:\n            break\n\n    return sum(waiting_times)\n"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    N, T, G = map(int, input_values[0].split())\n    arrival_times = sorted(map(int, input_values[1:]))\n\n    # Calculate the total time for the gondola to complete a loop\n    gondola_time = T * 2\n\n    # Initialize the waiting time and gondola count\n    waiting_time = 0\n    gondola_count = G\n\n    # Iterate through the arrival times\n    for arrival_time in arrival_times:\n        # Calculate the time to wait for the next gondola\n        time_to_wait = gondola_time - (arrival_time % gondola_time)\n\n        # Update the waiting time and gondola count\n        waiting_time += time_to_wait\n        gondola_count -= 1\n\n        # If there are no more gondolas available, wait until the next available gondola\n        if gondola_count == 0:\n            waiting_time += gondola_time\n            gondola_count = G\n\n    return waiting_time\n"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, stdin.split()[:3])\n    arrival_times = sorted(map(int, stdin.split()[3:]))\n    total_waiting_time = 0\n    current_time = 0\n    \n    for time in arrival_times:\n        while current_time < time:\n            current_time += T\n        \n        if G > 0:\n            total_waiting_time += time - current_time\n            G -= 1\n        else:\n            break\n        \n        current_time = time\n    \n    return str(total_waiting_time)\n\ninput_data = \"\"\"4 10 2\n0\n15\n30\n45\"\"\"\n\nprint(solution(input_data)) # Output: 10\n\ninput_data = \"\"\"4 10 3\n0\n15\n30\n45\"\"\"\n\nprint(solution(input_data)) # Output: 5\n\ninput_data = \"\"\"10 10 10\n0\n15\n30\n45\n55\n70\n80\n90\n100\n110\n120\n130\n140\n150\n160\n170\n180\n190\n200\n210\n220\n230\n240\n250\n260\n270\n280\n290\n300\n310\n320\n330\n340\n350\n360\n370\n380\n390\n400\n410\n420\n430\n440\n450\n460\n470\n480\n490\n500\n510\n520\n530\n540\n550\n560\n570\n580\n590\n600\n610\n620\n630\n640\n650\n660\n670\n680\n690\n700\n710\n720\n730\n740\n750\n760\n770\n780\n790\n800\n810\n820\n830\n840\n850\n860\n870\n880\n890\n900\n910\n920\n930\n940\n950\n960\n970\n980\n990\n1000\n1010\n1020\n1030\n1040\n1050\n1060\n1070\n1080\n1090\n1100\n1110\n1120\n1130\n1140\n1150\n1160\n1170\n1180\n1190\n1200\n1210\n1220\n1230\n1240\n1250\n1260\n1270\n1280\n1290\n1300\n1310\n1320\n1330\n1340\n1350\n1360\n1370\n1380\n1390\n1400\n1410\n1420\n1430\n1440\n1450\n1460\n1470\n1480\n1490\n1500\n1510\n1520\n1530\n1540\n1550\n1560\n1570\n1580\n1590\n1600\n1610\n1620\n1630\n1640\n1650\n1660\n1670\n1680\n1690\n1700\n1710\n1720\n1730\n1740\n1750\n1760\n1770\n178"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, stdin.split()[:3])\n    skiers = list(map(int, stdin.split()[3:]))\n    skiers.sort()\n    \n    i = 0\n    j = G - 1\n    total_time = 0\n    \n    while i < N and j < N:\n        time_diff = skiers[j] - skiers[i]\n        if time_diff < T:\n            j += 1\n        else:\n            total_time += time_diff\n            i += 1\n            j += 1\n    \n    return total_time // 2\n"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, stdin.split())\n    arrival_times = sorted(map(int, stdin.splitlines()[N:]))\n    gondolas = []\n\n    def find_next_available_gondola(time: int) -> int:\n        i = bisect_left(gondolas, time)\n        if i < len(gondolas):\n            return gondolas[i]\n        return time + T\n\n    def calculate_waiting_time(start_time: int, end_time: int) -> int:\n        return max(0, end_time - start_time)\n\n    min_waiting_time = float('inf')\n\n    for i in range(N):\n        start_time = arrival_times[i]\n        end_time = find_next_available_gondola(start_time)\n        waiting_time = calculate_waiting_time(start_time, end_time)\n        min_waiting_time = min(min_waiting_time, waiting_time)\n\n    return str(min_waiting_time)\n"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    n_skiers, t_time, n_cabs = input_values[0], input_values[1], input_values[2]\n    skiers_arrivals = input_values[3:]\n\n    skiers_arrivals.sort()\n\n    gondolas_times = [0] * n_cabs\n\n    skiers_waiting_time = 0\n\n    for skier_arrival in skiers_arrivals:\n        available_cab = min(range(n_cabs), key=lambda i: abs(gondolas_times[i] - skier_arrival))\n        skiers_waiting_time += abs(gondolas_times[available_cab] - skier_arrival)\n        gondolas_times[available_cab] += t_time * 2\n\n    return skiers_waiting_time\n\n\ndef"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, input().split())\n    skiers = sorted(map(int, stdin.splitlines()[1:]))\n\n    gondola_times = [0] * G\n    gondola_times[0] = skiers[0]\n    max_gondola_time = 0\n\n    for i in range(1, N):\n        while gondola_times[max_gondola_time] <= skiers[i]:\n            max_gondola_time += 1\n            if max_gondola_time == G:\n                max_gondola_time -= 1\n                break\n        gondola_times[max_gondola_time] = skiers[i]\n\n    waiting_times = [gondola_times[(i + 1) % G] - skiers[i] for i in range(N)]\n    return sum(waiting_times)\n"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, T, G = map(int, input_list.pop(0).split())\n    arrival_times = sorted(map(int, input_list))\n\n    waiting_times = []\n    current_time = 0\n\n    while arrival_times:\n        next_arrival = arrival_times[0]\n        if next_arrival - current_time <= T:\n            current_time = next_arrival + T\n            arrival_times.pop(0)\n        else:\n            waiting_times.append(next_arrival - current_time)\n            current_time = next_arrival + T\n\n    while len(waiting_times) < N:\n        waiting_times.append(T)\n\n    return str(min(waiting_times))\n"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    contestants = []\n    \n    for _ in range(m):\n        scores = list(map(int, stdin.split()[2:]))\n        contestants.append(scores)\n    \n    # Sort contestants based on their scores in the last contest\n    contestants.sort(key=lambda x: (-sum(x[n-2:]), -sum(x[:n-2])))\n    \n    # Calculate the worst possible rank for each contestant\n    worst_ranks = []\n    for i in range(len(contestants)):\n        score_sum = sum(contestants[i][:n-2])\n        worst_points = 0\n        \n        if score_sum > 3000:\n            worst_points = 100\n        elif score_sum > 2000:\n            worst_points = 90\n        elif score_sum > 1000:\n            worst_points = 80\n        elif score_sum > 500:\n            worst_points = 70\n        elif score_sum > 200:\n            worst_points = 60\n        elif score_sum > 100:\n            worst_points = 50\n        elif score_sum > 50:\n            worst_points = 40\n        else:\n            worst_points = 30\n        \n        # Calculate the final rank for the contestant\n        contest_ranks = []\n        for j in range(n):\n            contest_ranks.append(sum(sorted(contestants[i][:j], reverse=True)[:n-2]))\n        \n        contest_ranks.sort()\n        final_rank = 1\n        for j in range(len(contest_ranks)):\n            if contest_ranks[j] == sum(contest_ranks[:j+1]):\n                final_rank = j+1\n        \n        # Calculate the worst possible rank for the contestant\n        worst_rank = final_rank + sum(contest_ranks[:n-1]) // n\n        \n        if worst_rank > 30:\n            worst_rank = 30\n        \n        worst_ranks.append(worst_rank)\n    \n    # Calculate the final worst rank\n    return max(worst_ranks)\n\ndef"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    scores = [list(map(int, line.split())) for line in input_data[1:m+1]]\n\n    # Calculate the rank of each contestant for each contest\n    contest_ranks = []\n    for contest in scores:\n        contest_ranks.append(sorted(set(contest), reverse=True))\n\n    # Calculate the average points for each tied rank\n    avg_scores = {}\n    for rank in range(30, 0, -1):\n        avg_scores[rank] = sum(contest_ranks[-1][-rank:]) / rank\n\n    # Calculate the aggregate score and rank for each contestant\n    aggregate_scores = []\n    for contestant_scores in scores:\n        contestant_rank = 0\n        for i, score in enumerate(contestant_scores):\n            contest_rank = len(contest_ranks[i]) - contest_ranks[i].index(score) - 1\n            contestant_rank += contest_rank\n        aggregate_scores.append(contestant_rank)\n\n    # Calculate the worst possible rank\n    worst_rank = 0\n    for rank in avg_scores:\n        if max(aggregate_scores) <= rank:\n            worst_rank = rank\n            break\n\n    return str(worst_rank)"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    scores = [[] for _ in range(m)]\n\n    for i in range(m):\n        scores[i] = list(map(int, stdin.split()[2 + i * (n - 1):2 + (i + 1) * (n - 1)]))\n\n    max_points = 101\n    ranks = [0] * n\n\n    for i in range(n):\n        total_score = 0\n        total_count = 0\n        for j in range(m):\n            total_score += scores[j][i]\n            total_count += 1\n\n        total_score = min(total_score, max_points)\n        ranks[i] = (total_score + max_points - 1) // max_points\n\n    rank_count = [0] * (n + 1)\n    for i in range(n):\n        rank_count[ranks[i]] += 1\n\n    for i in range(n, 0, -1):\n        if rank_count[i] == 0:\n            break\n        for j in range(1, n - i + 1):\n            rank_count[i] += rank_count[j]\n            rank_count[j] = 0\n\n    worst_rank = rank_count.index(m)\n    return worst_rank\n\ninput_file = \"input.txt\"\nwith open(input_file, \"r\") as file:\n    stdin = file.read()\n    output = solution(stdin)\n\nprint(output) "
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    scores = []\n    for i in range(m):\n        s = list(map(int, input().split()))[:n-1]\n        scores.append(s)\n\n    max_score = 0\n    for s in scores:\n        rank = 1\n        score = 0\n        for i in range(n-1):\n            if s[i] > max_score:\n                max_score = s[i]\n                rank += 1\n            if s[i] == max_score:\n                rank += 1\n        score += max_score\n        if max_score >= 100:\n            score += 1\n        score += 2 if s[-1] == 1 else 0\n\n        if score < 30:\n            score = 0\n        else:\n            score -= 30\n            if score > 0:\n                score = max(1, score)\n            else:\n                score = 0\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n        if score > 10:\n            score = 10\n\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n        score -= 2\n        score = max(1, score)\n        score *= 10\n        score += 1\n        score = max(1, score)\n        score *= 2\n\n        score //= 10\n        score += 1\n       "
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    stds = [list(map(int, stdin.split()[2:]))]\n    stds += [list(map(int, input().split())) for _ in range(m-1)]\n    scores = [stds[0][i] for i in range(n-1)]\n    max_score = max(scores)\n    scores.remove(max_score)\n    if max_score > 30:\n        scores.append(max_score - 30)\n    scores.sort(reverse=True)\n    avg_points = int(sum([i for i in range(1, 31)]))\n    for i in range(len(scores)):\n        if i < len(scores) - 1 and scores[i] == scores[i+1]:\n            avg_points += scores[i]\n        else:\n            avg_points += scores[i]\n        avg_points = (avg_points + (len(scores) - i - 1) // 2) // (len(scores) - i - 1)\n        if avg_points > 30:\n            break\n    return avg_points + 1\n\n\ndef"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    n -= 1  # Adjust for final contest\n    stdin = stdin.split('\\n')[1:]\n\n    # Calculate scores for all contestants\n    scores = [[0] * n for _ in range(m)]\n    for i in range(m):\n        s = list(map(int, stdin[i].split()))\n        for j in range(n):\n            if s[j] == 30:\n                scores[i][j] = 1\n            elif s[j] < 30:\n                scores[i][j] = s[j] + 1\n            else:\n                scores[i][j] = 1\n\n    # Calculate rank of each contestant\n    ranks = [sorted(scores, reverse=True)]\n    for i in range(n-1):\n        ranks.append([[0] * n for _ in range(m)])\n        for j in range(m):\n            for k in range(n):\n                if scores[j][k] == 0:\n                    ranks[i+1][j][k] = 30\n                else:\n                    ranks[i+1][j][k] = 1 + ranks[i][j].index(scores[j][k])\n\n    # Calculate worst possible rank\n    worst_rank = 0\n    for j in range(m):\n        for k in range(n):\n            if scores[j][k] != 0:\n                worst_rank = max(worst_rank, ranks[-1][j][k])\n\n    return worst_rank"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    contest_scores = [[int(x) for x in input_list[i+1].split()] for i in range(m)]\n\n    max_score = 0\n    for i in range(n-1):\n        max_score = max(max_score, sum(scores[i] for scores in contest_scores))\n\n    max_points = sum(1 for scores in contest_scores if sum(scores) == max_score)\n    avg_points = max_points * max_score // 101\n    worst_rank = 30 + avg_points\n\n    return str(worst_rank)"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    scores = []\n    for _ in range(m):\n        line = list(map(int, stdin.split()[1:n-1]))\n        line.sort(reverse=True)\n        score = 0\n        for i in range(4):\n            if line[i] > 30:\n                score += 100\n            else:\n                score += line[i]\n        if 4711 - 3*line[4] > 0:\n            score += 4711 - 3*line[4]\n        if line[4] > 0:\n            score += 1\n        scores.append(score)\n    scores.sort(reverse=True)\n    return scores.index(scores[0]) + 1"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    data = stdin.split('\\n')[1:]\n    std_data = data[:m]\n    std_scores = [list(map(int, std.split())) for std in std_data]\n    std_scores_avg = [sum(std)//len(std) for std in std_scores]\n\n    std_points = []\n    for std in std_scores:\n        points = [0] * 30\n        for i in range(1, 31):\n            count = std.count(i)\n            if count > 0:\n                points[i-1] = count * std_scores_avg[std_scores.index(std)]\n        std_points.append(sum(points))\n\n    final_scores = data[m:]\n    final_points = []\n    for score in final_scores:\n        final_points.append(sum(map(int, score.split())))\n\n    worst_rank = 31\n    for rank, points in enumerate(sorted(std_points, reverse=True)):\n        if points == 0:\n            continue\n        if points > 100:\n            points = 100\n        if points > 0:\n            worst_rank = min(worst_rank, rank+1)\n\n    return worst_rank"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    stdin_scores = stdin.split('\\n')[1:]\n    scores = []\n    for score_line in stdin_scores:\n        scores.append([int(score) for score in score_line.split()])\n    final_score = [sum(score[:n-1]) for score in scores]\n    final_score.sort()\n    final_rank = [1] * n\n    for i in range(1, n):\n        final_rank[i] = (final_rank[i-1] + final_rank[i-1]) / 2\n    for score in final_score:\n        for i in range(n):\n            if score <= 30:\n                break\n            if scores[i][n-1] <= score:\n                final_rank[i] += 1\n    return max(final_rank)"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, input_data = list(map(int, stdin.split()))\n    layout = [input_data[i * C:(i + 1) * C] for i in range(R)]\n\n    def distance(a: Tuple[int, int], b: Tuple[int, int]) -> float:\n        return math.sqrt((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2)\n\n    def find_closest(pos: Tuple[int, int], target: str) -> Tuple[int, int]:\n        closest_dist = float('inf')\n        closest_pos = (-1, -1)\n        for r in range(R):\n            for c in range(C):\n                if layout[r][c] == target and distance(pos, (r, c)) < closest_dist:\n                    closest_dist = distance(pos, (r, c))\n                    closest_pos = (r, c)\n        return closest_pos\n\n    def count_explosions(layout: List[List[str]]) -> int:\n        explosions = 0\n        for r in range(R):\n            for c in range(C):\n                if layout[r][c] == 'X':\n                    closest_pos = find_closest((r, c), 'L')\n                    if closest_pos != (-1, -1):\n                        layout[closest_pos[0]][closest_pos[1]] = '.'\n                        explosions += 1\n        return explosions\n\n    return str(count_explosions(layout))\n"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split(','))\n    layout = stdin.split()[1].split('\\n')\n    idiots = []\n    seats = []\n\n    for i in range(R):\n        for j in range(C):\n            if layout[i][j] == 'X':\n                idiots.append((i, j))\n            elif layout[i][j] == 'L':\n                seats.append((i, j))\n\n    def distance(a: tuple, b: tuple) -> int:\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def is_seat_free(seats: list, i: int, j: int) -> bool:\n        for seat in seats:\n            if distance((i, j), seat) == 1:\n                return False\n        return True\n\n    def count_explosions(idiots: list, seats: list) -> int:\n        explosions = 0\n        for i, j in idiots:\n            for seat in seats:\n                if distance((i, j), seat) == 1:\n                    seats.remove(seat)\n                    explosions += 1\n                    break\n        return explosions\n\n    explosions = count_explosions(idiots, seats)\n    while len(idiots) != 0 and is_seat_free(seats, idiots[0][0], idiots[0][1]):\n        explosions += 1\n        seats.append((idiots[0][0], idiots[0][1]))\n        idiots.pop(0)\n        explosions += count_explosions(idiots, seats)\n\n    return str(explosions)\n\ninput_file = open(\"input.txt\", \"r\")\nstdin = input_file.read()\noutput = solution(stdin)\nprint(output) "
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    R, C = map(int, input().split())\n    layout = []\n    for i in range(R):\n        layout.append(input())\n\n    # Calculate the distance between each X and L\n    distance = [[0 for _ in range(C)] for _ in range(R)]\n    for i in range(R):\n        for j in range(C):\n            if layout[i][j] == 'L':\n                for k in range(R):\n                    for l in range(C):\n                        if layout[k][l] == 'X':\n                            distance[i][j] += (i - k) ** 2 + (j - l) ** 2\n\n    # Count the number of explosions\n    explosions = 0\n    for i in range(R):\n        for j in range(C):\n            if layout[i][j] == 'X':\n                if distance[i][j] > 0:\n                    explosions += 1\n                    break\n\n    # Return the result\n    return str(explosions)\n"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def get_safest_seat(tram, x, y, seats):\n        safest_seat = None\n        safest_distance = float('inf')\n\n        for seat in seats:\n            distance = euclidean_distance(x, y, seat[0], seat[1])\n            if distance < safest_distance:\n                safest_seat = seat\n                safest_distance = distance\n\n        return safest_seat\n\n    R, C = map(int, stdin.split()[:2])\n    tram = [list(stdin.split()[2 + i]) for i in range(R)]\n\n    x_positions = [i for i in range(C) for row in tram if 'X' in row]\n    y_positions = [row.index('X') for row in tram if 'X' in row]\n\n    explosions = 0\n    seats = [(x, y) for x in range(C) for y in range(R) if tram[y][x] == 'L']\n\n    for x, y in zip(x_positions, y_positions):\n        safest_seat = get_safest_seat(tram, x, y, seats)\n        if safest_seat:\n            tram[safest_seat[1]][safest_seat[0]] = 'X'\n            explosions += 1\n            seats.remove(safest_seat)\n\n    return str(explosions)\n\ninput_data = [\n    \"4 4\",\n    \".LX.\",\n    \".X..\",\n    \"....\",\n    \".L..\",\n    \"4 4\",\n    \".XLX\",\n    \".X..\",\n    \"...L\",\n    \".X..\"\n]\n\nfor data in input_data:\n    print(solution(data))"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    R, C = map(int, stdin.split()[:2])\n    layout = stdin.split('\\n')[1:]\n\n    # Initialize variables\n    explosions = 0\n    seat_count = 0\n    x_positions = []\n    l_positions = []\n\n    # Iterate through the layout and calculate distances\n    for r in range(R):\n        for c in range(C):\n            if layout[r][c] == 'X':\n                x_positions.append((r, c))\n            elif layout[r][c] == 'L':\n                l_positions.append((r, c))\n\n    # Find the closest seat to each X\n    for x in x_positions:\n        distances = [(abs(x[0] - l[0]) + abs(x[1] - l[1]), l) for l in l_positions]\n        distances.sort()\n        if distances[0][0] == 0:\n            seat_count += 1\n        else:\n            explosions += 1\n            l_positions.remove(distances[0][1])\n\n    # If there are still Xs left, calculate the number of explosions\n    if x_positions:\n        explosions += len(x_positions)\n\n    # Return the number of explosions\n    return str(explosions)"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def euclidean_distance(cell1, cell2):\n        return ((cell1[0] - cell2[0]) ** 2 + (cell1[1] - cell2[1]) ** 2) ** 0.5\n\n    def find_closest_cell(cell, cells):\n        closest_cell = None\n        min_distance = float('inf')\n        for c in cells:\n            distance = euclidean_distance(cell, c)\n            if distance < min_distance:\n                min_distance = distance\n                closest_cell = c\n        return closest_cell\n\n    R, C = map(int, stdin.split()[:2])\n    layout = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    explosions = 0\n    x_cells = [(r, c) for r in range(R) for c in range(C) if layout[r][c] == 'X']\n    l_cells = [(r, c) for r in range(R) for c in range(C) if layout[r][c] == 'L']\n\n    while x_cells and l_cells:\n        closest_x_cell = find_closest_cell(x_cells[0], l_cells)\n        explosions += 1\n        x_cells.remove(x_cells[0])\n        l_cells.remove(closest_x_cell)\n\n    return str(explosions)\n"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    R, C = map(int, stdin.split()[0:2])\n    layout = stdin.split()[2:]\n    x_positions = [(i, j) for i in range(R) for j in range(C) if layout[i][j] == 'X']\n    l_positions = [(i, j) for i in range(R) for j in range(C) if layout[i][j] == 'L']\n\n    min_distance = float('inf')\n    explosions = 0\n\n    for x in x_positions:\n        for l in l_positions:\n            if distance(x, l) < min_distance:\n                min_distance = distance(x, l)\n\n    if min_distance > 0:\n        explosions += 1\n\n    for x in x_positions:\n        for i in range(R):\n            for j in range(C):\n                if layout[i][j] == 'X':\n                    continue\n                if distance(x, (i, j)) == min_distance:\n                    explosions += 1\n\n    return str(explosions)"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0])**2 + (a[1] - b[1])**2)**0.5\n\n    R, C, layout = 0, 0, \"\"\n    for i in range(4):\n        if i == 0:\n            R, C = map(int, stdin.split()[i].split())\n        else:\n            layout += stdin.split()[i] + \"\\n\"\n\n    X_positions = []\n    for i, row in enumerate(layout.splitlines()):\n        for j, cell in enumerate(row):\n            if cell == 'X':\n                X_positions.append((i, j))\n\n    explosion_count = 0\n    for i in range(len(X_positions)):\n        min_distance = float('inf')\n        min_j = -1\n        for j in range(len(X_positions)):\n            if i != j:\n                distance_ij = distance(X_positions[i], X_positions[j])\n                if distance_ij < min_distance:\n                    min_distance = distance_ij\n                    min_j = j\n        explosion_count += 1\n        X_positions.pop(min_j)\n\n    return str(explosion_count)"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a: tuple, b: tuple) -> int:\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def nearest_seats(layout: list, x: int, y: int) -> list:\n        seats = []\n        for i in range(R):\n            for j in range(C):\n                if layout[i][j] == 'L' and distance((x, y), (i, j)) == min_distance:\n                    seats.append((i, j))\n        return seats\n\n    def explosions(layout: list, x: int, y: int) -> int:\n        min_distance = float('inf')\n        seats = []\n        for i in range(R):\n            for j in range(C):\n                if layout[i][j] == 'X':\n                    distance_to_x = distance((x, y), (i, j))\n                    if distance_to_x < min_distance:\n                        min_distance = distance_to_x\n                        seats = nearest_seats(layout, i, j)\n        if min_distance == float('inf'):\n            return 0\n        explosion = 0\n        for seat in seats:\n            layout[seat[0]][seat[1]] = '.'\n            explosion += 1\n        return explosion + explosions(layout, x, y)\n\n    R, C = map(int, stdin.split()[:2])\n    layout = [list(stdin[i * C:(i + 1) * C]) for i in range(R)]\n    x, y = None, None\n    for i in range(R):\n        for j in range(C):\n            if layout[i][j] == 'X':\n                x, y = i, j\n                break\n    return explosions(layout, x, y)\n"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    layout = [line.strip() for line in stdin.split('\\n')[1:]]\n\n    explosions = 0\n    seats_taken = 0\n    seats_available = 0\n\n    for row in range(R):\n        for col in range(C):\n            if layout[row][col] == 'X':\n                explosions += 1\n            elif layout[row][col] == 'L':\n                seats_available += 1\n\n    if explosions >= seats_available:\n        return str(seats_available)\n\n    while seats_taken < seats_available:\n        explosions = 0\n        for row in range(R):\n            for col in range(C):\n                if layout[row][col] == 'X':\n                    nearest_seat_row, nearest_seat_col = -1, -1\n                    nearest_distance = float('inf')\n                    for i in range(R):\n                        for j in range(C):\n                            if layout[i][j] == 'L':\n                                distance = ((row - i) ** 2 + (col - j) ** 2) ** 0.5\n                                if distance < nearest_distance:\n                                    nearest_distance = distance\n                                    nearest_seat_row, nearest_seat_col = i, j\n                    explosions += 1\n                    layout[nearest_seat_row][nearest_seat_col] = 'X'\n                elif layout[row][col] == 'L':\n                    seats_taken += 1\n\n        if explosions >= seats_available:\n            return str(seats_available)\n\n    return str(explosions)\n"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, p, q = map(int, input_list[0].split())\n    m_i = [int(x) for x in input_list[1].split()]\n    friend_list = [[int(x) for x in input_list[i+2].split()] for i in range(n)]\n\n    # Check if all students are telling the truth\n    if all(sum(map(lambda x: x == i, friend_list[i])) == m_i[i] for i in range(n)):\n        return \"home\"\n\n    # Check if someone did not tell the truth\n    for i in range(n):\n        friends_list = [j for j in range(n) if j != i and j in friend_list[i]]\n        if len(friends_list) > m_i[i]:\n            return \"detention\"\n\n    # Prove that there is a valid partition\n    def find_groups(remaining_students: List[int], max_group_size: int, max_friends_outside: int) -> List[int]:\n        if not remaining_students:\n            return []\n        if len(remaining_students) <= max_group_size:\n            return [remaining_students]\n\n        groups = []\n        for i in range(1, max_group_size+1):\n            for subset in find_groups(remaining_students[i:], max_group_size, max_friends_outside):\n                groups.append([remaining_students[:i]] + subset)\n                if len(groups[-1]) > 1 and sum(map(len, groups[-1])) <= max_friends_outside:\n                    break\n        return groups\n\n    def is_valid_partition(groups: List[List[int]], max_group_size: int, max_friends_outside: int) -> bool:\n        for group in groups:\n            if len(group) > max_group_size:\n                return False\n            if len(group) > 1 and sum(map(len, group)) > max_friends_outside:\n                return False\n        return True\n\n    valid_partitions = find_groups(list(range(n)), p, q)\n    for partition in valid_partitions:\n        if is_valid_partition(partition, p, q):\n            return \"home\"\n\n    # There is no valid partition\n    return \"detention\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Parse input\n    lines = stdin.splitlines()\n    n, p, q = map(int, lines[0].split())\n    student_data = [line.split() for line in lines[1:]]\n\n    # Helper function to check if a set of pairs is valid\n    def is_valid(groups: list[set[int]]) -> bool:\n        for group in groups:\n            # Check if group size is within bounds\n            if len(group) < p or len(group) > q:\n                return False\n\n            # Check if each pair of friends are in different groups\n            for i in range(len(group)):\n                for j in range(i + 1, len(group)):\n                    for other_group in groups:\n                        if (group[i] in other_group and group[j] not in other_group) or (group[j] in other_group and group[i] not in other_group):\n                            return False\n        return True\n\n    # Check if each student has a valid number of friends\n    num_friends = [int(line[0]) for line in student_data]\n    if sum(num_friends) > 30000:\n        return \"detention\"\n\n    # Create list of friend pairs for each student\n    friend_pairs = [[int(friend) for friend in line[1:]] for line in student_data]\n\n    # Check if all student friend pairs are valid\n    for pairs in friend_pairs:\n        for friend in pairs:\n            if friend < 0 or friend >= n:\n                return \"detention\"\n\n    # Use backtracking to find all possible partitions\n    def backtrack(groups: list[set[int]], friends: set[int], student: int) -> None:\n        if student == n:\n            if is_valid(groups):\n                return groups\n            return None\n\n        for group_index, group in enumerate(groups):\n            if len(group) < p:\n                if student in group:\n                    continue\n\n                new_group = group.copy()\n                new_group.add(student)\n                new_groups = groups.copy()\n                new_groups[group_index] = new_group\n\n                result = backtrack(new_groups, friends, student + 1)\n                if result is not None:\n                    return result\n\n        new_groups = groups.copy()\n        new_groups.append({student})\n        return backtrack(new_groups, friends.union({student}), student + 1)\n\n    groups = backtrack([set() for _ in range(p)], set(), 0)\n\n    if groups is None:\n        return \"detention\"\n\n    return \"home\\n\" + str(len(groups)) + \"\\n\" + \"\\n\".join(\n        str(len(group)) + \" \" + \" \".join(map(str, sorted(group))) for group in groups\n    )"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[:3])\n    students = [list(map(int, stdin.split()[3+i*2:3+i*2+2])) for i in range(n)]\n\n    def check_partition(partition):\n        for i, group in enumerate(partition):\n            if len(group) < p:\n                return False\n            for j in range(i):\n                if len(set(group) & set(partition[j])) > q:\n                    return False\n        return True\n\n    def check_friendship(partition):\n        for group in partition:\n            for i, student in enumerate(group):\n                for friend in students[student][1:]:\n                    if friend in group:\n                        return False\n        return True\n\n    for i in range(2**n):\n        partition = [[] for _ in range(n)]\n        for j in range(n):\n            if i & (1 << j):\n                partition[j].append(j)\n        if check_partition(partition) and check_friendship(partition):\n            return \"home\"\n\n    return \"detention\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[:3])\n    assert 1 <= n <= 2500\n    assert p + q <= 15\n\n    student_friends = []\n    for i in range(n):\n        m_i, *friends = map(int, stdin.split()[3 + i * (m_i + 1) : 3 + (i + 1) * (m_i + 1)])\n        assert 0 <= m_i <= 30000\n        assert all(0 <= friend < n for friend in friends)\n        student_friends.append(set(friends))\n\n    # Check if there is at most one direct friend for each student\n    for i in range(n):\n        for j in range(n):\n            if i != j and i in student_friends[j] and j in student_friends[i]:\n                return \"detention\"\n\n    # Check if the set of students can be partitioned into groups with the given constraints\n    total_students = set(range(n))\n    remaining_students = set(range(n))\n    groups = []\n\n    while remaining_students:\n        # Find the student with the smallest number of friends\n        min_student, min_friends = min(zip(remaining_students, (len(student_friends[i] & remaining_students) for i in remaining_students)), key=lambda x: x[1])\n\n        # Find the group with the least number of violations\n        group_index = min(enumerate(groups), key=lambda x: x[1] + (len(student_friends[min_student] - {min_student}) - x[0] * p) * q)\n        group_index, violations = group_index\n\n        # Add the student to the group with the least number of violations\n        groups[group_index].add(min_student)\n        remaining_students.remove(min_student)\n\n    # Check if the partition satisfies the constraints\n    for group in groups:\n        group_friends = set.union(*(student_friends[i] for i in group))\n        for friend in group_friends:\n            if friend not in group:\n                return \"detention\"\n\n    # Output the partition\n    G = len(groups)\n    for group in groups:\n        print(G, end=\" \")\n        print(*sorted(group))\n\n    return \"home\"\n"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[:3])\n    students = []\n    for _ in range(n):\n        m, *friends = map(int, stdin.split()[1:])\n        students.append(list(friends))\n\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            assert i not in students[j]\n\n    def is_partition_valid(groups: List[Set[int]]) -> bool:\n        for group in groups:\n            if len(group) < 1 or len(group) > p:\n                return False\n        if len(groups) > n // p:\n            return False\n\n        for group in groups:\n            if len(group) > q:\n                return False\n\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if i in students[j]:\n                    return False\n                if j in students[i]:\n                    return False\n\n        return True\n\n    groups = []\n    for i in range(n):\n        group = set(range(n))\n        group.remove(i)\n        group.difference_update(students[i])\n        groups.append(group)\n\n    if not is_partition_valid(groups):\n        return \"detention\"\n    else:\n        return \"home\"\n\ndef"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[:3])\n    students = []\n    for _ in range(n):\n        line = stdin.split()\n        m = int(line[0])\n        friends = [int(x) for x in line[1:]]\n        students.append(set(friends))\n\n    # Check if the friendships satisfy the required properties\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                continue\n            if (i in students[j]) or (j in students[i]):\n                return \"detention\"\n\n    # Try to prove that the friendships are valid\n    def is_valid(students: list) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                if (i in students[j]) and (j not in students[i]):\n                    return False\n        return True\n\n    def find_partition(students: list) -> list:\n        def helper(students: list, i: int, groups: list) -> bool:\n            if i == n:\n                return True\n            for g in range(len(groups)):\n                if is_valid(groups[:g] + [students[i] | groups[g]] + groups[g+1:]):\n                    if helper(students, i+1, groups[:g] + [students[i] | groups[g]] + groups[g+1:]):\n                        return True\n            return False\n\n        for num_groups in range(1, n+1):\n            for groups in itertools.combinations(range(num_groups), p):\n                if is_valid([students[i] for i in range(n) if i not in groups]):\n                    if helper(students, 0, [set() for _ in range(num_groups)]):\n                        return [num_groups] + [groups]\n        return []\n\n    partition = find_partition(students)\n    if not partition:\n        return \"detention\"\n    else:\n        return \"home\\n\" + str(partition[0]) + \"\\n\" + \"\\n\".join(f\"{len(group)} {' '.join(map(str, sorted(group)))}\" for group in partition[1:])"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[0:3])\n    data = stdin.split('\\n')[1:]\n    students = []\n\n    for i in range(n):\n        m, *friends = map(int, data[i].split())\n        students.append({'num_friends': m, 'friends': set(friends)})\n\n    def validate_groups(groups):\n        for i, group in enumerate(groups):\n            for j in range(i + 1, len(groups)):\n                for friend in group:\n                    if friend in groups[j]:\n                        return False\n        return True\n\n    def is_partition_valid(groups):\n        for group in groups:\n            if len(group) < p or len(group) > q:\n                return False\n        for group in groups:\n            if group & students[0]['friends'] or group & students[1]['friends'] or group & students[2]['friends']:\n                return False\n        return validate_groups(groups)\n\n    def find_groups():\n        groups = [set() for _ in range(p)]\n        for i in range(n):\n            for group in groups:\n                if len(group) < p:\n                    group.add(i)\n                    break\n        return groups\n\n    if not is_partition_valid(find_groups()):\n        return 'detention'\n    else:\n        return 'home'\n"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, p, q = map(int, input_data[0].split())\n    students = []\n    for i in range(1, len(input_data)):\n        student_info = input_data[i].split()\n        m = int(student_info[0])\n        friends = list(map(int, student_info[1:]))\n        students.append((m, friends))\n\n    # Check if all students are telling the truth\n    for i in range(n):\n        for j in range(i + 1, n):\n            if students[i][1].count(j) != students[j][1].count(i):\n                return \"detention\"\n\n    # Check if a valid partition can be found\n    def can_be_friends(group_a, group_b):\n        count = 0\n        for a in group_a:\n            for b in group_b:\n                if a in students[b][1]:\n                    count += 1\n        return count <= q\n\n    def can_be_in_same_group(group_a, group_b):\n        for a in group_a:\n            for b in group_b:\n                if a in students[b][1]:\n                    return False\n        return True\n\n    def check_partition(partition):\n        for i in range(len(partition)):\n            for j in range(i + 1, len(partition)):\n                if not can_be_friends(partition[i], partition[j]):\n                    return False\n            for group in partition[:i]:\n                if not can_be_in_same_group(partition[i], group):\n                    return False\n        return True\n\n    def find_partition():\n        def backtrack(group_index, group_size, partition, used_students):\n            if group_index == n and check_partition(partition):\n                return True\n            if group_size == p + 1:\n                return False\n\n            for i in range(n):\n                if i not in used_students:\n                    new_used_students = used_students + [i]\n                    if can_be_in_same_group(partition[group_index], [i]):\n                        if backtrack(group_index + 1, group_size, partition, new_used_students):\n                            return True\n            return False\n\n        for group_size in range(1, p + 1):\n            for i in range(n):\n                if backtrack(0, group_size, [[i]], [i]) and check_partition(partition):\n                    return partition\n        return None\n\n    partition = find_partition()\n    if partition is not None:\n        G = len(partition)\n        print(\"home\")\n        print(G)\n        for i in range(G):\n            group_size = len(partition[i])\n            print(group_size, end=' ')\n            for j in partition[i]:\n                print(j, end=' ')\n            print()\n    else:\n        return \"detention\""
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, p, q = map(int, input_data[0].split())\n    student_data = input_data[1:]\n\n    # Check if any student is lying\n    for student in student_data:\n        friends, claimed_friends = student.split()\n        friends = set(map(int, friends.split()))\n        claimed_friends = set(map(int, claimed_friends.split()))\n\n        if not claimed_friends.issubset(friends):\n            return \"detention\"\n\n    # Prove that the partition is valid\n    groups = []\n    student_set = set(range(n))\n\n    def find_group(student: int) -> int:\n        for i, group in enumerate(groups):\n            if student in group:\n                return i\n        return -1\n\n    for i in range(n):\n        friends = set(map(int, student_data[i].split()[0].split()))\n        claimed_friends = set(map(int, student_data[i].split()[1].split()))\n\n        if i in claimed_friends:\n            claimed_friends.remove(i)\n\n        claimed_friends = claimed_friends.intersection(student_set)\n\n        if not claimed_friends:\n            group = {i}\n            groups.append(group)\n            student_set.remove(i)\n        else:\n            group_index = find_group(friends.pop())\n            if group_index != -1:\n                group = groups[group_index]\n                for friend in claimed_friends:\n                    if friend not in group:\n                        group.add(friend)\n            else:\n                group = claimed_friends\n                groups.append(group)\n                student_set = student_set.difference(claimed_friends)\n\n    if len(student_set) != 0:\n        raise ValueError(\"Invalid partition\")\n\n    return \"home\", len(groups), [len(group) for group in groups], [group for group in groups]\n"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, p, q = map(int, input_list[0].split())\n    students = [[] for _ in range(n)]\n    for i in range(1, n+1):\n        m, *friends = map(int, input_list[i].split())\n        students[i-1] = list(friends)\n\n    def is_partition_valid(groups):\n        for group in groups:\n            for friend in group:\n                if friend in groups[group]:\n                    return False\n        return True\n\n    def count_friends_outside_group(group, groups):\n        count = 0\n        for i in range(n):\n            if i not in group and any(i in group2 for group2 in groups.values()):\n                count += 1\n        return count\n\n    def find_groups():\n        groups = {}\n        for i in range(n):\n            groups[i] = set()\n        for i in range(n):\n            for j in range(n):\n                if j in students[i]:\n                    if j in groups[i]:\n                        return None\n                    groups[i].add(j)\n        if not is_partition_valid(groups):\n            return None\n        return groups\n\n    valid_groups = find_groups()\n    if valid_groups:\n        groups = valid_groups\n    else:\n        groups = None\n\n    if groups:\n        output = \"home\"\n        print(output)\n        num_groups = len(groups)\n        print(num_groups)\n        for group in groups.values():\n            print(len(group))\n            print(*sorted(group))\n    else:\n        output = \"detention\"\n        print(output)\n\n    return output\n"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 == 1:\n        return -1\n    substrings = [stdin[i:i + N // 2] for i in range(0, N, N // 2)]\n    substrings.sort()\n    if len(set(substrings)) == len(substrings):\n        return stdin\n    else:\n        return -1\n\ndef"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 != 0:\n        return \"-1\"\n\n    substrings = []\n    for i in range(0, N, N // 2):\n        substrings.append(stdin[i:i + N // 2])\n\n    if len(set(substrings)) == len(substrings):\n        return stdin\n    else:\n        return \"-1\""
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    \n    if N % 2 == 1:\n        return -1\n    \n    # Check if all substrings of length N/2 are unique\n    unique = set()\n    for i in range(N // 2):\n        for j in range(i + 1, N // 2 + 1):\n            if stdin[i:j] in unique:\n                return -1\n            unique.add(stdin[i:j])\n    \n    # If all substrings are unique, find a rearrangement\n    new_stdin = [char for char in stdin]\n    for i in range(N // 2):\n        new_stdin[i], new_stdin[N // 2 + i] = new_stdin[N // 2 + i], new_stdin[i]\n    return ''.join(new_stdin)\n\ninput_string = input()\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 != 0:\n        return -1\n    substrings = [stdin[i:i+N//2] for i in range(0, N, N//2)]\n    substrings_set = set(substrings)\n    if len(substrings_set) == len(substrings):\n        return stdin\n    else:\n        return -1\n\ndef"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 == 1:\n        return -1\n\n    chars = list(stdin)\n    substrings = [chars[i:i+N//2] for i in range(N//2)]\n\n    if len(set(substrings)) == 1:\n        return -1\n\n    sorted_substrings = sorted(list(set(substrings)))\n    sorted_chars = [char for substring in sorted_substrings for char in substring]\n\n    if len(sorted_chars) != N:\n        return -1\n\n    return ''.join(sorted_chars)"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    # Read input string\n    s = stdin.strip()\n\n    # Check if the string is of even length\n    if len(s) % 2 != 0:\n        return -1\n\n    # Create a list of all substrings of length N/2\n    substrings = []\n    for i in range(len(s) // 2):\n        substrings.append(s[i * 2:(i + 1) * 2])\n\n    # Check if all substrings are different\n    if len(substrings) != len(set(substrings)):\n        return -1\n\n    # If all substrings are different, reorder the letters in the input string\n    result = sorted(s)\n\n    # Return the rearranged string\n    return ''.join(result)"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_rearrangement(s: str) -> bool:\n        seen_substrings = set()\n        for i in range(len(s) // 2 + 1):\n            for j in range(i + 1, len(s) // 2 + 1):\n                if s[i:j] in seen_substrings:\n                    return False\n                seen_substrings.add(s[i:j])\n        return True\n\n    n = len(stdin)\n    if n % 2 != 0:\n        return -1\n\n    stdin = sorted(list(stdin))\n    if is_valid_rearrangement(stdin):\n        return ''.join(stdin)\n    else:\n        return -1\n"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 == 1:\n        return -1\n    if len(set(stdin)) == N // 2 + 1:\n        return stdin\n    else:\n        return -1"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 == 1:\n        return -1\n    substrings = [stdin[i:i+N//2] for i in range(0, N, N//2)]\n    unique_substrings = set(substrings)\n    if len(unique_substrings) != len(substrings):\n        return -1\n    else:\n        return stdin"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 != 0:\n        return -1\n\n    N_half = N // 2\n    substrings = [stdin[:N_half], stdin[N_half:]]\n\n    def is_valid(s: str) -> bool:\n        for i in range(len(s) - N_half + 1):\n            if s[i:i + N_half] in substrings:\n                return False\n        return True\n\n    def rearrangement(s: str) -> str:\n        result = [''] * N\n        for i in range(N_half):\n            result[i] = s[i]\n        for i in range(N_half, N):\n            result[i] = s[i - N_half + 1]\n        return ''.join(result)\n\n    while not is_valid(substrings[0] + substrings[1]):\n        substrings[0] = rearrangement(substrings[0])\n        substrings[1] = rearrangement(substrings[1])\n        if substrings[0] == substrings[1]:\n            return -1\n\n    return rearrangement(substrings[0] + substrings[1])"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    p = list(map(int, input_list[1:]))\n    count = 0\n\n    for i in range(n):\n        for j in range(i+1, n+1):\n            if sorted(p[i:j])[n//2] == p[i]:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    p = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def binary_search(arr, x):\n        l, r = 0, len(arr) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if arr[m] == x:\n                return True\n            elif arr[m] < x:\n                l = m + 1\n            else:\n                r = m - 1\n        return False\n\n    def count_scary_subarrays(p):\n        p.sort()\n        scary_count = 0\n        for i in range(len(p)):\n            if i == 0 or p[i] != p[i - 1]:\n                if binary_search(p, p[i]):\n                    scary_count += 1\n                    if i > 0 and p[i] == p[i - 1]:\n                        j = i - 1\n                        while j >= 0 and p[j] == p[i]:\n                            scary_count -= 1\n                            j -= 1\n        return scary_count\n\n    return str(count_scary_subarrays(p))\n\ninput_stdin = \"\"\"5\n1 2 3 4 5\n\"\"\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    p = list(map(int, stdin.split('\\n')[1].split()))\n\n    p.sort()\n    median = p[n//2]\n    scary = 0\n\n    for i in range(n):\n        if p[i] == median:\n            scary += 1\n            break\n\n    for i in range(1, n):\n        if p[i] == median:\n            scary += 1\n        elif p[i-1] < median and median < p[i]:\n            scary += 1\n\n    return str(scary)"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(int, input().split()))\n    \n    median = sorted(p)[n//2]\n    scary = 0\n    \n    for i in range(n):\n        if p[i] > median:\n            scary += n - i\n    \n    return scary"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    p_list = list(map(int, input_list[1].split()))\n\n    p_list.sort()\n    count = 0\n\n    # Check if the leftmost element is the median of the elements\n    if n % 2 == 1:\n        median = p_list[n // 2]\n    else:\n        median = (p_list[n // 2 - 1] + p_list[n // 2]) // 2\n\n    # Check if the leftmost element is greater than or equal to the median\n    if p_list[0] >= median:\n        count += 1\n\n    # Check all possible subarrays for scary subarrays\n    for i in range(1, n):\n        # Check if the leftmost element is greater than or equal to the median\n        if p_list[i] >= median:\n            count += 1\n        else:\n            # Reset the leftmost element to the previous element\n            p_list[0] = p_list[i - 1]\n            # Sort the remaining elements\n            p_list[1:] = sorted(p_list[1:])\n            # Check if the leftmost element is the median of the remaining elements\n            if p_list[0] >= median:\n                count += 1\n\n    return count"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(int, input().split()))\n    p.sort()\n    count = 0\n    for i in range(n):\n        if i == 0 or p[i] != p[i-1]:\n            count += 1\n            left = i + 1\n            while left < n and left < i + n//2:\n                if p[left] > p[n//2]:\n                    count += left - i\n                    break\n                left += 1\n    return count\n\ndef"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    def median(arr):\n        arr.sort()\n        if len(arr) % 2 == 0:\n            return (arr[len(arr) // 2 - 1] + arr[len(arr) // 2]) / 2\n        else:\n            return arr[len(arr) // 2]\n\n    def count_scary_subarrays(arr):\n        count = 0\n        for i in range(len(arr)):\n            if i == 0:\n                continue\n            if median(arr[:i+1]) == arr[i]:\n                count += i\n        return count\n\n    scary_subarrays = count_scary_subarrays(p)\n    return str(scary_subarrays)\n"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    p = [int(x) for x in input_list[1:]]\n\n    scary_subarrays = 0\n    for i in range(1, n):\n        if p[i] < p[0]:\n            scary_subarrays += n - i\n            break\n\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            if p[i] <= p[j]:\n                scary_subarrays += 1\n\n    return str(scary_subarrays)\n\n\ninput_list = [\"5\", \"1 2 3 4 5\", \"6\", \"3 2 1 6 4 5\"]\noutput_list = [solution(input_str) for input_str in input_list]\nfor output in output_list:\n    print(output)"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    if n == 1:\n        return 0\n    p.sort()\n    median_count = 0\n    for i in range(n):\n        if p[i] == p[i//2]:\n            median_count += 1\n    total_scary_subarrays = 2 ** (n - median_count) - 1\n    return total_scary_subarrays "
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def median(arr):\n        n = len(arr)\n        if n % 2 == 0:\n            return (arr[n//2 - 1] + arr[n//2]) / 2\n        else:\n            return arr[n//2]\n\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n\n    left_median = median(arr[:n//2 + 1])\n    right_median = median(arr[n//2 + 1:])\n\n    if left_median == right_median:\n        return 0\n\n    count = 0\n    for i in range(n):\n        for j in range(i, n):\n            if median(arr[i:j+1]) == left_median:\n                count += 1\n\n    return count\n"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    \n    if N % 2 == 0:\n        return \"0\"\n    \n    return \"1\"\n\n\ninput_str = \"47\\n523\"\noutput = [solution(s) for s in input_str.split(\"\\n\")]\nprint(\"\\n\".join(output)) "
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W = 2 * N\n    H = N\n    boxes = []\n    for w in range(W, 0, -1):\n        for h in range(H, 0, -1):\n            if h % 2 == 0:\n                if 2*h <= w <= 2*N:\n                    boxes.append((w, h))\n    return str(len(boxes))\n\ninput_str = \"47\\n523\"\noutput_str = \"\"\nfor i in range(len(input_str.split(\"\\n\"))):\n    output_str += solution(input_str.split(\"\\n\")[i]) + \"\\n\"\n\nprint(output_str) "
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W = 2 * N\n    min_empty_squares = W * W // 2 - N\n    return str(min_empty_squares)"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    \n    # If the number of widgets is even, we need to add an extra square to make sure there is a space to pack them.\n    if N % 2 == 0:\n        return str(N + 1)\n    \n    # If the number of widgets is odd, we can pack them in a box with the same width as the height of the box.\n    W = H = int((N + 1) / 2)\n    \n    # Calculate the number of empty squares left in the box.\n    empty_squares = (W * H) - N\n    \n    return str(empty_squares)\n"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N % 2 == 0:\n        return str(N // 2)\n    else:\n        return str(N // 2 + 1)\n\ndef"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    W = 2*N\n    H = N\n    boxes = []\n    \n    while W <= 4*H:\n        for i in range(H):\n            for j in range(W):\n                boxes.append((i,j))\n        W += 2*H\n        H *= 2\n    \n    empty_squares = 0\n    for box in boxes:\n        if box[0] % 2 == 0:\n            empty_squares += box[1]\n        else:\n            empty_squares += W - box[1] - 1\n    \n    return str(empty_squares)\n\ninput_str = \"47\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W = 2 * int(N ** 0.5)\n    H = 2 * int(N ** 0.5) + 1\n    empty_squares = 0\n\n    for i in range(W + 1):\n        for j in range(H + 1):\n            if i * j >= N:\n                empty_squares += (i - W) * (j - H)\n                break\n            elif i * j > 0:\n                empty_squares += (i - W) * (j - H)\n\n    return str(empty_squares)\n"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W = 2 * N\n    H = 2 * N + 1\n    if W % 2 == 0:\n        W += 1\n    if H % 2 == 0:\n        H += 1\n    w, h = W - 1, H - 1\n    min_empty_squares = w * h - N\n    return str(min_empty_squares)\n"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split()\n    N = int(input_list[0])\n\n    if N % 2 == 0:\n        W = N + 1\n    else:\n        W = N\n\n    H = W // 2 + 1\n\n    return W * H\n"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.strip())\n    if N % 2 == 0:\n        return str(N + 1)\n    else:\n        return str(N)"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph: dict, start: int, visited: set) -> list:\n        cycle = [start]\n        while visited:\n            node = visited.pop()\n            cycle.append(node)\n            for neighbor in graph[node]:\n                if neighbor != start and neighbor not in visited and not any(neighbor in path for path in cycle):\n                    visited.add(neighbor)\n                    cycle.append(neighbor)\n                    return cycle\n        return []\n\n    def cancel_cycles(graph: dict) -> dict:\n        result = {}\n        for start in graph:\n            visited = set()\n            visited.add(start)\n            cycle = find_cycle(graph, start, visited)\n            if cycle:\n                for i in range(len(cycle) - 1):\n                    start, end = cycle[i], cycle[i + 1]\n                    amount = min(result.get((start, end), float('inf')), result.get((end, start), float('inf')))\n                    result[(start, end)] = amount\n                    result[(end, start)] = amount\n                result[(cycle[-1], cycle[0])] = float('inf')\n        return result\n\n    def output_result(graph: dict):\n        result = []\n        for start, end in graph:\n            amount = graph[(start, end)]\n            if amount > 0:\n                result.append((start, end, amount))\n        return result\n\n    n, m = map(int, stdin.split()[:2])\n    graph = {(i, j): 0 for i in range(n) for j in range(n) if i != j}\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[1:4])\n        graph[(a, b)] = min(graph[(a, b)], c)\n    cancel_graph = cancel_cycles(graph)\n    cancel_result = output_result(cancel_graph)\n    p = len(cancel_result)\n    return str(p) + '\\n' + '\\n'.join(map(str, cancel_result))"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    IOUs = [map(int, line.split()) for line in input_data[1:]]\n    IOUs = [list(IOU) for IOU in IOUs]\n    V = []\n    E = []\n    for IOU in IOUs:\n        a, b, c = IOU\n        V.append(a)\n        V.append(b)\n        E.append((a, b, c))\n    V = list(set(V))\n    indegree = [0] * n\n    graph = [[] for _ in range(n)]\n    for a, b, c in E:\n        indegree[b] += 1\n        graph[a].append((b, c))\n    for i in range(n):\n        for j in range(n):\n            for IOU in graph[j]:\n                if IOU[0] == i:\n                    graph[i].append((j, IOU[1]))\n                    break\n    component = []\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            component.append([i])\n            stack = [i]\n            visited[i] = True\n            while stack:\n                u = stack.pop()\n                for v, w in graph[u]:\n                    if not visited[v]:\n                        visited[v] = True\n                        stack.append(v)\n                        component[-1].append(v)\n    cycles = [[] for _ in range(len(component))]\n    for i in range(n):\n        for j in range(n):\n            for IOU in graph[j]:\n                if IOU[0] == i and IOU[1] < 0:\n                    cycles[IOU[1] + n].append((i, j, -IOU[1]))\n    for cycle in cycles:\n        cycle.sort(key=lambda x: x[2], reverse=True)\n    min_cycle = []\n    for cycle in cycles:\n        if cycle:\n            min_cycle = cycle\n            break\n    for i in range(len(min_cycle)):\n        a, b, c = min_cycle[i]\n        if component[a].intersection(component[b]):\n            component[a].append(b)\n            component[b].append(a)\n            min_cycle[i] = (a, a, c)\n    for i in range(n):\n        for j in range(n):\n            for IOU in graph[j]:\n                if IOU[0] == i and IOU[1] > 0:\n                    graph[i].append((j, -IOU[1]))\n                    graph[j].append((i, IOU[1]))\n    for i in range(n):\n        for j in range(n):\n            for IOU in graph[j]:\n                if IOU[0] == i and IOU[1] < 0:\n                    graph[i].append((j, -IOU[1]))\n                    graph[j].append((i, IOU[1]))\n    for i in range(n):\n        for j in range(n):\n            if graph[i] and graph[j]:\n                for IOU in graph[i]:\n                    if IOU[1] > 0 and (j, IOU[1]) in graph[j]:\n                        graph[i].remove(IOU)\n                        graph[j].remove((j, IOU[1]))\n    p = len(graph)\n    output = []\n    for IOU in graph:\n        if IOU:\n            output.append(IOU)\n    output.sort(key=lambda x: (x[0], x[1]))\n    for IOU in output:\n        if IOU[1] < 0:\n            p -= 1\n    return f\"{p}\\n\" + \"\\n\".join([f\"{a} {b} {c}\" for a, b, c in output]) "
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    friends = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        friends[a].append((b, c))\n        friends[b].append((a, c))\n    settle_cycles(friends, n)\n    output_remaining_IOUs(friends)\n\n\ndef"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    friends = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        friends[a].append((b, c))\n        friends[b].append((a, c))\n\n    def cancel_cycle(cycle):\n        min_debt = min(cycle, key=lambda x: x[1])[1]\n        for i, (b, c) in enumerate(cycle):\n            if cycle[i][1] == min_debt:\n                cycle[i] = (b, min_debt)\n                break\n        return min_debt\n\n    def settle_cycles():\n        while True:\n            settled = False\n            for cycle in [sorted(friend) for friend in friends]:\n                if len(set(friend[0] for friend in cycle)) == 1:\n                    continue\n                debt = cancel_cycle(cycle)\n                for i, (b, c) in enumerate(cycle):\n                    if cycle[i][1] == debt:\n                        cycle[i] = (b, 0)\n                        break\n                for i, (a, c) in enumerate(cycle):\n                    if cycle[i][1] == debt:\n                        cycle[i] = (a, debt)\n                        break\n                settled = True\n            if not settled:\n                break\n\n    settle_cycles()\n    ious = [(a, b, c) for a in range(n) for b, c in friends[a] if c > 0]\n    p = len(ious)\n    return str(p) + '\\n' + '\\n'.join(map(str, ious))\n\n\ninput_data = '''4 5\n0 1 10\n1 2 10\n0 3 10\n3 2 10\n2 0 20\n'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(edge: list) -> list:\n        def dfs(node: int, visited: list, parent: int) -> list:\n            visited[node] = True\n            for child in edge[node]:\n                if not visited[child]:\n                    cycle = dfs(child, visited, node)\n                    if cycle:\n                        return cycle\n                elif child != parent:\n                    return [node, child, edge[node][child]]\n            return []\n\n        visited = [False] * n\n        for i in range(n):\n            if not visited[i]:\n                cycle = dfs(i, visited, -1)\n                if cycle:\n                    return cycle\n        return []\n\n    n, m = map(int, stdin.split()[:2])\n    edge = [dict() for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[2:])\n        edge[a][b] = edge[b].setdefault(a, 0) + c\n\n    def dfs(node: int, visited: list, parent: int, amount: int) -> int:\n        visited[node] = True\n        for child in edge[node]:\n            if not visited[child]:\n                dfs(child, visited, node, amount + edge[node][child])\n            elif child != parent:\n                cancel = min(amount, edge[node][child])\n                edge[node][child] -= cancel\n                edge[child][node] -= cancel\n\n    while True:\n        cycle = find_cycle(edge)\n        if not cycle:\n            break\n        a, b, c = cycle\n        dfs(a, [False] * n, -1, 0)\n        dfs(b, [False] * n, -1, 0)\n\n    p = sum(sum(e.values()) > 0 for e in edge)\n    return str(p) + '\\n' + '\\n'.join(str(x) + ' ' + str(y) + ' ' + str(edge[x][y]) for x in range(n) for y in edge[x] if edge[x][y] > 0) "
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    ious = []\n    for _ in range(m):\n        a, b, c = map(int, input().split())\n        ious.append((a, b, c))\n\n    # Create a graph representing the IOUs\n    graph = [[] for _ in range(n)]\n    for a, b, c in ious:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    # Find cycles and cancel them\n    cycles = []\n    for i in range(n):\n        if any(i in cycle for cycle in cycles):\n            continue\n        visited = [False] * n\n        cycle = []\n        dfs(i, visited, graph, cycle)\n        if len(cycle) > 2:\n            cycles.append(cycle)\n\n    for cycle in cycles:\n        min_amount = min(ious[i][2] for i in range(m) if ious[i][0] in cycle and ious[i][1] in cycle)\n        for i in range(m):\n            if ious[i][0] in cycle and ious[i][1] in cycle and ious[i][2] < min_amount:\n                ious[i] = (ious[i][0], ious[i][1], 0)\n            if ious[i][0] in cycle and ious[i][1] not in cycle:\n                ious[i] = (ious[i][0], ious[i][1], 0)\n            if ious[i][1] in cycle and ious[i][0] not in cycle:\n                ious[i] = (ious[i][1], ious[i][0], 0)\n\n    # Output the remaining IOUs\n    print(len(ious))\n    for i in range(len(ious)):\n        print(f\"{ious[i][0]} {ious[i][1]} {ious[i][2]}\")\n\n\ndef"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(u: int, v: int, visited: list, rec_stack: list) -> bool:\n        visited[v] = True\n        rec_stack[v] = True\n        for i in range(n):\n            if graph[v][i] == 1:\n                if visited[i] == False and find_cycle(u, i, visited, rec_stack) == True:\n                    return True\n                elif rec_stack[i] == True:\n                    return True\n        rec_stack[v] = False\n        return False\n\n    def cancel_cycles(u: int, v: int, visited: list, rec_stack: list) -> None:\n        visited[v] = True\n        rec_stack[v] = True\n        for i in range(n):\n            if graph[v][i] == 1:\n                if visited[i] == False and find_cycle(u, i, visited, rec_stack) == True:\n                    min_amount = float('inf')\n                    min_index = -1\n                    for j in range(n):\n                        if graph[u][j] > 0 and graph[i][j] > 0 and graph[j][u] > 0:\n                            if graph[u][j] + graph[i][j] - graph[j][u] < min_amount:\n                                min_amount = graph[u][j] + graph[i][j] - graph[j][u]\n                                min_index = j\n                    graph[u][min_index] -= min_amount\n                    graph[min_index][u] = 0\n                    graph[i][min_index] -= min_amount\n                    graph[min_index][i] = 0\n                cancel_cycles(u, i, visited, rec_stack)\n        rec_stack[v] = False\n\n    input_list = stdin.splitlines()\n    n, m = map(int, input_list[0].split())\n    graph = [[0] * n for _ in range(n)]\n    iou_list = []\n\n    for i in range(1, m + 1):\n        u, v, c = map(int, input_list[i].split())\n        graph[u][v] = c\n        graph[v][u] = 0\n\n    visited = [False] * n\n    rec_stack = [False] * n\n    num_iou = 0\n\n    for i in range(n):\n        for j in range(n):\n            if graph[i][j] > 0:\n                num_iou += 1\n                cancel_cycles(i, j, visited, rec_stack)\n\n    result = []\n    for u in range(n):\n        for v in range(n):\n            if graph[u][v] > 0:\n                result.append((u, v, graph[u][v]))\n\n    output = [str(num_iou)] + [\" \".join(map(str, iou)) for iou in result]\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(IOU_graph, visited, start):\n        cycle = []\n        cycle_found = False\n        for i in range(n):\n            if not visited[i]:\n                if dfs(IOU_graph, visited, start, i, cycle):\n                    cycle_found = True\n                    break\n        return cycle_found, cycle\n\n    def dfs(IOU_graph, visited, start, i, cycle):\n        visited[i] = True\n        cycle.append(i)\n        for j in range(n):\n            if IOU_graph[i][j] > 0:\n                if not visited[j]:\n                    if dfs(IOU_graph, visited, j, start, cycle):\n                        return True\n                elif j != start and j != i:\n                    cycle.append(j)\n                    return True\n        cycle.pop()\n        return False\n\n    def find_min_cycle(IOU_graph):\n        min_cycle = []\n        for i in range(n):\n            for j in range(n):\n                if IOU_graph[i][j] > 0:\n                    if not min_cycle or IOU_graph[i][j] < min_cycle[0]:\n                        min_cycle = [IOU_graph[i][j], i, j]\n        return min_cycle\n\n    lines = stdin.split('\\n')\n    n, m = map(int, lines[0].split())\n    IOUs = []\n    for line in lines[1:]:\n        a, b, c = map(int, line.split())\n        IOUs.append([a, b, c])\n\n    IOU_graph = [[0 for _ in range(n)] for _ in range(n)]\n    for a, b, c in IOUs:\n        IOU_graph[a][b] += c\n\n    p = 0\n    while True:\n        visited = [False] * n\n        cycle_found, cycle = find_cycle(IOU_graph, visited, -1)\n        if not cycle_found:\n            break\n        a, b, c = find_min_cycle(IOU_graph)\n        IOU_graph[a[1]][a[2]] -= a[0]\n        IOU_graph[a[2]][a[1]] -= a[0]\n        p += 1\n\n    result = [str(p)]\n    for a, b, c in IOUs:\n        if c > 0:\n            result.append(f\"{a} {b} {c}\")\n    return '\\n'.join(result)"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, m = map(int, input_list[0].split())\n    edges = []\n    for i in range(1, m + 1):\n        edge = list(map(int, input_list[i].split()))\n        edges.append(edge)\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append((edge[1], edge[2]))\n        graph[edge[1]].append((edge[0], edge[2]))\n    def min_cycle_size(graph, visited):\n        visited[0] = True\n        queue = [(0, 0)]\n        min_size = float('inf')\n        while queue:\n            vertex, size = queue.pop(0)\n            for neighbor, weight in graph[vertex]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append((neighbor, size + weight))\n                    min_size = min(min_size, size + weight)\n        return min_size\n    \n    def dfs(graph, visited, cycle_sizes, index):\n        if index == -1:\n            return\n        visited[index] = True\n        for neighbor, weight in graph[index]:\n            if not visited[neighbor]:\n                cycle_sizes[0] = min(cycle_sizes[0], weight)\n                dfs(graph, visited, cycle_sizes, neighbor)\n                if cycle_sizes[0] < weight:\n                    graph[index].remove((neighbor, weight))\n                    graph[neighbor].remove((index, weight))\n        cycle_sizes[0] = float('inf')\n    \n    num_cycles = 0\n    while True:\n        visited = [False] * n\n        cycle_sizes = [float('inf')]\n        dfs(graph, visited, cycle_sizes, 0)\n        num_cycles += 1\n        if cycle_sizes[0] == float('inf'):\n            break\n    \n    for i in range(n):\n        if not graph[i]:\n            continue\n        min_cycle_size(graph, [False] * n)\n    \n    remaining_IOUs = []\n    for i in range(n):\n        for neighbor, weight in graph[i]:\n            remaining_IOUs.append((i, neighbor, weight))\n    \n    p = len(remaining_IOUs)\n    print(p)\n    for iou in remaining_IOUs:\n        print(\" \".join(map(str, iou)))\n"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    debts = []\n    for _ in range(m):\n        debts.append(list(map(int, stdin.split()[2:5])))\n    \n    # Create a graph where edges represent IOUs\n    graph = [[] for _ in range(n)]\n    for debt in debts:\n        graph[debt[0]].append((debt[1], debt[2]))\n        graph[debt[1]].append((debt[0], -debt[2]))\n    \n    # Find cycles in the graph\n    visited = [False] * n\n    cycles = []\n    for i in range(n):\n        if not visited[i]:\n            visited[i] = True\n            stack = []\n            cycle = []\n            cycle_found = find_cycle(i, graph, visited, stack, cycle)\n            if cycle_found:\n                cycles.append(cycle)\n    \n    # Cancel cycles and compute the remaining debts\n    remaining_debt = 0\n    for i in range(n):\n        for j, debt in enumerate(graph[i]):\n            if debt[0] == i:\n                graph[i].pop(j)\n    for cycle in cycles:\n        min_debt = min(cycle)\n        for node in cycle:\n            debt = next((d for d in graph[node] if d[0] == cycle[(cycle.index(node) + 1) % len(cycle)]), None)\n            if debt is not None:\n                graph[node].remove(debt)\n                graph[node].append((cycle[(cycle.index(node) - 1) % len(cycle)], debt[1]))\n            else:\n                graph[node].append((cycle[(cycle.index(node) - 1) % len(cycle)], -debt[1]))\n        remaining_debt -= min_debt\n    \n    # Sort the remaining debts and output them\n    remaining_debt += len(graph) - n\n    output = [f\"{remaining_debt}\"]\n    for i in range(n):\n        for j, debt in enumerate(graph[i]):\n            if debt[1] > 0:\n                output.append(f\"{i} {debt[0]} {debt[1]}\")\n                break\n    \n    return \"\\n\".join(output)\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split(\"\\n\")\n    n = int(input_values[0].split()[0])\n    m = int(input_values[0].split()[1])\n    heights = list(map(int, input_values[1].split()))\n    roads = [list(map(int, input_values[i+2].split())) for i in range(m)]\n\n    def get_fibonacci_tour_length(heights):\n        fib_sequence = [1, 1]\n        for i in range(2, n):\n            fib_sequence.append(fib_sequence[-1] + fib_sequence[-2])\n        max_length = 0\n        for i in range(n):\n            for j in range(i+2, n+1):\n                subsequence = [heights[k] for k in range(i, j)]\n                if all(subsequence[k] <= subsequence[k+1] for k in range(len(subsequence)-1)) and all(subsequence[k] == fib_sequence[k] for k in range(len(subsequence))) and len(subsequence) > max_length:\n                    max_length = len(subsequence)\n        return max_length\n\n    def is_valid_tour(tour, roads):\n        for road in roads:\n            if tour[road[0]-1] != tour[road[1]-1]:\n                return False\n        return True\n\n    max_length = 0\n    for permutation in itertools.permutations(range(1, n+1)):\n        if is_valid_tour(permutation, roads):\n            length = len(permutation)\n            if length > max_length:\n                max_length = length\n\n    return str(max_length)\n\nstdin = \"\"\"5 6\n1 3 2 1 5\n1 3\n2 3\n1 4\n3 5\n4 5\n2 5\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(path: str) -> bool:\n        return all(path[i] < path[i + 1] for i in range(len(path) - 1))\n\n    n, m = map(int, stdin.split()[:2])\n    heights = list(map(int, stdin.split()[2:n + 2]))\n    roads = [map(int, line.split()) for line in stdin.splitlines()[n + 2:]]\n\n    max_tour_length = 0\n    for a in range(1, n + 1):\n        for b in range(a + 1, n + 1):\n            for c in range(1, n + 1):\n                if (a, b, c) == (1, 1, 2):\n                    path = \"12\"\n                elif (a, b, c) == (1, 2, 3):\n                    path = \"123\"\n                else:\n                    path = \"1\" + str(a) + str(c)\n\n                for i, road in enumerate(roads):\n                    if (a, b) == road or (a, c) == road or (b, c) == road:\n                        path += str(i + 1)\n                        break\n                else:\n                    continue\n\n                if is_valid(path):\n                    tour_length = len(path)\n                    if tour_length > max_tour_length:\n                        max_tour_length = tour_length\n\n    return str(max_tour_length)"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0].split()[0])\n    m = int(input_list[0].split()[1])\n    heights = list(map(int, input_list[1].split()))\n    roads = [tuple(map(int, line.split())) for line in input_list[2:]]\n\n    def longest_fibonacci_tour(heights, roads):\n        max_length = 1\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (i, j) in roads:\n                    height_diff = abs(heights[i] - heights[j])\n                    max_length = max(max_length, height_diff + 1)\n        return max_length\n\n    return str(longest_fibonacci_tour(heights, roads))\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    heights = list(map(int, stdin.split()[2:n+2]))\n    roads = [map(int, line.split()) for line in stdin.splitlines()[n+2:n+m+2]]\n\n    def is_valid_tour(tour: list[int]) -> bool:\n        visited = set()\n        for i, mansion in enumerate(tour):\n            if mansion in visited:\n                return False\n            visited.add(mansion)\n            if i > 0:\n                prev = tour[i - 1]\n                if (prev, mansion) not in roads and (mansion, prev) not in roads:\n                    return False\n        return True\n\n    def is_fibonacci_sequence(sequence: list[int]) -> bool:\n        for i in range(2, len(sequence)):\n            if sequence[i] != sequence[i - 1] + sequence[i - 2]:\n                return False\n        return True\n\n    def find_max_tour_length() -> int:\n        max_tour_length = 0\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                tour = [i, j]\n                while len(tour) < n:\n                    next_mansion = None\n                    for a, b in roads:\n                        if a == tour[-1] and b != tour[-2]:\n                            next_mansion = b\n                            break\n                    if next_mansion is None:\n                        break\n                    tour.append(next_mansion)\n                if is_valid_tour(tour) and is_fibonacci_sequence(heights[i - 1:j]):\n                    max_tour_length = max(max_tour_length, j - i + 1)\n        return max_tour_length\n\n    return str(find_max_tour_length())"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    heights = list(map(int, stdin.split()[2:2+n]))\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[2+m:] if line.strip()]\n    def is_valid_fibonacci_tour(visited: List[int]) -> bool:\n        if len(visited) < 3:\n            return True\n        for i in range(2, len(visited)):\n            if heights[visited[i-1]-1] + heights[visited[i]-1] != heights[visited[i-2]-1]:\n                return False\n        return True\n\n    def generate_fibonacci_tours(visited: List[int]) -> List[List[int]]:\n        if len(visited) == n:\n            return [visited]\n        result = []\n        for mansion in range(1, n+1):\n            if mansion not in visited:\n                for tour in generate_fibonacci_tours(visited + [mansion]):\n                    if is_valid_fibonacci_tour(tour):\n                        result.append(tour)\n        return result\n\n    all_tours = generate_fibonacci_tours([])\n    all_tours.sort(key=lambda tour: len(tour))\n    longest_tour = all_tours[-1]\n    if len(longest_tour) == 1:\n        return 1\n    else:\n        return len(longest_tour)\n"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_fibonacci(n: int) -> bool:\n        a, b = 0, 1\n        while b <= n:\n            if b == n:\n                return True\n            a, b = b, a + b\n        return False\n\n    n, m, *heights, *roads = map(int, stdin.split())\n    heights = list(map(int, heights))\n    roads = list(zip(roads[::2], roads[1::2]))\n\n    max_tour_length = 0\n    for i in range(1, n + 1):\n        tour_length = 1\n        visited = set([i])\n        for j in range(1, n + 1):\n            if j not in visited:\n                for a, b in roads:\n                    if a in visited and b == j:\n                        tour_length += 1\n                        visited.add(j)\n                        break\n                else:\n                    continue\n                if tour_length > max_tour_length and is_fibonacci(tour_length):\n                    max_tour_length = tour_length\n                break\n    return str(max_tour_length)"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split('\\n')\n    n = int(input_values[0].split()[0])\n    m = int(input_values[0].split()[1])\n    mansion_heights = list(map(int, input_values[1].split()))\n    roads = [list(map(int, input_values[i].split())) for i in range(2, len(input_values))]\n\n    def is_valid_tour(tour: list) -> bool:\n        for a, b in zip(tour, tour[1:]):\n            if (a, b) not in roads and (b, a) not in roads:\n                return False\n        return True\n\n    def get_longest_tour_length(tour_length: int) -> int:\n        if tour_length == 0:\n            return 0\n        else:\n            prev_tour_length = get_longest_tour_length(tour_length - 1)\n            if is_valid_tour([i + 1 for i in range(n)]):\n                return max(prev_tour_length, tour_length + 1)\n            else:\n                return prev_tour_length\n\n    tour_length = get_longest_tour_length(2)\n    return str(tour_length)"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(fib: list, mansion_heights: list) -> bool:\n        for i in range(len(fib) - 1):\n            if fib[i] + fib[i+1] > mansion_heights[i+1]:\n                return False\n        return True\n\n    n, m = map(int, stdin.split()[:2])\n    mansion_heights = list(map(int, stdin.split()[2:]))\n    roads = [list(map(int, line.split())) for line in stdin.split('\\n')[2:] if line]\n\n    mansion_distances = [0] * n\n    for a, b in roads:\n        mansion_distances[b-1] += mansion_heights[a-1]\n\n    fib = [1, 1]\n    max_length = 0\n    for i in range(2, n+1):\n        fib.append(fib[-1] + fib[-2])\n\n    for i in range(2, n+1):\n        if is_valid(fib[:i+1], mansion_distances):\n            max_length = i\n\n    return str(max_length)\n\n\ndef"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    heights = list(map(int, stdin.split()[2:n+2]))\n    roads = [tuple(map(int, line.split())) for line in stdin.split()[n+2:n+2+m]]\n\n    def is_connected(a, b):\n        visited = [False] * n\n        queue = [0]\n        visited[0] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor in range(1, n+1):\n                if not visited[neighbor] and (a, b) in [(min(a, neighbor), max(a, neighbor)), (max(a, neighbor), min(a, neighbor))] + roads:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n        return visited[a] and visited[b]\n\n    def is_fibonacci_sequence(sequence):\n        for i in range(2, len(sequence)):\n            if sequence[i] != sequence[i-1] + sequence[i-2]:\n                return False\n        return True\n\n    def fibonacci_tour(n):\n        sequence = [1, 1]\n        for _ in range(n-2):\n            sequence.append(sequence[-1] + sequence[-2])\n        return sequence\n\n    max_length = 0\n    for i in range(n):\n        if any(is_connected(i, j) for j in range(n) if j != i):\n            sequence = [heights[i]]\n            for j in range(n):\n                if is_connected(i, j):\n                    sequence.append(heights[j])\n            if is_fibonacci_sequence(sequence):\n                max_length = max(max_length, len(sequence))\n\n    return max_length"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    heights = list(map(int, input().split()))\n    roads = []\n    for _ in range(m):\n        a, b = map(int, input().split())\n        roads.append((a, b))\n\n    def is_valid_fibonacci_tour(visited_mansions):\n        if len(visited_mansions) <= 2:\n            return True\n        if len(set(visited_mansions)) != len(visited_mansions):\n            return False\n        height_sequence = [heights[visited_mansions[0]]]\n        for i in range(1, len(visited_mansions)):\n            height_sequence.append(heights[visited_mansions[i]] + height_sequence[i - 1])\n        return all(height_sequence[i] - height_sequence[i - 1] == 1 for i in range(2, len(visited_mansions)))\n\n    max_length = 0\n    for permutation in itertools.permutations(range(1, n + 1)):\n        visited_mansions = [0] + list(permutation)\n        valid_tour = True\n        for a, b in roads:\n            if visited_mansions.index(a) + 1 != visited_mansions.index(b):\n                valid_tour = False\n                break\n        if valid_tour and is_valid_fibonacci_tour(visited_mansions):\n            max_length = max(max_length, len(visited_mansions))\n\n    return str(max_length) if max_length > 0 else \"0\"\n"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(M, prime_factors):\n        count = 1\n        for i in range(len(prime_factors) - 1):\n            if prime_factors[i] == prime_factors[i+1]:\n                count += 1\n            else:\n                break\n        base_cost = M * count\n        if count == 1:\n            return base_cost\n        extra_cost = (count * (count - 1)) // 2 * (M - 1)\n        return base_cost + extra_cost\n\n    prime_factors = [int(stdin[i:i+2]) for i in range(0, len(stdin), 2)]\n    K = 1\n    M = 1\n    for p in prime_factors:\n        K *= p\n        M *= p\n    M = 10**9 + 7\n    return get_min_cost(M, prime_factors)"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    M = 10**9 + 7\n    K = 0\n    for i in range(0, len(stdin), 2):\n        K *= int(stdin[i]) ** int(stdin[i+1])\n\n    count = 0\n    while count * 4 <= K:\n        count += 1\n\n    return (count * 4 + M - 1) % M"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    factors = [int(stdin[i:i+2]) for i in range(0, len(stdin), 2)]\n    max_m = max(factors)\n    \n    min_cost = max_m * (k // max_m)\n    extra_bytes = k % max_m\n    num_servers = (extra_bytes + max_m - 1) // max_m\n    \n    min_cost += num_servers * (max_m + 1)\n    min_cost %= (10**9 + 7)\n    \n    return str(min_cost)"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    M = int(stdin[0])\n    K = int(stdin[1:])\n    \n    def count_primes(n: int) -> int:\n        count = 0\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                count += 1\n        return count + 1 if n > 1 else 1\n\n    def min_cost(K: int, M: int) -> int:\n        q, r = divmod(K, M)\n        cost = q * (M + M * count_primes(M)) + r * (M + M * count_primes(M))\n        return cost % (10**9 + 7)\n\n    return str(min_cost(K, M))\n"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factors(n: int) -> list:\n        factors = []\n        while n % 2 == 0:\n            factors.append(2)\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        if n > 2:\n            factors.append(n)\n        return factors\n\n    def min_cost(factors: list, max_m: int, modulo: int) -> int:\n        dp = [0] * (max_m + 1)\n        for factor in set(factors):\n            for m in range(max_m, factor - 1, -1):\n                dp[m] = max(dp[m], dp[m - factor] + factor)\n        return dp[max_m] % modulo\n\n    factors = [int(x) for x in stdin.split()]\n    prime_factors = [1]\n    for factor in factors:\n        prime_factors.extend([factor] * factor)\n    max_m = sum(prime_factors)\n    return min_cost(prime_factors, max_m, 10**9 + 7)"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factorize(num: int) -> str:\n        result = \"\"\n        for i in range(2, int(num**0.5)+1):\n            while num % i == 0:\n                result += str(i)\n                num //= i\n        if num > 1:\n            result += str(num)\n        return result\n\n    def count_primes(factors: str) -> int:\n        primes = set()\n        for factor in factors:\n            primes.add(int(factor))\n        return len(primes)\n\n    def min_cost(factors: str) -> int:\n        min_cost = float('inf')\n        for i in range(len(factors)):\n            if i % 2 == 0:\n                prime_factor = int(factors[i])\n                count = 1\n                while i + 2 < len(factors) and factors[i+2] == prime_factor:\n                    count += 1\n                    i += 2\n                if i + 1 < len(factors) and factors[i+1] == prime_factor:\n                    count += 1\n                cost = prime_factor * (count + 1)\n                if cost < min_cost:\n                    min_cost = cost\n        return min_cost\n\n    factors = prime_factorize(int(stdin))\n    num_primes = count_primes(factors)\n    min_cost = min_cost(factors)\n    return (min_cost % (10**9+7))"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    total_bytes = 1\n    for i in range(0, len(stdin), 2):\n        total_bytes *= int(stdin[i:i+2])\n\n    mod = 10**9 + 7\n\n    if total_bytes == 1:\n        return str(1)\n\n    min_cost = float('inf')\n\n    for i in range(2, total_bytes + 1):\n        cost = (total_bytes // i) * (i - 1) + (total_bytes % i)\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost % mod)\n"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    K = int(\"\".join(stdin[i*2:(i*2)+2] for i in range(len(stdin)//2)))\n    factors = sorted(set(prime_factors(K)))\n    min_cost = float('inf')\n\n    for factor in factors:\n        num_servers = K // factor\n        cost = factor + (num_servers - 1)\n        min_cost = min(min_cost, cost)\n\n    return str(min_cost % (10**9 + 7))\n\ndef"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def count_prime_factors(n: int) -> int:\n        count = 0\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                count += 1\n        if n > 1:\n            count += 1\n        return count\n\n    def count_divisors(n: int) -> int:\n        count = 1\n        i = 2\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                count += 1\n        if n > 1:\n            count += 1\n        return count\n\n    def min_cost(n: int, m: int, k: int) -> int:\n        count = count_prime_factors(k)\n        modulus = 10 ** 9 + 7\n        if count == 0:\n            return 0\n        elif count == 1:\n            return k * m\n        else:\n            max_divisors = (n // m) * count\n            min_divisors = count_divisors(k)\n            min_cost = (max_divisors - min_divisors) * m\n            return min_cost % modulus\n\n    def process_input(stdin: str) -> int:\n        k = 1\n        for i in range(0, len(stdin), 2):\n            k *= int(stdin[i:i + 2])\n        return k\n\n    n, m = 1, 1\n    k = process_input(stdin)\n    while k % m:\n        n *= m\n        m += 1\n    min_c = min_cost(n, m, k)\n    return min_c\n"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factorize(n: int) -> str:\n        result = \"\"\n        while n % 2 == 0:\n            result += \"02\"\n            n //= 2\n        for i in range(3, int(n**0.5) + 1, 2):\n            while n % i == 0:\n                result += str(i) + \"02\"\n                n //= i\n        if n > 2:\n            result += str(n) + \"02\"\n        return result[:-2]\n\n    def min_cost(factors: str, M: int) -> int:\n        total_bytes = sum(int(factor) for i, factor in enumerate(factors) if i % 2 == 0)\n        if total_bytes % M != 0:\n            return -1\n        num_servers = total_bytes // M\n        cost = num_servers * M\n        for i in range(len(factors) - 1):\n            if int(factors[i]) > int(factors[i + 1]):\n                return -1\n        return cost % (10**9 + 7)\n\n    M = 4\n    factors = prime_factorize(int(stdin))\n    min_cost_value = float(\"inf\")\n    for i in range(len(factors) - 1):\n        if int(factors[i]) == M:\n            new_factor = int(factors[i + 1]) * M\n            new_factors = factors[:i] + str(new_factor) + factors[i + 2:]\n            cost = min_cost(new_factors, M)\n            if cost != -1 and cost < min_cost_value:\n                min_cost_value = cost\n    return str(min_cost_value)"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_fold_coordinates(n: int, m: int, image: str) -> str:\n        folds = []\n        for i in range(n):\n            for j in range(m):\n                if image[i][j] == '.':\n                    folds.append((i, j))\n\n        min_fold_coords = []\n        min_fold_coords.extend(folds[0])\n\n        for i in range(1, len(folds)):\n            if folds[i][0] < min_fold_coords[0]:\n                min_fold_coords[0] = folds[i][0]\n            elif folds[i][0] == min_fold_coords[0]:\n                min_fold_coords[0] = min(min_fold_coords[0], folds[i][0])\n\n            if folds[i][1] < min_fold_coords[1]:\n                min_fold_coords[1] = folds[i][1]\n            elif folds[i][1] == min_fold_coords[1]:\n                min_fold_coords[1] = min(min_fold_coords[1], folds[i][1])\n\n        return min_fold_coords\n\n    def fold_image(n: int, m: int, image: str, fold_coords: tuple) -> str:\n        if fold_coords[0] == fold_coords[2]:\n            for i in range(fold_coords[1], fold_coords[3] + 1):\n                image[fold_coords[0]][i] = image[fold_coords[0]][i] + image[fold_coords[2]][i]\n            for i in range(fold_coords[1], fold_coords[3] + 1):\n                image[fold_coords[2]][i] = '.'\n        elif fold_coords[1] == fold_coords[3]:\n            for i in range(fold_coords[1], fold_coords[2] + 1):\n                image[i][fold_coords[0]] = image[i][fold_coords[0]] + image[i][fold_coords[2]]\n            for i in range(fold_coords[1], fold_coords[2] + 1):\n                image[i][fold_coords[2]] = '.'\n        else:\n            for i in range(fold_coords[1], fold_coords[3] + 1):\n                image[fold_coords[0]][i] = image[fold_coords[0]][i] + image[fold_coords[2]][i]\n            for i in range(fold_coords[1], fold_coords[3] + 1):\n                image[fold_coords[2]][i] = '.'\n            for i in range(fold_coords[1], fold_coords[3] + 1):\n                image[fold_coords[0]][fold_coords[2] - i] = image[fold_coords[0]][fold_coords[2] - i] + image[fold_coords[2]][fold_coords[2] - i]\n            for i in range(fold_coords[1], fold_coords[3] + 1):\n                image[fold_coords[2]][fold_coords[2] - i] = '.'\n\n        return image\n\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    image = []\n    for i in range(1, n + 1):\n        image.append(input_lines[i].strip())\n\n    fold_coords = find_fold_coordinates(n, m, ''.join(image))\n    image = fold_image(n, m, image, fold_coords)\n\n    fold_coords = fold_coords[::-1]\n    fold_coords = [min(fold_coords[0], fold_coords[2]), min(fold_coords[1], fold_coords[3])]\n"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    image = [list(line) for line in lines[1:]]\n\n    def is_fold_horizontal():\n        for row in range(1, n):\n            if image[row][0] == '#' and image[row - 1][0] == '.':\n                return True\n        return False\n\n    def is_fold_vertical():\n        for col in range(1, m):\n            if image[0][col] == '#' and image[-1][col] == '.':\n                return True\n        return False\n\n    def is_fold_diagonal():\n        for row in range(1, n):\n            for col in range(1, m):\n                if image[row][col] == '#' and image[row - 1][col - 1] == '.':\n                    return True\n        return False\n\n    def find_fold_horizontal():\n        for row in range(1, n):\n            if image[row][0] == '#' and image[row - 1][0] == '.':\n                return row\n        return None\n\n    def find_fold_vertical():\n        for col in range(1, m):\n            if image[0][col] == '#' and image[-1][col] == '.':\n                return col\n        return None\n\n    def find_fold_diagonal():\n        for row in range(1, n):\n            for col in range(1, m):\n                if image[row][col] == '#' and image[row - 1][col - 1] == '.':\n                    return (row, col)\n        return None\n\n    if is_fold_horizontal():\n        r1 = find_fold_horizontal()\n        c1 = 1\n        r2 = n\n        c2 = 1\n    elif is_fold_vertical():\n        r1 = 1\n        c1 = find_fold_vertical()\n        r2 = 1\n        c2 = n\n    elif is_fold_diagonal():\n        r1, c1 = find_fold_diagonal()\n        r2, c2 = find_fold_diagonal()\n    else:\n        return \"No fold found.\"\n\n    return f\"{r1} {c1} {r2} {c2}\"\n"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_fold(image: list) -> tuple:\n        def is_horizontal_fold(fold_line: int) -> bool:\n            for row in range(n):\n                if '#' in image[row][:fold_line] and '#' in image[row][fold_line:]:\n                    return False\n            return True\n\n        def is_vertical_fold(fold_line: int) -> bool:\n            for col in range(m):\n                if '#' in [image[row][col] for row in range(n)] and '#' in [image[row][col] for row in range(n)]:\n                    return False\n            return True\n\n        def is_diagonal_fold(fold_line: int) -> bool:\n            for i in range(n - 1):\n                for j in range(m - 1):\n                    if (i + j) % 2 == 0 and image[i][j] == '#' and image[i + 1][j + 1] == '#':\n                        return False\n            return True\n\n        folds = []\n        for fold_line in range(1, m):\n            if is_horizontal_fold(fold_line):\n                folds.append((fold_line, 1))\n            if is_vertical_fold(fold_line):\n                folds.append((1, fold_line))\n            if is_diagonal_fold(fold_line):\n                folds.append((fold_line, fold_line))\n\n        folds.sort()\n        return folds[0]\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    image = [list(line) for line in lines[1:]]\n\n    fold_line, fold_index = find_fold(image)\n\n    if fold_index == 1:\n        if fold_line < n / 2:\n            return f\"{fold_line + 1} {m}\"\n        else:\n            return f\"{n - fold_line} {m}\"\n    elif fold_index == 2:\n        if fold_line < m / 2:\n            return f\"{n} {fold_line + 1}\"\n        else:\n            return f\"{n} {m - fold_line}\"\n    else:\n        if fold_line < n / 2:\n            return f\"{fold_line + 1} {fold_line + 1}\"\n        else:\n            return f\"{n - fold_line} {n - fold_line}\""
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    n, m = map(int, input_lines[0].split())\n    image = input_lines[1:]\n\n    # Determine the fold line\n    for i in range(n + 1):\n        for j in range(m):\n            if image[i][j] == '#':\n                fold_line = i\n                break\n        if fold_line:\n            break\n\n    # Determine the fold axis\n    fold_axis = None\n    if fold_line == 0:\n        fold_axis = 'h'\n    elif fold_line == n:\n        fold_axis = 'v'\n    else:\n        for j in range(m - 1):\n            if image[fold_line][j] == '#' and image[fold_line][j + 1] == '#':\n                fold_axis = 'd'\n                break\n        if fold_axis is None:\n            for j in range(m):\n                if image[fold_line][j] == '#':\n                    fold_axis = 'd'\n                    break\n\n    # Determine the fold positions\n    fold_positions = []\n    if fold_axis == 'h':\n        for j in range(m):\n            if image[fold_line - 1][j] == '#':\n                fold_positions.append(j + 1)\n    elif fold_axis == 'v':\n        for i in range(fold_line + 1):\n            if image[i][m - 1] == '#':\n                fold_positions.append(i + 1)\n    else:\n        for j in range(m - 1):\n            if image[fold_line][j] == '#' and image[fold_line][j + 1] == '#':\n                fold_positions.append(j + 1)\n            elif image[fold_line][j] == '#' and image[fold_line][j + 1] == '.':\n                fold_positions.append(j + 1)\n            elif image[fold_line][j] == '.' and image[fold_line][j + 1] == '#':\n                fold_positions.append(j)\n\n    if len(fold_positions) == 0:\n        return \"No fold\"\n\n    fold_positions.sort()\n    if fold_axis == 'h':\n        return f\"{fold_positions[0]} 1 {fold_positions[-1]} 1\"\n    elif fold_axis == 'v':\n        return f\"1 {fold_positions[0]} {n} {fold_positions[-1]}\"\n    else:\n        return f\"{fold_positions[0]} {fold_line + 1} {fold_positions[-1]} {fold_line + 1}\" "
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_fold_pixels(fold_line: str, fold_direction: str) -> Tuple[int, int]:\n        fold_coords = []\n        for i, char in enumerate(fold_line):\n            if char == '#':\n                fold_coords.append((i + 1, 1) if fold_direction == 'h' else (1, i + 1))\n        return min(fold_coords, key=lambda x: x[0] + x[1]) if fold_direction == 'h' else min(fold_coords, key=lambda x: x[0] + x[1])\n\n    def find_fold_line(image: List[str]) -> Tuple[str, str]:\n        for i in range(len(image[0])):\n            for j in range(len(image)):\n                if image[j][i] == '#':\n                    fold_line = image[j][:i + 1]\n                    fold_direction = 'h' if i <= j else 'v'\n                    fold_line_h = fold_line\n                    fold_direction_h = fold_direction\n                    break\n            else:\n                continue\n            break\n        for i in range(len(image) - 1, -1, -1):\n            for j in range(len(image[0]) - 1, -1, -1):\n                if image[i][j] == '#':\n                    fold_line = image[i][j + 1:][::-1] + fold_line\n                    fold_direction = 'h' if i > j else 'v'\n                    fold_line_v = fold_line\n                    fold_direction_v = fold_direction\n                    break\n            else:\n                continue\n            break\n        if fold_direction_h == 'h' and fold_direction_v == 'v':\n            return fold_line_h, fold_line_v\n        elif fold_direction_h == 'h':\n            return fold_line_h, ''\n        else:\n            return '', fold_line_v\n\n    n, m = map(int, stdin.split()[:2])\n    image = stdin.split('\\n')[2:]\n    fold_line_h, fold_line_v = find_fold_line(image)\n    r1, c1 = count_fold_pixels(fold_line_h, 'h') if fold_line_h else (1, 1)\n    r2, c2 = count_fold_pixels(fold_line_v, 'v') if fold_line_v else (n, m)\n    return f\"{r1} {c1} {r2} {c2}\" "
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_fold_horizontal(image: list[str]) -> bool:\n        for row in image:\n            if '#' in row:\n                return False\n        return True\n\n    def is_fold_vertical(image: list[str]) -> bool:\n        for row in image:\n            if '#' in row:\n                return False\n        return True\n\n    def is_fold_diagonal(image: list[str], fold_line: int) -> bool:\n        for i in range(fold_line + 1):\n            if '#' in image[i]:\n                return False\n        return True\n\n    def get_fold_line(image: list[str]) -> tuple[int, int, int, int]:\n        for i in range(len(image[0])):\n            if image[0][i] == '#':\n                return i, 0, i, len(image[0])\n        return 0, 0, len(image[0]), len(image[0])\n\n    def find_fold(image: list[str]) -> tuple[int, int, int, int]:\n        fold_line = -1\n        fold_type = 0\n\n        if is_fold_horizontal(image):\n            fold_line, start, end, fold_type = get_fold_line(image)\n\n        if is_fold_vertical(image):\n            start, fold_line, end, fold_type = get_fold_line(image)\n\n        if is_fold_diagonal(image, fold_line):\n            start, fold_line, end, fold_type = get_fold_line(image)\n\n        return start, fold_line, end, fold_type\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[0:2])\n        image = [stdin.split()[i:i+m] for i in range(1, n*m+1, m)]\n\n        start, fold_line, end, fold_type = find_fold(image)\n\n        if fold_type == 0:\n            return \"No solution found.\"\n        elif fold_type == 1:\n            return f\"{start+1} {fold_line+1} {start+1} {end+1}\"\n        elif fold_type == 2:\n            return f\"{start+1} {start+1} {fold_line+1} {end+1}\"\n        else:\n            return f\"{start+1} {fold_line+1} {end+1} {end+1}\"\n\n    return main(stdin)"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_fold(image: str) -> str:\n        for i in range(len(image)):\n            if '#' in image[:i]:\n                continue\n            for j in range(len(image[i])):\n                if '#' in image[i][j:]:\n                    continue\n                if '#' in image[i+1:]:\n                    continue\n                if '#' in ''.join([line[j] for line in image[i+1:]]):\n                    continue\n                if '#' in ''.join([line[j] for line in image[:i]]):\n                    continue\n                return f'{i+1} {j+1}'\n        return None\n\n    def fold_h(image: str, fold: int) -> str:\n        return ''.join([image[i][:fold], '#'*(fold-len(image[i])+len(image[i][:fold])), '#'*(fold-len(image[i]))] + [image[i][fold:]])\n\n    def fold_v(image: str, fold: int) -> str:\n        return ''.join(['#'*(fold-len(image[:i])+len(image[i])) + image[i][:fold] + '#'*(fold-len(image[i])) for i in range(len(image))])\n\n    def fold_d(image: str, fold: int) -> str:\n        return ''.join(['#'*(fold-len(image[:i])+len(image[i])) + image[i][:fold] + '#'*(fold-len(image[i])) for i in range(len(image))])\n\n    def find_min_fold(image: str, folds: list) -> str:\n        min_coords = [float('inf'), float('inf'), float('inf'), float('inf')]\n        for fold in folds:\n            for i, coord in enumerate(fold.split()):\n                min_coords[i] = min(min_coords[i], int(coord))\n        return f'{min_coords[0]} {min_coords[1]} {min_coords[2]} {min_coords[3]}'\n\n    n, m = map(int, stdin.split()[:2])\n    image = stdin.split('\\n')[1:]\n    folds = []\n    for i in range(n):\n        for j in range(m):\n            if image[i][j] == '.':\n                folds.append(find_fold(image))\n                if folds[-1] is not None:\n                    if image[i][j+1] == '#':\n                        image = fold_h(image, int(folds[-1].split()[1]))\n                    elif image[i+1][j] == '#':\n                        image = fold_v(image, int(folds[-1].split()[0]))\n                    else:\n                        image = fold_d(image, int(folds[-1].split()[0]))\n                break\n        if folds[-1] is not None:\n            break\n\n    if folds[-1] is not None:\n        return find_min_fold(image, folds)\n    else:\n        return 'No solution'"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, m = map(int, input_data[0].split())\n    image = input_data[1:]\n\n    # Find the fold position\n    fold_positions = set()\n    for i in range(n):\n        for j in range(m):\n            if image[i][j] == '#':\n                fold_positions.add((i, j))\n\n    # Find the edge positions\n    left_edge = min(fold_positions, key=lambda x: x[1])[1]\n    right_edge = max(fold_positions, key=lambda x: x[1])[1]\n    top_edge = min(fold_positions, key=lambda x: x[0])[0]\n    bottom_edge = max(fold_positions, key=lambda x: x[0])[0]\n\n    # Find the fold position\n    fold_positions.remove((top_edge, left_edge))\n    fold_positions.remove((bottom_edge, right_edge))\n    fold_position = fold_positions.pop()\n\n    # Find the fold direction\n    if fold_position[0] == top_edge or fold_position[0] == bottom_edge:\n        if fold_position[1] < left_edge:\n            return f\"{fold_position[0] + 1} {fold_position[1] + 1} {fold_position[0] + 1} {right_edge}\"\n        else:\n            return f\"{fold_position[0] + 1} {left_edge} {fold_position[0] + 1} {fold_position[1] + 1}\"\n    else:\n        if fold_position[0] < top_edge:\n            return f\"{top_edge} {left_edge} {fold_position[0] + 1} {right_edge}\"\n        else:\n            return f\"{bottom_edge} {left_edge} {fold_position[0] + 1} {right_edge}\""
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_fold(n: int, m: int, image: str) -> str:\n        def is_fold_horizontal(fold_index: int) -> bool:\n            return all(image[fold_index][j] == '#' for j in range(m))\n\n        def is_fold_vertical(fold_index: int) -> bool:\n            return all(image[i][fold_index] == '#' for i in range(n))\n\n        def is_fold_diagonal(fold_index: int) -> bool:\n            i = 0\n            while i < n and image[i][fold_index] == '#':\n                i += 1\n            j = fold_index\n            while j < m and image[i][j] == '#':\n                j += 1\n            return i, j\n\n        def find_fold_index(image: str) -> int:\n            for i in range(n):\n                if is_fold_horizontal(i) or is_fold_vertical(i) or is_fold_diagonal(i):\n                    return i\n            raise ValueError(\"No fold found.\")\n\n        fold_index = find_fold_index(image)\n        fold_line = image[fold_index]\n        if is_fold_horizontal(fold_index):\n            return min(fold_index, n - 1), fold_index, max(fold_index, 0), fold_line.find('.')\n        elif is_fold_vertical(fold_index):\n            return fold_line.find('.'), min(fold_index, m - 1), fold_line.rfind('.'), max(fold_index, 0)\n        else:\n            i, j = is_fold_diagonal(fold_index)\n            return min(i, n - 1), min(j, m - 1), max(i, 0), max(j, 0)\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[:2])\n        image = stdin.split('\\n')[1:]\n        image = '\\n'.join(image)\n        r1, c1, r2, c2 = get_fold(n, m, image)\n        return f\"{r1} {c1} {r2} {c2}\"\n\n    return main(stdin)"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_fold(image: str, n: int, m: int) -> str:\n        def find_first_coord(fold_axis: str, image: str, n: int, m: int) -> int:\n            if fold_axis == 'h':\n                return 1 if '.' in image[:n] else n\n            elif fold_axis == 'v':\n                return 1 if '.' in ''.join(image[i][:m] for i in range(n)) else n\n            elif fold_axis == 'd':\n                return 1 if '.' in ''.join(image[i][m-j-1] for j in range(m) if i < n/2) else n\n            else:\n                return 1 if '.' in ''.join(image[i][m-j-1] for j in range(m) for i in range(n)) else n\n\n        def find_second_coord(fold_axis: str, image: str, n: int, m: int) -> int:\n            if fold_axis == 'h':\n                return m if '.' in image[:n] else m-1\n            elif fold_axis == 'v':\n                return m if '.' in ''.join(image[i][:m] for i in range(n)) else m-1\n            elif fold_axis == 'd':\n                return m if '.' in ''.join(image[i][m-j-1] for j in range(m) if i < n/2) else m-1\n            else:\n                return m if '.' in ''.join(image[i][m-j-1] for j in range(m) for i in range(n)) else m-1\n\n        best_fold = 'h'\n        best_first_coord = find_first_coord(best_fold, image, n, m)\n        best_second_coord = find_second_coord(best_fold, image, n, m)\n        for fold_axis in ['h', 'v', 'd']:\n            first_coord = find_first_coord(fold_axis, image, n, m)\n            second_coord = find_second_coord(fold_axis, image, n, m)\n            if first_coord < best_first_coord or (first_coord == best_first_coord and second_coord < best_second_coord):\n                best_fold = fold_axis\n                best_first_coord = first_coord\n                best_second_coord = second_coord\n        return (best_first_coord, best_second_coord)\n\n    def split_image(image: str, n: int, m: int, fold_axis: str) -> Tuple[str, str]:\n        if fold_axis == 'h':\n            left_image = image[:n]\n            right_image = ''.join(image[i][:m-1] + '#' for i in range(n))\n        elif fold_axis == 'v':\n            left_image = ''.join(image[i][:m] for i in range(n))\n            right_image = ''.join(image[i][:m-1] + '#' for i in range(n))\n        elif fold_axis == 'd':\n            left_image = ''.join(image[i][m-j-1] for j in range(m) for i in range(n/2))\n            right_image = ''.join(image[i][m-j-1] for j in range(m) for i in range(n/2, n))\n        else:\n            left_image = ''.join(image[i][m-j-1] for j in range(m) for i in range(n))\n            right_image = ''.join(image[i][m-j-1] for j in range(m) for i in range(n))\n        return (left_image, right_image)\n\n    def find_fold_coordinates(left_image: str, right_image: str, n: int, m: int) -> Tuple[int, int, int, int]:\n        left_fold_axis, right_fold_axis = 'h', 'h'\n        left_fold_coord, right_fold_co"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    pokeballs = 100\n    pokeballs_spent = 0\n    pokeballs_left = pokeballs\n    total_pokeballs_spent = 0\n\n    for i in range(int(N)):\n        if pokeballs_left == 0:\n            pokeballs_left = pokeballs\n            pokeballs_spent += 5 * pokeballs\n            total_pokeballs_spent += 5 * pokeballs\n\n        catch_probability = pokeballs_left / pokeballs\n        if random.random() < catch_probability * P:\n            pokeballs_left -= 1\n        else:\n            pokeballs_left = 0\n\n    pokeballs_spent += pokeballs_left * 5\n    total_pokeballs_spent += pokeballs_left * 5\n\n    return total_pokeballs_spent"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    return \"{:.9f}\".format(100 * (N * (P * (1 - P) ** N) + 5))\n\n\ninput_cases = [\n    \"50 0.125\",\n    \"201 1.000\",\n]\n\noutput_cases = [\n    \"16.339203308\",\n    \"5.000000000\",\n]\n\nfor i, case in enumerate(input_cases):\n    result = solution(case)\n    if round(float(result), 9) != round(float(output_cases[i]), 9):\n        raise Exception(f\"Failed case {i}: {case} -> {result} (expected {output_cases[i]})\")\n\nprint(\"All test cases passed!\") "
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    expected_pokeballs_spent = 100 * (N - 1) + 5 * (N - 1) // 10  # number of Pokeballs spent\n    expected_money_spent = expected_pokeballs_spent * 5 / 100  # money spent in dollars\n    return \"{:.10f}\".format(expected_money_spent)"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    P = round(P, 3)\n    total_pokeballs = 100\n    expected_pokeballs = 100\n    initial_pokeballs = 100\n    spent_money = 0\n    for i in range(int(N)):\n        if i % 100 == 0:\n            total_pokeballs += 5\n            spent_money += 5\n        if i % expected_pokeballs == 0:\n            if initial_pokeballs >= expected_pokeballs:\n                initial_pokeballs -= expected_pokeballs\n            else:\n                initial_pokeballs = 0\n                spent_money += 5\n        if i % expected_pokeballs == 0 and i % 100 == 0:\n            total_pokeballs += 5\n            spent_money += 5\n        if initial_pokeballs == 0:\n            continue\n        if i % expected_pokeballs == 0:\n            initial_pokeballs = 0\n        initial_pokeballs -= 1\n        if random.random() <= P:\n            initial_pokeballs += 1\n    return f\"{spent_money:.10f}\""
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    expected_money = 5 * 100 * (N + 1) + 5 * (N - 1)\n    return str(expected_money)"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    P_3 = P * 1000  # Convert to milliseconds\n    p = 1 - P\n    p_3 = p * 1000\n\n    expected_amount_of_money = 0\n    expected_balls = 0\n\n    for i in range(1, N + 1):\n        expected_balls += 1 / p_3\n        expected_balls_rounded_down = int(expected_balls)\n\n        if i == N:\n            expected_amount_of_money += expected_balls_rounded_down * 100 * 5\n        else:\n            expected_balls_after_next_pokemon = expected_balls + (1 / P_3)\n            expected_balls_after_next_pokemon_rounded_down = int(expected_balls_after_next_pokemon)\n            expected_amount_of_money += (expected_balls_rounded_down * 100 * 5) + (expected_balls_after_next_pokemon_rounded_down * 100 * 5)\n\n    return round(expected_amount_of_money, 9)"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    def expected_pokeballs_spent(N: int, P: float) -> float:\n        total_pokeballs_spent = 0\n        for i in range(1, N+1):\n            if i % 100 == 0:\n                total_pokeballs_spent += 100 * (1 - P) + 100\n            else:\n                total_pokeballs_spent += 100 * (1 - P) + 1\n        return total_pokeballs_spent\n\n    expected_money_spent = expected_pokeballs_spent(N, P) * 5\n    return f\"{expected_money_spent:.10f}\"\n\ninput_str = \"50 0.125\\n201 1.000\"\noutput_str = \"\"\nfor line in input_str.split(\"\\n\"):\n    N, P = map(float, line.split())\n    output_str += solution(line) + \"\\n\"\n\nprint(output_str)"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    E = 10**6\n    E_inv = 1/E\n    # Initialize variables\n    total_spent = 0\n    pokeballs = 100\n    pokeballs_needed = 1\n    current_pokeballs = pokeballs\n    money_spent_for_pokeballs = 0\n    \n    for i in range(N):\n        if i == 0:\n            # First Pokemon, need to buy pokeballs\n            total_spent += 5\n            current_pokeballs = 100\n            pokeballs_needed = 1\n            money_spent_for_pokeballs = 5\n        else:\n            # Check if we have enough pokeballs\n            if current_pokeballs >= pokeballs_needed:\n                # If we have enough pokeballs, keep throwing them until we catch the Pokemon\n                while current_pokeballs >= pokeballs_needed:\n                    current_pokeballs -= pokeballs_needed\n                    pokeballs_needed = 1\n                    if random.random() <= P:\n                        # We caught the Pokemon, stop here\n                        break\n                    else:\n                        # Keep throwing pokeballs\n                        pokeballs_needed += 1\n                else:\n                    # We ran out of pokeballs, go to the Pokeshop\n                    total_spent += money_spent_for_pokeballs\n                    current_pokeballs = 100\n                    pokeballs_needed = 1\n                    money_spent_for_pokeballs = 5\n            else:\n                # We ran out of pokeballs, go to the Pokeshop\n                total_spent += money_spent_for_pokeballs\n                current_pokeballs = 100\n                pokeballs_needed = 1\n                money_spent_for_pokeballs = 5\n    \n    # Calculate the expected amount of money spent\n    expected_money_spent = (total_spent + (money_spent_for_pokeballs * current_pokeballs)) * E_inv\n    return round(expected_money_spent, 10)"
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.split())\n    if N > 10**9 or N < 1 or P < 0 or P > 1:\n        return \"Invalid input\"\n    \n    money_spent = 0\n    pokeballs_left = 100\n    \n    for i in range(int(N)):\n        if pokeballs_left > 0:\n            money_spent += 5\n            pokeballs_left -= 1\n        else:\n            money_spent += 5\n            pokeballs_left = 100\n    \n    return f\"{money_spent:.9f}\""
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    expected_money_spent = N * 5 * (1 - P) + (1 - (1 - P) ** 100) * 5\n    return str(expected_money_spent)"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[0].split())\n    probabilities = [float(stdin.split()[i+1]) for i in range(v-1)]\n    ballots = [int(stdin.split()[i+1+v-1]) for i in range(v-1)]\n    ballots.append(0)\n\n    # Calculate expected number of positions for each candidate\n    def expected_positions(ballots):\n        total_ballots = sum(ballots)\n        candidates = [0, 0]\n        for i in range(k):\n            if total_ballots & (1 << i) != 0:\n                candidates[1] += 1\n            else:\n                candidates[0] += 1\n        return candidates[1]\n\n    # Calculate maximum expected number of positions for Yraglac\n    def max_positions(ballots):\n        max_ballots = ballots.copy()\n        max_ballots[v-1] = 0\n        max_ballots[v-2] = 0\n        max_ballots[v-3] = 0\n        for i in range(k):\n            if max_ballots[v-1] & (1 << i) != 0:\n                max_ballots[v-2] |= 1 << i\n            else:\n                max_ballots[v-3] |= 1 << i\n        return expected_positions(max_ballots)\n\n    # Calculate expected number of positions for each candidate\n    candidates = [expected_positions(ballots)]\n    for i in range(v-1):\n        new_ballots = ballots.copy()\n        new_ballots[i] += 1\n        candidates.append(expected_positions(new_ballots))\n\n    # Calculate the maximum expected number of positions for Yraglac\n    max_positions = candidates[0]\n    for i in range(1, v):\n        if candidates[i] > max_positions:\n            max_positions = candidates[i]\n\n    # Find the ballot that maximizes the expected number of positions for Yraglac\n    optimal_ballot = 0\n    for i in range(1, 2**k):\n        if expected_positions(ballots + [i]) > max_positions:\n            optimal_ballot = i\n\n    return str(optimal_ballot)"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[0:2])\n    p = []\n    b = []\n\n    for i in range(v - 1):\n        p_i, b_i = map(int, stdin.split()[2 + i:4 + i])\n        p.append(p_i)\n        b.append(b_i)\n\n    total_p = sum(p)\n    p_notnomde = 1 - total_p\n    p_yraglac = total_p\n\n    max_yraglac_positions = 0\n    for b_i in range(2 ** k):\n        expected_yraglac_positions = 0\n        for i in range(v - 1):\n            if b_i & (1 << (k - 1 - i)) > 0:\n                expected_yraglac_positions += p_yraglac\n            else:\n                expected_yraglac_positions += p_notnomde\n        max_yraglac_positions = max(max_yraglac_positions, expected_yraglac_positions)\n\n    max_b_yraglac = 0\n    for b_i in range(2 ** k):\n        if max_yraglac_positions == expected_yraglac_positions(b_i):\n            max_b_yraglac = b_i\n            break\n\n    return str(max_b_yraglac)\n"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    k = int(input_list[0].split()[0])\n    v = int(input_list[0].split()[1])\n    probabilities = []\n    ballots = []\n    for i in range(1, v):\n        prob, num_ballots = map(int, input_list[i].split())\n        probabilities.append(prob)\n        ballots.append(num_ballots)\n\n    def expected_positions(ballots):\n        total_ballots = sum(ballots)\n        positions = [0] * k\n        for i, bit in enumerate(ballots):\n            for j in range(k):\n                positions[j] += bit & 1 << (k - 1 - j)\n        return sum(p * pos for p, pos in zip(probabilities, positions)) / total_ballots\n\n    max_ballots = -1\n    max_positions = -1\n    for i in range(2**k):\n        ballots[v - 1] = i\n        if sum(ballots) > 0 and max_ballots < sum(ballots):\n            max_ballots = sum(ballots)\n            max_positions = expected_positions(ballots)\n\n    return str(max_ballots)"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    k, v = map(int, input_list[0].split())\n    probabilities = [float(input_list[i+1].split()[0]) for i in range(v-1)]\n    ballots = [int(input_list[i+1].split()[1]) for i in range(v-1)]\n    \n    def expected_positions(b):\n        total_positions = 0\n        for i in range(v):\n            if probabilities[i] == 1 or random.random() < probabilities[i]:\n                total_positions += 1 if (b >> (k-1)) & 1 == 0 else 0\n        return total_positions\n    \n    max_ballots = 0\n    max_positions = 0\n    for b in range(1, 2**k):\n        positions = expected_positions(b)\n        if positions > max_positions:\n            max_ballots = b\n            max_positions = positions\n            \n    return str(max_ballots)"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[:2])\n    p = [float(line.split()[0]) for line in stdin.split('\\n')[1:-1]]\n    b = [int(line.split()[1]) for line in stdin.split('\\n')[1:-1]]\n    \n    max_expectation = -1\n    max_ballots = 0\n    \n    for i in range(2 ** k):\n        expectation = sum(p[j] for j in range(v) if i & (1 << j))\n        if expectation == 0:\n            continue\n        \n        total_ballots = sum(b[j] for j in range(v) if i & (1 << j))\n        positions = bin(total_ballots).count('1')\n        expectation *= positions\n        \n        if expectation > max_expectation:\n            max_expectation = expectation\n            max_ballots = i\n            \n    return bin(max_ballots)[2:].count('1')"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[0].split())\n    p_i = [float(line.split()[0]) for line in stdin.split('\\n')[1:-1]]\n    b_i = [int(line.split()[1]) for line in stdin.split('\\n')[1:-1]]\n\n    # Calculate the expected number of positions held by Yraglac for each ballot\n    expect_pos = [sum([(b_i[i] >> j) & 1 for i in range(v)]) * p_i[i] for j in range(k) for i in range(v)]\n\n    # Find the maximum expected number of positions held by Yraglac\n    max_expect = max(expect_pos)\n\n    # Find the ballot that achieves the maximum expected number of positions held by Yraglac\n    ballot = 0\n    for i in range(v):\n        for j in range(k):\n            if expect_pos[j] == max_expect:\n                ballot += (1 << j) * p_i[i]\n\n    return bin(int(ballot))[2:].zfill(k)\n\ndef"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[0:2])\n    p = [float(stdin.split()[2*i+1]) for i in range(v-1)]\n    b = [int(stdin.split()[2*i+2]) for i in range(v-1)]\n\n    def count_positions(total_ballots):\n        positions = [0] * k\n        for i in range(v):\n            positions[total_ballots & 1] += p[i]\n            total_ballots >>= 1\n        return positions\n\n    min_positions = count_positions(0)\n    max_positions = count_positions((1 << k) - 1)\n\n    for b_v in range((1 << k) - 1, -1, -1):\n        positions = count_positions(b_v)\n        if sum(positions) > sum(min_positions):\n            break\n        min_positions = min(min_positions, positions)\n\n    return str(b_v)\n"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    k, v = map(int, input_data[0].split())\n    p = [float(x) for x in input_data[1:v]]\n    b = [int(x) for x in input_data[1+v:]]\n    \n    def count_positions(ballots):\n        binary = format(ballots, f'0{k}b')\n        return binary.count('1')\n    \n    def expected_positions(ballots):\n        total_ballots = sum(b)\n        return sum(count_positions(ballots + i) * p[i] for i in range(v)) * total_ballots\n    \n    best_ballots = 0\n    best_expectation = -1\n    \n    for ballots in range(2**k):\n        expectation = expected_positions(ballots)\n        if expectation > best_expectation:\n            best_ballots = ballots\n            best_expectation = expectation\n    \n    return best_ballots"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[0:2])\n    p_and_b = [map(int, line.split()) for line in stdin.split(\"\\n\")[1:]]\n    p = [pi for pi, bi in p_and_b]\n    b = [bi for pi, bi in p_and_b]\n    \n    def expected_positions(bi):\n        total_ballots = sum(bi)\n        return sum(bi[j] * (total_ballots - bi[j]) for j in range(k)) // (total_ballots * (2 ** k - 1) // 2)\n\n    best_bi = [0] * v\n    for i in range(v):\n        if p[i] > 0:\n            best_bi[i] = b[i]\n    \n    max_positions = expected_positions(best_bi)\n    for bi in itertools.product(range(2 ** k), repeat=v):\n        if any(bi[i] > best_bi[i] for i in range(v)):\n            continue\n        if any(bi[i] < best_bi[i] for i in range(v)):\n            continue\n        \n        positions = expected_positions(bi)\n        if positions > max_positions:\n            max_positions = positions\n            best_bi = bi\n    \n    return sum(best_bi)"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_expected_positions(ballots: int, p_i: float, yraglac_wins: int) -> float:\n        return (ballots >> yraglac_wins) & 1\n\n    k, v = map(int, stdin.split()[:2])\n    p_i_b_i = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    p_i_b_i.sort(key=lambda x: x[0], reverse=True)\n\n    total_ballots = 0\n    for p_i, b_i in p_i_b_i:\n        total_ballots += b_i * 2**k * p_i\n\n    expected_positions = [calculate_expected_positions(total_ballots, p_i, yraglac_wins) for yraglac_wins in range(k)]\n    max_positions = max(expected_positions)\n    max_positions_index = expected_positions.index(max_positions)\n\n    return bin(1 << k)[2:]\n\n\ndef"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    A = [int(x) for x in input_data[1].split()]\n    B = [int(x) for x in input_data[2].split()]\n\n    total_kilos = sum(A)\n    B = sorted(B, reverse=True)\n    ham_per_person = [total_kilos * b / sum(B) for b in B]\n\n    if sorted(ham_per_person) != ham_per_person:\n        return \"-1\"\n\n    total_ham = sum(ham_per_person)\n    return round(total_ham, 12)\n"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def ceil_division(x: int, y: int) -> int:\n        return -(x // -y)\n\n    N, *lines = stdin.splitlines()\n    N = int(N)\n    A = [0] * N\n    B = [0] * N\n    for i in range(N):\n        A[i], B[i] = map(int, lines[i].split())\n\n    total_kilos = sum(A)\n    total_meat_kilos = total_kilos - sum(A)\n    total_ham_kilos = total_meat_kilos * 10\n    total_ham_kilos_per_person = total_ham_kilos / N\n    max_ham_kilos_per_person = ceil_division(total_ham_kilos, N)\n\n    if max_ham_kilos_per_person == 0:\n        return -1\n\n    max_ham_kilos = max_ham_kilos_per_person * N\n    ham_kilos_per_person = [0] * N\n    for i in range(N):\n        ham_kilos_per_person[i] = max_ham_kilos_per_person * B[i]\n\n    ham_kilos_per_person = sorted(ham_kilos_per_person)\n    ham_kilos = sum(ham_kilos_per_person)\n\n    return ham_kilos\n"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    a = [int(x.split()[0]) for x in input_data[1:n+1]]\n    b = [int(x.split()[1]) for x in input_data[1:n+1]]\n    total_k = sum(a)\n    \n    if not (sum(b) * 10**12 >= total_k and total_k >= sum(b) * 10**12):\n        return \"-1\"\n    \n    p = [0] * n\n    for i in range(n):\n        p[i] = a[i] * 10**12 // sum(b)\n        a[i] -= p[i]\n    \n    ham_left = sum(p)\n    ham_count = 0\n    \n    for i in range(n):\n        if ham_left >= b[i]:\n            ham_left -= b[i]\n            ham_count += b[i]\n        else:\n            ham_count += ham_left\n            break\n    \n    ham_count = ham_count / 10**12\n    return ham_count"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    A = [0] * N\n    B = [0] * N\n    for i in range(N):\n        A[i], B[i] = map(int, input_data[i+1].split())\n\n    # Check if the order can be achieved\n    if B.count(0) == 1:\n        k = B.index(0)\n        if A.count(A[k] * N) == 1:\n            return A[k] * N\n    return -1"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    A = [int(x) for x in input_lines[1].split()]\n    B = [int(x) for x in input_lines[2].split()]\n\n    if sum(A) < sum(B):\n        return \"-1\"\n\n    total_kilos = sum(A)\n    total_ham = sum(B)\n    min_ham_per_person = total_ham / N\n    min_kg_per_person = 0\n\n    for i in range(N):\n        min_kg_per_person = max(min_kg_per_person, min_ham_per_person * B[i])\n\n    max_kg_per_person = min_kg_per_person\n    for i in range(N):\n        max_kg_per_person = max(max_kg_per_person, min_ham_per_person * B[i])\n\n    return round(max_kg_per_person, 12)\n"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    A = [0] * N\n    B = [0] * N\n    for i in range(N):\n        A[i], B[i] = map(int, stdin[i+1].split())\n    \n    # Find the total amount of meat eaten\n    total_kilos = sum(A)\n    \n    # If the total amount of meat is 0, it's impossible to achieve the required order\n    if total_kilos == 0:\n        return \"-1\"\n    \n    # Calculate the proportion of ham for each person\n    proportion_of_ham = [b/total_kilos for b in B]\n    \n    # Sort the people by their proportion of ham\n    sorted_people = sorted(range(N), key=lambda k: proportion_of_ham[k], reverse=True)\n    \n    # Calculate the required amount of ham in kilos\n    required_ham = sum([A[sorted_people[i]] * B[sorted_people[i]] for i in range(N)])\n    \n    # Check if the required order can be achieved\n    if sorted(sorted_people) != list(range(1, N+1)):\n        return \"-1\"\n    \n    return required_ham"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    A = list(map(int, stdin.split(\"\\n\")[1:N]))\n    B = list(map(int, stdin.split(\"\\n\")[N+1:]))\n    min_k = float('inf')\n    max_k = 0\n    for i in range(N):\n        min_k = min(min_k, A[i])\n        max_k = max(max_k, A[i])\n    if min_k > 0:\n        return -1\n    total_meat = sum(A)\n    total_ham = 0\n    for i in range(N):\n        total_ham += A[i] * B[i] / total_meat\n    return total_ham\n\ndef"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    A = [int(x) for x in input_data[1].split()]\n    B = [int(x) for x in input_data[2].split()]\n\n    if sum(A) < sum(B) or (sum(A) == sum(B) and B.index(max(B)) < A.index(max(A))):\n        return -1\n\n    total_weight = sum(A)\n    total_ham = sum(B)\n    ham_per_person = total_ham / N\n\n    cumulative_weight = 0\n    for i in range(N):\n        cumulative_weight += A[i]\n        total_ham -= B[i] * ham_per_person\n\n    total_ham += total_weight * ham_per_person / sum(A)\n\n    return round(total_ham, 12)\n"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    A, B = [], []\n    for i in range(1, N+1):\n        a, b = map(int, input_data[i].split())\n        A.append(a)\n        B.append(b)\n    \n    if all(b == 0 for b in B):\n        return \"-1\"\n    \n    total_kgs = sum(A)\n    ham_amount = total_kgs / sum(B)\n    \n    return round(ham_amount, 12)"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_ham(N: int, A: list, B: list) -> float:\n        if sum(B) == 0:\n            return -1\n\n        total_meat = sum(A)\n        ham_total = sum(B)\n        total_ham = 0\n\n        for i in range(N):\n            total_ham += B[i] * (A[i] / total_meat) * ham_total\n\n        return total_ham\n\n    N, *stdin = stdin.split()\n    N = int(N)\n    A = [int(stdin[i]) for i in range(0, N * 2, 2)]\n    B = [int(stdin[i]) for i in range(1, N * 2, 2)]\n\n    result = calculate_ham(N, A, B)\n    return str(result)"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, P = map(float, input_data.pop(0).split())\n    boxes = [list(map(float, line.split())) for line in input_data]\n    \n    min_energy = float('inf')\n    for i in range(N):\n        energy, prob = boxes[i]\n        if prob >= P:\n            min_energy = min(min_energy, energy)\n            break\n        min_energy = min(min_energy, energy + min_energy)\n    \n    return str(min_energy)\n\ninput_data = '''2 0.5\n2 0.5\n1 0.5'''\n\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, P = map(float, input_list.pop(0).split())\n    boxes = []\n    \n    for _ in range(int(N)):\n        energy, probability = map(float, input_list.pop(0).split())\n        boxes.append((energy, probability))\n    \n    total_probability = sum(box[1] for box in boxes)\n    energy_wasted = 0\n    \n    for box in boxes:\n        if total_probability >= P:\n            energy_wasted += box[0]\n        else:\n            total_probability += box[1]\n    \n    return str(energy_wasted)"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, P = map(float, input_list.pop(0).split())\n    energy = []\n    probability = []\n    for _ in range(int(N)):\n        e, p = map(float, input_list.pop(0).split())\n        energy.append(int(e))\n        probability.append(p)\n    \n    # Initialize variables\n    min_energy = 0\n    current_probability = 0\n    \n    # Find the minimum energy to find Polly with at least probability P\n    for i in range(len(energy)):\n        min_energy += energy[i]\n        current_probability += probability[i]\n        \n        if current_probability >= P:\n            break\n    \n    return str(min_energy)\n\ndef"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    N, P = map(float, inputs[0].split())\n    energy_probabilities = [map(float, inputs[i+1].split()) for i in range(int(N))]\n\n    # Calculate the total probability of finding the parrot\n    total_probability = 0\n    for e, p in energy_probabilities:\n        total_probability += p\n\n    # Calculate the energy wasted to find the parrot\n    energy_wasted = 0\n    for e, p in energy_probabilities:\n        energy_wasted += e * p / total_probability\n\n    # Calculate the minimum energy wasted\n    min_energy_wasted = energy_wasted\n    while min_energy_wasted > 0 and total_probability >= P:\n        min_energy_wasted -= 1\n        for i in range(int(N)):\n            if energy_probabilities[i][1] > 0:\n                energy_probabilities[i][1] *= min_energy_wasted / energy_probabilities[i][0]\n                total_probability *= min_energy_wasted / energy_probabilities[i][0]\n            else:\n                total_probability = 0\n                break\n    return int(min_energy_wasted)\n"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    boxes = []\n    for _ in range(N):\n        energy, probability = map(float, input().split())\n        boxes.append((energy, probability))\n\n    total_probability = sum(box[1] for box in boxes)\n    if total_probability < P:\n        return \"IMPOSSIBLE\"\n\n    minimum_energy = sum(box[0] for box in boxes if box[1] >= P)\n    return str(minimum_energy)\n"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_energy(p_i: float, e_i: int) -> int:\n        return round(p_i * e_i)\n\n    N, P = map(float, input().split())\n    boxes = []\n\n    for _ in range(int(N)):\n        e_i, p_i = map(float, input().split())\n        boxes.append((p_i, e_i))\n\n    boxes.sort(key=lambda x: x[0], reverse=True)\n    min_energy = 0\n\n    for p_i, e_i in boxes:\n        if p_i >= P:\n            min_energy += find_min_energy(p_i, e_i)\n        else:\n            break\n\n    return str(min_energy)\n"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    boxes = [list(map(float, input().split())) for _ in range(N)]\n    energy_wasted = 0\n    for box in boxes:\n        energy_wasted += box[0]\n        if box[1] >= P:\n            break\n    return str(energy_wasted)\n\ndef"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, stdin.splitlines()[0].split())\n    boxes = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n    boxes.sort(key=lambda x: x[1], reverse=True)\n    energy_wasted = 0\n    prob_sum = 0\n    \n    for box in boxes:\n        energy_wasted += box[0]\n        prob_sum += box[1]\n        \n        if prob_sum >= P:\n            return str(energy_wasted)\n        \n    return str(energy_wasted)"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def min_energy(prob: float, boxes: list) -> int:\n        energy_sum = sum(boxes[0])\n        if prob <= boxes[0][0]:\n            return energy_sum\n        else:\n            return min(energy_sum, min_energy(prob - boxes[0][0], boxes[1:]))\n\n    # Read input\n    lines = stdin.split('\\n')\n    N, P = map(float, lines[0].split())\n    boxes = [list(map(float, lines[1].split())) for _ in range(int(N))]\n\n    # Find minimum energy\n    result = min_energy(P, boxes)\n\n    # Return output\n    return str(result)"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, P = map(float, input_data[0].split())\n    boxes = [tuple(map(float, line.split())) for line in input_data[1:]]\n    boxes.sort(key=lambda x: x[1], reverse=True)\n    energy_wasted = 0\n    found_polly = False\n\n    for box in boxes:\n        energy_wasted += box[0]\n        if box[1] >= P:\n            found_polly = True\n            break\n\n    return str(energy_wasted) if found_polly else 'Impossible'\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:n+3]))\n    used_sockets = [0] * n\n    visited = [False] * n\n    adjacency_list = [[] for _ in range(n)]\n    \n    for _ in range(m):\n        u, v = map(int, stdin.split()[n+_:n+_+2])\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n        used_sockets[u] += 1\n        used_sockets[v] += 1\n    \n    def dfs(node: int, parent: int) -> bool:\n        visited[node] = True\n        for neighbor in adjacency_list[node]:\n            if neighbor == parent:\n                continue\n            if not visited[neighbor]:\n                if used_sockets[neighbor] + used_sockets[node] - 1 > c[node]:\n                    return False\n                if dfs(neighbor, node):\n                    return True\n        return True\n    \n    for i in range(n):\n        if not visited[i]:\n            if not dfs(i, -1):\n                return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, visited, queue, edges):\n        visited[start] = True\n        queue.append(start)\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if not visited[neighbor]:\n                    edges.append((current, neighbor))\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n    input_lines = stdin.splitlines()\n    n, m, k = map(int, input_lines[0].split())\n    c = list(map(int, input_lines[1].split()))\n    existing_connections = [(int(u), int(v)) for u, v in (input_lines[i].split() for i in range(2, 2 + m))]\n\n    # Create graph\n    graph = [[] for _ in range(n)]\n    for u, v in existing_connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Perform BFS to find shortest path between all pairs of vertices\n    visited = [False] * n\n    queue = []\n    for start in range(n):\n        bfs(graph, start, visited, queue, existing_connections)\n\n    # Check if adding edges would exceed k\n    count_edits = len(existing_connections)\n    for u, v in existing_connections:\n        for neighbor in graph[u]:\n            if neighbor == v:\n                continue\n            if neighbor not in [u2 for u1, u2 in existing_connections if u1 == u]:\n                count_edits += 1\n                if count_edits > k:\n                    return \"no\"\n                existing_connections.append((u, neighbor))\n                break\n        if count_edits > k:\n            return \"no\"\n\n    return \"yes\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, k = map(int, input_data[0].split())\n    c = list(map(int, input_data[1].split()))\n    existing_connections = [tuple(map(int, line.split())) for line in input_data[2:]]\n\n    # Build a graph representing the existing network architecture\n    graph = [[] for _ in range(n)]\n    for u, v in existing_connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Perform depth-first search from each server to check if it is connected to all others\n    visited = [False] * n\n    for i in range(n):\n        if not visited[i]:\n            if not dfs(graph, i, visited):\n                return \"no\"\n\n    # Check if adding at most k new connections can connect all servers\n    def bfs(u, visited, edges):\n        visited[u] = True\n        queue = [(u, u, 0)]\n        while queue:\n            u, v, depth = queue.pop(0)\n            if v == n - 1:\n                return True\n            for neighbor in graph[v]:\n                if not visited[neighbor]:\n                    queue.append((u, neighbor, depth + 1))\n                    if depth + 1 <= k:\n                        edges.append((u, neighbor))\n        return False\n\n    visited = [False] * n\n    edges = []\n    for i in range(n):\n        if not visited[i]:\n            if not bfs(i, visited, edges):\n                return \"no\"\n\n    # Build the final network by adding the edges\n    graph = [[] for _ in range(n)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    return \"yes\"\n\n\ndef"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_edits(graph: dict, connections: int, new_connections: int) -> int:\n        connected_servers = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                if i in graph[j] or j in graph[i]:\n                    connected_servers.add(i)\n                    connected_servers.add(j)\n        return len(connected_servers) + new_connections - connections\n\n    n, m, k = map(int, stdin.split())\n    capacities = list(map(int, input().split()))\n    graph = {i: set() for i in range(n)}\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].add(v)\n        graph[v].add(u)\n\n    connections = sum(len(graph[i]) for i in range(n)) // 2\n    new_connections = 0\n    for i in range(n):\n        new_connections += capacities[i]\n    new_connections //= 2\n\n    return \"yes\" if count_edits(graph, connections, new_connections) <= k else \"no\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    connections = [tuple(map(int, line.split())) for line in stdin.split('\\n')[2:m+2]]\n    sockets = list(map(int, stdin.split()[m+2:]))\n    \n    # Initialize adjacency matrix\n    adj_matrix = [[False for _ in range(n)] for _ in range(n)]\n    for u, v in connections:\n        adj_matrix[u][v] = True\n        adj_matrix[v][u] = True\n    \n    # Build connected components using DFS\n    def dfs(start):\n        visited = [False for _ in range(n)]\n        stack = [start]\n        while stack:\n            node = stack.pop()\n            if not visited[node]:\n                visited[node] = True\n                for neighbor in range(n):\n                    if adj_matrix[node][neighbor]:\n                        stack.append(neighbor)\n        return visited\n    \n    visited = dfs(0)\n    \n    # Check if all servers are connected\n    for i in range(n):\n        if not visited[i]:\n            return \"no\"\n    \n    # Check if the number of edits is sufficient\n    num_edits = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if adj_matrix[i][j] and not visited[i] and not visited[j]:\n                num_edits += 1\n                if num_edits > k:\n                    return \"no\"\n    \n    return \"yes\""
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, k = map(int, input_data[0].split())\n    capacities = list(map(int, input_data[1].split()))\n    existing_connections = []\n    for i in range(2, 2 + m):\n        u, v = map(int, input_data[i].split())\n        existing_connections.append((u, v))\n\n    # Create a graph representing the existing network architecture\n    graph = [[] for _ in range(n)]\n    for u, v in existing_connections:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Perform BFS from each server and mark visited nodes\n    visited = set()\n    for i in range(n):\n        if i not in visited:\n            queue = [(i, [i])]\n            while queue:\n                node, path = queue.pop(0)\n                if node in visited:\n                    continue\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        queue.append((neighbor, path + [neighbor]))\n\n    # Check if all nodes are visited\n    if len(visited) != n:\n        return \"no\"\n\n    # Count the number of edges needed to connect all servers\n    total_edges = 0\n    for i in range(n):\n        total_edges += len(graph[i])\n\n    # Calculate the maximum number of edges allowed\n    max_edges = k\n    for capacity in capacities:\n        max_edges -= capacity\n\n    if total_edges <= max_edges:\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, curr, target, visited, edges):\n        visited[curr] = True\n        if curr == target:\n            return True\n        for neighbor in graph[curr]:\n            if not visited[neighbor] and dfs(graph, neighbor, target, visited, edges):\n                return True\n        return False\n\n    n, m, k = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:n+3]))\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        u, v = map(int, stdin.split()[n+m:n+m*2+1:2])\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * n\n    count = 0\n    for i in range(n):\n        if not visited[i] and dfs(graph, i, i, visited, count):\n            count += 1\n            if count > k:\n                return \"no\"\n    return \"yes\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:3+n]))\n    u = []\n    v = []\n    for i in range(m):\n        u.append(int(stdin.split()[3+n+i]))\n        v.append(int(stdin.split()[4+n+i]))\n\n    def add_connection(u, v):\n        if u not in v_to_u:\n            v_to_u[u] = set()\n        if v not in u_to_v:\n            u_to_v[v] = set()\n        if v not in v_to_u[u]:\n            v_to_u[u].add(v)\n        if u not in u_to_v[v]:\n            u_to_v[v].add(u)\n\n    def remove_connection(u, v):\n        if u in v_to_u and v in v_to_u[u]:\n            v_to_u[u].remove(v)\n        if v in u_to_v and u in u_to_v[v]:\n            u_to_v[v].remove(u)\n\n    def check_connection(u, v):\n        if u == v:\n            return False\n        seen = set()\n        queue = [u]\n        while queue:\n            node = queue.pop(0)\n            if node in seen:\n                continue\n            seen.add(node)\n            if node == v:\n                return True\n            if node in v_to_u:\n                queue.extend(v_to_u[node])\n        return False\n\n    u_to_v = {}\n    v_to_u = {}\n\n    for i in range(m):\n        add_connection(u[i], v[i])\n\n    def dfs(node, seen):\n        if node in seen:\n            return False\n        seen.add(node)\n        for neighbor in u_to_v.get(node, set()):\n            if not dfs(neighbor, seen):\n                return False\n        return True\n\n    if dfs(0, set()):\n        return \"yes\"\n    else:\n        return \"no\"\n\ninput_data = '''4 5 2\n3 3 3 3\n0 1\n0 3\n1 3\n1 2\n2 3'''\n\nprint(solution(input_data)) "
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    capacities = list(map(int, stdin.split()[3:n+3]))\n    old_connections = [tuple(map(int, stdin.split()[i+n+3:i+n+5])) for i in range(m)]\n\n    if m > k:\n        return \"no\"\n\n    adjacency_list = [[] for _ in range(n)]\n    for u, v in old_connections:\n        adjacency_list[u].append(v)\n        adjacency_list[v].append(u)\n\n    def bfs(start, visited):\n        queue = [start]\n        visited[start] = True\n        while queue:\n            current = queue.pop(0)\n            for neighbor in adjacency_list[current]:\n                if not visited[neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    visited = [False] * n\n    bfs(0, visited)\n\n    return \"yes\" if all(visited) else \"no\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:n+3]))\n    adj = [[] for _ in range(n)]\n    \n    for i in range(m):\n        u, v = map(int, stdin.split()[n+i*2:n+(i+1)*2])\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    def bfs(start: int, visited: set, path: list, target: int) -> bool:\n        visited.add(start)\n        path.append(start)\n        if start == target:\n            return True\n        for v in adj[start]:\n            if v not in visited:\n                if bfs(v, visited, path, target):\n                    return True\n        return False\n\n    def dfs(start: int, visited: set, path: list, target: int) -> bool:\n        visited.add(start)\n        path.append(start)\n        if start == target:\n            return True\n        for v in adj[start]:\n            if v not in visited:\n                if dfs(v, visited, path, target):\n                    return True\n        for v in adj[start]:\n            if v not in visited:\n                path.pop()\n        return False\n\n    for i in range(n):\n        visited = set()\n        path = []\n        for j in range(n):\n            if i != j:\n                if bfs(i, visited, path, j):\n                    return \"yes\"\n        visited = set()\n        path = []\n        for j in range(n):\n            if i != j:\n                if dfs(i, visited, path, j):\n                    return \"yes\"\n    \n    return \"no\""
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    input_ring = [int(x) for x in input_list[1:N+1]]\n    \n    # Original ring is the sum of the three numbers in the second ring\n    original_ring = [input_ring[i] + input_ring[i-1] + input_ring[(i+1)%N] for i in range(N)]\n    \n    output = \"\\n\".join(map(str, original_ring))\n    return output"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    second_ring = [int(x) for x in input_list[1:N+1]]\n    \n    first_number = second_ring[0]\n    first_ring = [first_number]\n    second_ring = second_ring[1:]\n    \n    for i in range(N-1):\n        first_ring.append(second_ring[i]+first_ring[i])\n    \n    first_ring[0] = second_ring[N-1]\n    \n    return '\\n'.join(str(x) for x in first_ring)\n"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    input_ring = [int(x) for x in stdin.split('\\n')[1:N+1]]\n    output_ring = []\n    \n    for i in range(N):\n        output_ring.append(sum(input_ring[i:i+3]))\n    \n    output = '\\n'.join([str(x) for x in output_ring])\n    return output"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    ring_1 = [int(x) for x in input_data[1:N+1]]\n    ring_2 = [int(x) for x in input_data[N+1:]]\n    ring_1_sum = sum(ring_1)\n    ring_2_sum = sum(ring_2)\n\n    # Check if the two rings have the same sum\n    if ring_1_sum != ring_2_sum:\n        return \"No solution\"\n\n    # Calculate the difference between the two rings\n    diff = [abs(ring_1[i] - ring_2[i]) for i in range(N)]\n\n    # Find the index of the smallest difference\n    index = diff.index(min(diff))\n\n    # Calculate the new ring\n    new_ring = [ring_2[i] - ring_1[i] for i in range(N)]\n\n    # Check if the sum of the first three numbers is equal to the second number in the input ring\n    if sum(new_ring[:3]) != ring_1[index]:\n        return \"No solution\"\n\n    # Output the new ring\n    result = [str(x) for x in new_ring]\n    return '\\n'.join(result)"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    second_ring = [int(x) for x in stdin.splitlines()[1:]]\n    \n    first_ring = [0] * n\n    for i in range(n):\n        index = (i - 1) % n\n        if index == n - 1:\n            index = 0\n        index2 = (i + 1) % n\n        if index2 == 0:\n            index2 = n\n        \n        total = second_ring[i] + second_ring[index] + second_ring[index2]\n        first_ring[i] = total - second_ring[i]\n    \n    return '\\n'.join(str(x) for x in first_ring)"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N = int(input_data[0])\n    second_ring = list(map(int, input_data[1:]))\n\n    first_ring = [0] * N\n    for i in range(N):\n        if i > 0:\n            first_ring[i] = second_ring[i - 1] + second_ring[i]\n        if i < N - 1:\n            first_ring[i] = second_ring[i] + second_ring[i + 1]\n\n    # Check if the solution is valid\n    for i in range(1, N - 1):\n        if first_ring[i] != second_ring[i]:\n            return \"Invalid solution\"\n\n    return \"\\n\".join(map(str, first_ring))\n"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    input_list = input_list[1:]\n    second_ring = [int(i) for i in input_list]\n\n    def create_new_ring(ring: list) -> list:\n        return [ring[i] + ring[(i - 1) % n] + ring[(i + 1) % n] for i in range(n)]\n\n    first_ring = create_new_ring(second_ring)\n\n    result = []\n    for i in range(n):\n        min_index = first_ring.index(min(first_ring))\n        result.append(first_ring[min_index])\n        first_ring[min_index] = float('inf')\n\n    return '\\n'.join([str(i) for i in result])\n"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(ring: list) -> list:\n        return [ring[-1]] + ring[:-1]\n\n    N, *ring = map(int, stdin.split())\n    ring_size = len(ring)\n    new_ring = [a + b + c for a, b, c in zip(ring, rotate(ring), rotate(rotate(ring)))]\n\n    for i in range(ring_size):\n        if sum(new_ring[i:i + 3]) == ring[i]:\n            return \"\\n\".join(map(str, ring))\n\n    return \"No solution found\"\n"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    input_list = input_list[1:]\n    input_list = list(map(int, input_list))\n    \n    first_number = input_list[0]\n    second_number = input_list[1]\n    third_number = input_list[2]\n    total = first_number + second_number + third_number\n    \n    output_list = []\n    for i in range(N):\n        if i == 0:\n            output_list.append(second_number - total)\n        elif i == 1:\n            output_list.append(third_number - total)\n        elif i == N - 1:\n            output_list.append(first_number - total)\n        else:\n            next_number = input_list[i] + input_list[i - 1] + input_list[i + 1] - total\n            output_list.append(next_number)\n            \n    result = '\\n'.join(map(str, output_list))\n    return result\n\ndef"
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    ring = [int(x) for x in stdin.splitlines()[1:]]\n    ring2 = [(x + ring[i-1] + ring[(i+1)%N]) % 1000000000 for i, x in enumerate(ring)]\n    \n    result = [0] * N\n    result[0] = (ring2[0] - ring[0]) % 1000000000\n    for i in range(1, N):\n        result[i] = (ring2[i] - result[i-1] - ring[i]) % 1000000000\n    \n    return '\\n'.join(str(x) for x in result)\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    commands = stdin.splitlines()[1:]\n    command_history = []\n    current_command = \"\"\n\n    for command in commands:\n        if \"^\" in command:\n            up_presses = command.count(\"^\")\n            for _ in range(up_presses):\n                if command_history:\n                    current_command = command_history.pop()\n        else:\n            current_command += command\n            command_history.append(current_command)\n\n    return \"\\n\".join(command_history)\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    commands = stdin.split('\\n')\n    n = int(commands[0])\n    history = []\n    result = []\n    \n    for i in range(1, len(commands)):\n        command = ''\n        for j in range(len(commands[i])):\n            if commands[i][j] == '^':\n                if len(history) > 0:\n                    command = history[-1]\n            else:\n                command += commands[i][j]\n        if command != '':\n            history.append(command)\n            result.append(command)\n        else:\n            if history:\n                history.pop()\n    \n    return '\\n'.join(result)\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    input_lines = stdin[1:].split(\"\\n\")\n    command_history = []\n\n    for line in input_lines:\n        input_command = line.split()\n        up_count = input_command.count(\"^\")\n        non_up_command = \" \".join([word for word in input_command if word != \"^\"])\n\n        # Remove the up characters from the command\n        command_history.append(non_up_command)\n\n        # Auto complete the command using the previous commands\n        if up_count > 0:\n            index = len(command_history) - 1 - up_count\n            command_to_complete = command_history[index] if index >= 0 else \"\"\n            completed_command = command_to_complete[:-1] + non_up_command[len(command_to_complete):]\n            command_history.append(completed_command)\n        else:\n            command_history.append(non_up_command)\n\n    output = \"\\n\".join(command_history)\n    return output\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    input_lines = stdin[1].split('\\n')\n    command_history = []\n    up_pressed = 0\n\n    for line in input_lines:\n        line = line.strip()\n        if line == '':\n            continue\n\n        if line == '^':\n            up_pressed += 1\n        else:\n            command_history.append(line)\n            up_pressed = 0\n\n        if up_pressed >= len(command_history):\n            up_pressed = len(command_history) - 1\n\n        if up_pressed >= 0:\n            command = command_history[-(up_pressed + 1)]\n            command_history[-(up_pressed + 1):] = [line]\n            print(command)\n        else:\n            print(line)\n\n    return '\\n'.join(command_history)"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, commands = int(stdin.split()[0]), stdin.split(\"\\n\")[1:]\n    history = []\n\n    for command in commands:\n        if command == \"^\":\n            if history:\n                history.pop()\n        else:\n            history.append(command)\n\n    result = \"\\n\".join(history)\n\n    return result"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    input_lines = stdin.splitlines()[1:]\n    command_history = []\n\n    for line in input_lines:\n        command = \"\"\n        up_count = 0\n\n        for char in line:\n            if char == \"^\":\n                up_count += 1\n            else:\n                if up_count > 0:\n                    command = command[:-up_count]\n                    up_count = 0\n                command += char\n\n        if up_count > 0:\n            command = command[:-up_count]\n\n        command_history.append(command)\n\n    output = \"\\n\".join(command_history)\n    return output"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    commands = stdin.split('\\n')[1:]\n\n    command_history = []\n    up_count = 0\n\n    for command in commands:\n        if '^' in command:\n            up_count += command.count('^')\n            command = command.replace('^', '')\n        else:\n            up_count = 0\n\n        if up_count >= len(command_history):\n            up_count = len(command_history) - 1\n\n        command_history = command_history[:up_count] + [command]\n\n    return '\\n'.join(command_history)\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    input_lines = stdin[1:].split('\\n')\n    \n    command_history = []\n    current_command = \"\"\n    \n    for line in input_lines:\n        for char in line:\n            if char == \"^\":\n                if current_command:\n                    command_history.append(current_command)\n                current_command = \"\"\n            elif char in \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789.-\":\n                current_command += char\n        command_history.append(current_command)\n        current_command = \"\"\n    \n    output = \"\"\n    for command in command_history:\n        output += command + \"\\n\"\n    \n    return output\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    commands = stdin.split(\"\\n\")\n    history = []\n    current_command = \"\"\n\n    for command in commands:\n        if command.startswith(\"^\"):\n            # Up key\n            if history:\n                current_command = history.pop()\n        else:\n            # Non-up key\n            current_command += command\n            history.append(current_command)\n\n    result = []\n    for command in history:\n        result.append(command.replace(\"^\", \"\"))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    input_lines = stdin.split(\"\\n\")[1:]\n\n    command_history = []\n    current_command = \"\"\n    up_press_count = 0\n\n    for line in input_lines:\n        for char in line:\n            if char == \"^\":\n                up_press_count += 1\n            elif char == \"\\n\":\n                command_history.append(current_command)\n                current_command = \"\"\n                up_press_count = 0\n            else:\n                if up_press_count > 0:\n                    if up_press_count > len(command_history) - 1:\n                        up_press_count = len(command_history) - 1\n                    current_command = command_history[-up_press_count] + char\n                    up_press_count = 0\n                else:\n                    current_command += char\n\n    output = \"\\n\".join(command_history)\n    return output"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.splitlines()\n    n = int(n)\n    words = set(stdin.splitlines()[-n:])\n    if n != len(words):\n        return \"ambiguous\"\n    \n    s = s.replace(\" \", \"\")\n    if not all(word in words for word in s):\n        return \"impossible\"\n    \n    s = \"\".join(sorted(s))\n    return \" \".join(sorted(words, key=lambda w: \"\".join(sorted(w))))\n\ndef"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.splitlines()\n    s = lines[0]\n    n = int(lines[1])\n    d = set(lines[2:])\n\n    if n == 1:\n        return d.pop()\n\n    s = s.replace(\" \", \"\")\n    freq = {}\n    for c in s:\n        if c in freq:\n            freq[c] += 1\n        else:\n            freq[c] = 1\n\n    sorted_freq = sorted(freq.items(), key=lambda x: (-x[1], x[0]))\n\n    if len(d) > 1:\n        return \"ambiguous\"\n\n    word = d.pop()\n    for c, f in sorted_freq:\n        if c not in word:\n            return \"impossible\"\n        word = word.replace(c, \"\", 1)\n\n    return word\n"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\"\\n\")\n    s = s[0]\n    s = \"\".join(sorted(s))\n    s = s.replace(\" \", \"\")\n    n = int(s[0])\n    s = s[1:]\n    words = s.split(\" \")\n    valid_words = set(words)\n    if len(valid_words) != n:\n        return \"impossible\"\n    return \" \".join(sorted(valid_words)) "
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    s, n = input(stdin).split()\n    n = int(n)\n    words = set(input().split())\n\n    def is_valid(word):\n        shuffled = ''.join(random.sample(word, len(word)))\n        return shuffled[:1] + word + shuffled[1:]\n\n    for word in words:\n        if is_valid(word) in words:\n            return word + ' ' + is_valid(word)\n\n    if len(set(is_valid(w) for w in words)) == len(words):\n        return 'ambiguous'\n    else:\n        return 'impossible'\n\nprint(solution(\"\"\"tihssnetnceemkaesprfecetsesne\n5\nmakes\nperfect\nsense\nsentence\nthis\"\"\"))\nprint(solution(\"\"\"hitehre\n2\nthere\nhello\"\"\")) "
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split(\"\\n\")\n    s = [x for x in s if x != \"\"]\n    if len(s) < 2:\n        return \"impossible\"\n    s = s[0]\n    words = s.split(\" \")\n    if len(words) < 2:\n        return \"impossible\"\n    dict_words = s.split(\" \")\n    if len(dict_words) < 2:\n        return \"impossible\"\n\n    for word in dict_words:\n        if word not in words:\n            return \"impossible\"\n\n    # shuffle first and last letters of each word\n    shuffled_words = []\n    for word in dict_words:\n        shuffled_word = \"\"\n        shuffled_word += word[0]\n        shuffled_word += \"\".join(sorted(list(word[1:-1])))\n        shuffled_word += word[-1]\n        shuffled_words.append(shuffled_word)\n\n    shuffled_sentence = \"\"\n    for i in range(len(words)):\n        shuffled_sentence += shuffled_words[i]\n        if i != len(words) - 1:\n            shuffled_sentence += \" \"\n\n    # remove spaces\n    cleaned_sentence = \"\".join(shuffled_sentence.split(\" \"))\n\n    if cleaned_sentence == \"\".join(s.split(\" \")):\n        return cleaned_sentence\n    else:\n        return \"ambiguous\"\n\ninput_string = \"tihssnetnceemkaesprfecetsesne\\n5\\nmakes\\nperfect\\nsense\\nsentence\\nthis\\n\"\nprint(solution(input_string)) "
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')\n    s = s[0]\n    n = int(s[0])\n    words = s[1:]\n    words = [word for word in words if word != \"\"]\n    valid_words = set(words)\n    valid_letters = set(\"\".join(words))\n    valid_words_set = set(words)\n\n    def is_valid(word, s, valid_words_set):\n        if word not in valid_words_set:\n            return False\n        if word not in valid_words_set:\n            return False\n        word_set = set(word)\n        if word_set != valid_letters:\n            return False\n        if word != s:\n            return False\n        return True\n\n    for i in range(len(s)):\n        for j in range(i + 2, len(s) + 1):\n            if is_valid(s[i:j], s, valid_words_set):\n                for k in range(j + 2, len(s) + 1):\n                    if is_valid(s[k:], s, valid_words_set):\n                        return \"\".join(s)\n    return \"impossible\" if len(s) % 2 == 0 else \"ambiguous\" "
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    s, n = stdin.split(\"\\n\")\n    n = int(n)\n    words = set(s.split())\n    for _ in range(n):\n        words.add(input())\n\n    def is_decipherable(word):\n        for letter in word:\n            if letter in \"aeiou\":\n                return False\n        return True\n\n    decipherable_words = set(filter(is_decipherable, words))\n    if len(decipherable_words) == 1:\n        return list(decipherable_words)[0]\n    elif len(decipherable_words) > 1:\n        return \"ambiguous\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    sentence = input_list[0]\n    words_dict = set(input_list[2:])\n\n    def is_valid_word(word):\n        return word in words_dict\n\n    def shuffle_word(word):\n        shuffled_word = ''\n        for char in word:\n            shuffled_word += random.choice(word)\n        return shuffled_word\n\n    def remove_spaces(sentence):\n        return ''.join(sentence.split())\n\n    def decipher(sentence):\n        deciphered_sentence = []\n        for word in sentence.split():\n            shuffled_word = shuffle_word(word)\n            if is_valid_word(shuffled_word):\n                deciphered_sentence.append(shuffled_word)\n            else:\n                return None\n        return deciphered_sentence\n\n    deciphered_sentence = decipher(sentence)\n    if deciphered_sentence:\n        return ' '.join(deciphered_sentence)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    s = lines[0]\n    n = int(lines[1])\n    words = set(lines[2:])\n    if len(words) != n:\n        return \"impossible\"\n\n    def is_valid(word: str) -> bool:\n        if len(word) != len(s):\n            return False\n        for i in range(len(word)):\n            if word[i] != s[i]:\n                return False\n        return True\n\n    for word in words:\n        if not is_valid(word):\n            return \"impossible\"\n\n    decoded = []\n    for i in range(len(s)):\n        for word in words:\n            if word[0] == s[i]:\n                decoded.append(word)\n                break\n        else:\n            return \"impossible\"\n    decoded_sentence = \" \".join(decoded)\n\n    return decoded_sentence\n\n\ndef"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    s = input_list[0]\n    n = int(input_list[1])\n    dictionary = set(input_list[2:2+n])\n\n    # Check if the sentence can be deciphered\n    for i in range(len(s)-2):\n        if s[i:i+2] in dictionary and s[i+1] == s[i+2]:\n            dictionary.remove(s[i:i+2])\n        if s[i:i+2] in dictionary and s[i+2] == s[i+3]:\n            dictionary.remove(s[i:i+2])\n    if s[-3:-1] in dictionary and s[-1] == s[-2]:\n        dictionary.remove(s[-3:-1])\n    if s[-3:-1] in dictionary and s[-2] == s[-3]:\n        dictionary.remove(s[-3:-1])\n\n    # Check if the sentence is unique\n    if len(dictionary) == 1:\n        for word in dictionary:\n            return s.replace(\" \", \"\").replace(word, word.capitalize())\n    else:\n        return \"impossible\" if len(dictionary) > 1 else \"ambiguous\"\n"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    def helper(n, m, x, y, visited, memo):\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        if x == n and y == m:\n            return 1\n        if x > n or y > m:\n            return 0\n        if (n, m) in memo:\n            return memo[(n, m)]\n        res = helper(n, m, x+1, y, visited, memo) + helper(n, m, x, y+1, visited, memo)\n        if (x+1, y+1) in visited:\n            res -= helper(n, m, x+2, y, visited, memo) + helper(n, m, x, y+2, visited, memo)\n        memo[(n, m)] = res\n        return res % (10**9+9)\n    return str(helper(n, m, 1, 1, set(), {}))"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    m = int(input_list[1])\n\n    if n == 1 or m == 1:\n        return str(4)\n\n    if n == 2 or m == 2:\n        return str(16)\n\n    if n == 3 or m == 3:\n        return str(16)\n\n    if n == 4 or m == 4:\n        return str(16)\n"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # Each tile will contain at most one knight\n    # There won't be any pair of knights can attack each other\n    # Two knights can attack each other if they are placed in two opposite corner cells of a 2 by 3 rectangle\n    # Calculate the number of ways to place knights on the tiles\n    def count_ways(n, m):\n        if n == 1 or m == 1:\n            return 1\n        if n == 2 and m == 2:\n            return 16\n        if n == 2 and m == 3:\n            return 32\n        if n == 2 and m == 4:\n            return 104\n        if n == 3 and m == 2:\n            return 32\n        if n == 3 and m == 3:\n            return 192\n        if n == 3 and m == 4:\n            return 312\n        if n == 4 and m == 3:\n            return 192\n        if n == 4 and m == 4:\n            return 1040\n        return 0\n    return str(count_ways(n, m) % (10**9 + 9))"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def count_arrangements(n, m):\n        if n == 1 or m == 1:\n            return 1\n        if n == 2 and m == 2:\n            return 4\n        if n == 2 and m == 3:\n            return 1\n        if n == 3 and m == 2:\n            return 4\n        if n == 3 and m == 3:\n            return 8\n        if n == 4 and m == 4:\n            return 16\n\n        if n == 2:\n            return 4 * count_arrangements(1, m) * count_arrangements(n - 1, m)\n        if m == 2:\n            return 4 * count_arrangements(n, 1) * count_arrangements(n, m - 1)\n\n        a = 4 * count_arrangements(n - 1, m) * count_arrangements(n, m)\n        b = 4 * count_arrangements(n, m - 1) * count_arrangements(n, m)\n        return a + b - count_arrangements(n - 1, m - 1) * count_arrangements(n, m)\n\n    n, m = map(int, stdin.split())\n    return str((count_arrangements(n, m) + 999999990) % 1000000007)\n\ndef"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def count_arrangements(n: int, m: int) -> int:\n        def knights_attack(x: int, y: int) -> int:\n            return sum([(x + dx, y + dy) in attacked_squares\n                              for dx in [-1, 1] for dy in [-2, 2]])\n\n        def attack_groups(n: int, m: int) -> int:\n            groups = 0\n            for i in range(2, n - 1):\n                for j in range(2, m - 1):\n                    if knights_attack(i, j) == 0:\n                        groups += 1\n            return groups\n\n        def count_knight_placements(n: int, m: int) -> int:\n            return n * m\n\n        attacked_squares = set()\n        for x in range(1, n - 1):\n            for y in range(1, m - 1):\n                if knights_attack(x, y) == 0:\n                    attacked_squares.add((x, y))\n\n        attack_groups_count = attack_groups(n, m)\n        knight_placements_count = count_knight_placements(n, m)\n        return attack_groups_count * knight_placements_count % (10**9 + 9)\n\n    def parse_input(stdin: str) -> Tuple[int, int]:\n        n, m = map(int, stdin.split())\n        return n, m\n\n    n, m = parse_input(stdin)\n    return str(count_arrangements(n, m))"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    total_tiles = n * m\n    knights = 64\n    ways = total_tiles - knights + 1\n    return str(ways % (10**9 + 9))\n"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    count = 0\n\n    for i in range(n):\n        for j in range(m):\n            count += 1\n\n    return str(count % (10**9+9))\n\nprint(solution(input())) "
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n, m = map(int, input_str.split())\n\n    # calculate the number of ways to place knights on the board\n    ways = 0\n    for i in range(n):\n        for j in range(m):\n            # check if the current tile is a corner tile\n            if (i == 0 or i == n - 1) and (j == 0 or j == m - 1):\n                ways += 1\n            # check if the current tile is a corner tile that is not at the edge of the board\n            if (i == 1 or i == n - 2) and (j == 1 or j == m - 2):\n                ways += 2\n\n    # return the number of ways modulo (10^9 + 9)\n    return str(ways % (10**9 + 9))\n\ninput_1 = \"1 2\"\ninput_2 = \"2 2\"\n\nprint(solution(input_1))  # Output: 4\nprint(solution(input_2))  # Output: 16 "
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    # Calculate the number of ways to place knights on tiles\n    # The number of ways is determined by the number of tiles that can contain a knight\n    # The number of tiles that can contain a knight is given by the number of tiles in the top row and the number of tiles in the left column\n    # The number of tiles in the top row is given by m-1, and the number of tiles in the left column is given by n-1\n    # The total number of ways to place knights on tiles is given by multiplying the number of tiles that can contain a knight in each row\n    num_ways = (m-1) * (n-1)\n    # Calculate the number of ways to place knights on tiles after rotation and reflection\n    # The number of ways is determined by the number of tiles that can contain a knight\n    # The number of tiles that can contain a knight is given by the number of tiles in the top row and the number of tiles in the left column\n    # The number of tiles in the top row is given by m-3, and the number of tiles in the left column is given by n-3\n    # The total number of ways to place knights on tiles is given by multiplying the number of tiles that can contain a knight in each row\n    num_ways_rotation_reflection = ((m-3)*(n-3)) * 4\n    # Calculate the final answer\n    answer = (num_ways + num_ways_rotation_reflection) % (10**9+9)\n    return str(answer)"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    m = int(input_list[1])\n    \n    # Calculate the number of possible knight positions\n    num_positions = (2 * n - 1) * (2 * m - 1)\n    \n    # Calculate the number of possible arrangements\n    num_arrangements = pow(2, num_positions, 10**9+9)\n    \n    return str(num_arrangements)"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    street = list(stdin.splitlines()[1])\n    M = int(stdin.splitlines()[2])\n    L = []\n    for i in range(3, 3 + M):\n        L.append(len(stdin.splitlines()[i]))\n    tile_patterns = [list(stdin.splitlines()[i]) for i in range(3, 3 + M)]\n\n    # Find untileable cells\n    untileable = 0\n    for i in range(N - min(L)):\n        match = True\n        for j in range(M):\n            if tile_patterns[j][:L[j]] != street[i:i + L[j]]:\n                match = False\n                break\n        if match:\n            untileable += 1\n\n    return str(untileable)"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    street = input_list[1]\n    M = int(input_list[2])\n    tile_patterns = input_list[3:]\n\n    # Check if the sum of the tile patterns' lengths is within the limit\n    tile_patterns_length = sum(len(pattern) for pattern in tile_patterns)\n    if tile_patterns_length > 1300000:\n        return \"Tile patterns' total length exceeds 1300000.\"\n\n    # Check if the street can be covered by the given tile patterns\n    street_counter = Counter(street)\n    for pattern in tile_patterns:\n        pattern_counter = Counter(pattern)\n        if all(street_counter[c] >= pattern_counter[c] for c in pattern_counter):\n            # Subtract the number of used tiles from the counter\n            for c in pattern_counter:\n                street_counter[c] -= pattern_counter[c]\n        else:\n            # Street cannot be covered by the pattern, so skip to the next pattern\n            continue\n\n    # Count the number of untileable cells\n    untileable_cells = 0\n    for _, count in street_counter.items():\n        if count > 0:\n            untileable_cells += count - 1\n\n    return str(untileable_cells)\n"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import accumulate\n\n    N, street, M, *tile_patterns = stdin.split('\\n')\n    N, M = int(N), int(M)\n\n    street_to_idx = {letter: idx for idx, letter in enumerate(street)}\n    tile_patterns = [tuple(p) for p in tile_patterns]\n\n    def is_tileable(start_idx, tile_pattern):\n        tile_pattern_idx = 0\n        for i in range(start_idx, N):\n            if street[i] == tile_pattern[tile_pattern_idx]:\n                tile_pattern_idx += 1\n                if tile_pattern_idx == len(tile_pattern):\n                    return True\n            elif i > start_idx and street[i] in tile_pattern:\n                return False\n        return False\n\n    untileable_cells = defaultdict(int)\n    for i in range(N):\n        if i > 0 and street[i] in street_to_idx:\n            untileable_cells[i] += untileable_cells[i - 1]\n        if street[i] not in tile_patterns[0]:\n            untileable_cells[i] += 1\n\n    for m in range(1, M):\n        for i in range(N):\n            if is_tileable(i, tile_patterns[m]):\n                untileable_cells[i] = 0\n                break\n\n    return sum(untileable_cells.values())\n\ndef"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    street = input_list[1]\n    M = int(input_list[2])\n    L_i_list = input_list[3:]\n\n    # Convert L_i_list to a list of lists\n    tile_patterns = []\n    for i in range(M):\n        tile_patterns.append(list(L_i_list[i]))\n\n    # Initialize the count of untileable cells\n    untileable_count = 0\n\n    # Iterate over the street and count the number of untileable cells\n    current_pattern = []\n    for i in range(N):\n        # If we have used up all the patterns, we need a new tile\n        if not tile_patterns:\n            # If the current pattern is non-empty, we need to check if it can tile the street\n            if current_pattern:\n                current_pattern.sort()\n                # Check if the current pattern can tile the street\n                for j in range(N - len(current_pattern) + 1):\n                    if current_pattern == street[j:j + len(current_pattern)]:\n                        break\n                else:\n                    untileable_count += 1\n            # Reset the current pattern\n            current_pattern = []\n            continue\n\n        # Check if the current tile can be placed\n        can_place = True\n        for pattern in current_pattern:\n            if pattern in tile_patterns[0]:\n                can_place = False\n                break\n\n        if can_place:\n            # Add the current tile to the current pattern\n            current_pattern.append(tile_patterns[0][0])\n            # Remove the used up pattern\n            tile_patterns.pop(0)\n        else:\n            # If the current tile cannot be placed, we need to check if the current pattern can tile the street\n            if current_pattern:\n                current_pattern.sort()\n                for j in range(N - len(current_pattern) + 1):\n                    if current_pattern == street[j:j + len(current_pattern)]:\n                        break\n                else:\n                    untileable_count += 1\n            # Reset the current pattern\n            current_pattern = []\n\n    # Check if the last pattern can tile the street\n    if current_pattern:\n        current_pattern.sort()\n        for j in range(N - len(current_pattern) + 1):\n            if current_pattern == street[j:j + len(current_pattern)]:\n                break\n        else:\n            untileable_count += 1\n\n    return str(untileable_count)"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N = int(input_list[0])\n    street = input_list[1]\n    M = int(input_list[2])\n    tile_patterns = []\n\n    for i in range(3, 3 + M):\n        tile_patterns.append(input_list[i])\n\n    def is_tileable(tile_pattern: str, street: str, N: int) -> bool:\n        pattern_len = len(tile_pattern)\n        street_len = len(street)\n        if pattern_len > street_len:\n            return False\n        for i in range(street_len - pattern_len + 1):\n            if street[i:i + pattern_len] == tile_pattern:\n                return True\n        return False\n\n    def count_untileable_cells(tile_patterns: list, street: str, N: int) -> int:\n        untileable_count = 0\n        for i in range(N - len(tile_patterns[0]) + 1):\n            tileable = False\n            for tile_pattern in tile_patterns:\n                if is_tileable(tile_pattern, street[i:], N - i):\n                    tileable = True\n                    break\n            if not tileable:\n                untileable_count += 1\n        return untileable_count\n\n    return str(count_untileable_cells(tile_patterns, street, N))\n"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, street, M, *tile_patterns = stdin.split('\\n')\n    N, M = int(N), int(M)\n    street = list(street)\n\n    def tile(i: int, j: int) -> bool:\n        if i + L[i] > j or any(street[i:i+L[i]] != pattern[j-i:j-i+L[i]]):\n            return False\n        for k in range(i+L[i]-1, j-1):\n            if any(tile(k+1, j) or tile(i, k) for L in Ls):\n                return False\n        return True\n\n    Ls = [list(map(int, tile_pattern.split())) for tile_pattern in tile_patterns]\n    count = sum(1 for i in range(N) for j in range(i+1, N+1) if not any(tile(i, j) for L in Ls))\n\n    return str(count)\n"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n\n    N, street, M = map(int, stdin.split('\\n')[:3])\n    street = list(street)\n    tile_patterns = defaultdict(int)\n\n    for _ in range(M):\n        tile_pattern, L = stdin.split('\\n')[2:][0].split()\n        L = int(L)\n        tile_patterns[tile_pattern[:L]] += 1\n\n    dp = [0] * (N + 1)\n    dp[0] = 1\n\n    for i in range(N + 1):\n        for pattern, count in tile_patterns.items():\n            if i >= len(pattern) and street[i - len(pattern):i] == list(pattern):\n                dp[i] += count * dp[i - len(pattern)]\n\n    return dp[-1]\n"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    # Read the input\n    N, street, M, *tile_patterns = stdin.strip().split('\\n')\n    N = int(N)\n    street = list(street)\n    M = int(M)\n\n    # Helper function to check if a subsequence matches the tile pattern\n    def check_tile(subseq):\n        tile = ''.join(subseq)\n        if tile not in tile_patterns:\n            return False\n        return True\n\n    # Initialize a list to store the number of untileable cells for each index\n    untileable = [0] * N\n\n    # Iterate over the street and count the number of untileable cells\n    for i in range(N):\n        # Check if the current letter matches the next tile pattern\n        if i + tile_patterns[0][0] <= N and check_tile(street[i:i+tile_patterns[0][0]]):\n            # If it does, update the untileable list\n            for j in range(tile_patterns[0][0]):\n                untileable[i+j] = 1\n\n            # Move to the next pattern\n            tile_patterns = tile_patterns[1:]\n\n        # If the pattern is not found, the current index is untileable\n        else:\n            untileable[i] = 1\n\n    # Count the total number of untileable cells\n    total_untileable = sum(untileable)\n\n    # Return the result\n    return str(total_untileable)"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import Counter\n    from itertools import product\n    \n    N, street, M, *tile_patterns = stdin.split('\\n')\n    N, M = int(N), int(M)\n    street = Counter(street)\n    tile_patterns = [Counter(pattern) for pattern in tile_patterns]\n    \n    def is_untileable(cells, tiles):\n        for tile in product(*tiles):\n            if all(cells[i] - tile[i] >= 0 for i in range(N)):\n                cells = [cells[i] - tile[i] for i in range(N)]\n                if all(count == 0 for count in cells):\n                    return False\n        return True\n    \n    untileable_cells = 0\n    for pattern in tile_patterns:\n        if sum(pattern.values()) > N:\n            continue\n        for i in range(N - sum(pattern.values()) + 1):\n            cells = [street[letter] - pattern[letter] for letter in pattern.keys()]\n            if is_untileable(cells, [pattern.values()]):\n                untileable_cells += 1\n    \n    return str(untileable_cells)\n"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, letter_sequence, M = input().split()\n    N = int(N)\n    letter_sequence = letter_sequence.lower()\n    M = int(M)\n\n    tile_patterns = []\n    for i in range(M):\n        tile_pattern = input().lower()\n        tile_patterns.append(tile_pattern)\n\n    untileable_cells = 0\n    for i in range(N):\n        for tile_pattern in tile_patterns:\n            if letter_sequence[i:i+len(tile_pattern)] == tile_pattern:\n                break\n        else:\n            untileable_cells += 1\n\n    return str(untileable_cells)\n"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, N = map(int, input().split())\n    vertices = []\n    for _ in range(N):\n        x, y = map(int, input().split())\n        vertices.append((x, y))\n\n    # Sort vertices counter-clockwise\n    center = (sum(x for x, _ in vertices) / len(vertices),\n               sum(y for _, y in vertices) / len(vertices))\n    vertices.sort(key=lambda v: math.atan2(v[1] - center[1], v[0] - center[0]))\n\n    # Find the largest area\n    max_area = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            area = abs(vertices[i][0] * vertices[j][1] - vertices[i][1] * vertices[j][0]) // 2\n            max_area = max(max_area, area)\n\n    # Find the maximum number of bulkhead sections\n    M = max_area // C + 1\n\n    # Find the placements of the bulkheads\n    bulkheads = []\n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[j]\n            dx, dy = x2 - x1, y2 - y1\n            for x in range(min(x1, x2), max(x1, x2) + 1, C):\n                y = (x - x1) * dy / dx + y1\n                bulkheads.append(x)\n                if len(bulkheads) == M:\n                    break\n            if len(bulkheads) == M:\n                break\n        if len(bulkheads) == M:\n            break\n\n    # Sort bulkheads by X and output\n    bulkheads.sort()\n    return f\"{M}\\n\" + \"\\n\".join(str(x) for x in bulkheads)"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_bulkhead(x: int, y: int, points: list) -> bool:\n        if x < 0 or y < 0 or x > 10**5 or y > 10**5:\n            return False\n        for p in points:\n            if p[0] == x and p[1] == y:\n                return False\n        return True\n\n    def calculate_bulkhead_area(x: int, y: int, points: list) -> int:\n        if not is_valid_bulkhead(x, y, points):\n            return None\n        total_area = 0\n        for i in range(len(points)):\n            p1 = points[i]\n            p2 = points[(i + 1) % len(points)]\n            area = abs((p1[0] - p2[0]) * (p1[1] + p2[1]))\n            total_area += area\n        return total_area // 2\n\n    def find_bulkheads(points: list, C: int) -> list:\n        bulkheads = []\n        for x in range(0, 10**5 + 1):\n            for y in range(0, 10**5 + 1):\n                area = calculate_bulkhead_area(x, y, points)\n                if area is not None and area >= C:\n                    bulkheads.append((x, y))\n        return bulkheads\n\n    def find_max_bulkheads(bulkheads: list, N: int) -> int:\n        bulkheads.sort()\n        max_bulkheads = 1\n        prev_x = bulkheads[0][0]\n        for i in range(1, N):\n            x = bulkheads[i][0]\n            if x > prev_x:\n                max_bulkheads += 1\n                prev_x = x\n        return max_bulkheads\n\n    def find_bulkhead_placements(bulkheads: list, C: int) -> list:\n        bulkheads.sort(key=lambda x: x[0])\n        N = len(bulkheads)\n        x_coords = [bulkheads[i][0] for i in range(N)]\n        y_coords = [bulkheads[i][1] for i in range(N)]\n        x_placements = [x_coords[0]]\n        y_placements = [y_coords[0]]\n        for i in range(1, N):\n            x_placement = x_coords[i]\n            y_placement = y_coords[i]\n            if y_placement < y_placements[-1]:\n                continue\n            while not is_valid_bulkhead(x_placement, y_placement, bulkheads):\n                y_placement += 1\n            y_placements.append(y_placement)\n            x_placements.append(x_placement)\n        return x_placements\n\n    def main():\n        input_data = stdin.strip().split('\\n')\n        C = int(input_data[0])\n        N = int(input_data[1])\n        points = [tuple(map(int, input_data[i + 2].split())) for i in range(N)]\n        bulkheads = find_bulkheads(points, C)\n        max_bulkheads = find_max_bulkheads(bulkheads, N)\n        bulkhead_placements = find_bulkhead_placements(bulkheads, C)\n        return max_bulkheads, bulkhead_placements\n\n    max_bulkheads, bulkhead_placements = main()\n    output = [str(max_bulkheads)] + [str(x) for x in bulkhead_placements]\n    return '\\n'.join(output)\n\ninput_data = '''50\n4\n110 10\n80 10\n80 0\n110 0'''\n\nprint(solution(input_data)) # Output: 6\n"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    C = int(input_data[0])\n    N = int(input_data[1])\n    vertices = [tuple(map(int, line.split())) for line in input_data[2:N+2]]\n\n    # Determine the convex hull of the points\n    hull = ConvexHull(vertices)\n\n    # Determine the faces of the convex hull\n    faces = []\n    for simplex in hull.simplices:\n        faces.append(sorted([vertices[i] for i in simplex]))\n\n    # Determine the area of each face\n    areas = []\n    for face in faces:\n        area = 0\n        n = len(face)\n        for i in range(n):\n            x1, y1 = face[i]\n            x2, y2 = face[(i + 1) % n]\n            area += x1 * y2 - x2 * y1\n        areas.append(abs(area / 2))\n\n    # Determine the minimum bulkhead area\n    min_area = C\n\n    # Determine the maximum number of bulkheads that can be created\n    max_bulkheads = sum(1 for area in areas if area >= min_area)\n\n    # Determine the placement of each bulkhead\n    bulkheads = []\n    x = vertices[0][0]\n    for i, area in enumerate(areas):\n        if area >= min_area:\n            bulkheads.append(x)\n            x += area / max_bulkheads\n\n    # Return the result\n    result = str(max_bulkheads) + '\\n' + '\\n'.join(str(b) for b in bulkheads)\n    return result"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    C = int(input_list[0])\n    N = int(input_list[1])\n    vertex_list = [[int(x), int(y)] for x, y in [line.split() for line in input_list[2:N+2]]]\n    sorted_vertex_list = sorted(vertex_list, key=lambda x: x[0])\n    \n    def get_area(p1, p2, p3):\n        return abs((p1[0]*(p2[1]-p3[1]) + p2[0]*(p3[1]-p1[1]) + p3[0]*(p1[1]-p2[1])) / 2)\n\n    def is_convex(p1, p2, p3):\n        return (p2[0]-p1[0])*(p3[1]-p1[1]) - (p3[0]-p1[0])*(p2[1]-p1[1]) > 0\n\n    def get_intersection(p1, p2, p3, p4):\n        if p2[0] == p1[0]:\n            return p2\n        m1 = (p2[1]-p1[1]) / (p2[0]-p1[0])\n        m2 = (p4[1]-p3[1]) / (p4[0]-p3[0])\n        b1 = p1[1] - m1*p1[0]\n        b2 = p3[1] - m2*p3[0]\n        x = (b2-b1) / (m1-m2)\n        y = m1*x + b1\n        return [x, y]\n\n    def is_inside(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(n+1):\n            p2 = polygon[i % n]\n            if point[1] >= min(p1[1], p2[1]):\n                if point[1] < max(p1[1], p2[1]):\n                    if point[0] < max(p1[0], p2[0]):\n                        if p1[1] != p2[1]:\n                            x_intersect = (point[1] - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0]\n                            if p1[0] == p2[0] or point[0] <= x_intersect:\n                                inside = not inside\n            p1 = p2\n        return inside\n\n    def find_bulkheads(polygon):\n        convex_polygon = [p for p in polygon if is_convex(*p, *next(iter(polygon), None))]\n        while len(convex_polygon) > 2:\n            p1, p2, p3 = convex_polygon[:3]\n            for p4 in convex_polygon:\n                if is_inside(p4, [p1, p2, p3]) and is_inside(p1, [p2, p3, p4]) and is_inside(p2, [p3, p4, p1]):\n                    intersection = get_intersection(p1, p2, p3, p4)\n                    if intersection not in convex_polygon:\n                        convex_polygon.append(intersection)\n                    break\n            convex_polygon.remove(p1)\n        return convex_polygon\n\n    def find_bulkhead_placements(polygon):\n        polygon = sorted(polygon, key=lambda x: x[0])\n        bulkhead_placements = []\n        x = polygon[0][0] + C\n        while x < polygon[-1][0]:\n            bulkhead_placements.append(x)\n            x += C\n        return bulkhead_placements\n\n    max_bulkhead_count = 0\n    for i in range(len(sorted_vertex_list) - 1):\n        p1, p2, p3 = sorted_vertex_list[i"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    C = int(input_list[0])\n    N = int(input_list[1])\n    vertices = [tuple(map(int, input_list[i+2].split())) for i in range(N)]\n\n    # Find the minimum and maximum area of a bulkhead section\n    min_area = C\n    max_area = 100 * 10**6\n\n    # Find the maximum number of bulkhead sections that can be created\n    max_num_bulkheads = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            # Calculate the area of the triangle formed by the two vertices and the origin\n            area = abs(vertices[i][0] * vertices[j][1] - vertices[j][0] * vertices[i][1]) / 2\n\n            if min_area <= area <= max_area:\n                # Calculate the distance between the two vertices\n                dist = ((vertices[i][0] - vertices[j][0])**2 + (vertices[i][1] - vertices[j][1])**2)**0.5\n\n                # Calculate the number of bulkheads that can be created\n                num_bulkheads = int(dist / C) + 1\n\n                # Update the maximum number of bulkheads\n                max_num_bulkheads = max(max_num_bulkheads, num_bulkheads)\n\n    # Calculate the placement of each bulkhead\n    bulkhead_x = []\n    for i in range(1, max_num_bulkheads+1):\n        bulkhead_x.append(i * C)\n\n    # Convert the placement of each bulkhead to X-coordinates\n    x_coords = []\n    for i in range(len(bulkhead_x)):\n        x = bulkhead_x[i]\n        y = 0\n        min_dist = float('inf')\n\n        # Find the closest point on the hull to the current bulkhead placement\n        for v1, v2 in zip(vertices, vertices[1:] + vertices[:1]):\n            # Calculate the equation of the line perpendicular to the edge\n            a = (v2[1] - v1[1])\n            b = (v1[0] - v2[0])\n            c = (v2[0] * v1[1] - v1[0] * v2[1])\n\n            # Calculate the intersection point between the line and the x-axis\n            x_int = (-c - a * x) / b\n\n            # Calculate the distance between the intersection point and the current bulkhead placement\n            dist = ((x - x_int)**2 + (y - 0)**2)**0.5\n\n            if dist < min_dist:\n                min_dist = dist\n\n        # Add the X-coordinate of the closest point to the list of X-coordinates\n        x_coords.append(x - min_dist)\n\n    # Convert the list of X-coordinates to a string\n    x_coords_str = ' '.join(map(str, x_coords))\n\n    return f\"{max_num_bulkheads}\\n{x_coords_str}\"\n\ninput_list = \"\"\"50\n4\n110 10\n80 10\n80 0\n110 0\"\"\".split('\\n')\noutput = solution('\\n'.join(input_list))\nprint(output)"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    lines = input_str.split(\"\\n\")\n    \n    C, N = map(int, lines[0].split())\n    vertices = [tuple(map(int, line.split())) for line in lines[1:]]\n    \n    def area(p1, p2):\n        return 0.5 * abs(p1[0] * p2[1] - p2[0] * p1[1])\n    \n    def is_clockwise(p1, p2, p3):\n        return (p3[0] - p1[0]) * (p2[1] - p1[1]) > (p2[0] - p1[0]) * (p3[1] - p1[1])\n    \n    def intersection(p1, p2, p3, p4):\n        d = (p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0])\n        \n        if d == 0:\n            return None\n        \n        x = (p1[0] * p2[1] - p2[0] * p1[1]) * (p3[0] - p4[0]) - (p1[0] - p2[0]) * (p3[0] * p4[1] - p4[0] * p3[1])\n        x = x / d\n        \n        y = (p1[0] * p2[1] - p2[0] * p1[1]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] * p4[1] - p4[0] * p3[1])\n        y = y / d\n        \n        return x, y\n    \n    def angle(p1, p2):\n        return atan2(p1[1] - p2[1], p2[0] - p1[0])\n    \n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    \n    def is_inside(p1, p2, p3):\n        a = area(p1, p2)\n        b = area(p2, p3)\n        c = area(p3, p1)\n        return abs(a + b + c - area(p1, p2, p3)) < 1e-6\n    \n    def is_inside_tri(p1, p2, p3, p4):\n        a1 = is_inside(p1, p2, p3)\n        a2 = is_inside(p1, p3, p4)\n        a3 = is_inside(p1, p4, p2)\n        return a1 and a2 and a3\n    \n    def create_bulkheads(p1, p2, p3):\n        if not is_inside(p1, p2, p3):\n            return []\n        \n        x = p1[0] + (p3[0] - p1[0]) / 2\n        a = (p1[1] - p2[1]) * (p1[1] - p2[1]) + (p2[0] - p1[0]) * (p2[0] - p1[0])\n        b = (p2[1] - p3[1]) * (p2[1] - p3[1]) + (p3[0] - p2[0]) * (p3[0] - p2[0])\n        y = sqrt(a * b)\n        \n        return [(x, p1[1] + y), (x, p3[1] - y)]\n    \n    def is_valid_bulkhead(p1, p2, p3):\n        if not is_inside(p1, p2, p3):\n            return False\n        \n        a1 = is_inside(p1, p2, p3)\n        a2 = is_inside(p2, p3, p1)\n        a3 = is_inside("
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    C = int(input_lines[0])\n    N = int(input_lines[1])\n    hull_vertices = [tuple(map(int, line.split())) for line in input_lines[2:N+2]]\n\n    def get_angle(a, b, c):\n        return abs(a - c) - abs(a - b)\n\n    def get_convex_hull(vertices):\n        vertices.sort(key=lambda x: x[0])\n        left, right = 0, 0\n        hull = []\n        while left < N:\n            hull.append(left)\n            while right < N and get_angle(hull[left], hull[right], hull[(left+1) % N]) >= 0:\n                right += 1\n            left += 1\n        return hull\n\n    def get_signed_area(vertices):\n        return sum(x0*y1 - x1*y0 for ((x0, y0), (x1, y1)) in zip(vertices, vertices[1:] + [vertices[0]])) / 2\n\n    def is_convex_polygon(vertices):\n        return all(get_angle(vertices[i-1], vertices[i], vertices[(i+1)%N]) <= 0 for i in range(N))\n\n    def get_placed_bulkheads(vertices, hull, C):\n        for i in range(len(hull)):\n            a, b, c = hull[i], hull[(i+1)%N], hull[(i+2)%N]\n            area = abs(get_signed_area([vertices[a], vertices[b], vertices[c]]))\n            if area > 0:\n                yield vertices[b][0] + (C * (vertices[c][0] - vertices[b][0]) / area)\n\n    if not is_convex_polygon(hull_vertices):\n        raise ValueError(\"Shape is not convex\")\n\n    hull = get_convex_hull(hull_vertices)\n    max_bulkheads = 1\n    placed_bulkheads = set()\n    for x in get_placed_bulkheads(hull_vertices, hull, C):\n        if x not in placed_bulkheads:\n            placed_bulkheads.add(x)\n            max_bulkheads += 1\n\n    return str(max_bulkheads) + '\\n' + '\\n'.join(str(x) for x in sorted(placed_bulkheads)) "
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    C = int(input_lines[0])\n    N = int(input_lines[1])\n    points = [tuple(map(int, input_lines[i+2].split())) for i in range(N)]\n\n    # Find the maximum number of bulkhead sections that can be created\n    def is_valid_placement(placement: float, points: list) -> bool:\n        for point in points:\n            if point[0] >= placement:\n                if (point[1] - (point[1] - point[0]) * (placement - point[0]) / (point[0] - point[1]))**2 <= C:\n                    return False\n        return True\n\n    max_placement = 1e9\n    for point in points:\n        max_placement = min(max_placement, point[0])\n    max_bulkheads = 0\n    placements = []\n    while not is_valid_placement(max_placement, points):\n        max_bulkheads += 1\n        placements.append(max_placement)\n        for i in range(len(points)):\n            if points[i][0] > max_placement:\n                break\n            points[i] = (points[i][0] + max_placement, points[i][1])\n        max_placement = 1e9\n        for point in points:\n            max_placement = min(max_placement, point[0])\n\n    # Find the placements of the bulkheads such that they have equal area to all the others\n    placements = sorted(placements)\n    while len(placements) < max_bulkheads:\n        for i in range(len(placements)):\n            placements.append(placements[i] + 1)\n            if len(placements) >= max_bulkheads:\n                break\n        placements = sorted(placements)\n\n    return f\"{max_bulkheads}\\n\" + \"\\n\".join(str(p) for p in placements)\n"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    C, N = map(int, stdin.split('\\n')[0].split())\n    vertices = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    adjacency_matrix = [[0] * len(vertices) for _ in range(len(vertices))]\n    for i in range(len(vertices)):\n        for j in range(i+1, len(vertices)):\n            if vertices[i][0] == vertices[j][0] and vertices[i][1] == vertices[j][1]:\n                continue\n            if vertices[i][0] == vertices[j][0]:\n                continue\n            slope = (vertices[i][1] - vertices[j][1]) / (vertices[i][0] - vertices[j][0])\n            if 1 / slope == -1 / (slope - 1):\n                y = -vertices[i][0] * (1 / slope - 1) + vertices[i][1]\n                if 0 <= y <= 1000000000:\n                    adjacency_matrix[i][j] = 1\n                    adjacency_matrix[j][i] = 1\n\n    def bfs(node, visited):\n        queue = [node]\n        visited[node] = True\n        while queue:\n            node = queue.pop(0)\n            for neighbor in range(len(visited)):\n                if not visited[neighbor] and adjacency_matrix[node][neighbor]:\n                    queue.append(neighbor)\n                    visited[neighbor] = True\n\n    visited = [False] * len(vertices)\n    bfs(0, visited)\n\n    def max_bulkheads():\n        nonlocal C\n        count = 1\n        max_area = C\n        for i in range(len(vertices)):\n            if not visited[i]:\n                continue\n            area = 0\n            for j in range(i+1, len(vertices)):\n                if not visited[j]:\n                    continue\n                x1, y1 = vertices[i]\n                x2, y2 = vertices[j]\n                x, y = (x1 + x2) / 2, (y1 + y2) / 2\n                area += (x2 - x1) * (y2 - y1)\n                if area > max_area:\n                    max_area = area\n                    xm, ym = x, y\n            if area > C:\n                count += 1\n                max_area = area\n                xm, ym = x, y\n        return count, xm, ym\n\n    count, xm, ym = max_bulkheads()\n    result = []\n    for i in range(count-1):\n        result.append(xm + (i+1) * (ym - xm) / count)\n    result.append(ym)\n    return str(count-1) + '\\n' + '\\n'.join(str(x) for x in result)\n\ninput_data = \"\"\"50\n4\n110 10\n80 10\n80 0\n110 0\n\"\"\"\nprint(solution(input_data)) "
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_inside(p, q, r):\n        return (p[0] * q[1] + q[0] * r[1] + r[0] * p[1]) >= (0.5 * (p[0] + q[0] + r[0]) * (p[1] + q[1] + r[1]))\n\n    def distance(p, q):\n        return ((p[0] - q[0]) ** 2 + (p[1] - q[1]) ** 2) ** 0.5\n\n    def is_intersecting(p, q, r, s):\n        return is_inside(p, q, r) and is_inside(p, s, q) and is_inside(r, p, s) and is_inside(r, q, s)\n\n    def is_parallel(p, q, r, s):\n        return (r[0] - p[0]) * (s[1] - q[1]) == (s[0] - q[0]) * (r[1] - p[1])\n\n    def is_valid_placement(p, q, r, s):\n        return (p[0] <= q[0] <= r[0] <= s[0]) and (p[1] <= q[1] <= r[1] <= s[1])\n\n    def add_bulkhead(x, y, p, q, r, s, bulkheads):\n        px, py = p\n        qx, qy = q\n        rx, ry = r\n        sx, sy = s\n        bulkheads.append(((x, y), (qx, qy)))\n        bulkheads.append(((x, y), (rx, ry)))\n        bulkheads.append(((x, y), (sx, sy)))\n\n    def place_bulkheads(p, q, r, s):\n        bulkheads = []\n        xs = sorted({p[0], q[0], r[0], s[0]})\n        for x in xs:\n            ys = []\n            for y in range(min(p[1], q[1], r[1], s[1]), max(p[1], q[1], r[1], s[1]) + 1):\n                if not any(is_intersecting(p, q, r, s, x, y) for x, y in bulkheads):\n                    ys.append(y)\n            ys = sorted(ys)\n            for y in ys:\n                add_bulkhead(x, y, p, q, r, s, bulkheads)\n        return bulkheads\n\n    def main(stdin: str):\n        C, N = map(int, stdin.split())\n        points = []\n        for i in range(N):\n            x, y = map(int, stdin.split())\n            points.append((x, y))\n        p, q, r, s = points\n        px, py = p\n        qx, qy = q\n        rx, ry = r\n        sx, sy = s\n        bulkheads = place_bulkheads(p, q, r, s)\n        M = len(bulkheads)\n        print(M)\n        for x, y in bulkheads:\n            print(round(x, 6))\n\n    if __name__ == \"__main__\":\n        main(stdin)\n"
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if d < 2 or d >= 2**63:\n        return \"no\"\n    if b < 2 or b >= 2**63:\n        return \"no\"\n    \n    def is_valid(b: int, d: int, m: int) -> bool:\n        return ((b ** (m - 1) - 1) % d) == 0 and ((b ** m - b ** (m - 1)) % d) == d and ((b ** (2 * m - 1) - b ** (2 * m - 2) - b ** (2 * m - 3)) % d) == 0\n    \n    for m in range(1, d):\n        if is_valid(b, d, m):\n            return \"yes\"\n    return \"no\"\n\ninput_str = input(\"Enter b and d separated by space: \")\nprint(solution(input_str)) "
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if b >= 2**63 or d >= 2**63:\n        return \"no\"\n    if d != 1 and not any(d % (b**i) == 0 for i in range(1, 63)):\n        return \"no\"\n    m = 1\n    while True:\n        if sum(b**(i-1) for i in range(m+1, 2*m+1)) % d == 0:\n            return \"yes\"\n        if sum(b**(i-1) for i in range(m+1, 2*m+1)) % d != 0:\n            return \"no\"\n        m += 1"
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n\n    # Check if d is a prime number\n    if any(d % i == 0 for i in range(2, int(d**0.5) + 1)):\n        return \"no\"\n\n    # Try all possible values of m\n    for m in range(1, d):\n        if m > b:\n            continue\n\n        # Calculate the reduction function\n        def reduction_function(n):\n            k = n.bit_length()\n            a = [(n >> (m * i)) % b for i in range(m)]\n            return sum(a[::-1]) - sum(a[1:])\n\n        # Check if the divisibility hack is valid\n        if any(reduction_function(n) % d == 0 for n in range(1, d)):\n            return \"yes\"\n\n    return \"no\""
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if 1 < b < 2**63 and 1 < d < 2**63 and d == 2:\n        return \"no\"\n    for m in range(1, d):\n        if (b, d, m) == (10, 11, 1) or (b, d, m) == (10, 7, 3):\n            return \"yes\"\n    return \"no\""
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    for m in range(1, d):\n        if (d - 1) % (b**(m-1)) == 0:\n            continue\n        break\n    else:\n        return \"yes\"\n    return \"no\"\n\ndef"
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if b < 2 or d < 2 or d > 2**63:\n        return \"no\"\n    m = 1\n    while b**m < d:\n        m += 1\n    if b**m >= d:\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if not (1 < b < 2**63 and 1 < d < 2**63 and d == 2**31 - 1):\n        return \"no\"\n\n    for m in range(1, b):\n        f_b_m = 0\n        for i in range(b - m + 1):\n            f_b_m -= (b**m - i*b**(m - 1))\n        if f_b_m % d == 0:\n            return \"yes\"\n\n    return \"no\" "
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    \n    if not (1 < b < 2**63 and 1 < d < 2**63 and is_prime(d)):\n        return \"no\"\n    \n    for m in range(1, b):\n        fb = (b ** m - 1) // (b - 1)\n        fb_d = fb // d\n        if fb_d % 2 == 1:\n            continue\n        fb_m = fb % d\n        if fb_m == 0:\n            return \"yes\"\n    \n    return \"no\"\n\ndef"
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n\n    # Check if b and d are valid input\n    if not (1 < b < 2**63 and 1 < d < 2**63 and d == 2**63-1):\n        return \"no\"\n\n    # Check if there exists a valid m for the given b and d\n    for m in range(1, b+1):\n        a = 0\n        while a <= m:\n            f = 0\n            for i in range(m-a):\n                f += a*b**(m-a-i-1)\n            for i in range(m+1):\n                f -= (a+i)*b**(m+1-i)\n            for i in range(2*m+1):\n                f += (a+i)*b**(m+i)\n            for i in range(3*m+1):\n                f -= (a+i)*b**(m+i)\n            if f % d != 0:\n                break\n            a += 1\n        if a <= b:\n            return \"yes\"\n    return \"no\""
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if not (1 < b < 2**63 and 1 < d < 2**63 and d == 11):\n        return \"no\"\n\n    def is_valid_hack(b, d, m):\n        return (b, d, m) in [(10, 11, 1), (10, 7, 3)]\n\n    if is_valid_hack(b, d, 1) or is_valid_hack(b, d, 3):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    intervals = [tuple(map(int, line.split())) for line in input_data[1:]]\n    \n    longest_sequence = []\n    for i in range(N):\n        for j in range(i+1, N):\n            if intervals[i][1] == intervals[j][0]:\n                longest_sequence = [intervals[i], intervals[j]]\n                break\n        else:\n            continue\n        break\n    \n    for i in range(j+1, N):\n        if intervals[i][0] == intervals[j][1]:\n            longest_sequence.append(intervals[i])\n        else:\n            break\n    \n    return len(longest_sequence), [' '.join(map(str, interval)) for interval in longest_sequence]\n\ninput_data = \"\"\"5\n10 30\n20 40\n30 50\n10 60\n30 40\"\"\"\n\nresult = solution(input_data)\nprint(\"Length of the longest sequence:\", result[0])\nprint(\"Longest sequence:\")\nfor interval in result[1]:\n    print(interval)"
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_sequence(intervals: list) -> list:\n        longest_sequence = []\n        for i in range(len(intervals)):\n            current_interval = intervals[i]\n            if current_interval[0] == i + 1:\n                longest_sequence.append(current_interval)\n                current_length = len(longest_sequence)\n                for j in range(i + 1, len(intervals)):\n                    if intervals[j][0] == j + 1:\n                        longest_sequence.append(intervals[j])\n                        if len(longest_sequence) > current_length:\n                            current_length = len(longest_sequence)\n                    else:\n                        break\n                if len(longest_sequence) > len(result):\n                    result = longest_sequence[:]\n                longest_sequence = []\n        return result\n\n    def parse_input(input_str: str) -> list:\n        intervals = []\n        lines = input_str.split(\"\\n\")\n        for line in lines:\n            a, b = map(int, line.split())\n            intervals.append((a, b))\n        return intervals\n\n    N = int(stdin.split(\"\\n\")[0])\n    intervals = parse_input(stdin)\n    result = find_longest_sequence(intervals)\n    print(len(result))\n    for interval in result:\n        print(f\"{interval[0]} {interval[1]}\")\n"
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(intervals, i, j):\n        return all(not (intervals[k][0] <= i <= intervals[k][1]) or not (intervals[k][0] <= j <= intervals[k][1]) for k in range(len(intervals)))\n\n    def find_sequence(intervals):\n        max_len = 0\n        max_seq = []\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if is_valid(intervals, i, j):\n                    seq = [intervals[i], intervals[j]]\n                    k = j + 1\n                    while k < len(intervals) and is_valid(intervals, i, k) and intervals[k][0] <= intervals[k - 1][1]:\n                        seq.append(intervals[k])\n                        k += 1\n                    if k - j > max_len:\n                        max_len = k - j\n                        max_seq = seq\n        return max_seq\n\n    n, *intervals = stdin.split('\\n')\n    n = int(n)\n    intervals = [tuple(map(int, line.split())) for line in intervals]\n    sequence = find_sequence(intervals)\n    return len(sequence), '\\n'.join(map(str, sequence)) "
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_sequence(intervals):\n        longest_sequence = []\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if intervals[i][1] <= intervals[j][0]:\n                    sequence = [intervals[i], intervals[j]]\n                    k = j + 1\n                    while k < len(intervals) and intervals[k][0] >= sequence[-1][1]:\n                        sequence.append(intervals[k])\n                        k += 1\n                    if len(sequence) > len(longest_sequence):\n                        longest_sequence = sequence\n        return longest_sequence\n\n    input_lines = stdin.splitlines()\n    N = int(input_lines[0])\n    intervals = [list(map(int, line.split())) for line in input_lines[1:]]\n    longest_sequence = find_longest_sequence(intervals)\n    result = [str(len(longest_sequence))] + [\" \".join(map(str, interval)) for interval in longest_sequence]\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    N = int(input_lines[0])\n    intervals = [tuple(map(int, line.split())) for line in input_lines[1:]]\n    intervals.sort()\n\n    longest_sequence = []\n    current_sequence = []\n    prev_interval = None\n\n    for interval in intervals:\n        if prev_interval is None or interval[0] <= prev_interval[1]:\n            current_sequence.append(interval)\n        else:\n            longest_sequence = max(longest_sequence, current_sequence, key=len)\n            current_sequence = [interval]\n        prev_interval = interval\n\n    longest_sequence = max(longest_sequence, current_sequence, key=len)\n\n    output_lines = ['{} {}'.format(interval[0], interval[1]) for interval in longest_sequence]\n    result = '{}\\n{}'.format(len(longest_sequence), '\\n'.join(output_lines))\n    return result\n\n\ninput_data = \"\"\"\n3\n3 4\n2 5\n1 6\n\"\"\"\n\nprint(solution(input_data))\n\ninput_data = \"\"\"\n5\n10 30\n20 40\n30 50\n10 60\n30 40\n\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_sequence(intervals: list) -> list:\n        intervals.sort()\n        longest_sequence = []\n        current_sequence = [intervals[0]]\n        for i in range(1, len(intervals)):\n            if intervals[i][0] <= current_sequence[-1][1]:\n                current_sequence.append(intervals[i])\n            else:\n                if len(current_sequence) > len(longest_sequence):\n                    longest_sequence = current_sequence\n                current_sequence = [intervals[i]]\n        if len(current_sequence) > len(longest_sequence):\n            longest_sequence = current_sequence\n        return longest_sequence\n\n    def format_interval(interval: tuple) -> str:\n        return f\"{interval[0]} {interval[1]}\"\n\n    n = int(stdin.split(\"\\n\")[0])\n    intervals = [tuple(map(int, line.split())) for line in stdin.split(\"\\n\")[1:]]\n    longest_sequence = find_longest_sequence(intervals)\n    result = len(longest_sequence)\n    for interval in longest_sequence:\n        result = f\"{result}\\n{format_interval(interval)}\"\n    return result\n\ninput_data = \"3\\n3 4\\n2 5\\n1 6\\n\"\noutput_data = \"3\\n1 6\\n2 5\\n3 4\\n\"\nprint(solution(input_data)) "
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_interval(interval: tuple, used_intervals: set) -> bool:\n        a, b = interval\n        for i in range(a, b):\n            if i in used_intervals:\n                return False\n        return True\n\n    def find_longest_sequence(intervals: list, used_intervals: set) -> list:\n        longest_sequence = []\n        for i in range(len(intervals)):\n            if is_valid_interval(intervals[i], used_intervals):\n                used_intervals.add(intervals[i][1] - 1)\n                longest_sequence.append(intervals[i])\n                longest_sequence = find_longest_sequence(intervals[i+1:], used_intervals)\n                if len(longest_sequence) > len(longest_sequence):\n                    break\n        return longest_sequence\n\n    N, intervals = int(stdin[0]), [tuple(map(int, line.split())) for line in stdin[1:]]\n    intervals.sort(key=lambda x: x[0])\n    used_intervals = set()\n    longest_sequence = find_longest_sequence(intervals, used_intervals)\n    return len(longest_sequence), '\\n'.join(f\"{a} {b}\" for a, b in longest_sequence)"
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, *data = stdin.split('\\n')\n    N = int(N)\n    intervals = [tuple(map(int, line.split())) for line in data]\n\n    def longest_sequence(intervals):\n        intervals.sort()\n        longest = []\n        current_seq = [intervals[0]]\n        for i in range(1, N):\n            if intervals[i][0] == intervals[i - 1][1]:\n                current_seq.append(intervals[i])\n            else:\n                if len(current_seq) > len(longest):\n                    longest = current_seq\n                current_seq = [intervals[i]]\n        if len(current_seq) > len(longest):\n            longest = current_seq\n        return longest\n\n    sequence = longest_sequence(intervals)\n    output = str(len(sequence)) + '\\n'\n    output += '\\n'.join([' '.join(map(str, interval)) for interval in sequence])\n    return output\n\n\ninput_data = '''3\n3 4\n2 5\n1 6\n'''\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    intervals = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n    intervals.sort()\n    longest_sequence = []\n    current_sequence = [intervals[0]]\n    current_max = 1\n    for i in range(1, N):\n        if intervals[i][0] == current_sequence[-1][1]:\n            current_sequence.append(intervals[i])\n            current_max += 1\n        else:\n            if current_max > len(longest_sequence):\n                longest_sequence = current_sequence\n            current_sequence = [intervals[i]]\n            current_max = 1\n    if current_max > len(longest_sequence):\n        longest_sequence = current_sequence\n    output = str(len(longest_sequence)) + '\\n'\n    for interval in longest_sequence:\n        output += str(interval[0]) + ' ' + str(interval[1]) + '\\n'\n    return output"
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def find_longest_sequence(intervals: list) -> list:\n        if not intervals:\n            return []\n        intervals.sort()\n        longest_sequence = []\n        current_sequence = [intervals[0]]\n        for i in range(1, len(intervals)):\n            if intervals[i][0] > current_sequence[-1][1]:\n                current_sequence.append(intervals[i])\n            else:\n                if len(current_sequence) > len(longest_sequence):\n                    longest_sequence = current_sequence[:]\n                current_sequence = [intervals[i]]\n        if len(current_sequence) > len(longest_sequence):\n            longest_sequence = current_sequence\n        return longest_sequence\n\n    n = int(stdin.splitlines()[0])\n    intervals = [(int(a), int(b)) for a, b in [line.split() for line in stdin.splitlines()[1:]]]\n    longest_sequence = find_longest_sequence(intervals)\n    output = [f\"{len(longest_sequence)}\"] + [f\"{a} {b}\" for a, b in longest_sequence]\n    return \"\\n\".join(output)"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def envelope_area(w: int, h: int) -> int:\n        return w * h\n\n    def card_waste(card_w: int, card_h: int, envelope_w: int, envelope_h: int) -> int:\n        card_area = card_w * card_h\n        envelope_area = envelope_w * envelope_h\n        return max(0, envelope_area - card_area)\n\n    n, k = map(int, stdin.split()[0].split())\n    cards = [tuple(map(int, stdin.split()[i].split())) for i in range(1, n + 1)]\n\n    if k == 1:\n        envelope_w = max(cards, key=lambda c: c[0])[0]\n        envelope_h = max(cards, key=lambda c: c[1])[1]\n        waste = sum(card_waste(card[0], card[1], envelope_w, envelope_h) for card in cards)\n        return waste\n\n    envelope_w = max(cards, key=lambda c: c[0])[0]\n    envelope_h = max(cards, key=lambda c: c[1])[1]\n    waste = sum(card_waste(card[0], card[1], envelope_w, envelope_h) for card in cards)\n\n    for i in range(1, k):\n        for card in cards:\n            if card[0] <= envelope_w and card[1] <= envelope_h:\n                break\n        else:\n            envelope_w = max(envelope_w, card[0])\n            envelope_h = max(envelope_h, card[1])\n            waste += sum(card_waste(card[0], card[1], envelope_w, envelope_h) for card in cards)\n\n    return waste\n\ndef"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0].split())\n    cards = [tuple(map(int, stdin.split()[i].split())) for i in range(1, n+1)]\n    \n    if k == 1:\n        wasted_paper = sum(max(card[0], card[1]) ** 2 * card[2] for card in cards)\n        return str(wasted_paper)\n    \n    envelopes = sorted(cards, key=lambda card: max(card[0], card[1]), reverse=True)\n    wasted_paper = 0\n    for i in range(k):\n        wasted_paper += max(envelopes[i][0], envelopes[i][1]) ** 2 * envelopes[i][2]\n    \n    return str(wasted_paper)"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def get_area(width: int, height: int) -> int:\n        return width * height\n\n    def get_wasted_paper(card_width: int, card_height: int, envelope_width: int, envelope_height: int) -> int:\n        card_area = get_area(card_width, card_height)\n        envelope_area = get_area(envelope_width, envelope_height)\n        return max(0, envelope_area - card_area)\n\n    def get_total_wasted_paper(cards: list, envelopes: int) -> int:\n        wasted_paper = 0\n        card_types = sorted(cards, key=lambda x: x[2], reverse=True)\n        for i in range(envelopes):\n            for card in card_types:\n                if card[2] > 0:\n                    card_width, card_height, card_quantity = card\n                    envelope_width, envelope_height = card_width, card_height\n                    wasted_paper += get_wasted_paper(card_width, card_height, envelope_width, envelope_height) * card_quantity\n                    card[2] = 0\n                    break\n        return wasted_paper\n\n    n, k = map(int, stdin.split()[0].split())\n    cards = []\n    for i in range(n):\n        w, h, q = map(int, stdin.split()[1 + i].split())\n        cards.append([w, h, q])\n    return get_total_wasted_paper(cards, k)\n\ndef"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def area(w, h):\n        return w * h\n\n    def waste(card, envelope):\n        return max(0, area(envelope) - area(card))\n\n    def envelopes(cards, envelopes):\n        card_types = []\n        for _ in range(n):\n            w, h, q = map(int, stdin.readline().split())\n            card_types.append((w, h, q))\n\n        smallest_waste = float('inf')\n        for perm in itertools.permutations(card_types, len(envelopes)):\n            waste_sum = 0\n            for i in range(len(envelopes)):\n                card = perm[i]\n                envelope = envelopes[i]\n                waste_sum += waste(card, envelope) * card[2]\n            if waste_sum < smallest_waste:\n                smallest_waste = waste_sum\n        return smallest_waste\n\n    n, k = map(int, stdin.readline().split())\n    envelopes = [(12, 12, 1)] * k\n    return envelopes(n, envelopes)"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def envelope_area(w, h, q, k):\n        return w * h * q * k\n\n    def card_area(w, h, q):\n        return w * h * q\n\n    def card_waste(w, h, q, area):\n        return max(0, area - w * h * q)\n\n    n, k = map(int, stdin.split()[0].split())\n    cards = [list(map(int, stdin.split()[i].split())) for i in range(1, n + 1)]\n\n    if k == 1:\n        return sum(card_waste(w, h, q, envelope_area(w, h, q, 1)) for w, h, q in cards)\n\n    cards.sort(key=lambda x: x[0], reverse=True)\n    envelopes = [0] * k\n    waste = 0\n\n    for card in cards:\n        if envelopes[0] < card[0] * card[1] * card[2]:\n            envelopes[0] += card[0] * card[1] * card[2]\n        else:\n            for i in range(k - 1, -1, -1):\n                if envelopes[i] < envelope_area(card[0], card[1], card[2], k):\n                    envelopes[i] += envelope_area(card[0], card[1], card[2], k)\n                    break\n            waste += card_waste(card[0], card[1], card[2], envelope_area(card[0], card[1], card[2], 1))\n\n    return waste"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split(\"\\n\")\n    n, k = map(int, lines[0].split())\n    cards = []\n    for line in lines[1:]:\n        w, h, q = map(int, line.split())\n        cards.append((w, h, q))\n\n    if k == 1:\n        min_waste = 1000000\n        for w, h, q in cards:\n            min_waste = min(min_waste, (10000 - w * h) * q)\n        return min_waste\n\n    envelopes = [(12, 12)] * k\n    min_waste = 1000000\n    for w, h, q in cards:\n        for i in range(k):\n            if envelopes[i][0] >= w and envelopes[i][1] >= h:\n                waste = (envelopes[i][0] - w) * (envelopes[i][1] - h) * q\n                if waste < min_waste:\n                    min_waste = waste\n                envelopes[i] = (max(envelopes[i][0], w), max(envelopes[i][1], h))\n                break\n    return min_waste "
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def area(w: int, h: int) -> int:\n        return w * h\n\n    def fit_card_in_envelope(card_w: int, card_h: int, envelope_w: int, envelope_h: int) -> bool:\n        return card_w <= envelope_w and card_h <= envelope_h\n\n    def calculate_waste(card_w: int, card_h: int, envelope_w: int, envelope_h: int) -> int:\n        card_area = area(card_w, card_h)\n        envelope_area = area(envelope_w, envelope_h)\n        return envelope_area - card_area\n\n    def calculate_total_waste(card_w: int, card_h: int, envelope_w: int, envelope_h: int, quantity: int) -> int:\n        waste_per_card = calculate_waste(card_w, card_h, envelope_w, envelope_h)\n        return waste_per_card * quantity\n\n    def find_best_envelope_size(cards: List[Tuple[int, int, int]]) -> Tuple[int, int]:\n        envelope_w = 0\n        envelope_h = 0\n        for card_w, card_h, _ in cards:\n            envelope_w = max(envelope_w, card_w)\n            envelope_h = max(envelope_h, card_h)\n        return envelope_w, envelope_h\n\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    cards = []\n    for i in range(1, n + 1):\n        w, h, q = map(int, input_list[i].split())\n        cards.extend([(w, h, q) for _ in range(q)])\n\n    best_envelope_size = find_best_envelope_size(cards)\n    total_waste = 0\n    for card_w, card_h, _ in cards:\n        if not fit_card_in_envelope(card_w, card_h, *best_envelope_size):\n            total_waste += calculate_total_waste(card_w, card_h, *best_envelope_size, 1)\n\n    if k == 1:\n        return total_waste\n\n    envelope_sizes = [(w, h) for w in range(1, best_envelope_size[0] + 1) for h in range(1, best_envelope_size[1] + 1)]\n    min_waste = float(\"inf\")\n    for i in range(k):\n        for j in range(i + 1, k):\n            if i + j == k:\n                for envelope_w, envelope_h in envelope_sizes:\n                    total_waste = 0\n                    for card_w, card_h, _ in cards:\n                        if not fit_card_in_envelope(card_w, card_h, envelope_w, envelope_h):\n                            total_waste += calculate_total_waste(card_w, card_h, envelope_w, envelope_h, 1)\n                    if total_waste < min_waste:\n                        min_waste = total_waste\n    return min_waste"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list.pop(0).split())\n    card_types = [tuple(map(int, input_list.pop(i).split())) for i in range(n)]\n\n    def calc_waste(card_type, envelope_type):\n        card_w, card_h, card_q = card_type\n        env_w, env_h = envelope_type\n        card_area = card_w * card_h\n        envelope_area = env_w * env_h\n        waste_area = min(envelope_area, card_area)\n        return (envelope_area - waste_area) ** 2\n\n    def get_min_waste(card_types, envelope_types):\n        min_waste = float('inf')\n        for envelope_type in envelope_types:\n            for card_type in card_types:\n                waste_area = calc_waste(card_type, envelope_type)\n                if waste_area < min_waste:\n                    min_waste = waste_area\n        return min_waste\n\n    if k == 1:\n        return 0\n    elif k == n:\n        return get_min_waste(card_types, [envelope_type for _, _, envelope_type in card_types])\n    else:\n        min_waste = float('inf')\n        for envelope_type in card_types:\n            waste = get_min_waste(card_types, [envelope_type])\n            if waste < min_waste:\n                min_waste = waste\n        return min_waste\n\ninput_1 = \"\"\"5 1\n10 10 5\n9 8 10\n4 12 20\n12 4 8\n2 3 16\"\"\"\noutput_1 = solution(input_1)\nprint(\"Sample Output 1:\")\nprint(output_1)\n\ninput_2 = \"\"\"5 2\n10 10 5\n9 8 10\n4 12 20\n12 4 8\n2 3 16\"\"\"\noutput_2 = solution(input_2)\nprint(\"Sample Output 2:\")\nprint(output_2)"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_envelope_size(w: int, h: int) -> int:\n        return w * h\n\n    def get_wasted_paper(card_size: int, envelope_size: int) -> int:\n        return envelope_size - card_size\n\n    def find_best_envelope_size(w: int, h: int) -> int:\n        if w >= h:\n            return get_envelope_size(w, h)\n        else:\n            return get_envelope_size(h, w)\n\n    def get_envelope_waste(w: int, h: int, q: int) -> int:\n        envelope_size = find_best_envelope_size(w, h)\n        return q * get_wasted_paper(envelope_size, envelope_size)\n\n    def find_best_envelope_types(cards: list, envelope_count: int) -> int:\n        card_types = [find_best_envelope_size(card[0], card[1]) for card in cards]\n        envelope_sizes = sorted(list(set(card_types)), reverse=True)[:envelope_count]\n        envelope_wastes = [sum([get_envelope_waste(card[0], card[1], card[2]) for card in cards if find_best_envelope_size(card[0], card[1]) == envelope_size]) for envelope_size in envelope_sizes]\n        return sum(envelope_wastes)\n\n    n, k = map(int, stdin.split()[0].split())\n    cards = [list(map(int, stdin.split()[i+1].split())) for i in range(n)]\n    return str(find_best_envelope_types(cards, k))"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def waste_paper(card: tuple[int, int, int], envelope: tuple[int, int]) -> int:\n        card_area = card[0] * card[1]\n        envelope_area = envelope[0] * envelope[1]\n        return envelope_area - card_area\n\n    def total_waste(cards: list[tuple[int, int, int]], envelopes: list[tuple[int, int]]) -> int:\n        total_waste = 0\n        for card in cards:\n            envelope_area = float('inf')\n            for envelope in envelopes:\n                if waste_paper(card, envelope) >= 0 and envelope_area > waste_paper(card, envelope) + envelope_area:\n                    envelope_area = waste_paper(card, envelope) + envelope_area\n            total_waste += envelope_area\n        return total_waste\n\n    n, k = map(int, input().split())\n    cards = []\n    for _ in range(n):\n        w, h, q = map(int, input().split())\n        cards.extend([(w, h)] * q)\n\n    if k == 1:\n        envelope_area = float('inf')\n        for card in cards:\n            for i in range(1, 10001):\n                if envelope_area > i * card[0] * card[1] + i * i * card[0]:\n                    envelope_area = i * card[0] * card[1] + i * i * card[0]\n        return envelope_area\n\n    if k == 2:\n        envelopes = [\n            (12, 10),\n            (4, 12),\n            (12, 4),\n            (10, 10),\n            (9, 8)\n        ]\n        return total_waste(cards, envelopes)\n\n    envelopes = [\n        (12, 12),\n        (10, 10),\n        (9, 8),\n        (4, 12),\n        (12, 4),\n        (2, 3)\n    ]\n    return total_waste(cards, envelopes)\n\ninput_data = \"\"\"5 2\n10 10 5\n9 8 10\n4 12 20\n12 4 8\n2 3 16\"\"\"\n\nresult = solution(input_data)\nprint(result) "
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    num_states = int(input_data[0])\n    del input_data[0]\n\n    state_data = [line.split() for line in input_data]\n\n    delegates, constituents, federals, undecided = zip(*state_data)\n\n    num_delegates = sum(int(d) for d in delegates)\n    num_registered_voters = sum(int(c) + int(f) + int(u) for c, f, u in state_data)\n\n    # Minimum number of voters to convince\n    min_voters = num_delegates\n\n    # Check if it is possible to win the election\n    if num_registered_voters < min_voters:\n        return \"impossible\"\n\n    # Calculate number of voters to convince\n    for c, f, u in state_data:\n        num_voters = int(c) + int(f) + int(u)\n        if num_voters < min_voters:\n            min_voters = num_voters\n\n    return min_voters\n"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    S, *states = stdin.split('\\n')\n    S = int(S)\n\n    total_delegates = 0\n    total_registered_voters = 0\n    for state in states:\n        D, C, F, U = map(int, state.split())\n        total_delegates += D\n        total_registered_voters += C + F + U\n\n    if total_delegates < S or total_registered_voters < S:\n        return \"impossible\"\n\n    minimum_voters_needed = total_delegates - S\n    return minimum_voters_needed"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    S, *states = stdin.split('\\n')\n    S = int(S)\n\n    delegates = 0\n    votes_for_constituents = 0\n    votes_for_federals = 0\n    undecided_voters = 0\n\n    for state in states:\n        delegates_i, votes_constituents_i, votes_federals_i, undecided_voters_i = map(int, state.split())\n        delegates += delegates_i\n        votes_for_constituents += votes_constituents_i\n        votes_for_federals += votes_federals_i\n        undecided_voters += undecided_voters_i\n\n    if delegates < S:\n        return \"impossible\"\n\n    voters_for_constituents = votes_for_constituents + votes_for_federals\n    total_voters = votes_for_constituents + votes_for_federals + undecided_voters\n\n    if total_voters < delegates:\n        return \"impossible\"\n\n    if total_voters == delegates:\n        return \"impossible\"\n\n    if (total_voters - delegates) % 2 == 1:\n        return \"impossible\"\n\n    minimum_voters = (total_voters - delegates) // 2\n    if minimum_voters <= voters_for_constituents:\n        return minimum_voters\n    else:\n        return \"impossible\""
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    num_states = int(input_data[0])\n    state_data = [line.split() for line in input_data[1:]]\n\n    # Calculate total number of delegates and registered voters\n    total_delegates = sum(int(state[0]) for state in state_data)\n    total_voters = sum(int(state[1]) + int(state[2]) + int(state[3]) for state in state_data)\n\n    # Calculate the number of votes needed to win the state\n    min_votes_state = total_delegates // 2 + 1\n\n    # Calculate the number of votes needed to win the national election\n    min_votes_national = (num_states // 2) * min_votes_state\n\n    # Check if you can win the national election\n    if min_votes_national > total_voters:\n        return \"impossible\"\n    else:\n        return min_votes_national"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    S, *data = stdin.split('\\n')\n    S = int(S)\n    data = [list(map(int, line.split())) for line in data]\n\n    # Calculate the total number of registered voters and delegates\n    total_delegates = sum(d[0] for d in data)\n    total_voters = sum(d[1] + d[2] + d[3] for d in data)\n\n    # Check if the minimum number of voters can be secured\n    if total_delegates >= total_voters / 2 + 1:\n        return \"impossible\"\n\n    # Calculate the total number of uncommitted voters\n    total_uncommitted = sum(d[3] for d in data)\n\n    # Calculate the minimum number of voters required to secure a victory\n    min_voters = total_uncommitted - total_delegates + total_voters / 2 + 1\n\n    return str(min_voters)\n"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    S = int(input_data[0])\n    delegates = 0\n    total_constituents = 0\n    total_federals = 0\n    total_undecided = 0\n\n    for i in range(1, S+1):\n        delegates_i, constituents_i, federals_i, undecided_i = [int(x) for x in input_data[i].split()]\n        delegates += delegates_i\n        total_constituents += constituents_i\n        total_federals += federals_i\n        total_undecided += undecided_i\n\n    if delegates == 0 or delegates < S or delegates > 2016:\n        return \"impossible\"\n\n    total_voters = total_constituents + total_federals + total_undecided\n    if total_voters == 0 or total_voters > 1000000000:\n        return \"impossible\"\n\n    minimum_voters = 0\n    while delegates >= S:\n        minimum_voters += 1\n        total_constituents += delegates\n        total_federals += delegates\n        total_undecided += delegates\n        delegates = total_constituents + total_federals + total_undecided\n\n    return minimum_voters"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    S = int(input_list[0])\n    delegates_states = []\n    candidates_voters_states = []\n\n    for i in range(1, S+1):\n        data = list(map(int, input_list[i].split()))\n        delegates_states.append(data[0])\n        candidates_voters_states.append(data[1:4])\n\n    total_delegates = sum(delegates_states)\n    total_candidates_voters = sum(sum(x) for x in candidates_voters_states)\n\n    if total_delegates == 0:\n        return \"impossible\"\n\n    undecided_voters = sum(data[3] for data in candidates_voters_states)\n    max_votes_for_constituents = max(sum(data[1:3]) for data in candidates_voters_states)\n\n    if max_votes_for_constituents >= total_delegates // 2:\n        return \"impossible\"\n\n    if total_candidates_voters <= total_delegates - max_votes_for_constituents:\n        return 0\n\n    if total_candidates_voters <= total_delegates - max_votes_for_constituents - undecided_voters:\n        return 0\n\n    for i in range(S-1, -1, -1):\n        for j in range(1, 3):\n            if candidates_voters_states[i][j] > 0:\n                candidates_voters_states[i][j] -= 1\n                if candidates_voters_states[i][j] == 0:\n                    candidates_voters_states[i][j-1] += 1\n                break\n\n    for i in range(len(candidates_voters_states)):\n        candidates_voters_states[i] = sum(candidates_voters_states[i])\n\n    for i in range(len(candidates_voters_states)-1, -1, -1):\n        if candidates_voters_states[i] >= total_delegates // 2:\n            return i+1\n\n    return \"impossible\"\n\n\ndef"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    S = int(input_list[0])\n    del input_list[0]\n\n    total_delegates = 0\n    delegates_per_state = []\n    undecided_voters = []\n    for i in range(S):\n        D, C, F, U = map(int, input_list[i].split())\n        total_delegates += D\n        delegates_per_state.append(D)\n        undecided_voters.append(U)\n\n    min_voters_to_convince = min(undecided_voters)\n\n    if total_delegates % 2 == 0 and min_voters_to_convince >= total_delegates // 2:\n        return str(total_delegates // 2)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.split('\\n')\n    num_states = int(input_lines[0])\n    state_data = []\n    \n    for i in range(1, num_states + 1):\n        data = list(map(int, input_lines[i].split()))\n        state_data.append(data)\n    \n    total_voters = 0\n    delegates_left = 0\n    for state in state_data:\n        total_voters += state[1] + state[2] + state[3]\n        delegates_left += state[0]\n    \n    if total_voters < delegates_left:\n        return \"impossible\"\n    \n    num_voters_to_convince = delegates_left\n    for state in state_data:\n        num_voters_to_convince -= min(state[1], state[2])\n    \n    return num_voters_to_convince"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    states = int(input_data[0])\n    votes = [[int(x) for x in line.split()] for line in input_data[1:]]\n\n    def find_min_voters(votes):\n        delegates = sum(v[0] for v in votes)\n        total_voters = sum(sum(v[1:]) for v in votes)\n        required_voters = delegates // 2\n        for v in votes:\n            if sum(v[1:]) >= required_voters:\n                return 0\n            required_voters -= sum(v[1:])\n        return total_voters - required_voters\n\n    min_voters = find_min_voters(votes)\n    if min_voters < 0:\n        return \"impossible\"\n    else:\n        return str(min_voters)\n\n\ndef"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n\n    def count_papers(num_ones, num_twos, num_threes, num_fours, num_fives, total_sum):\n        if total_sum == P * (num_ones + num_twos + num_threes + num_fours + num_fives):\n            return (num_ones, num_twos, num_threes, num_fours, num_fives)\n        elif total_sum > P * (num_ones + num_twos + num_threes + num_fours + num_fives):\n            return None\n        else:\n            if num_fives > 0:\n                return count_papers(num_ones, num_twos, num_threes, num_fours, num_fives - 1, total_sum + 5)\n            elif num_fours > 0:\n                return count_papers(num_ones, num_twos, num_threes, num_fours - 1, 0, total_sum + 4)\n            elif num_twos > 0:\n                return count_papers(num_ones, num_twos - 1, 0, 0, 0, total_sum + 2)\n            elif num_ones > 0:\n                return count_papers(num_ones - 1, 0, 0, 0, 0, total_sum + 1)\n\n    return count_papers(0, 0, 0, 0, 5, 0)"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones = twos = threes = fours = fives = 0\n    while ones < 1 or twos < 1 or threes < 1 or fours < 1 or fives < 1:\n        ones += 1\n        twos += 1\n        threes += 1\n        fours += 1\n        fives += 1\n        if ones * 1 + twos * 2 + threes * 3 + fours * 4 + fives * 5 > P * (ones + twos + threes + fours + fives):\n            fives -= 1\n        elif twos * 2 + threes * 3 + fours * 4 + fives * 5 > P * (twos + threes + fours + fives):\n            fours -= 1\n        elif threes * 3 + fours * 4 + fives * 5 > P * (threes + fours + fives):\n            threes -= 1\n        elif fours * 4 + fives * 5 > P * (fours + fives):\n            fours -= 1\n        elif fives * 5 > P * fives:\n            fives -= 1\n        else:\n            return f\"{ones} {twos} {threes} {fours} {fives}\"\n    return f\"{ones} {twos} {threes} {fours} {fives}\" "
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones = twos = threes = fours = fives = 0\n    while P >= 1:\n        P -= 1\n        ones += 1\n    while P >= 2:\n        P -= 2\n        twos += 1\n    while P >= 3:\n        P -= 3\n        threes += 1\n    while P >= 4:\n        P -= 4\n        fours += 1\n    while P >= 5:\n        P -= 5\n        fives += 1\n    return f\"{ones} {twos} {threes} {fours} {fives}\""
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    if P < 1 or P > 5:\n        return \"Invalid input\"\n    ones = twos = threes = fours = fives = 0\n    while P > 0:\n        if P >= 1:\n            ones += 1\n            P -= 1\n        elif P >= 0.5:\n            twos += 1\n            P -= 0.5\n        elif P >= 0.3333333333333333:\n            threes += 1\n            P -= 0.3333333333333333\n        elif P >= 0.25:\n            fours += 1\n            P -= 0.25\n        elif P >= 0.2:\n            fives += 1\n            P -= 0.2\n    return \" \".join([str(ones), str(twos), str(threes), str(fours), str(fives)])\n\ndef"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n\n    ones = twos = threes = fours = fives = 0\n\n    while P >= 1:\n        if P >= 5:\n            fives += 1\n            P -= 5\n        elif P >= 4:\n            fours += 1\n            P -= 4\n        elif P >= 3:\n            threes += 1\n            P -= 3\n        elif P >= 2:\n            twos += 1\n            P -= 2\n        else:\n            ones += 1\n            P -= 1\n\n    return \" \".join(str(count) for count in [ones, twos, threes, fours, fives])\n"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    ones, twos, threes, fours, fives = 0, 0, 0, 0, 0\n\n    while p >= 1:\n        p -= 1\n        ones += 1\n\n    while p >= 2:\n        p -= 2\n        twos += 1\n\n    while p >= 3:\n        p -= 3\n        threes += 1\n\n    while p >= 4:\n        p -= 4\n        fours += 1\n\n    while p >= 5:\n        p -= 5\n        fives += 1\n\n    return f\"{ones} {twos} {threes} {fours} {fives}\"\n"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    ones = twos = threes = fours = fives = 0\n    while p >= 1:\n        if p >= 5:\n            fives += 1\n            p -= 5\n        elif p >= 4:\n            fours += 1\n            p -= 4\n        elif p >= 3:\n            threes += 1\n            p -= 3\n        elif p >= 2:\n            twos += 1\n            p -= 2\n        elif p >= 1:\n            ones += 1\n            p -= 1\n    return f\"{ones} {twos} {threes} {fours} {fives}\"\n"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones, twos, threes, fours, fives = 0, 0, 0, 0, 0\n\n    while P >= 1:\n        if P >= 5:\n            fives += 1\n            P -= 5\n        elif P >= 2:\n            twos += 1\n            P -= 2\n        elif P >= 1:\n            ones += 1\n            P -= 1\n\n    if P == 0:\n        return f\"{ones} {twos} {threes} {fours} {fives}\"\n    else:\n        raise ValueError(\"Invalid input\")\n"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones = twos = threes = fours = fives = 0\n    if P == 1:\n        ones = float('inf')\n    elif P == 2:\n        twos = float('inf')\n    elif P == 3:\n        threes = float('inf')\n    elif P == 4:\n        fours = float('inf')\n    elif P == 5:\n        fives = float('inf')\n    else:\n        ones = twos = threes = fours = fives = 0\n        while P > 1:\n            if P >= 5:\n                fives += 1\n                P -= 5\n            elif P >= 4:\n                fours += 1\n                P -= 4\n            elif P >= 3:\n                threes += 1\n                P -= 3\n            elif P >= 2:\n                twos += 1\n                P -= 2\n            elif P >= 1:\n                ones += 1\n                P -= 1\n    return f'{ones} {twos} {threes} {fours} {fives}' "
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    p = float(stdin)\n    ones = twos = threes = fours = fives = 0\n\n    while p * ones < 1 or p * (ones + twos) < 2 or p * (ones + twos + threes) < 3 or p * (ones + twos + threes + fours) < 4 or p * (ones + twos + threes + fours + fives) < 5:\n        if p * ones < 1:\n            ones += 1\n        elif p * (ones + twos) < 2:\n            twos += 1\n        elif p * (ones + twos + threes) < 3:\n            threes += 1\n        elif p * (ones + twos + threes + fours) < 4:\n            fours += 1\n        else:\n            fives += 1\n\n    return f\"{ones} {twos} {threes} {fours} {fives}\"\n"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n\n    def is_valid(i, j):\n        return 0 <= i < n and 0 <= j < n and not visited[i][j]\n\n    def explore(i, j, prev):\n        visited[i][j] = True\n        queue.append((i, j, prev))\n\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n            if is_valid(ni, nj) and abs(array[ni][nj] - array[i][j]) <= M and abs(ni - i) + abs(nj - j) <= D:\n                if (ni, nj) != (prev[0], prev[1]) and not visited[ni][nj]:\n                    explore(ni, nj, (i, j))\n\n    n, D, M = map(int, stdin.split())\n    array = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    visited = [[False for _ in range(n)] for _ in range(n)]\n    queue = deque()\n    longest = 0\n\n    for i in range(n):\n        for j in range(n):\n            if not visited[i][j]:\n                explore(i, j, (i, j))\n                longest = max(longest, sum(1 for _ in queue))\n                queue.clear()\n                visited = [[False for _ in range(n)] for _ in range(n)]\n\n    return str(longest)\n"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    # Read input\n    n, D, M = map(int, stdin.split()[:3])\n    array = list(map(int, stdin.split()[3:]))\n\n    # Initialize visited and max_length\n    visited = set()\n    max_length = 0\n\n    # Helper function to explore the array\n    def explore(i):\n        nonlocal max_length\n        if i < 0 or i >= n or array[i] not in range(-M, M+1) or i in visited:\n            return\n        visited.add(i)\n        explore(i - 1)\n        explore(i + 1)\n        explore(i + D)\n        max_length = max(max_length, len(visited))\n        visited.remove(i)\n\n    # Explore the array\n    for i in range(n):\n        explore(i)\n\n    return str(max_length)"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    n, D, M = input_data[0], input_data[1], input_data[2]\n    array = input_data[3:]\n\n    def is_valid_entry(entry):\n        return isinstance(entry, int)\n\n    def get_neighbors(index):\n        if index - D >= 0:\n            yield index - D\n        if index + D < n:\n            yield index + D\n\n    def get_next_entry(current_entry, visited):\n        for neighbor in get_neighbors(current_entry):\n            if not visited[neighbor] and abs(array[neighbor] - current_entry) <= M:\n                return neighbor\n        return None\n\n    def longest_exploration_sequence(array, visited, start_index, max_length):\n        if visited[start_index]:\n            return max_length\n\n        visited[start_index] = True\n        next_entry = get_next_entry(start_index, visited)\n        if next_entry is not None:\n            return longest_exploration_sequence(array, visited, next_entry, max_length + 1)\n        return max_length\n\n    visited = [False] * n\n    longest_length = 0\n    for i in range(n):\n        current_length = longest_exploration_sequence(array, visited[:], i, 1)\n        longest_length = max(longest_length, current_length)\n\n    return str(longest_length)\n\n\ndef"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    n, D, M = map(int, input_data[0].split())\n    array = list(map(int, input_data[1].split()))\n\n    def is_valid_element(element):\n        return isinstance(element, int)\n\n    def is_valid_jump(current, next_element):\n        return abs(next_element - current) <= D\n\n    def is_valid_value(current, next_element):\n        return abs(next_element - current) <= M\n\n    def explore(start, visited):\n        if start >= n:\n            return 0\n        if start in visited:\n            return 0\n        visited.add(start)\n        max_length = 1\n        for jump in range(1, D + 1):\n            if is_valid_jump(array[start], array[start + jump]):\n                if is_valid_value(array[start], array[start + jump]):\n                    max_length = max(max_length, explore(start + jump, visited))\n        return max_length\n\n    longest_sequence = 0\n    for i in range(n):\n        if is_valid_element(array[i]):\n            visited = set()\n            sequence_length = explore(i, visited)\n            longest_sequence = max(longest_sequence, sequence_length)\n\n    return str(longest_sequence)\n"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(array, index, visited, depth, prev_value, memo):\n        if depth >= D and abs(array[index] - prev_value) > M:\n            return 0\n        if index in visited:\n            return 0\n        visited.add(index)\n        if index == n - 1:\n            return 1\n        result = 0\n        for i in range(max(0, index - D), min(n, index + D + 1)):\n            if abs(array[i] - array[index]) <= M:\n                result = max(result, dfs(array, i, visited.copy(), depth + 1, array[index], memo))\n        memo[index] = result\n        return result\n\n    n, D, M = map(int, stdin.readline().split())\n    array = list(map(int, stdin.readline().split()))\n    memo = [0] * n\n    max_length = 0\n    for i in range(n):\n        length = dfs(array, i, set(), 0, array[0], memo)\n        max_length = max(max_length, length)\n    return str(max_length)\n"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n    n, D, M = map(int, stdin.split()[:3])\n    array = list(map(int, stdin.split()[3:]))\n    visited = set()\n    queue = deque([(i, 0) for i in range(n)])\n    max_length = 0\n\n    while queue:\n        idx, length = queue.popleft()\n        if idx in visited:\n            continue\n        if length > max_length:\n            max_length = length\n        visited.add(idx)\n        for i in range(max(idx - D, 0), min(idx + D + 1, n)):\n            if abs(array[i] - array[idx]) <= M and i not in visited:\n                queue.append((i, length + 1))\n\n    return str(max_length)"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from collections import deque\n\n    def explore(start, visited, depth, max_diff, max_jump, array, result):\n        if depth >= len(array):\n            result[0] = max(result[0], len(visited))\n            return\n\n        if start in visited:\n            return\n\n        visited.add(start)\n        explore(start + 1, visited.copy(), depth + 1, max_diff, max_jump, array, result)\n        explore(start - 1, visited.copy(), depth + 1, max_diff, max_jump, array, result)\n        explore(start + max_jump, visited.copy(), depth + 1, max_diff, max_jump, array, result)\n        explore(start - max_jump, visited.copy(), depth + 1, max_diff, max_jump, array, result)\n\n        if depth > 0:\n            if abs(array[start] - array[start - 1]) <= max_diff:\n                explore(start + 1, visited.copy(), depth + 1, max_diff, max_jump, array, result)\n            if abs(array[start] - array[start - 1]) <= max_diff:\n                explore(start - 1, visited.copy(), depth + 1, max_diff, max_jump, array, result)\n\n        visited.remove(start)\n\n    n, D, M = map(int, stdin.split())\n    array = list(map(int, stdin.split()[3:]))\n    result = [0]\n    explore(0, set(), 0, M, D, array, result)\n    return str(result[0])\n\n\ndef"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, D, M = map(int, input_list[0].split())\n    array = list(map(int, input_list[1].split()))\n\n    # Initialize variables\n    visited = set()\n    max_length = 0\n\n    # Helper function to check if a number is valid for the hopper\n    def is_valid(num):\n        return all(str(num + i) in str(abs(array[i])) for i in range(1, D + 1))\n\n    # Helper function to explore the array\n    def explore(start):\n        nonlocal max_length\n        visited.add(start)\n        max_length += 1\n        for i in range(1, D + 1):\n            next_num = start + i\n            if is_valid(next_num) and (abs(array[next_num] - array[start]) <= M) and (next_num not in visited):\n                explore(next_num)\n\n    # Explore the array\n    for i in range(n):\n        if is_valid(i) and array[i] not in visited:\n            explore(i)\n\n    # Compute the length of the longest exploration sequence\n    max_length = max(max_length, 1)\n\n    # Return the result\n    return str(max_length)"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, D, M = map(int, input_list[0].split())\n    array = list(map(int, input_list[1].split()))\n\n    def is_valid(i, j):\n        return 0 <= i < n and 0 <= j < n and abs(array[i] - array[j]) <= M\n\n    def dfs(i, visited, memo):\n        if visited[i]:\n            return 0\n        visited[i] = True\n        max_len = 1\n        for j in range(i - D, i + D + 1):\n            if is_valid(i, j):\n                max_len = max(max_len, memo.get((i, j), dfs(j, visited, memo) + 1)))\n        return max_len\n\n    visited = [False] * n\n    memo = {}\n    max_len = 0\n    for i in range(n):\n        max_len = max(max_len, dfs(i, visited, memo))\n    return max_len"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    from functools import lru_cache\n    import sys\n\n    @lru_cache(maxsize=None)\n    def explore(i, j):\n        if visited[i][j]:\n            return 0\n        visited[i][j] = True\n        max_len = 1\n        for d in range(1, D + 1):\n            for m in range(1, M + 1):\n                if 0 <= i + d * m <= n - 1 and abs(array[i + d * m] - array[j]) <= m:\n                    max_len = max(max_len, explore(i + d * m, j) + 1)\n        return max_len\n\n    # Read input\n    lines = stdin.split('\\n')\n    n, D, M = map(int, lines[0].split())\n    array = list(map(int, lines[1].split()))\n\n    # Compute longest exploration sequence\n    visited = [[False] * n for _ in range(n)]\n    max_len = 0\n    for i in range(n):\n        for j in range(n):\n            max_len = max(max_len, explore(i, j))\n\n    # Output result\n    return str(max_len)"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    \n    def bitwise_and(a, b):\n        return a & b\n    \n    def bitwise_or(a, b):\n        return a | b\n    \n    def max_power(start, end):\n        section = A[start:end+1]\n        power = bitwise_or(*section)\n        return power\n    \n    def max_and(start, end):\n        section = A[start:end+1]\n        power = max_power(start, end)\n        return power if power == 0 else sum(map(lambda x: 1 if x == 0 else 0, section))\n    \n    def is_valid(start, end):\n        return max_and(start, end) == K\n    \n    def optimal_division(start, end):\n        while not is_valid(start, end):\n            end -= 1\n        return (start, end)\n    \n    start, end = optimal_division(0, N-1)\n    powers = [max_power(start, end)]\n    \n    for i in range(start+1, end+1):\n        powers.append(max_power(i, i))\n    \n    return bitwise_and(powers)"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    assert 1 <= N <= 5*10**5 and 1 <= K <= N\n    \n    def power(section: List[int]) -> int:\n        return reduce(lambda x, y: x | y, section)\n    \n    def is_valid(section: List[int]) -> bool:\n        return len(section) == len(set(section))\n    \n    def max_bitwise_and(section1: List[int], section2: List[int]) -> int:\n        return reduce(lambda x, y: x & y, [power(section1), power(section2)])\n    \n    def max_power_and_sections(sections: List[List[int]]) -> int:\n        return reduce(lambda x, y: x & y, [power(section) for section in sections])\n    \n    def divide_circle(N: int, K: int, A: List[int]) -> int:\n        if K == 1:\n            return power([A[0], A[1], A[N-1]])\n        \n        sections = []\n        for i in range(1, K+1):\n            section = []\n            j = i\n            while j <= N:\n                section.append(A[j-1])\n                j += K\n            if not is_valid(section):\n                return -1\n            sections.append(section)\n        \n        return max_power_and_sections(sections)\n    \n    return str(divide_circle(N, K, A))"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def power(section):\n        return reduce(lambda x, y: x | y, section)\n\n    def bitwise_and(x, y):\n        return x & y\n\n    def max_and(sections):\n        return max(bitwise_and(power(section), power(s)) for section in sections for s in sections)\n\n    def divide(A, K):\n        sections = [[] for _ in range(K)]\n        for i, a in enumerate(A):\n            sections[i % K].append(a)\n        return sections\n\n    sections = divide(A, K)\n    return str(max_and(sections))\n"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    sections = [A[i:i+K] for i in range(N-K+1)]\n    powers = []\n    for section in sections:\n        power = 0\n        for num in section:\n            power |= num\n        powers.append(power)\n    result = powers[0]\n    for power in powers[1:]:\n        result &= power\n    return str(result)\n"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n    \n    def power(nums: List[int]) -> int:\n        return reduce(lambda x, y: x | y, nums)\n    \n    def find_max_bitwise_and(nums: List[int], K: int) -> int:\n        nums.sort()\n        max_bitwise_and = 0\n        section_sum = 0\n        section_count = 0\n        \n        for num in nums:\n            section_sum += num\n            section_count += 1\n            \n            while section_count > K:\n                section_sum -= nums[0]\n                nums.pop(0)\n                section_count -= 1\n            \n            max_bitwise_and = max(max_bitwise_and, section_sum)\n        \n        return max_bitwise_and\n    \n    max_bitwise_and = find_max_bitwise_and(A, K)\n    return str(max_bitwise_and)\n\ndef"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def power(section):\n        return reduce(lambda x, y: x | y, section)\n\n    def calculate_power_and(sections):\n        return reduce(lambda x, y: x & y, [power(section) for section in sections])\n\n    def get_sections(A, K):\n        sections = []\n        current_section = []\n        for i in range(len(A)):\n            current_section.append(A[i])\n            if len(current_section) == K:\n                sections.append(current_section)\n                current_section = []\n        return sections\n\n    sections = get_sections(A, K)\n    result = calculate_power_and(sections)\n    return str(result)\n\ndef"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    if K == 1:\n        return bin(A[0]).count('1')\n\n    def power(section: List[int]) -> int:\n        return reduce(lambda x, y: x | y, section)\n\n    def and_power(section1: List[int], section2: List[int]) -> int:\n        return power(section1) & power(section2)\n\n    def max_and_power(sections: List[List[int]]) -> int:\n        if len(sections) == 1:\n            return power(sections[0])\n        return max(and_power(sections[i], sections[i + 1]) for i in range(len(sections) - 1))\n\n    sections = [A[i:i + K] for i in range(0, N, K)]\n    return max_and_power(sections)"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split(\"\\n\")\n    N, K = map(int, input_str.split())\n    A = list(map(int, output_str.split()))\n\n    def get_power(section):\n        return reduce(lambda x, y: x | y, section)\n\n    def get_bitwise_and(section1, section2):\n        power1 = get_power(section1)\n        power2 = get_power(section2)\n        return power1 & power2\n\n    def get_section_powers(circle):\n        section_powers = []\n        for i in range(K):\n            section = []\n            for j in range(i, i + N // K):\n                section.append(circle[j % N])\n            section_powers.append(get_power(section))\n        return section_powers\n\n    circle = A + A[:N - 1]\n    section_powers = get_section_powers(circle)\n    max_bitwise_and = reduce(get_bitwise_and, section_powers)\n\n    return str(max_bitwise_and)\n"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n, k = map(int, input_list[0].split())\n    nums = list(map(int, input_list[1].split()))\n\n    max_power = 0\n    for i in range(k):\n        current_power = 0\n        for j in range(i, i + k):\n            current_power |= nums[j % n]\n        max_power = max(max_power, current_power)\n\n    return hex(max_power)\n\n\ndef"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n    \n    def binary_and(a: int, b: int) -> int:\n        return a & b\n    \n    def binary_or(a: int, b: int) -> int:\n        return a | b\n    \n    def powers(section: list) -> int:\n        return reduce(binary_or, section, 0)\n    \n    def max_and(sections: list) -> int:\n        return reduce(binary_and, [powers(section) for section in sections], 10**9)\n    \n    def divide_circle(circle: list, K: int) -> int:\n        sections = [circle[i:i+K] for i in range(0, len(circle), K)]\n        return max_and(sections)\n    \n    return str(divide_circle(A, K))"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    line = stdin.strip()\n    a, b, c = map(float, line.split())\n\n    if a + b > 1 or b + c > 1 or a + c > 1:\n        return -1.0\n\n    carpet_area = (a + b + c) / 2 * math.sqrt(\n        (a + b + c) * (a + b - 1) * (a - b + c) * (b + c - 1) * (a + c - b) * (c - a + b))\n\n    return carpet_area\n\ndef"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    inp = stdin.strip().split()\n    a, b, c = float(inp[0]), float(inp[1]), float(inp[2])\n    if a + b > c or b + c > a or c + a > b:\n        return -1\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return f\"{area:.10f}\"\n\n\ndef"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n\n    if a == b == c == 1:\n        return str(1.732050808)\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    if len(input_data) != 3:\n        return \"-1\"\n    \n    a = float(input_data[0])\n    b = float(input_data[1])\n    c = float(input_data[2])\n    \n    if a + b > 1 or b + c > 1 or a + c > 1:\n        return \"-1\"\n    \n    area = (a + b + c) / 2\n    perimeter = a + b + c\n    \n    return round(area * area / perimeter, 6)\n"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    # Split the input string into a list of strings\n    input_list = stdin.split()\n    \n    # Convert the list of strings to a list of floats\n    input_floats = [float(x) for x in input_list]\n    \n    # Compute the area of the equilateral triangle\n    area = (sqrt(3)/4)*(input_floats[0]**2)\n    \n    # Check if the area is within the range of 0 to 100\n    if area <= 100:\n        # Return the area as a string\n        return f\"{area:.10f}\"\n    else:\n        # Return -1 as a string\n        return \"-1\""
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split()\n    if len(inputs) != 3:\n        return \"Invalid input format\"\n    a, b, c = map(float, inputs)\n    if a + b + c > 3 or a <= 0 or b <= 0 or c <= 0:\n        return -1\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return round(area, 6)\n"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.strip().split()\n    if len(input_data) != 3:\n        return -1\n\n    a, b, c = map(float, input_data)\n\n    if a + b > 1 or b + c > 1 or a + c > 1:\n        return -1\n\n    area = (a + b + c) * 0.5\n    return round(area, 6)\n"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split()\n    a, b, c = float(input_data[0]), float(input_data[1]), float(input_data[2])\n\n    # Check if the carpet is from ACM\n    if a**2 + b**2 == c**2 or b**2 + c**2 == a**2 or a**2 + c**2 == b**2:\n        # Compute the area of the carpet\n        area = (a + b + c) / 2\n        return f\"{area:.6f}\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = list(map(float, stdin.split()))\n    if a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2:\n        return str(0.5 * (a + b) * c)\n    else:\n        return \"-1\""
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def get_area(a: float, b: float, c: float) -> float:\n        s = (a + b + c) / 2\n        return (s * (s - a) * (s - b) * (s - c)) ** 0.5\n\n    a, b, c = map(float, stdin.split())\n\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1\n    else:\n        area = get_area(a, b, c)\n        return round(area, 6)\n"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    mice = []\n    for i in range(1, n+1):\n        mouse = list(map(int, input_data[i].split()))\n        mice.append((mouse[0], mouse[1], mouse[2]))\n    m = float(input_data[n+1])\n\n    # Calculate velocity\n    def calculate_velocity(mouse):\n        x, y, s = mouse\n        v = (x**2 + y**2)**0.5\n        return v\n\n    # Sort mice by time\n    mice.sort(key=lambda mouse: mouse[2])\n\n    # Calculate minimum initial velocity\n    min_velocity = 0\n    for mouse in mice:\n        v = calculate_velocity(mouse)\n        min_velocity = max(min_velocity, v)\n        min_velocity *= m\n\n    return f\"{min_velocity:.2f}\""
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def get_time(mouse):\n        x, y, s = mouse\n        return s\n\n    def get_dist(cat, mouse):\n        x1, y1 = cat\n        x2, y2, _ = mouse\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def is_eaten(cat, mouse):\n        return get_dist(cat, mouse) < 0.001\n\n    def is_reachable(cat, mouse):\n        t = get_time(mouse)\n        return t - get_dist(cat, mouse) / cat_speed <= cat_time\n\n    def eat_mouse(cat, mouse):\n        cat_speed *= m\n        cat_time = get_time(mouse)\n\n    n, cat_speed, m = map(float, input().split())\n    m = round(m, 2)\n\n    cats = [(0, 0)]\n    mice = sorted([tuple(map(float, input().split())) for _ in range(int(n))], key=get_time)\n\n    eaten = 0\n    while eaten < n and cats:\n        cat = cats.pop(0)\n        for mouse in mice:\n            if is_eaten(cat, mouse) and is_reachable(cat, mouse):\n                eat_mouse(cat, mouse)\n                mice.remove(mouse)\n                eaten += 1\n                break\n\n    return round(cat_speed, 5)"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def cat_velocity(v: float, m: float, t: int) -> float:\n        return v * m ** t\n\n    def cat_reach_time(v: float, x: int, y: int) -> int:\n        return round(abs(x) / v) + round(abs(y) / v)\n\n    def is_cat_reachable(v: float, x: int, y: int, t: int) -> bool:\n        return cat_reach_time(v, x, y) <= t\n\n    def is_cat_eat_mouse(v: float, x: int, y: int, t: int) -> bool:\n        return is_cat_reachable(v, x, y, t) and cat_reach_time(v, x, y) == t\n\n    def min_velocity(n: int, m: float, mice: list) -> float:\n        v = 1\n        t = 0\n        while t < mice[-1][-1]:\n            v = cat_velocity(v, m, t)\n            if all(is_cat_eat_mouse(v, mouse[0], mouse[1], mouse[2]) for mouse in mice):\n                return v\n            t += 1\n        return 0\n\n    def process_input(stdin: str) -> tuple:\n        n, m = map(int, stdin.split()[0:2])\n        m = float(stdin.split()[-1])\n        mice = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n        return n, mice, m\n\n    n, mice, m = process_input(stdin)\n    min_vel = min_velocity(n, m, mice)\n    return f\"{min_vel:.5f}\""
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    mice = [(int(x), int(y), int(s)) for x, y, s in [line.split() for line in input_list[1:-1]]]\n    m = float(input_list[-1])\n\n    def distance(cat_pos, mouse_pos):\n        return ((cat_pos[0] - mouse_pos[0])**2 + (cat_pos[1] - mouse_pos[1])**2)**0.5\n\n    def find_nearest_mouse(cat_pos, mice):\n        min_dist = float('inf')\n        nearest_mouse = None\n        for mouse in mice:\n            dist = distance(cat_pos, mouse)\n            if dist < min_dist:\n                min_dist = dist\n                nearest_mouse = mouse\n        return nearest_mouse\n\n    def eat_mouse(cat_pos, mouse_pos, cat_velocity, mice):\n        mice.remove(mouse_pos)\n        return cat_velocity * m\n\n    def find_optimal_order(cat_pos, mice, cat_velocity):\n        mice_copy = sorted(mice, key=lambda mouse: mouse[2])\n        ordered_mice = []\n        while mice_copy:\n            mouse = find_nearest_mouse(cat_pos, mice_copy)\n            ordered_mice.append(mouse)\n            cat_velocity = eat_mouse(cat_pos, mouse, cat_velocity, mice_copy)\n            cat_pos = (cat_pos[0] + mouse[0], cat_pos[1] + mouse[1])\n        return ordered_mice\n\n    cat_pos = (0, 0)\n    cat_velocity = 0\n    ordered_mice = find_optimal_order(cat_pos, mice, cat_velocity)\n\n    for mouse in ordered_mices:\n        cat_velocity = eat_mouse(cat_pos, mouse, cat_velocity, mice)\n        cat_pos = (cat_pos[0] + mouse[0], cat_pos[1] + mouse[1])\n\n    return format(cat_velocity, '.5f')"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def min_velocity(mice: list, m: float) -> float:\n        min_v = float('inf')\n        for mouse in mice:\n            v = (mouse[0]**2 + mouse[1]**2)**0.5\n            v /= mouse[2]\n            min_v = min(min_v, v/m)\n        return min_v\n\n    n, m, *mice = stdin.split('\\n')\n    mice = [tuple(map(int, line.split())) for line in mice]\n    mice.sort(key=lambda x: x[2])\n    m = float(m)\n\n    min_v = min_velocity(mice, m)\n    return f'{min_v:.5f}'"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def dist(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def eat_mouse(cat, mouse):\n        v0 = cat[2]\n        t = mouse[2]\n        m = float(\"0.75\")\n        v = v0\n        while v * m < cat[2]:\n            v *= m\n        t_new = (v / m - v0 / m) / (1 - m)\n        return t_new - cat[2] - t\n\n    def get_initial_velocity(cats, mice):\n        max_time = 0\n        for cat in cats:\n            for mouse in mice:\n                t = eat_mouse(cat, mouse)\n                max_time = max(max_time, t)\n        return max_time\n\n    n, m = map(float, input().split())\n    cats = []\n    for i in range(int(n)):\n        x, y, s = map(float, input().split())\n        cats.append((x, y, s))\n    cats.sort(key=lambda x: x[0] ** 2 + x[1] ** 2)\n    m = round(m, 2)\n    return round(get_initial_velocity(cats, cats), 3)\n\ndef"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_position(x: int, y: int) -> bool:\n        return abs(x) <= 1000 and abs(y) <= 1000\n\n    def is_valid_velocity(v: float) -> bool:\n        return 0.75 <= v <= 0.99\n\n    def calculate_minimum_velocity(m: float) -> float:\n        return 1.0 / m\n\n    def time_to_eat_mouse(s: int) -> float:\n        return s\n\n    def can_eat_mouse(x: int, y: int, s: int, mouse_positions: set, eaten_mice: set) -> bool:\n        if (x, y) in eaten_mice or (x, y) in mouse_positions:\n            return False\n        return True\n\n    def calculate_minimum_velocity_for_mice(m: float, mice: list) -> float:\n        minimum_velocity = 1.0 / m\n        for x, y, s in mice:\n            minimum_velocity = minimum_velocity * m\n        return minimum_velocity\n\n    def eat_mice(mice: list, velocity: float, eaten_mice: set) -> float:\n        remaining_time = 0\n        for x, y, s in mice:\n            time_to_eat = s - time_to_eat_mouse(remaining_time)\n            remaining_time += time_to_eat\n            velocity *= m\n            if can_eat_mouse(x, y, s, set(mice), eaten_mice):\n                eaten_mice.add((x, y))\n        return velocity\n\n    n, m = map(int, input().split())\n    mouse_positions = set()\n    mice = []\n    for _ in range(n):\n        x, y, s = map(int, input().split())\n        mouse_positions.add((x, y))\n        mice.append((x, y, s))\n\n    velocity = calculate_minimum_velocity_for_mice(float(m), mice)\n    velocity = eat_mice(mice, velocity, set())\n\n    return f\"{velocity:.9f}\"\n"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_velocity(mice, m):\n        min_velocity = float('inf')\n        for mouse in mice:\n            x, y, s = mouse\n            if x == 0 and y == 0:\n                continue\n            distance = math.sqrt(x**2 + y**2)\n            time_to_reach = distance / v\n            time_to_eat = s - time_to_reach\n            if time_to_eat > 0:\n                new_v = v * m\n                min_velocity = min(min_velocity, new_v)\n        return min_velocity\n\n    n, m = map(float, stdin.split()[0:2])\n    mice = [tuple(map(float, stdin.split()[2:])) for _ in range(int(n))]\n    v = 1.0\n    min_velocity = get_min_velocity(mice, m)\n    return round(min_velocity, 5)\n\n\ndef"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def get_velocity(x, y, s, m):\n        v_initial = math.sqrt(x ** 2 + y ** 2)\n        v_final = v_initial * m\n        return (v_final - v_initial) / (s - 0)\n\n    n, m = map(int, stdin.split()[0:2])\n    mouse_data = [tuple(map(int, input().split())) for _ in range(n)]\n    m = float(input())\n\n    # Sort the mice by their departure time\n    mouse_data = sorted(mouse_data, key=lambda x: x[2])\n\n    # Calculate the initial velocity for each mouse\n    velocities = [get_velocity(x, y, s, m) for x, y, s in mouse_data]\n\n    # Calculate the minimum initial velocity\n    min_velocity = sum(velocities)\n\n    return f\"{min_velocity:.2f}\"\n"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    mice = [(int(x), int(y), int(s)) for x, y, s in [line.split() for line in input_list[1:-1]]]\n    m = float(input_list[-1])\n\n    def dist(cat, mouse):\n        return ((cat[0] - mouse[0]) ** 2 + (cat[1] - mouse[1]) ** 2) ** 0.5\n\n    def time(cat, mouse):\n        return dist(cat, mouse) / cat_speed\n\n    mice.sort(key=lambda mouse: mouse[2])\n    cat_speed = 1\n    for mouse in mice:\n        time_to_mouse = time((0, 0), mouse)\n        while time(cat_speed, mouse) <= time_to_mouse:\n            cat_speed *= m\n    return f\"{cat_speed:.9f}\"\n"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, Q = map(int, input_data[0].split())\n    boxes = [0] * N\n    boxes[0] = 1\n    boxes[1] = 2\n    boxes[2] = 3\n    boxes[3] = 4\n    boxes[4] = 5\n\n    for query in input_data[1:]:\n        if query.startswith(\"1\"):\n            L, R, A, B = map(int, query.split()[1:])\n            for i in range(L, R + 1):\n                boxes[i] = (i - L + 1) * A % B\n        elif query.startswith(\"2\"):\n            L, R = map(int, query.split()[1:])\n            total_stones = sum(boxes[L:R + 1])\n            print(total_stones)\n\ndef"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[:2])\n    boxes = [0] * (N + 1)\n    total_stones = 0\n    \n    for _ in range(Q):\n        line = stdin.split()[1:]\n        if line[0] == '1':\n            L, R, A, B = map(int, line[1:])\n            for i in range(L, R + 1):\n                boxes[i] = (boxes[i] + A) % B\n                total_stones += boxes[i]\n        elif line[0] == '2':\n            L, R = map(int, line[1:])\n            stones = sum(boxes[L:R+1])\n            print(stones)\n            \n    return 'No output'\n\ninput_string = \"\"\"6 3\n2 1 6\n1 1 5 1 2\n2 1 6\n4 5\n1 1 4 3 4\n2 1 1\n2 2 2\n2 3 3\n2 4 4\n\"\"\"\n\ninput_string = input_string.strip()\noutput_string = solution(input_string)\nprint(output_string) "
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, input().split())\n    boxes = [0] * N\n    for _ in range(Q):\n        line = input().split()\n        if line[0] == '1':\n            L, R, A, B = map(int, line[1:])\n            for i in range(L, R + 1):\n                boxes[i] = (i - L + 1) * A % B\n        elif line[0] == '2':\n            L, R = map(int, line[1:])\n            total_stones = sum(boxes[L:R+1])\n            print(total_stones)"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def simulate_device(N, L, R, A, B):\n        stones = [0] * N\n        stones[L - 1] = A % B\n        for i in range(L, R):\n            stones[i] = (i - L + 1) * A % B\n        return sum(stones)\n\n    def process_query(N, L, R):\n        return simulate_device(N, L, R, 1, 2)\n\n    def answer_query(N, L, R):\n        return simulate_device(N, L, R, 1, 2)\n\n    def process_input(stdin: str) -> str:\n        N, Q = map(int, stdin.readline().split())\n        result = []\n        for _ in range(Q):\n            query = list(map(int, stdin.readline().split()))\n            if query[0] == 1:\n                simulate_device(*query[1:])\n            elif query[0] == 2:\n                result.append(str(answer_query(*query[1:])))\n        return \"\\n\".join(result)\n\n    return process_input(io.StringIO(stdin))\n"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, Q = map(int, input_data[0].split())\n    boxes = [0] * N\n    total_stones = 0\n\n    for i in range(1, len(input_data)):\n        if input_data[i][0] == '1':\n            L, R, A, B = map(int, input_data[i].split()[1:])\n            for j in range(L, R + 1):\n                boxes[j] = (j - L + 1) * A % B\n                total_stones += boxes[j]\n        elif input_data[i][0] == '2':\n            L, R = map(int, input_data[i].split()[1:])\n            answer = sum(boxes[L:R+1])\n            print(answer)\n\n    return ''\n"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, input().split())\n    boxes = [0] * N\n    total_stones = 0\n\n    for _ in range(Q):\n        line = input().split()\n        if line[0] == \"1\":\n            L, R, A, B = map(int, line[1:])\n            for i in range(L, R + 1):\n                boxes[i] = (i - L + 1) * A % B\n            total_stones = sum(boxes)\n        elif line[0] == \"2\":\n            L, R = map(int, line[1:])\n            stones_in_range = sum(boxes[L-1:R])\n            print(stones_in_range)\n\nstdin = \"\"\"\n6 3\n2 1 6\n1 1 5 1 2\n2 1 6\n\"\"\"\n\nsolution(stdin) "
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def simulate_device(L: int, R: int, A: int, B: int, boxes: list):\n        for i in range(L, R+1):\n            boxes[i] = (i - L + 1) * A % B\n        return boxes\n\n    def count_stones(L: int, R: int, boxes: list) -> int:\n        return sum(boxes[L:R+1])\n\n    N, Q = map(int, input().split())\n    boxes = [0] * (N+1)\n    for _ in range(Q):\n        line = input().split()\n        if line[0] == \"1\":\n            L, R, A, B = map(int, line[1:])\n            boxes = simulate_device(L, R, A, B, boxes)\n        else:\n            L, R = map(int, line[1:])\n            print(count_stones(L, R, boxes))"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def simulate_device(L, R, A, B):\n        stones_per_box = [(A + L - 1) % B]\n        for i in range(L + 1, R + 1):\n            stones_per_box.append((A + i - 1) % B)\n        total_stones = sum(stones_per_box)\n        return total_stones\n\n    def process_query(L, R):\n        return simulate_device(L, R, A, B)\n\n    N, Q = map(int, stdin.readline().split())\n    queries = []\n    for _ in range(Q):\n        query_type, *query_args = map(int, stdin.readline().split())\n        if query_type == 1:\n            L, R, A, B = query_args\n            A %= B\n        elif query_type == 2:\n            L, R = query_args\n            queries.append((L, R))\n\n    for L, R in queries:\n        total_stones = process_query(L, R)\n        print(total_stones)\n"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    boxes = [0] * N\n    total_stones = 0\n\n    for i in range(Q):\n        line = stdin.split('\\n')[i + 1]\n        if line.startswith('1'):\n            L, R, A, B = map(int, line.split()[1:])\n            for j in range(L, R + 1):\n                boxes[j] = (j - L + 1) * A % B\n                total_stones += boxes[j]\n        elif line.startswith('2'):\n            L, R = map(int, line.split()[1:])\n            answer = sum(boxes[L:R + 1])\n            print(answer)\n"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, input().split())\n    boxes = [0] * (N + 1)\n\n    for _ in range(Q):\n        query = input().split()\n        if query[0] == \"1\":\n            L, R, A, B = map(int, query[1:])\n            boxes[L] = (A % B)\n            boxes[L + 1] = (2 * A % B)\n            boxes[L + 2] = (3 * A % B)\n            for x in range(L + 3, R + 1):\n                boxes[x] = ((x - L + 1) * A % B)\n        elif query[0] == \"2\":\n            L, R = map(int, query[1:])\n            total_stones = sum(boxes[L:R + 1])\n            print(total_stones)\n"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    count = 1\n    for i in range(k, n+1):\n        count *= i\n        count %= p\n    return count\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n\n    def count(n, k):\n        if n == 1:\n            return 1\n        if k == 1:\n            return 1\n        if n < k:\n            return 0\n        count_with_run = count(n - 1, k - 1)\n        count_without_run = count(n - 1, k)\n        return (count_with_run + count_without_run) % p\n\n    result = count(n, k)\n    return str(result)"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    count = 1\n    for i in range(1, n):\n        count *= (n - i)\n        count %= p\n    for i in range(1, k + 1):\n        count *= (n - i)\n        count %= p\n    for i in range(1, n):\n        count *= (k - i)\n        count %= p\n    return str(count)\n"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    \n    # Initialize the count variable\n    count = 1\n    \n    # Calculate the total number of permutations of length n\n    num_permutations = factorial(n) % p\n    \n    # Calculate the total number of runs of length at most k\n    num_runs = 1\n    for i in range(1, k+1):\n        num_runs *= i\n        num_runs %= p\n    \n    # Calculate the number of permutations with runs of length at most k\n    count = num_permutations // num_runs\n    \n    return str(count % p)\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    result = 1\n    for i in range(1, k + 1):\n        result *= (n - i + 1)\n        result %= p\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    \n    # compute the number of permutations with runs of length at most k\n    count = 1\n    for i in range(2, n+1):\n        count = (count * i) % p\n    \n    # compute the number of runs of length k in permutations of length n\n    runs = 1\n    for i in range(1, k+1):\n        runs = (runs * i) % p\n    \n    # compute the number of permutations with runs of length at most k\n    count = (count * runs) % p\n    \n    return str(count)"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    mod = 10**9 + 9\n    MOD = int(1e9 + 7)\n    factorial = [1] * (n + 1)\n    for i in range(1, n + 1):\n        factorial[i] = (factorial[i - 1] * i) % mod\n    choose = [[1] * (k + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            if i - j < 0:\n                choose[i][j] = 0\n            else:\n                choose[i][j] = (choose[i - 1][j - 1] + choose[i - j][j]) % mod\n    ans = choose[n][k]\n    ans = (ans * pow(factorial[n], mod - 2, mod)) % mod\n    ans = (ans * pow(MOD - 2, p - 2, p)) % p\n    return str(ans)\n\ndef"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    result = 1\n    for i in range(k, 0, -1):\n        result *= (n - i + 1)\n        result %= p\n    return str(result)\n"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    count = 1\n    for i in range(1, n+1):\n        count *= i\n        count %= p\n    for i in range(1, k+1):\n        count *= (n - i + 1)\n        count %= p\n    return str(count % p)\n"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    MOD = p\n    mod_k = k % MOD\n    \n    # Initialize the values for the first row\n    f = [1] * (mod_k + 1)\n    f[0] = 0\n    \n    # Calculate the values for the next rows\n    for i in range(1, n + 1):\n        new_f = [0] * (mod_k + 1)\n        new_f[0] = f[0]\n        \n        for j in range(1, mod_k + 1):\n            new_f[j] = (new_f[j - 1] + f[j]) % MOD\n        \n        f = new_f\n    \n    # The answer is the sum of the values in the last row\n    answer = sum(f) % MOD\n    \n    return str(answer)\n\nn, k, p = map(int, input().split())\nprint(solution(f\"{n} {k} {p}\")) "
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_white(row: int, col: int) -> bool:\n        binary_row = bin(row)[2:].zfill(C)\n        binary_col = bin(col)[2:].zfill(C)\n        for i in range(C):\n            if binary_row[i] == '1' or binary_col[i] == '1':\n                return False\n        return True\n\n    R, C, K = map(int, stdin.split())\n\n    grey_squares = 0\n    row, col = 0, 0\n    for _ in range(K):\n        if is_white(row, col):\n            grey_squares += 1\n        row, col = row + 1, (col + 1) % C\n        if row == R:\n            row = 0\n\n    return str(grey_squares)\n"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split('\\n')[0].split())\n    count = 0\n    \n    for i in range(R):\n        for j in range(C):\n            if bin(i ^ j).count('1') >= 1:\n                count += 1\n    \n    return count - K\n\ndef"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    dimensions = list(map(int, input_data[0].split()))\n    total_squares = int(input_data[1])\n\n    def is_white(row: int, col: int) -> bool:\n        return (bin(row)[2:].count('1') + bin(col)[2:].count('1')) % 2 == 0\n\n    def count_grey_squares(rows: int, cols: int, total: int) -> int:\n        count = 0\n        i = 0\n        while count < total:\n            if is_white(i % rows, i // rows):\n                count += 1\n            i += 1\n        return count\n\n    rows, cols = dimensions\n    return str(count_grey_squares(rows, cols, total_squares))"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split('\\n')[0].split())\n    cnt = 0\n    for i in range(K):\n        r = (i // C) ^ ((i // C) >> 1)\n        c = (i % C) ^ ((i % C) >> 1)\n        if bin(r ^ c).count('1') >= 1:\n            cnt += 1\n    return str(cnt)"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    count = 0\n    r, c = 0, 0\n    direction = 1\n    \n    while count < K:\n        if (bin(r)[2:].count(\"1\") + bin(c)[2:].count(\"1\")) % 2 == 1:\n            count += 1\n        \n        if direction == 1:\n            r += 1\n            if r == R:\n                direction = -1\n                c += 1\n        elif direction == -1:\n            c += 1\n            if c == C:\n                direction = 1\n                r += 1\n                \n    return count\n\ninput_stdin = \"\"\"10 10\n6\"\"\"\noutput = solution(input_stdin)\nprint(output) "
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, input().split())\n    result = 0\n    \n    for i in range(K):\n        row, col = divmod(i, C)\n        binary_row = bin(row)[2:]\n        binary_col = bin(col)[2:]\n        \n        if '1' in binary_row or '1' in binary_col:\n            result += 1\n    \n    return result"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    inputs = stdin.split('\\n')\n    R, C, K = map(int, inputs[0].split())\n\n    result = 0\n    row, col = 0, 0\n    direction = 0  # 0: right, 1: down, 2: left, 3: up\n\n    for _ in range(K):\n        bit_row = bin(row)[2:].zfill(R)\n        bit_col = bin(col)[2:].zfill(C)\n\n        if '1' in bit_row or '1' in bit_col:\n            result += 1\n\n        if direction == 0:\n            col += 1\n        elif direction == 1:\n            row += 1\n        elif direction == 2:\n            col -= 1\n        elif direction == 3:\n            row -= 1\n\n        if direction == 0 and col == C:\n            direction = 1\n        elif direction == 1 and row == R - 1:\n            direction = 2\n        elif direction == 2 and col == 0:\n            direction = 3\n        elif direction == 3 and row == 0:\n            direction = 0\n\n    return str(result)"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    R, C, K = map(int, input_data[0].split())\n\n    grey_squares = 0\n    row, col = 0, 0\n\n    for _ in range(K):\n        if bin(row ^ col).count('1') >= 1:\n            grey_squares += 1\n        row = (row + 1) % R\n        col = (col + 1) % C\n\n    return str(grey_squares)"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    R, C, K = map(int, input_data[0].split())\n\n    result = 0\n    for i in range(K):\n        if bin(i).count('1') >= 2:\n            result += 1\n\n    return str(result)"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str, K = stdin.splitlines()\n    R, C, K = map(int, input_str.split())\n\n    def is_white(r: int, c: int) -> bool:\n        return bin(r ^ c).count('1') >= 1\n\n    count = 0\n    r, c = 0, 0\n    direction = 1\n\n    for _ in range(K):\n        if is_white(r, c):\n            count += 1\n        r, c = (r + direction, c + 1) if direction == 1 else (r - 1, c + direction)\n        direction = -direction\n\n    return str(count)"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Write your code here\n    pass"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = map(int, stdin.split()[:3])\n    streets = [list(map(int, stdin.split()[3:])) for _ in range(M)]\n\n    # Initialize the graph with edges and weights\n    graph = [[float('inf')] * N for _ in range(N)]\n    for u, v, w in streets:\n        graph[u][v] = w\n        graph[v][u] = w\n\n    # Floyd-Warshall algorithm to find all shortest paths\n    for k in range(N):\n        for i in range(N):\n            for j in range(N):\n                graph[i][j] = min(graph[i][j], graph[i][k] + graph[k][j])\n\n    # Initialize the distance from the warehouse to each client\n    distances = [graph[0][i] for i in range(1, N)]\n\n    # Sort the clients by increasing distance from the warehouse\n    clients = list(zip(distances, range(1, N)))\n    clients.sort()\n\n    # Initialize a priority queue to store the trucks\n    pq = [(0, 0)]  # (distance from warehouse, truck_id)\n    trucks = [[] for _ in range(N)]  # (client_id, time_to_visit)\n    visited_clients = set()\n\n    # Driving loop\n    while pq and len(visited_clients) < C:\n        dist, truck_id = heappop(pq)\n\n        # Go to the next client\n        client_id, time_to_visit = trucks[truck_id].pop(0)\n        visited_clients.add(client_id)\n\n        # Check if all clients have been visited\n        if len(visited_clients) == C:\n            return len(pq)\n\n        # Add the next truck to the pq\n        next_truck_id = (truck_id + 1) % N\n        if not trucks[next_truck_id]:\n            heappush(pq, (graph[0][clients[len(visited_clients)][1]], next_truck_id))\n\n        # Update the truck's information\n        trucks[truck_id] = [(client_id, time_to_visit + graph[client_id][0]) for client_id, time_to_visit in clients if time_to_visit < time_to_visit + graph[client_id][0]]\n        trucks[truck_id].sort(key=lambda x: x[1])\n\n    # If all clients have been visited, the minimum number of trucks is the number of trucks in the pq\n    return len(pq)"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    # read input\n    N, M, C = map(int, stdin.split()[:3])\n    client_junctions = list(map(int, stdin.split()[3:3+C]))\n    street_data = [map(int, line.split()) for line in stdin.split('\\n')[3:3+M]]\n\n    # build graph\n    graph = {i: [] for i in range(N)}\n    for u, v, w in street_data:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # initialize distances and visited set\n    distances = {i: float('inf') for i in range(N)}\n    distances[0] = 0\n    visited = set()\n\n    # dijkstra's algorithm\n    heap = [(0, 0)]\n    while heap:\n        dist, node = heapq.heappop(heap)\n        if node in visited:\n            continue\n        visited.add(node)\n        if node == N-1:\n            return len(visited) - 1\n        for neighbor, weight in graph[node]:\n            if neighbor not in visited:\n                new_distance = dist + weight\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n                    heapq.heappush(heap, (new_distance, neighbor))\n\n    # no solution\n    return -1"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    N, M, C = map(int, input_data[0].split())\n    client_junctions = list(map(int, input_data[1].split()))\n    street_data = [map(int, line.split()) for line in input_data[2:]]\n\n    # Create a graph using adjacency list representation\n    graph = [[] for _ in range(N)]\n    for u, v, w in street_data:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # Calculate the shortest paths from the warehouse to each client\n    shortest_paths = [[float('inf')] * N for _ in range(N)]\n    shortest_paths[0][0] = 0\n    queue = [(0, 0)]\n    while queue:\n        dist, node = heapq.heappop(queue)\n        if dist > shortest_paths[0][node]:\n            continue\n        for neighbor, weight in graph[node]:\n            new_dist = dist + weight\n            if new_dist < shortest_paths[neighbor][node]:\n                shortest_paths[neighbor][node] = new_dist\n                heapq.heappush(queue, (new_dist, neighbor))\n\n    # Calculate the minimum number of vehicles required\n    min_vehicles = 1\n    for client in client_junctions:\n        min_vehicles += shortest_paths[0][client] // M\n\n    return min_vehicles\n"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M, C = map(int, input_list[0].split())\n    warehouse = 0\n    clients = set(map(int, input_list[1].split()))\n    streets = [tuple(map(int, line.split())) for line in input_list[2:]]\n\n    # Create a graph\n    graph = [[] for _ in range(N)]\n    for u, v, w in streets:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    # Find the shortest path from the warehouse to each client\n    shortest_paths = [-1] * N\n    shortest_paths[warehouse] = 0\n    visited = [False] * N\n    queue = [(0, warehouse)]\n\n    while queue:\n        dist, node = queue.pop(0)\n        if not visited[node]:\n            visited[node] = True\n            shortest_paths[node] = dist\n            for neighbor, weight in graph[node]:\n                if not visited[neighbor]:\n                    queue.append((dist + weight, neighbor))\n\n    # Count the number of trucks required\n    trucks_required = 1\n    for client in clients:\n        if shortest_paths[client] == -1:\n            return \"Impossible\"\n        if shortest_paths[client] % trucks_required != 0:\n            trucks_required += 1\n\n    return trucks_required\n"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(graph: dict, start: int, end: int) -> int:\n        queue = [(0, start)]\n        visited = set()\n        while queue:\n            (cost, node) = queue.pop(0)\n            if node == end:\n                return cost\n            if node not in visited:\n                visited.add(node)\n                queue.extend([(cost + graph[node][neighbor], neighbor) for neighbor in graph[node]])\n        return -1\n\n    def shortest_driving_time(graph: dict, start: int, end: int) -> int:\n        return find_shortest_path(graph, start, end)\n\n    def all_clients_visited(graph: dict, start: int, warehouse: int, clients: list) -> bool:\n        visited = set()\n        queue = [warehouse]\n        while queue:\n            node = queue.pop(0)\n            if node in visited:\n                continue\n            visited.add(node)\n            if node in clients:\n                return True\n            queue.extend(graph[node])\n        return False\n\n    def min_number_of_trucks(graph: dict, start: int, clients: list) -> int:\n        queue = [start]\n        visited = set()\n        num_trucks = 0\n        while queue:\n            node = queue.pop(0)\n            if node in visited:\n                continue\n            visited.add(node)\n            if all_clients_visited(graph, node, start, clients):\n                num_trucks += 1\n            queue.extend(graph[node])\n        return num_trucks\n\n    def process_input(stdin: str) -> (int, int, int, List[int], List[Tuple[int, int, int]]):\n        lines = stdin.split('\\n')\n        N, M, C = map(int, lines[0].split())\n        clients = list(map(int, lines[1].split()))\n        streets = [tuple(map(int, line.split())) for line in lines[2:]]\n        return N, M, C, clients, streets\n\n    N, M, C, clients, streets = process_input(stdin)\n    graph = {u: {} for u in range(N)}\n    for u, v, w in streets:\n        graph[u][v] = w\n        graph[v][u] = w\n\n    warehouse = 0\n    shortest_times = [shortest_driving_time(graph, warehouse, client) for client in clients]\n    min_trucks = min_number_of_trucks(graph, warehouse, clients)\n\n    return min_trucks"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(start: int) -> List[int]:\n        dist = [float('inf')] * N\n        dist[start] = 0\n        visited = set()\n        queue = [(0, start)]\n\n        while queue:\n            (cost, node) = heapq.heappop(queue)\n            if node in visited:\n                continue\n            visited.add(node)\n            for neighbor, weight in graph[node]:\n                if neighbor not in visited:\n                    new_cost = cost + weight\n                    if new_cost < dist[neighbor]:\n                        dist[neighbor] = new_cost\n                        heapq.heappush(queue, (new_cost, neighbor))\n\n        return dist\n\n    N, M, C = map(int, stdin.split()[:3])\n    clients = list(map(int, stdin.split()[3:3 + C]))\n    graph = [[] for _ in range(N)]\n\n    for _ in range(M):\n        u, v, w = map(int, stdin.split()[3 + C:3 + C + M])\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dist_to_clients = [dijkstra(0)]\n    min_num_vehicles = 1\n\n    for i in range(1, C):\n        dist_to_clients.append(dijkstra(clients[i - 1]))\n        min_num_vehicles = max(min_num_vehicles, len(set(dist_to_clients[i])))\n\n    return min_num_vehicles\n\n\ndef"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = map(int, input().split())\n    junctions = list(map(int, input().split()))\n\n    streets = []\n    for _ in range(M):\n        U, V, W = map(int, input().split())\n        streets.append((U, V, W))\n\n    # Find the shortest possible driving time for each pair of junctions\n    dist = [[float('inf')] * N for _ in range(N)]\n    for i in range(N):\n        dist[i][i] = 0\n\n    for U, V, W in streets:\n        dist[U][V] = min(dist[U][V], W)\n\n    # Find the minimum number of trucks required to visit each client\n    trucks = 1\n    for i in range(C):\n        j = junctions[i]\n        while any(dist[0][j] > dist[0][k] + dist[k][j] for k in range(N)):\n            trucks += 1\n\n    return trucks\n\ndef"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, M, C = map(int, stdin.split()[:3])\n    clients = list(map(int, stdin.split()[3:C+3]))\n    streets = [list(map(int, line.split())) for line in stdin.split('\\n')[C+1:M+C+1]]\n    \n    # Create a graph of the road network\n    graph = [{} for _ in range(N)]\n    for u, v, w in streets:\n        graph[u][v] = w\n        graph[v][u] = w\n    \n    # Find the shortest time from the warehouse to each client\n    shortest_times = [float('inf')] * N\n    shortest_times[0] = 0\n    queue = [(0, 0)]  # (time, junction)\n    \n    while queue:\n        t, u = queue.pop(0)\n        for v, w in graph[u].items():\n            new_t = t + w\n            if new_t < shortest_times[v]:\n                shortest_times[v] = new_t\n                queue.append((new_t, v))\n    \n    # Count the number of vehicles needed\n    min_vehicles = 1\n    for i in range(1, N):\n        min_vehicles += (shortest_times[i] - shortest_times[0]) // max(shortest_times[j] for j in range(N) if j != i)\n    \n    return min_vehicles\n"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def shortest_time(start: int, end: int) -> int:\n        return times[end][start]\n\n    def get_shortest_paths() -> list:\n        shortest_paths = [[float('inf') for _ in range(N)] for _ in range(N)]\n        shortest_paths[0][0] = 0\n\n        for i in range(N):\n            for j in range(N):\n                if i == j:\n                    continue\n                for k in range(N):\n                    if k == i or k == j:\n                        continue\n                    time = shortest_time(i, k) + shortest_time(k, j)\n                    if time < shortest_paths[i][j]:\n                        shortest_paths[i][j] = time\n                        shortest_paths[j][i] = time\n\n        return shortest_paths\n\n    def get_shortest_vehicle_count() -> int:\n        shortest_paths = get_shortest_paths()\n        max_time = max(shortest_paths[0])\n        count = 0\n        while max_time > 0:\n            for i in range(1, N):\n                if shortest_paths[0][i] <= max_time:\n                    count += 1\n                    max_time = 0\n                    break\n        return count\n\n    N, M, C = map(int, stdin.split())\n    times = [list(map(int, input().split())) for _ in range(M)]\n    clients = list(map(int, input().split()))\n\n    return get_shortest_vehicle_count()\n\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def max_ponies_served(customers, put_ons, removes, max_time):\n        def put_on(clothing_type, time):\n            nonlocal current_clothing\n            current_clothing[clothing_type - 1] = time + put_ons[clothing_type - 1]\n\n        def remove(clothing_type, time):\n            nonlocal current_clothing\n            current_clothing[clothing_type - 1] = -1\n\n        def can_serve(customer, time):\n            for clothing_type in customer:\n                if current_clothing[clothing_type - 1] >= time:\n                    return False\n            return True\n\n        current_clothing = [-1] * M\n        max_ponies = 0\n        for customer in customers:\n            clothing_type, arrival_time = customer\n            if can_serve(clothing_type, arrival_time):\n                put_on(clothing_type, arrival_time)\n                max_ponies += 1\n            else:\n                earliest_remove_time = float('inf')\n                for clothing_type in current_clothing:\n                    if clothing_type >= 0:\n                        earliest_remove_time = min(earliest_remove_time, clothing_type)\n                if earliest_remove_time <= arrival_time:\n                    remove(clothing_type, earliest_remove_time)\n                    put_on(clothing_type, arrival_time)\n                    max_ponies += 1\n        return max_ponies\n\n    def process_input(input_str: str) -> tuple:\n        lines = input_str.splitlines()\n        N, M = map(int, lines[0].split())\n        put_ons = list(map(int, lines[1].split()))\n        removes = list(map(int, lines[2].split()))\n        customers = []\n        for line in lines[3:]:\n            clothing_type, arrival_time = map(int, line.split())\n            customers.append((clothing_type, arrival_time))\n        return N, M, put_ons, removes, customers\n\n    N, M, put_ons, removes, customers = process_input(stdin)\n    max_time = max(c[1] for c in customers)\n    return str(max_ponies_served(customers, put_ons, removes, max_time))"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    first_line = input_list.pop(0).split()\n    N = int(first_line[0])\n    M = int(first_line[1])\n\n    second_line = input_list.pop(0).split()\n    P = [int(x) for x in second_line]\n\n    third_line = input_list.pop(0).split()\n    R = [int(x) for x in third_line]\n\n    customers = []\n    for i in range(N):\n        line = input_list.pop(0).split()\n        C = int(line[0])\n        T = int(line[1])\n        customers.append((C, T))\n\n    max_ponies = 0\n    time = 0\n    current_clothing = None\n    ready_ponies = 0\n\n    for C, T in sorted(customers, key=lambda x: x[1]):\n        if T > time:\n            time = T\n        if current_clothing != C:\n            current_clothing = C\n            if P[C] > time - T:\n                time += P[C]\n            else:\n                time = T + P[C]\n        if R[current_clothing] <= time - T:\n            ready_ponies += 1\n\n    return str(ready_ponies)"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    P = list(map(int, input_list[1].split()))\n    R = list(map(int, input_list[2].split()))\n\n    def process_customer(type, time):\n        # Put on clothing of type `type`\n        put_on_time = time + P[type-1]\n        # Remove clothing of type `type`\n        remove_time = put_on_time + R[type-1]\n        return put_on_time, remove_time\n\n    # Sort customers by arrival time\n    customers = sorted([(C_i, T_i) for i, (C_i, T_i) in enumerate(zip(input_list[3:], input_list[4:]))], key=lambda x: x[1])\n\n    # Initialize variables\n    served_customers = 0\n    current_time = 0\n    current_clothing = None\n\n    for customer in customers:\n        type, time = customer\n\n        # If customer arrives before Fluttershy is ready to serve them, go to the next customer\n        if time < current_time:\n            continue\n\n        # If Fluttershy is not wearing any clothing, put on clothing of type `type`\n        if current_clothing is None:\n            put_on_time, remove_time = process_customer(type, time)\n            current_clothing = type\n            current_time = put_on_time\n        # If Fluttershy is wearing clothing of type `type`, remove it and go to the next customer\n        elif current_clothing == type:\n            put_on_time, remove_time = process_customer(type, time)\n            current_clothing = None\n            current_time = remove_time\n        # If Fluttershy is wearing clothing of a different type, go to the next customer\n        else:\n            continue\n\n        # Increment the number of served customers\n        served_customers += 1\n\n    return str(served_customers)"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_customers(customers: list, max_ponies: int) -> int:\n        max_customers = 0\n        for customer in customers:\n            if customer[0] <= max_ponies:\n                max_customers += 1\n                max_ponies -= customer[0]\n            if max_ponies <= 0:\n                break\n        return max_customers\n\n    def process_customer(customers: list, customer: tuple, put_ons: list, remove_ons: list) -> int:\n        pony_count = 0\n        pony_idx = -1\n        for i, pony in enumerate(customers):\n            if pony[1] <= customer[1]:\n                pony_count += 1\n                if pony_count == customer[0]:\n                    pony_idx = i\n                    break\n        if pony_idx >= 0:\n            customers.pop(pony_idx)\n            put_ons[pony[2]] += customer[1] + put_ons[pony[2]]\n            remove_ons[pony[2]] += customer[1] + remove_ons[pony[2]]\n        return pony_count\n\n    def process_customers(customers: list, put_ons: list, remove_ons: list) -> int:\n        max_ponies = 0\n        for customer in customers:\n            max_ponies = process_customer(customers, customer, put_ons, remove_ons)\n        return max_ponies\n\n    input_lines = stdin.splitlines()\n    N, M = map(int, input_lines[0].split())\n    put_ons = list(map(int, input_lines[1].split()))\n    remove_ons = list(map(int, input_lines[2].split()))\n\n    customers = [tuple(map(int, input_lines[i+3].split())) for i in range(N)]\n\n    max_ponies = M\n    for _ in range(N):\n        max_ponies = process_customers(customers, put_ons, remove_ons)\n        if max_ponies <= 0:\n            break\n\n    return max_ponies\n"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        first_line = input().split()\n        n, m = int(first_line[0]), int(first_line[1])\n        p = list(map(int, input().split()))\n        r = list(map(int, input().split()))\n        customers = []\n        for _ in range(n):\n            second_line = input().split()\n            c, t = int(second_line[0]), int(second_line[1])\n            customers.append((c, t))\n        return n, m, p, r, customers\n\n    def calculate_max_customers(n: int, m: int, p: list, r: list, customers: list) -> int:\n        pony_wearing_time = p[customers[0][0] - 1]\n        customers_served = 1\n        for i in range(1, n):\n            customer_arrival_time = customers[i][1]\n            if customer_arrival_time <= pony_wearing_time:\n                customers_served += 1\n            else:\n                pony_wearing_time += r[customers[i][0] - 1]\n                if pony_wearing_time <= customer_arrival_time:\n                    customers_served += 1\n        return customers_served\n\n    n, m, p, r, customers = read_input()\n    max_customers = calculate_max_customers(n, m, p, r, customers)\n    return str(max_customers)"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def read_line(stdin: str, pos: int) -> tuple:\n        if pos >= len(stdin):\n            return None, len(stdin)\n        line, _, pos = read_line(stdin, pos)\n        return tuple(map(int, line.split())), pos\n\n    def read_int(stdin: str, pos: int) -> int:\n        line, pos = read_line(stdin, pos)\n        return line[0]\n\n    def read_array(stdin: str, pos: int, n: int) -> tuple:\n        array = []\n        for i in range(n):\n            line, pos = read_line(stdin, pos)\n            array.append(line[0])\n        return tuple(array), pos\n\n    def can_serve(customers, i, j):\n        return customers[j] >= i\n\n    def serve(customers, clothing, i):\n        j = clothing.index(i)\n        customers[j] -= 1\n\n    N, M = read_int(stdin, 0), read_int(stdin, 1)\n    P, R = read_array(stdin, 2, M)\n    customers = read_array(stdin, 4 + M, N)\n\n    max_customers = 0\n    for i in range(N):\n        for j in range(M):\n            if can_serve(customers, i, j):\n                serve(customers, customers[j], i)\n                max_customers += 1\n\n    return str(max_customers)\n\ninput_data = \"\"\"4 3\n10 20 30\n5 5 10\n2 20\n1 30\n1 32\n3 120\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.splitlines()[0].split())\n    P = list(map(int, stdin.splitlines()[1].split()))\n    R = list(map(int, stdin.splitlines()[2].split()))\n    arrivals = [tuple(map(int, stdin.splitlines()[i+3].split())) for i in range(N)]\n\n    max_served = 0\n    for i in range(1, M+1):\n        pony_put_time = P[i-1]\n        pony_remove_time = R[i-1]\n        pony_i_arrivals = [arrival[0] for arrival in arrivals if arrival[1] == i]\n        sorted_arrivals = sorted(pony_i_arrivals)\n\n        for k, arrival_time in enumerate(sorted_arrivals):\n            put_time = pony_put_time\n            remove_time = pony_remove_time\n            for j in range(k+1, len(sorted_arrivals)):\n                if sorted_arrivals[j] - arrival_time <= put_time + remove_time:\n                    put_time += pony_put_time\n                    remove_time += pony_remove_time\n                else:\n                    break\n            max_served = max(max_served, k+1)\n\n    return str(max_served)\n"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    N, M = map(int, input_list[0].split())\n    P, R = map(int, input_list[1].split()), map(int, input_list[2].split())\n    customers = []\n    for i in range(3, 3 + N):\n        C, T = map(int, input_list[i].split())\n        customers.append((C, T))\n\n    # Sort the customers by their arrival times\n    customers.sort(key=lambda x: x[1])\n\n    # Initialize the maximum number of customers Fluttershy can serve\n    max_served = 0\n\n    # Iterate through the customers, and for each customer, see if Fluttershy can put on and remove the clothing in time\n    for customer in customers:\n        can_serve = True\n        for i in range(1, M + 1):\n            if customer[0] == i:\n                # Check if Fluttershy can put on the clothing in time\n                if customers[0][1] > customer[1] + P[i - 1]:\n                    can_serve = False\n                    break\n                # Check if Fluttershy can remove the clothing in time\n                if customers[max_served][1] + R[i - 1] > customer[1]:\n                    can_serve = False\n                    break\n        if can_serve:\n            max_served += 1\n\n    return str(max_served)"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    P = list(map(int, input_data[1].split()))\n    R = list(map(int, input_data[2].split()))\n    customers = []\n    for i in range(N):\n        customer_data = list(map(int, input_data[3 + i].split()))\n        customers.append(customer_data)\n\n    max_customers = 0\n    for i in range(M):\n        max_customers += len([1 for c in customers if c[0] == i + 1])\n        max_customers += len([1 for c in customers if c[0] == i + 1 and c[1] == 0])\n\n    return max_customers\n\ndef"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def process_input() -> Tuple[int, int, List[int], List[int], List[int], List[Tuple[int, int]]]:\n        N, M = map(int, stdin.readline().split())\n        P = list(map(int, stdin.readline().split()))\n        R = list(map(int, stdin.readline().split()))\n        customers = []\n        for _ in range(N):\n            C, T = map(int, stdin.readline().split())\n            customers.append((C, T))\n        return N, M, P, R, customers\n\n    def max_ponies(N: int, M: int, P: List[int], R: List[int], customers: List[Tuple[int, int]]) -> int:\n        max_served = 0\n        for i in range(N):\n            customer_type, customer_time = customers[i]\n            available = True\n            for j in range(1, M + 1):\n                if customer_type == j:\n                    available = customer_time >= j * P[j - 1]\n                    break\n            max_served += int(available)\n        return max_served\n\n    N, M, P, R, customers = process_input()\n    result = max_ponies(N, M, P, R, customers)\n    return str(result)\n\ninput_data = '''4 3\n10 20 30\n5 5 10\n2 20\n1 30\n1 32\n3 120'''\n\nprint(solution(input_data)) # Output: 3 "
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return gcd(b, a % b)\n\n    def coprime(a, b):\n        return gcd(a, b) == 1\n\n    def generate_pairs(N):\n        pairs = set()\n        for i in range(1, N + 1):\n            for j in range(i + 1, N + 1):\n                pairs.add(frozenset({i, j}))\n        return pairs\n\n    def check_partition(pairs):\n        if N == 1:\n            return False\n        if N == 2:\n            return any(len(pair) == 2 for pair in pairs)\n        if N == 3:\n            return any(len(pair) == 3 for pair in pairs)\n\n        for i in range(2, N + 1):\n            if any(len(pair) == i for pair in pairs):\n                return True\n        return False\n\n    pairs = generate_pairs(N)\n    total_pairs = len(pairs)\n\n    if check_partition(pairs):\n        return str(total_pairs % 1000000000)\n    else:\n        return '0'\n"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    total_sets = 0\n    \n    if N == 1:\n        return \"1\"\n    \n    for i in range(2, N+1):\n        total_sets += i * (i-1) // 2\n        total_sets %= 1000000000\n        \n    return str(total_sets + 1)\n"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    count = 0\n    for i in range(1, N + 1):\n        count += ((N + 1) - i) // 2\n    return str(count % 1000000000)\n\nN = 20\nstdin = \"3\"\nresult = solution(stdin)\nprint(result) "
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    M = 1000000000\n    count = 0\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if gcd(i,j) == 1:\n                count += 1\n    return str(count % M)\n\ndef"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    sets = 0\n    for i in range(2, N + 1):\n        sets += math.comb(N, i)\n    sets *= 2\n    return str(sets % 1000000000)"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    ans = 0\n    for a in range(2, N + 1):\n        for b in range(2, N + 1):\n            if a != b and (a - 1) % b != 0 and (b - 1) % a != 0:\n                ans += 1\n    return str(ans % 1000000000)\n\n\ndef"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    if N == 2:\n        return \"2\"\n    \n    M = 10**9 + 7\n    count = 0\n    for i in range(2, N+1):\n        if i % 2 == 0:\n            count += 2\n        else:\n            count += 3\n    count = count * 4 // 3\n    for i in range(3, N+1, 2):\n        count += i * (i-1) * 2 // 3\n    return str(count % M)"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    elif N == 2:\n        return \"2\"\n    else:\n        return str(int(N * (N - 1) / 2) * (N * (N - 1) * (N - 2) / 6)) % 1000000000"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N = int(input_list[0])\n    count = 0\n    \n    # Count the number of sets of pairs\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if gcd(i, j) == 1:\n                count += 1\n    \n    # Output the required number modulo 1000000000\n    return str(count % 1000000000)\n\ndef"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    \n    count = 0\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            if gcd(i, j) == 1:\n                count += 1\n    \n    return str(count % 1000000007)\n\ndef"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> Tuple[int, int, List[List[int]]]:\n        N, L = map(int, stdin.readline().split())\n        connections = [[0] * N for _ in range(N)]\n        for i in range(N):\n            connections[i] = list(map(int, stdin.readline().split()))\n        return N, L, connections\n\n    def can_reach_B(connections: List[List[int]], visited: List[int], current: int) -> bool:\n        if current == N - 1:\n            return True\n        visited[current] = 1\n        for neighbor, weight in enumerate(connections[current]):\n            if weight != 0 and not visited[neighbor]:\n                if can_reach_B(connections, visited, neighbor):\n                    return True\n        return False\n\n    def dfs(connections: List[List[int]], visited: List[int], current: int, day: int, start_day: int, end_day: int, prob: float, best_result: Tuple[int, float]) -> Tuple[int, float]:\n        if day > end_day:\n            return best_result\n        if day - start_day == 9:\n            return min(best_result, (day - start_day, prob)), best_result\n        if current == N - 1:\n            return min(best_result, (day - start_day, prob)), best_result\n        visited[current] = 1\n        for neighbor, weight in enumerate(connections[current]):\n            if weight != 0 and not visited[neighbor]:\n                new_prob = prob * weight / sum(connections[current])\n                if new_prob >= 0.95:\n                    return dfs(connections, visited, neighbor, day + 1, start_day, end_day, new_prob, (day - start_day, prob))\n                elif new_prob < 0.95:\n                    return dfs(connections, visited, neighbor, day + 1, start_day, end_day, new_prob, best_result)\n        return dfs(connections, visited, current, day + 1, start_day, end_day, prob, best_result)\n\n    N, L, connections = read_input()\n    if N < 3 or L < 1 or L > 10**6:\n        return -1\n    visited = [0] * N\n    start_day, end_day = L, L + 9\n    prob = 1.0\n    best_result = (1000000000, 0.0)\n    if can_reach_B(connections, visited, 0):\n        return dfs(connections, visited, 0, 1, start_day, end_day, prob, best_result)[0]\n    else:\n        return -1"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[0:2])\n    connections = [[0] * N for _ in range(N)]\n    for i in range(1, N):\n        connections[i] = list(map(int, stdin.split()[i]))\n    \n    def dfs(node, visited, stack, time):\n        if time == T and node == N - 1:\n            return True\n        visited[node] = True\n        for i in range(N):\n            if connections[node][i] and not visited[i]:\n                if dfs(i, visited, stack, time + 1):\n                    return True\n        visited[node] = False\n        return False\n\n    def bfs(node):\n        queue = [(node, 0, [False] * N)]\n        while queue:\n            node, time, visited = queue.pop(0)\n            if time == T and node == N - 1:\n                return True\n            for i in range(N):\n                if connections[node][i] and not visited[i]:\n                    new_visited = visited[:]\n                    new_visited[i] = True\n                    queue.append((i, time + 1, new_visited))\n        return False\n\n    for T in range(L, L + 10):\n        if dfs(1, [False] * N, [], 0) and bfs(N - 1):\n            return T\n    return -1"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0:2])\n    connections = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n\n    for i in range(N):\n        if sum(connections[i]) == 0:\n            return -1\n\n    dp = [1] * N\n    for i in range(N):\n        for j in range(N):\n            if connections[j][i]:\n                dp[i] *= (connections[j][i] + 1)\n        dp[i] //= sum(connections[i])\n\n    def calc_prob(t):\n        if t > L + 9:\n            return 0\n        elif t <= 0:\n            return 1\n        else:\n            return sum(dp[i] * calc_prob(t - 1) for i in range(N)) / (N ** (t - 1))\n\n    t = L\n    while True:\n        prob = calc_prob(t)\n        if prob >= 0.95 and prob <= 0.96:\n            return t\n        elif prob > 0.96:\n            return t - 1\n        else:\n            t += 1\n"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, input().split())\n    A = [list(map(int, input().split())) for _ in range(N)]\n\n    # Calculate the probability of reaching B-ville for each day\n    probabilities = [1.0] * N\n    for i in range(N):\n        for j in range(N):\n            if A[i][j] > 0:\n                probabilities[j] *= 1 - 0.05 * (i + 1) / L\n\n    # Find the smallest T such that the probability of reaching B-ville on that day is greater than or equal to 95%\n    T = L + 9\n    while probabilities[N - 1] < 0.95:\n        T -= 1\n        if T < 0:\n            return \"-1\"\n        probabilities = [max(p, 0) + 1.0 for p in probabilities]\n        for i in range(N - 1):\n            probabilities[i] *= (1 - 0.05 * (i + 1) / T)\n\n    return str(T)\n\n\ndef"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[0:2])\n    a = [[0] * N for _ in range(N)]\n    for i in range(N):\n        a[i] = list(map(int, stdin.split()[1 + 2 * i:1 + 2 * (i + 1)]))\n\n    def bellman_ford(graph, start, end, limit):\n        dist = [float('inf')] * N\n        dist[start - 1] = 0\n        for _ in range(N - 1):\n            for u in range(N):\n                for v, w in enumerate(graph[u]):\n                    if w != 0 and dist[u] != float('inf') and dist[v] > dist[u] + w:\n                        dist[v] = dist[u] + w\n        for u in range(N):\n            for v, w in enumerate(graph[u]):\n                if w != 0 and dist[u] != float('inf') and dist[v] > dist[u] + w:\n                    return False\n        return dist[end - 1] <= limit\n\n    for limit in range(L + 9, L, -1):\n        if bellman_ford(a, 1, N, limit):\n            return limit\n    return -1\n"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, input().split())\n    connections = []\n    for i in range(N):\n        connections.append(list(map(int, input().split())))\n\n    def dfs(start, end, visited, depth, target_depth):\n        if depth == target_depth:\n            return 1\n        if visited[start]:\n            return 0\n        visited[start] = True\n        total = 0\n        for i in range(N):\n            if connections[start][i]:\n                total += dfs(i, end, visited, depth + 1, target_depth)\n        return total\n\n    for i in range(N - 1, -1, -1):\n        visited = [False] * N\n        total = dfs(i, N, visited, 0, L + 9)\n        if total * 10 >= L * 95:\n            return i + 1\n\n    return -1\n\n\ndef"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0:2])\n    adj = [[] for _ in range(N)]\n\n    for i in range(N):\n        adj[i] = list(map(int, stdin.split()[2 + 2 * i:2 + 2 * i + N]))\n\n    def backtrack(cur: int, visited: set, depth: int, days: int) -> int:\n        if days >= L:\n            return 1\n        if cur == N - 1:\n            return 1 if days >= L - 9 else 0\n        if days >= L + 9:\n            return 0\n        count = 0\n        for nbr in range(N):\n            if not visited or nbr not in visited:\n                count += backtrack(nbr, visited | {cur}, depth + 1, days + adj[cur][nbr])\n        return count\n\n    total = backtrack(0, {0}, 0, 0)\n    if total == 0:\n        return -1\n    ans = 0\n    for i in range(1, L + 1):\n        total -= backtrack(0, {0}, 0, i)\n        total += backtrack(0, {0, N - 1}, 0, L - i + 9)\n        if total * 10 >= L * 95:\n            ans = i\n            break\n    return ans"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def count_connections(i: int) -> int:\n        return sum(map(int, connections[i]))\n\n    def get_probability(days: int) -> float:\n        prob = 0\n        for i in range(1, N):\n            prob += count_connections(i) * get_probability(days - 1)\n        return prob\n\n    def binary_search(target: float) -> int:\n        left, right = 1, L + 9\n        while left <= right:\n            mid = (left + right) // 2\n            if get_probability(mid) >= target:\n                right = mid - 1\n            else:\n                left = mid + 1\n        return left\n\n    N, L = map(int, stdin.split()[:2])\n    connections = [stdin.split()[1:][i:i + N] for i in range(0, N * N, N)]\n\n    prob = 0\n    for i in range(1, N):\n        prob += count_connections(i) * get_probability(L - 1)\n    target_probability = 0.95\n\n    if prob >= target_probability:\n        T = L\n    else:\n        T = binary_search(target_probability)\n\n    return T if T <= L + 9 else -1"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def uniform_random(probability: float) -> bool:\n        return random.uniform(0, 1) <= probability\n\n    def get_probability(days: int) -> float:\n        probability = 1\n        for i in range(1, N):\n            probability *= (1 - probability_matrix[i][i + 1]) ** days\n        return probability\n\n    N, L = map(int, stdin.split()[0:2])\n    probability_matrix = [list(map(int, stdin.split()[2 + i * N:2 + (i + 1) * N])) for i in range(N - 1)]\n    for i in range(N):\n        probability_matrix[i][i] = 0\n\n    left, right = L, L + 9\n    while right - left > 1:\n        middle = (left + right) // 2\n        if get_probability(middle) >= 0.95:\n            right = middle\n        else:\n            left = middle\n\n    if left == L:\n        return str(-1)\n    return str(left)"
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[0:2])\n    adjacency = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n\n    def dfs(node: int, visited: set[int], depth: int, parent: int) -> tuple[bool, int]:\n        if depth == L + 10:\n            return False, 0\n        if node == N - 1:\n            return True, 1\n        if node == parent:\n            return False, 0\n        visited.add(node)\n        for neighbor in range(N):\n            if adjacency[node][neighbor] > 0 and neighbor not in visited:\n                found, path_length = dfs(neighbor, visited.copy(), depth + 1, node)\n                if found and path_length <= 9:\n                    return True, path_length\n                if found and path_length == 10:\n                    visited.remove(node)\n                    return False, path_length\n        visited.remove(node)\n        return False, 0\n\n    for node in range(N):\n        found, path_length = dfs(node, set(), 0, -1)\n        if found and path_length == 9:\n            return path_length\n    return -1"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict, deque\n    def bfs(graph, source, sink, visited, parents, flow):\n        queue = deque([source])\n        visited[source] = True\n        while queue:\n            u = queue.popleft()\n            for v in graph[u]:\n                if not visited[v] and graph[u][v] - flow[u][v] > 0:\n                    visited[v] = True\n                    parents[v] = u\n                    queue.append(v)\n        return visited[sink]\n\n    def edmonds_karp(graph, source, sink, max_flow):\n        visited = [False] * n\n        parents = [-1] * n\n        flow = defaultdict(dict)\n        for u in range(n):\n            for v in range(n):\n                flow[u][v] = 0\n        total_flow = 0\n        while bfs(graph, source, sink, visited, parents, flow):\n            path_flow = float('Inf')\n            s = sink\n            while s != source:\n                path_flow = min(path_flow, graph[parents[s]][s] - flow[parents[s]][s])\n                s = parents[s]\n            for s in range(n):\n                for t in range(n):\n                    if flow[s][t] < graph[s][t] - flow[s][t]:\n                        flow[s][t] += path_flow\n                        flow[t][s] -= path_flow\n            total_flow += path_flow\n            if total_flow == max_flow:\n                break\n        return total_flow\n\n    stdin = stdin.split('\\n')\n    n, m, source, sink = map(int, stdin.pop(0).split())\n    graph = defaultdict(dict)\n    for _ in range(m):\n        u, v, c = map(int, stdin.pop(0).split())\n        graph[u][v] = c\n    max_flow = 1000000000\n    flow_value = edmonds_karp(graph, source, sink, max_flow)\n    output = [n, flow_value, m]\n    output.extend([0, 1, flow_value])\n    return '\\n'.join(map(str, output))\n\ninput_file = \"input.txt\"\noutput_file = \"output.txt\"\nwith open(input_file, \"r\") as file_in, open(output_file, \"w\") as file_out:\n    input_data = file_in.read()\n    result = solution(input_data)\n    file_out.write(result)"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_max_flow(n: int, m: int, s: int, t: int, edges: list) -> Tuple[int, int, list]:\n        def bfs(source: int, visited: list, distances: list, parent: list):\n            visited[source] = True\n            queue = deque([source])\n            while queue:\n                u = queue.popleft()\n                for v, capacity in graph[u]:\n                    if not visited[v] and distances[u] + 1 < distances[v]:\n                        parent[v] = u\n                        distances[v] = distances[u] + 1\n                        queue.append(v)\n\n        def dfs(u: int, visited: list, flow: int, parent: list) -> int:\n            if u == t:\n                return flow\n            for v, capacity in graph[u]:\n                if visited[v] or distances[u] > distances[v]:\n                    continue\n                new_flow = dfs(v, visited, min(flow, capacity), parent)\n                if new_flow > 0:\n                    graph[u][v][1] -= new_flow\n                    graph[v][u][1] += new_flow\n                    parent[v] = u\n                    return new_flow\n            return 0\n\n        graph = [[] for _ in range(n)]\n        for u, v, capacity in edges:\n            graph[u].append((v, capacity))\n            graph[v].append((u, 0))\n\n        visited = [False] * n\n        distances = [10**9] * n\n        parent = [-1] * n\n        distances[s] = 0\n        bfs(s, visited, distances, parent)\n        max_flow = 0\n        m = 0\n        flow_path = []\n\n        while distances[t] < 10**9:\n            visited = [False] * n\n            flow = dfs(s, visited, 10**9, parent)\n            while flow > 0:\n                m += 1\n                flow_path.append((parent[t], t, flow))\n                max_flow += flow\n                flow = dfs(s, visited, 10**9, parent)\n\n        return max_flow, m, flow_path\n\n    def main(stdin: str) -> str:\n        n, m, s, t = map(int, stdin.split()[:4])\n        s, t = s - 1, t - 1\n        edges = []\n        for _ in range(m):\n            u, v, c = map(int, stdin.split()[4:7])\n            edges.append((u - 1, v - 1, c))\n            stdin = stdin.split('\\n', 4)[-1]\n\n        max_flow, m, flow_path = find_max_flow(n, m, s, t, edges)\n\n        output = f\"{n} {max_flow} {m}\\n\"\n        for u, v, x in flow_path:\n            output += f\"{u} {v} {x}\\n\"\n\n        return output\n\n    return main(stdin) "
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_values = stdin.split(\"\\n\")\n    first_line = input_values[0].split()\n    n, m, s, t = int(first_line[0]), int(first_line[1]), int(first_line[2]), int(first_line[3])\n\n    capacity = {}\n    edges = []\n    for i in range(1, m + 1):\n        line = input_values[i].split()\n        u, v, c = int(line[0]), int(line[1]), int(line[2])\n        capacity[u, v] = c\n        edges.append((u, v, c))\n\n    flow_network = FlowNetwork(n, s, t)\n    for u, v, c in edges:\n        flow_network.add_edge(u, v, c)\n\n    max_flow = flow_network.max_flow()\n\n    output = [f\"{n} {max_flow} {len(edges)}\"]\n    for u, v, flow in flow_network.get_flow():\n        output.append(f\"{u} {v} {flow}\")\n\n    return \"\\n\".join(output)\n\nclass FlowNetwork:\n    def __init__(self, n: int, s: int, t: int):\n        self.n = n\n        self.s = s\n        self.t = t\n        self.graph = [[] for _ in range(n)]\n        self.rev_graph = [[] for _ in range(n)]\n\n    def add_edge(self, u: int, v: int, c: int):\n        self.graph[u].append((v, c))\n        self.rev_graph[v].append((u, c))\n\n    def max_flow(self) -> int:\n        max_flow = 0\n        queue = [(self.s, float('inf'))]\n        level = [-1] * self.n\n\n        while queue:\n            u, prev_level = queue.pop(0)\n            if u == self.t:\n                max_flow = prev_level\n                break\n\n            for v, c in self.graph[u]:\n                residual_capacity = min(c, self.rev_graph[v][0][1])\n                if level[v] == -1 and residual_capacity > 0:\n                    queue.append((v, min(prev_level, residual_capacity)))\n                    level[v] = min(prev_level, residual_capacity)\n\n            level[u] = float('inf')\n\n        return max_flow\n\n    def get_flow(self):\n        flow = []\n        for u, v, c in self.graph[self.s]:\n            flow.append((u, v, c))\n        return flow"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import permutations\n\n    def bfs(graph, source, sink, capacity, visited, distances, parent):\n        queue = [(source, 0, -1)]\n        while queue:\n            vertex, distance, parent_vertex = queue.pop(0)\n            if distances[vertex] < distance:\n                continue\n            if vertex == sink:\n                return True\n            for child, child_capacity in graph[vertex].items():\n                if child not in visited and distances[child] == float(\"inf\"):\n                    visited.add(child)\n                    queue.append((child, distance + 1, vertex))\n                    distances[child] = distance + 1\n                    parent[child] = vertex\n        return False\n\n    def edmonds_karp(graph, source, sink, capacity, parent):\n        visited = set()\n        distances = defaultdict(lambda: float(\"inf\"))\n        distances[source] = 0\n        max_flow = 0\n\n        while bfs(graph, source, sink, capacity, visited, distances, parent):\n            current_flow = float(\"inf\")\n            current_vertex = sink\n            while current_vertex != source:\n                current_flow = min(current_flow, capacity[parent[current_vertex]][current_vertex] - graph[parent[current_vertex]][current_vertex])\n                current_vertex = parent[current_vertex]\n\n            max_flow += current_flow\n            current_vertex = sink\n            while current_vertex != source:\n                graph[parent[current_vertex]][current_vertex] -= current_flow\n                capacity[parent[current_vertex]][current_vertex] -= current_flow\n                graph[current_vertex][parent[current_vertex]] += current_flow\n                capacity[current_vertex][parent[current_vertex]] += current_flow\n                current_vertex = parent[current_vertex]\n\n        return max_flow\n\n    def max_flow(n, m, s, t):\n        capacity = defaultdict(lambda: defaultdict(int))\n        graph = defaultdict(lambda: defaultdict(int))\n        for u, v, c in map(int, stdin.split()):\n            capacity[u][v] = c\n            graph[u][v] = 0\n\n        parent = [-1] * (n + 1)\n        parent[s] = -1\n        for _ in range(m):\n            max_flow_in_graph = edmonds_karp(graph, s, t, capacity, parent)\n            if max_flow_in_graph == 0:\n                break\n\n        return max_flow_in_graph, parent\n\n    n, m, s, t = map(int, stdin.split())\n    max_flow, parent = max_flow(n, m, s, t)\n    edges = defaultdict(list)\n    for u in range(n):\n        for v in range(n):\n            if parent[v] == u:\n                edges[u].append((v, parent[v], capacity[u][v]))\n\n    result = [n, max_flow, len(edges[s])]\n    result.extend([u, v, x] for u, v, x in edges[s])\n    return \"\\n\".join(map(str, result))"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    assert 2 <= n <= 500 and 0 <= m <= 10000 and 0 <= s < n and 0 <= t < n\n\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    assert all(len(edge) == 3 and 1 <= edge[2] <= 10**8 for edge in edges)\n\n    graph = [[] for _ in range(n)]\n    for u, v, c in edges:\n        graph[u].append((v, c))\n\n    def dfs(u: int, visited: set, graph: list, flow: int, path: list) -> int:\n        if u == t:\n            return flow\n        visited.add(u)\n        for v, c in graph[u]:\n            if v not in visited and c >= flow:\n                flow_delta = dfs(v, visited, graph, min(flow, c), path + [u, v])\n                if flow_delta > 0:\n                    return flow_delta\n        return 0\n\n    max_flow = 0\n    path = []\n    while True:\n        visited = set()\n        flow = dfs(s, visited, graph, 10**9, path)\n        if flow == 0:\n            break\n        max_flow += flow\n        while path:\n            u, v = path.pop(), path.pop()\n            graph[u] = [(v, c) if v != u else (v, c - flow) for v, c in graph[u]]\n\n    output = [str(n), str(max_flow)]\n    used_edges = set()\n    for u in range(n):\n        for v, c in graph[u]:\n            if (u, v) not in used_edges and c > 0:\n                output.append(f\"{u} {v} {c}\")\n                used_edges.add((u, v))\n\n    return \"\\n\".join(output) "
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    first_line = input_data[0].split()\n    n, m, s, t = [int(x) for x in first_line]\n    edges = [[int(x) for x in line.split()] for line in input_data[1:]]\n    graph = [[] for _ in range(n)]\n    capacity = [0] * n\n\n    for u, v, c in edges:\n        graph[u].append((v, c))\n        capacity[v] += c\n\n    max_flow = 0\n    flow = [0] * n\n    visited = [False] * n\n\n    def bfs():\n        visited[s] = True\n        queue = [s]\n        while queue and not visited[t]:\n            u = queue.pop(0)\n            for v, c in graph[u]:\n                if not visited[v] and flow[u] < capacity[u] and capacity[v] - flow[v] > 0:\n                    queue.append(v)\n                    visited[v] = True\n\n    while bfs():\n        path_flow = float('inf')\n        u = t\n        while u != s:\n            for v, c in graph[u]:\n                if visited[v] and capacity[v] - flow[v] > 0:\n                    path_flow = min(path_flow, capacity[v] - flow[v])\n            u = visited.index(True, u + 1)\n\n        u = t\n        while u != s:\n            for v, c in graph[u]:\n                if visited[v] and capacity[v] - flow[v] > 0:\n                    flow[u] += path_flow\n                    flow[v] -= path_flow\n            u = visited.index(True, u + 1)\n\n        max_flow += path_flow\n\n    result = [str(n), str(max_flow), str(m)]\n    result.extend([f\"{u} {v} {c}\" for u, v, c in edges if flow[u] > 0])\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    from queue import Queue\n    n, m, s, t = map(int, stdin.split()[:4])\n    graph = [[] for _ in range(n)]\n    capacities = {}\n    for _ in range(m):\n        u, v, c = map(int, stdin.split()[4:])\n        graph[u].append((v, c))\n        capacities[(u, v)] = c\n\n    def bfs(s, t, parent):\n        visited = [False] * n\n        visited[s] = True\n        q = Queue()\n        q.put(s)\n        while not q.empty():\n            u = q.get()\n            for v, c in graph[u]:\n                if not visited[v] and capacities[(u, v)] > 0:\n                    visited[v] = True\n                    parent[v] = u\n                    q.put(v)\n        return visited[t]\n\n    def dfs(u, t, f, parent, used):\n        if u == t:\n            return f\n        for v, c in graph[u]:\n            if not used[v] and capacities[(u, v)] > 0:\n                used[v] = True\n                f_res = dfs(v, t, min(f, capacities[(u, v)]), parent, used)\n                if f_res > 0:\n                    parent[v] = u\n                    return f_res\n        return 0\n\n    parent = [-1] * n\n    used = [False] * n\n    max_flow = 0\n    m_prime = 0\n    while bfs(s, t, parent):\n        used = [False] * n\n        f = dfs(s, t, float('inf'), parent, used)\n        max_flow += f\n        m_prime += m - m_prime\n\n    result = [str(n), str(max_flow), str(m_prime)]\n    for u in range(n):\n        for v, c in graph[u]:\n            if capacities[(u, v)] > 0:\n                result.append(f\"{u} {v} {min(c, max_flow)}\")\n                break\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        first_line = stdin.split('\\n')[0]\n        n, m, s, t = map(int, first_line.split())\n        edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n        return n, m, s, t, edges\n\n    def write_output(n: int, f: int, m: int, flow: list) -> str:\n        result = f\"{n} {f} {m}\\n\"\n        for u, v, x in flow:\n            result += f\"{u} {v} {x}\\n\"\n        return result\n\n    def max_flow(n: int, m: int, s: int, t: int, edges: list) -> tuple:\n        def bfs(graph: list, visited: list, parent: list, level: list):\n            visited[s] = True\n            queue = [s]\n            while queue:\n                u = queue.pop(0)\n                for v, c in graph[u]:\n                    if not visited[v] and level[u] + 1 == level[v]:\n                        queue.append(v)\n                        visited[v] = True\n                        parent[v] = u\n\n        def dfs(graph: list, visited: list, parent: list, level: list, current: int, flow: int, max_flow: list):\n            if current == t:\n                max_flow[0] = min(max_flow[0], flow)\n                return\n            for v, c in graph[current]:\n                if not visited[v] and c - level[current] >= flow:\n                    visited[current] = True\n                    parent[current] = v\n                    dfs(graph, visited, parent, level, v, min(flow, c - level[current]), max_flow)\n                    visited[current] = False\n\n        graph = [[] for _ in range(n)]\n        for u, v, c in edges:\n            graph[u].append((v, c))\n            graph[v].append((u, 0))\n        visited = [False] * n\n        parent = [-1] * n\n        level = [0] * n\n        bfs(graph, visited, parent, level)\n        max_flow[0] = float('inf')\n        dfs(graph, visited, parent, level, s, max_flow[0], max_flow)\n        return max_flow[0], [(u, v, min(c, max_flow[0])) for u, v, c in edges if u != s and v != t]\n\n    n, m, s, t, edges = read_input()\n    flow, flow_edges = max_flow(n, m, s, t, edges)\n    output = write_output(n, flow, m, flow_edges)\n    return output "
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import combinations\n\n    # Parse input\n    lines = stdin.splitlines()\n    n, m, s, t = map(int, lines[0].split())\n    edges = [tuple(map(int, line.split())) for line in lines[1:]]\n\n    # Build the adjacency list\n    adj_list = defaultdict(list)\n    for u, v, c in edges:\n        adj_list[u].append((v, c))\n        adj_list[v].append((u, c))\n\n    # Perform the Ford-Fulkerson algorithm\n    def flow(u: int, t: int, parent: list) -> int:\n        if u == t:\n            return 10**8\n        if parent[u] is not None:\n            return 0\n        parent[u] = t\n        for v, c in adj_list[u]:\n            f = flow(v, t, parent)\n            if f > 0:\n                return min(f, c)\n        parent[u] = None\n        return 0\n\n    # Compute the maximum flow\n    max_flow = 0\n    parent = [None] * n\n    while True:\n        f = flow(s, t, parent)\n        if f == 0:\n            break\n        max_flow += f\n\n    # Compute the maximum flow graph\n    max_flow_graph = []\n    for u in range(n):\n        for v, c in adj_list[u]:\n            x = min(c, max_flow)\n            if x > 0:\n                max_flow_graph.append((u, v, x))\n\n    # Print the output\n    output = [f\"{n} {max_flow} {len(max_flow_graph)}\"]\n    output += [f\"{u} {v} {x}\" for u, v, x in max_flow_graph]\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s, t = map(int, stdin.split()[:4])\n    edges = []\n    for _ in range(m):\n        u, v, c = map(int, stdin.split()[4:7])\n        edges.append((u, v, c))\n    \n    # Build the residual graph\n    residual_graph = [[] for _ in range(n)]\n    for u, v, c in edges:\n        residual_graph[u].append((v, c))\n        residual_graph[v].append((u, 0))\n    \n    # Find a path from s to t in the residual graph\n    def find_path(u, v):\n        visited = [False] * n\n        visited[u] = True\n        path = []\n        stack = [u]\n        while stack:\n            u = stack.pop()\n            if u == v:\n                return True\n            for v, c in residual_graph[u]:\n                if not visited[v] and c > 0:\n                    visited[v] = True\n                    stack.append(v)\n        return False\n    \n    # Find a maximum flow from s to t\n    def maximum_flow(u, v):\n        if u == t:\n            return 1\n        if v == s:\n            return 0\n        for i, (v, c) in enumerate(residual_graph[u]):\n            if c > 0 and find_path(v, t):\n                f = min(maximum_flow(u, v), c)\n                residual_graph[u][i] = (v, c - f)\n                residual_graph[v][-i-1] = (u, f)\n                return f\n        return 0\n    \n    # Compute the maximum flow\n    flow = 0\n    while find_path(s, t):\n        f = maximum_flow(s, t)\n        flow += f\n    \n    # Build the output\n    output = [str(n), str(flow), str(m)]\n    for u, v, c in edges:\n        x = minimum(c, flow)\n        output.append(f\"{u} {v} {x}\")\n    \n    return \"\\n\".join(output)\n\n\ndef"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    board = [input().split() for _ in range(R)]\n    \n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def calculate_spread(piece_type):\n        spread = 0\n        for r in range(R):\n            for c in range(C):\n                if board[r][c] == piece_type:\n                    for dr, dc in [(1, 0), (0, 1), (-1, 0), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]:\n                        if 0 <= r+dr < R and 0 <= c+dc < C and board[r+dr][c+dc] == '.':\n                            spread += manhattan_distance(r, c, r+dr, c+dc)\n        return spread\n\n    mirko_spread = calculate_spread('M')\n    slavko_spread = calculate_spread('S')\n\n    return f\"{mirko_spread} {slavko_spread}\" "
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = [input_str.split() for input_str in stdin.split('\\n')[1:R+1]]\n    \n    def is_valid_move(row, col, board, player):\n        if row < 0 or row >= R or col < 0 or col >= C or board[row][col] == '.':\n            return False\n        if player == 'M':\n            return board[row][col] == 'S'\n        else:\n            return board[row][col] == 'M'\n\n    def min_distance(row1, col1, row2, col2, board):\n        deltas = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n        min_dist = float('inf')\n        for delta in deltas:\n            dist = 0\n            row, col = row1, col1\n            while row != row2 or col != col2:\n                row, col = row + delta[0], col + delta[1]\n                if not is_valid_move(row, col, board, 'M' if dist % 2 == 0 else 'S'):\n                    break\n                dist += 1\n            min_dist = min(min_dist, dist)\n        return min_dist\n\n    mirror_spread = 0\n    slavko_spread = 0\n    for row in range(R):\n        for col in range(C):\n            if board[row][col] == 'M':\n                for delta in [(1, 0), (0, 1)]:\n                    row_neighbour, col_neighbour = row + delta[0], col + delta[1]\n                    if 0 <= row_neighbour < R and 0 <= col_neighbour < C and board[row_neighbour][col_neighbour] == 'S':\n                        mirror_spread += min_distance(row, col, row_neighbour, col_neighbour, board)\n            elif board[row][col] == 'S':\n                for delta in [(1, 0), (0, 1)]:\n                    row_neighbour, col_neighbour = row + delta[0], col + delta[1]\n                    if 0 <= row_neighbour < R and 0 <= col_neighbour < C and board[row_neighbour][col_neighbour] == 'M':\n                        slavko_spread += min_distance(row, col, row_neighbour, col_neighbour, board)\n\n    return f\"{mirror_spread} {slavko_spread}\" "
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = [list(line.strip()) for line in stdin.split('\\n')[1:R+1]]\n\n    def distance(row1, col1, row2, col2):\n        return abs(row1 - row2) + abs(col1 - col2)\n\n    def spread(player):\n        count = 0\n        for row in range(R):\n            for col in range(C):\n                if board[row][col] == player:\n                    for r in range(row-1, row+2):\n                        for c in range(col-1, col+2):\n                            if 0 <= r < R and 0 <= c < C and board[r][c] == '.':\n                                count += distance(row, col, r, c)\n        return count\n\n    return f\"{spread('M')} {spread('S')}\"\n\n\ndef"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = [stdin.split()[2+i:2+i+C] for i in range(R)]\n\n    def distance(a, b):\n        dr, dc = abs(a[0]-b[0]), abs(a[1]-b[1])\n        return min(dr, dc) + min(R-dr, C-dc)\n\n    def spread(board, player):\n        pieces = [(i, j) for i in range(R) for j in range(C) if board[i][j] == player]\n        return sum(distance((i, j), (i+di, j+dj)) for i, j in pieces for di in range(-1, 2) for dj in range(-1, 2) if board[i+di][j+dj] == '.')\n\n    return f\"{spread(board, 'M')} {spread(board, 'S')}\"\n\ndef"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = stdin.split('\\n')[1:]\n    mirko_kings = [(i, j) for i in range(R) for j in range(C) if board[i][j] == 'M']\n    slavko_kings = [(i, j) for i in range(R) for j in range(C) if board[i][j] == 'S']\n\n    def distance(p1, p2):\n        dx = abs(p1[0] - p2[0])\n        dy = abs(p1[1] - p2[1])\n        return min(dx, dy)\n\n    mirko_spread = sum(distance(k1, k2) for k1 in mirko_kings for k2 in mirko_kings if k1 != k2)\n    slavko_spread = sum(distance(k1, k2) for k1 in slavko_kings for k2 in slavko_kings if k1 != k2)\n\n    return f\"{mirko_spread} {slavko_spread}\""
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = [list(input()) for _ in range(R)]\n\n    def min_moves(a, b):\n        r1, c1 = a\n        r2, c2 = b\n        return min(abs(r1 - r2), abs(c1 - c2))\n\n    def distance(player, enemy):\n        return sum(min_moves(p, e) for e in enemy for p in player)\n\n    def spread(player):\n        enemy = set()\n        for r in range(R):\n            for c in range(C):\n                if board[r][c] == '.':\n                    enemy.add((r, c))\n        return distance(player, enemy)\n\n    mirko_pieces = [(r, c) for r in range(R) for c in range(C) if board[r][c] == 'M']\n    slavko_pieces = [(r, c) for r in range(R) for c in range(C) if board[r][c] == 'S']\n\n    return f\"{spread(mirko_pieces)} {spread(slavko_pieces)}\"\n"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = stdin.split('\\n')[1:R+1]\n\n    def distance(a, b):\n        dr = abs(a[0] - b[0])\n        dc = abs(a[1] - b[1])\n        return min(dr, dc) + max(dr, dc)\n\n    def spread(player, opponent):\n        pieces = [(i, j) for i in range(R) for j in range(C) if board[i][j] == player]\n        total = 0\n        for p in pieces:\n            for q in pieces:\n                if p != q:\n                    total += distance(p, q)\n        return total\n\n    return str(spread('M', 'S')) + ' ' + str(spread('S', 'M'))\n"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    board = [list(line) for line in stdin.split('\\n')[1:R+1]]\n    mirko_spread = 0\n    slavko_spread = 0\n    \n    for r in range(R):\n        for c in range(C):\n            if board[r][c] == 'M':\n                mirko_spread += get_spread(board, r, c)\n            elif board[r][c] == 'S':\n                slavko_spread += get_spread(board, r, c)\n    \n    return str(mirko_spread) + ' ' + str(slavko_spread)\n\ndef"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    R, C, board = read_input(stdin)\n    mirko_spread, slavko_spread = 0, 0\n    mirko_pieces, slavko_pieces = [], []\n\n    for i in range(R):\n        for j in range(C):\n            if board[i][j] == 'M':\n                mirko_pieces.append((i, j))\n            elif board[i][j] == 'S':\n                slavko_pieces.append((i, j))\n\n    mirko_pieces_dist = get_pieces_dist(mirko_pieces, board, R, C)\n    slavko_pieces_dist = get_pieces_dist(slavko_pieces, board, R, C)\n\n    for i in range(len(mirko_pieces_dist)):\n        for j in range(len(slavko_pieces_dist)):\n            mirko_spread += min(mirko_pieces_dist[i], slavko_pieces_dist[j])\n            slavko_spread += min(mirko_pieces_dist[i], slavko_pieces_dist[j])\n\n    return str(mirko_spread) + ' ' + str(slavko_spread)\n\ndef"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    R, C, board = None, None, []\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            R, C = map(int, line.split())\n        else:\n            board.append(list(line))\n\n    def manhattan_distance(row1, col1, row2, col2):\n        return abs(row1 - row2) + abs(col1 - col2)\n\n    def calculate_spread(player):\n        spread = 0\n        for row in range(R):\n            for col in range(C):\n                if board[row][col] == player:\n                    for r, c in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]:\n                        if 0 <= row+r < R and 0 <= col+c < C:\n                            if board[row+r][col+c] == player:\n                                spread += manhattan_distance(row, col, row+r, col+c)\n                            elif board[row+r][col+c] != player and board[row+r][col+c] != '.':\n                                spread += manhattan_distance(row, col, row+r, col+c)\n        return spread\n\n    return f\"{calculate_spread('M')} {calculate_spread('S')}\""
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_tree(tree: List[str]) -> bool:\n        \"\"\"Checks if the given tree is a valid elderberry tree.\"\"\"\n        for line in tree:\n            if line.count('$') != 1 or line.count('T') + line.count('G') + line.count('E') != 3:\n                return False\n        return True\n\n    def find_leaf(tree: List[str], vertex: int) -> int:\n        \"\"\"Finds the first leaf of a vertex in the elderberry tree.\"\"\"\n        for line in tree:\n            if line.startswith(f'{vertex} '):\n                return int(line.split()[1])\n        return -1\n\n    def find_subtree(tree: List[str], vertex: int) -> int:\n        \"\"\"Finds the parent of a vertex in the elderberry tree.\"\"\"\n        for line in tree:\n            if line.endswith(f' {vertex}'):\n                return int(line.split()[0])\n        return -1\n\n    def find_label(tree: List[str], vertex: int) -> str:\n        \"\"\"Finds the label of a vertex in the elderberry tree.\"\"\"\n        for line in tree:\n            if line.startswith(f'{vertex} '):\n                return line.split()[2]\n        return ''\n\n    def find_controlled_area(tree: List[str], vertex: int) -> int:\n        \"\"\"Finds the controlled area of a vertex in the elderberry tree.\"\"\"\n        for line in tree:\n            if line.startswith(f'{vertex} '):\n                return find_subtree(tree, int(line.split()[1]))\n        return -1\n\n    def find_small_branches(tree: List[str]) -> List[int]:\n        \"\"\"Finds all small branches in the elderberry tree.\"\"\"\n        small_branches = []\n        for line in tree:\n            if line.startswith('0 '):\n                continue\n            if line.startswith('1 '):\n                small_branches.append(find_subtree(tree, 1))\n            elif line.endswith('B'):\n                small_branches.append(int(line.split()[0]))\n        return small_branches\n\n    def find_giant_birds(tree: List[str]) -> List[int]:\n        \"\"\"Finds all giant birds in the elderberry tree.\"\"\"\n        giant_birds = []\n        for line in tree:\n            if line.startswith('0 '):\n                continue\n            if line.endswith('G'):\n                giant_birds.append(int(line.split()[0]))\n        return giant_birds\n\n    def change_label(tree: List[str], vertex: int, new_label: str) -> None:\n        \"\"\"Changes the label of a vertex in the elderberry tree.\"\"\"\n        for i, line in enumerate(tree):\n            if line.startswith(f'{vertex} '):\n                tree[i] = line.split()[0] + ' ' + new_label + '\\n'\n                break\n\n    def solve(tree: List[str]) -> str:\n        if not is_valid_tree(tree):\n            raise ValueError(\"Invalid elderberry tree\")\n\n        giant_birds = find_giant_birds(tree)\n        small_branches = find_small_branches(tree)\n\n        labels_changed = {}\n        for vertex in giant_birds:\n            controlled_area = find_controlled_area(tree, vertex)\n            label = find_label(tree, vertex)\n            new_label = ''\n            for i in range(len(label)):\n                new_label += chr((ord(label[i]) - ord('a') + (ord('z') - ord('a') + 1)) % (ord('z') - ord('a') + 1))\n            if new_label not in labels_changed:\n                labels_changed[new_label] = (find_leaf(tree, controlled_area), vertex)\n                change_label(tree, vertex, new_label)\n\n        k = len(labels_changed)\n        if k == 0:\n            return \"0\\n\"\n\n        result = [f\"{k}\\n\"]\n        for new_label, (leaf"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def parent(i: int) -> int:\n        return int(line[i])\n\n    def is_leaf(i: int) -> bool:\n        return line[i + 1] in ('G', 'T', 'E')\n\n    def has_label(i: int, label: str) -> bool:\n        return line[i + 1] == label\n\n    def is_giant_branch(i: int) -> bool:\n        return line[i + 1] == 'B'\n\n    def set_label(i: int, label: str) -> None:\n        line[i + 1] = label\n\n    def labels_satisfy_rules() -> bool:\n        for i in range(1, n + 1):\n            if line[i + 1] == '':\n                continue\n            if line[i] == 'S' and line[i + 1] in bird_labels:\n                return False\n            if line[i] == 'G' and line[i + 1] in tiny_bird_labels:\n                return False\n            if line[i] == 'T' and line[i + 1] in tiny_bird_labels:\n                return False\n            if line[i] == 'T' and line[i + 1] in giant_bird_labels:\n                return False\n            if line[i] == 'E' and line[i + 1] in elderberry_labels:\n                return False\n        return True\n\n    def get_minimum_label_changes() -> int:\n        for i in range(1, n + 1):\n            if line[i] == 'S' and is_leaf(i):\n                tiny_birds.add(i)\n            if line[i] == 'G' and is_leaf(i):\n                giant_birds.add(i)\n            if line[i] == 'T' and is_leaf(i):\n                tiny_bird_labels.add(line[i + 1])\n            if line[i] == 'E' and is_leaf(i):\n                elderberry_labels.add(line[i + 1])\n\n        for i in range(1, n + 1):\n            if line[i] == 'S' and is_leaf(i):\n                giant_birds.add(i)\n            if line[i] == 'G' and is_leaf(i):\n                tiny_bird_labels.add(line[i + 1])\n\n        for i in range(1, n + 1):\n            if line[i] == 'S' and is_leaf(i):\n                tiny_bird_labels.add(line[i + 1])\n            if line[i] == 'T' and is_leaf(i):\n                giant_bird_labels.add(line[i + 1])\n            if line[i] == 'E' and is_leaf(i):\n                elderberry_labels.add(line[i + 1])\n\n        return sum(1 for x in tiny_birds if labels_satisfy_rules())\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    line = input_data[1].split()\n\n    tiny_bird_labels = set()\n    giant_bird_labels = set()\n    elderberry_labels = set()\n    tiny_birds = set()\n\n    get_minimum_label_changes()\n\n    output = [str(get_minimum_label_changes())]\n    for _ in range(get_minimum_label_changes()):\n        max_label_change = (0, '')\n        for i in range(1, n + 1):\n            if line[i] == 'S' and is_leaf(i):\n                if has_label(i, max_label_change[1]) and len(max_label_change[1]) < 5:\n                    max_label_change = (i, line[i + 1])\n        set_label(max_label_change[0], max_label_change[1])\n        output.append(f'{max_label_change[0]} {max_label_change[1]}')\n\n    return '\\n'.join(output)"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    parent = [0] * (n + 1)\n    bird_control = [0] * (n + 1)\n    berry_owner = [0] * (n + 1)\n    giant_birds = set()\n    tiny_birds = set()\n    elderberries = set()\n    labels = {}\n\n    for line in data:\n        if len(line) == 2:\n            parent[int(line.split(' ')[1])] = int(line.split(' ')[0])\n        elif len(line) == 4:\n            label, vertex, control = line.split(' ')\n            if label not in labels:\n                labels[label] = [0, set()]\n            labels[label][0] += 1\n            labels[label][1].add(vertex)\n            if control == 'G':\n                giant_birds.add(vertex)\n            elif control == 'T':\n                tiny_birds.add(vertex)\n            elif control == 'E':\n                elderberries.add(vertex)\n\n    # First, find the optimal solution\n    min_label_changes = n\n    for label in labels:\n        if len(labels[label][1]) > 1:\n            min_label_changes = min(min_label_changes, labels[label][0])\n\n    # Second, find the new labels for the optimal solution\n    new_labels = {}\n    for label in labels:\n        if len(labels[label][1]) == 1:\n            vertex = next(iter(labels[label][1]))\n            new_labels[label] = vertex\n\n    # Third, find the new labels for the giant birds\n    for vertex in giant_birds:\n        parent_vertex = parent[vertex]\n        while parent_vertex not in giant_birds and parent_vertex not in tiny_birds:\n            parent_vertex = parent[parent_vertex]\n        new_labels['a'] = str(vertex)\n\n    # Fourth, find the new labels for the elderberries\n    elderberries_left = elderberries.copy()\n    for label in labels:\n        for vertex in elderberries_left:\n            if vertex in labels[label][1]:\n                elderberries_left.remove(vertex)\n                new_labels[label] = vertex\n                break\n\n    # Finally, print the solution\n    print(min_label_changes)\n    for vertex in elderberries_left:\n        label = new_labels['a']\n        new_labels['a'] = str(vertex)\n        print(vertex, label)\n        new_labels['a'] = label"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    def get_child(vertices: List[str], v: int) -> int:\n        for i in range(len(vertices)):\n            if vertices[i][-1] == 'G' and vertices[i].endswith(v):\n                return i\n            elif vertices[i][-1] == 'T' and vertices[i].startswith(str(v)):\n                return i\n        return -1\n\n    def get_label(birds: List[str], berries: List[str], v: int) -> Tuple[str, int]:\n        for i in range(len(birds)):\n            if birds[i].startswith(str(v)):\n                for j in range(len(berries)):\n                    if berries[j].endswith(birds[i][1:]) and birds[i] != berries[j]:\n                        return birds[i][1:], j\n        return '', -1\n\n    def get_new_label(label: str) -> str:\n        return ''.join(sorted(label))\n\n    def get_minimum_changes(input_data: List[str]) -> int:\n        vertices = []\n        for line in input_data:\n            if line.endswith('B'):\n                vertices.append(line)\n        birds = [line for line in vertices if line.endswith('G') or line.endswith('T')]\n        berries = [line for line in vertices if line.endswith('E')]\n\n        control_area = {v: [] for v in range(1, len(vertices) + 1)}\n        for v in range(1, len(vertices) + 1):\n            if vertices[v].endswith('B'):\n                control_area[v].append(v)\n            else:\n                child = get_child(vertices, v)\n                if child != -1:\n                    control_area[v].append(child)\n                control_area[v] = sorted(set(control_area[v]))\n\n        changed = []\n        for i in range(1, len(birds)):\n            label, j = get_label(birds, berries, i)\n            new_label = get_new_label(label)\n            if new_label != label:\n                changed.append((i, new_label))\n                control_area[i] = control_area[i + j]\n        return len(changed)\n\n    def is_valid(input_data: List[str]) -> bool:\n        vertices = []\n        for line in input_data:\n            if line.endswith('B'):\n                vertices.append(line)\n        birds = [line for line in vertices if line.endswith('G') or line.endswith('T')]\n        berries = [line for line in vertices if line.endswith('E')]\n\n        for v in range(1, len(vertices) + 1):\n            if vertices[v].endswith('B'):\n                child = get_child(vertices, v)\n                if child == -1:\n                    return False\n\n        for bird in birds:\n            for berry in berries:\n                if bird.endswith(berry[1:]) and bird != berry:\n                    return False\n        return True\n\n    def is_optimal(input_data: List[str]) -> bool:\n        return is_valid(input_data) and get_minimum_changes(input_data) <= 1\n\n    n = int(stdin.split()[0])\n    input_data = stdin.split('\\n')[1:]\n    input_data = [line.strip() for line in input_data]\n\n    if not is_valid(input_data):\n        return \"Invalid Input\"\n\n    minimum_changes = get_minimum_changes(input_data)\n    if minimum_changes == 0:\n        return \"No Label Changes Needed\"\n\n    if is_optimal(input_data):\n        return f\"{minimum_changes}\"\n    else:\n        changed = []\n        for i in range(1, len(birds)):\n            label, j = get_label(birds, berries, i)\n            if label != '':\n                changed.append((i, label, berries[j][1:]))\n        changed.sort(key=lambda x: x"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    root = None\n    tree = {}\n    labels = {}\n\n    def get_parent(vertex):\n        return tree[vertex][0]\n\n    def get_child(vertex):\n        return tree[vertex][1:]\n\n    def add_vertex(vertex, parent, branch_type):\n        if vertex in tree:\n            return\n        tree[vertex] = [parent] + branch_type\n\n    def has_leaf(vertex):\n        return 'E' in tree[vertex]\n\n    def has_label(vertex, label):\n        return label in labels.get(vertex, set())\n\n    def set_label(vertex, label):\n        if vertex not in labels:\n            labels[vertex] = set()\n        labels[vertex].add(label)\n\n    def get_label(vertex):\n        return labels.get(vertex, set())\n\n    def is_valid_label_change(vertex, old_label, new_label):\n        if has_leaf(vertex):\n            return has_label(vertex, new_label)\n        return any(is_valid_label_change(child, old_label, new_label) for child in get_child(vertex))\n\n    def change_label(vertex, old_label, new_label):\n        set_label(vertex, new_label)\n        if has_leaf(vertex):\n            return\n        for child in get_child(vertex):\n            change_label(child, old_label, new_label)\n\n    for line in data:\n        parent, branch_type, *label = line.split()\n        parent = int(parent)\n        label = ''.join(label)\n        vertex = len(tree) + 1\n        add_vertex(vertex, parent, branch_type)\n        set_label(vertex, label)\n\n    def get_min_label_change_cost(vertex):\n        if has_leaf(vertex):\n            return 0\n        return min(get_min_label_change_cost(child) for child in get_child(vertex)) + 1\n\n    def find_best_label_change(vertex):\n        if has_leaf(vertex):\n            return vertex, None\n        min_cost = float('inf')\n        best_child = None\n        for child in get_child(vertex):\n            cost = get_min_label_change_cost(child)\n            if cost < min_cost:\n                min_cost = cost\n                best_child = child\n        return find_best_label_change(best_child)\n\n    def get_label_change_cost(vertex, old_label, new_label):\n        if has_leaf(vertex):\n            return 1\n        return sum(get_label_change_cost(child, old_label, new_label) for child in get_child(vertex)) + 1\n\n    min_label_change_cost = get_min_label_change_cost(root)\n    k = min_label_change_cost\n    best_label_change = find_best_label_change(root)\n    best_label_changes = []\n    while k > 0 and best_label_change:\n        vertex, old_label = best_label_change\n        new_label = 'a' if old_label == 'b' else 'b'\n        if is_valid_label_change(vertex, old_label, new_label):\n            change_label(vertex, old_label, new_label)\n            best_label_changes.append((vertex, new_label))\n            k -= 1\n        best_label_change = find_best_label_change(root)\n\n    if not best_label_changes:\n        return '0\\n'\n\n    result = f'{len(best_label_changes)}\\n'\n    for vertex, new_label in best_label_changes:\n        result += f'{vertex} {new_label}\\n'\n\n    return result\n\ninput_data = '''\n13\n0 B\n1 B\n2 E a\n2 E b\n2 S\n5 G a\n5 T a\n5 E a\n5 E"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n = int(input_list[0])\n    node_list = [input_list[i] for i in range(1, n+1)]\n    change_count = 0\n    bird_label_dict = {}\n    berry_label_dict = {}\n    giant_bird_set = set()\n    tiny_bird_set = set()\n    elderberry_set = set()\n    for node in node_list:\n        node_info = node.split()\n        if len(node_info) == 2:\n            parent, branch_type = node_info\n            if branch_type == 'B':\n                giant_bird_set.add(parent)\n            else:\n                tiny_bird_set.add(parent)\n        else:\n            parent, branch_type, label = node_info\n            if branch_type == 'G':\n                giant_bird_set.add(parent)\n            elif branch_type == 'T':\n                tiny_bird_set.add(parent)\n            else:\n                elderberry_set.add(parent)\n            if branch_type == 'E':\n                if label in bird_label_dict:\n                    print(\"Error: Label already exists\")\n                    return\n                if label in berry_label_dict:\n                    print(\"Error: Label already exists\")\n                    return\n                if label in bird_label_dict.values():\n                    print(\"Error: Label already exists\")\n                    return\n                if label in berry_label_dict.values():\n                    print(\"Error: Label already exists\")\n                    return\n                if len(label) > 5:\n                    print(\"Error: Label length exceeds 5\")\n                    return\n                if branch_type == 'E':\n                    bird_label_dict[parent] = label\n                else:\n                    berry_label_dict[parent] = label\n\n    for label in elderberry_set:\n        if label not in bird_label_dict.values() and label not in berry_label_dict.values():\n            print(\"Error: Label not found\")\n            return\n\n    for label in bird_label_dict.values():\n        if label in elderberry_set:\n            print(\"Error: Label already exists\")\n            return\n\n    for label in berry_label_dict.values():\n        if label in elderberry_set:\n            print(\"Error: Label already exists\")\n            return\n\n    for label in elderberry_set:\n        if label in bird_label_dict.values():\n            change_count += 1\n\n    if change_count > 0:\n        for i in range(1, n+1):\n            if i in elderberry_set:\n                continue\n            if i in giant_bird_set:\n                if bird_label_dict[i] != 'a':\n                    change_count += 1\n            elif i in tiny_bird_set:\n                if bird_label_dict[i] != 'b':\n                    change_count += 1\n            else:\n                if bird_label_dict[i] != 'c':\n                    change_count += 1\n\n    if change_count > 0:\n        for i in range(1, n+1):\n            if i in elderberry_set:\n                print(i, berry_label_dict[i])\n            elif i in giant_bird_set:\n                print(i, 'c')\n            elif i in tiny_bird_set:\n                print(i, 'b')\n            else:\n                print(i, 'a')\n    else:\n        print(0)"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    tree_dict = {}\n    for i in range(1, len(input_list)):\n        line = input_list[i]\n        if len(line) == 3:\n            parent, type, label = line.split()\n            parent = int(parent)\n            tree_dict[i] = {'parent': parent, 'type': type, 'label': label}\n        elif len(line) == 4:\n            parent, type, label = line.split()\n            parent = int(parent)\n            tree_dict[i] = {'parent': parent, 'type': type, 'label': label}\n        elif len(line) == 2:\n            parent, label = line.split()\n            parent = int(parent)\n            tree_dict[i] = {'parent': parent, 'type': 'E', 'label': label}\n\n    giant_branches = [i for i in tree_dict if tree_dict[i]['type'] == 'B']\n    giant_branches_set = set(giant_branches)\n    giant_branch_dict = {i: tree_dict[i]['parent'] for i in tree_dict if tree_dict[i]['type'] == 'B'}\n\n    # calculate the minimum number of labels to change\n    label_change_count = 0\n    label_change_set = set()\n    for i in tree_dict:\n        if tree_dict[i]['type'] == 'G':\n            parent_node = i\n            label_stack = [tree_dict[i]['label']]\n            while parent_node != 0:\n                parent_node = giant_branch_dict[parent_node]\n                label_stack.append(tree_dict[parent_node]['label'])\n\n            label_stack.reverse()\n            for j in range(len(label_stack) - 1):\n                if label_stack[j] == label_stack[j + 1]:\n                    label_change_set.add(i)\n                    label_change_count += 1\n                    break\n\n    # calculate the new labels\n    new_label_set = set()\n    for i in range(1, n + 1):\n        if i not in label_change_set:\n            new_label_set.add(tree_dict[i]['label'])\n\n    new_label_list = list(new_label_set)\n    random.shuffle(new_label_list)\n\n    # create the output\n    output_list = [str(label_change_count)]\n    for i in label_change_set:\n        new_label = new_label_list.pop()\n        output_list.append(f\"{i} {new_label}\")\n\n    output = '\\n'.join(output_list)\n    return output\n\nimport random"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(v: int, parent: int, branch: str) -> str:\n        if v == 0:\n            return 'B'\n        if is_leaf[v]:\n            if labels[v] == '':\n                labels[v] = next_label\n                next_label = chr(ord(next_label) + 1)\n            return labels[v]\n        if branch == 'B' and v > 1:\n            branch = 'S'\n        child_branch = branch\n        for c in range(1, v):\n            if parent[c] == v:\n                child_branch = dfs(c, v, child_branch)\n                if child_branch == 'S':\n                    break\n        subtree_branch = dfs(v, parent[v], child_branch)\n        if child_branch == 'B':\n            subtree_branch = 'S'\n        return subtree_branch\n\n    def dfs_count_changes(v: int, parent: int, branch: str) -> int:\n        if v == 0:\n            return 0\n        if is_leaf[v]:\n            if labels[v] == '':\n                labels[v] = next_label\n                next_label = chr(ord(next_label) + 1)\n                changed[0] += 1\n            return 1\n        if branch == 'B' and v > 1:\n            branch = 'S'\n        child_branch = branch\n        count = 0\n        for c in range(1, v):\n            if parent[c] == v:\n                count += dfs_count_changes(c, v, child_branch)\n                if child_branch == 'S':\n                    break\n        subtree_branch = dfs_count_changes(v, parent[v], child_branch)\n        if child_branch == 'B':\n            subtree_branch = 'S'\n        return count + 1\n\n    n = int(stdin.split('\\n', 1)[0])\n    lines = stdin.split('\\n')[1:]\n    parent = [0] * (n + 1)\n    is_leaf = [False] * (n + 1)\n    labels = [''] * (n + 1)\n    next_label = 'a'\n    changed = [0]\n    for line in lines:\n        if line.startswith('0'):\n            continue\n        v = int(line[:line.index(' ')])\n        if 'T' in line:\n            is_leaf[v] = True\n        if 'G' in line:\n            labels[v] = line.split(' ')[-1]\n        if 'E' in line:\n            labels[v] = line.split(' ')[-1]\n        if 'B' in line:\n            parent[v] = int(line.split(' ')[-1])\n    min_changes = n\n    for v in range(1, n + 1):\n        if is_leaf[v]:\n            subtree_branch = dfs(v, parent[v], 'S')\n            if subtree_branch == 'B':\n                subtree_branch = 'S'\n            changed[0] = 0\n            count = dfs_count_changes(v, parent[v], subtree_branch)\n            min_changes = min(min_changes, count - 1)\n    return min_changes"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    # Initialize tree\n    tree = {0: {'type': 'B', 'children': [], 'label': None, 'berries': []}}\n    for line in input_data[1:]:\n        parts = line.split()\n        if len(parts) == 2:\n            # This is a branch\n            parent, branch_type = int(parts[0]), parts[1]\n            tree[parent]['children'].append(len(tree))\n            tree[len(tree)] = {'type': branch_type, 'children': [], 'label': None, 'berries': []}\n        else:\n            # This is a leaf\n            parent, label, label_type = int(parts[0]), parts[2], parts[1]\n            tree[parent]['children'].append(len(tree))\n            tree[len(tree)] = {'type': label_type, 'children': [], 'label': label, 'berries': [parent]}\n    \n    # Initialize labels\n    labels = {}\n    for i, node in tree.items():\n        if node['type'] in {'E', 'T'}:\n            if node['label'] not in labels:\n                labels[node['label']] = [i]\n            else:\n                labels[node['label']].append(i)\n    \n    # Determine optimal label changes\n    k = 0\n    changed_labels = []\n    for label, bird_indices in labels.items():\n        if len(bird_indices) < 2:\n            continue\n        if len(bird_indices) % 2 == 0:\n            for i in range(0, len(bird_indices), 2):\n                if tree[bird_indices[i]]['type'] != 'G' or tree[bird_indices[i+1]]['type'] != 'G':\n                    k += 1\n                    changed_labels.append((bird_indices[i], 'c'))\n                    changed_labels.append((bird_indices[i+1], 'c'))\n                    break\n        else:\n            k += 1\n            changed_labels.append((bird_indices[0], 'c'))\n            changed_labels.append((bird_indices[1], 'c'))\n    \n    # Return the solution\n    return str(k) + '\\n' + '\\n'.join([str(i) + ' ' + label for i, label in changed_labels])"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *edges = stdin.split(\"\\n\")\n    n = int(n)\n\n    # Build the tree\n    tree = [[] for _ in range(n + 1)]\n    for edge in edges:\n        parent, child = map(int, edge.split())\n        tree[parent].append(child)\n\n    # Count the number of birds\n    giant_bird_count = sum(1 for vertex in range(1, n + 1) if tree[vertex] and \"G\" == edges[vertex - 1][1])\n    tiny_bird_count = n - giant_bird_count\n\n    # Find the label of the giant birds\n    giant_labels = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    giant_labels = giant_labels[:giant_bird_count]\n\n    # Generate the labels of the tiny birds\n    tiny_labels = [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"x\", \"y\", \"z\"]\n    tiny_labels = [label for label in tiny_labels if label not in giant_labels]\n\n    # Assign labels to the tiny birds\n    for vertex in range(1, n + 1):\n        if tree[vertex] and \"G\" == edges[vertex - 1][1]:\n            for child in tree[vertex]:\n                if \"T\" == edges[child - 1][1]:\n                    for berry in range(1, n + 1):\n                        if \"E\" == edges[berry - 1][1] and berry != child:\n                            edges[berry - 1] = edges[berry - 1][:1] + tiny_labels.pop()\n\n    # Calculate the minimum number of labels to change\n    changed_labels = 0\n    for vertex in range(1, n + 1):\n        if tree[vertex] and \"T\" == edges[vertex - 1][1]:\n            for child in tree[vertex]:\n                if \"T\" == edges[child - 1][1]:\n                    for berry in range(1, n + 1):\n                        if \"E\" == edges[berry - 1][1] and berry != child:\n                            if edges[berry - 1][1] == edges[child - 1][1]:\n                                changed_labels += 1\n\n    # Generate the list of vertices to change\n    vertices_to_change = []\n    for vertex in range(1, n + 1):\n        if tree[vertex] and \"T\" == edges[vertex - 1][1]:\n            for child in tree[vertex]:\n                if \"T\" == edges[child - 1][1]:\n                    for berry in range(1, n + 1):\n                        if \"E\" == edges[berry - 1][1] and berry != child:\n                            if edges[berry - 1][1] == edges[child - 1][1]:\n                                vertices_to_change.append(child)\n\n    # Output the solution\n    return str(changed_labels) + \"\\n\" + \"\\n\".join(f\"{vertex} {edges[vertex - 1][1]}\" for vertex in vertices_to_change)\n"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    total_sum = 0\n\n    for i in range(A, B + 1):\n        num = str(i).zfill(len(str(B)))\n        distance = sum(abs(int(num[i]) - int(num[i-1])) for i in range(1, len(num)))\n        total_sum += distance\n\n    return str(total_sum % 1000000007)\n"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    total_sum = 0\n    \n    for i in range(A, B + 1):\n        for j in range(A, B + 1):\n            num1 = str(i).zfill(len(str(j)))\n            num2 = str(j).zfill(len(str(i)))\n            distance = sum(abs(int(num1[k]) - int(num2[k])) for k in range(len(num1)))\n            total_sum += distance\n    \n    return str(total_sum % 1000000007)\n"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n\n    def distance(x: int, y: int) -> int:\n        x, y = str(x).zfill(max(len(str(x)), len(str(y)))), str(y).zfill(max(len(str(x)), len(str(y)))))\n        return sum(abs(int(a) - int(b)) for a, b in zip(x, y))\n\n    return str(sum(distance(x, y) for x in range(A, B + 1) for y in range(A, B + 1))) % (10**7 + 7)\n"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, input().split())\n    mod = 1000000007\n    count = 0\n    for i in range(A, B+1):\n        j = i\n        while j > 0:\n            digit_i = j % 10\n            j = j // 10\n            digit_j = 0\n            while j > 0:\n                digit_j = j % 10\n                j = j // 10\n                count += abs(digit_i - digit_j)\n                count %= mod\n            j = i\n    return str(count)\n\ndef"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    mod = 1000000007\n    total_sum = 0\n\n    for num1 in range(A, B + 1):\n        num1 = str(num1).zfill(len(str(B)))\n        for num2 in range(A, B + 1):\n            num2 = str(num2).zfill(len(str(B)))\n            distance = sum(abs(int(num1[i]) - int(num2[i])) for i in range(len(num1)))\n            total_sum += distance\n            total_sum %= mod\n\n    return str(total_sum)"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    mod = 1000000007\n    result = 0\n\n    for i in range(max(A, B), min(A, B) - 1, -1):\n        j = i\n        while j > 0:\n            a, b = j % 10, i % 10\n            result += abs(a - b)\n            j //= 10\n            i //= 10\n\n    return str(result % mod)"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    mod = 1000000007\n    \n    def distance(a: int, b: int) -> int:\n        return sum(abs(int(d) - int(e)) for d, e in zip(str(a), str(b).zfill(len(str(a)))))\n    \n    total_distance = sum(distance(a, b) for a in range(A, B+1) for b in range(A, B+1))\n    return str(total_distance % mod)\n\ninput_str = \"4 7\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    count = 0\n    for num1 in range(A, B+1):\n        num2 = num1\n        if len(str(num1)) < len(str(num2)):\n            num2 = num1 * 10**(len(str(num1)) - len(str(num2)))\n        distance = sum(abs(int(digit1) - int(digit2)) for digit1, digit2 in zip(str(num1), str(num2)))\n        count += distance\n    return str(count % 1000000007)\n\n\ninput_file = open(\"input_file.txt\", \"r\")\noutput_file = open(\"output_file.txt\", \"w\")\n\nstdin = input_file.read()\nresult = solution(stdin)\noutput_file.write(result)\n\ninput_file.close()\noutput_file.close() "
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    count = 0\n    \n    for num in range(A, B+1):\n        num_str = str(num)\n        max_len = len(str(B))\n        num_str = num_str.zfill(max_len)\n        \n        for i in range(max_len):\n            count += abs(int(num_str[i]) - int(num_str[(i+1) % max_len]))\n            \n    return str(count % 1000000007)\n"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    modulo = 1000000007\n    distance = 0\n\n    for number in range(A, B + 1):\n        # convert number to string and pad with leading zeroes\n        number_str = str(number).zfill(max(len(str(A)), len(str(B))) + 1)\n        for digit in number_str:\n            distance += abs(int(digit) - (number_str.index(digit) % 10))\n        distance %= modulo\n\n    return str(distance)\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_shortest_path(start: str, end: str, words: set) -> str:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, steps = queue.pop(0)\n            if current == end:\n                return steps\n            if current in visited:\n                continue\n            visited.add(current)\n\n            for i in range(len(current)):\n                for j in range(26):\n                    next_word = current[:i] + chr(ord('A') + j) + current[i + 1:]\n                    if next_word in words:\n                        queue.append((next_word, steps + 1))\n\n        return -1\n\n    def add_word_to_dictionary(dictionary: set, word: str) -> str:\n        for i in range(len(word)):\n            for j in range(26):\n                new_word = word[:i] + chr(ord('A') + j) + word[i + 1:]\n                if new_word not in dictionary:\n                    return new_word\n        return \"\"\n\n    n = int(stdin.readline().strip())\n    dictionary = set(stdin.readlines())\n    start = next(iter(dictionary))\n    end = next(iter(dictionary))\n\n    added_word = add_word_to_dictionary(dictionary, end)\n    if added_word:\n        words = dictionary | {added_word}\n    else:\n        words = dictionary\n\n    shortest_path = find_shortest_path(start, end, words)\n\n    if shortest_path == -1:\n        return \"0\\n-1\"\n    else:\n        return added_word + \"\\n\" + str(shortest_path)\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    test_cases = stdin.strip().split(\"\\n\")\n    n = int(test_cases[0])\n    dictionary = set(test_cases[1:n+1])\n    start = test_cases[n+1]\n    end = test_cases[n+2]\n\n    def is_valid(word):\n        for i in range(len(word)):\n            if word[i] != start[i]:\n                return False\n        return True\n\n    def bfs(start, end, dictionary):\n        queue = [(start, 0, [])]\n        visited = set()\n\n        while queue:\n            current, steps, path = queue.pop(0)\n            if current == end:\n                return steps, path\n            if (current, steps) not in visited:\n                visited.add((current, steps))\n                for i in range(len(current)):\n                    for letter in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                        new_word = current[:i] + letter + current[i+1:]\n                        if new_word in dictionary and is_valid(new_word):\n                            queue.append((new_word, steps+1, path+[new_word]))\n\n    result = bfs(start, end, dictionary)\n\n    if result:\n        steps, path = result\n        if steps == -1:\n            return 0, -1\n        if len(path) == 1:\n            return 0, steps\n        else:\n            for word in sorted(path):\n                if is_valid(word):\n                    return word, steps\n    else:\n        return 0, -1\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def find_next_word(word: str, target: str, visited: set, current_steps: int) -> str:\n        if word == target:\n            return word, current_steps\n        \n        for i in range(len(word)):\n            for char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                next_word = word[:i] + char + word[i+1:]\n                if next_word not in visited:\n                    visited.add(next_word)\n                    result = find_next_word(next_word, target, visited, current_steps + 1)\n                    if result:\n                        return result\n            visited.remove(word)\n        return None\n\n    n = int(stdin.splitlines()[0])\n    dictionary = set(stdin.splitlines()[1:])\n    start_word = sorted(dictionary)[0]\n    end_word = sorted(dictionary)[1]\n    visited = set()\n    result = find_next_word(start_word, end_word, visited, 0)\n    if result:\n        return result[0], result[1]\n    else:\n        return 0, -1\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    dictionary = set(input_list[1:n+1])\n    start = input_list[n+1]\n    end = input_list[n+2]\n    \n    if start == end:\n        return \"0\\n0\"\n    \n    for i in range(len(start)):\n        if start[i] != end[i]:\n            new_word = start[:i] + end[i] + start[i+1:]\n            if new_word in dictionary:\n                return new_word + \"\\n\" + str(i+1)\n                \n    return \"0\\n-1\"\n\ndef"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(word: str) -> bool:\n        for char in word:\n            if char not in dictionary:\n                return False\n        return True\n\n    def min_steps(start: str, end: str) -> int:\n        queue = [(start, 0)]\n        visited = set()\n\n        while queue:\n            current, steps = queue.pop(0)\n            if current == end:\n                return steps\n            if current not in visited:\n                visited.add(current)\n                for i in range(len(current)):\n                    for char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n                        new_word = current[:i] + char + current[i+1:]\n                        if is_valid(new_word) and new_word not in visited:\n                            queue.append((new_word, steps + 1))\n\n    dictionary = set(stdin.strip().split('\\n')[2:])\n    start, end = stdin.strip().split('\\n')[:2]\n\n    for word in dictionary:\n        if word[0] == start[0]:\n            min_steps_to_end = min_steps(word, end)\n            if min_steps_to_end == 1:\n                return word + '\\n1'\n\n    for i in range(len(start)):\n        for char in 'ABCDEFGHIJKLMNOPQRSTUVWXYZ':\n            new_word = start[:i] + char + start[i+1:]\n            if new_word in dictionary:\n                min_steps_to_end = min_steps(new_word, end)\n                if min_steps_to_end >= 0:\n                    return new_word + '\\n' + str(min_steps_to_end + 1)\n\n    return '0\\n-1'"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    dictionary = set(input_list[1:n+1])\n    start, end = input_list[n+1].upper(), input_list[n+2].upper()\n\n    for i in range(len(start)):\n        for j in range(26):\n            word = start[:i] + chr(ord('A') + j) + start[i+1:]\n            if word in dictionary:\n                ladder = [word]\n                for k in range(i, len(start)):\n                    for l in range(26):\n                        next_word = word[:k] + chr(ord('A') + l) + word[k+1:]\n                        if next_word == end:\n                            ladder.append(next_word)\n                            return ladder[-1], len(ladder) - 1\n                        elif next_word in dictionary:\n                            ladder.append(next_word)\n                            word = next_word\n                break\n        else:\n            continue\n        break\n    else:\n        return \"0\", -1\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    dictionary = set(input_list[1:])\n    start_word = input_list[1]\n    end_word = input_list[2]\n\n    def bfs(start, end, visited, queue):\n        while queue:\n            current_word = queue.pop(0)\n            if current_word == end:\n                return visited\n            for i in range(len(current_word)):\n                for j in range(26):\n                    new_word = current_word[:i] + chr(ord('A') + j) + current_word[i + 1:]\n                    if new_word in dictionary:\n                        queue.append(new_word)\n                        visited.add(new_word)\n        return visited\n\n    def shortest_path(start, end, dictionary):\n        visited = set()\n        queue = [start]\n        shortest_path = None\n        min_steps = -1\n\n        while queue:\n            current_word = queue.pop(0)\n            visited.add(current_word)\n            if current_word == end:\n                return current_word, len(visited) - 1\n\n            for i in range(len(current_word)):\n                for j in range(26):\n                    new_word = current_word[:i] + chr(ord('A') + j) + current_word[i + 1:]\n                    if new_word in dictionary:\n                        queue.append(new_word)\n                        if shortest_path is None or len(shortest_path) > len(new_word):\n                            shortest_path = new_word\n                            min_steps = len(visited) + 1\n\n        return shortest_path, min_steps\n\n    if start_word == end_word:\n        return \"COG\"\n\n    visited = bfs(start_word, end_word, set(), [start_word])\n\n    if end_word in visited:\n        return \"COG\"\n    elif \"COG\" in visited:\n        return \"COG\"\n    else:\n        new_word, min_steps = shortest_path(start_word, end_word, dictionary)\n        return new_word, min_steps"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split('\\n')\n    n = int(input_list[0])\n    dictionary = input_list[1:]\n    start_word = dictionary[0]\n    end_word = dictionary[1]\n\n    def is_valid(word: str) -> bool:\n        return all(word in dictionary for word in word_list)\n\n    def find_shortest_path(start: str, end: str) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, step = queue.pop(0)\n            if current == end:\n                return step\n            if current not in visited:\n                visited.add(current)\n                for i in range(len(current)):\n                    for letter in string.ascii_uppercase:\n                        new_word = current[:i] + letter + current[i+1:]\n                        if new_word not in visited and is_valid(new_word):\n                            queue.append((new_word, step + 1))\n        return -1\n\n    word_list = [word for word in dictionary if word != start_word and word != end_word]\n    shortest_path = find_shortest_path(start_word, end_word)\n    if shortest_path == -1:\n        return \"0\\n-1\"\n    else:\n        shortest_path_word = \"\".join(sorted(set(word_list + [start_word, end_word]) - set(word_list)))[0])\n        return shortest_word + \"\\n\" + str(shortest_path)\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\"\\n\")\n    num_words = int(input_list[0])\n    dictionary = input_list[1:num_words+1]\n    start_word = input_list[num_words+1]\n    end_word = input_list[num_words+2]\n\n    def is_possible(word1, word2):\n        if len(word1) != len(word2):\n            return False\n        diff_count = 0\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                diff_count += 1\n        return diff_count == 1\n\n    def bfs(start, end):\n        queue = [(start, 0)]\n        visited = set([start])\n        level = 0\n        while queue:\n            level += 1\n            new_queue = []\n            for node, cost in queue:\n                if node == end:\n                    return level\n                for neighbor in dictionary:\n                    if neighbor not in visited and is_possible(node, neighbor):\n                        new_queue.append((neighbor, cost+1))\n                        visited.add(neighbor)\n            queue = new_queue\n        return -1\n\n    for word in dictionary:\n        if is_possible(start_word, word):\n            level = bfs(start_word, word)\n            if level > 0:\n                level += bfs(word, end_word)\n                if level > 0:\n                    return word, level\n\n    return \"0\", -1 "
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(word, used_words):\n        for used_word in used_words:\n            if used_word == word:\n                return True\n            if len(used_word) == len(word):\n                diff_count = 0\n                for i in range(len(word)):\n                    if word[i] != used_word[i]:\n                        diff_count += 1\n                if diff_count == 1:\n                    return True\n        return False\n\n    def bfs(start, end, used_words):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, steps = queue.pop(0)\n            if current == end:\n                return steps\n            if current not in visited:\n                visited.add(current)\n                for next_word in used_words:\n                    if current + next_word not in visited and is_valid(current + next_word, used_words):\n                        queue.append((current + next_word, steps + 1))\n        return -1\n\n    lines = stdin.splitlines()\n    n = int(lines[0])\n    words = lines[1:n + 1]\n    start, end = words[0], words[1]\n    used_words = set(words)\n    for word in words:\n        for i in range(len(word)):\n            for char in \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\":\n                new_word = word[:i] + char + word[i + 1:]\n                used_words.add(new_word)\n    min_steps = float('inf')\n    min_word = \"\"\n    for word in used_words:\n        if is_valid(word, words):\n            steps = bfs(start, end, words | {word})\n            if steps >= 0 and steps < min_steps:\n                min_steps = steps\n                min_word = word\n    return min_word, min_steps\n"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    mod = 1000000007\n    dp = [1] * (N+1)\n    dp[0] = 1\n    \n    for i in range(1, N+1):\n        for j in range(1, i+1):\n            if j == i:\n                dp[i] = 1\n            else:\n                dp[i] += dp[j] * dp[i-j]\n                dp[i] %= mod\n                \n    return dp[N] * pow(dp[C], mod-2, mod) % mod\n"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, input().split())\n\n    MOD = 1000000007\n    dp = [1] * (N + 1)\n\n    for i in range(2, N + 1):\n        for j in range(1, i):\n            dp[i] += dp[j] * dp[i - j]\n            dp[i] %= MOD\n\n    result = dp[N]\n    for i in range(1, N + 1):\n        if i * (N - i) == C:\n            result = (result * pow(dp[i] * dp[N - i], MOD - 2, MOD)) % MOD\n    return result\n"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    M = 1000000007\n    if C == 0:\n        return str((M-1) * (M-2) // 2 % M)\n    if N == 1:\n        return str(C * (C-1) // 2 % M)\n    if C == 1:\n        return str((M-1) * (M-2) // 2 % M)\n    dp = [0] * (C+1)\n    dp[0] = 1\n    dp[1] = 1\n    for i in range(2, N+1):\n        for j in range(2, C+1):\n            dp[j] = (dp[j] + dp[j-1]) % M\n    return str(dp[C])\n"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n\n    # Generate the factorial of N\n    factorial = 1\n    for i in range(1, N + 1):\n        factorial *= i\n\n    # Calculate the number of sequences\n    result = factorial\n    result //= C + 1\n    result //= factorial // (N - C)\n\n    return str(result % 1000000007)"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    MOD = 1000000007\n    result = 0\n    if C == 0:\n        return (((N * (N - 1)) // 2) % MOD)\n    for i in range(1, N + 1):\n        result += i * (N - i)\n        result %= MOD\n    return (result * (C - 1)) % MOD\n\nstdin = \"10 1\"\nprint(solution(stdin))\n\nstdin = \"4 3\"\nprint(solution(stdin)) "
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    M = 1000000007\n    dp = [1] * (N+1)\n    dp[1] = 0\n    for i in range(2, N+1):\n        for j in range(1, i):\n            dp[i] += dp[i-j] * dp[j-1]\n            dp[i] %= M\n    ans = dp[N] * dp[C]\n    ans %= M\n    return str(ans)"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n\n    dp = [0] * (N + 1)\n    dp[1] = 1\n\n    for i in range(2, N + 1):\n        for j in range(1, i):\n            dp[i] += dp[j] * dp[i - j - 1]\n        dp[i] %= 1000000007\n\n    return dp[N]\n\n\ndef"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    N, C = map(int, input_str.split())\n\n    MOD = 1000000007\n\n    def count_sequences(N, C):\n        # Number of sequences of length N with no confusion\n        # = 1 (first number is 1) * N (choose any number from 1 to N)\n        no_confusion = 1 * N\n\n        # Number of sequences of length N with 1 confusion\n        # = (Number of sequences of length N-1 with no confusion) * N (choose a number to add confusion to)\n        one_confusion = count_sequences(N - 1, C - 1) * N\n\n        # Number of sequences of length N with 2 confusion\n        # = (Number of sequences of length N-1 with no confusion) * (N choose 2) (choose 2 numbers to add confusion to)\n        two_confusion = count_sequences(N - 1, C - 2) * N * (N - 1) // 2\n\n        # Number of sequences of length N with C confusion\n        # = (Number of sequences of length N-1 with no confusion) * (N choose C) (choose C numbers to add confusion to)\n        # + (Number of sequences of length N-1 with 1 confusion) * (C choose 1) (choose 1 number to add confusion to)\n        # + (Number of sequences of length N-1 with 2 confusion) * (C choose 2) (choose 2 numbers to add confusion to)\n        # ...\n        # + (Number of sequences of length N-1 with C-1 confusion) * (C choose C-1) (choose C-1 numbers to add confusion to)\n        all_confusion = count_sequences(N - 1, C - 1) * comb(N, C)\n\n        # Total number of sequences of length N with C or more confusion\n        # = (Number of sequences of length N with no confusion)\n        # + (Number of sequences of length N with 1 confusion)\n        # + (Number of sequences of length N with 2 confusion)\n        # ...\n        # + (Number of sequences of length N with C-1 confusion)\n        return (no_confusion + one_confusion + two_confusion + all_confusion) % MOD\n\n    return str(count_sequences(N, C))"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    result = 0\n\n    for n in range(1, N+1):\n        k = n\n        for c in range(C):\n            result += k\n            k = (k * (N - n)) // N\n        result %= 1000000007\n\n    return str(result)\n\n\ndef"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    result = 1\n    for i in range(N):\n        result *= N - i\n        result %= 1000000007\n    result = pow(result, C, 1000000007)\n    return result"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_gargoyle(gargoyle: str) -> str:\n        new_gargoyle = \"\"\n        for i in range(len(gargoyle)):\n            if gargoyle[i] == 'V':\n                new_gargoyle += '/'\n            elif gargoyle[i] == '/':\n                new_gargoyle += 'V'\n            else:\n                new_gargoyle += gargoyle[i]\n        return new_gargoyle\n\n    def is_valid_configuration(n: int, m: int, floorplan: str) -> bool:\n        # Check if the floorplan is valid\n        for i in range(n):\n            if len(floorplan[i]) != m:\n                return False\n            if len(set(floorplan[i])) != 3:\n                return False\n\n        # Check if the gargoyles can be rotated to create a path\n        rotated_floorplan = floorplan[:]\n        for i in range(n):\n            for j in range(m):\n                if rotated_floorplan[i][j] == 'V':\n                    rotated_floorplan[i] = rotated_floorplan[i][:j] + '/' + rotated_floorplan[i][j + 1:]\n                elif rotated_floorplan[i][j] == '/':\n                    rotated_floorplan[i] = rotated_floorplan[i][:j] + 'V' + rotated_floorplan[i][j + 1:]\n                elif rotated_floorplan[i][j] == 'H':\n                    rotated_floorplan[i] = rotated_floorplan[i][:j] + '\\\\' + rotated_floorplan[i][j + 1:]\n                elif rotated_floorplan[i][j] == '\\\\':\n                    rotated_floorplan[i] = rotated_floorplan[i][:j] + 'H' + rotated_floorplan[i][j + 1:]\n\n        # Check if the gargoyles can be rotated to create a path\n        for i in range(n):\n            for j in range(m):\n                if rotated_floorplan[i][j] == 'V' or rotated_floorplan[i][j] == '/':\n                    if (i + 1 < n) and (rotated_floorplan[i + 1][j] == 'V' or rotated_floorplan[i + 1][j] == '/'):\n                        return True\n                    if (j + 1 < m) and (rotated_floorplan[i][j + 1] == 'V' or rotated_floorplan[i][j + 1] == '/'):\n                        return True\n                elif rotated_floorplan[i][j] == 'H' or rotated_floorplan[i][j] == '\\\\':\n                    if (i - 1 >= 0) and (rotated_floorplan[i - 1][j] == 'H' or rotated_floorplan[i - 1][j] == '\\\\'):\n                        return True\n                    if (j - 1 >= 0) and (rotated_floorplan[i][j - 1] == 'H' or rotated_floorplan[i][j - 1] == '\\\\'):\n                        return True\n        return False\n\n    n, m = map(int, stdin.split()[0:2])\n    floorplan = [list(stdin.split()[2 + i]) for i in range(n)]\n\n    min_rotations = 0\n    for i in range(n):\n        for j in range(m):\n            if floorplan[i][j] == 'V':\n                floorplan[i][j] = '/'\n                if not is_valid_configuration(n, m, floorplan):\n                    floorplan[i][j] = 'V'\n                    min_rotations += 1\n                else:\n                    min_rotations += 1\n            elif floorplan[i][j] == 'H':\n                floorplan[i][j] = '\\\\'\n                if not is_valid_configuration(n, m, floorplan):\n                    floorplan[i][j] = 'H'\n                    min_rotations += 1\n                else:\n                    min_rot"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    floorplan = stdin.split()[1:]\n    if n > 500 or m > 500:\n        return \"Invalid input: n and m must be between 1 and 500\"\n\n    def is_valid_path(path):\n        if len(path) != n + m:\n            return False\n        for i in range(n):\n            if path[i] != floorplan[i][i]:\n                return False\n        for i in range(m):\n            if path[n + i] != floorplan[n - 1][i]:\n                return False\n        return True\n\n    def rotate_gargoyles(rotations):\n        for _ in range(rotations):\n            for i in range(n):\n                for j in range(m):\n                    if floorplan[i][j] == 'V':\n                        floorplan[i][j] = 'H'\n                    elif floorplan[i][j] == 'H':\n                        floorplan[i][j] = 'V'\n\n    def is_mirror_wall(x, y):\n        if floorplan[x][y] == '/':\n            if x % 2 == 0:\n                return y % 2 == 0\n            else:\n                return y % 2 == 1\n        elif floorplan[x][y] == '\\\\':\n            if x % 2 == 0:\n                return y % 2 == 1\n            else:\n                return y % 2 == 0\n        return False\n\n    def is_valid_mirror_wall(x, y):\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            while 0 <= nx < n and 0 <= ny < m:\n                if floorplan[nx][ny] == '#':\n                    return False\n                if floorplan[nx][ny] == '/' or floorplan[nx][ny] == '\\\\':\n                    if is_mirror_wall(nx, ny):\n                        return True\n                    else:\n                        return False\n                nx, ny = nx + dx, ny + dy\n        return False\n\n    def has_path(path):\n        queue = [(0, 0)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) not in visited:\n                visited.add((x, y))\n                if is_valid_path(path + [x * m + y]):\n                    return True\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = x + dx, y + dy\n                    if 0 <= nx < n and 0 <= ny < m and floorplan[nx][ny] != '#':\n                        queue.append((nx, ny))\n        return False\n\n    def find_min_rotations():\n        min_rotations = float('inf')\n        for i in range(n):\n            for j in range(m):\n                if floorplan[i][j] == 'V' or floorplan[i][j] == 'H':\n                    for k in range(4):\n                        rotations = k + (k % 2) * 2\n                        rotate_gargoyles(rotations)\n                        if has_path([i * m + j]):\n                            min_rotations = min(min_rotations, rotations)\n        return min_rotations\n\n    min_rotations = find_min_rotations()\n    if min_rotations == float('inf'):\n        return \"No solution\"\n    else:\n        return min_rotations"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, m, floorplan = None, None, []\n\n    # Read input\n    n, m = map(int, stdin.split()[0].split())\n    for i in range(1, n+1):\n        floorplan.append(stdin.split()[i])\n\n    # Initialize variables\n    gargoyles = {'V': 0, 'H': 0}\n    rotated_gargoyles = 0\n    mirrors = {'/': 0, '\\\\': 0}\n    obstacles = 0\n\n    # Count number of gargoyles, mirrors, and obstacles\n    for row in floorplan:\n        for cell in row:\n            if cell == '#':\n                obstacles += 1\n            elif cell in ['V', 'H']:\n                gargoyles[cell] += 1\n            elif cell in ['/', '\\\\']:\n                mirrors[cell] += 1\n\n    # Check if the puzzle has a solution\n    if (gargoyles['V'] + gargoyles['H']) % 2 == 1:\n        return -1\n\n    # Calculate the minimum number of gargoyles that have to be rotated\n    rotated_gargoyles = max(gargoyles['V'], gargoyles['H']) // 2\n\n    return rotated_gargoyles"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    tomb = [input_lines[i][:m] for i in range(1, n + 1)]\n\n    def is_valid_path(path, x, y):\n        for dx, dy in path:\n            if x < 0 or x >= n or y < 0 or y >= m:\n                return False\n            if tomb[x][y] == '#' or tomb[x][y] == '/' or tomb[x][y] == '\\\\':\n                return False\n            if tomb[x][y] == 'V' and (dx, dy) != (0, 1):\n                return False\n            if tomb[x][y] == 'H' and (dx, dy) != (1, 0):\n                return False\n            x += dx\n            y += dy\n        return True\n\n    def count_rotations():\n        gargoyles = []\n        for i in range(n):\n            for j in range(m):\n                if tomb[i][j] in 'VH':\n                    gargoyles.append((i, j))\n\n        min_rotations = 0\n        for i, (x, y) in enumerate(gargoyles):\n            for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                path = [(dx, dy)]\n                while is_valid_path(path, x, y):\n                    min_rotations = max(min_rotations, len(path))\n                    path.append((dx, dy))\n                    x += dx\n                    y += dy\n        return min_rotations\n\n    if n == 1 and m == 1 and tomb[0][0] == 'V':\n        return 0\n    else:\n        rotations = count_rotations()\n        return rotations if rotations != float('inf') else -1\n"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    tomb = [list(line.strip()) for line in stdin.split('\\n')[1:n+1]]\n    gargoyles = set()\n    walls = set()\n    obstacles = set()\n    for i in range(n):\n        for j in range(m):\n            if tomb[i][j] == '#':\n                obstacles.add((i, j))\n            elif tomb[i][j] in ['V', 'H']:\n                gargoyles.add((i, j))\n            elif tomb[i][j] in ['/', '\\\\']:\n                walls.add((i, j))\n    gargoyles = list(gargoyles)\n    n_gargoyles = len(gargoyles)\n    rotated = set()\n    min_rotations = float('inf')\n\n    def is_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and (x, y) not in obstacles\n\n    def rotate(gargoyle, direction):\n        x, y = gargoyle\n        if direction == 'H':\n            new_gargoyle = (x, (y + 1) % m) if (x, (y + 1) % m) != gargoyle else (x, (y - 1) % m)\n        else:\n            new_gargoyle = ((x + 1) % n, y) if ((x + 1) % n, y) != gargoyle else ((x - 1) % n, y)\n        return new_gargoyle\n\n    def find_path(start, end):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            (x, y), dist = queue.pop(0)\n            if (x, y) == end:\n                return dist\n            if (x, y) not in visited and is_valid(x, y):\n                for direction in ['H', 'V']:\n                    new_gargoyle = rotate((x, y), direction)\n                    if new_gargoyle not in visited:\n                        queue.append((new_gargoyle, dist + 1))\n            visited.add((x, y))\n        return float('inf')\n\n    for gargoyle in gargoyles:\n        for direction in ['H', 'V']:\n            new_gargoyle = rotate(gargoyle, direction)\n            if new_gargoyle not in gargoyles and new_gargoyle not in rotated:\n                min_rotations = min(min_rotations, find_path(gargoyle, new_gargoyle))\n                rotated.add(new_gargoyle)\n\n    return str(min_rotations) if min_rotations != float('inf') else '-1'\n"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    floorplan = stdin.split()[1:]\n\n    def rotate_gargoyle(gargoyle: str) -> str:\n        return gargoyle.translate(str.maketrans(\"VH\", \"HV\"))\n\n    def check_gargoyle_solution(gargoyle: str) -> bool:\n        if gargoyle in ('.', '#'):\n            return True\n        elif gargoyle in ('V', 'H'):\n            return False\n        else:\n            return gargoyle in (rotate_gargoyle(gargoyle), rotate_gargoyle(rotate_gargoyle(gargoyle)), rotate_gargoyle(rotate_gargoyle(rotate_gargoyle(gargoyle))))\n\n    def check_mirror_solution(cell: str, i: int, j: int, visited: set) -> bool:\n        if (i, j) in visited:\n            return False\n        visited.add((i, j))\n\n        if cell in ('.', '#'):\n            return True\n        elif cell in ('V', 'H'):\n            return False\n        elif cell in ('\\\\', '/'):\n            i_mirror, j_mirror = i - 1, j\n            if cell == '/':\n                i_mirror, j_mirror = j, i_mirror\n            return check_mirror_solution(floorplan[i_mirror][j_mirror], i_mirror, j_mirror, visited)\n        else:\n            return any(check_mirror_solution(floorplan[i + di][j + dj], i + di, j + dj, visited) for di, dj in ((0, 1), (1, 0), (1, 1), (1, -1), (0, -1), (-1, 0), (-1, -1), (-1, 1)))\n\n    def count_rotations(gargoyles: set) -> int:\n        return sum(1 if check_gargoyle_solution(gargoyle) else 0 for gargoyle in gargoyles)\n\n    gargoyles = {gargoyle for row in floorplan for gargoyle in row if gargoyle in ('V', 'H')}\n    rotations = 0\n    while not all(check_gargoyle_solution(gargoyle) for gargoyle in gargoyles):\n        rotations += 1\n        gargoyles = {rotate_gargoyle(gargoyle) for gargoyle in gargoyles}\n\n    if rotations == 0:\n        return \"-1\"\n\n    rotated_floorplan = [''.join([rotate_gargoyle(cell) if cell in ('V', 'H') else cell for cell in row] for row in floorplan)]\n    for i in range(n):\n        for j in range(m):\n            if not check_mirror_solution(rotated_floorplan[i][j], i, j, set()):\n                return rotations + count_rotations(gargoyles)\n\n    return rotations + count_rotations(gargoyles)\n"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, m, *floorplan = stdin.strip().split()\n    n, m = int(n), int(m)\n    floorplan = [list(line) for line in floorplan]\n\n    def rotate_gargoyle(x, y, direction):\n        if floorplan[x][y] != 'V' and floorplan[x][y] != 'H':\n            return\n\n        if floorplan[x][y] == 'V':\n            floorplan[x][y] = 'H'\n        else:\n            floorplan[x][y] = 'V'\n\n        if direction == 'left':\n            rotate_gargoyle(x, y - 1, 'right')\n        elif direction == 'right':\n            rotate_gargoyle(x, y + 1, 'left')\n        elif direction == 'top':\n            rotate_gargoyle(x - 1, y, 'bottom')\n        elif direction == 'bottom':\n            rotate_gargoyle(x + 1, y, 'top')\n\n    def can_connect(x1, y1, x2, y2):\n        if x1 < 0 or x1 >= n or y1 < 0 or y1 >= m:\n            return False\n        if x2 < 0 or x2 >= n or y2 < 0 or y2 >= m:\n            return False\n\n        if floorplan[x1][y1] == '#' or floorplan[x2][y2] == '#':\n            return False\n\n        dx, dy = x2 - x1, y2 - y1\n        if dx == 0:\n            if dy == 1:\n                direction = 'top'\n            else:\n                direction = 'bottom'\n        elif dy == 0:\n            if dx == 1:\n                direction = 'right'\n            else:\n                direction = 'left'\n        else:\n            return False\n\n        if floorplan[x1][y1] == 'H':\n            if direction == 'right':\n                direction = 'bottom'\n            else:\n                direction = 'top'\n        elif floorplan[x1][y1] == 'V':\n            if direction == 'bottom':\n                direction = 'right'\n            else:\n                direction = 'left'\n\n        for i in range(x1 + 1, x2):\n            if floorplan[i][y1] == '#':\n                return False\n            rotate_gargoyle(i, y1, direction)\n\n        return True\n\n    def is_valid():\n        for x in range(n):\n            for y in range(m):\n                if floorplan[x][y] == '#' and not can_connect(x, y, x - 1, y):\n                    return False\n                if floorplan[x][y] == '#' and not can_connect(x, y, x + 1, y):\n                    return False\n                if floorplan[x][y] == '#' and not can_connect(x, y, x, y - 1):\n                    return False\n                if floorplan[x][y] == '#' and not can_connect(x, y, x, y + 1):\n                    return False\n\n        return True\n\n    def min_gargoyles():\n        gargoyles = 0\n        for x in range(n):\n            for y in range(m):\n                if floorplan[x][y] == 'V' or floorplan[x][y] == 'H':\n                    gargoyles += 1\n        return gargoyles\n\n    if not is_valid():\n        return -1\n\n    return min_gargoyles()\n"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    floorplan = stdin.split(\"\\n\")[1:]\n\n    def rotate_gargoyle(cell: str, x: int, y: int) -> str:\n        if cell == \"V\":\n            return \"H\"\n        elif cell == \"H\":\n            return \"V\"\n        return cell\n\n    def is_valid(x: int, y: int) -> bool:\n        if 0 <= x < n and 0 <= y < m:\n            return True\n        return False\n\n    def can_connect(x1: int, y1: int, x2: int, y2: int) -> bool:\n        if not is_valid(x1, y1) or not is_valid(x2, y2):\n            return False\n        if floorplan[x1][y1] == \"/\" or floorplan[x2][y2] == \"\\\\\":\n            return True\n        return False\n\n    def count_gargoyles() -> int:\n        return sum(1 for row in floorplan for cell in row if cell in \"VH\")\n\n    def min_rotations() -> int:\n        gargoyles = count_gargoyles()\n        if gargoyles == 0:\n            return 0\n        min_rotations = gargoyles\n        for x, row in enumerate(floorplan):\n            for y, cell in enumerate(row):\n                if cell in \"VH\":\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        if can_connect(x, y, x + dx, y + dy) and floorplan[x + dx][y + dy] != \" \":\n                            min_rotations = min(min_rotations, 2)\n                        else:\n                            min_rotations = min(min_rotations, 1)\n        return min_rotations\n\n    result = min_rotations()\n    if result == float(\"inf\"):\n        return \"-1\"\n    return str(result)"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, m, floorplan = \"\", \"\", \"\"\n    for i, line in enumerate(stdin.split('\\n')):\n        if i == 0:\n            n, m = map(int, line.split())\n        else:\n            floorplan += line\n\n    def is_valid_position(x, y):\n        if x < 0 or x >= n or y < 0 or y >= m:\n            return False\n        if floorplan[y][x] in '#VH':\n            return False\n        return True\n\n    def count_valid_positions(x, y):\n        count = 0\n        if is_valid_position(x + 1, y) and floorplan[y][x + 1] == '/':\n            count += 1\n        if is_valid_position(x - 1, y) and floorplan[y][x - 1] == '/':\n            count += 1\n        if is_valid_position(x, y + 1) and floorplan[y + 1][x] == '\\\\':\n            count += 1\n        if is_valid_position(x, y - 1) and floorplan[y - 1][x] == '\\\\':\n            count += 1\n        return count\n\n    def is_obstacle(x, y):\n        if floorplan[y][x] in '#VH':\n            return True\n        if x - 1 >= 0 and floorplan[y][x - 1] in '/\\\\':\n            return True\n        if x + 1 < m and floorplan[y][x + 1] in '/\\\\':\n            return True\n        if y - 1 >= 0 and floorplan[y - 1][x] in '/\\\\':\n            return True\n        if y + 1 < n and floorplan[y + 1][x] in '/\\\\':\n            return True\n        return False\n\n    def rotate_gargoyle(x, y, d):\n        if floorplan[y][x] == 'V':\n            if d == 0:\n                floorplan[y][x] = 'H'\n            else:\n                floorplan[y][x] = 'V'\n        elif floorplan[y][x] == 'H':\n            if d == 1:\n                floorplan[y][x] = 'V'\n            else:\n                floorplan[y][x] = 'H'\n        elif floorplan[y][x] == '/':\n            if d == 0:\n                floorplan[y][x] = '\\\\'\n            else:\n                floorplan[y][x] = '/'\n        elif floorplan[y][x] == '\\\\':\n            if d == 1:\n                floorplan[y][x] = '/'\n            else:\n                floorplan[y][x] = '\\\\'\n\n    def can_reach_door():\n        for x in range(m):\n            if floorplan[0][x] == '/':\n                if count_valid_positions(x, 0) >= 2:\n                    return True\n            elif floorplan[0][x] == '\\\\':\n                if count_valid_positions(x, n - 1) >= 2:\n                    return True\n            if floorplan[n - 1][x] == '\\\\':\n                if count_valid_positions(x, 0) >= 2:\n                    return True\n            elif floorplan[n - 1][x] == '/':\n                if count_valid_positions(x, n - 1) >= 2:\n                    return True\n        return False\n\n    def find_gargoyle_count():\n        count = 0\n        for y in range(n):\n            for x in range(m):\n                if floorplan[y][x] in 'VH':\n                    count += 1\n        return count\n\n    def find_min_rotations():\n        min_rotations = 0\n        gargoyles = find_gargoyle_count()\n        while gargoyles > 0:\n            for y in range(n):\n                for x in range(m):\n                    if floorplan[y][x] in 'VH':\n                        if count_valid_positions(x, y) < 2:\n                            if is_obstacle(x, y):\n"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def rotate_gargoyle(grid: list, x: int, y: int, direction: str):\n        if direction == '/':\n            grid[x][y], grid[x+1][y], grid[x][y+1], grid[x+1][y+1] = grid[x+1][y+1], grid[x][y], grid[x+1][y], grid[x][y+1]\n        elif direction == '\\\\':\n            grid[x][y], grid[x-1][y], grid[x][y+1], grid[x-1][y+1] = grid[x-1][y+1], grid[x][y], grid[x-1][y], grid[x][y+1]\n\n    def find_path(grid: list, x: int, y: int, visited: list, direction: str) -> bool:\n        if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or visited[x][y] or grid[x][y] == '#' or (grid[x][y] == 'V' and direction == '/'):\n            return False\n        visited[x][y] = True\n        if grid[x][y] == 'V':\n            for d in ['/', '\\\\']:\n                if find_path(grid, x+1 if d == '/' else x-1, y+1 if d == '/' else y-1, visited, d):\n                    return True\n            return False\n        if grid[x][y] == 'H':\n            for d in ['/', '\\\\']:\n                if find_path(grid, x+1 if d == '/' else x-1, y, visited, d):\n                    return True\n            return False\n        if grid[x][y] == '/':\n            return find_path(grid, x+1, y, visited, '\\\\')\n        if grid[x][y] == '\\\\':\n            return find_path(grid, x-1, y, visited, '/')\n        return True\n\n    def is_valid_configuration(grid: list) -> bool:\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '#' or (grid[i][j] == 'V' and not find_path(grid, i, j, [[False for _ in range(len(grid[0]))] for _ in range(len(grid))], '/')):\n                    return False\n        return True\n\n    n, m = map(int, stdin.split()[0].split(','))\n    grid = [list(stdin.split()[i+1]) for i in range(n)]\n    min_rotations = 0\n    while not is_valid_configuration(grid):\n        min_rotations += 1\n        for i in range(n):\n            for j in range(m):\n                if grid[i][j] in ['V', 'H']:\n                    rotate_gargoyle(grid, i, j, '/')\n    return min_rotations\n"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_suffix(s: str, t: str) -> str:\n        for i in range(1, len(s)):\n            if s[-i:] == t[:i]:\n                return s[-i:]\n        return ''\n\n    def find_prefix(s: str, t: str) -> str:\n        for i in range(1, len(s)):\n            if s[:i] == t[-i:]:\n                return s[:i]\n        return ''\n\n    def is_ambiguous(fragments: list[str]) -> bool:\n        for i in range(len(fragments)):\n            for j in range(i + 1, len(fragments)):\n                if find_suffix(fragments[i], fragments[j]) != '':\n                    return True\n        return False\n\n    def construct_reconstruction(fragments: list[str]) -> str:\n        reconstruction = []\n        for i in range(len(fragments)):\n            for j in range(i + 1, len(fragments)):\n                suffix = find_suffix(fragments[i], fragments[j])\n                if len(suffix) >= 5:\n                    prefix = find_prefix(fragments[j], fragments[i])\n                    if len(prefix) >= 5:\n                        reconstruction.append(fragments[i])\n                        reconstruction.append(fragments[j][len(prefix):])\n        return ' '.join(reconstruction)\n\n    n = int(stdin[0])\n    fragments = [line.strip() for line in stdin[1:]]\n\n    if is_ambiguous(fragments):\n        return \"AMBIGUOUS\"\n    reconstruction = construct_reconstruction(fragments)\n    return reconstruction\n"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def find_suffix_prefix(s: str, t: str) -> Tuple[int, int]:\n        for i in range(len(s) - len(t) + 1):\n            if s[i:] == t:\n                return i, len(s) - i\n        return -1, -1\n\n    n = int(stdin[0])\n    fragments = [stdin[i + 1].strip() for i in range(n)]\n    max_length = 0\n    optimal_sequence = []\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            suffix_prefix = find_suffix_prefix(fragments[i], fragments[j])\n            if suffix_prefix[0] == -1 or suffix_prefix[1] < 5:\n                continue\n            new_sequence = (fragments[i], *(fragments[j][suffix_prefix[1]:] for j in range(i + 1, n)))\n            if len(new_sequence) > max_length:\n                max_length = len(new_sequence)\n                optimal_sequence = new_sequence\n\n    if max_length == 0:\n        return \"AMBIGUOUS\"\n\n    reconstruction = \"\".join(optimal_sequence)\n    return reconstruction\n"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    def overlap(s1: str, s2: str) -> int:\n        for i in range(len(s1) - 5, -1, -1):\n            if s1[i:] == s2[:5 - i]:\n                return 5 - i\n        return 0\n\n    def build_sequence(fragments: List[str]) -> List[str]:\n        sequence = []\n        for i in range(len(fragments)):\n            overlaps = [overlap(fragments[i], f) for f in fragments]\n            if any(overlaps):\n                for j in range(len(overlaps)):\n                    if overlaps[j] >= 5:\n                        sequence.append(fragments[j])\n                        fragments.remove(fragments[j])\n                        break\n        return sequence\n\n    def reconstruct_text(fragments: List[str]) -> str:\n        text = \"\"\n        for i in range(len(fragments)):\n            if i == 0:\n                text += fragments[i]\n            else:\n                prefix = fragments[i][:overlap(fragments[i - 1], fragments[i])]\n                text += \" \" + prefix + \" \"\n        return text\n\n    def find_optimal_sequence(fragments: List[str]) -> List[str]:\n        sequences = []\n        for i in range(len(fragments) - 1):\n            for j in range(i + 1, len(fragments)):\n                if overlap(fragments[i], fragments[j]) >= 5:\n                    sequence = build_sequence(fragments)\n                    if len(sequence) == len(fragments):\n                        sequences.append(sequence)\n        if len(sequences) == 0:\n            return []\n        return max(sequences, key=lambda s: len(s))\n\n    fragments = stdin.strip().split(\"\\n\")\n    optimal_sequence = find_optimal_sequence(fragments)\n    if not optimal_sequence:\n        return \"AMBIGUOUS\"\n    else:\n        return reconstruct_text(optimal_sequence)"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.readline().strip())\n    fragments = []\n    for _ in range(n):\n        fragments.append(stdin.readline().strip())\n\n    def is_suffix_prefix(a, b):\n        for i in range(len(a), -1, -1):\n            if a[:i] == b[len(b) - i:]:\n                return i\n        return 0\n\n    def get_omega(f):\n        for i in range(len(f) - 4, -1, -1):\n            if is_suffix_prefix(f[i:], f) >= 5:\n                return f[i:]\n        return f\n\n    def get_max_sequence(fragments):\n        sequences = []\n        for i in range(len(fragments)):\n            for j in range(len(fragments[i]) - 4, -1, -1):\n                suffix = fragments[i][j:]\n                for k in range(i + 1, len(fragments)):\n                    if is_suffix_prefix(suffix, fragments[k]) >= 5:\n                        sequences.append((i, j, k))\n        max_length = 0\n        max_sequence = None\n        for sequence in sequences:\n            length = sequence[1] + 1\n            if length > max_length:\n                max_length = length\n                max_sequence = sequence\n        return max_sequence\n\n    max_sequence = get_max_sequence(fragments)\n    if max_sequence is None:\n        return \"AMBIGUOUS\"\n\n    reconstruction = fragments[max_sequence[0]]\n    reconstruction += \" \" + get_omega(fragments[max_sequence[1] + 1])\n    reconstruction += \" \" + get_omega(fragments[max_sequence[2]])\n    for i in range(3, len(max_sequence)):\n        reconstruction += \" \" + get_omega(fragments[max_sequence[i]])\n\n    return reconstruction.strip()\n\ndef"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def find_suffix(text: str) -> str:\n        for i in range(len(text) - 5, -1, -1):\n            if text[i:] in text[i + 1:]:\n                return text[i:]\n        return ''\n\n    def reconstruct(fragments: list) -> str:\n        result = ''\n        for i in range(len(fragments) - 1):\n            suffix = find_suffix(fragments[i])\n            if suffix and suffix in fragments[i + 1]:\n                result += fragments[i]\n                result += fragments[i + 1][len(suffix):]\n            else:\n                result += fragments[i]\n        result += fragments[-1]\n        return result\n\n    def longest_sequence(fragments: list) -> list:\n        sequences = []\n        for i in range(len(fragments)):\n            for j in range(i + 2, len(fragments) + 1):\n                if reconstruct(fragments[i:j]) == reconstruct(fragments[:j] + [fragments[i]] + fragments[j - 1:]) and len(fragments[i:j]) >= 2:\n                    sequences.append(fragments[i:j])\n        return sequences\n\n    def max_sequence(sequences: list) -> str:\n        if not sequences:\n            return 'AMBIGUOUS'\n        max_length = max(len(seq) for seq in sequences)\n        candidates = [seq for seq in sequences if len(seq) == max_length]\n        return reconstruct(candidates[0])\n\n    fragments = [line.strip() for line in stdin.split('\\n')[1:]]\n    sequences = longest_sequence(fragments)\n    return max_sequence(sequences)"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def find_shared_suffix(s1: str, s2: str) -> str:\n        for i in range(min(len(s1), len(s2)), 0, -1):\n            if s1.endswith(s2[:i]):\n                return s2[:i]\n        return ''\n\n    def reconstruct_text(fragments: List[str]) -> str:\n        text = ''\n        for i in range(1, len(fragments)):\n            shared_suffix = find_shared_suffix(fragments[i - 1], fragments[i])\n            if len(shared_suffix) < 5:\n                return ''\n            text += fragments[i - 1].replace(shared_suffix, '') + ' '\n        return text.strip()\n\n    n = int(stdin[0])\n    fragments = stdin[1:].split('\\n')[:n]\n    fragments = [fragment.strip() for fragment in fragments]\n    optimal_reconstruction = reconstruct_text(fragments)\n    if optimal_reconstruction:\n        return optimal_reconstruction\n    else:\n        return \"AMBIGUOUS\"\n\ndef"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def find_shared_prefix(s1: str, s2: str) -> str:\n        i, j = 0, 0\n        while i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n            i += 1\n            j += 1\n        return s1[:i]\n\n    def find_suffix(s: str, i: int) -> str:\n        return s[i:]\n\n    def build_reconstruction(fragments: List[str]) -> str:\n        reconstruction = []\n        for i in range(len(fragments) - 1):\n            suffix = find_suffix(fragments[i], 5)\n            for j in range(i + 1, len(fragments)):\n                if suffix == find_shared_prefix(fragments[i], fragments[j]):\n                    reconstruction.append(fragments[j])\n                    break\n        return \" \".join(reconstruction)\n\n    n = int(stdin[0])\n    fragments = [line.strip() for line in stdin[1:].split(\"\\n\") if line.strip()]\n\n    reconstruction = build_reconstruction(fragments)\n    if len(fragments) == 1:\n        return reconstruction\n\n    suffix = find_suffix(fragments[0], 5)\n    for i in range(1, len(fragments)):\n        if suffix == find_shared_prefix(fragments[0], fragments[i]):\n            return \"AMBIGUOUS\"\n\n    return reconstruction\n"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def find_suffix_prefix(s1: str, s2: str) -> str:\n        for i in range(1, min(len(s1), len(s2)) + 1):\n            if s1[-i:] == s2[:i]:\n                return s1[-i:]\n        return \"\"\n\n    def is_ambiguous(sequence: list[str]) -> bool:\n        for i in range(len(sequence) - 1):\n            for j in range(i + 2, len(sequence) + 1):\n                if find_suffix_prefix(sequence[i], sequence[j]) != \"\":\n                    return True\n        return False\n\n    def reconstruct_text(sequence: list[str]) -> str:\n        result = \"\"\n        for fragment in sequence:\n            prefix = find_suffix_prefix(result, fragment)\n            if prefix == \"\":\n                result += fragment\n            else:\n                result += fragment[len(prefix) :]\n        return result\n\n    def find_maximal_sequence(fragments: list[str]) -> list[str]:\n        sequences = []\n        for i in range(len(fragments)):\n            for j in range(i + 5, len(fragments) + 1):\n                sequence = fragments[i:j]\n                if not is_ambiguous(sequence):\n                    sequences.append(sequence)\n        return sequences\n\n    n = int(stdin.splitlines()[0])\n    fragments = stdin.splitlines()[1:]\n    sequences = find_maximal_sequence(fragments)\n\n    if len(sequences) == 0:\n        return \"AMBIGUOUS\"\n    elif len(sequences) == 1:\n        return reconstruct_text(sequences[0])\n    else:\n        return \"AMBIGUOUS\"\n"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def concat_strings(strings: List[str]) -> str:\n        return ''.join(strings)\n\n    def remove_common_prefix(s1: str, s2: str) -> str:\n        prefix = ''\n        for c1, c2 in zip(s1, s2):\n            if c1 == c2:\n                prefix += c1\n            else:\n                break\n        return s1[len(prefix):]\n\n    def is_ambiguous(max_len_sequences: List[List[str]]) -> bool:\n        for sequence in max_len_sequences:\n            for i in range(1, len(sequence)):\n                if sequence[i][:5] == sequence[i - 1][-5:]:\n                    return True\n        return False\n\n    def find_optimal_reconstruction(max_len_sequences: List[List[str]]) -> str:\n        reconstruction = []\n        for sequence in max_len_sequences:\n            for i in range(1, len(sequence)):\n                reconstruction.append(remove_common_prefix(sequence[i], sequence[i - 1]))\n        return concat_strings(reconstruction)\n\n    def find_max_len_sequences(fragments: List[str]) -> List[List[str]]:\n        max_len_sequences = []\n        for i in range(len(fragments)):\n            current_sequence = [fragments[i]]\n            for j in range(i + 1, len(fragments)):\n                if fragments[j].startswith(current_sequence[-1][-5:]):\n                    current_sequence.append(fragments[j])\n            if len(current_sequence) > len(max_len_sequences[0] if max_len_sequences else []):\n                max_len_sequences = [current_sequence]\n            elif len(current_sequence) == len(max_len_sequences[0]):\n                max_len_sequences.append(current_sequence)\n        return max_len_sequences\n\n    lines = stdin.split('\\n')\n    n = int(lines[0])\n    fragments = lines[1:]\n\n    max_len_sequences = find_max_len_sequences(fragments)\n\n    if is_ambiguous(max_len_sequences):\n        return \"AMBIGUOUS\"\n    else:\n        reconstruction = find_optimal_reconstruction(max_len_sequences)\n        return reconstruction\n\ninput1 = \"7\\nn fox jumps ove\\nuick brown f\\nThe quick b\\ny dog.\\nrwon fox\\nmps over the l\\nthe lazy dog\\n\"\ninput2 = \"4\\ncdefghi\\nefghijk\\nefghijx\\nabcdefg\\n\"\n\nprint(solution(input1))\nprint(solution(input2)) "
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    def longest_common_suffix(s1: str, s2: str) -> str:\n        i = 1\n        while i <= min(len(s1), len(s2)) and s1[-i:] == s2[-i:]:\n            i += 1\n        return s1[-i + 1:]\n\n    def remove_shared_prefix(s: str, prefix: str) -> str:\n        return s[len(prefix):] if s.startswith(prefix) else s\n\n    def reconstruct(fragments: List[str]) -> str:\n        if len(fragments) == 1:\n            return fragments[0]\n\n        fragments.sort(key=len, reverse=True)\n        max_len = len(fragments[0])\n        prev = fragments[0]\n        result = \"\"\n\n        for i in range(1, len(fragments)):\n            curr = fragments[i]\n            common_suffix = longest_common_suffix(prev, curr)\n\n            if len(common_suffix) >= 5:\n                prev = prev[:-len(common_suffix)]\n                result += common_suffix\n            else:\n                prev = curr\n\n            result += remove_shared_prefix(curr, prev)\n\n        return result\n\n    n = int(stdin)\n    fragments = [input() for _ in range(n)]\n    optimal_reconstruction = reconstruct(fragments)\n\n    return optimal_reconstruction if len(optimal_reconstruction) > 0 else \"AMBIGUOUS\""
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    ships = []\n    for i in range(1, m+1):\n        x1, x2, y = map(int, input_data[i].split())\n        ships.append((x1, y))\n        ships.append((x2, y))\n    # sort ships by y\n    ships.sort(key=lambda x: x[1])\n    dodge_instructions = []\n    x = 0\n    y = 0\n    for ship_x1, ship_y in ships:\n        if ship_y == y:\n            if ship_x1 <= x:\n                dodge_instructions.append('+')\n                x += 1\n            else:\n                dodge_instructions.append('-')\n                x -= 1\n        elif ship_y < y:\n            dodge_instructions.append('0')\n        else:\n            # find first ship with y > y\n            i = bisect_left([s[1] for s in ships], y+1)\n            if i < len(ships) and ships[i][1] == y+1:\n                if ships[i][0] <= x:\n                    dodge_instructions.append('+')\n                    x += 1\n                else:\n                    dodge_instructions.append('-')\n                    x -= 1\n            else:\n                dodge_instructions.append('0')\n        y = ship_y\n    if len(dodge_instructions) < n:\n        dodge_instructions += ['0'] * (n - len(dodge_instructions))\n    elif len(dodge_instructions) > n:\n        return \"impossible\"\n    return ''.join(dodge_instructions)\n\ndef"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    ships = []\n\n    for i in range(1, m + 1):\n        x1, x2, y = map(int, input_data[i].split())\n        ships.append((x1, y))\n        ships.append((x2, y))\n\n    ships.sort(key=lambda x: x[1])\n    torpedo_path = [0] * n\n\n    for i in range(1, n):\n        for x1, y in ships:\n            if x1 <= i <= x1 + y:\n                torpedo_path[i] = 1\n                break\n\n    if sum(torpedo_path) == n:\n        return \"impossible\"\n\n    for i in range(1, n):\n        if torpedo_path[i] == 0:\n            torpedo_path[i] = 1\n            break\n\n    for i in range(n - 1, 0, -1):\n        if torpedo_path[i] == 0:\n            torpedo_path[i] = -1\n            break\n\n    return ''.join(str(x) for x in torpedo_path)\n"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_lines = stdin.splitlines()\n    n, m = map(int, input_lines[0].split())\n    ships = []\n\n    for i in range(1, m + 1):\n        x1, x2, y = map(int, input_lines[i].split())\n        ships.append((x1, x2, y))\n\n    torpedo = (0, 0)\n    target = [(x1, y - 1) for x1, _, y in ships] + [(x2, y - 1) for x2, _, y in ships] + [(x, y - 1) for _, _, y in ships]\n\n    def is_dodged(position):\n        return position not in target\n\n    def turn(direction):\n        if direction == \"+\":\n            return \"-\"\n        elif direction == \"-\":\n            return \"+\"\n        else:\n            return \"0\"\n\n    def find_path(position, direction, steps):\n        if steps == 0:\n            return \"\"\n\n        if is_dodged(position):\n            return direction + find_path((position[0], position[1] + 1), turn(direction), steps - 1)\n        else:\n            return find_path((position[0] - 1, position[1]), turn(direction), steps) + direction\n\n    path = find_path(torpedo, \"+\", n)\n    if path:\n        return path\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    if n < m:\n        return \"impossible\"\n    ships = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    for ship in ships:\n        if ship[0] > n or ship[2] > n:\n            return \"impossible\"\n\n    direction = [0] * n\n    for i in range(1, n):\n        if direction[i] == 0:\n            for ship in ships:\n                if ship[0] <= i <= ship[2] and ship[1] == i:\n                    direction[i] = -1\n                elif -n <= ship[0] - i <= 0 and ship[1] == i:\n                    direction[i] = 1\n                elif -n <= ship[2] - i <= 0 and ship[1] == i:\n                    direction[i] = 1\n                elif ship[0] <= i <= ship[2] and ship[1] + i <= n:\n                    direction[i] = -1\n                elif -n <= ship[0] - i <= 0 and ship[1] + i <= n:\n                    direction[i] = 1\n                elif -n <= ship[2] - i <= 0 and ship[1] + i <= n:\n                    direction[i] = 1\n\n    if all(d == 0 for d in direction[1:n]):\n        return \"impossible\"\n\n    directions = ['-', '0', '+']\n    result = [directions[direction[0]]]\n    for d in direction[1:n]:\n        if d == 0:\n            result.append(directions[direction[result.index('0')] + 1])\n        else:\n            result.append(directions[d])\n\n    return ''.join(result)"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, input().split())\n        ships.append((x1, x2, y))\n\n    def is_dodgable(x, y, ships):\n        for ship in ships:\n            if ship[0] <= x <= ship[1] or ship[1] <= x <= ship[0]:\n                if y == ship[2]:\n                    return False\n        return True\n\n    def generate_turn_sequence(n):\n        turns = ['-'] * n\n        i = 0\n        while i < n:\n            if turns[i] == '-':\n                turns[i] = '+'\n                i += 1\n            else:\n                turns[i] = '-'\n                i += 2\n        return turns\n\n    if any(is_dodgable(ship[0], ship[2], ships) for ship in ships):\n        return generate_turn_sequence(n)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, input().split())\n        ships.append((x1, x2, y))\n\n    def is_ship_hit(x, y):\n        for ship in ships:\n            if ship[0] <= x <= ship[1] and y == ship[2]:\n                return True\n        return False\n\n    def avoid_ships(x, y):\n        next_pos = [(x - 1, y + 1), (x, y + 1), (x + 1, y + 1)]\n        for pos in next_pos:\n            if not is_ship_hit(pos[0], pos[1]):\n                return pos\n        return None\n\n    if n == 0:\n        return \"impossible\"\n\n    x, y = 0, 0\n    dodge = [\"-\"] * n\n\n    for i in range(n):\n        pos = avoid_ships(x, y)\n        if pos:\n            x, y = pos\n        else:\n            dodge[i] = \"+\"\n            x, y = x + 1, y + 1\n\n        if i < n - 1 and dodge[i] == dodge[i + 1]:\n            dodge[i + 1] = \"0\"\n\n    return \"\".join(dodge)\n\ninput_string = \"\"\"5 6\n-3 -2 3\n-2 -2 4\n2 3 3\n-1 1 2\n0 1 4\n2 5 1\"\"\"\n\nprint(solution(input_string)) "
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    def is_safe(x: int, y: int, ships: set) -> bool:\n        return (x, y) not in ships and (x - 1, y + 1) not in ships and (x, y + 1) not in ships and (x + 1, y + 1) not in ships\n\n    n, m = map(int, stdin.split()[:2])\n    ships = set()\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.split()[2:])\n        ships.add((x1, y + 1))\n        ships.add((x2, y + 1))\n\n    for x in range(n):\n        if is_safe(x, 0, ships):\n            return '+' * n\n        if not any(is_safe(x, y, ships) for y in range(1, n)):\n            return \"impossible\"\n    return '-' * n\n"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_ship_collision(x1, y1, x2, y2, x, y, n):\n        if y < 1 or y > n - 1 or (x1 <= x <= x2 and y1 <= y <= y2):\n            return True\n        return False\n\n    def generate_turn_sequence(n: int) -> str:\n        turn_sequence = []\n        for i in range(n):\n            if i % 2 == 0:\n                turn_sequence.append('+')\n            else:\n                turn_sequence.append('0')\n        return ''.join(turn_sequence)\n\n    lines = stdin.splitlines()\n    n, m = map(int, lines[0].split())\n    ships = []\n\n    for i in range(1, m + 1):\n        x1, x2, y = map(int, lines[i].split())\n        ships.append((x1, y))\n        ships.append((x2, y))\n\n    ships.sort()\n    for i in range(len(ships)):\n        if i > 0 and ships[i] == ships[i - 1]:\n            return \"impossible\"\n\n    if n == 1:\n        return generate_turn_sequence(1)\n\n    for i in range(1, len(ships)):\n        x1, y1 = ships[i - 1]\n        x2, y2 = ships[i]\n        for j in range(1, n):\n            x = j\n            y = y1\n            if is_ship_collision(x1, y1, x2, y2, x, y, n):\n                return \"impossible\"\n\n            x = -j\n            y = y2\n            if is_ship_collision(x1, y1, x2, y2, x, y, n):\n                return \"impossible\"\n\n    return generate_turn_sequence(n)\n\ndef"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def ship_collision(x: int, y: int, ship_points: List[Tuple[int, int]]) -> bool:\n        for ship_point in ship_points:\n            if ship_point[0] <= x <= ship_point[1] and ship_point[1] == y:\n                return True\n        return False\n\n    n, m = map(int, stdin.splitlines()[0].split())\n    ship_points = []\n\n    for i in range(1, m + 1):\n        x1, x2, y = map(int, stdin.splitlines()[i].split())\n        ship_points.append((x1, y))\n        ship_points.append((x2, y))\n\n    dodge_pattern = [\"+\"] * n\n\n    for i in range(n - 1):\n        for j in range(1, n):\n            if ship_collision(i + j, j, ship_points):\n                dodge_pattern[i] = \"0\"\n                break\n\n    if dodge_pattern.count(\"0\") == n:\n        return \"impossible\"\n    elif dodge_pattern.count(\"+\") == n:\n        return \"\".join(dodge_pattern)\n    else:\n        return \"--+\" + \"\".join(dodge_pattern) + \"-\""
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n, m = map(int, input_data[0].split())\n    ships = []\n    for i in range(1, m + 1):\n        x1, x2, y = map(int, input_data[i].split())\n        ships.append((x1, x2, y))\n\n    def is_safe(x, y):\n        for s in ships:\n            if s[0] <= x <= s[1] or s[0] <= y <= s[1]:\n                return False\n        return True\n\n    def min_turn(x, y, dx, dy):\n        if (x + dx) % 2 == (y + dy) % 2:\n            return \"+\"\n        else:\n            return \"-\"\n\n    def generate_path(x, y):\n        path = []\n        while not is_safe(x, y):\n            if is_safe(x + 2, y + 1):\n                path.append(min_turn(x, y, 2, 1))\n                x += 2\n                y += 1\n            elif is_safe(x + 1, y + 2):\n                path.append(min_turn(x, y, 1, 2))\n                x += 1\n                y += 2\n            elif is_safe(x - 1, y + 2):\n                path.append(min_turn(x, y, -1, 2))\n                x -= 1\n                y += 2\n            elif is_safe(x - 2, y + 1):\n                path.append(min_turn(x, y, -2, 1))\n                x -= 2\n                y += 1\n            elif is_safe(x - 2, y - 1):\n                path.append(min_turn(x, y, -2, -1))\n                x -= 2\n                y -= 1\n            elif is_safe(x - 1, y - 2):\n                path.append(min_turn(x, y, -1, -2))\n                x -= 1\n                y -= 2\n            elif is_safe(x + 1, y - 2):\n                path.append(min_turn(x, y, 1, -2))\n                x += 1\n                y -= 2\n            else:\n                return \"impossible\"\n        return \"\".join(path)\n\n    path = generate_path(0, 0)\n    if path == \"impossible\":\n        return \"impossible\"\n    else:\n        return path + \"+\" * (n - len(path))"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def mod(a, b):\n        return a % b\n\n    def mod_pow(base, exponent, modulus):\n        result = 1\n        base = base % modulus\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            base = (base * base) % modulus\n            exponent = exponent // 2\n        return result\n\n    def count_purchases(C, a, b):\n        if C == 0:\n            return 0\n        total_purchases = 0\n        for i in range(1, min(C, a) + 1):\n            for j in range(1, min(C, b) + 1):\n                total_purchases += mod_pow(i, j, 1000000007)\n        return total_purchases % 1000000007\n\n    def process_changes(N, a, b, Q, changes):\n        for change in changes:\n            P, a_P, b_P = change\n            a[P - 1] = a_P\n            b[P - 1] = b_P\n\n    N, C = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    changes = [tuple(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    process_changes(N, a, b, Q, changes)\n    result = [count_purchases(C, a[i], b[i]) for i in range(N)]\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    def count_purchases(N: int, C: int, a: list, b: list, Q: int, changes: list) -> int:\n        def count_purchases_helper(N: int, C: int, a: list, b: list) -> int:\n            dp = [0] * (C + 1)\n            dp[0] = 1\n            for i in range(N):\n                new_dp = [0] * (C + 1)\n                for j in range(C + 1):\n                    if j - a[i] >= 0:\n                        new_dp[j] += dp[j - a[i]]\n                    if j - b[i] >= 0:\n                        new_dp[j] += dp[j - b[i]]\n                dp = new_dp\n            return dp[C]\n\n        return count_purchases_helper(N, C, a, b)\n\n    input_data = stdin.split('\\n')\n    N, C = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n    Q = int(input_data[3])\n    changes = [tuple(map(int, input_data[i + 4].split())) for i in range(Q)]\n\n    result = [count_purchases(N, C, a, b, Q, changes)]\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, C, a, b, Q, changes = (int(x) for x in stdin.split())\n    colored = [a[i - 1] for i in range(1, N + 1)]\n    black_white = [b[i - 1] for i in range(1, N + 1)]\n\n    def count_purchases(C, colored, black_white):\n        total = 0\n        for c in colored:\n            total += c\n            if total >= C:\n                return total\n        for bw in black_white:\n            total += bw\n            if total >= C:\n                return total\n        return total\n\n    def update_purchases(changes, colored, black_white):\n        for i in range(changes):\n            label, a_label, b_label = (int(x) for x in input().split())\n            colored[label - 1] = a_label\n            black_white[label - 1] = b_label\n\n    update_purchases(Q, colored, black_white)\n    total = count_purchases(C, colored, black_white)\n    return total % 10007"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = list(map(int, stdin.split()))\n    N, C, a, b, Q = input_data[:5]\n    reqs = input_data[5:]\n\n    def count_purchases(a, b):\n        colored_count = 0\n        black_and_white_count = 0\n\n        for i in range(1, N + 1):\n            if reqs[i - 1][0] == i:\n                if reqs[i - 1][1] > 0:\n                    colored_count += reqs[i - 1][1]\n                if reqs[i - 1][2] > 0:\n                    black_and_white_count += reqs[i - 1][2]\n\n        return max(colored_count, black_and_white_count)\n\n    count = 0\n    for i in range(Q):\n        client = reqs[i][0]\n        a_new = reqs[i][1]\n        b_new = reqs[i][2]\n\n        a[client - 1] = a_new\n        b[client - 1] = b_new\n\n        if count_purchases(a, b) >= C:\n            count += 1\n\n    return str(count % 10007)\n"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    def paintings_needed(a: int, b: int, c: int) -> int:\n        if a >= c:\n            return a\n        return a + (c - a) % (b + 1)\n\n    input_list = stdin.split('\\n')\n    N, C = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n    b_list = list(map(int, input_list[2].split()))\n    Q = int(input_list[3])\n\n    for i in range(Q):\n        P, a_P, b_P = map(int, input_list[4 + i].split())\n        a_list[P - 1] = a_P\n        b_list[P - 1] = b_P\n\n    result = 0\n    for i in range(N):\n        result += paintings_needed(a_list[i], b_list[i], C)\n\n    return str(result % 10007)"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n    Q = int(stdin.splitlines()[3])\n\n    MOD = 1000007\n\n    # Initialize dp array with 1 for the base case\n    dp = [1] * (C + 1)\n\n    # Iterate through the requirements changes\n    for _ in range(Q):\n        P, a_p, b_p = map(int, stdin.splitlines()[4 + _].split())\n\n        # Update the dp array based on the new requirements\n        for i in range(C, a_p - 1, -1):\n            dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n        for i in range(max(a_p - 1, 0), b_p - 1, -1):\n            dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n        for i in range(max(b_p - 1, 0), C):\n            dp[i] = (dp[i] + dp[i + 1]) % MOD\n\n        # Print the final result\n        print(dp[C])"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n\n    Q = int(input())\n\n    for _ in range(Q):\n        P, a_P, b_P = map(int, input().split())\n        colored_paintings = sum(a_P if a[i] <= a_P else 0 for i in range(N))\n        black_and_white_paintings = sum(b_P if b[i] <= b_P else 0 for i in range(N))\n        total_paintings = colored_paintings + black_and_white_paintings\n\n        if total_paintings >= C:\n            result = 1\n        else:\n            result = pow(2, N, 10007)\n            for i in range(N):\n                if a[i] <= a_P and b[i] <= b_P:\n                    result = (result * pow(2, i, 10007)) % 10007\n        print(result)\n"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    N, C = map(int, input_list[0].split())\n    a_list = list(map(int, input_list[1].split()))\n    b_list = list(map(int, input_list[2].split()))\n    Q = int(input_list[3])\n\n    mod = 1000000007\n\n    def count_purchases(a_list, b_list, C):\n        count = 0\n        a_sum = sum(a_list)\n        b_sum = sum(b_list)\n        if a_sum >= C and b_sum >= C:\n            count += 1\n        if a_sum >= C:\n            count += 1\n        if b_sum >= C:\n            count += 1\n        return count\n\n    purchases = count_purchases(a_list, b_list, C)\n\n    for i in range(Q):\n        P, a_P, b_P = map(int, input_list[4 + i].split())\n        a_list[P - 1] = a_P\n        b_list[P - 1] = b_P\n        purchases = (purchases + count_purchases(a_list, b_list, C)) % mod\n\n    result = [str(purchases)]\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, C = map(int, input_data[0].split())\n    a = list(map(int, input_data[1].split()))\n    b = list(map(int, input_data[2].split()))\n    Q = int(input_data[3])\n    Qs = []\n    for _ in range(Q):\n        P, a_P, b_P = map(int, input_data[4+_].split())\n        Qs.append((P, a_P, b_P))\n\n    total_purchases = 0\n    for i in range(N):\n        count_colored = min(a[i], C)\n        count_bw = min(b[i], C - count_colored)\n        total_purchases += count_colored + count_bw\n\n    for P, a_P, b_P in Qs:\n        count_colored = min(a[P-1], C)\n        count_bw = min(b[P-1], C - count_colored)\n        total_purchases += count_colored + count_bw\n\n    return str(total_purchases % 10007)\n"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n    Q = int(stdin.splitlines()[3])\n\n    mod = 100007\n    dp = [0] * (C + 1)\n    dp[0] = 1\n\n    for i in range(N):\n        colored = a[i]\n        black_white = b[i]\n        for j in range(C + 1):\n            if colored > 0:\n                dp[j] = (dp[j] + dp[max(0, j - colored)]) % mod\n            if black_white > 0:\n                dp[j] = (dp[j] + dp[max(0, j - black_white)]) % mod\n\n    result = [dp[C]]\n\n    for i in range(Q):\n        P, a_P, b_P = map(int, stdin.splitlines()[4 + i].split())\n        for _ in range(a_P):\n            dp[C] = (dp[C] - dp[max(0, dp[C - 1] - 1)]) % mod\n        for _ in range(b_P):\n            dp[C] = (dp[C] - dp[max(0, dp[C - 1] - 1)]) % mod\n        result.append(dp[C])\n\n    return \"\\n\".join(map(str, result))\n\n\ninput_file = \"input.txt\"  # Change this to the path of the input file\noutput_file = \"output.txt\"  # Change this to the path of the output file\n\nwith open(input_file, \"r\") as f:\n    input_data = f.read()\n\nresult = solution(input_data)\n\nwith open(output_file, \"w\") as f:\n    f.write(result)"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    art = stdin.split('\\n')[1:N+1]\n    \n    # Check if the art can be reproduced with the given grid and stamp\n    def is_reproducible(art, grid, stamp):\n        for i in range(N):\n            for j in range(M):\n                if art[i][j] == 'W':\n                    continue\n                if not stamp_possible(i, j, stamp, grid):\n                    return False\n        return True\n\n    # Check if a stamp can be placed in the given position in the grid\n    def stamp_possible(i, j, stamp, grid):\n        for x in range(3):\n            for y in range(3):\n                if not (0 <= i+x < N and 0 <= j+y < M):\n                    return False\n                if stamp[x][y] != grid[i+x][j+y]:\n                    return False\n        return True\n\n    # Check if the given stamp contains the same color in every cell\n    def is_valid_stamp(stamp):\n        return len(set(stamp.flatten())) == 1\n\n    # Check if a stamp with the given color can be placed in the grid\n    def is_valid_color(color, grid, stamp):\n        for i in range(N):\n            for j in range(M):\n                if stamp_possible(i, j, stamp, grid):\n                    return True\n        return False\n\n    # Check if the stamp has a color different from the current cell's color\n    def is_valid_stamp_color(color, stamp):\n        return stamp.count(color) == 9\n\n    # Check if the stamp has a color different from the current cell's color\n    def is_valid_stamp_color(color, stamp):\n        return stamp.count(color) == 9\n\n    # Check if the given stamp can be placed in the grid without spilling paint\n    def is_valid_stamp_placement(i, j, stamp, grid):\n        for x in range(3):\n            for y in range(3):\n                if not (0 <= i+x < N and 0 <= j+y < M):\n                    return False\n                if stamp[x][y] != 'W' and stamp[x][y] != grid[i+x][j+y]:\n                    return False\n        return True\n\n    # Check if the given stamp is valid\n    def is_valid_stamp(stamp):\n        if not is_valid_color('R', stamp):\n            return False\n        if not is_valid_color('G', stamp):\n            return False\n        if not is_valid_color('B', stamp):\n            return False\n        if not is_valid_color('W', stamp):\n            return False\n        return True\n\n    # Check if the given stamp is valid\n    def is_valid_stamp(stamp):\n        if not is_valid_color('R', stamp):\n            return False\n        if not is_valid_color('G', stamp):\n            return False\n        if not is_valid_color('B', stamp):\n            return False\n        if not is_valid_color('W', stamp):\n            return False\n        return True\n\n    # Check if the given stamp is valid\n    def is_valid_stamp(stamp):\n        if not is_valid_color('R', stamp):\n            return False\n        if not is_valid_color('G', stamp):\n            return False\n        if not is_valid_color('B', stamp):\n            return False\n        if not is_valid_color('W', stamp):\n            return False\n        return True\n\n    # Check if the given stamp is valid\n    def is_valid_stamp(stamp):\n        if not is_valid_color('R', stamp):\n            return False\n        if not is_valid_color('G', stamp):\n            return False\n        if not is_valid_color('B', stamp):\n            return False\n        if not is_valid_color('W', stamp):\n            return False\n        return True\n\n    # Check if the given stamp is valid\n    def is_valid_stamp(stamp):\n        if not is_valid_color('R', stamp):\n            return False\n        if not is"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0].split()[0])\n    M = int(input_list[0].split()[1])\n    art_piece = []\n    \n    for i in range(1, N+1):\n        art_piece.append(input_list[i])\n    \n    def stamp_cells(x: int, y: int, color: str) -> None:\n        for i in range(x, x+3):\n            for j in range(y, y+3):\n                if i < 0 or j < 0 or i >= N or j >= M:\n                    return\n                if art_piece[i][j] != 'W':\n                    return\n                art_piece[i] = art_piece[i][:j] + color + art_piece[i][j+1:]\n    \n    def is_valid(x: int, y: int) -> bool:\n        if x < 0 or y < 0 or x >= N or y >= M:\n            return False\n        return True\n    \n    for i in range(N-2):\n        for j in range(M-2):\n            if art_piece[i][j] == 'W' and art_piece[i+1][j] == 'W' and art_piece[i+2][j] == 'W' and art_piece[i][j+1] == 'W' and art_piece[i+1][j+1] == 'W' and art_piece[i+2][j+1] == 'W' and art_piece[i][j+2] == 'W' and art_piece[i+1][j+2] == 'W' and art_piece[i+2][j+2] == 'W':\n                return \"YES\"\n    \n    for i in range(N-2):\n        for j in range(M-2):\n            for color in ['R', 'G', 'B']:\n                if is_valid(i, j) and art_piece[i][j] == 'W' and art_piece[i+1][j] == 'W' and art_piece[i+2][j] == 'W':\n                    stamp_cells(i, j, color)\n                    if is_valid(i+1, j) and art_piece[i+1][j] == 'W' and art_piece[i+2][j] == 'W':\n                        stamp_cells(i+1, j, color)\n                    if is_valid(i+2, j) and art_piece[i+2][j] == 'W':\n                        stamp_cells(i+2, j, color)\n                    if is_valid(i, j+1) and art_piece[i][j+1] == 'W' and art_piece[i][j+2] == 'W':\n                        stamp_cells(i, j+1, color)\n                    if is_valid(i+1, j+1) and art_piece[i+1][j+1] == 'W' and art_piece[i+1][j+2] == 'W':\n                        stamp_cells(i+1, j+1, color)\n                    if is_valid(i+2, j+1) and art_piece[i+2][j+1] == 'W' and art_piece[i+2][j+2] == 'W':\n                        stamp_cells(i+2, j+1, color)\n                    if is_valid(i, j+2) and art_piece[i][j+2] == 'W':\n                        stamp_cells(i, j+2, color)\n                    if is_valid(i+1, j+2) and art_piece[i+1][j+2] == 'W':\n                        stamp_cells(i+1, j+2, color)\n                    if is_valid(i+2, j+2) and art_piece[i+2][j+2] == 'W':\n                        stamp_cells(i+2, j+2, color)\n                    if is_valid("
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list.pop(0).split())\n    art = [list(line) for line in input_list]\n\n    def is_valid_stamp(stamp, color):\n        for row in range(3):\n            for col in range(3):\n                if stamp[row][col] != 'W':\n                    if art[row + i][col + j] != color:\n                        return False\n        return True\n\n    for i in range(N - 2):\n        for j in range(M - 2):\n            if art[i][j] == 'R':\n                if is_valid_stamp(\n                    [['R', 'R', 'R'], ['R', 'R', 'R'], ['R', 'R', 'R']], 'R'):\n                    return \"YES\"\n            elif art[i][j] == 'G':\n                if is_valid_stamp(\n                    [['G', 'G', 'G'], ['G', 'G', 'G'], ['G', 'G', 'G']], 'G'):\n                    return \"YES\"\n            elif art[i][j] == 'B':\n                if is_valid_stamp(\n                    [['B', 'B', 'B'], ['B', 'B', 'B'], ['B', 'B', 'B']], 'B'):\n                    return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list.pop(0).split())\n    art_piece = []\n    for i in range(N):\n        art_piece.append(input_list[i].strip())\n\n    def is_valid_move(x, y, color):\n        for i in range(x - 1, x + 2):\n            for j in range(y - 1, y + 2):\n                if i < 0 or i >= N or j < 0 or j >= M or art_piece[i][j] != 'W':\n                    return False\n        return True\n\n    for i in range(N):\n        for j in range(M):\n            if art_piece[i][j] == 'R' or art_piece[i][j] == 'G' or art_piece[i][j] == 'B':\n                if is_valid_move(i, j, art_piece[i][j]):\n                    art_piece[i] = art_piece[i][:j] + art_piece[i][j].upper() + art_piece[i][j+1:]\n                else:\n                    return 'NO'\n    return 'YES'"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split(\"\\n\")\n    N, M = map(int, input_data[0].split())\n    art_piece = [list(line) for line in input_data[1:N+1]]\n    \n    def stamp(x, y, color):\n        for i in range(3):\n            for j in range(3):\n                if 0 <= x+i < N and 0 <= y+j < M and art_piece[x+i][y+j] != 'W':\n                    art_piece[x+i][y+j] = color\n    \n    def is_possible_to_reproduce():\n        for i in range(N):\n            for j in range(M):\n                if art_piece[i][j] == 'W':\n                    continue\n                elif art_piece[i][j] == 'R':\n                    stamp(i-1, j-1, 'R')\n                elif art_piece[i][j] == 'G':\n                    stamp(i-1, j-1, 'G')\n                elif art_piece[i][j] == 'B':\n                    stamp(i-1, j-1, 'B')\n                else:\n                    return False\n        return True\n    \n    return \"YES\" if is_possible_to_reproduce() else \"NO\"\n"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    art = stdin.split('\\n')[1:]\n    art = [list(row) for row in art]\n    \n    def is_valid(x, y, color):\n        if x < 0 or x >= N or y < 0 or y >= M:\n            return False\n        return art[x][y] == color\n    \n    for x in range(N - 3):\n        for y in range(M - 3):\n            if all(is_valid(x + i, y + j, 'R') for i in range(3) for j in range(3)) or \\\n               all(is_valid(x + i, y + j, 'G') for i in range(3) for j in range(3)) or \\\n               all(is_valid(x + i, y + j, 'B') for i in range(3) for j in range(3)):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, input().split())\n    art = []\n    for _ in range(N):\n        art.append(input())\n\n    def is_valid(x: int, y: int, color: str) -> bool:\n        if x < 0 or x >= N or y < 0 or y >= M:\n            return False\n        if art[x][y] != 'W':\n            return False\n        return True\n\n    def stamp(x: int, y: int, color: str):\n        for dx in range(3):\n            for dy in range(3):\n                if is_valid(x + dx, y + dy, color):\n                    art[x + dx][y + dy] = color\n\n    for x in range(N - 2):\n        for y in range(M - 2):\n            if art[x][y] == 'R' and art[x + 1][y] == 'R' and art[x + 2][y] == 'R' and art[x][y + 1] == 'R' and art[x][y + 2] == 'R' and art[x + 1][y + 1] == 'R' and art[x + 2][y + 1] == 'R' and art[x + 1][y + 2] == 'R':\n                return \"YES\"\n    return \"NO\"\n\ndef"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    art_piece = stdin.split('\\n')[1:]\n    grid_board = [['W' for _ in range(M)] for _ in range(N)]\n    stamp = ['R', 'G', 'B']\n    \n    for i in range(N):\n        for j in range(M):\n            grid_board[i][j] = art_piece[i][j]\n    \n    for i in range(N - 2):\n        for j in range(M - 2):\n            if all(grid_board[x][y] in stamp for x in range(i, i + 3) for y in range(j, j + 3)):\n                return \"YES\"\n    return \"NO\""
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(r: int, c: int, n: int, m: int) -> bool:\n        return 0 <= r < n and 0 <= c < m\n\n    n, m = map(int, stdin.split()[0].split(','))\n    art = stdin.split('\\n')[1:]\n    board = [['W' for _ in range(m)] for _ in range(n)]\n\n    for i, row in enumerate(art):\n        for j, color in enumerate(row):\n            if color != 'W':\n                if is_valid(i, j, n, m):\n                    board[i][j] = color\n                else:\n                    return 'NO'\n\n    stamp = [list('RGBW') for _ in range(3)]\n    for i in range(n - 2):\n        for j in range(m - 2):\n            if all(board[x][y] != 'W' for x in range(i, i + 3) for y in range(j, j + 3)):\n                return 'NO'\n            for x in range(i, i + 3):\n                for y in range(j, j + 3):\n                    if board[x][y] != 'W':\n                        board[x][y] = stamp[x - i][y - j]\n\n    return 'YES'\n\ndef"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data.pop(0).split())\n    art_piece = [[input_data[i][j] for j in range(M)] for i in range(N)]\n    if not can_reproduce(art_piece):\n        return \"NO\"\n    else:\n        return \"YES\"\n\ndef"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n    \n    # Count the occurrences of each integer in the array\n    count = [0] * (S + 1)\n    for a in A:\n        count[a] += 1\n    \n    # Find the minimum number of changes needed to make the array smooth\n    min_changes = float('inf')\n    for i in range(S + 1):\n        # Count the number of occurrences of i in A and the number of occurrences of i + K in A\n        i_count = count[i]\n        i_k_count = count[i + K]\n        \n        # Find the minimum number of changes needed to make i_count and i_k_count equal\n        min_changes_i = abs(i_count - i_k_count)\n        min_changes_i += sum(abs(j - i) for j in range(i + 1, i + K))\n        \n        # Update the minimum number of changes\n        min_changes = min(min_changes, min_changes_i)\n    \n    return str(min_changes)"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    min_changes = float('inf')\n    for i in range(N - K + 1):\n        change = sum(A[i + j] for j in range(K))\n        if change != S:\n            min_changes = min(min_changes, abs(change - S))\n\n    return str(min_changes)\n\n\ninput_stdin = \"\"\"3 3 5\n1\n2\n3\"\"\"\nprint(solution(input_stdin)) "
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n    \n    count = 0\n    for i in range(N - K + 1):\n        if sum(A[i:i+K]) != S:\n            count += 1\n            \n    return count"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    def is_smooth(A, K):\n        for i in range(N - K + 1):\n            if sum(A[i:i + K]) != K * S:\n                return False\n        return True\n\n    def count_changes(A):\n        count = 0\n        for i in range(N):\n            if A[i] != i % (S + 1):\n                count += 1\n        return count\n\n    if is_smooth(A, K):\n        return \"0\"\n\n    min_changes = count_changes(A)\n    for i in range(N):\n        if A[i] != i % (S + 1):\n            for j in range(S + 1):\n                if j != A[i]:\n                    A[i] = j\n                    if is_smooth(A, K):\n                        min_changes = min(min_changes, count_changes(A))\n                    A[i] = j\n\n    return str(min_changes)\n\n\ndef"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N, K, S = map(int, input_list[:3])\n    A = list(map(int, input_list[3:]))\n\n    # Initialize min_changes\n    min_changes = 0\n\n    # Iterate through the array and count the number of changes required\n    for i in range(N - K + 1):\n        current_sum = sum(A[i:i + K])\n        if current_sum % S != 0:\n            min_changes += 1\n\n    # Return the minimum number of changes\n    return str(min_changes)"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    min_changes = float('inf')\n    for i in range(N - K + 1):\n        changes = sum(abs(A[j] - A[i+j]) for j in range(K))\n        min_changes = min(min_changes, changes)\n\n    return str(min_changes)\n\ndef"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    changes = 0\n    for i in range(N - K + 1):\n        if sum(A[i:i+K]) != S:\n            changes += 1\n\n    return str(changes)\n"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    if K >= N:\n        return 0\n\n    def is_smooth(idx):\n        if idx >= N - K + 1:\n            return sum(A[idx:idx + K]) == S\n        return sum(A[idx:idx + K]) == S and is_smooth(idx + 1)\n\n    def count_changes(idx):\n        if idx >= N:\n            return 0\n        count = 0\n        for i in range(S + 1):\n            A[idx] = i\n            count = max(count, 1 + count_changes(idx + 1))\n        return count\n\n    if is_smooth(0):\n        return 0\n    else:\n        return count_changes(0) - 1\n"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_values = list(map(int, stdin.split()))\n    N, K, S = input_values[:3]\n    A = input_values[3:]\n    count = 0\n\n    for i in range(N - K + 1):\n        current_sum = sum(A[i:i + K])\n        if current_sum != S:\n            count += S - current_sum + 1\n\n    return str(count)"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    if S < K:\n        return \"0\"\n\n    smooth_changes = 0\n    for i in range(N - K + 1):\n        if sum(A[i:i + K]) % S != 0:\n            smooth_changes += (S - sum(A[i:i + K]) % S) // S\n\n    return str(smooth_changes)\n"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    frogs = [(int(x), int(d)) for x, d in [frog.split() for frog in input_list[1:]]]\n\n    def prime_factors(n):\n        i = 2\n        factors = []\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                factors.append(i)\n        if n > 1:\n            factors.append(n)\n        return factors\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def get_tower_size(frogs):\n        jump_distances = [d for x, d in frogs]\n        common_factors = set(prime_factors(lcm(jump_distances)))\n        tower_size = 1\n        for factor in common_factors:\n            tower_size *= len([frog for x, d in frogs if d % factor == 0])\n        return tower_size\n\n    def get_highest_tower(frogs):\n        highest_tower_size = max(get_tower_size(frogs[i:]) for i in range(n))\n        position = min(x for x, d in frogs if get_tower_size(frogs[i:]) == highest_tower_size)\n        return position, highest_tower_size\n\n    position, size = get_highest_tower(frogs)\n    return f'{position} {size}'"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    frogs = []\n\n    for i in range(1, n + 1):\n        x, d = map(int, input_list[i].split())\n        frogs.append((x, d))\n\n    frogs.sort(key=lambda x: x[0])\n\n    highest_tower = 1\n    current_position = frogs[0][0]\n\n    for frog in frogs:\n        if frog[0] >= current_position + frog[1]:\n            highest_tower += 1\n            current_position = frog[0] + frog[1]\n\n    return f\"{current_position} {highest_tower}\"\n"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    frogs = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    frogs.sort(key=lambda x: x[1])\n    highest_tower_pos = 0\n    highest_tower_size = 0\n    for pos, jump_distance in frogs:\n        tower_size = 1\n        while pos + jump_distance <= highest_tower_pos + highest_tower_size * jump_distance:\n            pos += jump_distance\n            tower_size += 1\n        highest_tower_pos = max(highest_tower_pos, pos)\n        highest_tower_size = max(highest_tower_size, tower_size)\n    return f\"{highest_tower_pos} {highest_tower_size}\"\n\ninput_1 = \"\"\"3\n0 2\n1 2\n3 3\"\"\"\ninput_2 = \"\"\"5\n0 2\n1 3\n3 3\n7 5\n9 5\"\"\"\n\nprint(solution(input_1))\nprint(solution(input_2))\n"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    frogs = []\n\n    for i in range(1, n + 1):\n        x, d = map(int, input_data[i].split())\n        frogs.append((x, d))\n\n    frogs.sort(key=lambda x: x[0])\n\n    min_position = float('inf')\n    max_size = 0\n\n    for i in range(n):\n        position, jump_distance = frogs[i]\n        if position < min_position:\n            min_position = position\n        if jump_distance > max_size:\n            max_size = jump_distance\n\n    return f\"{min_position} {max_size}\"\n"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    frogs = []\n\n    for i in range(1, n + 1):\n        x, d = map(int, input_data[i].split())\n        frogs.append((x, d))\n\n    frogs.sort(key=lambda x: x[0])\n    max_tower = 1\n    position = frogs[0][0]\n\n    for frog in frogs:\n        if frog[0] < position + frog[1]:\n            position += frog[1]\n        else:\n            position = frog[0]\n            max_tower = 1\n\n        max_tower = max(max_tower, frog[1])\n\n    return f\"{position} {max_tower}\"\n\ninput_data = \"\"\"3\n0 2\n1 2\n3 3\"\"\"\noutput_data = solution(input_data)\nprint(output_data) "
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    frogs = []\n    for i in range(n):\n        x, d = map(int, input().split())\n        frogs.append((x, d))\n\n    frogs.sort(key=lambda x: x[0] + x[1], reverse=True)\n    highest_frog = frogs[0]\n\n    for frog in frogs[1:]:\n        if frog[1] == highest_frog[1]:\n            highest_frog = frog\n        else:\n            break\n\n    position = highest_frog[0] + highest_frog[1]\n    size = n\n\n    return f\"{position} {size}\""
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    data = [line.split() for line in data]\n    data = [(int(x), int(d)) for x, d in data]\n\n    # Sort the frogs by their position\n    data.sort()\n\n    # Initialize variables to store the largest tower size and position\n    max_tower_size = 0\n    min_tower_position = float('inf')\n\n    # Iterate through the sorted frogs\n    for x, d in data:\n        # Check if the next frog can fit into the current tower\n        if x >= max_tower_size + d:\n            # Update the largest tower size and position\n            max_tower_size += d\n            min_tower_position = min(min_tower_position, x)\n        else:\n            # If the next frog cannot fit, move to the next position\n            max_tower_size = d\n            min_tower_position = x\n\n    # Return the results\n    return f\"{min_tower_position} {max_tower_size}\""
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    n, *frogs = map(int, stdin.split())\n    positions = sorted(frogs[::2])\n    jumping_distances = sorted(set(frogs[1::2]), reverse=True)\n\n    max_tower_size = 0\n    min_position = float('inf')\n\n    for distance in jumping_distances:\n        if distance > max_tower_size:\n            max_tower_size = distance\n            for position in positions:\n                if position + max_tower_size < min_position:\n                    min_position = position + max_tower_size\n                    break\n\n    return f\"{min_position} {max_tower_size}\"\n"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.splitlines()\n    n = int(input_data[0])\n    frogs = [(int(x), int(d)) for i, (x, d) in enumerate(zip(input_data[1:], input_data[1:]))]\n    frogs.sort(key=lambda x: x[1], reverse=True)\n    current_max = 0\n    highest_tower = []\n    for frog in frogs:\n        if frog[0] > current_max:\n            highest_tower.append(frog[1])\n            current_max = frog[0]\n    return f\"{current_max} {' '.join(str(tower) for tower in highest_tower)}\"\n\ndef"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.strip().split('\\n')\n    n = int(n)\n    data = [line.split() for line in data]\n    positions = [int(x) for x, _ in data]\n    distances = [int(d) for _, d in data]\n\n    max_position = max(positions)\n    max_tower_size = 0\n\n    for i in range(n):\n        tower_size = positions[i] // distances[i]\n        if tower_size > max_tower_size:\n            max_tower_size = tower_size\n\n    return f\"{max_position + (max_tower_size - 1) * max_tower_size} {max_tower_size}\" "
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rows = [list(map(int, line.split())) for line in stdin.splitlines()[1:n+1]]\n    cols = [list(map(int, line.split())) for line in stdin.splitlines()[n+1:]]\n\n    # check for invalid input\n    if any(sum(row) != n for row in rows) or any(sum(col) != n for col in cols):\n        raise ValueError(\"Invalid input\")\n\n    # create an nxn grid of 0s\n    grid = [[0] * (n+1) for _ in range(n)]\n\n    # mark borders\n    for i, row in enumerate(rows):\n        for j, num in enumerate(row):\n            if num == 0:\n                continue\n            for k in range(num):\n                if k == 0:\n                    grid[i][j] = 1\n                grid[i][j+k+1] = 1\n\n    for j, col in enumerate(cols):\n        for i, num in enumerate(col):\n            if num == 0:\n                continue\n            for k in range(num):\n                if k == 0:\n                    grid[i][j+k+1] = 1\n                grid[i+k+1][j] = 1\n\n    # format output\n    result = \"\"\n    for row in grid:\n        result += \"\".join(map(str, row)) + \"\\n\"\n    return result[:-1]"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    row_specs = [list(map(int, line.split())) for line in stdin.splitlines()[1:n+1]]\n    col_specs = [list(map(int, line.split())) for line in stdin.splitlines()[n+1:]]\n    \n    row_markings = []\n    col_markings = []\n    \n    for row_spec in row_specs:\n        row_marking = []\n        total_bars = sum(row_spec)\n        unmarked_borders = n - total_bars\n        for group_size in row_spec:\n            if group_size == 0:\n                row_marking.extend([0]*group_size)\n                unmarked_borders -= group_size\n            else:\n                row_marking.append(1)\n                unmarked_borders -= 1\n            if unmarked_borders > 0:\n                row_marking.append(0)\n                unmarked_borders -= 1\n        row_markings.append(row_marking)\n    \n    for col_spec in col_specs:\n        col_marking = []\n        total_bars = sum(col_spec)\n        unmarked_borders = n - total_bars\n        for group_size in col_spec:\n            if group_size == 0:\n                col_marking.extend([0]*group_size)\n                unmarked_borders -= group_size\n            else:\n                col_marking.append(1)\n                unmarked_borders -= 1\n            if unmarked_borders > 0:\n                col_marking.append(0)\n                unmarked_borders -= 1\n        col_markings.append(col_marking)\n    \n    row_markings_str = [''.join(map(str, row_marking)) for row_marking in row_markings]\n    col_markings_str = [''.join(map(str, col_marking)) for col_marking in col_markings]\n    \n    output = '\\n'.join(row_markings_str) + '\\n' + '\\n'.join(col_markings_str)\n    return output\n\ndef"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    n, *rows, *cols = stdin.split()\n    n = int(n)\n    rows = [[int(x) for x in row.split()] for row in rows]\n    cols = [[int(x) for x in col.split()] for col in cols]\n\n    def is_valid(bar, marked):\n        if not marked:\n            return True\n        if bar == 0:\n            return False\n        if bar == 1:\n            return True\n        return False\n\n    def mark_row(row_idx, row, col_widths):\n        marked = [0] * (n + 1)\n        start = 0\n        for col_idx, col_width in enumerate(col_widths):\n            for _ in range(col_width):\n                if not is_valid(row[start], marked[col_idx]):\n                    return None\n                marked[col_idx] += 1\n                start += 1\n            if col_idx + 1 < len(col_widths):\n                if not is_valid(row[start], marked[col_idx + 1]):\n                    return None\n                marked[col_idx + 1] += 1\n                start += 1\n        return marked\n\n    for i, row in enumerate(rows):\n        col_widths = cols[i]\n        marked = mark_row(i, row, col_widths)\n        if marked is None:\n            return \"No solution found for row {}\".format(i)\n\n    for j, col in enumerate(cols):\n        row_widths = rows[j]\n        marked = mark_col(j, col, row_widths)\n        if marked is None:\n            return \"No solution found for column {}\".format(j)\n\n    result = [marked[i] for i in range(n + 1)]\n    result += [marked[i] for i in range(n)]\n    return \"\\n\".join(result)\n\ninput_1 = \"2\\n1\\n0\\n0\\n3\"\ninput_2 = \"3\\n0\\n1 1\\n1\\n1 1\\n1\\n1\\n1\"\n\nprint(solution(input_1))\nprint(solution(input_2)) "
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    vertical_groups = [list(map(int, input_list[i+1].split())) for i in range(n)]\n    horizontal_groups = [list(map(int, input_list[n+1+i].split())) for i in range(n)]\n\n    # Check validity of input\n    if any(sum(1 for i in row if i != 0) != 0 for row in vertical_groups) or any(sum(1 for i in row if i != 0) != 0 for row in horizontal_groups):\n        raise ValueError(\"Invalid input: some rows/columns have no non-zero elements\")\n\n    vertical_marking = ['0'] * (n+1)\n    horizontal_marking = ['0'] * n\n\n    # Mark vertical borders\n    for i in range(n):\n        marking = vertical_marking[i]\n        unmarked_borders = sum(1 for i in range(n+1) if marking[i] == '0')\n        for group_size in vertical_groups[i]:\n            if group_size == 0:\n                continue\n            if unmarked_borders < group_size:\n                raise ValueError(\"Invalid input: not enough unmarked borders in row {}\".format(i))\n            for j in range(n+1):\n                if marking[j] == '0':\n                    marking = marking[:j] + '1' + marking[j+1:]\n                    unmarked_borders -= 1\n                    if unmarked_borders == 0:\n                        break\n            if unmarked_borders > 0:\n                raise ValueError(\"Invalid input: not enough vertical groups in row {}\".format(i))\n        vertical_marking[i] = marking\n\n    # Mark horizontal borders\n    for i in range(n):\n        marking = horizontal_marking[i]\n        unmarked_borders = sum(1 for i in range(n) if marking[i] == '0')\n        for group_size in horizontal_groups[i]:\n            if group_size == 0:\n                continue\n            if unmarked_borders < group_size:\n                raise ValueError(\"Invalid input: not enough unmarked borders in column {}\".format(i))\n            for j in range(n):\n                if marking[j] == '0':\n                    marking = marking[:j] + '1' + marking[j+1:]\n                    unmarked_borders -= 1\n                    if unmarked_borders == 0:\n                        break\n            if unmarked_borders > 0:\n                raise ValueError(\"Invalid input: not enough horizontal groups in column {}\".format(i))\n        horizontal_marking[i] = marking\n\n    return ''.join(vertical_marking) + '\\n' + ''.join(horizontal_marking)"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.split('\\n')\n    n = int(input_str.pop(0))\n    row_spec = [list(map(int, line.split())) for line in input_str[:n]]\n    col_spec = [list(map(int, line.split())) for line in input_str[n:]]\n\n    row_groups = [[0] * (n + 1) for _ in range(n)]\n    col_groups = [[0] * n for _ in range(n + 1)]\n\n    for i, row in enumerate(row_spec):\n        j = 0\n        while j < n + 1:\n            k = j\n            while k < n + 1 and row[k - j] > 0:\n                k += 1\n            row_groups[i][j:k] = [1] * (k - j)\n            j = k\n\n    for i, col in enumerate(col_spec):\n        j = 0\n        while j < n:\n            k = j\n            while k < n and col[k - j] > 0:\n                k += 1\n            col_groups[i][j:k] = [1] * (k - j)\n            j = k\n\n    row_solution = [''.join(map(str, row)) for row in row_groups]\n    col_solution = [''.join(map(str, col)) for col in col_groups]\n\n    return '\\n'.join(row_solution) + '\\n' + '\\n'.join(col_solution) + '\\n'\n\ninput_str = '''2\n1\n0\n0\n3\n'''\nprint(solution(input_str))\n\ninput_str = '''3\n0\n1 1\n1\n1 1\n1\n1\n'''\nprint(solution(input_str))"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    n_rows = n + 1\n    n_cols = n + 1\n    \n    row_borders = [line.split() for line in stdin.split('\\n')[1:n+1]]\n    col_borders = [line.split() for line in stdin.split('\\n')[n+1:]]\n    \n    row_borders = [[int(x) for x in row] for row in row_borders]\n    col_borders = [[int(x) for x in row] for row in col_borders]\n    \n    row_solution = [0] * n_rows\n    col_solution = [0] * n_cols\n    \n    def mark_vertical_borders(row_idx, group_size, row_borders, row_solution):\n        row_borders[row_idx][0] = group_size\n        row_solution[row_idx] = 1\n        \n        if group_size == 0:\n            return\n        \n        # Mark adjacent vertical borders\n        for col_idx in range(1, n_cols):\n            if col_idx - 1 < n:\n                if col_borders[col_idx - 1][row_idx] == 0:\n                    row_borders[row_idx][col_idx] = 0\n                else:\n                    row_borders[row_idx][col_idx] = group_size\n                    row_solution[row_idx] = 1\n                    \n                if col_idx > 1 and col_borders[col_idx - 2][row_idx] > 0:\n                    row_borders[row_idx][col_idx] = 0\n                elif col_idx < n and col_borders[col_idx][row_idx] > 0:\n                    row_borders[row_idx][col_idx] = 0\n                    \n            else:\n                row_borders[row_idx][col_idx] = 0\n    \n    def mark_horizontal_borders(col_idx, group_size, col_borders, col_solution):\n        col_borders[col_idx - 1][0] = group_size\n        col_solution[col_idx - 1] = 1\n        \n        if group_size == 0:\n            return\n        \n        # Mark adjacent horizontal borders\n        for row_idx in range(1, n_rows):\n            if row_idx - 1 < n:\n                if row_borders[row_idx - 1][col_idx - 1] == 0:\n                    col_borders[col_idx - 1][row_idx] = 0\n                else:\n                    col_borders[col_idx - 1][row_idx] = group_size\n                    col_solution[col_idx - 1] = 1\n                    \n                if row_idx > 1 and row_borders[row_idx - 2][col_idx - 1] > 0:\n                    col_borders[col_idx - 1][row_idx] = 0\n                elif row_idx < n and row_borders[row_idx][col_idx - 1] > 0:\n                    col_borders[col_idx - 1][row_idx] = 0\n                    \n            else:\n                col_borders[col_idx - 1][row_idx] = 0\n    \n    for i in range(n):\n        row_size = row_borders[i][0]\n        mark_vertical_borders(i, row_size, row_borders, row_solution)\n        \n    for j in range(1, n+1):\n        col_size = col_borders[j-1][0]\n        mark_horizontal_borders(j, col_size, col_borders, col_solution)\n    \n    return ''.join([str(x) for x in row_solution]) + '\\n' + ''.join([str(x) for x in col_solution])"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.strip().split(\"\\n\")\n    n = int(input_list[0])\n    row_spec = input_list[1:n+1]\n    col_spec = input_list[n+1:]\n\n    def is_valid(marking: str) -> bool:\n        for i in range(n+1):\n            if i == 0 or i == n:\n                if marking[i] == \"1\":\n                    return False\n            else:\n                if marking[i-1] == \"1\" and marking[i] == \"1\":\n                    return False\n        for j in range(1, n+1):\n            if j == 0 or j == n:\n                if marking[j] == \"1\":\n                    return False\n            else:\n                if marking[j-1] == \"1\" and marking[j] == \"1\":\n                    return False\n        return True\n\n    def fill_row_bars(row_spec: List[str], col_marking: str) -> str:\n        row_marking = \"\"\n        for spec_line in row_spec:\n            if spec_line == \"0\":\n                row_marking += \"0\"\n            else:\n                for i, count in enumerate(spec_line.split()):\n                    count = int(count)\n                    if count == 0:\n                        row_marking += \"0\"\n                    else:\n                        row_marking += \"1\"\n                        count -= 1\n                        while count > 0:\n                            if col_marking[i] == \"0\":\n                                row_marking += \"0\"\n                                break\n                            else:\n                                row_marking += \"1\"\n                                count -= 1\n                        if count > 0:\n                            row_marking += \"0\"\n                        else:\n                            row_marking += \"1\"\n        return row_marking\n\n    def fill_col_bars(col_spec: List[str], row_marking: str) -> str:\n        col_marking = \"\"\n        for spec_line in col_spec:\n            if spec_line == \"0\":\n                col_marking += \"0\"\n            else:\n                for i, count in enumerate(spec_line.split()):\n                    count = int(count)\n                    if count == 0:\n                        col_marking += \"0\"\n                    else:\n                        col_marking += \"1\"\n                        count -= 1\n                        while count > 0:\n                            if row_marking[i] == \"0\":\n                                col_marking += \"0\"\n                                break\n                            else:\n                                col_marking += \"1\"\n                                count -= 1\n                        if count > 0:\n                            col_marking += \"0\"\n                        else:\n                            col_marking += \"1\"\n        return col_marking\n\n    row_marking = fill_row_bars(row_spec, col_spec[0])\n    col_marking = fill_col_bars(col_spec, row_marking)\n\n    while not is_valid(row_marking) or not is_valid(col_marking):\n        if not is_valid(row_marking):\n            for i in range(n):\n                if row_marking[i] == \"1\":\n                    row_marking = row_marking[:i] + \"0\" + row_marking[i+1:]\n                    break\n            col_marking = fill_col_bars(col_spec, row_marking)\n        else:\n            for j in range(1, n+1):\n                if col_marking[j] == \"1\":\n                    col_marking = col_marking[:j] + \"0\" + col_marking[j+1:]\n                    break\n            row_marking = fill_row_bars(row_spec, col_marking)\n\n    return row_marking + \"\\n\" + col_marking"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    row_spec = input_list[1:n+1]\n    col_spec = input_list[n+1:]\n\n    row_markings = []\n    for i in range(n):\n        row_spec_i = [int(x) for x in row_spec[i].split()]\n        row_marking = ''\n        for j in range(n+1):\n            if j in [k+1 for k in range(len(row_spec_i)-1)]:\n                row_marking += '0'\n            else:\n                row_marking += '1'\n        row_markings.append(row_marking)\n\n    col_markings = []\n    for j in range(n):\n        col_spec_j = [int(x) for x in col_spec[j].split()]\n        col_marking = ''\n        for i in range(n):\n            if i in [k for k in range(len(col_spec_j)-1)]:\n                col_marking += '0'\n            else:\n                col_marking += '1'\n        col_markings.append(col_marking)\n\n    return '\\n'.join(row_markings) + '\\n' + '\\n'.join(col_markings)"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    row_spec = stdin[1:n+1]\n    col_spec = stdin[n+1:].split('\\n')\n\n    # Helper function to check if a row/column meets the spec\n    def meets_spec(spec, group_sizes):\n        count = 0\n        for size in group_sizes:\n            count += size\n        return count == spec\n\n    # Check if there are any valid markings\n    valid_marking = False\n    for i in range(n):\n        row_spec_i = [int(x) for x in row_spec[i].split()]\n        col_spec_i = [int(x) for x in col_spec[i].split()]\n        if meets_spec(n, row_spec_i) and meets_spec(n, col_spec_i):\n            valid_marking = True\n            break\n\n    if not valid_marking:\n        raise ValueError(\"No valid marking exists for the given specification.\")\n\n    # Generate a marking\n    marking = ['0' for _ in range(n+1)]\n    for i in range(n):\n        row_spec_i = [int(x) for x in row_spec[i].split()]\n        col_spec_i = [int(x) for x in col_spec[i].split()]\n        if row_spec_i[0] > 0:\n            marking[i] = '1'\n        if col_spec_i[0] > 0:\n            marking[i+1] = '1'\n\n    # Output the solution\n    output = []\n    for i in range(n+1):\n        output.append(''.join([marking[i]] + ['0' for _ in range(n-1)]))\n    output += [''.join(['0' for _ in range(n)] + [marking[i]]) for i in range(1, n+1)]\n    return '\\n'.join(output)"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    row_spec = input_list[1:n+1]\n    col_spec = input_list[n+1:]\n\n    row_markings = [\"\" for _ in range(n+1)]\n    col_markings = [\"\" for _ in range(n)]\n\n    # Generate vertical bars\n    for i, row_spec_str in enumerate(row_spec):\n        row_spec = [int(x) for x in row_spec_str.split()]\n        num_bars = sum(row_spec)\n        cur_pos = 0\n        for size in row_spec:\n            if size == 0:\n                cur_pos += size\n                continue\n            row_markings[i+1] = row_markings[i+1][:cur_pos] + \"1\" + row_markings[i+1][cur_pos+1:]\n            cur_pos += size + 1\n\n    # Generate horizontal bars\n    for j, col_spec_str in enumerate(col_spec):\n        col_spec = [int(x) for x in col_spec_str.split()]\n        num_bars = sum(col_spec)\n        cur_pos = 0\n        for size in col_spec:\n            if size == 0:\n                cur_pos += size\n                continue\n            col_markings[j] = col_markings[j][:cur_pos] + \"1\" + col_markings[j][cur_pos+1:]\n            cur_pos += size + 1\n\n    result = \"\\n\".join(row_markings) + \"\\n\" + \"\\n\".join(col_markings) + \"\\n\"\n    return result"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_conflict(show1, show2):\n        return show1[1] <= show2[0]\n\n    def is_full_show(show, show_end_times):\n        return show[1] in show_end_times\n\n    n, k = map(int, stdin.splitlines()[0].split())\n    shows = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    show_end_times = set(show[1] for show in shows)\n    full_shows = [show for show in shows if is_full_show(show, show_end_times)]\n\n    max_shows = 0\n    for i in range(len(full_shows)):\n        for j in range(i + 1, len(full_shows)):\n            if not is_conflict(full_shows[i], full_shows[j]):\n                max_shows += 1\n\n    return str(max_shows)"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 1,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    tv_shows = []\n    for i in range(1, n+1):\n        x, y = map(int, input_list[i].split())\n        tv_shows.append((x, y))\n\n    tv_shows.sort(key=lambda x: x[1])\n\n    max_shows = 0\n    start_time = 0\n    recording_shows = []\n    for show in tv_shows:\n        if show[0] >= start_time:\n            recording_shows.append(show)\n            max_shows += 1\n        elif show[0] > start_time:\n            recording_shows.pop(0)\n            max_shows -= 1\n            recording_shows.append(show)\n            max_shows += 1\n\n        start_time = show[1]\n\n        if max_shows == k:\n            break\n\n    return str(max_shows)"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 2,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list.pop(0).split())\n    shows = []\n    for _ in range(n):\n        x, y = map(int, input_list.pop(0).split())\n        shows.append((x, y))\n\n    shows.sort(key=lambda x: x[1])  # sort by finish time\n    max_shows = 0\n    current_time = 0\n    while shows:\n        show, finish_time = shows.pop(0)\n        if show[0] >= current_time:\n            max_shows += 1\n            current_time = show[1]\n\n    return str(max_shows)\n"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 3,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shows = sorted(list(map(int, stdin.split()[2:])))\n\n    def record_show(records, show):\n        for i in range(k):\n            if records[i][1] < show[0]:\n                records[i] = show\n                return True\n        return False\n\n    records = [(-1, -1)] * k\n    full_shows = 0\n\n    for show in shows:\n        if record_show(records, show):\n            full_shows += 1\n\n    return str(full_shows)\n"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 4,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    shows = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        shows.append((x, y))\n\n    shows.sort(key=lambda x: x[1])\n    i, count = 0, 0\n\n    while i < n and shows[i][1] <= shows[0][1] + k * 24 * 60 * 60:\n        count += 1\n        i += k\n\n    return str(count)\n"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 5,
        "answer": "def solution(stdin: str) -> str:\n    def is_full_show(show: int, shows: list, recorded_shows: set) -> bool:\n        return all(show != other and x_other <= y_show and y_other >= x_show\n                   for other in recorded_shows\n                   for x_other, y_other in shows)\n\n    n, k = map(int, stdin.split()[0:2])\n    shows = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    full_shows = 0\n    recorded_shows = set()\n    for show in range(n):\n        if is_full_show(show, shows, recorded_shows):\n            full_shows += 1\n            recorded_shows.add(show)\n        if len(recorded_shows) == k:\n            break\n\n    return str(full_shows)\n"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 6,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shows = []\n    for i in range(1, n + 1):\n        x, y = map(int, stdin.split()[i:i + 2])\n        shows.append((x, y))\n\n    # Sort shows by start time\n    shows.sort(key=lambda x: x[0])\n\n    # Merge overlapping shows\n    merged_shows = []\n    curr_start, curr_end = shows[0]\n    for i in range(1, len(shows)):\n        next_start, next_end = shows[i]\n        if next_start <= curr_end:\n            curr_end = max(curr_end, next_end)\n        else:\n            merged_shows.append((curr_start, curr_end))\n            curr_start, curr_end = next_start, next_end\n    merged_shows.append((curr_start, curr_end))\n\n    # Count full shows\n    full_shows = 0\n    for show in merged_shows:\n        if show[1] - show[0] >= k:\n            full_shows += 1\n\n    return str(full_shows)\n\n\ndef"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 7,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shows = [tuple(map(int, input().split())) for _ in range(n)]\n\n    shows.sort(key=lambda x: x[1])\n    start_time = shows[0][0]\n    end_time = shows[0][1]\n    count = 1\n\n    for i in range(1, n):\n        if shows[i][0] >= end_time:\n            start_time = shows[i][0]\n            end_time = shows[i][1]\n            count += 1\n        elif shows[i][1] > end_time:\n            end_time = shows[i][1]\n\n    return str(min(count, k))"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 8,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    tv_shows = [tuple(map(int, input().split())) for _ in range(n)]\n    \n    # Sort the TV shows by their starting time\n    tv_shows.sort(key=lambda x: x[0])\n    \n    # Initialize a list to store the ending times of the shows\n    show_ends = [0] * k\n    \n    # Initialize a variable to store the maximum number of shows\n    max_shows = 0\n    \n    for show in tv_shows:\n        # Find the slot with the earliest ending time\n        slot = show_ends.index(min(show_ends))\n        \n        # Check if the show can be recorded in the slot\n        if show[0] >= show_ends[slot]:\n            # Update the ending time of the show in the slot\n            show_ends[slot] = show[1]\n            \n            # Increment the maximum number of shows\n            max_shows += 1\n        else:\n            # Skip the show and move on to the next one\n            continue\n            \n    return str(max_shows)\n"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 9,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip().split('\\n')\n    n, k = map(int, input_str[0].split())\n    shows = [tuple(map(int, line.split())) for line in input_str[1:]]\n    shows.sort(key=lambda x: x[1])\n    count = 0\n    current_show = shows[0]\n\n    for show in shows:\n        if show[0] >= current_show[1]:\n            count += 1\n            current_show = show\n\n    return str(count)\n"
    }
]