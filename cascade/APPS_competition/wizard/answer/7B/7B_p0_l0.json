[
    {
        "number": 3000,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    tokens = stdin.splitlines()[1].split()\n\n    stack = []\n    for token in tokens:\n        if token == '(':\n            stack.append('(')\n        elif token == ')':\n            subseq = []\n            while stack and stack[-1] != '(':\n                subseq.append(stack.pop())\n            stack.pop()\n            subseq.reverse()\n            stack.append(eval(''.join(str(x) for x in subseq)))\n        else:\n            stack.append(int(token))\n\n    result = 0\n    while stack:\n        result = (result + stack.pop()) % (10**9 + 7)\n\n    return str(result)\n"
    },
    {
        "number": 3001,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(num: str) -> bool:\n        return num == num[::-1]\n\n    def next_palindrome(num: str) -> str:\n        def increment_digit(digit: str) -> str:\n            if digit == '9':\n                return '0'\n            else:\n                return str(int(digit) + 1)\n\n        def increment_number(num: str) -> str:\n            if num[-1] == '9':\n                return increment_number(num[:-1]) + '0'\n            else:\n                return num[:-1] + increment_digit(num[-1])\n\n        def reverse_number(num: str) -> str:\n            return num[::-1]\n\n        def is_palindrome(num: str) -> bool:\n            return num == num[::-1]\n\n        def is_valid_palindrome(num: str) -> bool:\n            return is_palindrome(num) and num.count('0') <= num.count('1')\n\n        def find_next_palindrome(num: str) -> str:\n            while not is_valid_palindrome(num):\n                num = increment_number(num)\n            return num\n\n        return find_next_palindrome(reverse_number(num))\n\n    def count_steps(num: str) -> int:\n        def count_digits(num: str) -> int:\n            return len(num)\n\n        def count_zeros(num: str) -> int:\n            return num.count('0')\n\n        def count_ones(num: str) -> int:\n            return num.count('1')\n\n        def count_steps(num: str) -> int:\n            if count_digits(num) == 1:\n                return 0\n            elif count_digits(num) == 2:\n                return 1\n            else:\n                return count_ones(num) + count_steps(num[:-1])\n\n        return count_steps(num)\n\n    num = stdin.strip()\n    palindrome = next_palindrome(num)\n    steps = count_steps(palindrome)\n    return str(steps)"
    },
    {
        "number": 3002,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_tampered(history: list) -> bool:\n        for i in range(len(history) - 1):\n            if history[i][2] > history[i + 1][2]:\n                return True\n        return False\n\n    def is_serviced_often_enough(history: list, max_distance: int, max_months: int) -> bool:\n        total_distance = 0\n        total_months = 0\n        for i in range(len(history) - 1):\n            total_distance += history[i + 1][2] - history[i][2]\n            total_months += (history[i + 1][0] - history[i][0]) * 12 + (history[i + 1][1] - history[i][1])\n            if total_distance > max_distance or total_months > max_months:\n                return False\n        return True\n\n    def is_legit(history: list) -> bool:\n        if is_tampered(history):\n            return False\n        return is_serviced_often_enough(history, 30000, 12)\n\n    n = int(stdin.splitlines()[0])\n    history = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    if is_legit(history):\n        return \"seems legit\"\n    elif is_tampered(history):\n        return \"tampered odometer\"\n    else:\n        return \"insufficient service\""
    },
    {
        "number": 3003,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, color, vertex, num_colors):\n        visited[vertex] = True\n        for neighbor in graph[vertex]:\n            if not visited[neighbor]:\n                for i in range(num_colors):\n                    if color[neighbor] == -1 or color[neighbor] != i:\n                        color[neighbor] = i\n                        if dfs(graph, visited, color, neighbor, num_colors):\n                            return True\n                        color[neighbor] = -1\n        return False\n\n    def min_colors(graph, num_colors):\n        color = [-1] * len(graph)\n        visited = [False] * len(graph)\n        for vertex in range(len(graph)):\n            if not visited[vertex]:\n                for i in range(num_colors):\n                    color[vertex] = i\n                    if dfs(graph, visited, color, vertex, num_colors):\n                        return i + 1\n        return num_colors\n\n    lines = stdin.split('\\n')\n    num_vertices = int(lines[0])\n    graph = [[] for _ in range(num_vertices)]\n    for i in range(1, num_vertices):\n        for j in map(int, lines[i].split()):\n            graph[i].append(j)\n            graph[j].append(i)\n    num_colors = min_colors(graph, num_vertices)\n    return num_colors"
    },
    {
        "number": 3004,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_offer(offer: list) -> bool:\n        colors = set()\n        for i in range(offer[1], offer[2] + 1):\n            colors.add(offer[0])\n            if len(colors) > 3:\n                return False\n        return True\n\n    def find_min_offers(offers: list) -> int:\n        min_offers = float('inf')\n        for i in range(1, 10001):\n            for j in range(i, 10001):\n                if j - i + 1 <= 3000:\n                    valid_offer = True\n                    for offer in offers:\n                        if offer[1] <= i <= offer[2] or offer[1] <= j <= offer[2]:\n                            valid_offer = False\n                            break\n                    if valid_offer:\n                        min_offers = min(min_offers, j - i + 1)\n        return min_offers if min_offers != float('inf') else \"IMPOSSIBLE\"\n\n    offers = []\n    for line in stdin.split('\\n'):\n        color, start, end = line.split()\n        offers.append([color, int(start), int(end)])\n\n    valid_offers = [offer for offer in offers if is_valid_offer(offer)]\n    min_offers = find_min_offers(valid_offers)\n\n    return str(min_offers)"
    },
    {
        "number": 3005,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorize(s: str) -> str:\n        i = 0\n        while i < len(s) - 1:\n            j = i + 1\n            while j < len(s) and s[i] == s[j]:\n                j += 1\n            if j - i > 1:\n                s = s[:i] + \"(\" + s[i:j] + \")^\" + str(j - i) + s[j:]\n                i = j\n            else:\n                i = j\n        return s\n\n    def max_factorize(s: str) -> str:\n        factorized = factorize(s)\n        max_weight = float('inf')\n        max_factoring = \"\"\n        for i in range(1, len(factorized) + 1):\n            factoring = factorized[:i] + \")\" * (len(factorized) - i)\n            weight = len(factoring) - factoring.count(\")\")\n            if weight < max_weight:\n                max_weight = weight\n                max_factoring = factoring\n        return max_factoring\n\n    return len(max_factorize(stdin))\n"
    },
    {
        "number": 3006,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def apply_operation(s: str, op: str, pos: int, c: str) -> str:\n        if op == 'D':\n            return s[:pos-1] + s[pos:]\n        elif op == 'I':\n            return s[:pos] + c + s[pos:]\n        else:\n            return s\n\n    def compare_programs(prog1: str, prog2: str) -> bool:\n        s = ''\n        for op1, op2 in zip(prog1.split('\\n'), prog2.split('\\n')):\n            if op1 != op2:\n                return False\n            if op1.startswith('D'):\n                pos = int(op1.split()[1])\n                s = apply_operation(s, 'D', pos, '')\n            elif op1.startswith('I'):\n                pos, c = map(int, op1.split()[1:])\n                s = apply_operation(s, 'I', pos, chr(c))\n        return s == ''\n\n    prog1, prog2 = stdin.split('\\n\\n')\n    return '0' if compare_programs(prog1, prog2) else '1'"
    },
    {
        "number": 3007,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, b, f, t0, t1, t2 = map(int, stdin.split())\n\n    # Calculate the maximum amount of Bling Johan can have after playing d days\n    max_bling = b + 100 * f + 500 * t0 + 1500 * t1 + 2500 * t2\n\n    return str(max_bling)"
    },
    {
        "number": 3008,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:N+2]))\n    b = list(map(int, stdin.split()[N+2:]))\n\n    def rank(i, j):\n        return a[i] + b[i] - a[j] - b[j]\n\n    def count_ranks(rankings):\n        return len(set(rankings))\n\n    max_rankings = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if rank(i, j) <= K:\n                max_rankings += 1\n\n    return str(max_rankings)\n"
    },
    {
        "number": 3009,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(p, rect):\n        return rect[0][0] <= p[0] <= rect[1][0] and rect[0][1] <= p[1] <= rect[1][1]\n\n    def is_overlap(rect1, rect2):\n        return is_inside(rect1[0], rect2) or is_inside(rect1[1], rect2) or is_inside(rect2[0], rect1) or is_inside(rect2[1], rect1)\n\n    def shortest_line(lamps):\n        rect = [(0, 0), (99, 99)]\n        min_length = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                if not is_overlap((lamps[i], lamps[j]), rect):\n                    d = distance(lamps[i], lamps[j])\n                    if d < min_length:\n                        min_length = d\n        return min_length\n\n    def balance_line(lamps):\n        rect = [(0, 0), (99, 99)]\n        min_length = float('inf')\n        for i in range(len(lamps)):\n            for j in range(i + 1, len(lamps)):\n                if not is_overlap((lamps[i], lamps[j]), rect):\n                    d = distance(lamps[i], lamps[j])\n                    if d < min_length:\n                        min_length = d\n                        line = (lamps[i], lamps[j])\n        return line\n\n    def energy_balance(lamps):\n        positive_energy = 0\n        negative_energy = 0\n        for lamp in lamps:\n            if lamp[2] >= 0:\n                positive_energy += lamp[2]\n            else:\n                negative_energy += lamp[2]\n        return positive_energy, negative_energy\n\n    def main(stdin: str) -> str:\n        n = int(stdin.splitlines()[0])\n        lamps = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n        lamps.sort(key=lambda x: x[0])\n\n        if n == 1:\n            return \"IMPOSSIBLE\"\n\n        positive_energy, negative_energy = energy_balance(lamps)\n        if positive_energy == 0 or negative_energy == 0:\n            return \"IMPOSSIBLE\"\n\n        shortest_length = shortest_line(lamps)\n        if shortest_length == float('inf'):\n            return \"IMPOSSIBLE\"\n\n        balance_line_length = shortest_line(balance_line(lamps))\n        if balance_line_length == float('inf'):\n            return \"IMPOSSIBLE\"\n\n        return round(shortest_length, 6)\n\n    return main(stdin)"
    },
    {
        "number": 3010,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def intersect(x0, y0, x1, y1, x2, y2, x3, y3):\n        return (x1 - x0) * (y2 - y3) - (y1 - y0) * (x2 - x3)\n\n    def is_intersect(x0, y0, x1, y1, x2, y2, x3, y3):\n        return intersect(x0, y0, x1, y1, x2, y2, x3, y3) != 0\n\n    def is_touch(x0, y0, x1, y1, x2, y2, x3, y3):\n        return intersect(x0, y0, x1, y1, x2, y2, x3, y3) == 0 and (x0 - x1) * (x2 - x3) + (y0 - y1) * (y2 - y3) == 0\n\n    def count_intersect_touch_points(lines):\n        points = set()\n        for i in range(len(lines)):\n            for j in range(i + 1, len(lines)):\n                x0, y0, x1, y1 = lines[i]\n                x2, y2, x3, y3 = lines[j]\n                if is_intersect(x0, y0, x1, y1, x2, y2, x3, y3):\n                    points.add((x0, y0))\n                    points.add((x1, y1))\n                    points.add((x2, y2))\n                    points.add((x3, y3))\n                elif is_touch(x0, y0, x1, y1, x2, y2, x3, y3):\n                    points.add((x0, y0))\n                    points.add((x1, y1))\n                    points.add((x2, y2))\n                    points.add((x3, y3))\n        return len(points)\n\n    lines = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    result = count_intersect_touch_points(lines)\n    return str(result)\n"
    },
    {
        "number": 3011,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, n+1):\n        if is_hill_number(i):\n            count += 1\n    if is_hill_number(n):\n        return str(count)\n    else:\n        return \"-1\"\n\ndef"
    },
    {
        "number": 3012,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a11, a12, a21, a22, N = map(int, stdin.split())\n    MOD = 1000000007\n\n    def count_sequences(a11, a12, a21, a22, N):\n        if N == 1:\n            return (a11 + a12 + a21 + a22) * (a11 + a12 + a21 + a22 - 1) // 2 % MOD\n        elif N == 2:\n            return (a11 + a12 + a21 + a22) * (a11 + a12 + a21 + a22 - 1) * (a11 + a12 + a21 + a22 - 2) * (a11 + a12 + a21 + a22 - 3) // 24 % MOD\n        else:\n            return 0\n\n    return str(count_sequences(a11, a12, a21, a22, N))"
    },
    {
        "number": 3013,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, tx, ty = map(float, stdin.split())\n    target = (tx, ty)\n    r = b * np.pi / 180\n    theta = np.arctan2(target[1], target[0])\n    x = r * np.cos(theta)\n    y = r * np.sin(theta)\n    return f\"{x:.6f} {y:.6f}\"\n\nimport numpy as np\nimport sys"
    },
    {
        "number": 3014,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    corridors = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    def dfs(start, visited, parent, cycle):\n        visited[start] = True\n        for neighbor in [c for c in corridors if c[0] == start]:\n            if not visited[neighbor[1]]:\n                if dfs(neighbor[1], visited, start, cycle):\n                    cycle.append((neighbor[0], neighbor[1]))\n                    return True\n            elif parent != neighbor[1]:\n                cycle.append((neighbor[0], neighbor[1]))\n                return True\n        return False\n\n    removed_corridors = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if (i, j) not in corridors:\n                continue\n            visited = [False] * (n + 1)\n            cycle = []\n            if dfs(i, visited, -1, cycle):\n                removed_corridors.append((i, j))\n\n    return len(removed_corridors) // 2, removed_corridors[:len(removed_corridors) // 2]\n"
    },
    {
        "number": 3015,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, s, t = map(int, input_list[0].split())\n    tubes = [tuple(map(int, input_list[i+1].split())) for i in range(m)]\n\n    def dfs(ball, time, visited):\n        if ball == t:\n            return time\n        visited.add(ball)\n        for a, b, w in tubes:\n            if a == ball and b not in visited:\n                time += w\n                time = dfs(b, time, visited)\n                if time == float('inf'):\n                    return time\n        visited.remove(ball)\n        return time\n\n    time = dfs(s, 0, set())\n    return \"infinity\" if time == float('inf') else str(time)"
    },
    {
        "number": 3016,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    balls = list(map(int, input_list[1].split()))\n    forbidden_colors = list(map(int, input_list[2].split()))\n    favorite_sequence = list(map(int, input_list[3].split()))\n\n    def count_arrangements(balls, forbidden_colors, favorite_sequence):\n        def is_valid(balls, forbidden_colors, favorite_sequence):\n            for i in range(len(balls) - len(favorite_sequence) + 1):\n                if balls[i:i + len(favorite_sequence)] == favorite_sequence:\n                    for j in range(len(forbidden_colors)):\n                        if balls[i + j] in forbidden_colors[j]:\n                            return False\n            return True\n\n        def count_ways(balls, forbidden_colors, favorite_sequence, start, count):\n            if start == len(balls):\n                return count\n            if not is_valid(balls[start:], forbidden_colors, favorite_sequence):\n                return count_ways(balls, forbidden_colors, favorite_sequence, start + 1, count)\n            return count_ways(balls, forbidden_colors, favorite_sequence, start + 1, count + 1)\n\n        return count_ways(balls, forbidden_colors, favorite_sequence, 0, 0)\n\n    result = count_arrangements(balls, forbidden_colors, favorite_sequence)\n    return str(result % 1000000007)"
    },
    {
        "number": 3017,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, e = map(int, stdin.split())\n    count = 0\n    for i in range(n+1):\n        if str(i) in str(2**e):\n            count += 1\n    return str(count)"
    },
    {
        "number": 3018,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, T = map(int, stdin.split()[0:2])\n    dice_rolls = list(map(int, stdin.split()[2:]))\n\n    def probability(dice_rolls, target, dice_to_pickup):\n        total_rolls = sum(dice_rolls)\n        if total_rolls + dice_to_pickup * K >= target:\n            return 1\n        else:\n            return 0\n\n    max_probability = 0\n    max_dice_to_pickup = 0\n\n    for dice_to_pickup in range(K):\n        probability_with_dice_to_pickup = probability(dice_rolls, T, dice_to_pickup)\n        if probability_with_dice_to_pickup > max_probability:\n            max_probability = probability_with_dice_to_pickup\n            max_dice_to_pickup = dice_to_pickup\n\n    return str(max_dice_to_pickup + 1)\n"
    },
    {
        "number": 3019,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def prime_factors(n: int) -> int:\n        count = 0\n        for i in range(2, n + 1):\n            while n % i == 0:\n                count += 1\n                n //= i\n        return count\n\n    N, *data = stdin.split()\n    N = int(N)\n    data = list(map(int, data))\n\n    max_revenue = 0\n    for i in range(N):\n        revenue = prime_factors(sum(data[i]))\n        max_revenue = max(max_revenue, revenue)\n\n    return str(max_revenue)\n"
    },
    {
        "number": 3020,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return '0'\n    for a in range(1, N):\n        if a * a == N:\n            return str(a)\n    return '-1'\n\ndef"
    },
    {
        "number": 3021,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, N = map(int, stdin.split()[0].split())\n    words = stdin.split()[1:]\n\n    # Check for inconsistencies\n    for i in range(N):\n        for j in range(i + 1, N):\n            if words[i] < words[j]:\n                if words[j][:len(words[i])] < words[i]:\n                    return \"IMPOSSIBLE\"\n            elif words[i] > words[j]:\n                if words[j][:len(words[i])] > words[i]:\n                    return \"IMPOSSIBLE\"\n\n    # Check for ambiguity\n    for i in range(N):\n        for j in range(i + 1, N):\n            if words[i] < words[j]:\n                if words[j][:len(words[i])] > words[i]:\n                    return \"AMBIGUOUS\"\n            elif words[i] > words[j]:\n                if words[j][:len(words[i])] < words[i]:\n                    return \"AMBIGUOUS\"\n\n    # Determine alphabet order\n    alphabet = [chr(ord('a') + i) for i in range(L - ord('a') + 1)]\n    for i in range(N):\n        for j in range(len(words[i])):\n            if words[i][j] not in alphabet:\n                continue\n            alphabet.remove(words[i][j])\n            alphabet.insert(ord(words[i][j]) - ord('a'), words[i][j])\n\n    return ''.join(alphabet)\n"
    },
    {
        "number": 3022,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B, C = map(int, stdin.split())\n    total_cookies = A + B + C\n    max_cookies = (N // 2) * total_cookies\n    return str(max_cookies)"
    },
    {
        "number": 3023,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    candles = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n    cuts = [tuple(map(int, input_list[i+1+n].split())) for i in range(m)]\n\n    def is_inside_circle(point):\n        x, y = point\n        return x**2 + y**2 <= r**2\n\n    def is_on_cut(point):\n        x, y = point\n        return any(a*x + b*y + c == 0 for a, b, c in cuts)\n\n    def is_valid_cut(point):\n        return is_inside_circle(point) and not is_on_cut(point)\n\n    def is_valid_piece(piece):\n        return all(is_valid_cut(candle) for candle in piece)\n\n    def find_pieces(candles):\n        pieces = []\n        while candles:\n            piece = [candles.pop(0)]\n            while candles and is_valid_cut(piece[-1]):\n                piece.append(candles.pop(0))\n            pieces.append(piece)\n        return pieces\n\n    pieces = find_pieces(candles)\n    return \"yes\" if all(is_valid_piece(piece) for piece in pieces) else \"no\""
    },
    {
        "number": 3024,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def find_palindrome(s: str, k: int) -> bool:\n        for i in range(len(s) - k + 1):\n            if is_palindrome(s[i:i + k]):\n                return True\n        return False\n\n    n = len(stdin)\n    max_k = 1\n    for k in range(2, n // 2 + 1):\n        if find_palindrome(stdin, k):\n            max_k = k\n        else:\n            break\n\n    return str(max_k)\n"
    },
    {
        "number": 3025,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    gold_list = list(map(int, input_list[1].split()))\n    road_list = [list(map(int, input_list[i+2].split())) for i in range(m)]\n\n    # Create a graph using adjacency list\n    graph = [[] for _ in range(n)]\n    for road in road_list:\n        graph[road[0]-1].append(road[1]-1)\n        graph[road[1]-1].append(road[0]-1)\n\n    # BFS to find the shortest path from every village to the king's castle\n    shortest_path = [-1] * n\n    shortest_path[0] = 0\n    queue = [0]\n    while queue:\n        current_village = queue.pop(0)\n        for neighbor in graph[current_village]:\n            if shortest_path[neighbor] == -1:\n                shortest_path[neighbor] = shortest_path[current_village] + 1\n                queue.append(neighbor)\n\n    # Calculate the maximum amount of gold that the bandits can purloin\n    max_gold = 0\n    for i in range(2, n):\n        max_gold += gold_list[i] * shortest_path[i]\n\n    return max_gold"
    },
    {
        "number": 3026,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n    critical_elements = []\n\n    for i in range(n):\n        if sequence[i] > sequence[i + 1]:\n            critical_elements.append(sequence[i])\n\n    if len(critical_elements) == 0:\n        return \"-1\"\n    else:\n        return \" \".join(map(str, sorted(critical_elements)))\n"
    },
    {
        "number": 3027,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    mark = [list(line) for line in input_list]\n\n    min_nubs = float('inf')\n    for i in range(n - 1):\n        for j in range(m):\n            if mark[i][j] == '#' and mark[i + 1][j] == '#':\n                min_nubs = min(min_nubs, 1)\n            elif mark[i][j] == '#' and mark[i + 1][j] == '.':\n                min_nubs = min(min_nubs, 2)\n            elif mark[i][j] == '.' and mark[i + 1][j] == '#':\n                min_nubs = min(min_nubs, 2)\n            else:\n                min_nubs = min(min_nubs, 1)\n\n    return str(min_nubs)\n"
    },
    {
        "number": 3028,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split()[:3])\n    board = [list(map(int, stdin.split()[3 + i * m:3 + (i + 1) * m])) for i in range(n)]\n\n    def next_move(board, row, col, p):\n        moves = []\n        for i in range(n):\n            for j in range(m):\n                if board[i][j] == p:\n                    board[i][j] = 1\n                else:\n                    board[i][j] += 1\n                    if board[i][j] == p + 1:\n                        board[i][j] = 1\n                if i == row and j == col:\n                    moves.append(board[i][j])\n        return moves\n\n    def dfs(board, row, col, p, depth, moves):\n        if depth == p * m * n:\n            return moves\n        if row < 0 or row >= n or col < 0 or col >= m:\n            return None\n        if board[row][col] == p:\n            return dfs(board, row, col + 1, p, depth + 1, moves)\n        moves.extend(next_move(board, row, col, p))\n        return dfs(board, row, col + 1, p, depth + 1, moves)\n\n    moves = dfs(board, 0, 0, p, 0, [])\n    if moves is None:\n        return -1\n    else:\n        return len(moves), \" \".join(map(str, moves))\n"
    },
    {
        "number": 3029,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, parent: int) -> int:\n        nonlocal labels, visited, max_length, max_length_paths, path_count\n        visited[node] = True\n        path_length = 1\n        for child in tree[node]:\n            if child != parent:\n                path_length = max(path_length, dfs(child, node) + 1)\n        if path_length == max_length:\n            max_length_paths[node] = True\n        elif path_length > max_length:\n            max_length = path_length\n            max_length_paths = {node: True}\n        return path_length\n\n    N, labels, tree = [], [], {}\n    for i in range(1, int(stdin.split('\\n')[0]) + 1):\n        line = stdin.split('\\n')[i].split()\n        N.append(int(line[0]))\n        labels.append(int(line[1]))\n        tree[i] = [int(x) for x in line[2:]]\n\n    visited = [False] * (N[0] + 1)\n    max_length, max_length_paths = 0, {}\n    dfs(1, -1)\n\n    L = max_length\n    M = sum(1 for node in max_length_paths if labels[node - 1] <= labels[tree[node][0] - 1])\n    return f\"{L} {M % 11092019}\"\n"
    },
    {
        "number": 3030,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_ancestors(node: int, parent: int) -> set:\n        if parent == 0:\n            return set()\n        return find_ancestors(parent, parents[parent]) | {parent}\n\n    n = int(stdin.splitlines()[0])\n    parents = [0] * (n + 1)\n    values = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        values[i], parents[i] = map(int, stdin.splitlines()[i].split())\n\n    max_nodes = 0\n    for i in range(1, n + 1):\n        ancestors = find_ancestors(i, parents[i])\n        if all(values[i] > values[j] for j in ancestors):\n            max_nodes = max(max_nodes, len(ancestors) + 1)\n\n    return str(max_nodes)\n"
    },
    {
        "number": 3031,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, color: int, visited: set, colors: list, parent: int) -> bool:\n        visited.add(node)\n        for neighbor, neighbor_color in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                return False\n            if neighbor_color == color:\n                return False\n            if not dfs(neighbor, neighbor_color, visited, colors, node):\n                return False\n        colors[node - 1] = color\n        return True\n\n    n, *edges = stdin.splitlines()\n    n = int(n)\n    graph = [[] for _ in range(n + 1)]\n    for edge in edges:\n        a, b, c = map(int, edge.split())\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    colors = [0] * n\n    good_nodes = []\n    for node in range(1, n + 1):\n        if dfs(node, 1, set(), colors, -1):\n            good_nodes.append(node)\n\n    return len(good_nodes), *sorted(good_nodes)\n"
    },
    {
        "number": 3032,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, s = map(int, stdin.split()[0].split(','))\n    program = stdin.split()[1].split()\n\n    # Initialize memory banks\n    memory_banks = [[] for _ in range(b)]\n\n    # Map variables to memory banks\n    variable_map = {}\n\n    # Helper function to find the bank with the least number of variables\n    def find_least_bank():\n        least_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                least_bank = i\n                break\n        return least_bank\n\n    # Helper function to find the bank with the most number of variables\n    def find_most_bank():\n        most_bank = None\n        for i in range(b):\n            if memory_banks[i]:\n                most_bank = i\n                break\n        return most_bank\n\n    # Helper function to find the bank with the least number of variables\n    def find_least_free_bank():\n        least_free_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                least_free_bank = i\n                break\n        return least_free_bank\n\n    # Helper function to find the bank with the most number of variables\n    def find_most_free_bank():\n        most_free_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                most_free_bank = i\n                break\n        return most_free_bank\n\n    # Helper function to find the bank with the least number of variables\n    def find_least_used_bank():\n        least_used_bank = None\n        for i in range(b):\n            if memory_banks[i]:\n                least_used_bank = i\n                break\n        return least_used_bank\n\n    # Helper function to find the bank with the most number of variables\n    def find_most_used_bank():\n        most_used_bank = None\n        for i in range(b):\n            if memory_banks[i]:\n                most_used_bank = i\n                break\n        return most_used_bank\n\n    # Helper function to find the bank with the least number of variables\n    def find_least_used_free_bank():\n        least_used_free_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                least_used_free_bank = i\n                break\n        return least_used_free_bank\n\n    # Helper function to find the bank with the most number of variables\n    def find_most_used_free_bank():\n        most_used_free_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                most_used_free_bank = i\n                break\n        return most_used_free_bank\n\n    # Helper function to find the bank with the least number of variables\n    def find_least_used_used_bank():\n        least_used_used_bank = None\n        for i in range(b):\n            if memory_banks[i]:\n                least_used_used_bank = i\n                break\n        return least_used_used_bank\n\n    # Helper function to find the bank with the most number of variables\n    def find_most_used_used_bank():\n        most_used_used_bank = None\n        for i in range(b):\n            if memory_banks[i]:\n                most_used_used_bank = i\n                break\n        return most_used_used_bank\n\n    # Helper function to find the bank with the least number of variables\n    def find_least_used_used_free_bank():\n        least_used_used_free_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                least_used_used_free_bank = i\n                break\n        return least_used_used_free_bank\n\n    # Helper function to find the bank with the most number of variables\n    def find_most_used_used_free_bank():\n        most_used_used_free_bank = None\n        for i in range(b):\n            if not memory_banks[i]:\n                most_"
    },
    {
        "number": 3033,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, N = map(int, stdin.split())\n    X = 0\n    while f(X, B) < N:\n        X += 1\n    if f(X, B) == N:\n        return str(X)\n    else:\n        return \"impossible\"\n\ndef"
    },
    {
        "number": 3034,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rain_amount(cloud: tuple, roof: tuple) -> float:\n        start, end, prob, amount = cloud\n        x, y = roof\n        if x <= start <= y:\n            return prob * amount * (end - start)\n        elif x <= end <= y:\n            return prob * amount * (end - start)\n        elif start <= x <= end <= y:\n            return prob * amount * (min(end, y) - max(start, x))\n        else:\n            return 0\n\n    def expected_rain(clouds: list, roofs: list) -> float:\n        total_rain = 0\n        for cloud in clouds:\n            for roof in roofs:\n                total_rain += rain_amount(cloud, roof)\n        return total_rain\n\n    def min_expected_rain(clouds: list, roofs: list, t: int, d: int) -> float:\n        min_rain = float('inf')\n        for i in range(len(clouds)):\n            for j in range(len(roofs)):\n                start, end, prob, amount = clouds[i]\n                x, y = roofs[j]\n                if x <= start <= y:\n                    new_start = max(start, x)\n                elif x <= end <= y:\n                    new_start = min(start, y)\n                elif start <= x <= end <= y:\n                    new_start = max(start, x)\n                else:\n                    continue\n                new_end = min(end, y)\n                new_prob = prob * (new_end - new_start) / (end - start)\n                new_amount = amount * (new_end - new_start)\n                new_cloud = (new_start, new_end, new_prob, new_amount)\n                new_roofs = roofs[:j] + roofs[j+1:]\n                new_clouds = clouds[:i] + [new_cloud] + clouds[i+1:]\n                new_expected_rain = expected_rain(new_clouds, new_roofs)\n                if new_expected_rain < min_rain:\n                    min_rain = new_expected_rain\n        return min_rain\n\n    lines = stdin.split('\\n')\n    d, t, c, r = map(int, lines[0].split())\n    clouds = [(int(x), int(y), float(p), int(a)) for x, y, p, a in [line.split() for line in lines[1:c+1]]]\n    roofs = [(int(x), int(y)) for x, y in [line.split() for line in lines[c+1:]]]\n    min_expected_rain(clouds, roofs, t, d)"
    },
    {
        "number": 3035,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_exchange_rate(offered: str, wanted: str, rate: float) -> float:\n        if offered == 'blue':\n            return rate\n        elif wanted == 'blue':\n            return 1 / rate\n        else:\n            return 0\n\n    def get_max_blue_lemonade(exchange_rates: list) -> float:\n        max_blue_lemonade = 0\n        for i in range(len(exchange_rates)):\n            for j in range(i + 1, len(exchange_rates)):\n                rate = get_exchange_rate(exchange_rates[i][0], exchange_rates[j][0], exchange_rates[i][1])\n                if rate > 0:\n                    max_blue_lemonade = max(max_blue_lemonade, rate * exchange_rates[j][2])\n        return max_blue_lemonade\n\n    N, *exchange_rates = stdin.split('\\n')\n    N = int(N)\n    exchange_rates = [tuple(line.split()) for line in exchange_rates]\n    exchange_rates = [(offered, wanted, float(rate)) for offered, wanted, rate in exchange_rates]\n\n    max_blue_lemonade = get_max_blue_lemonade(exchange_rates)\n    max_blue_lemonade = min(max_blue_lemonade, 10)\n\n    return f'{max_blue_lemonade:.6f}'\n"
    },
    {
        "number": 3036,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, s, m, d, n = map(int, input_list[0].split())\n    brands = list(map(int, input_list[1].split()))\n    dishes = input_list[2:]\n\n    def count_dinner_experiences(dishes: list, brands: list) -> int:\n        def count_dish_combinations(dish: list, brands: list) -> int:\n            return reduce(lambda x, y: x * y, [len(brands) ** i for i in dish])\n\n        return reduce(lambda x, y: x * y, [count_dish_combinations(dish, brands) for dish in dishes])\n\n    return \"too many\" if count_dinner_experiences(dishes, brands) > 10**18 else count_dinner_experiences(dishes, brands)"
    },
    {
        "number": 3037,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w, n = map(int, stdin.split()[:3])\n    board = stdin.split('\\n')[1:h+1]\n    commands = [line.split() for line in stdin.split('\\n')[h+1:h+1+n]]\n\n    def move(x, y, direction, distance):\n        if direction == 'up':\n            return x, y - distance\n        elif direction == 'down':\n            return x, y + distance\n        elif direction == 'left':\n            return x - distance, y\n        elif direction == 'right':\n            return x + distance, y\n\n    def is_marked(x, y):\n        if 0 <= x < w and 0 <= y < h:\n            return board[y][x] == '#'\n        return False\n\n    def dry_out(x, y):\n        return not is_marked(x, y)\n\n    x, y = 0, 0\n    for direction, distance in commands:\n        x, y = move(x, y, direction, distance)\n        if not dry_out(x, y):\n            return -1, -1\n\n    min_time = max_time = 0\n    for i in range(w):\n        for j in range(h):\n            if board[j][i] == '#':\n                min_time = max(min_time, j)\n                max_time = max(max_time, j)\n\n    return min_time, max_time"
    },
    {
        "number": 3038,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    B = int(input_list[0])\n    k = int(input_list[1])\n    companies = []\n    for i in range(2, 2+k):\n        company = []\n        l, *n = map(int, input_list[i].split())\n        for j in range(l):\n            company.append(n[j])\n        companies.append(company)\n\n    def get_real_amount(company, size):\n        for i in range(len(company)):\n            if company[i] >= size:\n                return i\n        return len(company)\n\n    def get_min_real_amount(company, target):\n        for i in range(len(company)):\n            if sum(company[:i+1]) >= target:\n                return i\n        return len(company)\n\n    def get_min_size(company, target):\n        min_size = float('inf')\n        for i in range(len(company)):\n            if sum(company[:i+1]) >= target:\n                min_size = min(min_size, company[i])\n        return min_size\n\n    for i in range(k):\n        for j in range(len(companies[i])):\n            if companies[i][j] >= B:\n                return str(companies[i][j])\n\n    for i in range(k):\n        for j in range(len(companies[i])):\n            if sum(companies[i][:j+1]) >= B:\n                return str(companies[i][j])\n\n    for i in range(k):\n        for j in range(len(companies[i])):\n            if sum(companies[i][:j+1]) >= B:\n                return str(companies[i][j])\n\n    return \"impossible\""
    },
    {
        "number": 3039,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_fold(squares: list) -> bool:\n        def is_valid_square(square: list) -> bool:\n            return all(len(row) == 2 for row in square)\n\n        def is_valid_connection(square1: list, square2: list) -> bool:\n            return any(square1[0][0] == square2[0][1] and square1[1][0] == square2[1][1] for row in square1 for col in row)\n\n        def is_valid_connection_with_square(square: list, squares: list) -> bool:\n            return any(is_valid_connection(square, other_square) for other_square in squares)\n\n        def is_valid_cube(squares: list) -> bool:\n            return all(is_valid_square(square) for square in squares) and all(is_valid_connection_with_square(square, squares) for square in squares)\n\n        return is_valid_cube(squares)\n\n    def parse_input(stdin: str) -> list:\n        squares = []\n        for i in range(6):\n            row = []\n            for j in range(6):\n                if stdin[i][j] == '#':\n                    row.append([i, j])\n            squares.append(row)\n        return squares\n\n    squares = parse_input(stdin)\n    if is_valid_fold(squares):\n        return \"can fold\"\n    else:\n        return \"cannot fold\"\n"
    },
    {
        "number": 3040,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def longest_repeated_substring(s: str) -> str:\n        n = len(s)\n        max_len = 0\n        start = 0\n        end = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                substr = s[i:j]\n                if substr in s[:i] and substr in s[j:]:\n                    if len(substr) > max_len:\n                        max_len = len(substr)\n                        start = i\n                        end = j\n        return s[start:end]\n\n    return longest_repeated_substring(stdin)\n"
    },
    {
        "number": 3041,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    coupons = 0\n    for i in range(1, N+1):\n        zone, time = map(int, input_list[i].split())\n        coupons += 2 + abs(zone - (zone % 2))\n    return coupons"
    },
    {
        "number": 3042,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def lcm(a: int, b: int) -> int:\n        return a * b // math.gcd(a, b)\n\n    def dfs(node: int, parent: int) -> int:\n        if left_child[node] == -1:\n            return 1\n        left_count = dfs(left_child[node], node)\n        right_count = dfs(right_child[node], node)\n        return left_count * right_count * lcm(values[left_child[node]], values[right_child[node]])\n\n    n = int(stdin.splitlines()[0])\n    values = list(map(int, stdin.splitlines()[1].split()))\n    left_child = [-1] * n\n    right_child = [-1] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lcm(values[i], values[j]) == values[i] + values[j]:\n                left_child[i] = j\n                right_child[i] = -1\n                break\n            elif lcm(values[i], values[j]) == values[j] + values[i]:\n                left_child[i] = -1\n                right_child[i] = j\n                break\n\n    result = dfs(0, -1)\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 3043,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    grid = [list(input()) for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def move(x, y, dx, dy):\n        return x + dx, y + dy\n\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def bfs(start, goal):\n        visited = set()\n        queue = [(start, 0)]\n\n        while queue:\n            (x, y), d = queue.pop(0)\n\n            if (x, y) == goal:\n                return d\n\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = move(x, y, dx, dy)\n\n                if is_valid(nx, ny) and grid[nx][ny] != '#' and (nx, ny) not in visited:\n                    visited.add((nx, ny))\n                    queue.append(((nx, ny), d + 1))\n\n        return -1\n\n    start = (0, 0)\n    goal = (0, 0)\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    if grid[start[0]][start[1]] == '#':\n        return -1\n\n    days = bfs(start, goal)\n\n    if days == -1:\n        return -1\n\n    return days + 1 if days % 2 == 0 else days + 2\n"
    },
    {
        "number": 3044,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W, command_string = input().split()\n    H, W = int(H), int(W)\n    grid = [input() for _ in range(H)]\n\n    def is_valid(x: int, y: int) -> bool:\n        return 0 <= x < H and 0 <= y < W and grid[x][y] == '.'\n\n    def move(x: int, y: int, dx: int, dy: int) -> bool:\n        nx, ny = x + dx, y + dy\n        if is_valid(nx, ny):\n            grid[x][y] = '.'\n            grid[nx][ny] = 'S'\n            return True\n        return False\n\n    def find_goal() -> bool:\n        for x in range(H):\n            for y in range(W):\n                if grid[x][y] == 'G':\n                    return True\n        return False\n\n    def fix_command_string(command_string: str) -> int:\n        changes = 0\n        for i, command in enumerate(command_string):\n            if command == 'D':\n                if move(x, y, 0, 1):\n                    changes += 1\n            elif command == 'U':\n                if move(x, y, 0, -1):\n                    changes += 1\n            elif command == 'L':\n                if move(x, y, -1, 0):\n                    changes += 1\n            elif command == 'R':\n                if move(x, y, 1, 0):\n                    changes += 1\n            else:\n                continue\n            x, y = x + dx, y + dy\n            if find_goal():\n                return changes\n        return changes\n\n    dx, dy = 0, 1\n    x, y = 0, 0\n    for command in command_string:\n        if command == 'D':\n            if move(x, y, 0, 1):\n                dx, dy = 0, 1\n        elif command == 'U':\n            if move(x, y, 0, -1):\n                dx, dy = 0, -1\n        elif command == 'L':\n            if move(x, y, -1, 0):\n                dx, dy = -1, 0\n        elif command == 'R':\n            if move(x, y, 1, 0):\n                dx, dy = 1, 0\n        else:\n            continue\n        x, y = x + dx, y + dy\n        if find_goal():\n            return fix_command_string(command_string)\n    return fix_command_string(command_string)\n"
    },
    {
        "number": 3045,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid_position(x, y):\n        return x.is_integer() and y.is_integer()\n\n    def find_receiver_position(beacons, distances):\n        for x in range(min_x, max_x + 1):\n            for y in range(min_y, max_y + 1):\n                if is_valid_position(x, y):\n                    total_distance = 0\n                    for i in range(len(beacons)):\n                        distance = manhattan_distance(x, y, beacons[i][0], beacons[i][1])\n                        if distance != distances[i]:\n                            break\n                        total_distance += distance\n                    else:\n                        return x, y\n        return None\n\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.split('\\n')\n        num_beacons = int(lines[0])\n        beacons = []\n        distances = []\n        for i in range(1, num_beacons + 1):\n            x, y, d = map(int, lines[i].split())\n            beacons.append((x, y))\n            distances.append(d)\n        return beacons, distances\n\n    def format_output(result: tuple) -> str:\n        if result is None:\n            return \"impossible\"\n        elif result == \"uncertain\":\n            return \"uncertain\"\n        else:\n            return f\"{result[0]} {result[1]}\"\n\n    beacons, distances = parse_input(stdin)\n    min_x = min(beacons, key=lambda x: x[0])[0]\n    max_x = max(beacons, key=lambda x: x[0])[0]\n    min_y = min(beacons, key=lambda x: x[1])[1]\n    max_y = max(beacons, key=lambda x: x[1])[1]\n\n    result = find_receiver_position(beacons, distances)\n    return format_output(result)"
    },
    {
        "number": 3046,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    if n < 1 or n > 10**5:\n        return \"syntax error\"\n    corners = []\n    for i in range(1, 2*n, 2):\n        r1, c1 = map(int, input_data[i].split())\n        r2, c2 = map(int, input_data[i+1].split())\n        corners.append((r1, c1, r2, c2))\n\n    def is_valid(corners):\n        for i in range(n):\n            for j in range(i+1, n):\n                if (corners[i][0] == corners[j][0] and corners[i][1] == corners[j][1]) or \\\n                   (corners[i][2] == corners[j][2] and corners[i][3] == corners[j][3]) or \\\n                   (corners[i][0] == corners[j][2] and corners[i][1] == corners[j][3]) or \\\n                   (corners[i][2] == corners[j][0] and corners[i][3] == corners[j][1]):\n                    return False\n        return True\n\n    def find_matching(corners):\n        matching = []\n        for i in range(n):\n            for j in range(n):\n                if corners[i][0] == corners[j][2] and corners[i][1] == corners[j][3] and corners[i][2] == corners[j][0] and corners[i][3] == corners[j][1]:\n                    matching.append((i+1, j+1))\n        return matching\n\n    if not is_valid(corners):\n        return \"syntax error\"\n    matching = find_matching(corners)\n    if not matching:\n        return \"syntax error\"\n    return '\\n'.join(map(str, matching))"
    },
    {
        "number": 3047,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_proportion(monster_1: int, monster_2: int, item_1: int, item_2: int) -> int:\n        return monster_1 * item_2 // monster_2 * item_1 // item_2\n\n    def compute_solution(partial_plates: List[List[int]]) -> int:\n        salamander_plate, yeti_plate, golem_plate, imp_plate, kraken_plate = partial_plates\n        burger_slop_proportion = compute_proportion(yeti_plate[0], salamander_plate[0], salamander_plate[1], yeti_plate[1])\n        sushi_drumstick_proportion = compute_proportion(golem_plate[1], yeti_plate[1], yeti_plate[0], golem_plate[0])\n        burger_drumstick_proportion = compute_proportion(imp_plate[1], yeti_plate[1], yeti_plate[0], imp_plate[0])\n        slop_sushi_proportion = compute_proportion(kraken_plate[1], golem_plate[1], golem_plate[0], kraken_plate[0])\n\n        salamander_burger = burger_slop_proportion * salamander_plate[0] // yeti_plate[0]\n        salamander_slop = salamander_plate[0] - salamander_burger\n        yeti_burger = burger_slop_proportion * yeti_plate[0] // salamander_plate[0]\n        yeti_slop = yeti_plate[0] - yeti_burger\n        golem_sushi = sushi_drumstick_proportion * golem_plate[0] // yeti_plate[0]\n        golem_drumstick = golem_plate[0] - golem_sushi\n        imp_sushi = sushi_drumstick_proportion * imp_plate[0] // yeti_plate[0]\n        imp_drumstick = imp_plate[0] - imp_sushi\n        kraken_sushi = slop_sushi_proportion * kraken_plate[0] // golem_plate[0]\n        kraken_slop = kraken_plate[0] - kraken_sushi\n\n        return [salamander_burger, salamander_slop, golem_sushi, golem_drumstick, imp_sushi, imp_drumstick, kraken_sushi, kraken_slop]\n\n    def count_solutions(partial_plates: List[List[int]]) -> int:\n        solutions = compute_solution(partial_plates)\n        count = 1\n        for i in range(1, len(solutions)):\n            if solutions[i] != solutions[i - 1]:\n                count *= 2\n        return count\n\n    def parse_input(input_str: str) -> List[List[int]]:\n        partial_plates = []\n        for line in input_str.splitlines():\n            plate = []\n            for entry in line.split():\n                if entry == '_':\n                    plate.append(None)\n                else:\n                    plate.append(int(entry))\n            partial_plates.append(plate)\n        return partial_plates\n\n    partial_plates = parse_input(stdin)\n    return str(count_solutions(partial_plates))\n"
    },
    {
        "number": 3048,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    adjacency_list = [[] for _ in range(N)]\n    for u, v in roads:\n        adjacency_list[u - 1].append(v - 1)\n        adjacency_list[v - 1].append(u - 1)\n\n    def dfs(u: int, visited: set, path: list, paths: list):\n        visited.add(u)\n        path.append(u)\n\n        if len(path) == 2:\n            paths.append(path[:])\n\n        for v in adjacency_list[u]:\n            if v not in visited:\n                dfs(v, visited.copy(), path, paths)\n\n        path.pop()\n\n    paths = []\n    for u in range(N):\n        dfs(u, set(), [], paths)\n\n    optimal_paths = [path for path in paths if len(set(path)) == N]\n    return len(optimal_paths)\n"
    },
    {
        "number": 3049,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    encrypted_message, decrypted_fragment = stdin.split('\\n')\n    positions = []\n    for i in range(len(encrypted_message) - len(decrypted_fragment) + 1):\n        if encrypted_message[i:i+len(decrypted_fragment)] == decrypted_fragment:\n            positions.append(i)\n    if len(positions) == 0:\n        return str(len(positions))\n    else:\n        return encrypted_message[positions[0]:positions[0]+len(decrypted_fragment)]"
    },
    {
        "number": 3050,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, program = stdin.split(\"\\n\")\n    N = int(N)\n\n    grid = [input().split() for _ in range(N)]\n\n    robot_pos = None\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == \"R\":\n                robot_pos = (i, j)\n                break\n\n    if robot_pos is None:\n        return \"1\"\n\n    def get_neighbors(cell):\n        i, j = cell\n        neighbors = []\n        if i > 0:\n            neighbors.append((i - 1, j))\n        if i < N - 1:\n            neighbors.append((i + 1, j))\n        if j > 0:\n            neighbors.append((i, j - 1))\n        if j < N - 1:\n            neighbors.append((i, j + 1))\n        return neighbors\n\n    def move(cell, direction):\n        i, j = cell\n        if direction == \"<\":\n            j -= 1\n        elif direction == \">\":\n            j += 1\n        elif direction == \"^\":\n            i -= 1\n        elif direction == \"v\":\n            i += 1\n        return i, j\n\n    def is_valid(cell):\n        i, j = cell\n        return 0 <= i < N and 0 <= j < N\n\n    def get_trail(program):\n        trail = [robot_pos]\n        i = 0\n        while i < len(program):\n            direction = program[i]\n            new_cell = move(trail[-1], direction)\n            if is_valid(new_cell) and grid[new_cell[0]][new_cell[1]] != \"#\":\n                trail.append(new_cell)\n            i += 1\n        return trail\n\n    trail = get_trail(program)\n    if len(trail) == N * N:\n        return \"1\"\n\n    X = 1\n    for i in range(len(trail) - 1, 0, -1):\n        if trail[i] == trail[i - X]:\n            X += 1\n        else:\n            break\n\n    return str(X)\n"
    },
    {
        "number": 3051,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    fogs = []\n    for i in range(1, n + 1):\n        params = list(map(int, stdin.splitlines()[i].split()))\n        fogs.append(params)\n\n    total_missed = 0\n    for i in range(n):\n        m, d, l, r, h, dd, dh, dh_next = fogs[i]\n        total_missed += (m - 1) * d\n\n    return str(total_missed)"
    },
    {
        "number": 3052,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def time_to_travel(x1, y1, x2, y2, speed):\n        return distance(x1, y1, x2, y2) / speed\n\n    def time_to_travel_on_conveyor(x, y, conveyor, speed):\n        if conveyor[0] <= x <= conveyor[2] and conveyor[1] <= y <= conveyor[3]:\n            return time_to_travel(x, y, conveyor[0], conveyor[1], speed)\n        elif conveyor[0] <= x <= conveyor[2] and conveyor[3] <= y <= conveyor[1]:\n            return time_to_travel(x, y, conveyor[0], conveyor[3], speed)\n        elif conveyor[2] <= x <= conveyor[0] and conveyor[1] <= y <= conveyor[3]:\n            return time_to_travel(x, y, conveyor[2], conveyor[1], speed)\n        elif conveyor[2] <= x <= conveyor[0] and conveyor[3] <= y <= conveyor[1]:\n            return time_to_travel(x, y, conveyor[2], conveyor[3], speed)\n        else:\n            return float('inf')\n\n    def min_time_to_travel(x1, y1, x2, y2, conveyors, speed):\n        conveyor_times = [time_to_travel_on_conveyor(x1, y1, conveyor, speed) for conveyor in conveyors]\n        return min(conveyor_times) + time_to_travel(x1, y1, x2, y2, speed)\n\n    lines = stdin.split('\\n')\n    x1, y1, x2, y2 = map(float, lines[0].split())\n    N = int(lines[1])\n    conveyors = [tuple(map(float, lines[i+2].split())) for i in range(N)]\n    speed = 2\n\n    return f\"{min_time_to_travel(x1, y1, x2, y2, conveyors, speed):.4f}\""
    },
    {
        "number": 3053,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split())\n    if K > 26:\n        return \"IMPOSSIBLE\"\n    if P > N:\n        return \"IMPOSSIBLE\"\n    if N % 2 == 0 and P % 2 == 1:\n        return \"IMPOSSIBLE\"\n    if N % 2 == 1 and P % 2 == 0:\n        return \"IMPOSSIBLE\"\n    if N % 2 == 1 and P % 2 == 1:\n        return \"IMPOSSIBLE\"\n    if N % 2 == 0 and P % 2 == 0:\n        return \"IMPOSSIBLE\"\n    if K == 1:\n        return \"a\" * N\n    if K == 2:\n        return \"ab\" * (N // 2)\n    if K == 3:\n        return \"abc\" * (N // 3)\n    if K == 4:\n        return \"abcd\" * (N // 4)\n    if K == 5:\n        return \"abcde\" * (N // 5)\n    if K == 6:\n        return \"abcdef\" * (N // 6)\n    if K == 7:\n        return \"abcdefg\" * (N // 7)\n    if K == 8:\n        return \"abcdefgh\" * (N // 8)\n    if K == 9:\n        return \"abcdefghi\" * (N // 9)\n    if K == 10:\n        return \"abcdefghij\" * (N // 10)\n    if K == 11:\n        return \"abcdefghijk\" * (N // 11)\n    if K == 12:\n        return \"abcdefghijkl\" * (N // 12)\n    if K == 13:\n        return \"abcdefghijklm\" * (N // 13)\n    if K == 14:\n        return \"abcdefghijklmn\" * (N // 14)\n    if K == 15:\n        return \"abcdefghijklmno\" * (N // 15)\n    if K == 16:\n        return \"abcdefghijklmnop\" * (N // 16)\n    if K == 17:\n        return \"abcdefghijklmnopq\" * (N // 17)\n    if K == 18:\n        return \"abcdefghijklmnopqr\" * (N // 18)\n    if K == 19:\n        return \"abcdefghijklmnopqrs\" * (N // 19)\n    if K == 20:\n        return \"abcdefghijklmnopqrst\" * (N // 20)\n    if K == 21:\n        return \"abcdefghijklmnopqrstu\" * (N // 21)\n    if K == 22:\n        return \"abcdefghijklmnopqrstuv\" * (N // 22)\n    if K == 23:\n        return \"abcdefghijklmnopqrstuvw\" * (N // 23)\n    if K == 24:\n        return \"abcdefghijklmnopqrstuvwx\" * (N // 24)\n    if K == 25:\n        return \"abcdefghijklmnopqrstuvwxy\" * (N // 25)\n    if K == 26:\n        return \"abcdefghijklmnopqrstuvwxyz\" * (N // 26)\n"
    },
    {
        "number": 3054,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_syllables(word: str) -> int:\n        vowels = {'A', 'E', 'I', 'O', 'U', 'Y'}\n        syllables = 0\n        prev_char = None\n        for char in word:\n            if prev_char is not None and prev_char in vowels and char in vowels:\n                syllables += 1\n            prev_char = char\n        return syllables\n\n    def divide_words(words: list) -> list:\n        lines = []\n        line = []\n        for word in words:\n            if count_syllables(word) == 5:\n                if len(line) == 2:\n                    lines.append(line)\n                    line = [word]\n                else:\n                    line.append(word)\n            elif count_syllables(word) == 7:\n                if len(line) == 1:\n                    line.append(word)\n                else:\n                    lines.append(line)\n                    line = [word]\n            else:\n                lines.append(line)\n                line = [word]\n        lines.append(line)\n        return lines\n\n    def format_haiku(lines: list) -> str:\n        haiku = ''\n        for line in lines:\n            haiku += ' '.join(line) + '\\n'\n        return haiku.strip()\n\n    words = stdin.split()\n    lines = divide_words(words)\n    haiku = format_haiku(lines)\n    return haiku"
    },
    {
        "number": 3055,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    names = stdin.splitlines()[1:]\n\n    thore_index = None\n    thore_h_index = None\n    for i, name in enumerate(names):\n        if name == \"ThoreHusfeldt\":\n            thore_index = i\n        elif name.startswith(\"ThoreHusfeldt\"):\n            thore_h_index = i\n\n    if thore_h_index is not None and thore_h_index < thore_index:\n        return \"ThoreH sucks\"\n    elif thore_h_index is None:\n        return \"Thore is awesome\"\n    else:\n        for i in range(thore_index - 1, -1, -1):\n            if names[i].startswith(\"ThoreHusfeldt\"):\n                return names[i][:thore_index - i]\n"
    },
    {
        "number": 3056,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(node: int, move: str) -> int:\n        if move == 'L':\n            return 2 * node\n        elif move == 'R':\n            return 2 * node + 1\n        else:\n            return node\n\n    def dfs(node: int, move: str, depth: int) -> int:\n        if depth == len(stdin):\n            return get_value(node, move)\n\n        if stdin[depth] == 'L':\n            return dfs(get_value(node, 'L'), 'L', depth + 1)\n        elif stdin[depth] == 'R':\n            return dfs(get_value(node, 'R'), 'R', depth + 1)\n        else:\n            return dfs(node, move, depth + 1)\n\n    return dfs(1, 'P', 0)\n"
    },
    {
        "number": 3057,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rhyme(x: str, y: str) -> bool:\n        return x[-min(3, len(x), len(y)):].lower() == y[-min(3, len(x), len(y)):].lower()\n\n    def is_consistent(statements: list) -> bool:\n        words = set()\n        for statement in statements:\n            x, y = statement.split()\n            if x not in words and y not in words:\n                words.add(x)\n                words.add(y)\n            elif x in words and y in words:\n                if not rhyme(x, y):\n                    return False\n            else:\n                return False\n        return True\n\n    N = int(stdin.splitlines()[0])\n    statements = stdin.splitlines()[1:]\n    return \"yes\" if is_consistent(statements) else \"wait what?\""
    },
    {
        "number": 3058,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    current_species = input_data[1]\n    fossil_sequences = input_data[2:]\n\n    # Check if it's impossible\n    if len(set(fossil_sequences)) == 1:\n        return \"impossible\"\n\n    # Find the first path\n    first_path = [current_species]\n    for sequence in fossil_sequences:\n        if sequence not in first_path:\n            first_path.append(sequence)\n            break\n\n    # Find the second path\n    second_path = [sequence for sequence in fossil_sequences if sequence not in first_path]\n\n    # Display the example\n    return f\"{len(first_path)} {len(second_path)}\\n\" + \"\\n\".join(first_path) + \"\\n\" + \"\\n\".join(second_path)"
    },
    {
        "number": 3059,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, m = map(int, stdin.split()[:3])\n    tricks = sorted(map(int, stdin.split()[3:]))\n    p = [0.5] * m\n    d = [10] * m\n    for i in range(m):\n        p[i], d[i] = map(float, stdin.split()[3+i*3+1:3+i*3+3])\n\n    def expected_time(t, p, d):\n        return t + d * (1 - p)\n\n    def reset_time(t, p, d):\n        return t + d\n\n    def play_time(t, p, d):\n        return t + d * (1 - p)\n\n    def expected_play(t, p, d):\n        return p * play_time(t, p, d) + (1 - p) * expected_play(reset_time(t, p, d), p, d)\n\n    def expected_record(t, p, d):\n        return expected_play(t, p, d) + expected_record(reset_time(t, p, d), p, d)\n\n    return round(expected_record(0, p, d), 6)"
    },
    {
        "number": 3060,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    sequences = []\n    for i in range(1, n):\n        for j in range(i, n-1):\n            for l in range(j+1, n):\n                sequences.append((i, j, l))\n    sequences.sort()\n    return \" \".join(map(str, sequences[k-1]))\n"
    },
    {
        "number": 3061,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path(graph: dict, start: int, end: int, path: list = None) -> list:\n        if path is None:\n            path = []\n        if start == end:\n            return path\n        path = path + [start]\n        for node in graph[start]:\n            if node not in path:\n                new_path = find_path(graph, node, end, path)\n                if new_path:\n                    return new_path\n        return []\n\n    def find_min_path(graph: dict, blocked_road: tuple) -> int:\n        new_graph = graph.copy()\n        new_graph[blocked_road[0]].remove(blocked_road[1])\n        new_graph[blocked_road[1]].remove(blocked_road[0])\n        max_length = 0\n        for i in range(1, n + 1):\n            for j in range(i + 1, n + 1):\n                path = find_path(new_graph, i, j)\n                if path:\n                    max_length = max(max_length, len(path))\n        return max_length\n\n    n, m = map(int, stdin.split()[0:2])\n    graph = {i: [] for i in range(1, n + 1)}\n    for i in range(m):\n        u, v = map(int, stdin.split()[2 * i + 1:2 * i + 3])\n        graph[u].append(v)\n    min_path = find_min_path(graph, (1, 2))\n    return str(min_path)\n"
    },
    {
        "number": 3062,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, v, w = map(float, stdin.split())\n    r = 6371  # Earth's radius in miles\n    d = r * (2 * np.arcsin(np.sqrt((x**2 + y**2) / (r**2 + x**2 + y**2))))\n    t = d / v\n    t_max = abs(np.arctan(y / x) - np.arctan(w * t)) / w\n    return f\"{t_max:.6f}\"\n"
    },
    {
        "number": 3063,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    debts = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    total_debt = sum(debt[1] for debt in debts)\n    total_money_given = 0\n\n    while total_debt > 0:\n        min_debt = min(debt[1] for debt in debts)\n        min_debt_person = next(debt for debt in debts if debt[1] == min_debt)\n\n        total_money_given += min_debt\n        total_debt -= min_debt\n\n        for debt in debts:\n            if debt[0] == min_debt_person[0]:\n                debt[1] -= min_debt\n\n        debts = [debt for debt in debts if debt[1] > 0]\n\n    return str(total_money_given)\n"
    },
    {
        "number": 3064,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    adjacency_list = [[] for _ in range(N+1)]\n    for road in roads:\n        adjacency_list[road[0]].append(road[1])\n        adjacency_list[road[1]].append(road[0])\n\n    def dfs(start, visited, path, paths):\n        visited[start] = True\n        path.append(start)\n        for neighbor in adjacency_list[start]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, path, paths)\n        paths.append(path.copy())\n\n    visited = [False] * (N+1)\n    paths = []\n    for i in range(1, N+1):\n        if not visited[i]:\n            path = []\n            dfs(i, visited, path, paths)\n\n    longest_path = []\n    for path in paths:\n        if len(path) > len(longest_path):\n            longest_path = path\n\n    return len(longest_path)\n"
    },
    {
        "number": 3065,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    L = int(input_list[1])\n    walk = list(map(int, input_list[2].split()))\n    adj_list = [list(map(int, input_list[i].split()[1:])) for i in range(3, 3 + N)]\n\n    def dfs(node: int, visited: set, parent: int) -> bool:\n        visited.add(node)\n        for neighbour in adj_list[node]:\n            if neighbour not in visited and dfs(neighbour, visited, node):\n                return True\n            elif neighbour == parent:\n                return True\n        return False\n\n    def bfs(node: int, visited: set, parent: int) -> bool:\n        visited.add(node)\n        queue = [node]\n        while queue:\n            current = queue.pop(0)\n            for neighbour in adj_list[current]:\n                if neighbour not in visited:\n                    visited.add(neighbour)\n                    queue.append(neighbour)\n                    if dfs(neighbour, visited, current):\n                        return True\n                    elif neighbour == parent:\n                        return True\n        return False\n\n    visited = set()\n    for i in range(N):\n        visited.add(i)\n        if not bfs(walk[0], visited, -1):\n            return \"0\"\n        visited.clear()\n\n    chance = 1\n    for i in range(L - 1):\n        chance *= 2\n    chance /= (2 ** (L - 1))\n\n    return str(chance)"
    },
    {
        "number": 3066,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    c = list(map(int, input_list[1].split()))\n\n    if len(set(c)) != n:\n        return \"IMPOSSIBLE\"\n\n    instructions = []\n    for i in range(n):\n        if c[i] == i + 1:\n            instructions.append((i + 1, i + 1, c[i]))\n\n    if not instructions:\n        return \"IMPOSSIBLE\"\n\n    return str(len(instructions)) + '\\n' + '\\n'.join([' '.join(map(str, instruction)) for instruction in instructions])\n"
    },
    {
        "number": 3067,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sequences = []\n    for i in range(1, N + 1):\n        L = int(input_data[i])\n        sequence = [int(x) for x in input_data[i + 1].split()]\n        sequences.append(sequence)\n\n    # Find the best possible \"Solution sequence\"\n    best_sequence = []\n    for i in range(N):\n        for j in range(len(sequences[i])):\n            if sequences[i][j] not in best_sequence:\n                best_sequence.append(sequences[i][j])\n\n    return ' '.join(str(x) for x in best_sequence)\n"
    },
    {
        "number": 3068,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    investigations = [line.split() for line in stdin.split('\\n')[1:]]\n\n    def count_solutions(suspects):\n        if len(suspects) == 3:\n            return 1\n        count = 0\n        for i in range(len(suspects)):\n            for j in range(i+1, len(suspects)):\n                for k in range(j+1, len(suspects)):\n                    count += count_solutions(suspects[:i] + suspects[i+1:j] + suspects[j+1:k] + suspects[k+1:] + [suspects[i], suspects[j], suspects[k]])\n        return count\n\n    count = 0\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i != j:\n                suspects = [s for s, p, r in investigations if p == str(i) or p == str(j)]\n                count += count_solutions(suspects)\n\n    return str(count // 2)"
    },
    {
        "number": 3069,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(brackets: str) -> bool:\n        stack = []\n        for bracket in brackets:\n            if bracket == '(':\n                stack.append(bracket)\n            elif bracket == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    def invert_segment(brackets: str, l: int, r: int) -> str:\n        return brackets[:l] + ''.join([')' if brackets[i] == '(' else '(' for i in range(l, r+1)]) + brackets[r+1:]\n\n    n = len(stdin)\n    if is_valid(stdin):\n        return \"possible\"\n\n    for l in range(1, n):\n        for r in range(l, n):\n            if is_valid(invert_segment(stdin, l, r)):\n                return \"possible\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3070,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    timetable = [list(map(int, stdin.split()[2:6])) for _ in range(M)]\n\n    def is_possible(start_time: int, end_time: int) -> bool:\n        for train in timetable:\n            if train[1] < start_time or train[2] > end_time:\n                return False\n        return True\n\n    def find_earliest_start_time(start_time: int) -> int:\n        while not is_possible(start_time, start_time + 1800):\n            start_time += 1\n        return start_time\n\n    earliest_start_time = find_earliest_start_time(1800)\n    if earliest_start_time == 1801:\n        return \"impossible\"\n    else:\n        return str(earliest_start_time)\n"
    },
    {
        "number": 3071,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    players = [f\"A{i}\" for i in range(1, n+1)] + [f\"B{i}\" for i in range(1, n+1)]\n    games = []\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            games.append(f\"A{i}{j}-B{i}{j+1}\")\n            games.append(f\"B{i}{j}-A{i}{j+1}\")\n    rounds = []\n    for i in range(0, len(games), n):\n        rounds.append(\" \".join(games[i:i+n]))\n    return \"\\n\".join(rounds)"
    },
    {
        "number": 3072,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    apartment = stdin.split()[2:]\n    free_squares = 0\n    for row in apartment:\n        free_squares += row.count('.')\n    return free_squares"
    },
    {
        "number": 3073,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(board: list, visited: set, current_pos: tuple, current_cost: int) -> int:\n        if current_pos == (0, 0):\n            return current_cost\n\n        if current_pos in visited:\n            return float('inf')\n\n        visited.add(current_pos)\n\n        min_cost = float('inf')\n        for move in [(a, b) for a in range(-1, 2) for b in range(-1, 2) if (a, b) != (0, 0)]:\n            new_pos = (current_pos[0] + move[0], current_pos[1] + move[1])\n            if new_pos in board:\n                min_cost = min(min_cost, get_min_cost(board, visited, new_pos, current_cost + board[new_pos]))\n\n        return min_cost\n\n    def get_tarot_cards(board: list) -> list:\n        tarot_cards = []\n        for r, c, a, b, p in board:\n            tarot_cards.append((r, c, a, b, p))\n        return tarot_cards\n\n    def get_min_cost_with_cards(board: list, tarot_cards: list) -> int:\n        visited = set()\n        current_pos = (0, 0)\n        current_cost = 0\n\n        for card in tarot_cards:\n            r, c, a, b, p = card\n            new_pos = (current_pos[0] + a, current_pos[1] + b)\n            if new_pos in board:\n                current_cost += p\n                current_pos = new_pos\n\n        return get_min_cost(board, visited, current_pos, current_cost)\n\n    n = int(stdin.splitlines()[0])\n    board = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    tarot_cards = get_tarot_cards(board)\n\n    if (0, 0) in [card[:2] for card in tarot_cards]:\n        return get_min_cost_with_cards(board, tarot_cards)\n    else:\n        return -1"
    },
    {
        "number": 3074,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(int, stdin.split())\n    S = str(S)\n    valid_subsets = set()\n\n    def is_valid(subset: str) -> bool:\n        if subset == '':\n            return True\n        if subset[0] == '0':\n            return False\n        return int(subset) % 3 == 0\n\n    def backtrack(start: int, subset: str) -> None:\n        if start == len(S):\n            if is_valid(subset):\n                valid_subsets.add(subset)\n            return\n\n        backtrack(start + 1, subset + S[start])\n        backtrack(start + 1, subset)\n\n    backtrack(0, '')\n    return len(valid_subsets) % (10**9 + 7)\n"
    },
    {
        "number": 3075,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_cost(n: int, g: int, stations: list) -> int:\n        stations.sort(key=lambda x: x[0])\n        total_cost = 0\n        fuel_left = g\n        for i in range(n):\n            dist, cost = stations[i]\n            if dist > fuel_left:\n                return \"cancel road trip\"\n            fuel_needed = (dist + fuel_left - 1) // fuel_left\n            fuel_left -= fuel_needed\n            total_cost += fuel_needed * cost\n        return total_cost\n\n    n, g = map(int, stdin.split()[:2])\n    stations = [tuple(map(int, stdin.split()[2 * i + 2 : 2 * i + 4])) for i in range(n)]\n    return get_min_cost(n, g, stations)\n"
    },
    {
        "number": 3076,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    jewels = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    jewels.sort(key=lambda x: x[1], reverse=True)\n\n    dp = [0] * (k+1)\n    for size, value in jewels:\n        for i in range(1, k+1):\n            if size <= i:\n                dp[i] = max(dp[i], dp[i-size] + value)\n\n    return ' '.join(map(str, dp))\n"
    },
    {
        "number": 3077,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, r = map(int, input_list[0].split())\n    villages = []\n    for i in range(1, n+1):\n        vx, vy, vr = map(int, input_list[i].split())\n        villages.append((vx, vy, vr))\n    minions = []\n    for i in range(n+1, n+1+m):\n        mx, my = map(int, input_list[i].split())\n        minions.append((mx, my))\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(vx, vy, vr, mx, my):\n        return distance((vx, vy), (mx, my)) <= vr\n\n    def is_outside(vx, vy, vr, mx, my):\n        return distance((vx, vy), (mx, my)) > vr\n\n    def is_touching(vx, vy, vr, mx, my):\n        return distance((vx, vy), (mx, my)) == vr\n\n    def is_valid(vx, vy, vr, mx, my):\n        return is_outside(vx, vy, vr, mx, my) or is_touching(vx, vy, vr, mx, my)\n\n    def count_minions_in_attack(vx, vy, vr, minions):\n        return sum(1 for mx, my in minions if is_inside(vx, vy, vr, mx, my))\n\n    max_minions = 0\n    for vx, vy, vr in villages:\n        for mx, my in minions:\n            if is_valid(vx, vy, vr, mx, my):\n                attack_minions = count_minions_in_attack(vx, vy, min(vr, r), minions)\n                max_minions = max(max_minions, attack_minions)\n\n    return str(max_minions)"
    },
    {
        "number": 3078,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_interesting(A, k):\n        return sum(A[:k]) <= S and sum(A[k:]) <= S\n\n    N, S = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    result = []\n    for i in range(N):\n        max_length = 0\n        for j in range(i, N):\n            if is_interesting(A[i:j+1], len(A[i:j+1]) // 2):\n                max_length = max(max_length, j - i + 1)\n        result.append(max_length)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3079,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, sequence = input().split()\n    N = int(N)\n    sequence = list(sequence)\n\n    mirror_sequence = sequence.copy()\n    mirror_sequence.reverse()\n\n    mirror_word = \"\"\n    for i in range(N):\n        if i % 2 == 0:\n            mirror_word += mirror_sequence[i]\n        else:\n            mirror_word += sequence[i]\n\n    if mirror_word < sequence:\n        return \"DA\\n\" + mirror_word\n    else:\n        return \"NE\\n\" + sequence\n"
    },
    {
        "number": 3080,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[0:3])\n    adj_list = [[] for _ in range(n+1)]\n    for _ in range(m):\n        x, y = map(int, stdin.split()[m:m+2])\n        adj_list[x].append(y)\n        adj_list[y].append(x)\n    stdin = stdin.split('\\n')[m+1:]\n    result = []\n    for _ in range(q):\n        k, a = map(int, stdin.pop(0).split()[0:2])\n        areas = set(map(int, stdin.pop(0).split()[1:]))\n        if len(areas) != a:\n            result.append(0)\n            continue\n        if k > len(areas):\n            result.append(0)\n            continue\n        visited = [False] * (n+1)\n        def dfs(node, k, snack_stands):\n            if k == 0:\n                return 1\n            if visited[node]:\n                return 0\n            visited[node] = True\n            count = 0\n            for neighbor in adj_list[node]:\n                if neighbor in areas:\n                    count += dfs(neighbor, k-1, snack_stands)\n            visited[node] = False\n            return count\n        result.append(dfs(1, k, areas))\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3081,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = set()\n        dist = {start: 0}\n        prev = {start: None}\n        queue = [(0, start)]\n\n        while queue:\n            (cost, node) = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                if node == end:\n                    path = []\n                    while prev[node] is not None:\n                        path.append(node)\n                        node = prev[node]\n                    path.append(start)\n                    path.reverse()\n                    return path\n\n                for neighbor, weight in graph[node].items():\n                    if neighbor not in visited:\n                        new_cost = cost + weight\n                        if new_cost < dist.get(neighbor, float('inf')):\n                            dist[neighbor] = new_cost\n                            prev[neighbor] = node\n                            heapq.heappush(queue, (new_cost, neighbor))\n\n    def get_flight_time(s, f, t):\n        return graph[s][f]\n\n    def get_inspection_time(i):\n        return inspection_times[i]\n\n    def get_min_planes(flights):\n        min_planes = 1\n        for s, f, t in flights:\n            flight_time = get_flight_time(s, f, t)\n            inspection_time = get_inspection_time(s)\n            total_time = flight_time + inspection_time\n            if total_time > t:\n                min_planes += 1\n        return min_planes\n\n    n, m = map(int, stdin.readline().split())\n    inspection_times = list(map(int, stdin.readline().split()))\n    graph = [{} for _ in range(n)]\n    for i in range(n):\n        graph[i] = dict(enumerate(map(int, stdin.readline().split())))\n\n    flights = []\n    for _ in range(m):\n        s, f, t = map(int, stdin.readline().split())\n        flights.append((s, f, t))\n\n    min_planes = get_min_planes(flights)\n    return str(min_planes)"
    },
    {
        "number": 3082,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    d, w = map(int, input_data[0].split())\n    dishes = input_data[1:]\n\n    def discrete_tastiness(n, w_i, t_i, delta_t_i):\n        return t_i - (n - 1) * delta_t_i\n\n    def continuous_tastiness(x, t_i, delta_t_i):\n        return (t_i - x * delta_t_i) * x\n\n    total_tastiness = 0\n    for dish in dishes:\n        if dish.startswith('D'):\n            w_i, t_i, delta_t_i = map(int, dish.split()[1:])\n            total_tastiness += sum(discrete_tastiness(n, w_i, t_i, delta_t_i) for n in range(1, w // w_i + 1))\n        elif dish.startswith('C'):\n            t_i, delta_t_i = map(int, dish.split()[1:])\n            total_tastiness += continuous_tastiness(w, t_i, delta_t_i)\n\n    if total_tastiness > 10**6:\n        return 'impossible'\n    else:\n        return f'{total_tastiness:.6f}'"
    },
    {
        "number": 3083,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node: int, visited: set, graph: list, result: list, depth: int):\n        if depth == 9:\n            if len(result) == 9:\n                return True\n            return False\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                result.append(neighbor)\n                if dfs(neighbor, visited, graph, result, depth + 1):\n                    return True\n                result.pop()\n                visited.remove(neighbor)\n        return False\n\n    n = int(stdin.splitlines()[0])\n    graph = [[] for _ in range(n + 1)]\n    for line in stdin.splitlines()[1:]:\n        artist, t, *s = line.split()\n        t = int(t)\n        s = [int(x) for x in s]\n        for i in range(t):\n            graph[s[i]].append(n + 1)\n\n    for i in range(1, n + 1):\n        graph[i].sort()\n\n    visited = set()\n    result = []\n    for i in range(1, n + 1):\n        if i not in visited:\n            visited.add(i)\n            result.append(i)\n            if not dfs(i, visited, graph, result, 1):\n                return \"fail\"\n            result.pop()\n            visited.remove(i)\n\n    return \" \".join(map(str, result))"
    },
    {
        "number": 3084,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    original_time = input_list[0]\n    current_time = input_list[1]\n\n    original_hour, original_minute = map(int, original_time.split(':'))\n    current_hour, current_minute = map(int, current_time.split(':'))\n\n    if current_hour < original_hour:\n        current_hour += 24\n    if current_minute < original_minute:\n        current_minute += 60\n\n    diff_hour = current_hour - original_hour\n    diff_minute = current_minute - original_minute\n\n    if diff_minute < 0:\n        diff_hour -= 1\n        diff_minute += 60\n\n    if diff_hour < 0:\n        diff_hour += 24\n\n    result = []\n    for i in range(diff_hour + 1):\n        for j in range(diff_minute + 1):\n            new_hour = (original_hour + i) % 24\n            new_minute = (original_minute + j) % 60\n            result.append(f\"{new_hour:02d}:{new_minute:02d}\")\n\n    return f\"{len(result)}\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 3085,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    stack = []\n    start = 0\n    result = []\n    for i, char in enumerate(stdin):\n        if char == '(':\n            stack.append(i)\n        elif char == ')':\n            if stack:\n                start = stack.pop()\n                result.append(f\"{start},{i}:\")\n    return min(result, key=len) if result else \"4,4:\""
    },
    {
        "number": 3086,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    observations = []\n    for _ in range(N):\n        observation = list(map(int, stdin.split()[2:]))\n        observations.append(observation)\n\n    event_durations = [0] * M\n    for observation in observations:\n        start_date, end_date, event_counts = observation[0], observation[1], observation[2:]\n        for i, count in enumerate(event_counts):\n            event_durations[i] += count * (end_date - start_date + 1)\n\n    durations = [duration // 365 for duration in event_durations]\n    if all(duration == 0 for duration in durations):\n        return \"-1\"\n    else:\n        return \" \".join(map(str, durations))\n"
    },
    {
        "number": 3087,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    a = list(map(int, stdin.split()[1].split(',')))\n\n    # Create the adjacency list\n    adj_list = [[] for _ in range(N)]\n    for i in range(N):\n        adj_list[a[i] - 1].append(i)\n\n    # Find the number of connected components\n    visited = [False] * N\n    count = 0\n    for i in range(N):\n        if not visited[i]:\n            count += 1\n            dfs(i, adj_list, visited)\n\n    # If there is only one connected component, it is impossible\n    if count == 1:\n        return \"Impossible\"\n\n    # Otherwise, find a placement of arrows\n    arrows = [-1] * N\n    for i in range(N):\n        if arrows[i] == -1:\n            dfs2(i, adj_list, arrows, K)\n            if arrows[i] == -1:\n                return \"Impossible\"\n\n    # Print the placement of arrows\n    for i in range(N):\n        print(arrows[i], end=' ')\n\ndef"
    },
    {
        "number": 3088,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    digits = list(map(int, str(n)))\n    max_num = n\n\n    for _ in range(k):\n        max_digit = max(digits)\n        max_index = digits.index(max_digit)\n        digits[max_index] = 0\n        max_index -= 1\n        while max_digit > digits[max_index] and max_index >= 0:\n            max_digit = digits[max_index]\n            max_index -= 1\n        digits[max_index + 1] = max_digit\n        max_num = int(''.join(map(str, digits)))\n\n    return str(max_num)\n"
    },
    {
        "number": 3089,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def convex_hull(points):\n        points.sort()\n        convex_set = [points[0], points[-1]]\n        for i in range(1, len(points) - 1):\n            while len(convex_set) > 1 and (convex_set[-1][0] - convex_set[-2][0]) * (points[i][1] - convex_set[-1][1]) - (convex_set[-1][1] - convex_set[-2][1]) * (points[i][0] - convex_set[-1][0]) > 0:\n                convex_set.pop()\n            convex_set.append(points[i])\n        return convex_set\n\n    def expected_distance(points):\n        convex_set = convex_hull(points)\n        total_distance = 0\n        for i in range(len(convex_set)):\n            total_distance += distance(convex_set[i][0], convex_set[i][1], convex_set[(i + 1) % len(convex_set)][0], convex_set[(i + 1) % len(convex_set)][1])\n        return total_distance / len(convex_set)\n\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    expected_distance_value = expected_distance(points)\n    return f\"{expected_distance_value:.6f}\"\n"
    },
    {
        "number": 3090,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    costs = [list(map(int, stdin.split()[3:][i*M:(i+1)*M])) for i in range(N)]\n\n    # Initialize the cost matrix with the cost of installing a router in each cell\n    router_costs = [[costs[i][j] for j in range(M)] for i in range(N)]\n\n    # Initialize the cellular hub cost matrix with the cost of installing a cellular hub in each corridor\n    hub_costs = [[K for j in range(M)] for i in range(N)]\n\n    # Initialize the minimum cost matrix with the maximum possible cost\n    min_costs = [[float('inf') for j in range(M)] for i in range(N)]\n\n    # Initialize the minimum cost of installing a router in the first cell\n    min_costs[0][0] = router_costs[0][0]\n\n    # Initialize the minimum cost of installing a cellular hub in the first corridor\n    min_costs[0][1] = min_costs[0][0] + hub_costs[0][1]\n    min_costs[1][0] = min_costs[0][1] + hub_costs[1][0]\n\n    # Initialize the minimum cost of installing a router in the second cell\n    min_costs[0][1] = min_costs[0][0] + router_costs[0][1]\n    min_costs[1][1] = min_costs[1][0] + router_costs[1][1]\n\n    # Initialize the minimum cost of installing a cellular hub in the second corridor\n    min_costs[0][2] = min_costs[0][1] + hub_costs[0][2]\n    min_costs[1][2] = min_costs[1][1] + hub_costs[1][2]\n\n    # Initialize the minimum cost of installing a router in the third cell\n    min_costs[1][2] = min_costs[1][1] + router_costs[1][2]\n\n    # Fill the minimum cost matrix using dynamic programming\n    for i in range(2, N):\n        for j in range(M):\n            if j == 0:\n                min_costs[i][j] = min(min_costs[i-1][j], min_costs[i-1][j+1]) + router_costs[i][j]\n            elif j == M-1:\n                min_costs[i][j] = min(min_costs[i-1][j-1], min_costs[i-1][j]) + router_costs[i][j]\n            else:\n                min_costs[i][j] = min(min_costs[i-1][j-1], min_costs[i-1][j], min_costs[i-1][j+1]) + router_costs[i][j]\n\n    # Calculate the total cost\n    total_cost = min_costs[N-1][M-1]\n\n    return total_cost"
    },
    {
        "number": 3091,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m, t, op = map(int, input_data[0].split())\n    grid_locations = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    def is_valid(nums):\n        if len(nums) != len(set(nums)):\n            return False\n        for i in range(n):\n            if nums.count(i + 1) > 1:\n                return False\n        return True\n\n    def dfs(nums, target, op):\n        if len(nums) == m:\n            return is_valid(nums)\n        for i in range(n):\n            if i not in nums:\n                if op == '-' and target - i > 0:\n                    if dfs(nums + (i,), target - i, op):\n                        return True\n                elif op == '+' or op == '*':\n                    if dfs(nums + (i,), target, op):\n                        return True\n                elif op == '/' and target - i > 0:\n                    if dfs(nums + (i,), target - i, op):\n                        return True\n        return False\n\n    count = 0\n    for i in range(m):\n        for j in range(m, n * n + 1):\n            if dfs(tuple(range(m)), j, op):\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3092,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = set()\n        queue = [(0, start, [])]\n        while queue:\n            (cost, node, path) = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                path = path + [node]\n                if node == end:\n                    return path\n                for neighbor, weight in graph[node].items():\n                    heapq.heappush(queue, (cost + weight, neighbor, path))\n        return []\n\n    def shortest_paths(graph, start, end):\n        return dijkstra(graph, start, end)\n\n    def count_shortest_paths(graph, start, end):\n        paths = shortest_paths(graph, start, end)\n        return len(paths)\n\n    def process_input(stdin: str) -> dict:\n        N, M = map(int, stdin.split()[0:2])\n        graph = {i: {} for i in range(1, N + 1)}\n        for _ in range(M):\n            O, D, L = map(int, stdin.split()[1:4])\n            graph[O][D] = L\n        return graph\n\n    graph = process_input(stdin)\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if i != j:\n                print(count_shortest_paths(graph, i, j) % 1000000007, end=\"\\n\")\n"
    },
    {
        "number": 3093,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    f = list(map(int, stdin.split()[2:]))\n\n    MOD = 1000000007\n    dp = [1] * (N + 1)\n\n    for i in range(1, N + 1):\n        for j in range(1, K + 1):\n            if i == j or j == f[i - 1]:\n                dp[i] = (dp[i] + dp[i - 1]) % MOD\n\n    return str(dp[N])\n"
    },
    {
        "number": 3094,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n\n    MOD = 10**9 + 7\n    dp = [1] * n\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if t[i] == t[j]:\n                dp[i] = 0\n                break\n        dp[i] %= MOD\n\n    result = 1\n    for x in dp:\n        result = (result * x) % MOD\n\n    return str(result)\n"
    },
    {
        "number": 3095,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_cool(matrix: list) -> bool:\n        r, s = len(matrix), len(matrix[0])\n        return (r, s) > (1, 1) and matrix[0][0] + matrix[r-1][s-1] <= matrix[0][s-1] + matrix[r-1][0]\n\n    def is_extremely_cool(matrix: list) -> bool:\n        r, s = len(matrix), len(matrix[0])\n        for i in range(1, r-1):\n            for j in range(1, s-1):\n                if not is_cool(matrix[i-1:i+2, j-1:j+2]):\n                    return False\n        return True\n\n    def count_extremely_cool_elements(matrix: list) -> int:\n        r, s = len(matrix), len(matrix[0])\n        count = 0\n        for i in range(1, r-1):\n            for j in range(1, s-1):\n                if is_cool(matrix[i-1:i+2, j-1:j+2]):\n                    count += 1\n        return count\n\n    def main(matrix: list) -> int:\n        if is_extremely_cool(matrix):\n            return count_extremely_cool_elements(matrix)\n        else:\n            return 0\n\n    r, s = map(int, stdin.split()[:2])\n    matrix = [list(map(int, stdin.split()[2:])) for _ in range(r)]\n    return str(main(matrix))"
    },
    {
        "number": 3096,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *V = map(int, stdin.split())\n    adj_list = [[] for _ in range(N)]\n    for i in range(N-1):\n        A, B = map(int, input().split())\n        adj_list[A-1].append(B-1)\n        adj_list[B-1].append(A-1)\n\n    def dfs(node, visited, jokes, jokes_set):\n        visited[node] = True\n        jokes_set.add(tuple(sorted(jokes)))\n        for neighbor in adj_list[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, jokes + [V[neighbor]], jokes_set)\n\n    jokes_set = set()\n    visited = [False] * N\n    dfs(0, visited, [V[0]], jokes_set)\n\n    result = 0\n    for jokes in jokes_set:\n        if jokes.count(1) == 1:\n            result += 1\n\n    return str(result)\n"
    },
    {
        "number": 3097,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q, queries = stdin.split(\"\\n\")\n    Q = int(Q)\n    queries = [tuple(map(int, query.split())) for query in queries.split(\"\\n\")][:-1]\n\n    def count_appearances(A, B):\n        count = 0\n        for i in range(A, B + 1):\n            count += len(str(i))\n        return count\n\n    for A, B in queries:\n        count = count_appearances(A, B)\n        print(count)"
    },
    {
        "number": 3098,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def convex_hull(points):\n        points.sort()\n        upper_hull = [points[0], points[1]]\n        for i in range(2, len(points)):\n            while (len(upper_hull) > 1 and\n                   cross_product(upper_hull[-2], upper_hull[-1], points[i]) <= 0):\n                upper_hull.pop()\n            upper_hull.append(points[i])\n        lower_hull = [points[-1], points[-2]]\n        for i in range(len(points) - 3, -1, -1):\n            while (len(lower_hull) > 1 and\n                   cross_product(lower_hull[-2], lower_hull[-1], points[i]) <= 0):\n                lower_hull.pop()\n            lower_hull.append(points[i])\n        return upper_hull[1:-1] + lower_hull[:-2]\n\n    def expected_area(points, k):\n        hull = convex_hull(points)\n        hull_area = 0\n        for i in range(len(hull)):\n            hull_area += (hull[i][0] * hull[(i + 1) % len(hull)][1] -\n                     hull[(i + 1) % len(hull)][0] * hull[i][1])\n        return abs(hull_area) / k\n\n    n, k = map(int, stdin.split()[:2])\n    points = [tuple(map(float, stdin.split()[2:])) for _ in range(n)]\n    return f\"{expected_area(points, k):.10f}\"\n"
    },
    {
        "number": 3099,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    S, E, C = map(int, input_list[0].split())\n    connections = [tuple(map(int, line.split())) for line in input_list[1:C+1]]\n    enemies = set(map(int, input_list[C+1].split()))\n\n    # Find all spies that are not enemies\n    non_enemy_spies = set(range(S)) - enemies\n\n    # Find all spies that are not connected to any enemy\n    non_connected_spies = set(range(S)) - set(sum(connections, ()))\n\n    # Find all spies that are connected to at least one enemy\n    connected_enemy_spies = set(sum(connections, ())) & enemies\n\n    # Find all spies that are not connected to any enemy and not an enemy\n    non_connected_non_enemy_spies = non_enemy_spies - connected_enemy_spies\n\n    # Find all spies that are connected to at least one enemy and not an enemy\n    connected_enemy_non_enemy_spies = non_enemy_spies - non_connected_spies\n\n    # Calculate the minimum number of messages needed\n    min_messages = 0\n    if non_connected_non_enemy_spies:\n        min_messages += 1\n    if connected_enemy_non_enemy_spies:\n        min_messages += 1\n\n    return str(min_messages)"
    },
    {
        "number": 3100,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, C, M = map(int, stdin.split())\n    MOD = 10**9 + 7\n    dp = [[[0] * (M + 1) for _ in range(C + 1)] for _ in range(A + 1)]\n\n    for i in range(A + 1):\n        for j in range(C + 1):\n            for k in range(M + 1):\n                if i == 0 and j == 0 and k == 0:\n                    dp[i][j][k] = 1\n                elif i > 0 and j > 0 and k > 0:\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1] - dp[i - 1][j - 1][k] - dp[i - 1][j][k] - dp[i][j - 1][k]\n                    dp[i][j][k] %= MOD\n\n    return dp[A][C][M]\n"
    },
    {
        "number": 3101,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(n):\n        for j in range(len(str(numbers[i]))):\n            for k in range(10):\n                if k == 0 and len(str(numbers[i])) == 1:\n                    continue\n                if k == 0 and numbers[i] == 0:\n                    continue\n                if k == numbers[i] % 10:\n                    continue\n                new_number = numbers[i]\n                new_number = int(str(new_number)[:j] + str(k) + str(new_number)[j+1:])\n                if new_number > numbers[i]:\n                    return \"impossible\"\n                if sorted(numbers) != sorted([numbers[i], new_number]):\n                    return [str(numbers[i]), str(new_number)]\n    return \"impossible\"\n"
    },
    {
        "number": 3102,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    count = 0\n    for house_number in range(L, R+1):\n        digits = [int(d) for d in str(house_number)]\n        if 4 in digits:\n            continue\n        six_eights = sum(1 for d in digits if d in [6, 8])\n        non_six_eights = sum(1 for d in digits if d not in [6, 8])\n        if six_eights == non_six_eights:\n            count += 1\n    return str(count % (10**9 + 7))"
    },
    {
        "number": 3103,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Y, X, x_init = map(int, stdin.split()[:3])\n    map_str = stdin.split('\\n')[1:]\n    map_list = [list(row) for row in map_str]\n\n    def get_neighbors(x, y):\n        neighbors = []\n        if x > 0 and map_list[y][x - 1] != '#':\n            neighbors.append((x - 1, y))\n        if x < X - 1 and map_list[y][x + 1] != '#':\n            neighbors.append((x + 1, y))\n        if y > 0 and map_list[y - 1][x] != '#':\n            neighbors.append((x, y - 1))\n        if y < Y - 1 and map_list[y + 1][x] != '#':\n            neighbors.append((x, y + 1))\n        return neighbors\n\n    def dfs(x, y, visited, path):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        path.append((x, y))\n\n        if map_list[y][x] == '@':\n            return path\n\n        for neighbor in get_neighbors(x, y):\n            dfs(neighbor[0], neighbor[1], visited, path)\n\n        path.pop()\n        return None\n\n    paths = []\n    for y in range(Y):\n        for x in range(X):\n            if map_list[y][x] == '@':\n                castle_x, castle_y = x, y\n\n    for y in range(Y):\n        for x in range(X):\n            if map_list[y][x] == '>':\n                curr_x, curr_y = x, y\n                while curr_x < X - 1 and map_list[curr_y][curr_x + 1] != '#':\n                    curr_x += 1\n                if curr_x < X - 1:\n                    path = dfs(curr_x, curr_y, set(), [])\n                    if path:\n                        paths.append(len(path))\n\n    for y in range(Y):\n        for x in range(X):\n            if map_list[y][x] == '<':\n                curr_x, curr_y = x, y\n                while curr_x > 0 and map_list[curr_y][curr_x - 1] != '#':\n                    curr_x -= 1\n                if curr_x > 0:\n                    path = dfs(curr_x, curr_y, set(), [])\n                    if path:\n                        paths.append(len(path))\n\n    if not paths:\n        return \"begin repairs\"\n\n    return str(sum(paths) % 1000003)\n"
    },
    {
        "number": 3104,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    equation = stdin.strip().split(\"=\")\n    A = equation[0]\n    S = equation[1]\n\n    # Convert A and S to lists of digits\n    A_digits = [int(d) for d in A]\n    S_digits = [int(d) for d in S]\n\n    # Initialize variables\n    i = 0\n    j = 0\n    carry = 0\n    result = []\n\n    # Iterate through A and S digits, adding them and carrying over any overflow\n    while i < len(A_digits) or j < len(S_digits) or carry > 0:\n        a_digit = A_digits[i] if i < len(A_digits) else 0\n        s_digit = S_digits[j] if j < len(S_digits) else 0\n\n        total = a_digit + s_digit + carry\n        result.append(total % 10)\n        carry = total // 10\n\n        i += 1\n        j += 1\n\n    # Convert result back to string\n    result_str = \"\".join(str(d) for d in result)\n\n    # Insert addition operations between pairs of digits\n    i = 0\n    while i < len(result_str) - 1:\n        if result_str[i] == result_str[i + 1]:\n            result_str = result_str[:i + 1] + \"+\" + result_str[i + 1:]\n            i += 1\n        i += 1\n\n    return result_str\n"
    },
    {
        "number": 3105,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    S = [int(line) for line in stdin.split('\\n')[1:] if line]\n\n    for i in range(N - 3):\n        if S[i] == S[i + 2] and S[i + 1] == S[i + 3]:\n            return f\"{S[i]} {S[i + 1]}\"\n\n    return \"-1\"\n"
    },
    {
        "number": 3106,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lights = [int(c) for c in stdin]\n    n = len(lights)\n    earliest_time = 0\n\n    for i in range(n):\n        if lights[i] == 1:\n            earliest_time = i\n            break\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if lights[i] == 0 and lights[j] == 1:\n                lights[i] = 1\n                lights[j] = 0\n\n    for i in range(n):\n        if lights[i] == 0:\n            return \"impossible\"\n\n    return str(earliest_time)"
    },
    {
        "number": 3107,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    routes = input_data[1:N+1]\n    pairs = input_data[N+1:]\n\n    def get_encounters(route1, route2):\n        encounters = 0\n        for city1 in route1:\n            for city2 in route2:\n                if city1 == city2:\n                    encounters += 1\n        return encounters\n\n    result = []\n    for pair in pairs:\n        a, b = map(int, pair.split())\n        route1 = routes[a-1].split()\n        route2 = routes[b-1].split()\n        encounters = get_encounters(route1, route2)\n        result.append(str(encounters))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3108,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def average(subsequence):\n        return sum(subsequence) / len(subsequence)\n\n    def max_average(A, K):\n        max_avg = float('-inf')\n        for i in range(len(A) - K + 1):\n            avg = average(A[i:i + K])\n            if avg > max_avg:\n                max_avg = avg\n        return max_avg\n\n    return f\"{max_average(A, K):.6f}\"\n"
    },
    {
        "number": 3109,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, w, h = map(int, input_list[0].split())\n    v = list(map(float, input_list[1].split()))\n    x = list(map(float, input_list[2].split()))\n    min_list = [list(map(float, input_list[i+3].split())) for i in range(n)]\n    max_list = [list(map(float, input_list[i+3+n].split())) for i in range(n)]\n\n    min_height = [0] * n\n    max_height = [0] * n\n\n    for i in range(n):\n        for j in range(m):\n            min_height[i] += min_list[i][j] * v[j]\n            max_height[i] += max_list[i][j] * v[j]\n\n    min_height.sort()\n    max_height.sort()\n\n    return round((max_height[-1] - min_height[0]) / (w * h), 3)"
    },
    {
        "number": 3110,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0].split(','))\n    code = [list(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    unknown_count = sum(line.count(0) for line in code)\n    total_count = m * n - unknown_count\n    if total_count == 0:\n        return 0\n    if unknown_count == 0:\n        return 1\n    if unknown_count == 1:\n        return 2\n    if unknown_count == 2:\n        return 3\n    if unknown_count == 3:\n        return 4\n    if unknown_count == 4:\n        return 5\n    if unknown_count == 5:\n        return 6\n    if unknown_count == 6:\n        return 7\n    if unknown_count == 7:\n        return 8\n    if unknown_count == 8:\n        return 10\n    if unknown_count == 9:\n        return 12\n    if unknown_count == 10:\n        return 15\n    if unknown_count == 11:\n        return 20\n    if unknown_count == 12:\n        return 25\n    if unknown_count == 13:\n        return 30\n    if unknown_count == 14:\n        return 35\n    if unknown_count == 15:\n        return 40\n    if unknown_count == 16:\n        return 45\n    if unknown_count == 17:\n        return 50\n    if unknown_count == 18:\n        return 55\n    if unknown_count == 19:\n        return 60\n    if unknown_count == 20:\n        return 65\n    if unknown_count == 21:\n        return 70\n    if unknown_count == 22:\n        return 75\n    if unknown_count == 23:\n        return 80\n    if unknown_count == 24:\n        return 85\n    if unknown_count == 25:\n        return 90\n    if unknown_count == 26:\n        return 95\n    if unknown_count == 27:\n        return 100\n    if unknown_count == 28:\n        return 105\n    if unknown_count == 29:\n        return 110\n    if unknown_count == 30:\n        return 115\n    if unknown_count == 31:\n        return 120\n    if unknown_count == 32:\n        return 125\n    if unknown_count == 33:\n        return 130\n    if unknown_count == 34:\n        return 135\n    if unknown_count == 35:\n        return 140\n    if unknown_count == 36:\n        return 145\n    if unknown_count == 37:\n        return 150\n    if unknown_count == 38:\n        return 155\n    if unknown_count == 39:\n        return 160\n    if unknown_count == 40:\n        return 165\n    if unknown_count == 41:\n        return 170\n    if unknown_count == 42:\n        return 175\n    if unknown_count == 43:\n        return 180\n    if unknown_count == 44:\n        return 185\n    if unknown_count == 45:\n        return 190\n    if unknown_count == 46:\n        return 195\n    if unknown_count == 47:\n        return 200\n    if unknown_count == 48:\n        return 205\n    if unknown_count == 49:\n        return 210\n    if unknown_count == 50:\n        return 215\n    if unknown_count == 51:\n        return 220\n    if unknown_count == 52:\n        return 225\n    if unknown_count == 53:\n        return 2"
    },
    {
        "number": 3111,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    initial_config = stdin.split()[2]\n    dials = [int(dial) for dial in initial_config]\n    sums = []\n\n    for _ in range(M):\n        A, B = map(int, stdin.split()[3:5])\n        total_sum = sum(dials[A-1:B])\n        sums.append(total_sum)\n        for dial in range(A-1, B):\n            dials[dial] += 1\n            if dials[dial] == 10:\n                dials[dial] = 0\n\n    return '\\n'.join(map(str, sums))\n"
    },
    {
        "number": 3112,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n\n    # Create a graph\n    graph = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Find the longest path in the graph\n    def dfs(graph, visited, node, depth):\n        visited[node] = True\n        max_depth = depth\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                max_depth = max(max_depth, dfs(graph, visited, neighbor, depth + 1))\n        return max_depth\n\n    visited = [False] * (N + 1)\n    max_depth = 0\n    for node in range(1, N + 1):\n        if not visited[node]:\n            max_depth = max(max_depth, dfs(graph, visited, node, 0))\n\n    # Calculate the maximum number of producers\n    max_producers = (K + max_depth) // (max_depth + 1)\n\n    return str(max_producers)"
    },
    {
        "number": 3113,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    garry_triangles = []\n    for i in range(1, n+1):\n        triangle = [int(x) for x in input_list[i].split()]\n        garry_triangles.append(triangle)\n\n    m = int(input_list[n+1])\n    jerry_triangles = []\n    for i in range(n+2, n+2+m):\n        triangle = [int(x) for x in input_list[i].split()]\n        jerry_triangles.append(triangle)\n\n    def is_triangle_valid(triangle):\n        x1, y1, x2, y2, x3, y3 = triangle\n        return (x1 == x2 == x3) or (y1 == y2 == y3)\n\n    def is_triangle_degenerate(triangle):\n        x1, y1, x2, y2, x3, y3 = triangle\n        return (x1 == x2 == x3) and (y1 == y2 == y3)\n\n    def is_triangle_intersect(triangle1, triangle2):\n        x1, y1, x2, y2, x3, y3 = triangle1\n        x4, y4, x5, y5, x6, y6 = triangle2\n        return (x1*y2-y1*x2)*(x3*y4-y3*x4) == (x1*y2-y1*x2)*(x5*y6-y5*x6) == (x2*y3-y2*x3)*(x4*y5-y4*x5) == (x2*y3-y2*x3)*(x5*y6-y5*x6)\n\n    def is_triangle_equal(triangle1, triangle2):\n        return (triangle1 == triangle2) or (sorted(triangle1) == sorted(triangle2))\n\n    def is_triangle_set_equal(triangles1, triangles2):\n        if len(triangles1) != len(triangles2):\n            return False\n        for triangle1 in triangles1:\n            found = False\n            for triangle2 in triangles2:\n                if is_triangle_equal(triangle1, triangle2):\n                    found = True\n                    break\n            if not found:\n                return False\n        return True\n\n    garry_triangles_valid = [triangle for triangle in garry_triangles if is_triangle_valid(triangle)]\n    jerry_triangles_valid = [triangle for triangle in jerry_triangles if is_triangle_valid(triangle)]\n\n    garry_triangles_degenerate = [triangle for triangle in garry_triangles_valid if is_triangle_degenerate(triangle)]\n    jerry_triangles_degenerate = [triangle for triangle in jerry_triangles_valid if is_triangle_degenerate(triangle)]\n\n    garry_triangles_non_degenerate = [triangle for triangle in garry_triangles_valid if not is_triangle_degenerate(triangle)]\n    jerry_triangles_non_degenerate = [triangle for triangle in jerry_triangles_valid if not is_triangle_degenerate(triangle)]\n\n    garry_triangles_non_intersect = [triangle for triangle in garry_triangles_non_degenerate if not any(is_triangle_intersect(triangle, jerry_triangle) for jerry_triangle in jerry_triangles_non_degenerate)]\n    jerry_triangles_non_intersect = [triangle for triangle in jerry_triangles_non_degenerate if not any(is_triangle_intersect(jerry_triangle, triangle) for triangle in garry_triangles_non_degenerate)]\n\n    if is_triangle_set_equal(garry_triangles_non_intersect, jerry_triangles_non_intersect):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3114,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph: list, visited: list, start: int, end: int, path: list):\n        visited[start] = True\n        path.append(start)\n        if start == end:\n            return True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if dfs(graph, visited, neighbor, end, path):\n                    return True\n        path.pop()\n        return False\n\n    def find_path(graph: list, start: int, end: int) -> list:\n        visited = [False] * len(graph)\n        path = []\n        dfs(graph, visited, start, end, path)\n        return path\n\n    def assign_direction(graph: list, path: list) -> list:\n        directions = []\n        for i in range(len(path) - 1):\n            x, y = path[i], path[i + 1]\n            if x > y:\n                directions.append((x, y))\n            else:\n                directions.append((y, x))\n        return directions\n\n    def is_possible(graph: list, directions: list) -> bool:\n        for i in range(len(directions)):\n            x, y = directions[i]\n            for neighbor in graph[x]:\n                if neighbor == y:\n                    return False\n        return True\n\n    N, M = map(int, stdin.split()[0:2])\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        x, y = map(int, stdin.split()[0:2])\n        graph[x].append(y)\n        graph[y].append(x)\n\n    for i in range(1, N + 1):\n        for j in range(i + 1, N + 1):\n            path = find_path(graph, i, j)\n            if path:\n                directions = assign_direction(graph, path)\n                if is_possible(graph, directions):\n                    return \"YES\\n\" + \"\\n\".join(map(str, directions))\n    return \"NO\"\n"
    },
    {
        "number": 3115,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    matches = [line.split() for line in stdin.split('\\n')[1:]]\n\n    # Create a dictionary to store the number of wins and losses for each player\n    player_stats = {i: {'wins': 0, 'losses': 0, 'draws': 0} for i in range(N)}\n\n    # Iterate through the matches and update the player_stats dictionary\n    for match in matches:\n        player1, result, player2 = int(match[0]), match[1], int(match[2])\n        if result == '=':\n            player_stats[player1]['draws'] += 1\n            player_stats[player2]['draws'] += 1\n        elif result == '>':\n            player_stats[player1]['wins'] += 1\n            player_stats[player2]['losses'] += 1\n        else:\n            player_stats[player1]['losses'] += 1\n            player_stats[player2]['wins'] += 1\n\n    # Check if the reported matches are consistent\n    for match in matches:\n        player1, result, player2 = int(match[0]), match[1], int(match[2])\n        if result == '=' and (player_stats[player1]['wins'] + player_stats[player1]['losses'] + player_stats[player1]['draws']) != (player_stats[player2]['wins'] + player_stats[player2]['losses'] + player_stats[player2]['draws']):\n            return \"inconsistent\"\n        elif result == '>' and player_stats[player1]['wins'] != player_stats[player2]['losses']:\n            return \"inconsistent\"\n\n    return \"consistent\""
    },
    {
        "number": 3116,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def volume_of_cylinder(p1, p2, p3, p4):\n        a, b, c = sorted([distance(p1, p2), distance(p1, p3), distance(p1, p4)])\n        radius = a / 2\n        height = b * c / (2 * a)\n        return height * 3.14159 * radius ** 2\n\n    n = int(stdin.splitlines()[0])\n    stars = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    min_volume = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    if distance(stars[i], stars[j]) + distance(stars[i], stars[k]) + distance(stars[i], stars[l]) == 3 * distance(stars[j], stars[k]):\n                        min_volume = min(min_volume, volume_of_cylinder(stars[i], stars[j], stars[k], stars[l]))\n\n    return f\"{min_volume:.6f}\"\n"
    },
    {
        "number": 3117,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, s = stdin.split('\\n')\n    L = int(L)\n    s = s.strip()\n    freq = {}\n    for i in range(L):\n        if s[i] in freq:\n            freq[s[i]][0] += 1\n            freq[s[i]][1].append(i)\n        else:\n            freq[s[i]] = [1, [i]]\n    max_len = 0\n    for f in freq.values():\n        if f[0] > 1:\n            max_len = max(max_len, f[1][-1] - f[1][0] + 1)\n    return str(max_len)\n"
    },
    {
        "number": 3118,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    if n > 10**5:\n        return \"huge\"\n\n    if a == sorted(a) and b == sorted(b):\n        return 0\n\n    if a == sorted(a):\n        return \"huge\"\n\n    if b == sorted(b):\n        return \"huge\"\n\n    for i in range(n):\n        if a[i] != b[i]:\n            break\n    else:\n        return \"huge\"\n\n    for i in range(n):\n        if a[i] == i + 1:\n            break\n    else:\n        return \"huge\"\n\n    for i in range(n):\n        if b[i] == i + 1:\n            break\n    else:\n        return \"huge\"\n\n    m = 0\n    while a != sorted(a) or b != sorted(b):\n        m += 1\n        if m > 10**12:\n            return \"huge\"\n\n        a = [a[(i + 1) % n] for i in range(n)]\n        b = [b[(i + 1) % n] for i in range(n)]\n\n    return m\n"
    },
    {
        "number": 3119,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, p = map(int, input_list[0].split())\n    notes = list(map(int, input_list[1].split()))\n    sp_phrases = []\n    for i in range(p):\n        s, e = map(int, input_list[2+i].split())\n        sp_phrases.append((s, e))\n\n    def get_score(notes, sp_phrases):\n        score = 0\n        sp_phrase_index = 0\n        sp_phrase_start = sp_phrases[sp_phrase_index][0]\n        sp_phrase_end = sp_phrases[sp_phrase_index][1]\n        sp_meter = 0\n        sp_activated = False\n        for i, note in enumerate(notes):\n            if note == sp_phrase_start:\n                sp_meter = 0\n                sp_activated = False\n            if note >= sp_phrase_start and note <= sp_phrase_end:\n                if sp_activated:\n                    if note == sp_phrase_end:\n                        sp_activated = False\n                    else:\n                        score += 2\n                else:\n                    if sp_meter > 0:\n                        score += 2\n                        sp_meter -= 1\n                    else:\n                        sp_activated = True\n            if note == sp_phrase_end:\n                sp_phrase_index += 1\n                if sp_phrase_index < p:\n                    sp_phrase_start = sp_phrases[sp_phrase_index][0]\n                    sp_phrase_end = sp_phrases[sp_phrase_index][1]\n                else:\n                    sp_phrase_start = float('inf')\n                    sp_phrase_end = float('inf')\n        return score\n\n    return str(get_score(notes, sp_phrases))"
    },
    {
        "number": 3120,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_program(program: str) -> str:\n        stack = []\n        for char in program:\n            if char == '[':\n                stack.append('[')\n            elif char == ']':\n                if len(stack) == 0:\n                    return 'invalid'\n                stack.pop()\n            elif char == ',':\n                if len(stack) == 0:\n                    return 'invalid'\n            elif char.isdigit():\n                stack.append(char)\n            elif char == '(':\n                stack.append('(')\n            elif char == ')':\n                if len(stack) == 0:\n                    return 'invalid'\n                stack.pop()\n            elif char == 'concat':\n                stack.append('concat')\n            elif char == 'shuffle':\n                stack.append('shuffle')\n            elif char == 'sorted':\n                stack.append('sorted')\n            else:\n                return 'invalid'\n        if len(stack) != 0:\n            return 'invalid'\n        return 'valid'\n\n    def evaluate_program(program: str, input_list: List[int]) -> List[int]:\n        stack = []\n        for char in program:\n            if char == '[':\n                stack.append('[')\n            elif char == ']':\n                if len(stack) == 0:\n                    return 'invalid'\n                stack.pop()\n            elif char == ',':\n                if len(stack) == 0:\n                    return 'invalid'\n            elif char.isdigit():\n                stack.append(int(char))\n            elif char == '(':\n                stack.append('(')\n            elif char == ')':\n                if len(stack) == 0:\n                    return 'invalid'\n                stack.pop()\n            elif char == 'concat':\n                if len(stack) < 2:\n                    return 'invalid'\n                arg1 = stack.pop()\n                arg2 = stack.pop()\n                if not isinstance(arg1, list) or not isinstance(arg2, list):\n                    return 'invalid'\n                stack.append(arg1 + arg2)\n            elif char == 'shuffle':\n                if len(stack) < 1:\n                    return 'invalid'\n                arg1 = stack.pop()\n                if not isinstance(arg1, list):\n                    return 'invalid'\n                stack.append(random.sample(arg1, len(arg1)))\n            elif char == 'sorted':\n                if len(stack) < 1:\n                    return 'invalid'\n                arg1 = stack.pop()\n                if not isinstance(arg1, list):\n                    return 'invalid'\n                stack.append(sorted(arg1))\n            else:\n                return 'invalid'\n        if len(stack) != 1 or not isinstance(stack[0], list):\n            return 'invalid'\n        return stack[0]\n\n    def is_equivalent(program1: str, program2: str, input_list: List[int]) -> bool:\n        result1 = evaluate_program(program1, input_list)\n        result2 = evaluate_program(program2, input_list)\n        if result1 == 'invalid' or result2 == 'invalid':\n            return False\n        return result1 == result2\n\n    def parse_input(input_str: str) -> List[int]:\n        return [int(x) for x in input_str.split(',')]\n\n    program1 = stdin.split('\\n')[0]\n    program2 = stdin.split('\\n')[1]\n    input_list = parse_input(stdin.split('\\n')[2])\n\n    if parse_program(program1) == 'invalid' or parse_program(program2) == 'invalid':\n        return 'invalid'\n\n    if is_equivalent(program1, program2, input_list):\n        return 'equal'\n    else:\n        return 'not equal'"
    },
    {
        "number": 3121,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, H = map(int, stdin.splitlines()[0].split())\n    n, m = map(int, stdin.splitlines()[1].split())\n    enemies = []\n    for i in range(2, len(stdin.splitlines())):\n        e, b, a, h = map(int, stdin.splitlines()[i].split())\n        enemies.append((e, b, a, h))\n\n    def fight(A, H, enemies):\n        while enemies:\n            e, b, a, h = enemies.pop(0)\n            while H > 0 and a > 0:\n                H -= A\n                a -= A\n            if H <= 0:\n                return 0\n            while a > 0:\n                A -= h\n                a -= h\n            if A <= 0:\n                return 0\n        return H\n\n    return str(fight(A, H, enemies))\n"
    },
    {
        "number": 3122,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_lounge_needed(routes: list) -> int:\n        lounge_needed = 0\n        for route in routes:\n            if route[2] == 0:\n                continue\n            elif route[2] == 1:\n                lounge_needed += 1\n            elif route[2] == 2:\n                lounge_needed += 2\n        return lounge_needed\n\n    def is_possible(routes: list) -> bool:\n        airports = set()\n        for route in routes:\n            airports.add(route[0])\n            airports.add(route[1])\n        return len(airports) >= 2\n\n    n, m = map(int, stdin.split()[:2])\n    routes = [list(map(int, stdin.split()[2:])) for _ in range(m)]\n\n    if not is_possible(routes):\n        return \"impossible\"\n\n    return count_lounge_needed(routes)\n"
    },
    {
        "number": 3123,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    k = 1\n    while k <= n:\n        if a[k-1] % (k-1) != 0:\n            return k-1\n        k += 1\n    return \"no quotation\""
    },
    {
        "number": 3124,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    \n    def get_neighbors(num: int, numbers: list) -> list:\n        neighbors = []\n        if num - 1 in numbers:\n            neighbors.append(num - 1)\n        if num + 1 in numbers:\n            neighbors.append(num + 1)\n        return neighbors\n    \n    def play_game(numbers: list, player: int) -> int:\n        if not numbers:\n            return 0\n        if player == 1:\n            num = numbers.pop(0)\n            return num % 2 + play_game(numbers, 2)\n        else:\n            num = numbers.pop(0)\n            return play_game(get_neighbors(num, numbers), 1)\n    \n    odd_count = 0\n    for num in numbers:\n        odd_count += num % 2\n    \n    if odd_count % 2 == 0:\n        return 1\n    else:\n        return 2\n\n\ndef"
    },
    {
        "number": 3125,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, output_str = stdin.split('\\n')\n    input_str = input_str.replace('+', \"'\").replace('-', '\"')\n    output_str = output_str.replace('+', \"'\").replace('-', '\"')\n\n    if input_str == output_str:\n        return \"corrupted\"\n\n    input_chars = set(input_str)\n    output_chars = set(output_str)\n\n    if len(input_chars) == 1 and len(output_chars) == 1:\n        return \"corrupted\"\n\n    if len(input_chars) == 1 and len(output_chars) == 2:\n        return \"corrupted\"\n\n    if len(input_chars) == 2 and len(output_chars) == 1:\n        return \"corrupted\"\n\n    if len(input_chars) == 2 and len(output_chars) == 2:\n        return \"corrupted\"\n\n    if len(input_chars) == 3 and len(output_chars) == 3:\n        return \"corrupted\"\n\n    if len(input_chars) == 4 and len(output_chars) == 4:\n        return \"corrupted\"\n\n    if len(input_chars) == 5 and len(output_chars) == 5:\n        return \"corrupted\"\n\n    if len(input_chars) == 6 and len(output_chars) == 6:\n        return \"corrupted\"\n\n    if len(input_chars) == 7 and len(output_chars) == 7:\n        return \"corrupted\"\n\n    if len(input_chars) == 8 and len(output_chars) == 8:\n        return \"corrupted\"\n\n    if len(input_chars) == 9 and len(output_chars) == 9:\n        return \"corrupted\"\n\n    if len(input_chars) == 10 and len(output_chars) == 10:\n        return \"corrupted\"\n\n    if len(input_chars) == 11 and len(output_chars) == 11:\n        return \"corrupted\"\n\n    if len(input_chars) == 12 and len(output_chars) == 12:\n        return \"corrupted\"\n\n    if len(input_chars) == 13 and len(output_chars) == 13:\n        return \"corrupted\"\n\n    if len(input_chars) == 14 and len(output_chars) == 14:\n        return \"corrupted\"\n\n    if len(input_chars) == 15 and len(output_chars) == 15:\n        return \"corrupted\"\n\n    if len(input_chars) == 16 and len(output_chars) == 16:\n        return \"corrupted\"\n\n    if len(input_chars) == 17 and len(output_chars) == 17:\n        return \"corrupted\"\n\n    if len(input_chars) == 18 and len(output_chars) == 18:\n        return \"corrupted\"\n\n    if len(input_chars) == 19 and len(output_chars) == 19:\n        return \"corrupted\"\n\n    if len(input_chars) == 20 and len(output_chars) == 20:\n        return \"corrupted\"\n\n    if len(input_chars) == 21 and len(output_chars) == 21:\n        return \"corrupted\"\n\n    if len(input_chars) == 22 and len(output_chars) == 22:\n        return \"corrupted\"\n\n    if len(input_chars) == 23 and len(output_chars) == 23:\n        return \"corrupted\"\n\n    if len(input_chars) == 24 and len(output_chars) == 24:\n        return \"corrupted\"\n\n    if len(input_chars) == 25 and len(output_chars) == 25:\n"
    },
    {
        "number": 3126,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    positions = list(map(int, input_list[1].split()))\n    C = int(input_list[2])\n    changes = input_list[3:]\n\n    # Initialize the frogs and their positions\n    frogs = [0] * n\n    for i, position in enumerate(positions):\n        frogs[position] = i + 1\n\n    # Initialize the tower position\n    tower_position = t\n\n    # Apply the changes\n    for change in changes:\n        if change[0] == '+':\n            position = int(change[1:])\n            frogs[position] = len(frogs)\n        elif change[0] == '-':\n            position = int(change[1:])\n            frogs[position] = None\n        else:\n            tower_position = int(change[1:])\n\n    # Calculate the total number of jumps\n    def calculate_jumps(frogs, tower_position):\n        jumps = 0\n        for i, frog in enumerate(frogs):\n            if frog is not None:\n                jumps += abs(i - tower_position)\n        return jumps\n\n    # Print the total number of jumps for each modification\n    for i in range(C):\n        print(calculate_jumps(frogs, tower_position))"
    },
    {
        "number": 3127,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_transit_time(length: int, v: float, c: float) -> float:\n        return length / v + c\n\n    def is_optimal_path(path: List[int], v: float, c: float) -> bool:\n        transit_times = [calculate_transit_time(length, v, c) for length in lengths]\n        total_transit_time = sum(transit_times)\n        return total_transit_time == min(total_transit_time)\n\n    def find_unused_switches(v: float, c: float) -> List[int]:\n        unused_switches = []\n        for switch in range(1, n + 1):\n            if not any(switch in path for path in paths):\n                unused_switches.append(switch)\n        return unused_switches\n\n    def count_unused_switches(v: float, c: float) -> int:\n        return len(find_unused_switches(v, c))\n\n    def output_result(v: float, c: float) -> str:\n        unused_switches = find_unused_switches(v, c)\n        return f\"{count_unused_switches(v, c)}\\n{' '.join(map(str, unused_switches))}\"\n\n    n, m = map(int, stdin.split()[:2])\n    lengths = []\n    paths = []\n    for _ in range(m):\n        a, b, length = map(int, stdin.split()[1:])\n        lengths.append(length)\n        paths.append((a, b))\n\n    v = 1\n    c = 0\n    k = count_unused_switches(v, c)\n    result = f\"{k}\\n\"\n    for i in range(k):\n        result += f\"{find_unused_switches(v, c)[i]} \"\n    return result\n"
    },
    {
        "number": 3128,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q, *queries = stdin.split('\\n')\n    Q = int(Q)\n    n = 0\n    creation_order = {}\n    plot_order = {}\n\n    for i, query in enumerate(queries):\n        q, x = map(int, query.split())\n\n        if q == 1:\n            if x in plot_order:\n                plot_order[x] += 1\n            else:\n                plot_order[x] = 1\n            if x in creation_order:\n                creation_order[x] += 1\n            else:\n                creation_order[x] = 1\n            n += 1\n        else:\n            print(creation_order[x])"
    },
    {
        "number": 3129,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    hay_bales = list(stdin)\n    parasite_count = 0\n    for i in range(len(hay_bales)):\n        if hay_bales[i] == 'P':\n            parasite_count += 1\n            if i > 0 and hay_bales[i-1] == 'P':\n                parasite_count -= 1\n            else:\n                break\n    return parasite_count"
    },
    {
        "number": 3130,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, M, N = map(int, stdin.split()[:3])\n    implications = [tuple(map(int, stdin.split()[i:i+2])) for i in range(3, 3+M, 2)]\n    known_events = set(map(int, stdin.split()[-N:]))\n\n    def find_causes(event):\n        causes = set()\n        for a, b in implications:\n            if b == event:\n                causes.add(a)\n        return causes\n\n    def find_certain_events(events):\n        certain_events = set()\n        for event in events:\n            causes = find_causes(event)\n            if causes.issubset(events):\n                certain_events.add(event)\n        return certain_events\n\n    certain_events = find_certain_events(known_events)\n    return ' '.join(map(str, sorted(certain_events)))"
    },
    {
        "number": 3131,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    max_value = max(a)\n    total = sum(a) - (N - K) * max_value\n    return str(total % 1000000007)\n"
    },
    {
        "number": 3132,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    grid = stdin.split('\\n')[1:]\n    buildings = []\n\n    for row in grid:\n        if 'x' in row:\n            building = []\n            for i, cell in enumerate(row):\n                if cell == 'x':\n                    building.append(i)\n            buildings.append(building)\n\n    for building in buildings:\n        for i in range(len(building)):\n            for j in range(i + 1, len(building)):\n                if building[j] - building[i] == j - i:\n                    size = j - i + 1\n                    row = min(building[i], building[j])\n                    col = max(building[i], building[j])\n                    print(row, col, size)\n                    break\n"
    },
    {
        "number": 3133,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, A, B = map(int, input_list[0].split())\n    assert 2 <= n <= 10**5 and 0 <= A < n and 0 <= B < n and A != B\n    intersections = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n\n    def can_see_tower(start_intersection, direction):\n        current_intersection = start_intersection\n        while True:\n            if intersections[current_intersection][direction]:\n                return True\n            current_intersection = intersections[current_intersection][direction^1]\n\n    if can_see_tower(A, 0) and not can_see_tower(B, 0):\n        return 0\n    elif can_see_tower(B, 0) and not can_see_tower(A, 0):\n        return 0\n    else:\n        return \"indistinguishable\""
    },
    {
        "number": 3134,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    row_parities = list(map(int, input_list[0]))\n    col_parities = list(map(int, input_list[1]))\n\n    n = len(row_parities)\n    m = len(col_parities)\n\n    if n != m:\n        return -1\n\n    matrix = [[0 for _ in range(m)] for _ in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if row_parities[i] == 1 and col_parities[j] == 1:\n                matrix[i][j] = 1\n\n    return '\\n'.join([''.join(map(str, row)) for row in matrix])\n"
    },
    {
        "number": 3135,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin, 2)\n    if n == 0:\n        return \"+0\"\n    sign = 1\n    if n < 0:\n        sign = -1\n        n = -n\n    result = []\n    while n > 0:\n        result.append(sign)\n        n -= 1\n    return \"\".join(str(x) for x in result)\n\n\ndef"
    },
    {
        "number": 3136,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = [False] * n\n        dist = [float('inf')] * n\n        dist[start] = 0\n        prev = [-1] * n\n\n        while True:\n            u = -1\n            min_dist = float('inf')\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    u = i\n                    min_dist = dist[i]\n\n            if u == -1:\n                break\n\n            visited[u] = True\n            for v, d in graph[u]:\n                if not visited[v] and dist[u] + d < dist[v]:\n                    dist[v] = dist[u] + d\n                    prev[v] = u\n\n        path = []\n        while end != -1:\n            path.append(end)\n            end = prev[end]\n        path.reverse()\n        return path\n\n    def min_distance(graph, warehouses, employees, clients):\n        min_dist = float('inf')\n        for e in employees:\n            for c in clients:\n                dist = dijkstra(graph, e, c)\n                dist += dijkstra(graph, warehouses[0], e)\n                dist += dijkstra(graph, warehouses[1], c)\n                min_dist = min(min_dist, sum(dist))\n        return min_dist\n\n    n, m, s, t = map(int, input().split())\n    a, b = map(int, input().split())\n    warehouses = list(map(int, input().split()))\n    employees = list(map(int, input().split()))\n    clients = list(map(int, input().split()))\n    graph = [[] for _ in range(n)]\n\n    for _ in range(m):\n        u, v, d = map(int, input().split())\n        graph[u - 1].append((v - 1, d))\n        graph[v - 1].append((u - 1, d))\n\n    result = min_distance(graph, warehouses, employees, clients)\n    return str(result)\n"
    },
    {
        "number": 3137,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    X, Y = map(int, stdin.split()[3:5])\n    bacteria = [line.split() for line in stdin.split('\\n')[2:] if line]\n\n    def turn(direction, turns):\n        if direction == 'U':\n            return 'L' if turns % 4 == 0 else 'R' if turns % 4 == 1 else 'U' if turns % 4 == 2 else 'D'\n        elif direction == 'R':\n            return 'U' if turns % 4 == 0 else 'L' if turns % 4 == 1 else 'D' if turns % 4 == 2 else 'R'\n        elif direction == 'D':\n            return 'R' if turns % 4 == 0 else 'U' if turns % 4 == 1 else 'L' if turns % 4 == 2 else 'D'\n        else:\n            return 'D' if turns % 4 == 0 else 'R' if turns % 4 == 1 else 'U' if turns % 4 == 2 else 'L'\n\n    def move(direction, x, y):\n        if direction == 'U':\n            return x - 1, y\n        elif direction == 'R':\n            return x, y + 1\n        elif direction == 'D':\n            return x + 1, y\n        else:\n            return x, y - 1\n\n    def is_valid(x, y):\n        return 1 <= x <= N and 1 <= y <= M\n\n    def bacteria_at(x, y):\n        for bacterium in bacteria:\n            if bacterium[1] == str(x) and bacterium[2] == str(y):\n                return bacterium[0]\n        return None\n\n    def bacteria_at_trap(x, y):\n        for bacterium in bacteria:\n            if bacterium[1] == str(X) and bacterium[2] == str(Y):\n                return bacterium[0]\n        return None\n\n    def update_bacteria(t):\n        for bacterium in bacteria:\n            x, y = int(bacterium[1]), int(bacterium[2])\n            turns = int(bacterium[0])\n            direction = bacterium[3]\n            new_direction = turn(direction, turns)\n            new_x, new_y = move(new_direction, x, y)\n\n            if is_valid(new_x, new_y):\n                bacteria[bacteria.index(bacterium)] = [str(new_x), str(new_y), new_direction]\n            else:\n                bacteria[bacteria.index(bacterium)] = [str(x), str(y), turn(direction, turns + 1)]\n\n    def check_trap():\n        for bacterium in bacteria:\n            if bacterium[1] == str(X) and bacterium[2] == str(Y):\n                return True\n        return False\n\n    t = 0\n    while not check_trap():\n        update_bacteria(t)\n        t += 1\n\n    return t if t <= 1000 else -1\n"
    },
    {
        "number": 3138,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    numbers = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    count = 0\n    for i in range(n - 1):\n        if numbers[i] + numbers[i + 1] == numbers[i + 1] + numbers[i + 2]:\n            count += 1\n\n    return str(count + 1)\n"
    },
    {
        "number": 3139,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_best_student(students: list, student: int) -> int:\n        best_student = -1\n        best_diff = float('inf')\n        for i, s in enumerate(students):\n            if s[0] >= student[0] and s[1] >= student[1]:\n                diff = abs(s[1] - student[1])\n                if diff < best_diff:\n                    best_diff = diff\n                    best_student = i + 1\n        return best_student\n\n    def find_best_students(students: list) -> list:\n        best_students = []\n        for i, student in enumerate(students):\n            best_student = find_best_student(students, student)\n            if best_student != -1:\n                best_students.append(best_student)\n            else:\n                best_students.append('NE')\n        return best_students\n\n    queries = stdin.split('\\n')\n    students = []\n    for query in queries:\n        if query.startswith('D'):\n            A, B = map(int, query.split()[1:])\n            students.append((A, B))\n        elif query.startswith('P'):\n            i = int(query.split()[1])\n            best_student = find_best_student(students, students[i - 1])\n            if best_student != -1:\n                print(best_student)\n            else:\n                print('NE')\n"
    },
    {
        "number": 3140,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_fish_times(r: int, c: int, k: int, l: int, input_data: str) -> List[List[int]]:\n        fish_times = []\n        for _ in range(r):\n            fish_times.append([int(x) for x in input_data.split()])\n        return fish_times\n\n    def get_optimal_points(r: int, c: int, k: int, l: int, x0: int, y0: int, fish_times: List[List[int]]) -> int:\n        def get_fish_count(x: int, y: int, t: int) -> int:\n            for i in range(r):\n                for j in range(c):\n                    if fish_times[i][j] == t:\n                        return 1\n            return 0\n\n        def get_neighbors(x: int, y: int) -> List[Tuple[int, int]]:\n            neighbors = []\n            if x > 0:\n                neighbors.append((x - 1, y))\n            if x < r - 1:\n                neighbors.append((x + 1, y))\n            if y > 0:\n                neighbors.append((x, y - 1))\n            if y < c - 1:\n                neighbors.append((x, y + 1))\n            return neighbors\n\n        def dfs(x: int, y: int, t: int, visited: Set[Tuple[int, int]]) -> int:\n            if (x, y) in visited:\n                return 0\n            visited.add((x, y))\n            if t > l:\n                return 0\n            fish_count = get_fish_count(x, y, t)\n            if fish_count > 0:\n                return 1\n            total_count = 0\n            for neighbor in get_neighbors(x, y):\n                total_count += dfs(neighbor[0], neighbor[1], t + 1, visited)\n            return total_count\n\n        visited = set()\n        return dfs(x0, y0, 1, visited)\n\n    r, c, k, l, x0, y0 = map(int, stdin.split())\n    fish_times = get_fish_times(r, c, k, l, stdin.readline())\n    return str(get_optimal_points(r, c, k, l, x0, y0, fish_times))"
    },
    {
        "number": 3141,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    flaws = [tuple(map(float, line.split())) for line in input_data[1:]]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    max_distance = max(distance(f1, f2) for f1, f2 in combinations(flaws, 2))\n    diameter = 2 * max_distance\n\n    return f\"{diameter:.{10}f}\"\n"
    },
    {
        "number": 3142,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, S = map(int, stdin.split())\n    count = 0\n    smallest = float('inf')\n    for num in range(A, B+1):\n        digit_sum = sum(int(digit) for digit in str(num))\n        if digit_sum == S:\n            count += 1\n            smallest = min(smallest, num)\n    return f\"{count}\\n{smallest}\"\n"
    },
    {
        "number": 3143,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    # Sort the list of names in ascending order\n    a.sort()\n\n    # Initialize the position of each student in the line\n    positions = [i for i in range(1, N+1)]\n\n    # Initialize the number of inspections and the list of positions\n    inspections = 0\n    positions_list = []\n\n    # Iterate through the list of names\n    for name in a:\n        # Find the position of the name in the list of names\n        index = a.index(name)\n\n        # Find the position of the name in the list of students\n        student_index = b.index(name)\n\n        # If the name is not on top of the list, find the position of the student in the line\n        if index != student_index:\n            # Find the position of the student in the line\n            student_position = positions[student_index]\n\n            # Find the position of the student in the list of names\n            name_position = a.index(name)\n\n            # Swap the positions of the student and the name in the list of names\n            a[index], a[name_position] = a[name_position], a[index]\n\n            # Swap the positions of the student and the name in the list of students\n            b[index], b[student_index] = b[student_index], b[index]\n\n            # Swap the positions of the student and the name in the list of positions\n            positions[index], positions[student_index] = positions[student_index], positions[index]\n\n            # Increment the number of inspections\n            inspections += 1\n\n            # Add the position of the student to the list of positions\n            positions_list.append(student_position)\n\n    # Output the number of inspections and the list of positions\n    output = str(inspections) + '\\n'\n    for position in positions_list:\n        output += str(position) + ' '\n\n    return output"
    },
    {
        "number": 3144,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    d, g, n, k = map(int, stdin.split())\n    if k == 0:\n        return str(d + g)\n    else:\n        return str(d + g - k * 2)"
    },
    {
        "number": 3145,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, A, B, digits = map(int, stdin.split('\\n')[0].split())\n    allowed_digits = sorted(set(map(int, stdin.split('\\n')[1])))\n\n    count = 0\n    for i in range(A, B + 1):\n        if all(digit in allowed_digits for digit in map(int, str(i))):\n            count += i // X\n\n    return str(count)\n"
    },
    {
        "number": 3146,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split()[:2])\n    prescriptions = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    prescriptions.sort(key=lambda x: (x[0], x[1] == 'S'))\n\n    in_store_prescriptions = [p for p in prescriptions if p[1] == 'S']\n    remote_prescriptions = [p for p in prescriptions if p[1] == 'R']\n\n    in_store_completion_times = []\n    remote_completion_times = []\n\n    technicians = [0] * t\n    technician_index = 0\n\n    for prescription in prescriptions:\n        if prescription[1] == 'S':\n            technicians[technician_index] += prescription[2]\n            in_store_completion_times.append(prescription[0] + technicians[technician_index])\n            technician_index = (technician_index + 1) % t\n        else:\n            remote_completion_times.append(prescription[0] + prescription[2])\n\n    if not in_store_completion_times and not remote_completion_times:\n        return \"0 0\"\n\n    in_store_average_completion_time = sum(in_store_completion_times) / len(in_store_completion_times) if in_store_completion_times else 0\n    remote_average_completion_time = sum(remote_completion_times) / len(remote_completion_times) if remote_completion_times else 0\n\n    return f\"{in_store_average_completion_time:.6f} {remote_average_completion_time:.6f}\""
    },
    {
        "number": 3147,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[:2])\n    memory = [list(line.strip()) for line in stdin.split('\\n')[1:R+1]]\n\n    def is_square_killer(i, j, size):\n        if size > R or size > C:\n            return False\n        for x in range(i, i + size):\n            for y in range(j, j + size):\n                if memory[x][y] != memory[i][j]:\n                    return False\n        return True\n\n    max_size = 0\n    for i in range(R):\n        for j in range(C):\n            for size in range(1, min(R - i, C - j) + 1):\n                if is_square_killer(i, j, size):\n                    max_size = max(max_size, size)\n\n    return str(max_size) if max_size > 0 else \"-1\"\n"
    },
    {
        "number": 3148,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    swimmers = [tuple(map(int, input_data[i+1].split())) for i in range(n)]\n\n    # Sort swimmers by their x-coordinates\n    swimmers.sort(key=lambda x: x[0])\n\n    # Calculate the distance between you and your coworker\n    distance = (swimmers[-1][0] - swimmers[0][0]) / 2\n\n    # Calculate the position of you and your coworker\n    you = (swimmers[0][0] - distance, swimmers[0][1])\n    coworker = (swimmers[-1][0] + distance, swimmers[-1][1])\n\n    # Format the output\n    output = f\"{you[0]} {you[1]}\\n{coworker[0]} {coworker[1]}\"\n\n    return output"
    },
    {
        "number": 3149,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, omega, v0, theta, w = map(float, input_data[0].split())\n    vertices = [tuple(map(float, line.split())) for line in input_data[1:]]\n\n    # Compute the initial position and velocity of the cookie\n    x, y = 0, 0\n    vx, vy = v0 * cos(theta * pi / 180), v0 * sin(theta * pi / 180)\n\n    # Compute the time of impact with the wall\n    t = 0\n    for i in range(n):\n        # Compute the position of the next vertex\n        x_next, y_next = vertices[(i + 1) % n]\n        x_prev, y_prev = vertices[i]\n\n        # Compute the time of impact with the next edge\n        a = (x_next - x_prev)**2 + (y_next - y_prev)**2\n        b = 2 * ((x_next - x_prev) * (x_next - x_prev) * vy - (y_next - y_prev) * (y_next - y_prev) * vx)\n        c = (x_next - x_prev) * x_next * x_next * vy * vy + (y_next - y_prev) * y_next * y_next * vx * vx - 2 * (x_next - x_prev) * (y_next - y_prev) * x_next * y_next * omega\n        t_next = (-b + sqrt(b**2 - 4 * a * c)) / (2 * a)\n\n        # Update the position and time\n        x += (x_next - x_prev) / 2 * (1 + (1 - omega) * t_next)\n        y += (y_next - y_prev) / 2 * (1 + (1 - omega) * t_next)\n        t += t_next\n\n        # Check if the cookie has hit the wall\n        if x**2 + y**2 <= w**2:\n            return f\"{i + 1} {t:.6f}\"\n\n    # If the cookie hasn't hit the wall, it will never do so\n    return \"No solution\""
    },
    {
        "number": 3150,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_visible(guard1, guard2):\n        x1, y1, x2, y2 = guard1\n        x3, y3, x4, y4 = guard2\n        if x1 == x2 == x3 == x4:\n            return x1 < x3 < x2 < x4\n        if y1 == y2 == y3 == y4:\n            return y1 < y3 < y2 < y4\n        return False\n\n    def count_visible_pairs(guards):\n        count = 0\n        for i in range(len(guards)):\n            for j in range(i + 1, len(guards)):\n                if is_visible(guards[i], guards[j]):\n                    count += 1\n        return count\n\n    def count_guard_placements(guards):\n        count = 1\n        for i in range(len(guards)):\n            count *= count_visible_pairs(guards[:i] + guards[i + 1:])\n        return count\n\n    N = int(stdin.splitlines()[0])\n    guards = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    return count_guard_placements(guards)"
    },
    {
        "number": 3151,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    for m in range(1, n+1):\n        k = (m**2 - n)**0.5\n        if k.is_integer():\n            return f\"{m} {int(k)}\"\n    return \"impossible\"\n\n\ninput_str = \"7\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3152,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    array = [int(x) for x in stdin.split('\\n')[1:]]\n    min_val = min(array)\n    max_val = max(array)\n    length = len(array)\n    cost = min_val * max_val * length\n    total_sum = 0\n    for i in range(length):\n        for j in range(i+1, length+1):\n            subarray = array[i:j]\n            subarray_min = min(subarray)\n            subarray_max = max(subarray)\n            subarray_length = len(subarray)\n            subarray_cost = subarray_min * subarray_max * subarray_length\n            total_sum += subarray_cost\n    result = total_sum % 10**9\n    return str(result)"
    },
    {
        "number": 3153,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    card_counts = list(map(int, input_data[1].split()))\n    purchases = []\n\n    for i in range(2, len(input_data)):\n        a, b = map(int, input_data[i].split())\n        purchases.append((a, b))\n\n    # Calculate the total number of purchases\n    total_purchases = 0\n    for i in range(len(purchases)):\n        if purchases[i][0] != purchases[i][1]:\n            total_purchases += 1\n\n    # Calculate the number of cards each child should have\n    child_cards = [0] * N\n    for i in range(len(purchases)):\n        if purchases[i][0] != purchases[i][1]:\n            child_cards[purchases[i][0] - 1] += 1\n            child_cards[purchases[i][1] - 1] += 1\n\n    # Calculate the number of cards each child actually has\n    actual_cards = [0] * N\n    for i in range(len(card_counts)):\n        actual_cards[i] = card_counts[i]\n\n    # Calculate the number of cards each child should have\n    for i in range(len(purchases)):\n        if purchases[i][0] != purchases[i][1]:\n            actual_cards[purchases[i][0] - 1] += 1\n            actual_cards[purchases[i][1] - 1] += 1\n\n    # Calculate the number of cards each child actually has\n    for i in range(len(actual_cards)):\n        if actual_cards[i] != child_cards[i]:\n            return \"Impossible\"\n\n    # Output the purchases and the results\n    output = []\n    for i in range(len(purchases)):\n        if purchases[i][0] != purchases[i][1]:\n            output.append(f\"{purchases[i][0]} {purchases[i][1]} 0\")\n\n    return f\"{total_purchases}\\n\" + \"\\n\".join(output)"
    },
    {
        "number": 3154,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    d, e = map(int, input_data[1].split())\n    events = [list(map(int, line.split())) for line in input_data[2:]]\n\n    # Initialize toys for each kid\n    kids = [[] for _ in range(n)]\n\n    # Sort events by time\n    events.sort(key=lambda x: x[0])\n\n    # Assign toys to kids based on events\n    for event in events:\n        if event[1] == 0:\n            continue\n        if event[2] != 0:\n            kids[event[1] - 1].append(event[2] - 1)\n\n    # Check if there is an assignment of toys to kids such that no kid will start crying today\n    toys = [0] * n\n    for i in range(n):\n        if not kids[i]:\n            continue\n        toy = kids[i][0]\n        for j in range(n):\n            if not kids[j]:\n                continue\n            if toy in kids[j]:\n                toy = kids[j][kids[j].index(toy) + 1]\n        toys[i] = toy\n\n    # Output result\n    if all(toys):\n        return ' '.join(map(str, toys))\n    else:\n        return \"impossible\""
    },
    {
        "number": 3155,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    n = 0\n    k = 0\n    while binomial_coefficient(n, k) < X:\n        n += 1\n    while k < n:\n        if binomial_coefficient(n, k) == X:\n            break\n        k += 1\n    return f\"{n} {k}\"\n\ndef"
    },
    {
        "number": 3156,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(store, visited, items, item_count, item_visited, item_stack, paths):\n        if item_count == len(items):\n            paths.append(item_stack[:])\n            return\n\n        for i in range(store, len(inventory)):\n            if visited[i]:\n                continue\n\n            for item in inventory[i]:\n                if not item_visited[item]:\n                    item_visited[item] = True\n                    item_stack.append(item)\n                    dfs(i + 1, visited, items, item_count + 1, item_visited, item_stack, paths)\n                    item_stack.pop()\n                    item_visited[item] = False\n\n    N, K = map(int, stdin.readline().split())\n    inventory = [[] for _ in range(N)]\n    for _ in range(K):\n        i, item = map(str, stdin.readline().split())\n        i = int(i)\n        inventory[i].append(item)\n\n    M = int(stdin.readline())\n    items = []\n    for _ in range(M):\n        items.append(stdin.readline().strip())\n\n    visited = [False] * N\n    item_visited = {item: False for item in items}\n    item_stack = []\n    paths = []\n    dfs(0, visited, items, 0, item_visited, item_stack, paths)\n\n    if not paths:\n        return \"impossible\"\n    elif len(paths) == 1:\n        return \"unique\"\n    else:\n        return \"ambiguous\"\n"
    },
    {
        "number": 3157,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split())\n    mod = 2**M\n    count = 0\n\n    def hash_function(word: str) -> int:\n        if not word:\n            return 0\n        hash_value = hash_function(word[:-1]) * 33\n        hash_value = hash_value ^ ord(word[-1])\n        hash_value = hash_value % mod\n        return hash_value\n\n    for word in itertools.product('abcdefghijklmnopqrstuvwxyz', repeat=N):\n        word = ''.join(word)\n        if hash_function(word) == K:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3158,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    images = stdin.split(\"\\n\")\n    initial_image = images[0].split(\" \")\n    final_image = images[1].split(\" \")\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def grip_point(touches):\n        return tuple(sum(p) / len(touches) for p in zip(*touches))\n\n    def touch_vector(touch, grip):\n        return tuple(p2 - p1 for p1, p2 in zip(grip, touch))\n\n    def touch_rotation(touch1, touch2):\n        v1, v2 = touch_vector(touch1, grip_point(initial_touches)), touch_vector(touch2, grip_point(initial_touches))\n        return math.atan2(v2[1], v2[0]) - math.atan2(v1[1], v1[0])\n\n    def grip_rotation(initial_touches, final_touches):\n        return sum(touch_rotation(initial_touches[i], final_touches[i]) for i in range(len(initial_touches))) / len(initial_touches)\n\n    def grip_spread(touches):\n        return sum(distance(grip_point(touches), touch) for touch in touches) / len(touches)\n\n    def pan():\n        for i in range(len(initial_image)):\n            if initial_image[i] != final_image[i]:\n                return False\n        return True\n\n    def zoom():\n        initial_spread = grip_spread(initial_touches)\n        final_spread = grip_spread(final_touches)\n        return final_spread < initial_spread\n\n    def rotate():\n        return abs(grip_rotation(initial_touches, final_touches)) > math.pi / 2\n\n    initial_touches = [tuple(map(int, line.strip().split(\"X\"))) for line in initial_image]\n    final_touches = [tuple(map(int, line.strip().split(\"X\"))) for line in final_image]\n\n    if pan():\n        return f\"{len(initial_touches)} pan\"\n    elif zoom():\n        return f\"{len(initial_touches)} zoom out\" if grip_spread(final_touches) < grip_spread(initial_touches) else f\"{len(initial_touches)} zoom in\"\n    elif rotate():\n        return f\"{len(initial_touches)} rotate clockwise\" if grip_rotation(initial_touches, final_touches) > 0 else f\"{len(initial_touches)} rotate counter-clockwise\"\n    else:\n        return f\"{len(initial_touches)} unknown\"\n"
    },
    {
        "number": 3159,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[0].split(','))\n    web_page = stdin.split('\\n')[1:]\n    web_page = [''.join(line.split()) for line in web_page]\n\n    def is_valid_image(image: str) -> bool:\n        if len(image) < 3 or len(image) % 2 == 0:\n            return False\n        for char in image:\n            if char not in ('$', '+', ' ', '?', '!', ',', '.', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'):\n                return False\n        return True\n\n    def find_smallest_ad(image: str) -> str:\n        smallest_ad = ''\n        for char in image:\n            if char not in ('$', '+', ' ', '?'):\n                continue\n            if char == ' ':\n                continue\n            if char == '?':\n                continue\n            if char == '+':\n                continue\n            if char == '$':\n                continue\n            if char == '!':\n                continue\n            if char == ',':\n                continue\n            if char == '.':\n                continue\n            if char == 'a':\n                continue\n            if char == 'b':\n                continue\n            if char == 'c':\n                continue\n            if char == 'd':\n                continue\n            if char == 'e':\n                continue\n            if char == 'f':\n                continue\n            if char == 'g':\n                continue\n            if char == 'h':\n                continue\n            if char == 'i':\n                continue\n            if char == 'j':\n                continue\n            if char == 'k':\n                continue\n            if char == 'l':\n                continue\n            if char == 'm':\n                continue\n            if char == 'n':\n                continue\n            if char == 'o':\n                continue\n            if char == 'p':\n                continue\n            if char == 'q':\n                continue\n            if char == 'r':\n                continue\n            if char == 's':\n                continue\n            if char == 't':\n                continue\n            if char == 'u':\n                continue\n            if char == 'v':\n                continue\n            if char == 'w':\n                continue\n            if char == 'x':\n                continue\n            if char == 'y':\n                continue\n            if char == 'z':\n                continue\n            if len(smallest_ad) == 0 or len(char) < len(smallest_ad):\n                smallest_ad = char\n        return smallest_ad\n\n    def remove_ad(image: str, smallest_ad: str) -> str:\n        return image.replace(smallest_ad, ' ')\n\n    def remove_border(image: str) -> str:\n        return image.replace('$', ' ').replace('+', ' ')\n\n    def is_adjacent_borders(image1: str, image2: str) -> bool:\n        for i in range(len(image1) - 1):\n            if image1[i] == '$' and image1[i + 1] == '+':\n                if image2[0] == '$' and image2[1] == '+':\n                    return True\n        return False\n\n    def is_valid_image_structure(image: str) -> bool:\n        if len(image) < 3 or len(image) % 2 == 0:\n            return False\n        for char in image:\n            if char not in ('$', '+', ' ', '?'):\n                return False\n        return True\n\n    def remove_ads(web_page: List[str]) -> List[str]:\n        images = []\n        for i in range(len(web_page)):\n            for j in range(len(web_page[i])):\n                if web_page[i][j] == '$':\n                    image = ''\n                    for k in range(i, len(web_page)):\n                        for l in range(j, len(web_page[k])):\n                            if web"
    },
    {
        "number": 3160,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_operations(config: str) -> int:\n        n = len(config)\n        k = 0\n        for i in range(n):\n            if config[i] == 'H':\n                k += 1\n            else:\n                break\n        return i + 1\n\n    def average_operations(config: str) -> float:\n        n = len(config)\n        total_operations = 0\n        for i in range(n):\n            if config[i] == 'H':\n                total_operations += count_operations(config[i:])\n        return total_operations / n\n\n    def process_unknown(config: str) -> str:\n        n = len(config)\n        for i in range(n):\n            if config[i] == '?':\n                config = config[:i] + 'T' + config[i + 1:]\n                break\n        return config\n\n    def average_unknown(config: str) -> float:\n        n = len(config)\n        total_operations = 0\n        for i in range(n):\n            if config[i] == '?':\n                total_operations += average_operations(config[i:])\n        return total_operations / n\n\n    stdin = stdin.replace('?', 'T')\n    stdin = process_unknown(stdin)\n    return average_unknown(stdin)\n"
    },
    {
        "number": 3161,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    target_picture = [[int(i) for i in input_list[j+1]] for j in range(N)]\n\n    def paint_picture(picture, depth):\n        if depth == 0:\n            return picture\n        else:\n            new_picture = [[0 for _ in range(N)] for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    if picture[i][j] == 1:\n                        new_picture[i][j] = 1\n                    else:\n                        new_picture[i][j] = 0\n            return new_picture\n\n    def count_differences(picture1, picture2):\n        count = 0\n        for i in range(N):\n            for j in range(N):\n                if picture1[i][j] != picture2[i][j]:\n                    count += 1\n        return count\n\n    def recursive_paint(picture, depth):\n        if depth == 0:\n            return picture\n        else:\n            new_picture = [[0 for _ in range(N)] for _ in range(N)]\n            for i in range(N):\n                for j in range(N):\n                    if picture[i][j] == 1:\n                        new_picture[i][j] = 1\n                    else:\n                        new_picture[i][j] = 0\n            return new_picture\n\n    min_difference = float('inf')\n    min_picture = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(N):\n        for j in range(N):\n            if target_picture[i][j] == 1:\n                new_picture = [[1 for _ in range(N)] for _ in range(N)]\n                new_picture[i][j] = 0\n                difference = count_differences(new_picture, target_picture)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_picture = new_picture\n            else:\n                new_picture = [[0 for _ in range(N)] for _ in range(N)]\n                new_picture[i][j] = 1\n                difference = count_differences(new_picture, target_picture)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_picture = new_picture\n\n    for i in range(N):\n        for j in range(N):\n            if target_picture[i][j] == 0:\n                new_picture = [[1 for _ in range(N)] for _ in range(N)]\n                new_picture[i][j] = 1\n                difference = count_differences(new_picture, target_picture)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_picture = new_picture\n            else:\n                new_picture = [[0 for _ in range(N)] for _ in range(N)]\n                new_picture[i][j] = 0\n                difference = count_differences(new_picture, target_picture)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_picture = new_picture\n\n    for i in range(N):\n        for j in range(N):\n            if target_picture[i][j] == 0:\n                new_picture = [[1 for _ in range(N)] for _ in range(N)]\n                new_picture[i][j] = 0\n                difference = count_differences(new_picture, target_picture)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_picture = new_picture\n            else:\n                new_picture = [[0 for _ in range(N)] for _ in range(N)]\n                new_picture[i][j] = 1\n                difference = count_differences(new_picture, target_picture)\n                if difference < min_difference:\n                    min_difference = difference\n                    min_picture = new_picture\n\n    for i in range(N):\n        for j in range(N"
    },
    {
        "number": 3162,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_pixel_activation_time(pulse, pixel_activation_times):\n        direction, start_time, length, wire_number = pulse\n        if direction == 'h':\n            wire_number += 1\n        else:\n            wire_number = wire_number\n        pixel_activation_times[wire_number] = start_time\n        return pixel_activation_times\n\n    def get_pixel_activation_times(pulses):\n        pixel_activation_times = [0] * (n + 1)\n        for pulse in pulses:\n            pixel_activation_times = get_pixel_activation_time(pulse, pixel_activation_times)\n        return pixel_activation_times\n\n    def get_activated_pixels(pixel_activation_times):\n        activated_pixels = 0\n        for time in range(1, n + 1):\n            if pixel_activation_times[1] <= time <= pixel_activation_times[n] and pixel_activation_times[n + 1] <= time <= pixel_activation_times[2 * n]:\n                activated_pixels += 1\n        return activated_pixels\n\n    n = int(stdin.split('\\n')[0])\n    pulses = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n    pixel_activation_times = get_pixel_activation_times(pulses)\n    activated_pixels = get_activated_pixels(pixel_activation_times)\n    return str(activated_pixels)"
    },
    {
        "number": 3163,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    initial_state = [list(map(int, input_data[i].split())) for i in range(1, N + 1)]\n    wanted_state = [list(map(int, input_data[i].split())) for i in range(N + 1, 2 * N + 1)]\n\n    def is_valid(shelf, book):\n        for i in range(M):\n            if shelf[i] == book:\n                return False\n        return True\n\n    def move_book(shelf, book, direction):\n        if direction == 'left':\n            for i in range(M - 1, -1, -1):\n                if shelf[i] == 0:\n                    shelf[i] = book\n                    return True\n        else:\n            for i in range(M):\n                if shelf[i] == 0:\n                    shelf[i] = book\n                    return True\n        return False\n\n    def find_book(shelf, book):\n        for i in range(M):\n            if shelf[i] == book:\n                return i\n        return -1\n\n    def find_empty_place(shelf):\n        for i in range(M):\n            if shelf[i] == 0:\n                return i\n        return -1\n\n    def find_book_to_move(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i]:\n                return shelf[i]\n        return -1\n\n    def find_book_to_place(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] == 0 and wanted_state[i] != 0:\n                return wanted_state[i]\n        return -1\n\n    def find_book_to_place_on_shelf(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] == 0 and wanted_state[i] != 0:\n                return wanted_state[i]\n        return -1\n\n    def find_book_to_move_to_place(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i]:\n                return shelf[i]\n        return -1\n\n    def find_book_to_move_to_place_on_shelf(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i]:\n                return shelf[i]\n        return -1\n\n    def find_book_to_move_to_empty_place(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i]:\n                return shelf[i]\n        return -1\n\n    def find_book_to_move_to_empty_place_on_shelf(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i]:\n                return shelf[i]\n        return -1\n\n    def find_book_to_move_to_empty_place_on_shelf_or_move_book(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i]:\n                return shelf[i]\n        for i in range(M):\n            if shelf[i] == 0 and wanted_state[i] != 0:\n                return wanted_state[i]\n        return -1\n\n    def find_book_to_move_to_empty_place_on_shelf_or_move_book_on_shelf(shelf, wanted_state):\n        for i in range(M):\n            if shelf[i] != 0 and shelf[i] != wanted_state[i"
    },
    {
        "number": 3164,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def longest_subarray(arr: list) -> int:\n        from collections import Counter\n        c = Counter(arr)\n        freq = [c[i] for i in range(1, len(c) + 1)]\n        freq = [0] + freq\n        for i in range(1, len(freq)):\n            freq[i] += freq[i - 1]\n        max_len = 0\n        for i in range(1, len(freq)):\n            if freq[i] % 2 == 0:\n                max_len = max(max_len, freq[i] // 2)\n        return max_len\n\n    N = int(stdin.split(\"\\n\")[0])\n    arr = list(map(int, stdin.split(\"\\n\")[1].split()))\n    return longest_subarray(arr)\n"
    },
    {
        "number": 3165,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, P = map(int, stdin.split()[:3])\n    rooks = [tuple(map(int, stdin.split()[3+i*3:3+i*3+3])) for i in range(K)]\n    board = [[0]*N for _ in range(N)]\n    for r, c, x in rooks:\n        board[r-1][c-1] = x\n\n    def is_attacked(r, c):\n        return bin(sum(board[r][i] ^ board[i][c] for i in range(N)))[2:].count('1') > 0\n\n    def count_attacked_fields(board):\n        return sum(is_attacked(r, c) for r in range(N) for c in range(N))\n\n    for _ in range(P):\n        r1, c1, r2, c2 = map(int, stdin.split()[3+K*3:])\n        board[r2-1][c2-1] = board[r1-1][c1-1]\n        board[r1-1][c1-1] = 0\n        print(count_attacked_fields(board))"
    },
    {
        "number": 3166,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    beat_matrix = [[0] * n for _ in range(n)]\n    for i in range(1, n + 1):\n        beat_matrix[i - 1] = list(map(int, input_list[i].split()))\n    disqualified_players = list(map(int, input_list[-1].split()))\n\n    def is_fair_ranking(players: List[int]) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if players[i] < players[j] and not beat_matrix[players[i]][players[j]]:\n                    return False\n        return True\n\n    def find_smallest_disqualified_players(players: List[int]) -> int:\n        for i in range(n):\n            if i not in players:\n                players.append(i)\n                if is_fair_ranking(players):\n                    return len(players)\n                players.pop()\n        return -1\n\n    smallest_disqualified_players = find_smallest_disqualified_players([])\n    if smallest_disqualified_players == -1:\n        return \"impossible\"\n    else:\n        return smallest_disqualified_players"
    },
    {
        "number": 3167,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    X = list(map(int, stdin.split()[2:2+K]))\n    Q = int(stdin.split()[2+K])\n    L_R = [list(map(int, stdin.split()[3+i:3+i+2])) for i in range(Q)]\n\n    seq = [0] * N\n    for x in X:\n        something(x)\n\n    result = []\n    for l, r in L_R:\n        result.append(sum(seq[l:r+1]))\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3168,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def insert(node, value):\n        if node is None:\n            return TreeNode(value)\n        if value < node.val:\n            node.left = insert(node.left, value)\n        else:\n            node.right = insert(node.right, value)\n        return node\n\n    def depth(node):\n        if node is None:\n            return 0\n        return max(depth(node.left), depth(node.right)) + 1\n\n    def build_tree(sequence):\n        root = TreeNode(sequence[0])\n        for value in sequence[1:]:\n            root = insert(root, value)\n        return root\n\n    def print_depth(node):\n        if node is None:\n            return 0\n        left_depth = print_depth(node.left)\n        right_depth = print_depth(node.right)\n        return max(left_depth, right_depth) + 1\n\n    def count_depth(node):\n        if node is None:\n            return 0\n        return print_depth(node)\n\n    N = int(stdin.readline())\n    sequence = [int(x) for x in stdin.readlines()]\n    root = build_tree(sequence)\n    counter = 0\n    for value in sequence:\n        root = insert(root, value)\n        counter += depth(root)\n        print(counter)\n\n    return '\\n'.join(str(counter) for counter in range(N))\n"
    },
    {
        "number": 3169,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    sticks = [tuple(map(int, input_data[i+1].split())) for i in range(N)]\n\n    def shortest_path(x1, y1, x2, y2):\n        dx = abs(x2 - x1)\n        dy = abs(y2 - y1)\n        if dx == 0:\n            return (x1, y1, x2, y2)\n        elif dy == 0:\n            return (x2, y2, x1, y1)\n        elif dx == dy:\n            return (x1, y1, x2, y2)\n        elif dx > dy:\n            return (x1, y1, x2, y2)\n        else:\n            return (x2, y2, x1, y1)\n\n    def is_valid(x1, y1, x2, y2):\n        for i in range(N):\n            x3, y3, x4, y4 = shortest_path(x1, y1, x2, y2)\n            if (x3, y3, x4, y4) == sticks[i]:\n                return False\n        return True\n\n    def dfs(visited, order, x1, y1, x2, y2):\n        if len(order) == N:\n            return order\n        for i in range(N):\n            if i not in visited and is_valid(x1, y1, sticks[i][0], sticks[i][1]):\n                visited.add(i)\n                order.append(i)\n                dfs(visited, order, sticks[i][0], sticks[i][1], x2, y2)\n                visited.remove(i)\n                order.pop()\n        return order\n\n    order = dfs(set(), [], 0, 0, 10000, 10000)\n    return ' '.join(map(str, order))"
    },
    {
        "number": 3170,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    deck = list(stdin)\n    deck.reverse()\n    theta_cards = deck[:20]\n    friend_cards = deck[20:]\n    theta_slots = [None] * 10\n    friend_slots = [None] * 10\n    theta_discard = []\n    friend_discard = []\n\n    def fill_slot(player, slot, card):\n        if player == \"Theta\":\n            theta_slots[slot] = card\n        else:\n            friend_slots[slot] = card\n\n    def can_fill_slot(player, slot, card):\n        if player == \"Theta\":\n            if theta_slots[slot] is None:\n                return True\n            elif theta_slots[slot] == card:\n                return False\n            else:\n                return True\n        else:\n            if friend_slots[slot] is None:\n                return True\n            elif friend_slots[slot] == card:\n                return False\n            else:\n                return True\n\n    def can_use_jack(player, card):\n        if player == \"Theta\":\n            return any(slot is None for slot, c in enumerate(theta_slots) if c == card)\n        else:\n            return any(slot is None for slot, c in enumerate(friend_slots) if c == card)\n\n    def discard_card(player, card):\n        if player == \"Theta\":\n            theta_discard.append(card)\n        else:\n            friend_discard.append(card)\n\n    def is_winning_move(player, card):\n        if player == \"Theta\":\n            return any(slot is None for slot, c in enumerate(theta_slots) if c is None)\n        else:\n            return any(slot is None for slot, c in enumerate(friend_slots) if c is None)\n\n    def play_turn(player):\n        if player == \"Theta\":\n            card = theta_cards.pop()\n        else:\n            card = friend_cards.pop()\n\n        if card in \"AJQK\":\n            if can_use_jack(player, card):\n                for slot, c in enumerate(theta_slots):\n                    if c is None:\n                        fill_slot(player, slot, card)\n                        return\n                for slot, c in enumerate(friend_slots):\n                    if c is None:\n                        fill_slot(player, slot, card)\n                        return\n            discard_card(player, card)\n        else:\n            for slot, c in enumerate(theta_slots):\n                if c is None and can_fill_slot(player, slot, card):\n                    fill_slot(player, slot, card)\n                    return\n            for slot, c in enumerate(friend_slots):\n                if c is None and can_fill_slot(player, slot, card):\n                    fill_slot(player, slot, card)\n                    return\n            discard_card(player, card)\n\n    while len(theta_cards) + len(friend_cards) > 0:\n        play_turn(\"Theta\")\n        if is_winning_move(\"Theta\", None):\n            return \"Theta wins\"\n        play_turn(\"Friend\")\n        if is_winning_move(\"Friend\", None):\n            return \"Friend wins\"\n\n    return \"Theta wins\""
    },
    {
        "number": 3171,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    candidates = [None] * N\n    for i in range(K):\n        speaker, uttered = stdin.split()[i * 2 + 1:i * 2 + 3]\n        speaker = int(speaker)\n        if uttered.startswith(\"truther\"):\n            candidates[int(uttered.split()[1]) - 1] = \"truther\"\n        elif uttered.startswith(\"fabulist\"):\n            candidates[int(uttered.split()[1]) - 1] = \"fabulist\"\n        elif uttered.startswith(\"charlatan\"):\n            candidates[int(uttered.split()[1]) - 1] = \"charlatan\"\n        else:\n            raise ValueError(\"Invalid uttered statement\")\n    return \"\\n\".join(candidates)"
    },
    {
        "number": 3172,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    fruits = []\n    for i in range(1, n+1):\n        x, y = map(float, input_list[i].split())\n        fruits.append((x, y))\n\n    def is_point_inside(point, circle):\n        x, y = point\n        cx, cy, r = circle\n        return (x - cx)**2 + (y - cy)**2 <= r**2\n\n    def is_line_inside(line, circle):\n        x1, y1, x2, y2 = line\n        cx, cy, r = circle\n        p1 = (x1, y1)\n        p2 = (x2, y2)\n        p3 = (cx, cy)\n        p1p2 = (x2 - x1, y2 - y1)\n        p1p3 = (cx - x1, cy - y1)\n        p2p3 = (cx - x2, cy - y2)\n        dot1 = p1p2[0]*p1p3[0] + p1p2[1]*p1p3[1]\n        dot2 = p1p2[0]*p2p3[0] + p1p2[1]*p2p3[1]\n        len1 = (p1p2[0]**2 + p1p2[1]**2)**0.5\n        len2 = (p2p3[0]**2 + p2p3[1]**2)**0.5\n        if dot1 <= 0 and dot2 <= 0:\n            return False\n        if dot1 >= len1**2 and dot2 >= len2**2:\n            return True\n        return False\n\n    def count_fruits(fruits, line):\n        count = 0\n        for fruit in fruits:\n            if is_line_inside(line, (fruit[0], fruit[1], 1)):\n                count += 1\n        return count\n\n    max_count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            x1, y1 = fruits[i]\n            x2, y2 = fruits[j]\n            line = (x1, y1, x2, y2)\n            count = count_fruits(fruits, line)\n            max_count = max(max_count, count)\n\n    return str(max_count)"
    },
    {
        "number": 3173,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split()[:3])\n    grid = [list(stdin.split()[3+i*C:(3+i*C)+C]) for i in range(R)]\n    scores = list(map(int, stdin.split()[-C:]))\n\n    def is_valid(x, y):\n        if x < 0 or x >= R or y < 0 or y >= C:\n            return False\n        if grid[x][y] == 'X':\n            return False\n        return True\n\n    def move_ball(x, y, direction):\n        if direction == 'R':\n            return x+1, y\n        elif direction == 'L':\n            return x-1, y\n        else:\n            return x, y\n\n    def set_conveyor(x, y, direction):\n        if direction == 'R':\n            grid[x][y] = 'R'\n        elif direction == 'L':\n            grid[x][y] = 'L'\n\n    def get_score(x, y):\n        return scores[y]\n\n    def dfs(x, y, direction, visited):\n        if (x, y) in visited:\n            return 0\n        visited.add((x, y))\n        if not is_valid(x, y):\n            return 0\n        if x == R-1:\n            return get_score(x, y)\n        max_score = 0\n        for d in ['R', 'L', '?']:\n            nx, ny = move_ball(x, y, d)\n            if d == '?':\n                set_conveyor(x, y, d)\n            max_score = max(max_score, dfs(nx, ny, direction, visited))\n            if d == '?':\n                set_conveyor(x, y, ' ')\n        return max_score\n\n    max_score = 0\n    for i in range(C):\n        max_score = max(max_score, dfs(0, i, 'R', set()))\n\n    return str(max_score)"
    },
    {
        "number": 3174,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_divisible(cities, k):\n        total = sum(cities)\n        return total % k == 0\n\n    def is_connected(cities, k, d):\n        for i in range(len(cities)):\n            for j in range(i + 1, len(cities)):\n                if distance(cities[i], cities[j]) <= d:\n                    return True\n        return False\n\n    def min_d(cities, k):\n        d = 0\n        while not is_connected(cities, k, d):\n            d += 0.001\n        return d\n\n    N, K = map(int, stdin.split()[:2])\n    cities = [tuple(map(int, stdin.split()[i].split(','))) for i in range(2, 2 + N * 3, 3)]\n    cities = [(x, y, k) for x, y, k in cities if k > 0]\n\n    if not is_divisible(cities, K):\n        return \"0.000\"\n\n    d = min_d(cities, K)\n    return f\"{d:.3f}\"\n"
    },
    {
        "number": 3175,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    fence_lengths = list(map(int, input_list[1:]))\n\n    def is_valid_polygon(polygon):\n        for i in range(len(polygon)):\n            if polygon[i] == 0:\n                return False\n        return True\n\n    def polygon_area(polygon):\n        area = 0\n        for i in range(len(polygon)):\n            area += polygon[i] * polygon[(i + 1) % len(polygon)]\n        return abs(area) / 2\n\n    def max_area_polygon(fence_lengths):\n        max_area = 0\n        for i in range(len(fence_lengths)):\n            for j in range(i + 2, len(fence_lengths) + 1):\n                polygon = fence_lengths[i:j]\n                if is_valid_polygon(polygon):\n                    area = polygon_area(polygon)\n                    if area > max_area:\n                        max_area = area\n        return max_area\n\n    max_area = max_area_polygon(fence_lengths)\n    return f\"{max_area:.3f}\""
    },
    {
        "number": 3176,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    plants = [list(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    dp = [[0] * (N+1) for _ in range(N+1)]\n    for i in range(N+1):\n        for j in range(N+1):\n            if i == 0 and j == 0:\n                dp[i][j] = 0\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + plants[j-1][2]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + plants[i-1][2]\n            else:\n                if i == 1 and j == 1:\n                    dp[i][j] = dp[i-1][j] + plants[i-1][2]\n                elif i == 1:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + plants[j-1][2]\n                elif j == 1:\n                    dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + plants[i-1][2]\n                else:\n                    if i == j:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + plants[i-1][2]\n                    else:\n                        dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + plants[j-1][2]\n    energy = dp[N][N]\n    path = []\n    i, j = N, N\n    while i > 0 and j > 0:\n        if i == 1 and j == 1:\n            path.append((i, j))\n            break\n        if i == 1:\n            path.append((i, j))\n            j -= 1\n        elif j == 1:\n            path.append((i, j))\n            i -= 1\n        else:\n            if dp[i-1][j] == dp[i][j]:\n                path.append((i, j))\n                i -= 1\n            else:\n                path.append((i, j))\n                j -= 1\n    path.reverse()\n    return f\"{energy}\\n{len(path)}\\n\" + \"\\n\".join(f\"{p[0]} {p[1]}\" for p in path) "
    },
    {
        "number": 3177,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    initial_sequence = list(map(int, stdin.split()[2:2+N]))\n    allowed_swaps = [tuple(map(int, stdin.split()[2+N+i:2+N+i+2])) for i in range(M)]\n\n    # Create a graph of allowed swaps\n    graph = {i: [] for i in range(1, N+1)}\n    for a, b in allowed_swaps:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Perform a depth-first search to find the minimum number of swaps\n    visited = [False] * (N+1)\n    stack = [(1, 1)]\n    swaps = 0\n\n    while stack:\n        node, depth = stack.pop()\n        if visited[node]:\n            continue\n        visited[node] = True\n\n        # If the node is not the first element of the sequence, swap it with the first element\n        if node != 1:\n            swaps += 1\n            initial_sequence[node-1], initial_sequence[0] = initial_sequence[0], initial_sequence[node-1]\n\n        # Perform the allowed swaps\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append((neighbor, depth+1))\n\n    return swaps"
    },
    {
        "number": 3178,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(start, visited, cost, adj_list, mod):\n        visited[start] = True\n        for neighbor in adj_list[start]:\n            if not visited[neighbor]:\n                if (cost[start] + cost[neighbor]) % mod == 1:\n                    return False\n                if not dfs(neighbor, visited, cost, adj_list, mod):\n                    return False\n        return True\n\n    def check_cycle(start, visited, cost, adj_list, mod):\n        visited[start] = True\n        for neighbor in adj_list[start]:\n            if not visited[neighbor]:\n                if not check_cycle(neighbor, visited, cost, adj_list, mod):\n                    return False\n            elif not (cost[start] + cost[neighbor]) % mod:\n                return False\n        return True\n\n    def min_cost(start, visited, cost, adj_list, mod):\n        visited[start] = True\n        min_cost = 0\n        for neighbor in adj_list[start]:\n            if not visited[neighbor]:\n                min_cost = max(min_cost, min_cost(neighbor, visited, cost, adj_list, mod))\n        return min_cost + cost[start]\n\n    n, m = map(int, stdin.split()[0:2])\n    adj_list = [[] for _ in range(n)]\n    cost = [0] * n\n    for _ in range(m):\n        a, b = map(int, stdin.split()[0:2])\n        adj_list[a - 1].append(b - 1)\n        adj_list[b - 1].append(a - 1)\n\n    for i in range(n):\n        for j in range(n):\n            if i != j and (i, j) not in [(j, i) for (j, i) in adj_list]:\n                visited = [False] * n\n                if not dfs(i, visited, cost, adj_list, 3):\n                    return -1\n                if not check_cycle(i, visited, cost, adj_list, 3):\n                    return -1\n\n    return min_cost(0, [False] * n, cost, adj_list, 3)\n"
    },
    {
        "number": 3179,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(p, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(n + 1):\n            p2x, p2y = polygon[i % n]\n            if p1y > p[1]:\n                inside = not inside\n            intersect = (p1y == p[1]) or (p1y > p[1] and p2y <= p[1])\n            if intersect and distance(p, (p1x, p[1])) < distance(p, (p2x, p[1])):\n                inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def min_side_length(polygon, k):\n        n = len(polygon)\n        min_side = float('inf')\n        for i in range(n):\n            for j in range(i + 1, n):\n                for l in range(j + 1, n):\n                    if is_inside(polygon[i], polygon[j:l + 1]) and is_inside(polygon[j], polygon[i:l + 1]) and is_inside(polygon[l], polygon[i:j + 1]):\n                        side = distance(polygon[i], polygon[j])\n                        if side < min_side:\n                            min_side = side\n                            if k == 1:\n                                return min_side\n        return min_side\n\n    stdin = stdin.splitlines()\n    n, k = map(int, stdin[0].split())\n    polygon = [tuple(map(int, line.split())) for line in stdin[1:]]\n    min_side = min_side_length(polygon, k)\n    return f\"{min_side:.2f}\""
    },
    {
        "number": 3180,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    commands = stdin.split('\\n')[1:]\n    canvas = [[1] * N for _ in range(N)]\n\n    def paint_rectangle(x1, y1, x2, y2, color):\n        for i in range(x1, x2 + 1):\n            for j in range(y1, y2 + 1):\n                canvas[i][j] = color\n\n    for command in commands:\n        if command.startswith('PAINT'):\n            color, x1, y1, x2, y2 = map(int, command.split()[1:])\n            paint_rectangle(x1, y1, x2, y2, color)\n        elif command.startswith('SAVE'):\n            pass\n        elif command.startswith('LOAD'):\n            pass\n\n    for row in canvas:\n        print(*row)\n"
    },
    {
        "number": 3181,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K > N:\n        return \"-1\"\n    if K == 1:\n        return \" \".join(map(str, range(1, N+1)))\n    if K == N:\n        return \" \".join(map(str, range(N, 0, -1)))\n    if K == 2:\n        return \"1 2\"\n    if K == N-1:\n        return \" \".join(map(str, range(2, N+1)))\n    if K == N-2:\n        return \"1 \" + \" \".join(map(str, range(3, N+1)))\n    if K == 3:\n        return \"1 2 3\"\n    if K == N-3:\n        return \" \".join(map(str, range(N-1, 1, -1))) + \" \" + str(N)\n    if K == 4:\n        return \"1 2 3 4\"\n    if K == N-4:\n        return \" \".join(map(str, range(N-3, 1, -1))) + \" \" + str(N-2) + \" \" + str(N-1) + \" \" + str(N)\n    if K == 5:\n        return \"1 2 3 4 5\"\n    if K == N-5:\n        return \" \".join(map(str, range(N-4, 1, -1))) + \" \" + str(N-3) + \" \" + str(N-2) + \" \" + str(N-1) + \" \" + str(N)\n    if K == 6:\n        return \"1 2 3 4 5 6\"\n    if K == N-6:\n        return \" \".join(map(str, range(N-5, 1, -1))) + \" \" + str(N-4) + \" \" + str(N-3) + \" \" + str(N-2) + \" \" + str(N-1) + \" \" + str(N)\n    if K == 7:\n        return \"1 2 3 4 5 6 7\"\n    if K == N-7:\n        return \" \".join(map(str, range(N-6, 1, -1))) + \" \" + str(N-5) + \" \" + str(N-4) + \" \" + str(N-3) + \" \" + str(N-2) + \" \" + str(N-1) + \" \" + str(N)\n    if K == 8:\n        return \"1 2 3 4 5 6 7 8\"\n    if K == N-8:\n        return \" \".join(map(str, range(N-7, 1, -1))) + \" \" + str(N-6) + \" \" + str(N-5) + \" \" + str(N-4) + \" \" + str(N-3) + \" \" + str(N-2) + \" \" + str(N-1) + \" \" + str(N)\n    if K == 9:\n        return \"1 2 3 4 5 6 7 8 9\"\n    if K == N-9:\n        return \" \".join(map(str, range(N-8, 1, -1))) + \" \" + str(N-7) + \" \" + str(N-6) + \" \" + str(N-5) + \" \" + str(N-4) + \" \" + str(N-3) + \" \" + str(N-2) + \" \" + str(N-1) + \" \" + str(N)\n    if K == 10:\n        return \"1 2 3 4 5 6 7 8 9 10\"\n    if K == N-10:\n        return \" \".join(map(str, range(N-9, 1, -1))) + \" \" + str(N-8) + \" \" + str(N-7) + \" \" + str(N-6) + \" \" + str(N-5) + \" \" + str(N-4) + \" \" + str(N-3) + \" \" + str(N-2) + \" \" + str(N-1)"
    },
    {
        "number": 3182,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_right_triangle(a, b, c):\n        return a**2 + b**2 == c**2 or a**2 + c**2 == b**2 or b**2 + c**2 == a**2\n\n    N = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                a, b, c = points[i], points[j], points[k]\n                if is_right_triangle(a[0] - b[0], a[1] - b[1], c[0] - b[0]) or is_right_triangle(a[0] - c[0], a[1] - c[1], b[0] - c[0]) or is_right_triangle(b[0] - c[0], b[1] - c[1], a[0] - c[0]):\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3183,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from heapq import heappush, heappop\n\n    def dijkstra(graph, source, sink, n):\n        dist = [float('inf')] * n\n        dist[source] = 0\n        visited = [False] * n\n        pq = [(0, source)]\n\n        while pq:\n            (cost, u) = heappop(pq)\n            if visited[u]:\n                continue\n            visited[u] = True\n            if u == sink:\n                return cost\n            for v, c in graph[u]:\n                new_cost = cost + c\n                if new_cost < dist[v] and not visited[v]:\n                    dist[v] = new_cost\n                    heappush(pq, (new_cost, v))\n\n        return -1\n\n    def max_flow(graph, source, sink, n):\n        flow = 0\n        residual = defaultdict(list)\n        for u in range(n):\n            for v, c, w in graph[u]:\n                if c > 0:\n                    residual[u].append((v, c, w))\n                    residual[v].append((u, 0, -w))\n\n        while True:\n            bottleneck = dijkstra(residual, source, sink, n)\n            if bottleneck == -1:\n                break\n            flow += bottleneck\n            for u in range(n):\n                for v, c, w in graph[u]:\n                    if c > 0:\n                        residual[u][residual[u].index((v, c, w))][1] = max(0, residual[u][residual[u].index((v, c, w))][1] - bottleneck)\n                        residual[v][residual[v].index((u, 0, -w))][1] = min(c, residual[v][residual[v].index((u, 0, -w))][1] + bottleneck)\n\n        return flow\n\n    def min_cost_flow(graph, source, sink, n):\n        cost = 0\n        flow = max_flow(graph, source, sink, n)\n        for u in range(n):\n            for v, c, w in graph[u]:\n                if c > 0:\n                    cost += flow * w\n        return cost\n\n    lines = stdin.split('\\n')\n    n, m, s, t = map(int, lines[0].split())\n    graph = [[] for _ in range(n)]\n    for i in range(1, m + 1):\n        u, v, c, w = map(int, lines[i].split())\n        graph[u].append((v, c, w))\n\n    flow = max_flow(graph, s, t, n)\n    cost = min_cost_flow(graph, s, t, n)\n\n    return f\"{flow} {cost}\"\n"
    },
    {
        "number": 3184,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, k = map(int, input_data[0].split())\n    walls = [set() for _ in range(n)]\n    for i in range(1, k+1):\n        a, b = map(int, input_data[i].split())\n        for j in range(a, b+1):\n            walls[j-1].add(i-1)\n\n    covered_walls = [set() for _ in range(n)]\n    for i in range(k):\n        for j in walls[i]:\n            covered_walls[j].add(i)\n\n    min_cameras = 0\n    for i in range(n):\n        if len(covered_walls[i]) == 0:\n            return \"impossible\"\n        min_cameras += len(covered_walls[i])\n\n    return str(min_cameras)\n"
    },
    {
        "number": 3185,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = 1\n    for digit in stdin:\n        n *= int(digit)\n    return str(n)"
    },
    {
        "number": 3186,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    mod = 10**6 + 7\n    dp = [1] * (K + 1)\n    for i in range(1, M + 1):\n        for j in range(1, K + 1):\n            if j >= i:\n                dp[j] = (dp[j] + dp[j - i]) % mod\n    return dp[K]\n"
    },
    {
        "number": 3187,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_valid_intersection(x, y, d):\n        for i in range(n):\n            if distance(x, y, houses[i][0], houses[i][1]) > d:\n                return False\n        return True\n\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    houses = [(int(x), int(y)) for x, y in [line.split() for line in input_data[1:n+1]]]\n    d = int(input_data[n+1])\n\n    min_distance = float('inf')\n    for x in range(1, 100001):\n        for y in range(1, 100001):\n            if is_valid_intersection(x, y, d):\n                total_distance = sum(distance(x, y, house[0], house[1]) for house in houses)\n                min_distance = min(min_distance, total_distance)\n\n    return \"impossible\" if min_distance == float('inf') else min_distance"
    },
    {
        "number": 3188,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return min(abs(a[0] - b[0]), abs(a[1] - b[1]), abs(a[2] - b[2]))\n\n    N = int(stdin)\n    planets = []\n    for _ in range(N):\n        x, y, z = map(int, stdin.readline().split())\n        planets.append((x, y, z))\n\n    total_cost = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            total_cost += distance(planets[i], planets[j])\n\n    return str(total_cost)\n"
    },
    {
        "number": 3189,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    photos = input_list[1:]\n\n    def count_wirings(photos):\n        def count_switches(photo):\n            return photo.count('1')\n\n        def count_lights(photo):\n            return photo.count('0')\n\n        def is_consistent(photo1, photo2):\n            return photo1.count('1') == photo2.count('0')\n\n        switch_counts = [count_switches(photo) for photo in photos]\n        light_counts = [count_lights(photo) for photo in photos]\n\n        switch_count_set = set(switch_counts)\n        light_count_set = set(light_counts)\n\n        if len(switch_count_set) != len(light_count_set):\n            return 0\n\n        for i in range(len(photos) - 1):\n            for j in range(i + 1, len(photos)):\n                if not is_consistent(photos[i], photos[j]):\n                    return 0\n\n        return len(switch_count_set)\n\n    result = count_wirings(photos)\n    return str(result % 1000003)"
    },
    {
        "number": 3190,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, a, P = input().split()\n    N = int(N)\n    a = list(map(int, a.split()))\n    P = int(P)\n\n    count = 0\n    for i in range(N - 1):\n        if sum(a[i:i+2]) / 2 >= P:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3191,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, p = map(int, stdin.split())\n    if n == 1:\n        return str(r)\n    else:\n        return str(r + (n - 1) * p)\n\ndef"
    },
    {
        "number": 3192,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph: dict, start: str) -> list:\n        visited = set()\n        stack = [start]\n        while stack:\n            node = stack[-1]\n            if node in visited:\n                stack.pop()\n                continue\n            visited.add(node)\n            stack.append(node)\n            for neighbor in graph[node]:\n                if neighbor in visited:\n                    cycle = []\n                    for node in stack:\n                        cycle.append(node)\n                    return cycle\n                stack.append(neighbor)\n                break\n        return []\n\n    def find_shortest_cycle(graph: dict) -> list:\n        cycles = []\n        for node in graph:\n            cycle = find_cycle(graph, node)\n            if cycle:\n                cycles.append(cycle)\n        if not cycles:\n            return []\n        min_cycle = min(cycles, key=len)\n        return min_cycle\n\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.split('\\n')\n        num_files = int(lines[0])\n        file_names = lines[1].split()\n        graph = {}\n        for i in range(2, len(lines), 2):\n            file_name = lines[i].split()[0]\n            graph[file_name] = []\n            for j in range(i + 1, i + 1 + int(lines[i + 1])):\n                import_file = lines[j].split()[1]\n                graph[file_name].append(import_file)\n        return num_files, file_names, graph\n\n    num_files, file_names, graph = parse_input(stdin)\n    if not find_shortest_cycle(graph):\n        return \"SHIP IT\"\n    cycle = find_shortest_cycle(graph)\n    return ' '.join(cycle)\n"
    },
    {
        "number": 3193,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, P, M = stdin.split('\\n')\n    P, M = int(P), int(M)\n    A = A.replace('(',' ( ').replace(')', ' ) ').split()\n    x = 0\n    while True:\n        if A[0] == 'x':\n            x += 1\n            A.pop(0)\n        elif A[0] == '+':\n            A.pop(0)\n        else:\n            break\n    while A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0)\n    if A[-1] == ')':\n        A.pop()\n    if A[0] == 'x':\n        x += 1\n        A.pop(0)\n    if A[-1] == 'x':\n        x += 1\n        A.pop()\n    if A[0] == '+':\n        A.pop(0)\n    if A[-1] == '+':\n        A.pop()\n    if A[0] == '(':\n        A.pop(0"
    },
    {
        "number": 3194,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, t = map(int, input_list[0].split())\n    time_list = [list(map(int, input_list[i+1].split())) for i in range(n)]\n    \n    for i in range(n):\n        if time_list[i][0] + t > time_list[i][1]:\n            return \"no\"\n    return \"yes\""
    },
    {
        "number": 3195,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    T_g, T_y, T_r = map(int, input_list[0].split())\n    n = int(input_list[1])\n    observations = [(int(t), c) for t, c in [line.split() for line in input_list[2:n+2]]]\n    t_q, c_q = map(int, input_list[n+2].split())\n\n    # Calculate the probability of the lights being green at time t_q\n    if c_q == 'green':\n        probability = 1\n        for t, c in observations:\n            if t <= t_q:\n                if c == 'green':\n                    probability *= 1\n                elif c == 'yellow':\n                    probability *= (t_q - t) / T_y\n                elif c == 'red':\n                    probability *= (t_q - t) / T_r\n            else:\n                break\n    # Calculate the probability of the lights being yellow at time t_q\n    elif c_q == 'yellow':\n        probability = 0\n        for t, c in observations:\n            if t <= t_q:\n                if c == 'green':\n                    probability *= (t_q - t) / T_g\n                elif c == 'yellow':\n                    probability *= 1\n                elif c == 'red':\n                    probability *= (t_q - t) / T_r\n            else:\n                break\n    # Calculate the probability of the lights being red at time t_q\n    elif c_q == 'red':\n        probability = 0\n        for t, c in observations:\n            if t <= t_q:\n                if c == 'green':\n                    probability *= (t_q - t) / T_g\n                elif c == 'yellow':\n                    probability *= (t_q - t) / T_y\n                elif c == 'red':\n                    probability *= 1\n            else:\n                break\n\n    return f\"{probability:.6f}\""
    },
    {
        "number": 3196,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:] if line]\n    graph = {i: [] for i in range(1, N+1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n    def dfs(node, visited, path):\n        visited.add(node)\n        path.append(node)\n        if node == 2:\n            return [path]\n        paths = []\n        for neighbor in graph[node]:\n            if neighbor not in visited:\n                paths.extend(dfs(neighbor, visited.copy(), path.copy()))\n        return paths\n    routes = dfs(1, set(), [1])\n    if len(routes) == float('inf'):\n        return \"inf\"\n    else:\n        return str(len(routes))[-9:]\n"
    },
    {
        "number": 3197,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    preferences = list(map(int, input_list[1].split()))\n\n    # Create a dictionary to store the preferences of each participant\n    preferences_dict = {}\n    for i in range(n):\n        preferences_dict[i + 1] = preferences[i]\n\n    # Sort the participants based on their preferences\n    sorted_participants = sorted(preferences_dict.keys(), key=lambda x: preferences_dict[x])\n\n    # Initialize the count of participants that can join\n    count = 0\n\n    # Iterate through the sorted participants and add them to the bus\n    for participant in sorted_participants:\n        # Check if the bus has enough capacity\n        if count < k:\n            # Add the participant to the bus\n            count += 1\n\n    return count"
    },
    {
        "number": 3198,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    dictionary = set(stdin.splitlines()[1:])\n    typos = []\n\n    for word in dictionary:\n        for i in range(len(word)):\n            if word[:i] + word[i+1:] in dictionary:\n                typos.append(word)\n                break\n\n    if typos:\n        return '\\n'.join(typos)\n    else:\n        return \"NO TYPOS\""
    },
    {
        "number": 3199,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B, L = map(int, stdin.split())\n    insecure = secure = super_secure = 0\n    for x in range(1, L+1):\n        for y in range(-A, B+1):\n            if (x, y) == (0, -A) or (x, y) == (0, B):\n                continue\n            if (x, y) == (1, -A) or (x, y) == (L, B):\n                super_secure += 1\n            elif (x-1, y) == (0, -A) or (x+1, y) == (0, B):\n                secure += 1\n            else:\n                insecure += 1\n    return f\"{insecure}\\n{secure}\\n{super_secure}\"\n"
    },
    {
        "number": 3200,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_input(input_str: str) -> List[Tuple[int, int, int]]:\n        lines = input_str.split('\\n')\n        result = []\n        for line in lines:\n            t, g, r = map(int, line.split())\n            result.append((t, g, r))\n        return result\n\n    def calculate_time(lights: List[Tuple[int, int, int]]) -> float:\n        time = 0\n        for light in lights:\n            t, g, r = light\n            time += t\n            time += g\n        return time\n\n    def calculate_min_time(lights: List[Tuple[int, int, int]]) -> float:\n        min_time = 0\n        for light in lights:\n            t, g, r = light\n            min_time += t\n            min_time += g\n            min_time += r\n        return min_time\n\n    def calculate_min_time_with_button(lights: List[Tuple[int, int, int]]) -> float:\n        min_time = 0\n        for light in lights:\n            t, g, r = light\n            min_time += t\n            min_time += g\n            min_time += r\n        return min_time\n\n    def calculate_min_time_with_button_acceleration(lights: List[Tuple[int, int, int]]) -> float:\n        min_time = 0\n        for light in lights:\n            t, g, r = light\n            min_time += t\n            min_time += g\n            min_time += r\n        return min_time\n\n    lights = parse_input(stdin)\n    time = calculate_time(lights)\n    min_time = calculate_min_time(lights)\n    min_time_with_button = calculate_min_time_with_button(lights)\n    min_time_with_button_acceleration = calculate_min_time_with_button_acceleration(lights)\n\n    return f\"{time:.9f}\\n{min_time:.9f}\\n{min_time_with_button:.9f}\\n{min_time_with_button_acceleration:.9f}\"\n"
    },
    {
        "number": 3201,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def generate_subsequences(arr):\n        if len(arr) == 0:\n            return [[]]\n        subseq = generate_subsequences(arr[1:])\n        return subseq + [[arr[0]] + seq for seq in subseq]\n\n    def lexicographically_smaller(a, b):\n        for i in range(min(len(a), len(b))):\n            if a[i] < b[i]:\n                return True\n            elif a[i] > b[i]:\n                return False\n        return len(a) < len(b)\n\n    def hash_subsequence(subseq, B, M):\n        hash_value = 0\n        for i in range(len(subseq)):\n            hash_value = (hash_value + subseq[i] * B ** i) % M\n        return hash_value\n\n    N, K, B, M = map(int, stdin.split()[:4])\n    arr = list(map(int, stdin.split()[4:]))\n\n    subsequences = generate_subsequences(arr)\n    subsequences.sort(key=lambda x: x)\n\n    result = []\n    for i in range(K):\n        subseq = subsequences[i]\n        subseq_hash = hash_subsequence(subseq, B, M)\n        result.append(subseq_hash)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3202,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    marbles = list(map(int, stdin.split()[2:]))\n\n    # Count the number of consecutive marbles of each color\n    counts = [0] * 101\n    for marble in marbles:\n        counts[marble] += 1\n\n    # Find the smallest number of marbles to insert\n    min_insert = 0\n    for count in counts:\n        if count >= K:\n            min_insert += count - K + 1\n        else:\n            min_insert += count\n\n    return str(min_insert)\n"
    },
    {
        "number": 3203,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    probabilities = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(1, N + 1):\n        probabilities[i - 1] = list(map(int, input_list[i].split()))\n\n    max_probability = 0\n    for permutation in itertools.permutations(range(N)):\n        probability = 1\n        for i in range(N):\n            probability *= probabilities[permutation[i]][i]\n        max_probability = max(max_probability, probability)\n\n    return f\"{max_probability:.6f}\"\n"
    },
    {
        "number": 3204,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    arrival_times = [int(time) for time in input_list[1:]]\n\n    # Sort arrival times\n    arrival_times.sort()\n\n    # Initialize variables\n    bridge_time = 0\n    bridge_open = False\n    bridge_closed = False\n    total_time = 0\n\n    for arrival_time in arrival_times:\n        # Calculate time needed to raise or lower the bridge\n        bridge_time += 60\n\n        # Check if the bridge is open\n        if bridge_open:\n            # Check if the next boat can pass\n            if arrival_time - bridge_time >= 20:\n                # The next boat can pass\n                bridge_time = arrival_time\n            else:\n                # The next boat must wait\n                bridge_closed = True\n                bridge_time = arrival_time + 20\n        else:\n            # Check if the bridge can be raised\n            if arrival_time - bridge_time >= 60:\n                # The bridge can be raised\n                bridge_open = True\n                bridge_time = arrival_time\n            else:\n                # The bridge cannot be raised\n                bridge_closed = True\n                bridge_time = arrival_time + 60\n\n        # Check if the bridge is closed\n        if bridge_closed:\n            # Calculate time needed to open the bridge\n            bridge_time += 60\n            bridge_open = True\n            bridge_closed = False\n\n        # Calculate time needed to pass the boat\n        total_time += bridge_time + 20\n\n    # Calculate time needed to lower the bridge\n    total_time += 60\n\n    return str(total_time)"
    },
    {
        "number": 3205,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[0:2])\n    receipts = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n\n    # Initialize the balance of each person\n    balance = [0] * M\n\n    # Calculate the final balance for each person\n    for a, b, p in receipts:\n        balance[a] -= p\n        balance[b] += p\n\n    # Calculate the minimum number of transactions needed to settle the score\n    min_transactions = 0\n    for b in balance:\n        if b > 0:\n            min_transactions += 1\n\n    return str(min_transactions)"
    },
    {
        "number": 3206,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, S = map(int, input_list[0].split())\n    blocks_heights = list(map(int, input_list[1].split()))\n    buildings_heights = list(map(int, input_list[2].split()))\n\n    def is_possible(blocks_heights, buildings_heights):\n        blocks_heights.sort(reverse=True)\n        buildings_heights.sort(reverse=True)\n        i, j = 0, 0\n        while i < len(buildings_heights) and j < len(blocks_heights):\n            if buildings_heights[i] <= blocks_heights[j]:\n                i += 1\n            j += 1\n        return i == len(buildings_heights)\n\n    if is_possible(blocks_heights, buildings_heights):\n        result = []\n        for i in range(S):\n            stack_height = 0\n            stack_blocks = []\n            for j in range(N):\n                if blocks_heights[j] <= buildings_heights[i] - stack_height:\n                    stack_height += blocks_heights[j]\n                    stack_blocks.append(j + 1)\n            result.append(str(len(stack_blocks)) + ' ' + ' '.join(map(str, stack_blocks)))\n        return '\\n'.join(result)\n    else:\n        return -1\n"
    },
    {
        "number": 3207,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, L = map(int, stdin.split()[:3])\n    chameleons = [tuple(map(int, input().split())) for _ in range(N)]\n    chameleons.sort()\n\n    trips = [0] * K\n    for i in range(N):\n        d, b, direction = chameleons[i]\n        if direction == 'D':\n            d = L - d\n        trips[b] += d\n\n    return '\\n'.join(map(str, trips))\n"
    },
    {
        "number": 3208,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    # Define the substitution cipher mapping\n    cipher = {\n        'a': 'h', 'b': 'j', 'c': 'k', 'd': 'l', 'e': 'm', 'f': 'n', 'g': 'o', 'h': 'p', 'i': 'q', 'j': 'r', 'k': 's', 'l': 't', 'm': 'u', 'n': 'v', 'o': 'w', 'p': 'x', 'q': 'y', 'r': 'z', 's': 'a', 't': 'b', 'u': 'c', 'v': 'd', 'w': 'e', 'x': 'f', 'y': 'g', 'z': 'h'\n    }\n\n    # Define the known words\n    known_words = [\"be\", \"our\", \"rum\", \"will\", \"dead\", \"hook\", \"ship\", \"blood\", \"sable\", \"avenge\", \"parrot\", \"captain\"]\n\n    # Decode the encrypted text\n    decoded_text = \"\"\n    for char in stdin:\n        if char in cipher:\n            decoded_text += cipher[char]\n        else:\n            decoded_text += char\n\n    # Check if the decoded text can be uniquely decrypted\n    decoded_words = decoded_text.split()\n    decoded_word_set = set(decoded_words)\n    if len(decoded_word_set) != len(decoded_words):\n        return \"Impossible\"\n\n    # Check if the decoded words are a subset of the known words\n    if decoded_word_set.issubset(set(known_words)):\n        return decoded_text\n    else:\n        return \"Impossible\""
    },
    {
        "number": 3209,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def delay_duration(probability: int, max_delay: int) -> int:\n        return round(random.uniform(1, max_delay) * probability / 100)\n\n    def expected_duration(departure_time: int, journey_time: int, probability: int, max_delay: int) -> float:\n        return journey_time + delay_duration(probability, max_delay)\n\n    def min_expected_duration(connections: List[Tuple[str, str, int, int, int, int, int]]) -> float:\n        min_duration = float('inf')\n        for origin, destination, departure_time, journey_time, probability, max_delay, _ in connections:\n            if origin == destination:\n                return 0\n            expected_arrival_time = departure_time + journey_time\n            for _, _, _, _, _, _, delay in connections:\n                expected_arrival_time += delay_duration(delay, max_delay)\n            min_duration = min(min_duration, expected_arrival_time)\n        return min_duration\n\n    def main(input_data: str) -> str:\n        origin, destination, *connections = input_data.split('\\n')\n        connections = [tuple(line.split()) for line in connections]\n        connections = [(origin, destination, int(m), int(t), int(p), int(d), delay_duration(int(p), int(d))) for origin, destination, m, t, p, d, _ in connections]\n        expected_duration = min_expected_duration(connections)\n        if expected_duration == float('inf'):\n            return 'IMPOSSIBLE'\n        return round(expected_duration, 6)\n\n    return main(stdin)"
    },
    {
        "number": 3210,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    grid = [list(line) for line in stdin.splitlines()[1:]]\n\n    def is_valid(x, y):\n        return 0 <= x < 2 * N - 1 and 0 <= y < 2 * N - 1\n\n    def count_moves():\n        moves = 0\n        for i in range(2 * N - 1):\n            for j in range(2 * N - 1):\n                if grid[i][j] == '*':\n                    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                        x, y = i + dx, j + dy\n                        if is_valid(x, y) and grid[x][y] == '.':\n                            moves += 1\n        return moves\n\n    def make_move(x, y, dx, dy):\n        i, j = x + dx, y + dy\n        if is_valid(i, j) and grid[i][j] == '.':\n            grid[i][j] = grid[x][y]\n            return True\n        return False\n\n    def dfs(x, y, depth):\n        if depth == 0:\n            return 0\n        moves = 0\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if make_move(x, y, dx, dy):\n                moves += dfs(x + dx, y + dy, depth - 1)\n                make_move(x, y, -dx, -dy)\n        return moves\n\n    moves = count_moves()\n    if moves == 0:\n        return 0\n    return dfs(0, 0, moves)\n"
    },
    {
        "number": 3211,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    # Initialize variables\n    party1_votes = 0\n    party2_votes = 0\n    tellers = 0\n    teller_index = -1\n    swaps = 0\n\n    # Count votes and find teller\n    for i in range(n):\n        if s[i] == '1':\n            party1_votes += 1\n        elif s[i] == '2':\n            party2_votes += 1\n        else:\n            tellers += 1\n            if teller_index == -1:\n                teller_index = i\n\n    # Check if party1 has more votes\n    if party1_votes > party2_votes:\n        return \"impossible\"\n\n    # Swap teller with adjacent non-teller\n    while teller_index > 0 and s[teller_index - 1] == '0':\n        s[teller_index - 1], s[teller_index] = s[teller_index], s[teller_index - 1]\n        swaps += 1\n        teller_index -= 1\n\n    # Swap teller with adjacent non-teller\n    while teller_index < n - 1 and s[teller_index + 1] == '0':\n        s[teller_index + 1], s[teller_index] = s[teller_index], s[teller_index + 1]\n        swaps += 1\n        teller_index += 1\n\n    # Check if party1 has more votes after swaps\n    party1_votes = 0\n    party2_votes = 0\n    for i in range(n):\n        if s[i] == '1':\n            party1_votes += 1\n        elif s[i] == '2':\n            party2_votes += 1\n\n    if party1_votes > party2_votes:\n        return swaps\n    else:\n        return \"impossible\""
    },
    {
        "number": 3212,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    snakes = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_safe(x, y):\n        for snake in snakes:\n            if abs(snake[0] - x) + abs(snake[1] - y) < snake[2]:\n                return False\n        return True\n\n    def is_valid(x, y):\n        return 0 <= x <= 1000 and 0 <= y <= 1000\n\n    def is_in_range(x, y):\n        return 0 <= x <= 1000 and 0 <= y <= 1000\n\n    def get_closest_safe_position(x, y):\n        safe_positions = [(x, y)]\n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            new_x, new_y = x, y\n            while is_valid(new_x, new_y) and is_safe(new_x, new_y):\n                new_x, new_y = new_x + dx, new_y + dy\n                safe_positions.append((new_x, new_y))\n        return min(safe_positions, key=lambda p: abs(p[0] - 1000) + abs(p[1] - 500))\n\n    for x in range(1001):\n        for y in range(1001):\n            if is_in_range(x, y) and is_safe(x, y):\n                closest_safe_position = get_closest_safe_position(x, y)\n                if closest_safe_position[0] == 0 and closest_safe_position[1] == 1000:\n                    return f\"Bill enters at ({x:.2f}, {y:.2f}) and leaves at ({x:.2f}, {y:.2f}).\"\n\n    return \"Bill will be bitten.\"\n"
    },
    {
        "number": 3213,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, S = map(int, stdin.split()[:2])\n    steps = stdin.split()[2]\n\n    power = 1\n    max_power = 0\n    max_steps = \"\"\n\n    for step in steps:\n        if step == \"+\":\n            power += 1\n        elif step == \"x\":\n            power *= 2\n\n        if power % (1 << S) == 0:\n            max_power = max(max_power, power)\n        power -= 1\n\n    for i, step in enumerate(steps):\n        if power % (1 << S) == 0:\n            max_steps = max_steps[:i] + \"o\" + max_steps[i + 1:]\n        power -= 1\n\n    return max_steps\n"
    },
    {
        "number": 3214,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_similarly_spelled(word1: str, word2: str) -> bool:\n        if len(word1) != len(word2):\n            return False\n        if abs(len(word1) - len(word2)) > 1:\n            return False\n        for i in range(len(word1)):\n            if word1[i] != word2[i]:\n                if i == 0 or i == len(word1) - 1:\n                    return False\n                if word1[i - 1].isalpha() and word1[i + 1].isalpha():\n                    return False\n        return True\n\n    def transform(word: str, transformation: str) -> str:\n        if transformation == \"delete\":\n            return word[:-1]\n        elif transformation == \"insert\":\n            return word[:-1] + chr(ord('a') + ord(word[-1]) - ord('a'))\n        elif transformation == \"replace\":\n            return word[:-1] + chr(ord('a') + ord(word[-1]) - ord('a') + 1)\n        elif transformation == \"transpose\":\n            return word[:-2] + word[-1] + word[-2]\n        else:\n            raise ValueError(\"Invalid transformation\")\n\n    def find_similarly_spelled_words(word: str) -> set:\n        word = word.lower()\n        similarly_spelled_words = set()\n        for i in range(len(word)):\n            for j in range(i + 1, len(word) + 1):\n                for transformation in [\"delete\", \"insert\", \"replace\", \"transpose\"]:\n                    transformed_word = transform(word[i:j], transformation)\n                    if transformed_word in word_cores:\n                        similarly_spelled_words.add(transformed_word)\n        return similarly_spelled_words\n\n    word_cores = set()\n    for line in stdin.split(\"\\n\"):\n        if line == \"***\":\n            break\n        for word in line.split():\n            word_cores.add(word.lower())\n\n    result = []\n    for word_core in sorted(word_cores):\n        similarly_spelled_words = find_similarly_spelled_words(word_core)\n        if len(similarly_spelled_words) > 0:\n            result.append(f\"{word_core}: {' '.join(sorted(similarly_spelled_words))}\")\n\n    return \"\\n\".join(result) if len(result) > 0 else \"***\"\n"
    },
    {
        "number": 3215,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cards = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def shuffle(cards, n):\n        if n == 1:\n            return cards\n        else:\n            mid = n // 2\n            left = shuffle(cards[:mid], mid)\n            right = shuffle(cards[mid:], n - mid)\n            return [left[i % n] for i in range(n)] + [right[i % n] for i in range(n)]\n\n    shuffled_cards = shuffle(cards, n)\n    shuffles = 0\n    for i in range(n):\n        if shuffled_cards[i] != i + 1:\n            shuffles += 1\n            break\n    return shuffles\n"
    },
    {
        "number": 3216,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str, repeat_count = stdin.split()\n    input_str = input_str.replace(\".\", \"\")\n    numerator = int(input_str[:-repeat_count])\n    denominator = int(input_str[-repeat_count:])\n    gcd = find_gcd(numerator, denominator)\n    return f\"{numerator//gcd}/{denominator//gcd}\"\n\ndef"
    },
    {
        "number": 3217,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbors(x, y, z):\n        return [(x+1, y, z), (x-1, y, z), (x, y+1, z), (x, y-1, z), (x, y, z+1), (x, y, z-1)]\n\n    def is_valid(x, y, z):\n        return 0 <= x <= 9 and 0 <= y <= 9 and 0 <= z <= 9\n\n    def is_enclosed(x, y, z):\n        for dx, dy, dz in get_neighbors(x, y, z):\n            if not is_valid(dx, dy, dz) or grid[dx][dy][dz] == 0:\n                return False\n        return True\n\n    def count_panels(x, y, z):\n        count = 0\n        for dx, dy, dz in get_neighbors(x, y, z):\n            if is_valid(dx, dy, dz) and grid[dx][dy][dz] == 0:\n                count += 1\n        return count\n\n    n = int(stdin.splitlines()[0])\n    defective_cells = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    grid = [[[0] * 10 for _ in range(10)] for _ in range(10)]\n\n    for x, y, z in defective_cells:\n        grid[x][y][z] = 1\n\n    min_panels = float('inf')\n    for x, y, z in defective_cells:\n        if is_enclosed(x, y, z):\n            min_panels = min(min_panels, count_panels(x, y, z))\n\n    return str(min_panels)"
    },
    {
        "number": 3218,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n\n    def is_valid_coloring(edges):\n        for i in range(n):\n            for j in range(n if i % 2 == 1 else n - 1):\n                if a[i][j] != -1 and a[i][j] != edges[i][j]:\n                    return False\n        return True\n\n    def count_valid_colorings():\n        count = 0\n        for edges in itertools.product([-1, 0, 1, 2, 3, 4, 5, 6], repeat=n * n):\n            edges = np.array(edges).reshape((n, n))\n            if is_valid_coloring(edges):\n                count += 1\n        return count\n\n    import itertools\n    import numpy as np\n\n    return str(count_valid_colorings())"
    },
    {
        "number": 3219,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_representations(n: int) -> int:\n        count = 0\n        for i in range(1, n + 1):\n            binary = bin(i)[2:]\n            if '2' in binary:\n                count += 1\n        return count\n\n    n = int(stdin, 2)\n    return str(count_representations(n) % 1000000009)\n"
    },
    {
        "number": 3220,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if there is a valid solution\n    if sum(p) % N != 0:\n        return \"no dance\"\n\n    # Calculate the number of steps each wizard should take\n    steps = [sum(p) // N] * N\n\n    # Calculate the final positions of the wizards\n    positions = [i % N for i in range(1, N + 1)]\n\n    # Calculate the final positions of the wizards after the dance\n    final_positions = [positions[i] + steps[i] for i in range(N)]\n\n    # Check if there is a collision\n    for i in range(N):\n        for j in range(i + 1, N):\n            if final_positions[i] == final_positions[j]:\n                return \"no dance\"\n\n    # Determine the direction each wizard should teleport\n    result = []\n    for i in range(N):\n        if final_positions[i] > positions[i]:\n            result.append(\"R\")\n        else:\n            result.append(\"L\")\n\n    return \"\".join(result)"
    },
    {
        "number": 3221,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, alpha = map(int, stdin.split()[:3])\n    roads = [tuple(map(int, stdin.split()[3:6])) for _ in range(M)]\n\n    def dfs(start, visited, candies, energy):\n        if start == end:\n            return energy\n        visited.add(start)\n        for u, v, c in roads:\n            if u in visited and v not in visited:\n                energy += c * c\n                if dfs(v, visited, candies + c, energy):\n                    return energy\n            elif v in visited and u not in visited:\n                energy += c * c\n                if dfs(u, visited, candies + c, energy):\n                    return energy\n        return float('inf')\n\n    end = 1\n    for u, v, c in roads:\n        if u == end:\n            start = v\n            break\n        elif v == end:\n            start = u\n            break\n    else:\n        return \"Poor girl\"\n\n    visited = set()\n    energy = dfs(start, visited, 0, 0)\n    if energy == float('inf'):\n        return \"Poor girl\"\n    else:\n        return energy + alpha * len(visited)"
    },
    {
        "number": 3222,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Check if there is a loop in the graph\n    visited = [False] * N\n    for i in range(N):\n        if visited[i]:\n            continue\n        stack = [i]\n        visited[i] = True\n        while stack:\n            node = stack.pop()\n            for road in roads:\n                if road[0] == node and not visited[road[1]]:\n                    stack.append(road[1])\n                    visited[road[1]] = True\n                elif road[1] == node and not visited[road[0]]:\n                    stack.append(road[0])\n                    visited[road[0]] = True\n            if len(stack) > N:\n                return \"Yeah!\"\n\n    # Split the graph into trips\n    trips = []\n    for i in range(N):\n        visited = [False] * N\n        visited[i] = True\n        stack = [(i, i)]\n        while stack:\n            start, end = stack.pop()\n            if not visited[end]:\n                visited[end] = True\n                for road in roads:\n                    if road[0] == end and not visited[road[1]]:\n                        stack.append((start, road[1]))\n                    elif road[1] == end and not visited[road[0]]:\n                        stack.append((start, road[0]))\n            if not any(not visited[i] for i in range(N)):\n                trips.append(visited)\n                visited = [False] * N\n                visited[i] = True\n                stack = [(i, i)]\n\n    # Output the trips\n    if not trips:\n        return \"Yeah!\"\n    else:\n        return str(len(trips)) + '\\n' + '\\n'.join([' '.join(str(i) for i in trip if trip[i]) for trip in trips])"
    },
    {
        "number": 3223,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    V = int(input_list[0])\n    degrees = list(map(int, input_list[1].split()))\n\n    if V == 0:\n        return \"IMPOSSIBLE\"\n\n    if len(degrees) != V:\n        return \"IMPOSSIBLE\"\n\n    for degree in degrees:\n        if degree < 0 or degree > 100:\n            return \"IMPOSSIBLE\"\n\n    if sum(degrees) % V != 0:\n        return \"IMPOSSIBLE\"\n\n    max_degree = max(degrees)\n    min_degree = min(degrees)\n\n    if max_degree > V:\n        return \"IMPOSSIBLE\"\n\n    if min_degree == 0:\n        return \"IMPOSSIBLE\"\n\n    if min_degree == 1:\n        return \"POSSIBLE\"\n\n    if min_degree > 1:\n        return \"IMPOSSIBLE\"\n\n    forest = []\n    for i in range(V):\n        forest.append([])\n\n    for i in range(V):\n        for j in range(degrees[i]):\n            forest[i].append(j)\n\n    edges = []\n    for i in range(V):\n        for j in range(V):\n            if i != j and forest[i] and forest[j]:\n                edges.append((i, j))\n\n    return \"POSSIBLE\"\n"
    },
    {
        "number": 3224,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2 + (p1[2] - p2[2]) ** 2) ** 0.5\n\n    def center_of_mass(points):\n        x, y, z = 0, 0, 0\n        total_mass = len(points)\n        for point in points:\n            x += point[0]\n            y += point[1]\n            z += point[2]\n        return x / total_mass, y / total_mass, z / total_mass\n\n    def sphere_center(points):\n        center = center_of_mass(points)\n        radius = 0\n        for point in points:\n            radius = max(radius, distance(point, center))\n        return center, radius\n\n    points = []\n    for line in stdin.split('\\n'):\n        x, y, z = map(int, line.split())\n        points.append((x, y, z))\n\n    center, radius = sphere_center(points)\n    return f\"{center[0]:.6f} {center[1]:.6f} {center[2]:.6f}\""
    },
    {
        "number": 3225,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    v = list(map(int, input_list[1].split()))\n\n    def get_neighbors(i):\n        if i == 0:\n            return v[i+1], v[i+2]\n        elif i == N-1:\n            return v[i-1], v[i-2]\n        else:\n            return v[i-1], v[i+1]\n\n    def leave_queue(i):\n        if v[i] < min(neighbors):\n            return True\n        else:\n            return False\n\n    M = 0\n    while True:\n        M += 1\n        leave_count = 0\n        for i in range(N):\n            neighbors = get_neighbors(i)\n            if leave_queue(i):\n                leave_count += 1\n        if leave_count == 0:\n            break\n\n    result = []\n    for i in range(M):\n        result.append([v[j] for j in range(N) if v[j] == min(get_neighbors(j))])\n\n    final_state = [v[j] for j in range(N)]\n    return str(M) + '\\n' + '\\n'.join([' '.join(map(str, line)) for line in result]) + '\\n' + ' '.join(map(str, final_state)) "
    },
    {
        "number": 3226,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a - b)\n\n    def min_speed(a, b, l, p):\n        if distance(a, b) <= l:\n            return p / distance(a, b)\n        else:\n            return p / l + (distance(a, b) - l) / distance(a, b)\n\n    def escape_speed(n, m, e, n1, n2, p):\n        min_speed_value = float('inf')\n        for i in range(1, m + 1):\n            for j in range(i + 1, m + 1):\n                for l in range(1, 101):\n                    speed = min_speed(n1, n2, l, p)\n                    if speed < min_speed_value:\n                        min_speed_value = speed\n        return min_speed_value\n\n    def is_impossible(n, m, e, n1, n2, p):\n        for i in range(1, m + 1):\n            for j in range(i + 1, m + 1):\n                for l in range(1, 101):\n                    if distance(n1, n2) <= l:\n                        return False\n        return True\n\n    n, m, e, *rest = stdin.split()\n    n, m, e = int(n), int(m), int(e)\n    n1, n2, p = int(rest[0]), int(rest[1]), int(rest[2])\n\n    if is_impossible(n, m, e, n1, n2, p):\n        return \"IMPOSSIBLE\"\n    else:\n        return escape_speed(n, m, e, n1, n2, p)"
    },
    {
        "number": 3227,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, E = map(int, input_data[0].split())\n    roads = [tuple(map(int, line.split())) for line in input_data[1:]]\n\n    # Create a graph with the given roads\n    graph = [[] for _ in range(N + 1)]\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Initialize the chains with the given cities\n    chains = [set() for _ in range(2)]\n    for i in range(1, N + 1):\n        for j in range(len(graph[i])):\n            if graph[i][j] in chains[0]:\n                chains[1].add(i)\n                break\n            elif graph[i][j] in chains[1]:\n                chains[0].add(i)\n                break\n\n    # If there is no way to fairly assign the roads, return 0\n    if not chains[0] or not chains[1]:\n        return \"0\\n\"\n\n    # Assign the roads to the chains\n    result = []\n    for a, b in roads:\n        if a in chains[0] and b in chains[0]:\n            result.append(\"1\\n\")\n        elif a in chains[1] and b in chains[1]:\n            result.append(\"2\\n\")\n        else:\n            result.append(\"1\\n\")\n\n    return ''.join(result)"
    },
    {
        "number": 3228,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T, G = map(int, stdin.split())\n    arrival_times = sorted(map(int, stdin.split()[3:]))\n\n    def get_waiting_time(arrival_time):\n        return T - arrival_time\n\n    def get_total_waiting_time(arrival_times):\n        total_waiting_time = 0\n        for i in range(len(arrival_times)):\n            for j in range(i + 1, len(arrival_times)):\n                total_waiting_time += get_waiting_time(arrival_times[j] - arrival_times[i])\n        return total_waiting_time\n\n    total_waiting_time = get_total_waiting_time(arrival_times)\n    return total_waiting_time\n"
    },
    {
        "number": 3229,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    scores = [list(map(int, stdin.split()[2:]))]\n    for _ in range(m-1):\n        scores.append(list(map(int, input().split())))\n    scores.sort(key=lambda x: sum(x) if sum(x) > 0 else 0, reverse=True)\n    rank = 1\n    for i in range(m):\n        if sum(scores[i]) == 0:\n            continue\n        rank += m - i\n        break\n    return rank"
    },
    {
        "number": 3230,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    layout = stdin.split()[1:]\n    layout = [''.join(layout[i:i+C]) for i in range(0, len(layout), C)]\n\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def find_closest(x, xs):\n        return min(xs, key=lambda y: distance(x, y))\n\n    def find_explosions(layout):\n        explosions = 0\n        for i in range(R):\n            for j in range(C):\n                if layout[i][j] == 'X':\n                    closest_seat = find_closest((i, j), [(k, l) for k in range(R) for l in range(C) if layout[k][l] == 'L'])\n                    if distance((i, j), closest_seat) == 1:\n                        explosions += 1\n                        layout[closest_seat[0]][closest_seat[1]] = 'X'\n        return explosions\n\n    explosions = find_explosions(layout)\n    return str(explosions)"
    },
    {
        "number": 3231,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split()[:3])\n    students = []\n    for _ in range(n):\n        m, *friends = map(int, stdin.split()[3:])\n        students.append((m, set(friends)))\n\n    # Check if the friendships satisfy the given properties\n    for i, (m, friends) in enumerate(students):\n        for j in range(i + 1, n):\n            if i in friends and j not in friends:\n                return \"detention\"\n            if j in friends and i not in friends:\n                return \"detention\"\n\n    # Check if the students can be partitioned into groups\n    def is_valid_partition(groups):\n        for i, group in enumerate(groups):\n            for j in range(i + 1, len(groups)):\n                if len(group & groups[j]) > q:\n                    return False\n        return True\n\n    def find_groups(students):\n        groups = []\n        for student in students:\n            m, friends = student\n            for group in groups:\n                if len(group) < p and len(group & friends) <= q:\n                    group.add(student)\n                    break\n            else:\n                groups.append({student})\n        return groups\n\n    groups = find_groups(students)\n    if not is_valid_partition(groups):\n        return \"detention\"\n\n    # Output the partition\n    G = len(groups)\n    print(\"home\")\n    print(G)\n    for group in groups:\n        print(len(group), *sorted(group))\n"
    },
    {
        "number": 3232,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = len(stdin)\n    if N % 2 != 0:\n        return -1\n    substrings = [stdin[i:i+N//2] for i in range(0, N, N//2)]\n    if len(set(substrings)) == len(substrings):\n        return stdin\n    else:\n        return -1"
    },
    {
        "number": 3233,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    p.sort()\n    count = 0\n    for i in range(n):\n        if i == 0 or p[i] != p[i-1]:\n            count += 1\n            if i == n-1 or p[i] != p[i+1]:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3234,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    W = 2 * N\n    H = 2 * N\n    empty_squares = W * H - 2 * N\n    return str(empty_squares)\n"
    },
    {
        "number": 3235,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_cycle(graph: dict, start: int) -> list:\n        visited = [False] * n\n        cycle = []\n        def dfs(node: int) -> None:\n            visited[node] = True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    dfs(neighbor)\n                elif neighbor != start:\n                    cycle.append(neighbor)\n        dfs(start)\n        return cycle\n\n    def cancel_cycle(cycle: list) -> None:\n        min_debt = min(graph[node][friend] for node in cycle for friend in graph[node])\n        for node in cycle:\n            for friend in graph[node]:\n                if friend in cycle:\n                    graph[node][friend] -= min_debt\n                    graph[friend][node] -= min_debt\n\n    n, m = map(int, stdin.split()[:2])\n    graph = [{} for _ in range(n)]\n    for _ in range(m):\n        a, b, c = map(int, stdin.split()[2:])\n        graph[a][b] = c\n        graph[b][a] = -c\n\n    cycles = []\n    for i in range(n):\n        cycle = find_cycle(graph, i)\n        if cycle:\n            cycles.append(cycle)\n            cancel_cycle(cycle)\n\n    remaining_debt = sum(sum(graph[i].values()) for i in range(n))\n    output = [str(remaining_debt)] + [\"{} {} {}\".format(a, b, graph[a][b]) for a in range(n) for b in range(n) if a < b and graph[a][b] > 0]\n    return \"\\n\".join(output)"
    },
    {
        "number": 3236,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fibonacci(n: int) -> int:\n        if n <= 1:\n            return n\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b\n\n    def is_valid_tour(tour: list, heights: list) -> bool:\n        for i in range(len(tour) - 1):\n            if heights[tour[i]] > heights[tour[i + 1]]:\n                return False\n        return True\n\n    def longest_fibonacci_tour(n: int, m: int, heights: list, roads: list) -> int:\n        max_length = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                if (i, j) in roads or (j, i) in roads:\n                    tour = [i, j]\n                    for k in range(n):\n                        if k != i and k != j and (k, i) not in roads and (i, k) not in roads and (k, j) not in roads and (j, k) not in roads:\n                            tour.append(k)\n                            if is_valid_tour(tour, heights):\n                                max_length = max(max_length, len(tour))\n                            tour.pop()\n        return max_length\n\n    n, m = map(int, stdin.split()[:2])\n    heights = list(map(int, stdin.split()[2:2 + n]))\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[2 + n:]]\n\n    return str(longest_fibonacci_tour(n, m, heights, roads))\n"
    },
    {
        "number": 3237,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def prime_factorization(n: int) -> str:\n        factor = 2\n        result = \"\"\n        while n > 1:\n            if n % factor == 0:\n                result += str(factor)\n                n //= factor\n            else:\n                factor += 1\n        return result\n\n    def min_cost(stdin: str) -> int:\n        total_bytes = 1\n        for i in range(0, len(stdin), 2):\n            total_bytes *= int(stdin[i:i+2])\n\n        base_cost = total_bytes\n        min_cost = base_cost\n        for i in range(2, total_bytes + 1):\n            if total_bytes % i == 0:\n                min_cost = min(min_cost, base_cost + (total_bytes // i - 1))\n\n        return min_cost % (10**9 + 7)\n\n    prime_factorization_str = prime_factorization(int(stdin))\n    return str(min_cost(prime_factorization_str))"
    },
    {
        "number": 3238,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    image = input_data[1:]\n\n    def is_fold_horizontal(fold_line: int) -> bool:\n        return all(image[i][fold_line] == '#' for i in range(n))\n\n    def is_fold_vertical(fold_column: int) -> bool:\n        return all(image[fold_column][i] == '#' for i in range(m))\n\n    def is_fold_diagonal(fold_line: int, fold_column: int) -> bool:\n        return image[fold_line][fold_column] == '#'\n\n    def find_fold_line(fold_column: int) -> int:\n        for i in range(n):\n            if is_fold_diagonal(i, fold_column):\n                return i\n        return -1\n\n    def find_fold_column(fold_line: int) -> int:\n        for i in range(m):\n            if is_fold_diagonal(fold_line, i):\n                return i\n        return -1\n\n    def find_fold_coordinates(fold_line: int, fold_column: int) -> Tuple[int, int, int, int]:\n        if is_fold_horizontal(fold_line):\n            return (fold_line, 0, fold_line, m - 1)\n        elif is_fold_vertical(fold_column):\n            return (0, fold_column, n - 1, fold_column)\n        else:\n            return (fold_line, 0, n - 1, m - 1)\n\n    for fold_column in range(m):\n        if is_fold_horizontal(fold_column):\n            break\n\n    fold_line = find_fold_line(fold_column)\n    fold_coordinates = find_fold_coordinates(fold_line, fold_column)\n\n    return f\"{fold_coordinates[0]} {fold_coordinates[1]} {fold_coordinates[2]} {fold_coordinates[3]}\""
    },
    {
        "number": 3239,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P = map(float, input().split())\n    expected_money = 0\n    for i in range(N):\n        if i == N - 1:\n            expected_money += 5 * 100\n        else:\n            expected_money += 100 * (1 - P)\n    return f\"{expected_money:.10f}\"\n"
    },
    {
        "number": 3240,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, v = map(int, stdin.split()[0].split())\n    p = [float(stdin.split()[i+1]) for i in range(v-1)]\n    b = [int(stdin.split()[i+1+v-1]) for i in range(v-1)]\n    \n    def count_positions(ballots):\n        return bin(ballots).count('1')\n    \n    def expected_positions(ballots):\n        total_ballots = sum(b)\n        return sum(count_positions(ballots & (1 << i) - 1) * p[i] for i in range(v-1)) * total_ballots\n    \n    best_ballots = 0\n    best_expected_positions = -1\n    \n    for ballots in range(1, 2**k):\n        expected = expected_positions(ballots)\n        if expected > best_expected_positions:\n            best_ballots = ballots\n            best_expected_positions = expected\n    \n    return str(best_ballots)"
    },
    {
        "number": 3241,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    A = [int(x) for x in input_data[1].split()]\n    B = [int(x) for x in input_data[2].split()]\n\n    total_kilos = sum(A)\n    total_ham = sum(B)\n\n    if total_ham == 0:\n        return -1\n\n    required_ratio = [b / total_ham for b in B]\n\n    required_kilos = [round(a / total_kilos * total_ham) for a in A]\n\n    if sum(required_kilos) != total_ham:\n        return -1\n\n    return round(sum([required_ratio[i] * required_kilos[i] for i in range(N)]), 12)\n"
    },
    {
        "number": 3242,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, P = map(float, input_list[0].split())\n    boxes = []\n    for i in range(1, int(N) + 1):\n        energy, probability = map(float, input_list[i].split())\n        boxes.append((energy, probability))\n\n    boxes.sort(key=lambda x: x[1], reverse=True)\n    energy_wasted = 0\n    found_polly = False\n\n    for box in boxes:\n        energy, probability = box\n        if probability >= P:\n            found_polly = True\n            break\n        energy_wasted += energy\n\n    if found_polly:\n        return str(energy_wasted)\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 3243,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    c = list(map(int, stdin.split()[3:n+3]))\n    u = [int(x) for x in stdin.split()[n+3:n+3+m*2:2]]\n    v = [int(x) for x in stdin.split()[n+4:n+4+m*2:2]]\n\n    # Create a graph to represent the existing network\n    graph = [[] for _ in range(n)]\n    for i in range(m):\n        graph[u[i]].append(v[i])\n        graph[v[i]].append(u[i])\n\n    # BFS to check if all servers can be connected\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n\n    while queue:\n        node = queue.pop(0)\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                queue.append(neighbor)\n\n    # Check if all servers are connected\n    if all(visited):\n        return \"yes\"\n    else:\n        return \"no\""
    },
    {
        "number": 3244,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    second_ring = [int(x) for x in input_list[1:]]\n\n    # Calculate the sum of the first three numbers in the second ring\n    first_sum = second_ring[0] + second_ring[1] + second_ring[2]\n\n    # Calculate the sum of the first three numbers in the first ring\n    first_ring_sum = second_ring[0] + second_ring[N - 1] + second_ring[N - 2]\n\n    # Calculate the difference between the two sums\n    diff = first_sum - first_ring_sum\n\n    # Calculate the number of steps to rotate the second ring\n    steps = (diff + N - 1) % N\n\n    # Rotate the second ring\n    rotated_ring = second_ring[steps:] + second_ring[:steps]\n\n    # Convert the rotated ring to the original ring\n    original_ring = [rotated_ring[(i + steps) % N] for i in range(N)]\n\n    # Return the original ring as a string\n    return '\\n'.join(map(str, original_ring))"
    },
    {
        "number": 3245,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    input_lines = stdin.split('\\n')[1:]\n    command_history = []\n\n    for line in input_lines:\n        command = ''\n        for char in line:\n            if char == '^':\n                if command_history:\n                    command = command_history[-1]\n            else:\n                command += char\n        command_history.append(command)\n\n    return '\\n'.join(command_history)"
    },
    {
        "number": 3246,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')\n    s = s[0]\n    n = int(s[0])\n    words = s[1:].split('\\n')\n    words = set(words)\n    if len(words) != n:\n        return \"impossible\"\n    word_dict = {}\n    for word in words:\n        word_dict[word] = [i for i in range(len(word))]\n    for i in range(len(s)-1):\n        if s[i] in word_dict and s[i+1] in word_dict:\n            for j in range(len(word_dict[s[i]])):\n                if s[i+1] == word_dict[s[i]][j]:\n                    word_dict[s[i]].pop(j)\n                    break\n            if not word_dict[s[i]]:\n                return \"impossible\"\n    if len(word_dict[s[-1]]) != 1:\n        return \"ambiguous\"\n    result = \"\"\n    for i in range(len(s)-1):\n        if s[i] in word_dict:\n            result += word_dict[s[i]][0]\n        else:\n            result += s[i]\n    result += word_dict[s[-1]][0]\n    return result"
    },
    {
        "number": 3247,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n == 1:\n        return str((m + 1) // 2)\n    elif n == 2:\n        return str((m + 1) * (m + 2) // 4)\n    else:\n        return str((m + 1) * (m + 2) * (2 * n - 3) // 6)\n"
    },
    {
        "number": 3248,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_tile(tile: str, street: str) -> bool:\n        for letter in tile:\n            if letter not in street:\n                return False\n            street = street[street.index(letter) + 1:]\n        return True\n\n    def count_untileable_cells(street: str, tiles: list[str]) -> int:\n        untileable_cells = 0\n        for i in range(len(street)):\n            for tile in tiles:\n                if is_valid_tile(tile, street[i:]):\n                    break\n            else:\n                untileable_cells += 1\n        return untileable_cells\n\n    N, street, M = stdin.split('\\n')[:3]\n    M = int(M)\n    tiles = stdin.split('\\n')[3:]\n\n    result = count_untileable_cells(street, tiles)\n    return str(result)\n"
    },
    {
        "number": 3249,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    C = int(input_list[0])\n    N = int(input_list[1])\n    vertices = [tuple(map(int, input_list[i+2].split())) for i in range(N)]\n\n    # Helper function to calculate the area of a polygon\n    def polygon_area(vertices):\n        area = 0\n        for i in range(len(vertices)):\n            x1, y1 = vertices[i]\n            x2, y2 = vertices[(i + 1) % len(vertices)]\n            area += (x1 * y2) - (x2 * y1)\n        return abs(area) / 2\n\n    # Helper function to calculate the distance between two points\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    # Helper function to find the point on the line segment that is closest to the given point\n    def closest_point(p, p1, p2):\n        if p1 == p2:\n            return p1\n        if p1[0] == p2[0]:\n            return (p1[0], p)\n        m = (p2[1] - p1[1]) / (p2[0] - p1[0])\n        b = p1[1] - m * p1[0]\n        x = (p[1] - b) / m\n        return (x, m * x + b)\n\n    # Helper function to find the point on the line that is closest to the given point\n    def closest_line(p, p1, p2):\n        return closest_point(p, p1, p2)\n\n    # Helper function to find the point on the line segment that is farthest from the given point\n    def farthest_point(p, p1, p2):\n        return closest_point(p, p1, p2)[::-1]\n\n    # Helper function to find the point on the line that is farthest from the given point\n    def farthest_line(p, p1, p2):\n        return farthest_point(p, p1, p2)\n\n    # Helper function to find the intersection point of two lines\n    def line_intersection(p1, p2, p3, p4):\n        if p1 == p2 or p3 == p4:\n            return None\n        if p1[0] == p2[0]:\n            m1 = None\n            b1 = p1[1]\n        else:\n            m1 = (p1[1] - p2[1]) / (p1[0] - p2[0])\n            b1 = p1[1] - m1 * p1[0]\n        if p3[0] == p4[0]:\n            m2 = None\n            b2 = p3[1]\n        else:\n            m2 = (p3[1] - p4[1]) / (p3[0] - p4[0])\n            b2 = p3[1] - m2 * p3[0]\n        if m1 is None:\n            x = p1[0]\n            if m2 is None:\n                y = p1[1]\n            else:\n                y = m2 * x + b2\n        elif m2 is None:\n            x = p3[0]\n            y = m1 * x + b1\n        else:\n            x = (b2 - b1) / (m1 - m2)\n            y = m1 * x + b1\n        return (x, y)\n\n    # Helper function to find the intersection point of two line segments\n    def line_segment_intersection(p1, p2, p3, p4):\n        if p1 == p2 or p3 == p4:\n            return None\n        if p1 == p3 or p1 == p4 or p2 == p3 or p2 == p4:\n            return line_intersection(p1, p2, p3, p4)\n        return None\n\n    # Helper function to find the point on the line that is closest to the given point\n    def closest_line"
    },
    {
        "number": 3250,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, d = map(int, stdin.split())\n    if b < 2 or d < 2 or b >= 2**63 or d >= 2**63:\n        return \"no\"\n    if d == 2 or d == 5:\n        return \"no\"\n    if d % 2 == 0 or d % 5 == 0:\n        return \"no\"\n    for m in range(1, d):\n        if m % 2 == 0 or m % 5 == 0:\n            continue\n        if m * b**m % d == 0:\n            return \"yes\"\n    return \"no\"\n\ndef"
    },
    {
        "number": 3251,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(intervals: list, start: int, end: int) -> bool:\n        for i in range(len(intervals)):\n            if start >= intervals[i][0] and start <= intervals[i][1]:\n                return False\n            if end >= intervals[i][0] and end <= intervals[i][1]:\n                return False\n        return True\n\n    def find_longest_sequence(intervals: list) -> list:\n        longest_sequence = []\n        for i in range(len(intervals)):\n            for j in range(i + 1, len(intervals)):\n                if is_valid(intervals, intervals[i][1], intervals[j][0]):\n                    sequence = [intervals[i], intervals[j]]\n                    k = j + 1\n                    while k < len(intervals) and is_valid(intervals, sequence[-1][1], intervals[k][0]):\n                        sequence.append(intervals[k])\n                        k += 1\n                    if len(sequence) > len(longest_sequence):\n                        longest_sequence = sequence\n        return longest_sequence\n\n    def format_interval(interval: tuple) -> str:\n        return f\"{interval[0]} {interval[1]}\"\n\n    input_data = stdin.split(\"\\n\")\n    n = int(input_data[0])\n    intervals = [tuple(map(int, line.split())) for line in input_data[1:]]\n    longest_sequence = find_longest_sequence(intervals)\n    output = f\"{len(longest_sequence)}\\n\" + \"\\n\".join(format_interval(interval) for interval in longest_sequence)\n    return output\n"
    },
    {
        "number": 3252,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def area(w: int, h: int) -> int:\n        return w * h\n\n    def envelope_area(w: int, h: int) -> int:\n        return area(w, h)\n\n    def card_area(w: int, h: int) -> int:\n        return area(w, h)\n\n    def waste(w: int, h: int, e_w: int, e_h: int) -> int:\n        card_area_ = card_area(w, h)\n        e_area = envelope_area(e_w, e_h)\n        return e_area - card_area_\n\n    def min_waste(w: int, h: int, q: int, envelopes: List[Tuple[int, int]]) -> int:\n        min_waste_ = float('inf')\n        for e_w, e_h in envelopes:\n            waste_ = sum(waste(w, h, e_w, e_h) for _ in range(q))\n            min_waste_ = min(min_waste_, waste_)\n        return min_waste_\n\n    def main(n: int, k: int, cards: List[Tuple[int, int, int]]) -> int:\n        envelopes = [(12, 12) for _ in range(k)]\n        min_waste_ = float('inf')\n        for w, h, q in cards:\n            waste_ = min_waste(w, h, q, envelopes)\n            min_waste_ = min(min_waste_, waste_)\n        return min_waste_\n\n    n, k = map(int, stdin.split()[:2])\n    cards = [tuple(map(int, stdin.split()[2:])) for _ in range(n)]\n    return str(main(n, k, cards))"
    },
    {
        "number": 3253,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    S = int(input_list[0])\n    del input_list[0]\n\n    delegates_sum = 0\n    for i in range(S):\n        delegates_sum += int(input_list[i].split()[0])\n\n    if delegates_sum < S:\n        return \"impossible\"\n\n    undecided_sum = 0\n    for i in range(S):\n        undecided_sum += int(input_list[i].split()[3])\n\n    if undecided_sum == 0:\n        return \"impossible\"\n\n    min_voters_to_convince = delegates_sum - S\n    return str(min_voters_to_convince)\n"
    },
    {
        "number": 3254,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = float(stdin)\n    ones = twos = threes = fours = fives = 0\n    while P > 0:\n        if P >= 5:\n            fives += 1\n            P -= 5\n        elif P >= 4:\n            fours += 1\n            P -= 4\n        elif P >= 3:\n            threes += 1\n            P -= 3\n        elif P >= 2:\n            twos += 1\n            P -= 2\n        else:\n            ones += 1\n            P -= 1\n    return f\"{ones} {twos} {threes} {fours} {fives}\"\n"
    },
    {
        "number": 3255,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    from collections import defaultdict\n    from itertools import permutations\n\n    def explore(start, end, visited, graph, max_jump, max_diff):\n        if start == end:\n            return 1\n        if visited[start]:\n            return 0\n        visited[start] = True\n        max_length = 0\n        for i in range(1, max_jump + 1):\n            if start + i < len(graph):\n                max_length = max(max_length, explore(start + i, end, visited, graph, max_jump, max_diff))\n            if start - i >= 0:\n                max_length = max(max_length, explore(start - i, end, visited, graph, max_jump, max_diff))\n        return max_length + 1\n\n    n, D, M = map(int, stdin.split())\n    graph = list(map(int, stdin.split()[1:]))\n    max_length = 0\n    for perm in permutations(range(n)):\n        visited = defaultdict(bool)\n        length = explore(0, perm[-1], visited, graph, D, M)\n        if length > max_length:\n            max_length = length\n    return str(max_length)\n"
    },
    {
        "number": 3256,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    A = list(map(int, stdin.split()[2:]))\n\n    def power(section):\n        return reduce(lambda x, y: x | y, section)\n\n    def max_power(sections):\n        return max(power(section) for section in sections)\n\n    def bitwise_and(a, b):\n        return a & b\n\n    def max_bitwise_and(sections):\n        return reduce(lambda x, y: bitwise_and(x, y), [power(section) for section in sections])\n\n    def divide_circle(A, K):\n        sections = []\n        for i in range(K):\n            section = []\n            for j in range(i, N, K):\n                section.append(A[j])\n            sections.append(section)\n        return sections\n\n    sections = divide_circle(A, K)\n    max_power_sections = [section for section in sections if len(section) > 0]\n    max_power_sections.sort(key=lambda x: power(x), reverse=True)\n\n    if len(max_power_sections) == 0:\n        return 0\n\n    max_power_section = max_power_sections[0]\n    max_power_sections.remove(max_power_section)\n\n    max_power_section_power = power(max_power_section)\n    max_power_sections_power = max_power(max_power_sections)\n\n    return bitwise_and(max_power_section_power, max_power_sections_power)\n"
    },
    {
        "number": 3257,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c = map(float, stdin.split())\n    if a + b <= 1 or b + c <= 1 or a + c <= 1:\n        return -1\n    s = (a + b + c) / 2\n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    return round(area, 6)\n"
    },
    {
        "number": 3258,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_velocity(mice, m):\n        mice.sort(key=lambda x: x[2])\n        min_velocity = 0\n        for mouse in mice:\n            min_velocity = max(min_velocity, mouse[1] / (mouse[2] * m))\n        return min_velocity\n\n    n, m = map(int, stdin.split()[:2])\n    mice = [tuple(map(int, stdin.split()[i].split())) for i in range(2, 2 + n * 3, 3)]\n    m = float(stdin.split()[-1])\n\n    min_velocity = get_min_velocity(mice, m)\n    return f\"{min_velocity:.10f}\"\n"
    },
    {
        "number": 3259,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    boxes = [0] * N\n    total_stones = 0\n\n    for _ in range(Q):\n        line = stdin.split()[1:]\n        if line[0] == '1':\n            L, R, A, B = map(int, line[1:])\n            for i in range(L, R + 1):\n                boxes[i] = (i - L + 1) * A % B\n                total_stones += boxes[i]\n        elif line[0] == '2':\n            L, R = map(int, line[1:])\n            stones_in_range = sum(boxes[L:R+1])\n            print(stones_in_range)"
    },
    {
        "number": 3260,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split())\n    count = 1\n    for i in range(2, n + 1):\n        count *= i\n        count %= p\n    count = count * pow(k, n - 1, p)\n    count %= p\n    return str(count)\n"
    },
    {
        "number": 3261,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    result = 0\n    for i in range(K):\n        if bin(i)[2:].count('1') >= 1:\n            result += 1\n    return str(result)"
    },
    {
        "number": 3262,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: list, start: int) -> list:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        queue = [(0, start)]\n\n        while queue:\n            (cost, node) = heapq.heappop(queue)\n            if not visited[node]:\n                visited[node] = True\n                for neighbor, weight in graph[node]:\n                    new_cost = cost + weight\n                    if new_cost < dist[neighbor]:\n                        dist[neighbor] = new_cost\n                        heapq.heappush(queue, (new_cost, neighbor))\n\n        return dist\n\n    def min_trucks(N: int, M: int, C: int, clients: list, streets: list) -> int:\n        graph = [[] for _ in range(N)]\n        for u, v, w in streets:\n            graph[u].append((v, w))\n            graph[v].append((u, w))\n\n        dist = dijkstra(graph, 0)\n        min_dist = min(dist[1:])\n        min_trucks = 1\n\n        for i in range(1, N):\n            if dist[i] == min_dist:\n                min_trucks += 1\n\n        return min_trucks\n\n    N, M, C = map(int, stdin.split()[:3])\n    clients = list(map(int, stdin.split()[3:3 + C]))\n    streets = [tuple(map(int, stdin.split()[3 + C + i * 3: 3 + C + i * 3 + 3])) for i in range(M)]\n\n    return min_trucks(N, M, C, clients, streets)\n"
    },
    {
        "number": 3263,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    P = list(map(int, input_list[1].split()))\n    R = list(map(int, input_list[2].split()))\n    customers = [tuple(map(int, input_list[i].split())) for i in range(3, 3 + N)]\n\n    def can_serve(customer, time):\n        clothing_type = customer[0]\n        clothing_put_time = P[clothing_type - 1]\n        clothing_remove_time = R[clothing_type - 1]\n        return time >= customer[1] - clothing_put_time - clothing_remove_time\n\n    customers.sort(key=lambda x: x[1])\n    max_served = 0\n    for customer in customers:\n        if can_serve(customer, customer[1]):\n            max_served += 1\n\n    return str(max_served)"
    },
    {
        "number": 3264,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 1:\n        return \"1\"\n    elif N == 2:\n        return \"2\"\n    else:\n        return str((N * (N - 1)) // 2 + 1)\n\n\ninput_str = \"3\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3265,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[0:2])\n    adj_list = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n\n    # Calculate the probability of Alice and Bob being in B-ville after T days\n    def probability(T):\n        # Initialize the probability matrix\n        prob = [[0 for _ in range(N)] for _ in range(N)]\n        prob[0][0] = 1\n\n        # Calculate the probability of being in each place after T days\n        for i in range(N):\n            for j in range(N):\n                if adj_list[i][j] > 0:\n                    prob[i][j] = adj_list[i][j] / (1 + adj_list[i][j]) * prob[i][j]\n\n        # Calculate the probability of being in B-ville after T days\n        prob_b_ville = 0\n        for i in range(1, N):\n            prob_b_ville += prob[0][i] * prob[i][N - 1]\n\n        # Calculate the probability of being in B-ville after T days with a 95% probability\n        prob_b_ville_95 = prob_b_ville * 0.95\n\n        # Calculate the number of days T such that the probability of being in B-ville after T days is at least 0.95\n        T_95 = 0\n        while prob_b_ville_95 > 0:\n            prob_b_ville_95 -= prob[0][0] * prob[0][1] * prob[1][N - 1]\n            T_95 += 1\n\n        return T_95\n\n    # Find the smallest T such that the probability of being in B-ville after T days is at least 0.95\n    T = L\n    while T <= L + 9:\n        if probability(T) >= 95:\n            break\n        T += 1\n\n    if T > L + 9:\n        return \"-1\"\n    else:\n        return str(T)"
    },
    {
        "number": 3266,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, s, t = map(int, input_list[0].split())\n    edges = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Create a graph using an adjacency list\n    graph = [[] for _ in range(n)]\n    for u, v, c in edges:\n        graph[u].append((v, c))\n\n    # Find the maximum flow using the Ford-Fulkerson algorithm\n    def dfs(graph: list, visited: list, u: int, flow: int, path: list) -> bool:\n        if u == t:\n            return True\n        visited[u] = True\n        for v, c in graph[u]:\n            if not visited[v] and flow > 0 and c > 0:\n                if dfs(graph, visited, v, min(flow, c), path + [(u, v, c)]):\n                    return True\n        return False\n\n    max_flow = 0\n    path = []\n    while True:\n        visited = [False for _ in range(n)]\n        if not dfs(graph, visited, s, float('inf'), path):\n            break\n        for u, v, c in path:\n            graph[u].remove((v, c))\n            graph[v].remove((u, c))\n            graph[u].append((v, c - 1))\n            graph[v].append((u, c - 1))\n            max_flow += c - 1\n\n    # Output the solution\n    output = [str(n), str(max_flow), str(len(path))]\n    for u, v, c in path:\n        output.append(f\"{u} {v} {c}\")\n    return '\\n'.join(output)"
    },
    {
        "number": 3267,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    board = [list(line) for line in stdin.split('\\n')[1:R+1]]\n    mirko_spread = 0\n    slavko_spread = 0\n\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def get_neighbours(row, col):\n        return [(row - 1, col), (row + 1, col), (row, col - 1), (row, col + 1), (row - 1, col - 1), (row - 1, col + 1), (row + 1, col - 1), (row + 1, col + 1)]\n\n    def get_pieces(board, player):\n        pieces = []\n        for row in range(R):\n            for col in range(C):\n                if board[row][col] == player:\n                    pieces.append((row, col))\n        return pieces\n\n    def get_spread(board, pieces):\n        spread = 0\n        for piece in pieces:\n            for neighbour in get_neighbours(*piece):\n                if 0 <= neighbour[0] < R and 0 <= neighbour[1] < C and board[neighbour[0]][neighbour[1]] == '.':\n                    spread += distance(piece, neighbour)\n        return spread\n\n    mirko_pieces = get_pieces(board, 'M')\n    slavko_pieces = get_pieces(board, 'S')\n\n    mirko_spread = get_spread(board, mirko_pieces)\n    slavko_spread = get_spread(board, slavko_pieces)\n\n    return f\"{mirko_spread} {slavko_spread}\"\n"
    },
    {
        "number": 3268,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_label(vertex: int, labels: dict) -> str:\n        if vertex in labels:\n            return labels[vertex]\n        else:\n            return 'a'\n\n    def set_label(vertex: int, label: str, labels: dict) -> None:\n        labels[vertex] = label\n\n    def get_parent(vertex: int, parents: list) -> int:\n        return parents[vertex]\n\n    def get_children(vertex: int, children: list) -> list:\n        return children[vertex]\n\n    def get_big_branches(parents: list) -> list:\n        big_branches = []\n        for vertex in range(1, len(parents)):\n            if parents[vertex] == 0:\n                big_branches.append(vertex)\n        return big_branches\n\n    def get_small_branches(parents: list) -> list:\n        small_branches = []\n        for vertex in range(1, len(parents)):\n            if parents[vertex] != 0:\n                small_branches.append(vertex)\n        return small_branches\n\n    def get_giant_birds(parents: list) -> list:\n        giant_birds = []\n        for vertex in range(1, len(parents)):\n            if parents[vertex] == 0:\n                giant_birds.append(vertex)\n        return giant_birds\n\n    def get_tiny_birds(parents: list) -> list:\n        tiny_birds = []\n        for vertex in range(1, len(parents)):\n            if parents[vertex] != 0:\n                tiny_birds.append(vertex)\n        return tiny_birds\n\n    def get_elderberries(children: list) -> list:\n        elderberries = []\n        for vertex in range(1, len(children)):\n            if children[vertex] == []:\n                elderberries.append(vertex)\n        return elderberries\n\n    def get_controlled_area(vertex: int, parents: list, children: list) -> int:\n        if parents[vertex] == 0:\n            return vertex\n        else:\n            return get_controlled_area(parents[vertex], parents, children)\n\n    def get_label_change(labels: dict, vertex: int, new_label: str) -> None:\n        for child in get_children(vertex, children):\n            if labels[child] == new_label:\n                return False\n        for child in get_children(vertex, children):\n            set_label(child, new_label, labels)\n        return True\n\n    def get_min_label_change(labels: dict, tiny_birds: list, elderberries: list, new_label: str) -> int:\n        min_label_change = float('inf')\n        for tiny_bird in tiny_birds:\n            for elderberry in elderberries:\n                if get_label(tiny_bird, labels) == get_label(elderberry, labels) and get_label_change(labels, tiny_bird, new_label):\n                    min_label_change = min(min_label_change, get_controlled_area(tiny_bird, parents, children))\n        return min_label_change\n\n    n, *stdin = stdin.split()\n    n = int(n)\n    parents = [0] * (n + 1)\n    children = [[] for _ in range(n + 1)]\n    labels = {}\n\n    for i in range(1, n):\n        parent, *stdin = stdin.split()\n        parent = int(parent)\n        parents[i] = parent\n        children[parent].append(i)\n\n    for i in range(1, n):\n        if stdin:\n            label, *stdin = stdin.split()\n            label = label.lower()\n            labels[i] = label\n        else:\n            labels[i] = 'a'\n\n    big_branches = get_big_branches(parents)\n    small_branches = get_small_branches(parents)\n    giant_birds = get_giant_birds(parents)\n    tiny_bird"
    },
    {
        "number": 3269,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    total_sum = 0\n\n    for num in range(A, B + 1):\n        num_str = str(num)\n        max_len = max(len(num_str), len(str(B)))\n        num_str = num_str.zfill(max_len)\n        B_str = str(B).zfill(max_len)\n\n        for i in range(max_len):\n            total_sum += abs(int(num_str[i]) - int(B_str[i]))\n\n    return str(total_sum % 1000000007)\n"
    },
    {
        "number": 3270,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    n = int(input_list[0])\n    dictionary = set(input_list[1:n+1])\n    start_word = input_list[n+1]\n    end_word = input_list[n+2]\n\n    def is_valid(word: str) -> bool:\n        for i in range(len(word)):\n            for letter in \"abcdefghijklmnopqrstuvwxyz\":\n                if word[:i] + letter + word[i+1:] in dictionary:\n                    return True\n        return False\n\n    def bfs(start: str, end: str) -> int:\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            current, steps = queue.pop(0)\n            if current == end:\n                return steps\n            if current not in visited:\n                visited.add(current)\n                for i in range(len(current)):\n                    for letter in \"abcdefghijklmnopqrstuvwxyz\":\n                        new_word = current[:i] + letter + current[i+1:]\n                        if new_word in dictionary and new_word not in visited:\n                            queue.append((new_word, steps+1))\n        return -1\n\n    if start_word == end_word:\n        return 0, 0\n\n    for word in dictionary:\n        if is_valid(word):\n            steps = bfs(start_word, end_word)\n            if steps == -1:\n                continue\n            return word, steps\n\n    return 0, -1\n"
    },
    {
        "number": 3271,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, C = map(int, stdin.split())\n    MOD = 1000000007\n    dp = [1] * (N + 1)\n    for i in range(2, N + 1):\n        for j in range(1, i):\n            dp[i] = (dp[i] + dp[j]) % MOD\n    return dp[N]\n\n\ndef"
    },
    {
        "number": 3272,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split())\n    floorplan = stdin.split()[1:]\n    gargoyles = []\n    for i, row in enumerate(floorplan):\n        for j, cell in enumerate(row):\n            if cell in 'VH':\n                gargoyles.append((i, j))\n\n    def rotate(gargoyle):\n        i, j = gargoyle\n        floorplan[i] = floorplan[i][:j] + floorplan[i][j:].swapcase()\n\n    def is_valid(gargoyle):\n        i, j = gargoyle\n        if floorplan[i][j] not in 'VH':\n            return False\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if 0 <= i + di < n and 0 <= j + dj < m:\n                if floorplan[i + di][j + dj] in 'VH':\n                    return False\n        return True\n\n    def is_connected(gargoyle1, gargoyle2):\n        i1, j1 = gargoyle1\n        i2, j2 = gargoyle2\n        if i1 == i2 and j1 == j2:\n            return False\n        if i1 == i2:\n            return floorplan[i1][j1] == floorplan[i2][j2]\n        if j1 == j2:\n            return floorplan[i1][j1] == floorplan[i2][j2]\n        return False\n\n    def dfs(gargoyle, visited, count):\n        if visited[gargoyle]:\n            return count\n        visited[gargoyle] = True\n        for neighbor in [(gargoyle[0] - 1, gargoyle[1]), (gargoyle[0] + 1, gargoyle[1]), (gargoyle[0], gargoyle[1] - 1), (gargoyle[0], gargoyle[1] + 1)]:\n            if 0 <= neighbor[0] < n and 0 <= neighbor[1] < m and is_connected(gargoyle, neighbor) and not visited[neighbor]:\n                count = dfs(neighbor, visited, count)\n        return count + 1\n\n    def bfs(gargoyle, visited, count):\n        queue = [(gargoyle, 0)]\n        while queue:\n            gargoyle, depth = queue.pop(0)\n            if visited[gargoyle]:\n                continue\n            visited[gargoyle] = True\n            if depth >= count:\n                return depth + 1\n            for neighbor in [(gargoyle[0] - 1, gargoyle[1]), (gargoyle[0] + 1, gargoyle[1]), (gargoyle[0], gargoyle[1] - 1), (gargoyle[0], gargoyle[1] + 1)]:\n                if 0 <= neighbor[0] < n and 0 <= neighbor[1] < m and not visited[neighbor]:\n                    queue.append((neighbor, depth + 1))\n        return count\n\n    def min_rotations():\n        min_count = float('inf')\n        for gargoyle in gargoyles:\n            rotate(gargoyle)\n            visited = [False] * len(gargoyles)\n            count = 0\n            for i, g in enumerate(gargoyles):\n                if is_valid(g):\n                    count = max(count, dfs(g, visited, count))\n            min_count = min(min_count, count)\n            rotate(gargoyle)\n        return min_count\n\n    def max_rotations():\n        max_count = 0\n        for gargoyle in gargoyles:\n            visited = [False] * len(gargoyles)\n            count = 0\n            for i, g in enumerate(gargoyles):\n                if is_valid(g):\n                    count = max(count, bfs(g, visited, count))\n            max_count = max(max_count, count)\n        return max_count\n\n    if min_rotations() == float('inf'):\n        return -1\n    return max_rot"
    },
    {
        "number": 3273,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_suffix(s: str, prefix: str) -> str:\n        for i in range(len(prefix), len(s)):\n            if s[i:] == prefix:\n                return s[:i]\n        return \"\"\n\n    def find_prefix(s: str, suffix: str) -> str:\n        for i in range(len(suffix), len(s)):\n            if s[:i] == suffix:\n                return s[i:]\n        return \"\"\n\n    def is_valid(s1: str, s2: str) -> bool:\n        return s1.endswith(s2[:5]) and len(s2) >= 5\n\n    def build_reconstruction(fragments: List[str]) -> str:\n        reconstruction = \"\"\n        for i in range(len(fragments)):\n            if i == 0:\n                reconstruction += fragments[i]\n            else:\n                suffix = find_suffix(fragments[i - 1], fragments[i])\n                prefix = find_prefix(fragments[i], suffix)\n                reconstruction += suffix + prefix\n        return reconstruction\n\n    def find_maximal_sequence(fragments: List[str]) -> List[str]:\n        sequences = []\n        for i in range(len(fragments)):\n            for j in range(i + 1, len(fragments)):\n                if is_valid(fragments[i], fragments[j]):\n                    sequences.append([fragments[i], fragments[j]])\n        sequences.sort(key=lambda x: len(x), reverse=True)\n        return sequences\n\n    def reconstruct_text(fragments: List[str]) -> str:\n        reconstruction = build_reconstruction(fragments)\n        return reconstruction\n\n    def main(stdin: str) -> str:\n        fragments = stdin.strip().split(\"\\n\")\n        sequences = find_maximal_sequence(fragments)\n        if len(sequences) == 1:\n            return reconstruct_text(sequences[0])\n        else:\n            return \"AMBIGUOUS\"\n\n    return main(stdin)\n"
    },
    {
        "number": 3274,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    ships = []\n    for _ in range(m):\n        x1, x2, y = map(int, stdin.split()[2+_*3:2+_*3+3])\n        ships.append((x1, x2, y))\n\n    def is_safe(x, y):\n        for ship in ships:\n            if ship[0] <= x <= ship[1] and ship[2] == y:\n                return False\n        return True\n\n    def find_path(x, y, direction):\n        if direction == '+':\n            return (x+1, y+1)\n        elif direction == '-':\n            return (x-1, y+1)\n        else:\n            return (x, y+1)\n\n    def generate_path(x, y, direction):\n        path = ''\n        for _ in range(n):\n            if is_safe(x, y):\n                path += direction\n                x, y = find_path(x, y, direction)\n            else:\n                path += '-'\n                x, y = find_path(x, y, '-')\n            direction = '+' if direction == '-' else '-'\n        return path\n\n    if n % 2 == 0:\n        return \"impossible\"\n\n    x, y = 0, 0\n    direction = '+'\n    path = generate_path(x, y, direction)\n    return path"
    },
    {
        "number": 3275,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_purchases(a, b, c, d):\n        def count_combinations(n, k):\n            if k > n // 2:\n                k = n - k\n            result = 1\n            for i in range(1, k + 1):\n                result *= n - i + 1\n                result //= i\n            return result\n\n        def count_purchases_with_colored(a, b, c, d):\n            return count_combinations(a + b, c)\n\n        def count_purchases_with_black_and_white(a, b, c, d):\n            return count_combinations(a + b, d)\n\n        return (count_purchases_with_colored(a, b, c, d) * count_purchases_with_black_and_white(a, b, c, d)) % 10007\n\n    def process_changes(a, b, c, d, changes):\n        for change in changes:\n            a[change[0] - 1] = change[1]\n            b[change[0] - 1] = change[2]\n\n    N, C = map(int, stdin.readline().split())\n    a = list(map(int, stdin.readline().split()))\n    b = list(map(int, stdin.readline().split()))\n    Q = int(stdin.readline())\n    changes = [list(map(int, stdin.readline().split())) for _ in range(Q)]\n\n    process_changes(a, b, C, N, changes)\n    result = [count_purchases(a[i - 1], b[i - 1], C, N) for i in range(1, N + 1)]\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3276,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    art = [line.strip() for line in stdin.split('\\n')[1:N+1]]\n    board = [['W' for _ in range(M)] for _ in range(N)]\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def stamp(x, y, color):\n        for i in range(x, x+3):\n            for j in range(y, y+3):\n                if is_valid(i, j):\n                    board[i][j] = color\n\n    for i in range(N):\n        for j in range(M):\n            if art[i][j] == 'R':\n                stamp(i, j, 'R')\n            elif art[i][j] == 'G':\n                stamp(i, j, 'G')\n            elif art[i][j] == 'B':\n                stamp(i, j, 'B')\n\n    for row in board:\n        if 'W' in row:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3277,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, S = map(int, stdin.split()[:3])\n    A = list(map(int, stdin.split()[3:]))\n\n    min_changes = float('inf')\n    for i in range(N - K + 1):\n        sum_set = sum(A[i:i+K])\n        if sum_set != S:\n            min_changes = min(min_changes, abs(sum_set - S))\n\n    return str(min_changes)\n"
    },
    {
        "number": 3278,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    frogs = [(int(x), int(d)) for x, d in [line.split() for line in input_list[1:]]]\n    frogs.sort(key=lambda x: x[0])\n    max_tower_size = 0\n    max_tower_position = 0\n    current_position = 0\n    for frog in frogs:\n        if frog[0] > current_position:\n            current_position = frog[0]\n        if frog[1] > max_tower_size:\n            max_tower_size = frog[1]\n            max_tower_position = current_position\n    return f\"{max_tower_position} {max_tower_size}\"\n"
    },
    {
        "number": 3279,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    row_spec = [list(map(int, line.split())) for line in stdin.splitlines()[1:n+1]]\n    col_spec = [list(map(int, line.split())) for line in stdin.splitlines()[n+1:]]\n\n    # Check if there is a valid marking\n    def is_valid(marking):\n        for i in range(n):\n            for j in range(n):\n                if marking[i][j] == 1:\n                    if j > 0 and marking[i][j-1] == 1:\n                        return False\n                    if i > 0 and marking[i-1][j] == 1:\n                        return False\n        return True\n\n    # Generate all possible markings\n    def generate_markings():\n        markings = []\n        for row_marking in row_spec:\n            if row_marking[0] == 0:\n                markings.append([[0]*n for _ in range(n)])\n            else:\n                for col_marking in col_spec:\n                    if col_marking[0] == 0:\n                        marking = [[0]*n for _ in range(n)]\n                        for i in range(n):\n                            for j in range(n):\n                                if marking[i][j] == 0:\n                                    marking[i][j] = 1\n                        markings.append(marking)\n                    else:\n                        for i in range(n):\n                            for j in range(n):\n                                if row_marking[i] == 0 or col_marking[j] == 0:\n                                    marking = [[0]*n for _ in range(n)]\n                                    for k in range(n):\n                                        for l in range(n):\n                                            if marking[k][l] == 0:\n                                                marking[k][l] = 1\n                                    markings.append(marking)\n        return markings\n\n    # Find a valid marking\n    markings = generate_markings()\n    for marking in markings:\n        if is_valid(marking):\n            return ''.join([''.join(map(str, row)) for row in marking]) + '\\n' + ''.join([''.join(map(str, col)) for col in marking.T])"
    },
    {
        "number": 3280,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    shows = [tuple(map(int, stdin.split()[2*i+2:2*i+4])) for i in range(n)]\n    shows.sort(key=lambda x: x[1])\n    count = 0\n    i = 0\n    while i < n:\n        if shows[i][1] <= shows[i][0] + count*k:\n            count += 1\n            i += 1\n        else:\n            break\n    return str(count)\n"
    },
    {
        "number": 3281,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_turning_angle(path: List[Tuple[int, int]]) -> float:\n        total_angle = 0\n        for i in range(len(path) - 1):\n            dx = path[i + 1][0] - path[i][0]\n            dy = path[i + 1][1] - path[i][1]\n            total_angle += atan2(dy, dx)\n        return degrees(total_angle)\n\n    def is_valid_path(path: List[Tuple[int, int]], distance: int) -> bool:\n        return all(distance >= sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) for (x1, y1), (x2, y2) in zip(path, path[1:]))\n\n    def find_shortest_path(junctions: List[Tuple[int, int]], roads: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]:\n        graph = defaultdict(set)\n        for a, b, x, y in roads:\n            graph[a].add((b, x, y))\n            graph[b].add((a, -x, -y))\n\n        def dfs(node: int, visited: Set[int], path: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n            if node == 1:\n                return path\n            for neighbor, dx, dy in graph[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    path.append((dx, dy))\n                    result = dfs(neighbor, visited, path)\n                    if result:\n                        return result\n                    path.pop()\n                    visited.remove(neighbor)\n            return []\n\n        return dfs(1, {1}, [(0, 0)])\n\n    J, R, D = map(int, stdin.split()[:3])\n    junctions = [tuple(map(int, stdin.split()[3 + i * 2: 3 + (i + 1) * 2])) for i in range(J)]\n    roads = [tuple(map(int, stdin.split()[3 + J * 2 + i * 2: 3 + J * 2 + (i + 1) * 2])) for i in range(R)]\n\n    path = find_shortest_path(junctions, roads)\n    if not is_valid_path(path, D):\n        return \"Impossible\"\n\n    return str(get_turning_angle(path))\n"
    },
    {
        "number": 3282,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P = int(stdin)\n    bills = set()\n    count = 0\n    for beverage in range(1, P):\n        for main_dish in range(beverage + 1, P):\n            if beverage < main_dish:\n                for total in range(beverage + main_dish, P):\n                    if (str(beverage) + str(main_dish) + str(total)) not in bills:\n                        bills.add(str(beverage) + str(main_dish) + str(total))\n                        count += 1\n    bills = sorted(list(bills))\n    if len(bills) > 5000:\n        bills = bills[:5000]\n    return str(count) + \"\\n\" + \"\\n\".join(bills)\n"
    },
    {
        "number": 3283,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, r = map(int, stdin.split())\n    gems = [1] * n\n    for _ in range(d):\n        gems = [2 if random.random() < 0.5 else 1 for gem in gems]\n    gems.sort(reverse=True)\n    expected_gems = sum(gems[:r])\n    return f\"{expected_gems:.6f}\""
    },
    {
        "number": 3284,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    count = 0\n    for x in range(a, b + 1):\n        for y in range(c, d + 1):\n            if gcd(x, y) == 1:\n                count += 1\n    return str(count)\n\ndef"
    },
    {
        "number": 3285,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A1, m = map(int, stdin.split())\n    A = [A1]\n    d = 1\n    n = 1\n    while A[-1] + d <= m:\n        A.append(A[-1] + d)\n        n += 1\n    for i in range(n):\n        if A[i] == m:\n            return i + 1\n        for j in range(i):\n            if A[i] - A[j] == m:\n                return i + 1\n    return -1\n"
    },
    {
        "number": 3286,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_vowel(char: str) -> bool:\n        return char in \"aeiou\"\n\n    def transform_char(char: str) -> str:\n        if is_vowel(char):\n            return char\n        else:\n            return char + char\n\n    def transform_word(word: str) -> str:\n        return \"\".join(transform_char(char) for char in word)\n\n    def count_ways(encrypted_word: str) -> int:\n        decrypted_word = transform_word(encrypted_word)\n        count = 1\n        for i in range(len(encrypted_word)):\n            if encrypted_word[i] != decrypted_word[i]:\n                count *= 2\n        return count\n\n    encrypted_word = stdin\n    return str(count_ways(encrypted_word) % 1000009)"
    },
    {
        "number": 3287,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *x = map(int, stdin.split())\n    x = [0] + x\n    loot = sum(x[i] * (2**i) for i in range(k))\n    thieves_share = loot // 2\n    min_loot = sum(thieves_share // (2**i) for i in range(k))\n    return str(min_loot % (10**9 + 7))\n"
    },
    {
        "number": 3288,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k == 1:\n        return \"a\" * n\n    elif k == 2:\n        if n % 2 == 0:\n            return \"ab\" * (n // 2)\n        else:\n            return \"ab\" * ((n // 2) + 1)\n    elif k == 3:\n        if n % 3 == 0:\n            return \"abc\" * (n // 3)\n        elif n % 3 == 1:\n            return \"ab\" + \"c\" * ((n // 3) + 1)\n        else:\n            return \"ab\" + \"c\" * ((n // 3) + 1) + \"b\"\n    else:\n        return -1\n"
    },
    {
        "number": 3289,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *data = stdin.split('\\n')\n    n = int(n)\n    data = [list(map(int, line.split())) for line in data]\n\n    def cluster_size(S, T):\n        data.sort(key=lambda x: x[0] * S + x[1] * T)\n        j = 0\n        k = 0\n        while k < n:\n            if data[k][2] == 1:\n                k += 1\n                while k < n and data[k][2] == 1:\n                    k += 1\n                j = k - 1\n            else:\n                j += 1\n            k = j + 1\n        return k - j\n\n    min_size = float('inf')\n    for S in range(1, 100001):\n        for T in range(1, 100001):\n            size = cluster_size(S, T)\n            min_size = min(min_size, size)\n\n    return str(min_size)\n"
    },
    {
        "number": 3290,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, E, D = map(int, stdin.split()[:3])\n    e = list(map(int, stdin.split()[3:3+E]))\n    d = list(map(int, stdin.split()[3+E:]))\n\n    def find_winner(hands: list, e: list, d: list) -> int:\n        def discard_cards(hand: list, n: int) -> list:\n            if len(hand) <= n:\n                return []\n            else:\n                return hand[:n]\n\n        def explode_kittens(hand: list, e: list, d: list) -> tuple:\n            if not e:\n                return hand, e, d\n            else:\n                index = e.index(min(e))\n                e.pop(index)\n                return hand[index+1:], e, d\n\n        def defuse_kittens(hand: list, d: list) -> tuple:\n            if not d:\n                return hand, d\n            else:\n                index = d.index(min(d))\n                d.pop(index)\n                return hand[index+1:], d\n\n        def play_turn(hand: list, e: list, d: list) -> tuple:\n            if not hand:\n                return hand, e, d\n            else:\n                card = hand.pop(0)\n                if card == 0:\n                    return hand, e, d\n                elif card == 1:\n                    return hand, e, d\n                elif card == 2:\n                    return hand, e, d\n                elif card == 3:\n                    return hand, e, d\n                elif card == 4:\n                    return hand, e, d\n                elif card == 5:\n                    return hand, e, d\n                elif card == 6:\n                    return hand, e, d\n                elif card == 7:\n                    return hand, e, d\n                elif card == 8:\n                    return hand, e, d\n                elif card == 9:\n                    return hand, e, d\n                elif card == 10:\n                    return hand, e, d\n                elif card == 11:\n                    return hand, e, d\n                elif card == 12:\n                    return hand, e, d\n                elif card == 13:\n                    return hand, e, d\n                elif card == 14:\n                    return hand, e, d\n                elif card == 15:\n                    return hand, e, d\n                elif card == 16:\n                    return hand, e, d\n                elif card == 17:\n                    return hand, e, d\n                elif card == 18:\n                    return hand, e, d\n                elif card == 19:\n                    return hand, e, d\n                elif card == 20:\n                    return hand, e, d\n                elif card == 21:\n                    return hand, e, d\n                elif card == 22:\n                    return hand, e, d\n                elif card == 23:\n                    return hand, e, d\n                elif card == 24:\n                    return hand, e, d\n                elif card == 25:\n                    return hand, e, d\n                elif card == 26:\n                    return hand, e, d\n                elif card == 27:\n                    return hand, e, d\n                elif card == 28:\n                    return hand, e, d\n                elif card == 29:\n                    return hand, e, d\n                elif card == 30:\n                    return hand, e, d\n                elif card == 31:\n                    return hand, e, d\n                elif card == 32:\n                    return hand, e, d\n                elif card == 33:\n                    return hand, e, d\n                elif card == 34:\n                    return hand, e, d\n                elif card == 35:\n                    return hand, e, d\n                elif card == 36:\n                    return hand, e, d\n                elif card == 37:\n                    return hand, e, d\n                elif card == 38:\n                    return hand, e, d\n                el"
    },
    {
        "number": 3291,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    a, b = map(int, input_data[0].split())\n    c, d = map(int, input_data[1].split())\n\n    def splitter_count(ratio):\n        a, b = ratio\n        return min(a, b)\n\n    def splitter_ratio(ratio):\n        a, b = ratio\n        return a / (a + b)\n\n    def build_network(ratio, splitter_count):\n        network = []\n        for i in range(splitter_count):\n            network.append((-2, -1))\n        network.append((0, -2))\n        return network\n\n    splitter_count_a = splitter_count((a, b))\n    splitter_count_c = splitter_count((c, d))\n\n    network_a = build_network((a, b), splitter_count_a)\n    network_c = build_network((c, d), splitter_count_c)\n\n    output = f\"{splitter_count_a}\\n\"\n    for i in range(splitter_count_a):\n        output += f\"{network_a[i][0]} {network_a[i][1]}\\n\"\n\n    output += f\"{splitter_count_c}\\n\"\n    for i in range(splitter_count_c):\n        output += f\"{network_c[i][0]} {network_c[i][1]}\\n\"\n\n    return output"
    },
    {
        "number": 3292,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(names: list) -> bool:\n        for i in range(len(names) - 1):\n            if names[i][:len(names[i]) - len(names[i + 1])] != names[i + 1][:len(names[i]) - len(names[i + 1])]:\n                return False\n        return True\n\n    N = int(stdin.splitlines()[0])\n    names = sorted(stdin.splitlines()[1:])\n    count = 0\n\n    for i in range(1, len(names) + 1):\n        for j in range(len(names) - i + 1):\n            if is_valid(names[j:j + i]):\n                count += 1\n\n    return str(count % 1000000007)\n"
    },
    {
        "number": 3293,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_profit(buy_position: int, buy_price: int, market_price: int, snack_count: int) -> int:\n        return market_price - buy_price\n\n    def get_buy_position(position: int, f: Callable[[int], int]) -> int:\n        return f(position)\n\n    def get_max_profit(buy_positions: List[int], buy_prices: List[int], market_prices: List[int], snack_counts: List[int], f: Callable[[int], int]) -> int:\n        max_profit = 0\n        for i in range(len(buy_positions)):\n            buy_position = get_buy_position(i + 1, f)\n            profit = get_profit(buy_position, buy_prices[i], market_prices[i], snack_counts[i])\n            max_profit = max(max_profit, profit)\n        return max_profit\n\n    def get_f(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i\n        return f\n\n    def get_g(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 1\n        return f\n\n    def get_h(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 2\n        return f\n\n    def get_i(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 3\n        return f\n\n    def get_j(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 4\n        return f\n\n    def get_k(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 5\n        return f\n\n    def get_l(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 6\n        return f\n\n    def get_m(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 7\n        return f\n\n    def get_n(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 8\n        return f\n\n    def get_o(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 9\n        return f\n\n    def get_p(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 10\n        return f\n\n    def get_q(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 11\n        return f\n\n    def get_r(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 12\n        return f\n\n    def get_s(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 13\n        return f\n\n    def get_t(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 14\n        return f\n\n    def get_u(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 15\n        return f\n\n    def get_v(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 16\n        return f\n\n    def get_w(n: int) -> Callable[[int], int]:\n        def f(i: int) -> int:\n            return i + 17\n        return f"
    },
    {
        "number": 3294,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def min_distance(contour):\n        min_dist = float('inf')\n        for i in range(len(contour)):\n            for j in range(i + 1, len(contour)):\n                dist = distance(contour[i], contour[j])\n                if dist < min_dist:\n                    min_dist = dist\n        return min_dist\n\n    def min_slanted_distance(contour):\n        min_dist = float('inf')\n        for i in range(len(contour)):\n            for j in range(i + 1, len(contour)):\n                dist = distance(contour[i], contour[j])\n                if dist < min_dist:\n                    min_dist = dist\n                for k in range(len(contour)):\n                    if k != i and k != j:\n                        dist = distance(contour[i], contour[k]) + distance(contour[j], contour[k])\n                        if dist < min_dist:\n                            min_dist = dist\n        return min_dist\n\n    lines = stdin.split('\\n')\n    N = int(lines[0])\n    contours = []\n    for i in range(1, N + 1):\n        H0, H1, M = map(int, lines[i].split())\n        contour = []\n        for j in range(i * 2 + 1, i * 2 + 1 + M):\n            x, y = map(int, lines[j].split())\n            contour.append((x, y))\n        contours.append((H0, H1, contour))\n\n    min_dist = float('inf')\n    for H0, H1, contour in contours:\n        dist = min_slanted_distance(contour)\n        if dist < min_dist:\n            min_dist = dist\n\n    return f\"{min_dist:.6f}\"\n"
    },
    {
        "number": 3295,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Q, *input_data = stdin.split('\\n')\n    Q = int(Q)\n    input_data = [list(map(int, line.split())) for line in input_data]\n\n    def is_happy(num: int) -> bool:\n        if num <= M:\n            return True\n        if num == 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def count_happy_numbers(arr: list) -> int:\n        return sum(is_happy(num) for num in arr)\n\n    def find_initial_number(K: int, L: int, M: int) -> int:\n        if L == 0:\n            return 1\n        if L == 1:\n            return 2\n        if L == 2:\n            return 3\n        if L == 3:\n            return 4\n        if L == 4:\n            return 5\n        if L == 5:\n            return 6\n        if L == 6:\n            return 7\n        if L == 7:\n            return 8\n        if L == 8:\n            return 9\n        if L == 9:\n            return 10\n        if L == 10:\n            return 11\n        if L == 11:\n            return 12\n        if L == 12:\n            return 13\n        if L == 13:\n            return 14\n        if L == 14:\n            return 15\n        if L == 15:\n            return 16\n        if L == 16:\n            return 17\n        if L == 17:\n            return 18\n        if L == 18:\n            return 19\n        if L == 19:\n            return 20\n        if L == 20:\n            return 21\n        if L == 21:\n            return 22\n        if L == 22:\n            return 23\n        if L == 23:\n            return 24\n        if L == 24:\n            return 25\n        if L == 25:\n            return 26\n        if L == 26:\n            return 27\n        if L == 27:\n            return 28\n        if L == 28:\n            return 29\n        if L == 29:\n            return 30\n        if L == 30:\n            return 31\n        if L == 31:\n            return 32\n        if L == 32:\n            return 33\n        if L == 33:\n            return 34\n        if L == 34:\n            return 35\n        if L == 35:\n            return 36\n        if L == 36:\n            return 37\n        if L == 37:\n            return 38\n        if L == 38:\n            return 39\n        if L == 39:\n            return 40\n        if L == 40:\n            return 41\n        if L == 41:\n            return 42\n        if L == 42:\n            return 43\n        if L == 43:\n            return 44\n        if L == 44:\n            return 45\n        if L == 45:\n            return 46\n        if L == 46:\n            return 47\n        if L == 47:\n            return 48\n        if L == 48:\n            return 49\n        if L == 49:\n            return 50\n        if L == 50:\n            return 51\n        if L == 51:\n            return 52\n        if L == 52:\n            return 53\n        if L == 53:\n            return 54\n        if L == 54:\n            return 55\n        if L == 55:\n            return 56\n        if L == 56:\n            return 57\n       "
    },
    {
        "number": 3296,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    if K == 1:\n        return 1\n    if K == N:\n        return 1\n    if K == 2:\n        return 2\n    if K == 3:\n        return 3\n    if K == 4:\n        return 6\n    if K == 5:\n        return 10\n    if K == 6:\n        return 15\n    if K == 7:\n        return 21\n    if K == 8:\n        return 28\n    if K == 9:\n        return 36\n    if K == 10:\n        return 45\n    if K == 11:\n        return 55\n    if K == 12:\n        return 66\n    if K == 13:\n        return 78\n    if K == 14:\n        return 91\n    if K == 15:\n        return 105\n    if K == 16:\n        return 120\n    if K == 17:\n        return 136\n    if K == 18:\n        return 153\n    if K == 19:\n        return 172\n    if K == 20:\n        return 192\n    if K == 21:\n        return 214\n    if K == 22:\n        return 240\n    if K == 23:\n        return 268\n    if K == 24:\n        return 300\n    if K == 25:\n        return 336\n    if K == 26:\n        return 375\n    if K == 27:\n        return 416\n    if K == 28:\n        return 458\n    if K == 29:\n        return 503\n    if K == 30:\n        return 549\n    if K == 31:\n        return 600\n    if K == 32:\n        return 653\n    if K == 33:\n        return 709\n    if K == 34:\n        return 770\n    if K == 35:\n        return 835\n    if K == 36:\n        return 903\n    if K == 37:\n        return 974\n    if K == 38:\n        return 1047\n    if K == 39:\n        return 1123\n    if K == 40:\n        return 1202\n    if K == 41:\n        return 1284\n    if K == 42:\n        return 1369\n    if K == 43:\n        return 1457\n    if K == 44:\n        return 1547\n    if K == 45:\n        return 1639\n    if K == 46:\n        return 1733\n    if K == 47:\n        return 1830\n    if K == 48:\n        return 1929\n    if K == 49:\n        return 2031\n    if K == 50:\n        return 2135\n    if K == 51:\n        return 2241\n    if K == 52:\n        return 2349\n    if K == 53:\n        return 2460\n    if K == 54:\n        return 2575\n    if K == 55:\n        return 2693\n    if K == 56:\n        return 2815\n    if K == 57:\n        return 2941\n    if K == 58:\n        return 3069\n    if K == 59:\n        return 3199\n    if K == 60:\n        return 3332\n    if K == 61:\n        return 3466\n    if K == 62:\n        return 3595\n    if K == 6"
    },
    {
        "number": 3297,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    puzzle = stdin.strip()\n    words = puzzle.split('=')\n    letters = set(''.join(words))\n    if len(letters) == 1:\n        return \"impossible\"\n    if '0' in letters:\n        return \"impossible\"\n    if len(letters) > 10:\n        return \"impossible\"\n\n    digits = list(range(10))\n    digits.remove(0)\n    letters.remove('0')\n    letter_to_digit = {}\n\n    for letter in sorted(letters):\n        for digit in digits:\n            if digit not in letter_to_digit.values():\n                letter_to_digit[letter] = digit\n                break\n\n    if len(letter_to_digit) < len(letters):\n        return \"impossible\"\n\n    for word in words:\n        for letter in word:\n            if letter not in letter_to_digit:\n                return \"impossible\"\n\n    result = []\n    for word in words:\n        for letter in word:\n            result.append(str(letter_to_digit[letter]))\n        result.append('+')\n    result[-1] = '='\n\n    return ''.join(result)\n"
    },
    {
        "number": 3298,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_sorted(sequence):\n        for i in range(len(sequence) - 1):\n            if sequence[i] > sequence[i + 1]:\n                return False\n        return True\n\n    def count_unsorted_sequences(sequence):\n        count = 1\n        for perm in itertools.permutations(sequence):\n            if not is_sorted(perm):\n                count += 1\n        return count\n\n    count = count_unsorted_sequences(a)\n    return str(count % (10**9 + 9))\n"
    },
    {
        "number": 3299,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_magic_checkerboard(board: list) -> bool:\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 0:\n                    continue\n                if j > 0 and board[i][j] <= board[i][j - 1]:\n                    return False\n                if i > 0 and board[i][j] <= board[i - 1][j]:\n                    return False\n                if j > 0 and i > 0 and (board[i][j] % 2 == board[i - 1][j] % 2 or board[i][j] % 2 == board[i][j - 1] % 2):\n                    return False\n        return True\n\n    def min_sum(board: list) -> int:\n        def dfs(board: list, row: int, col: int, visited: set) -> int:\n            if row == len(board) and col == len(board[0]):\n                return sum(sum(row for row in board) for board in boards)\n            if (row, col) in visited:\n                return 0\n            visited.add((row, col))\n            min_sum = float('inf')\n            for i in range(len(board[row])):\n                if board[row][i] == 0:\n                    board[row][i] = 1\n                    min_sum = min(min_sum, dfs(board, row, col + 1, visited))\n                    board[row][i] = 0\n            return min_sum\n\n        boards = [board]\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 0:\n                    new_board = [[board[x][y] for y in range(len(board[0]))] for x in range(len(board))]\n                    new_board[i][j] = 1\n                    boards.append(new_board)\n        min_sum = float('inf')\n        for board in boards:\n            if is_valid_magic_checkerboard(board):\n                min_sum = min(min_sum, dfs(board, 0, 0, set()))\n        return min_sum\n\n    n, m = map(int, stdin.split()[:2])\n    board = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n    if is_valid_magic_checkerboard(board):\n        return min_sum(board)\n    else:\n        return -1\n"
    },
    {
        "number": 3300,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N = int(input_data[0])\n    cheetahs = [tuple(map(int, line.split())) for line in input_data[1:]]\n    cheetahs.sort(key=lambda x: x[0])\n\n    min_length = float('inf')\n    for i in range(N):\n        for j in range(i + 1, N):\n            distance = cheetahs[j][0] - cheetahs[i][0]\n            if distance < min_length:\n                min_length = distance\n\n    return f\"{min_length:.3f}\"\n"
    },
    {
        "number": 3301,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, P, X, Y, M = map(int, stdin.split()[:5])\n    banks = list(map(int, stdin.split()[5:5+M]))\n    if X not in banks or Y not in banks:\n        return \"Impossible\"\n    if X == Y:\n        return \"Impossible\"\n    partnerships = []\n    for _ in range(P):\n        a, b, c = map(int, stdin.split()[5+M:5+M+P])\n        if a == X or b == Y:\n            partnerships.append((a, b, c))\n    partnerships.sort(key=lambda x: x[2], reverse=True)\n    for i in range(len(partnerships)):\n        a, b, c = partnerships[i]\n        if a == X and b == Y:\n            return c\n    return \"Infinity\""
    },
    {
        "number": 3302,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, *palette = map(int, stdin.split())\n    if n < 1 or n > 16 or p < 1 or p > n:\n        return \"impossible\"\n\n    def is_valid_code(code: List[int]) -> bool:\n        for i in range(1, len(code)):\n            if sum(1 for j in range(n) if (code[i] >> j) & 1 != (code[i - 1] >> j) & 1) != 1:\n                return False\n        return True\n\n    def generate_code(code: List[int]) -> List[int]:\n        if len(code) == 2 ** n:\n            return code\n        for i in range(2 ** n):\n            if not any(code[i] >> j & 1 == code[i - 1] >> j & 1 for j in range(n)):\n                code.append(code[i] ^ (1 << palette[p - 1]))\n                return generate_code(code)\n        return []\n\n    code = [0] * (2 ** n)\n    if is_valid_code(code):\n        return generate_code(code)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3303,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    num1, num2 = stdin.split('\\n')\n    num1 = int(num1)\n    num2 = int(num2)\n\n    # First method\n    carry = 0\n    while num1 > 0 or num2 > 0:\n        if num1 % 10 + num2 % 10 + carry > 9:\n            carry = 1\n        else:\n            carry = 0\n        num1 //= 10\n        num2 //= 10\n\n    # Second method\n    count = 0\n    while num1 != num2:\n        if num1 < num2:\n            num1 += 1\n            count += 1\n        else:\n            num2 += 1\n            count += 1\n\n    return str(count)"
    },
    {
        "number": 3304,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, P, V = map(int, stdin.split('\\n'))\n    elves = sorted(range(N), key=lambda i: V[i], reverse=True)\n    dwarves = sorted(range(N), key=lambda i: P[i], reverse=True)\n    victories = 0\n    for elf in elves:\n        if elf == A[elf-1]:\n            victories += 1\n        else:\n            for dwarf in dwarves:\n                if dwarf == A[elf-1]:\n                    victories += 1\n                    break\n    return str(victories)\n"
    },
    {
        "number": 3305,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def count_almost_palindromic_substrings(s: str) -> int:\n        count = 0\n        for i in range(len(s)):\n            for j in range(i + 1, len(s) + 1):\n                substring = s[i:j]\n                if is_palindrome(substring) or (len(substring) > 1 and substring[0] == substring[-1]):\n                    count += 1\n        return count\n\n    def almost_palindrome_rich(s: str, L: int, R: int) -> int:\n        return count_almost_palindromic_substrings(s[L - 1:R])\n\n    N, Q = map(int, stdin.readline().split())\n    S = stdin.readline().strip()\n    for _ in range(Q):\n        L, R = map(int, stdin.readline().split())\n        print(almost_palindrome_rich(S, L, R))\n"
    },
    {
        "number": 3306,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    N, M = map(int, input_data[0].split())\n    detectors = [list(map(int, line.split())) for line in input_data[1:]]\n\n    phone_calls = sum(detectors[i][1] for i in range(N))\n    return str(phone_calls)"
    },
    {
        "number": 3307,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def area(x, y):\n        return 0.5 * abs(sum(x * (np.roll(y, -i) - y) for i in range(len(x))))\n\n    def intersection(x1, y1, x2, y2, x3, y3, x4, y4):\n        def orientation(x1, y1, x2, y2, x3, y3):\n            return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1)\n\n        def intersect(x1, y1, x2, y2, x3, y3, x4, y4):\n            d = orientation(x1, y1, x2, y2, x3, y3)\n            e = orientation(x1, y1, x2, y2, x4, y4)\n            f = orientation(x3, y3, x4, y4, x1, y1)\n            g = orientation(x3, y3, x4, y4, x2, y2)\n\n            if d != 0 and e != 0 and f != 0 and g != 0 and d * e * f * g < 0:\n                t = (float(e) * x1 - float(d) * x2 + y2 - y1) / (float(d) * e - float(g) * f)\n                return t, (float(d) * t + x1, float(d) * t + y1)\n            else:\n                return None\n\n        t, p = intersect(x1, y1, x2, y2, x3, y3, x4, y4)\n        if t is not None and 0 <= t <= 1:\n            return p\n        else:\n            return None\n\n    def max_area(x, y):\n        max_area = 0\n        for i in range(len(x)):\n            for j in range(i + 1, len(x)):\n                area_ij = 0.5 * abs(sum(x * (np.roll(y, -i) - y) for i in range(len(x))))\n                if area_ij > max_area:\n                    max_area = area_ij\n        return max_area\n\n    def min_area(x, y):\n        min_area = float('inf')\n        for i in range(len(x)):\n            for j in range(i + 1, len(x)):\n                area_ij = 0.5 * abs(sum(x * (np.roll(y, -i) - y) for i in range(len(x))))\n                if area_ij < min_area:\n                    min_area = area_ij\n        return min_area\n\n    def max_corn_area(x, y, x1, y1, x2, y2):\n        max_area = 0\n        for i in range(len(x)):\n            for j in range(i + 1, len(x)):\n                p1 = intersection(x[i], y[i], x[j], y[j], x1, y1, x2, y2)\n                p2 = intersection(x[j], y[j], x[i], y[i], x1, y1, x2, y2)\n                if p1 is not None and p2 is not None:\n                    area_ij = 0.5 * abs(sum(x * (np.roll(y, -i) - y) for i in range(len(x))))\n                    area_ij += 0.5 * abs(sum(x * (np.roll(y, -j) - y) for j in range(len(x))))\n                    if area_ij > max_area:\n                        max_area = area_ij\n        return max_area\n\n    def min_corn_area(x, y, x1, y1, x2, y2):\n        min_area = float('inf')\n        for i in range(len(x)):\n            for j in range(i + 1, len(x)):\n                p1 = intersection(x[i], y[i], x[j], y[j], x1, y1, x2, y2)\n                p2 = intersection(x[j],"
    },
    {
        "number": 3308,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def is_inside(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(n + 1):\n            p2x, p2y = polygon[i % n]\n            if cross_product(point, (p1x, p1y), (p2x, p2y)) > 0:\n                inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def polygon_area(polygon):\n        n = len(polygon)\n        area = 0\n        p1x, p1y = polygon[0]\n        for i in range(n):\n            p2x, p2y = polygon[i]\n            area += p1x * p2y - p2x * p1y\n            p1x, p1y = p2x, p2y\n        return abs(area) / 2\n\n    n = int(stdin.splitlines()[0])\n    polygon = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n\n    center = (sum(x for x, y in polygon) / n, sum(y for x, y in polygon) / n)\n    max_distance = max(abs(x - center[0]) + abs(y - center[1]) for x, y in polygon)\n\n    result = 0\n    for x in range(-max_distance, max_distance + 1):\n        for y in range(-max_distance, max_distance + 1):\n            if is_inside((x, y), polygon):\n                result += 1\n\n    return f\"{polygon_area(polygon) * result:.10f}\"\n"
    },
    {
        "number": 3309,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K, C = map(int, input_list[0].split())\n    A = list(map(int, input_list[1].split()))\n\n    def count_colors(start, end):\n        colors = set()\n        for i in range(start, end + 1):\n            colors.add(A[i])\n        return len(colors)\n\n    def count_sectors(start, end):\n        return end - start + 1\n\n    def is_valid(start, end):\n        return count_colors(start, end) >= C and count_sectors(start, end) >= K\n\n    max_count = 0\n    for i in range(N - K + 1):\n        for j in range(i + K - 1, N):\n            if is_valid(i, j):\n                max_count += 1\n\n    return str(max_count)\n"
    },
    {
        "number": 3310,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, g, t = map(int, input_list[0].split())\n    capacities = list(map(int, input_list[1].split()))\n\n    def expected_occupancy(n, g, t, capacities):\n        total_capacity = sum(capacities)\n        expected_groups = sum([(g ** i) * (n - g) ** (t - i) / (n ** t) for i in range(t + 1)])\n        return expected_groups * total_capacity\n\n    result = expected_occupancy(n, g, t, capacities)\n    return f\"{result:.6f}\""
    },
    {
        "number": 3311,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = 1\n    for i in range(n-1):\n        result *= m\n        result %= m\n    return str(result)\n\ndef"
    },
    {
        "number": 3312,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, E, X_S, Y_S, C = map(int, input_list[0].split())\n    can_list = [list(map(int, can.split())) for can in input_list[1:]]\n\n    def get_adjacent_cells(x, y):\n        return [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\n    def get_can_score(x, y, can_time):\n        if can_time <= 0:\n            return 0\n        adjacent_cells = get_adjacent_cells(x, y)\n        adjacent_cells.remove((X_S, Y_S))\n        return sum(1 for cell in adjacent_cells if cell in can_list)\n\n    max_score = 0\n    for can in can_list:\n        x, y, can_time = can\n        max_score += get_can_score(x, y, can_time)\n\n    return str(max_score)"
    },
    {
        "number": 3313,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, r, w, h = map(int, stdin.split()[:4])\n    gems = [tuple(map(int, stdin.split()[4:][i:i+2])) for i in range(0, n*2, 2)]\n    gems.sort(key=lambda x: x[1])\n\n    max_gems = 0\n    for gem in gems:\n        x, y = gem\n        if y <= h:\n            max_gems += 1\n        else:\n            break\n\n    return str(max_gems)\n"
    },
    {
        "number": 3314,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    wheels = [list(wheel) for wheel in stdin.split(\"\\n\")]\n    n = len(wheels[0])\n    for i in range(n):\n        if not all(w[i] in \"ABC\" for w in wheels):\n            return \"-1\"\n    for i in range(n):\n        if not all(w[i] == wheels[0][i] for w in wheels):\n            return \"-1\"\n    for i in range(n):\n        if not all(w[i] == wheels[1][i] for w in wheels):\n            return \"-1\"\n    for i in range(n):\n        if not all(w[i] == wheels[2][i] for w in wheels):\n            return \"-1\"\n    for i in range(n):\n        if not all(w[i] == \"A\" for w in wheels):\n            return \"-1\"\n    for i in range(n):\n        if not all(w[i] == \"B\" for w in wheels):\n            return \"-1\"\n    for i in range(n):\n        if not all(w[i] == \"C\" for w in wheels):\n            return \"-1\"\n    return \"2\"\n"
    },
    {
        "number": 3315,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    strings = stdin.split('\\n')[1:]\n    subseq = set()\n    for i in range(N):\n        for j in range(i+1, N):\n            if strings[j].startswith(strings[i]) and strings[j].endswith(strings[i]):\n                subseq.add((i, j))\n    return str(max(len(set(range(N)).difference(set(x for x, y in subseq)))) - 1)\n"
    },
    {
        "number": 3316,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, t, p = map(int, stdin.split())\n    total_tickets = n * t\n    group_tickets = p * t\n    if total_tickets < group_tickets:\n        return \"0\"\n    else:\n        return str(group_tickets / total_tickets)\n"
    },
    {
        "number": 3317,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    s = input_list[0]\n    q = int(input_list[1])\n    queries = [tuple(map(int, input_list[i+2].split())) for i in range(q)]\n\n    def is_identical_sequence(i: int, j: int) -> int:\n        if s[i] != s[j]:\n            return 0\n        if s[i].isupper() != s[j].isupper():\n            return 0\n        if i == j:\n            return 1\n        return is_identical_sequence(i+1, j+1) + 1\n\n    result = []\n    for i, j in queries:\n        result.append(is_identical_sequence(i, j))\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3318,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, D = map(int, input_list[0].split())\n    tree = [0] * (N + 1)\n    for i in range(1, N):\n        tree[i] = int(input_list[i])\n\n    def dfs(node: int, visited: set, distance: int) -> int:\n        if distance > D:\n            return 0\n        if node in visited:\n            return 0\n        visited.add(node)\n        return 1 + dfs(tree[node], visited, distance + 1) + dfs(node - 1, visited, distance + 1)\n\n    return str(dfs(1, set(), 0))\n"
    },
    {
        "number": 3319,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n_x, n_y, n_z, n = map(int, input_list[0].split())\n    planetoids = []\n    for i in range(1, n+1):\n        mass, x, y, z, v_x, v_y, v_z = map(int, input_list[i].split())\n        planetoids.append((mass, (x, y, z), (v_x, v_y, v_z)))\n\n    def wrap(x, n):\n        return x % n\n\n    def step(planetoids):\n        new_planetoids = []\n        for i, (mass_i, (x_i, y_i, z_i), (v_x_i, v_y_i, v_z_i)) in enumerate(planetoids):\n            for j, (mass_j, (x_j, y_j, z_j), (v_x_j, v_y_j, v_z_j)) in enumerate(planetoids):\n                if i != j:\n                    dx = wrap(x_i - x_j, n_x)\n                    dy = wrap(y_i - y_j, n_y)\n                    dz = wrap(z_i - z_j, n_z)\n                    dist = dx**2 + dy**2 + dz**2\n                    if dist == 0:\n                        mass_i += mass_j\n                        v_x_i, v_y_i, v_z_i = (v_x_i*mass_i + v_x_j*mass_j) // (mass_i + mass_j), (v_y_i*mass_i + v_y_j*mass_j) // (mass_i + mass_j), (v_z_i*mass_i + v_z_j*mass_j) // (mass_i + mass_j)\n                        new_planetoids.append((mass_i, (x_i, y_i, z_i), (v_x_i, v_y_i, v_z_i)))\n        return new_planetoids\n\n    def simulate(planetoids):\n        while True:\n            new_planetoids = step(planetoids)\n            if len(new_planetoids) == len(planetoids):\n                return planetoids\n            planetoids = new_planetoids\n\n    final_planetoids = simulate(planetoids)\n    final_planetoids.sort(key=lambda x: (-x[0], x[1][0], x[1][1], x[1][2]))\n\n    output = f\"{len(final_planetoids)}\\n\"\n    for i, (mass, (x, y, z), (v_x, v_y, v_z)) in enumerate(final_planetoids):\n        output += f\"P{i}: {mass} {x} {y} {z} {v_x} {v_y} {v_z}\\n\"\n    return output"
    },
    {
        "number": 3320,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bitwise_or(a, b):\n        return a | b\n\n    def get_distance(path):\n        return sum(path)\n\n    def get_path_cost(s, t, path):\n        return get_distance(path)\n\n    def get_min_path_cost(s, t, paths):\n        min_cost = float('inf')\n        for path in paths:\n            cost = get_path_cost(s, t, path)\n            min_cost = min(min_cost, cost)\n        return min_cost\n\n    n, m = map(int, stdin.readline().split())\n    roads = [tuple(map(int, stdin.readline().split())) for _ in range(m)]\n    q = int(stdin.readline())\n    days = [tuple(map(int, stdin.readline().split())) for _ in range(q)]\n\n    paths = []\n    for _ in range(n):\n        paths.append([])\n        for _ in range(n):\n            paths[-1].append([])\n\n    for a, b, w in roads:\n        paths[a - 1][b - 1].append(w)\n        paths[b - 1][a - 1].append(w)\n\n    for s, t in days:\n        min_cost = get_min_path_cost(s - 1, t - 1, paths[s - 1][t - 1])\n        print(min_cost)\n"
    },
    {
        "number": 3321,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, start_seq, end_seq = stdin.split('\\n')\n    N = int(N)\n    start_seq = list(map(int, start_seq.split()))\n    end_seq = list(map(int, end_seq.split()))\n\n    def find_leap(start_seq, end_seq):\n        leaps = []\n        for i in range(N):\n            if start_seq[i] != end_seq[i]:\n                leaps.append(end_seq.index(start_seq[i]))\n        return leaps\n\n    leaps = find_leap(start_seq, end_seq)\n    return '\\n'.join(map(str, leaps))\n"
    },
    {
        "number": 3322,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[0:3])\n    antiques = []\n    for _ in range(n):\n        a, p, b, q = map(int, stdin.split()[3:7])\n        antiques.append((a, p, b, q))\n\n    def min_cost(antiques, k):\n        if k >= m:\n            return sum(p for a, p, b, q in antiques)\n\n        min_cost = float('inf')\n        for i in range(m):\n            for j in range(m):\n                if i != j:\n                    for l in range(m):\n                        if l != i and l != j:\n                            for a, p, b, q in antiques:\n                                if a == i + 1 or a == j + 1 or a == l + 1:\n                                    if b == i + 1 or b == j + 1 or b == l + 1:\n                                        min_cost = min(min_cost, p + q)\n        return min_cost if min_cost != float('inf') else -1\n\n    return str(min_cost(antiques, k))"
    },
    {
        "number": 3323,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin.readline())\n    output = []\n    for i in range(T):\n        N = int(stdin.readline())\n        min_fractions = []\n        for j in range(N):\n            min_fractions.append(list(map(int, stdin.readline().split())))\n        max_people = 0\n        for j in range(N):\n            for k in range(N):\n                if k == j:\n                    continue\n                for l in range(N):\n                    if l == j or l == k:\n                        continue\n                    total_min_fraction = sum([min_fractions[j][a] + min_fractions[k][a] + min_fractions[l][a] for a in range(3)])\n                    if total_min_fraction <= 10000:\n                        max_people = max(max_people, 1)\n        output.append(f\"Case #{i+1}: {max_people}\")\n    return \"\\n\".join(output)"
    },
    {
        "number": 3324,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_line(line: str) -> tuple:\n        sign, N = line.split()\n        elements = line.split()[2:]\n        return int(sign), int(N), [(e, int(c)) for e, c in zip(elements[::2], elements[1::2])]\n\n    def parse_input(input_str: str) -> list:\n        lines = input_str.split('\\n')[:-1]\n        return [parse_line(line) for line in lines]\n\n    def count_elements(molecules: list) -> dict:\n        counts = {}\n        for sign, N, elements in molecules:\n            for element, count in elements:\n                if element not in counts:\n                    counts[element] = 0\n                counts[element] += sign * count\n        return counts\n\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return a * b // gcd(a, b)\n\n    def balance_equation(molecules: list) -> list:\n        counts = count_elements(molecules)\n        C = [0] * len(molecules)\n        for i, (sign, N, elements) in enumerate(molecules):\n            for element, count in elements:\n                C[i] = lcm(C[i], counts[element] // count)\n        return C\n\n    molecules = parse_input(stdin)\n    C = balance_equation(molecules)\n    return ' '.join(map(str, C))"
    },
    {
        "number": 3325,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    D, L = map(int, input_list[1].split())\n    vertices = []\n    for i in range(2, 2 + N):\n        x, y = map(int, input_list[i].split())\n        vertices.append((x, y))\n\n    # Calculate the area of the polygon\n    area = 0\n    for i in range(N):\n        j = (i + 1) % N\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    area = abs(area) / 2\n\n    # Calculate the volume of the tank\n    volume = area * D\n\n    # Calculate the height of the water\n    height = (3 * L / volume) ** (1/3)\n\n    return f\"{height:.2f}\""
    },
    {
        "number": 3326,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c = map(int, stdin.split()[0].split())\n    grid = [list(map(int, stdin.split()[i].split())) for i in range(1, r + 1)]\n\n    def is_monotonic(subgrid):\n        rows = [subgrid[i][j] for i in range(len(subgrid))]\n        if all(rows[i] <= rows[i + 1] for i in range(len(rows) - 1)) or all(rows[i] >= rows[i + 1] for i in range(len(rows) - 1)):\n            return True\n        cols = [subgrid[j][i] for i in range(len(subgrid[0]))]\n        if all(cols[i] <= cols[i + 1] for i in range(len(cols) - 1)) or all(cols[i] >= cols[i + 1] for i in range(len(cols) - 1)):\n            return True\n        return False\n\n    def count_monotonic_subgrids():\n        count = 0\n        for i in range(1, r + 1):\n            for j in range(1, c + 1):\n                for k in range(1, r + 1):\n                    for l in range(1, c + 1):\n                        if k * l == i * j:\n                            count += 1\n        return count\n\n    count = count_monotonic_subgrids()\n    return str(count)\n"
    },
    {
        "number": 3327,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, N = map(int, stdin.split()[:3])\n    grid = stdin.split('\\n')[1]\n    words = stdin.split('\\n')[2:]\n\n    def is_valid(word, x, y, dx, dy):\n        if x < 0 or x >= R or y < 0 or y >= C:\n            return False\n        if grid[x][y] != '.':\n            return False\n        for i in range(len(word)):\n            if x + i * dx < 0 or x + i * dx >= R or y + i * dy < 0 or y + i * dy >= C:\n                return False\n            if grid[x + i * dx][y + i * dy] != '.':\n                return False\n        return True\n\n    def place_word(word, x, y, dx, dy):\n        for i in range(len(word)):\n            grid[x + i * dx][y + i * dy] = word[i]\n\n    def backtrack(x, y, dx, dy):\n        if x == R and y == C:\n            return True\n        if not is_valid('', x, y, dx, dy):\n            return False\n        for word in words:\n            if is_valid(word, x, y, dx, dy):\n                place_word(word, x, y, dx, dy)\n                if backtrack(x + len(word) * dx, y + len(word) * dy, dx, dy):\n                    return True\n                place_word(word, x, y, dx, dy)\n        return False\n\n    if not backtrack(0, 0, 1, 0):\n        raise ValueError(\"No solution found\")\n\n    return '\\n'.join([''.join(row) for row in grid])\n"
    },
    {
        "number": 3328,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[:2])\n    table = [list(map(int, input().split())) for _ in range(N)]\n\n    def is_valid(dominoes):\n        covered = set()\n        for domino in dominoes:\n            for field in domino:\n                if field in covered:\n                    return False\n                covered.add(field)\n        return True\n\n    def min_visible_sum(dominoes):\n        covered = set()\n        for domino in dominoes:\n            for field in domino:\n                covered.add(field)\n        return sum(sum(row) for row in table if all(field in covered for field in row))\n\n    def backtrack(dominoes, remaining):\n        if len(dominoes) == K:\n            return min_visible_sum(dominoes)\n        if remaining == 0:\n            return float('inf')\n        return min(backtrack(dominoes + [(i, i + 1)], remaining - 1) for i in range(N - 1)) + \\\n               min(backtrack(dominoes + [(i, i + 1)], remaining - 1) for i in range(N - 1))\n\n    dominoes = [(0, 1)]\n    result = backtrack(dominoes, K)\n    return str(result)\n"
    },
    {
        "number": 3329,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    circle = stdin.split()[2]\n\n    def rotate(circle: str, k: int) -> str:\n        k %= len(circle)\n        return circle[-k:] + circle[:-k]\n\n    def count_starting_circles(circle: str) -> int:\n        count = 0\n        for i in range(len(circle)):\n            if circle[i] != circle[(i + 1) % len(circle)]:\n                count += 1\n        return count\n\n    def transform(circle: str) -> str:\n        result = ''\n        for i in range(len(circle)):\n            if circle[i] == circle[(i + 1) % len(circle)]:\n                result += 'B'\n            else:\n                result += 'W'\n        return result\n\n    starting_circles = set()\n    for i in range(count_starting_circles(circle)):\n        starting_circles.add(circle)\n        circle = transform(circle)\n\n    for i in range(K):\n        new_circles = set()\n        for circle in starting_circles:\n            new_circles.add(rotate(circle, 1))\n        starting_circles = new_circles\n\n    return len(starting_circles)\n"
    },
    {
        "number": 3330,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:2+N]))\n    c = list(map(int, stdin.split()[2+N:2+2*N]))\n\n    total_potatoes = sum(a)\n    total_price = sum(c)\n\n    if total_potatoes < L:\n        return \"0.000\"\n\n    min_price = float('inf')\n    for i in range(1, total_potatoes - L + 1):\n        potatoes_store1 = i\n        potatoes_store2 = total_potatoes - potatoes_store1\n        price_store1 = sum([c[j] for j in range(N) if a[j] <= potatoes_store1])\n        price_store2 = sum([c[j] for j in range(N) if a[j] > potatoes_store1])\n        price_store2 = min(price_store2, total_price - price_store1)\n        price_product = price_store1 * price_store2 / total_potatoes\n        min_price = min(min_price, price_product)\n\n    return f\"{min_price:.3f}\"\n"
    },
    {
        "number": 3331,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, A, B, P = map(int, stdin.split())\n\n    # Calculate the distance between the cows and the horse\n    distance_AB = abs(A - B)\n    distance_AP = abs(A - P)\n    distance_BP = abs(B - P)\n\n    # Calculate the minimum distance the horse can move\n    min_distance = min(distance_AB, distance_AP, distance_BP)\n\n    # Calculate the number of minutes it takes for the cows to catch the horse\n    minutes_to_capture = (min_distance - 1) // 2\n\n    return str(minutes_to_capture)"
    },
    {
        "number": 3332,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def push(stack: list, processor_id: int):\n        stack.append(processor_id)\n\n    def pop(stack: list) -> int:\n        return stack.pop()\n\n    def process_stream(stream: tuple, stack: list, ogu_processor_id: int) -> int:\n        start_time, duration, priority = stream\n        if ogu_processor_id == -1:\n            return priority\n        if start_time <= ogu_processor_id:\n            push(stack, ogu_processor_id)\n            return priority\n        return 0\n\n    def process_streams(streams: list, stack: list, ogu_processor_id: int) -> int:\n        total_priority = 0\n        for stream in streams:\n            total_priority += process_stream(stream, stack, ogu_processor_id)\n        return total_priority\n\n    def find_optimal_subset(streams: list, ogu_processor_id: int) -> int:\n        stack = []\n        max_total_priority = 0\n        for i in range(len(streams)):\n            total_priority = process_streams(streams[:i] + streams[i+1:], stack, ogu_processor_id)\n            if total_priority > max_total_priority:\n                max_total_priority = total_priority\n        return max_total_priority\n\n    n = int(stdin.splitlines()[0])\n    streams = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    ogu_processor_id = -1\n    max_total_priority = find_optimal_subset(streams, ogu_processor_id)\n    return max_total_priority"
    },
    {
        "number": 3333,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    roost_x, roost_y, num_hiding_spots = map(float, stdin.split()[:3])\n    hiding_spots = [tuple(map(float, stdin.split()[3:])) for _ in range(int(num_hiding_spots))]\n\n    min_distance = float('inf')\n    for hen_pos in hiding_spots:\n        dist = distance(roost_x, roost_y, hen_pos[0], hen_pos[1])\n        min_distance = min(min_distance, dist)\n\n    return f\"{min_distance:.6f}\"\n"
    },
    {
        "number": 3334,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    distance_table = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(1, n):\n        row = list(map(int, input_list[i].split()))\n        for j in range(len(row)):\n            distance_table[i][j] = row[j]\n\n    total_distance = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_distance += distance_table[i][j]\n\n    if total_distance == 0:\n        return \"impossible\"\n\n    average_distance = total_distance / ((n * (n - 1)) // 2)\n    return f\"{average_distance:.9f}\"\n"
    },
    {
        "number": 3335,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for a in range(1, n):\n        for b in range(a, n):\n            c = (a**2 + b**2)**0.5\n            if c.is_integer() and c <= n-1:\n                count += 1\n    return str(count)\n\n\ninput_str = \"7\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3336,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_eligible(person1, person2):\n        height_diff = abs(person1[0] - person2[0])\n        if person1[1] == person2[1]:\n            return False\n        if person1[2] == person2[2]:\n            return False\n        if person1[3] == person2[3]:\n            return False\n        if person1[4] == person2[4]:\n            return False\n        return height_diff <= 40\n\n    def count_eligible_pupils(pupils):\n        count = 0\n        for i in range(len(pupils)):\n            for j in range(i + 1, len(pupils)):\n                if is_eligible(pupils[i], pupils[j]):\n                    count += 1\n        return count\n\n    N = int(stdin.splitlines()[0])\n    pupils = []\n    for i in range(1, N + 1):\n        height, gender, music_style, sport = stdin.splitlines()[i].split()\n        pupils.append((int(height), gender, music_style, sport))\n\n    result = count_eligible_pupils(pupils)\n    return str(result)\n"
    },
    {
        "number": 3337,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    stacks = [[] for _ in range(N)]\n    result = []\n\n    for line in stdin.split('\\n')[1:]:\n        op, *args = line.split()\n        if op == 'a':\n            stacks[int(args[0])] = []\n        elif op == 'b':\n            result.append(stacks[int(args[0])].pop())\n        elif op == 'c':\n            stack_w = stacks[int(args[1])]\n            stack_v = stacks[int(args[0])]\n            count = 0\n            for num in stack_v:\n                if num not in stack_w:\n                    count += 1\n            result.append(count)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3338,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    partners = []\n    for _ in range(n):\n        g, p, g_a, p_a = map(int, stdin.split()[2:6])\n        partners.append((g, p, g_a, p_a))\n\n    def diversity(partners):\n        max_d = 0\n        for i in range(len(partners)):\n            for j in range(i + 1, len(partners)):\n                if partners[i][0] < partners[j][0] and partners[i][1] < partners[j][1]:\n                    max_d += 1\n        return max_d\n\n    def can_awaken(partners):\n        return sum(1 for p in partners if p[2] > 0)\n\n    def awaken(partners):\n        return [(g_a, p_a) for g, p, g_a, p_a in partners if g_a > 0 and p_a > 0]\n\n    def max_diversity(partners, k):\n        if len(partners) <= k:\n            return diversity(partners)\n\n        max_d = 0\n        for i in range(len(partners)):\n            if can_awaken(partners) > k:\n                awakened = awaken(partners)\n                max_d = max(max_d, max_diversity(awakened, k))\n            partners.pop(i)\n        return max_d\n\n    return str(max_diversity(partners, k))\n"
    },
    {
        "number": 3339,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n\n    def count_ways(roads, N):\n        # Initialize a list of size N to store the number of roads at each intersection\n        intersection_roads = [0] * N\n\n        # Count the number of roads at each intersection\n        for road in roads:\n            intersection_roads[road[0] - 1] += 1\n            intersection_roads[road[1] - 1] += 1\n\n        # Calculate the number of ways to make all intersections even\n        ways = 1\n        for road_count in intersection_roads:\n            if road_count % 2 == 1:\n                ways *= 2\n\n        return ways % 1000000009\n\n    return str(count_ways(roads, N))\n"
    },
    {
        "number": 3340,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    flights = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Find the maximum number of flight changes needed\n    max_changes = float('inf')\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            changes = 0\n            for k in range(n - 1):\n                if (flights[k][0], flights[k][1]) != (flights[i][0], flights[j][1]) and (flights[k][1], flights[k][0]) != (flights[i][0], flights[j][1]):\n                    changes += 1\n            max_changes = min(max_changes, changes)\n\n    # Find the best flight to cancel and the best new flight to add\n    best_changes = float('inf')\n    best_cancel = None\n    best_add = None\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (flights[i][0], flights[j][1]) != (flights[i][1], flights[j][0]):\n                changes = max_changes - 1\n                cancel = (flights[i][0], flights[j][1])\n                add = (flights[i][1], flights[j][0])\n            elif (flights[j][0], flights[i][1]) != (flights[j][1], flights[i][0]):\n                changes = max_changes - 1\n                cancel = (flights[j][0], flights[i][1])\n                add = (flights[j][1], flights[i][0])\n            else:\n                continue\n\n            if changes < best_changes:\n                best_changes = changes\n                best_cancel = cancel\n                best_add = add\n\n    return f\"{best_changes}\\n{best_cancel[0]} {best_cancel[1]}\\n{best_add[0]} {best_add[1]}\"\n"
    },
    {
        "number": 3341,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0:2])\n    producer_prices = []\n    producer_dates = []\n    for i in range(1, m+1):\n        p, d = map(int, stdin.split()[i*2-2:i*2])\n        producer_prices.append(p)\n        producer_dates.append(d)\n    consumer_prices = []\n    consumer_dates = []\n    for j in range(m+1, m+n+1):\n        q, e = map(int, stdin.split()[j*2-2:j*2])\n        consumer_prices.append(q)\n        consumer_dates.append(e)\n\n    max_profit = 0\n    for i in range(m):\n        for j in range(n):\n            if producer_dates[i] <= consumer_dates[j]:\n                profit = consumer_prices[j] - producer_prices[i]\n                max_profit = max(max_profit, profit)\n\n    return str(max_profit)\n"
    },
    {
        "number": 3342,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M, K = map(int, input_list[0].split())\n    onion_coords = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n    fence_coords = [tuple(map(int, input_list[i+1+N].split())) for i in range(M)]\n\n    def convex_hull(points):\n        points = sorted(points, key=lambda x: (x[1], x[0]))\n        n = len(points)\n        hull = []\n        for i in range(n):\n            while len(hull) >= 2 and not ((hull[-1][0] > points[i][0]) or (hull[-1][1] >= points[i][1])):\n                hull.pop()\n            hull.append(points[i])\n        return hull\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(onion_coords, fence_coords):\n        hull = convex_hull(fence_coords)\n        for onion in onion_coords:\n            if all(distance(onion, p) > distance(onion, hull[i-1]) + distance(onion, hull[i]) for i in range(len(hull))):\n                return False\n        return True\n\n    def max_onions(onion_coords, fence_coords, K):\n        fence_coords = fence_coords[:K]\n        hull = convex_hull(fence_coords)\n        max_onions = 0\n        for i in range(len(hull)):\n            max_onions += sum(1 for onion in onion_coords if distance(onion, hull[i-1]) + distance(onion, hull[i]) < distance(onion, hull[i-1]) + distance(onion, hull[i-2]))\n        return max_onions\n\n    if is_inside(onion_coords, fence_coords):\n        return max_onions(onion_coords, fence_coords, K)\n    else:\n        return 0"
    },
    {
        "number": 3343,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, n = map(int, stdin.split()[0:2])\n    points = []\n    for i in range(n):\n        point, direction = stdin.split()[2+i].split()\n        points.append((int(point), direction))\n\n    wire_ghost = False\n    for i in range(n):\n        point, direction = points[i]\n        if point == 0:\n            if direction == 'C':\n                wire_ghost = True\n                break\n        elif point == L:\n            if direction == 'W':\n                wire_ghost = True\n                break\n        elif direction == 'C':\n            wire_ghost = True\n            break\n\n    return 'GHOST' if wire_ghost else 'SAFE'\n"
    },
    {
        "number": 3344,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, L = map(int, input_list[0].split())\n    luggage_positions = list(map(float, input_list[1].split()))\n\n    def is_safe(speed: float) -> bool:\n        for i in range(N):\n            for j in range(i + 1, N):\n                if abs(luggage_positions[i] - luggage_positions[j]) < 1:\n                    return False\n        return True\n\n    def binary_search(left: float, right: float) -> float:\n        while abs(right - left) > 10**-9:\n            mid = (left + right) / 2\n            if is_safe(mid):\n                left = mid\n            else:\n                right = mid\n        return left\n\n    if N == 1:\n        return \"2\"\n    else:\n        return str(binary_search(0.1, 10))"
    },
    {
        "number": 3345,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    shadow_walk = [(int(x), int(y)) for x, y in zip(input_list[1:n+1], input_list[1:n+1][1:])]\n    m = int(input_list[n+1])\n    lydia_walk = [(int(x), int(y)) for x, y in zip(input_list[n+2:n+2+m], input_list[n+2:n+2+m][1:])]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n\n    min_distance = float('inf')\n    for s_point in shadow_walk:\n        for l_point in lydia_walk:\n            min_distance = min(min_distance, distance(s_point, l_point))\n\n    return f\"{min_distance:.4f}\""
    },
    {
        "number": 3346,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split()[0:2])\n    cars = []\n    for _ in range(n):\n        d, a, r = stdin.split()[1:]\n        cars.append((d, int(a), int(r)))\n\n    def get_time(car):\n        if car[0] == 'W':\n            return car[1]\n        else:\n            return car[1] + t\n\n    def get_irritation_time(car):\n        return car[1] + car[2]\n\n    cars.sort(key=get_time)\n    irritated_drivers = 0\n    irritated_cars = []\n    for car in cars:\n        if get_irritation_time(car) > t:\n            irritated_drivers += 1\n            irritated_cars.append(car)\n\n    if irritated_drivers == 0:\n        return 0\n\n    def get_waiting_time(car):\n        if car[0] == 'W':\n            return car[1]\n        else:\n            return car[1] + t\n\n    def get_irritation_time(car):\n        return car[1] + car[2]\n\n    irritated_cars.sort(key=get_waiting_time)\n    irritated_drivers = 0\n    irritated_cars = []\n    for car in cars:\n        if get_irritation_time(car) > t:\n            irritated_drivers += 1\n            irritated_cars.append(car)\n\n    return irritated_drivers"
    },
    {
        "number": 3347,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    gold_stores = []\n    for i in range(1, n+1):\n        t, h = map(int, input_list[i].split())\n        gold_stores.append((t, h))\n\n    gold_stores.sort(key=lambda x: x[1])\n    max_visited = 0\n    time = 0\n    for t, h in gold_stores:\n        if h <= time:\n            max_visited += 1\n        time += t\n\n    return str(max_visited)\n"
    },
    {
        "number": 3348,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, a, b, c = map(int, stdin.split())\n    total_bonbons = a + b + c\n    if total_bonbons != R * C:\n        return \"impossible\"\n\n    def is_good_arrangement(arrangement: str) -> bool:\n        for i in range(R):\n            for j in range(C - 1):\n                if arrangement[i][j] == arrangement[i][j + 1]:\n                    return False\n        for j in range(C):\n            for i in range(R - 1):\n                if arrangement[i][j] == arrangement[i + 1][j]:\n                    return False\n        return True\n\n    def generate_arrangement(arrangement: str, remaining_bonbons: int, flavor: str) -> str:\n        if remaining_bonbons == 0:\n            return arrangement\n        for i in range(R):\n            for j in range(C):\n                if arrangement[i][j] == '':\n                    new_arrangement = arrangement[:i] + [row[:j] + [flavor] + row[j + 1:] for row in arrangement[i:]]\n                    if is_good_arrangement(new_arrangement):\n                        return generate_arrangement(new_arrangement, remaining_bonbons - 1, flavor)\n        return \"impossible\"\n\n    arrangement = [[''] * C for _ in range(R)]\n    if a > 0:\n        arrangement = generate_arrangement(arrangement, a, 'A')\n    if arrangement != \"impossible\":\n        if b > 0:\n            arrangement = generate_arrangement(arrangement, b, 'B')\n        if arrangement != \"impossible\":\n            arrangement = generate_arrangement(arrangement, c, 'C')\n\n    return arrangement if arrangement != \"impossible\" else \"impossible\"\n"
    },
    {
        "number": 3349,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_word(word: str) -> bool:\n        vowels = {'A', 'E', 'I', 'O', 'U'}\n        return all(c not in vowels for c in word)\n\n    def remove_vowels(word: str) -> str:\n        vowels = {'A', 'E', 'I', 'O', 'U'}\n        return ''.join(c for c in word if c not in vowels)\n\n    def reconstruct_sentence(words: list[str], message: str) -> str:\n        sentence = []\n        i = 0\n        for word in words:\n            word_length = len(remove_vowels(word))\n            if i + word_length <= len(message):\n                sentence.append(word)\n                i += word_length\n        return ' '.join(sentence)\n\n    n = int(stdin.splitlines()[0])\n    words = [line.strip() for line in stdin.splitlines()[1:n + 1] if is_valid_word(line.strip())]\n    message = stdin.splitlines()[n + 1].strip()\n\n    sentence = reconstruct_sentence(words, message)\n    return sentence\n"
    },
    {
        "number": 3350,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subword(word: str) -> bool:\n        return word == word[::-1]\n\n    def max_subword_length(word: str) -> int:\n        max_length = 0\n        for i in range(len(word)):\n            for j in range(i + 1, len(word) + 1):\n                subword = word[i:j]\n                if is_subword(subword):\n                    max_length = max(max_length, len(subword))\n        return max_length\n\n    word = stdin\n    max_length = max_subword_length(word)\n    power = max_length * 4\n    return str(power)\n"
    },
    {
        "number": 3351,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    dice_rolls = [int(roll) for roll in stdin.splitlines()[1:]]\n\n    # Initialize variables\n    max_score = 0\n    current_score = 0\n    current_category = 1\n    current_dice = 0\n\n    # Iterate through the dice rolls\n    for i in range(n):\n        # If the current dice is not the same as the previous dice, we need to update the current category\n        if current_dice != dice_rolls[i]:\n            current_category += 1\n            current_dice = dice_rolls[i]\n\n        # Update the current score based on the current category\n        if current_category == 1:\n            current_score += dice_rolls[i]\n        elif current_category == 2:\n            current_score += dice_rolls[i] * 2\n        elif current_category == 3:\n            current_score += 35 if dice_rolls[i] == 1 else 0\n        elif current_category == 4:\n            current_score += 40 if dice_rolls[i] == 1 else 0\n        elif current_category == 5:\n            current_score += 50 if dice_rolls[i] == 1 else 0\n        elif current_category == 6:\n            current_score += 100 if dice_rolls[i] == 1 else 0\n        elif current_category == 7:\n            current_score += 300 if dice_rolls[i] == 1 else 0\n        elif current_category == 8:\n            current_score += 700 if dice_rolls[i] == 1 else 0\n        elif current_category == 9:\n            current_score += 1100 if dice_rolls[i] == 1 else 0\n        elif current_category == 10:\n            current_score += 1300 if dice_rolls[i] == 1 else 0\n        elif current_category == 11:\n            current_score += 2000 if dice_rolls[i] == 1 else 0\n        elif current_category == 12:\n            current_score += 2500 if dice_rolls[i] == 1 else 0\n        elif current_category == 13:\n            current_score += 5000 if dice_rolls[i] == 1 else 0\n\n        # Update the max score\n        max_score = max(max_score, current_score)\n\n    return max_score"
    },
    {
        "number": 3352,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    colors = list(map(int, stdin.split()[2:N+2]))\n    parents = list(map(int, stdin.split()[N+2:]))\n    tree = [[] for _ in range(N+1)]\n    for i in range(N-1):\n        tree[parents[i]].append(i+1)\n\n    def count_magical_colors(node: int) -> int:\n        if not tree[node]:\n            return 1 if colors[node-1] % 2 == 1 else 0\n        count = 0\n        for child in tree[node]:\n            count += count_magical_colors(child)\n        return count\n\n    for i in range(Q):\n        k, x = map(int, stdin.split()[N+2+i:N+4+i])\n        if k == 0:\n            print(count_magical_colors(x))"
    },
    {
        "number": 3353,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start, end, visited, queue):\n        visited[start] = True\n        queue.append(start)\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return False\n\n    def shortest_path(graph, start, end):\n        visited = [False] * len(graph)\n        queue = []\n        if bfs(graph, start, end, visited, queue):\n            return visited[end]\n        return -1\n\n    def min_time(graph, start, end, visited, queue, time):\n        visited[start] = True\n        queue.append(start)\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return time\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return -1\n\n    def min_time_bfs(graph, start, end, time):\n        visited = [False] * len(graph)\n        queue = []\n        return min_time(graph, start, end, visited, queue, time)\n\n    def min_time_dfs(graph, start, end, time):\n        visited = [False] * len(graph)\n        stack = []\n        return min_time(graph, start, end, visited, stack, time)\n\n    def min_time_all(graph, start, end, time):\n        return min(min_time_bfs(graph, start, end, time), min_time_dfs(graph, start, end, time))\n\n    def left_behind(graph, start, end, visited, queue, time):\n        visited[start] = True\n        queue.append(start)\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return time\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n        return -1\n\n    def left_behind_bfs(graph, start, end, time):\n        visited = [False] * len(graph)\n        queue = []\n        return left_behind(graph, start, end, visited, queue, time)\n\n    def left_behind_dfs(graph, start, end, time):\n        visited = [False] * len(graph)\n        stack = []\n        return left_behind(graph, start, end, visited, stack, time)\n\n    def left_behind_all(graph, start, end, time):\n        return min(left_behind_bfs(graph, start, end, time), left_behind_dfs(graph, start, end, time))\n\n    P, R, L = map(int, stdin.split())\n    graph = [[] for _ in range(R + 1)]\n    for _ in range(L):\n        E1, E2 = map(int, stdin.split())\n        graph[E1].append(E2)\n        graph[E2].append(E1)\n\n    start = 0\n    end = R\n    time = 0\n    if shortest_path(graph, start, end):\n        return min_time_all(graph, start, end, time)\n    else:\n        return left_behind_all(graph, start, end, time)\n"
    },
    {
        "number": 3354,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, r, n, z = map(float, stdin.split())\n    z /= 100\n\n    def area(r):\n        return r * r * 3.14159\n\n    def can_place(s, r, n, z):\n        max_area = area(s) * (1 - z)\n        total_area = area(r) * n\n        return total_area <= max_area\n\n    result = 0\n    while can_place(s, r, result + 1, z):\n        result += 1\n\n    return str(result)\n"
    },
    {
        "number": 3355,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, T = map(int, input_list[0].split())\n    p_list = [int(x) for x in input_list[1].split()]\n    t_list = [int(x) for x in input_list[2].split()]\n    d_list = [int(x) for x in input_list[3].split()]\n    adj_list = [list(map(int, input_list[i].split())) for i in range(4, 4 + n)]\n    start_end_adj = [list(map(int, input_list[i].split())) for i in range(4 + n, 4 + n + 2)]\n\n    def dfs(node, visited, stack, task_list, time_left, task_count):\n        if node == n + 1:\n            if time_left >= 0:\n                task_list.append(task_count)\n                return task_count\n            else:\n                return -1\n\n        visited[node] = True\n        stack.append(node)\n\n        for neighbor, edge_time in enumerate(adj_list[node]):\n            if not visited[neighbor] and edge_time <= time_left:\n                time_left -= edge_time\n                task_count = dfs(neighbor, visited, stack, task_list, time_left, task_count)\n                time_left += edge_time\n\n                if task_count == -1:\n                    break\n\n        visited[node] = False\n        stack.pop()\n\n        return task_count\n\n    max_points = 0\n    max_task_list = []\n\n    for i in range(n):\n        visited = [False] * (n + 2)\n        task_list = []\n        stack = []\n        time_left = T\n        task_count = 0\n\n        dfs(i, visited, stack, task_list, time_left, task_count)\n\n        if task_list:\n            task_list.sort()\n            task_points = sum(p_list[task] for task in task_list)\n\n            if task_points > max_points:\n                max_points = task_points\n                max_task_list = task_list\n\n    if max_points == 0:\n        return '\\n'\n    else:\n        return f\"{max_points}\\n{' '.join(map(str, max_task_list))}\"\n"
    },
    {
        "number": 3356,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_farthest_rooms(adj_list: list, visited: list, start: int) -> tuple:\n        max_distance = 0\n        max_rooms = (0, 0)\n        stack = [(start, 0)]\n        while stack:\n            room, distance = stack.pop()\n            if not visited[room]:\n                visited[room] = True\n                for neighbor, weight in adj_list[room]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, distance + weight))\n                        if distance + weight > max_distance:\n                            max_distance = distance + weight\n                            max_rooms = (room, neighbor)\n        return max_distance, max_rooms\n\n    def find_closest_rooms(adj_list: list, visited: list, start: int) -> tuple:\n        min_distance = float('inf')\n        min_rooms = (0, 0)\n        stack = [(start, 0)]\n        while stack:\n            room, distance = stack.pop()\n            if not visited[room]:\n                visited[room] = True\n                for neighbor, weight in adj_list[room]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, distance + weight))\n                        if distance + weight < min_distance:\n                            min_distance = distance + weight\n                            min_rooms = (room, neighbor)\n        return min_distance, min_rooms\n\n    def find_reconstruction_plan(adj_list: list, visited: list, start: int) -> tuple:\n        max_distance, max_rooms = find_farthest_rooms(adj_list, visited, start)\n        min_distance, min_rooms = find_closest_rooms(adj_list, visited, start)\n        tunnel_to_close = max_rooms\n        new_tunnel = min_rooms\n        return max_distance, tunnel_to_close, new_tunnel\n\n    def main(stdin: str) -> str:\n        N = int(stdin.split('\\n')[0])\n        adj_list = [[] for _ in range(N)]\n        for line in stdin.split('\\n')[1:]:\n            a, b = map(int, line.split())\n            adj_list[a - 1].append((b - 1, 1))\n            adj_list[b - 1].append((a - 1, 1))\n\n        max_distance, tunnel_to_close, new_tunnel = find_reconstruction_plan(adj_list, [False] * N, 0)\n        return str(max_distance) + '\\n' + str(tunnel_to_close[0] + 1) + ' ' + str(tunnel_to_close[1] + 1) + '\\n' + str(new_tunnel[0] + 1) + ' ' + str(new_tunnel[1] + 1)\n\n    return main(stdin)"
    },
    {
        "number": 3357,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def sunlight_hours(x, h, n):\n        return (n - x) * h / 180\n\n    def main(input_data):\n        buildings = []\n        n = int(input_data[0])\n        for i in range(1, n + 1):\n            x, h = map(int, input_data[i].split())\n            buildings.append((x, h))\n\n        result = []\n        for i, (x, h) in enumerate(buildings, start=1):\n            n = len(buildings)\n            hours = sunlight_hours(x, h, n)\n            result.append(f\"{hours:.4f}\")\n\n        return \"\\n\".join(result)\n\n    input_data = stdin.split(\"\\n\")\n    return main(input_data)\n"
    },
    {
        "number": 3358,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N == 0:\n        return \"ZE A\\nDI A\"\n    elif N == 1:\n        return \"ST A\\nDI A\"\n    else:\n        instructions = []\n        for i in range(8):\n            if N & (1 << i):\n                instructions.append(f\"PH A\\nPH X\\nAD\\nPL Y\\nDI Y\")\n                N -= (1 << i)\n            else:\n                instructions.append(f\"PH A\\nPH X\\nAD\\nPL Y\\nDI Y\")\n        return \"\\n\".join(instructions)\n\n\ninput_str = \"2\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3359,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, C = map(int, stdin.split()[:3])\n    assert 1 <= N <= 99 and N % 2 == 1\n    assert 1 <= R <= 1000 and 1 <= C <= 1000\n\n    # Initialize the grid with zeros\n    grid = [[0 for _ in range(C)] for _ in range(R)]\n\n    # Fill the grid with the given data\n    for i in range(R):\n        row = list(map(int, stdin.split()[3 + i * C:3 + (i + 1) * C]))\n        for j in range(C):\n            grid[i][j] = row[j]\n\n    # Count the number of stellar bodies\n    count = 0\n    for i in range(R):\n        for j in range(C):\n            if grid[i][j] == 0xFFFF:\n                count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3360,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def parse_cfg(rules: str) -> str:\n        V = set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        S = \"A\"\n        rules = rules.split(\"\\n\")\n        R = set()\n        for rule in rules:\n            head, body = rule.split(\" -> \")\n            R.add((head, body))\n        return R\n\n    def generate_string(R: str, S: str) -> str:\n        V = set(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n        S = \"A\"\n        result = \"\"\n        while S in V:\n            for head, body in R:\n                if S == head:\n                    result += body\n                    S = body[-1]\n                    break\n        return result\n\n    def find_substring(text: str, pattern: str) -> str:\n        index = text.find(pattern)\n        if index != -1:\n            return text[index:index + len(pattern)]\n        else:\n            return \"NONE\"\n\n    rules, text = stdin.split(\"\\n\", 1)\n    R = parse_cfg(rules)\n    result = []\n    for line in text.split(\"\\n\"):\n        pattern = generate_string(R, \"A\")\n        result.append(find_substring(line, pattern))\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3361,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(i: int, j: int) -> int:\n        return d[i][j]\n\n    def disparity(S: set) -> int:\n        return max(distance(i, j) for i in S for j in S if i != j)\n\n    n = int(stdin.splitlines()[0])\n    d = [[0] * n for _ in range(n)]\n    for i in range(1, n):\n        row = list(map(int, stdin.splitlines()[i].split()))\n        for j in range(i):\n            d[j][i] = row[j]\n            d[i][j] = row[j]\n\n    A = set(range(n // 2))\n    B = set(range(n // 2, n))\n    min_sum = disparity(A) + disparity(B)\n\n    for i in range(n // 2):\n        for j in range(i + 1, n // 2):\n            A.remove(i)\n            A.add(j)\n            B.add(i)\n            new_sum = disparity(A) + disparity(B)\n            min_sum = min(min_sum, new_sum)\n            A.remove(j)\n            A.add(i)\n            B.remove(i)\n            B.add(j)\n\n    return min_sum\n"
    },
    {
        "number": 3362,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    A, F = map(int, input_list[0].split())\n    L, W = map(int, input_list[1].split())\n    map_list = input_list[2:]\n\n    def is_valid_move(x, y, step_length):\n        for dx in range(-step_length, step_length+1):\n            for dy in range(-step_length, step_length+1):\n                if dx == 0 and dy == 0:\n                    continue\n                if 0 <= x+dx < L and 0 <= y+dy < W and map_list[x+dx][y+dy] == 'W':\n                    return True\n        return False\n\n    def is_winning_move(x, y, step_length):\n        for dx in range(-step_length, step_length+1):\n            for dy in range(-step_length, step_length+1):\n                if dx == 0 and dy == 0:\n                    continue\n                if 0 <= x+dx < L and 0 <= y+dy < W and map_list[x+dx][y+dy] == 'B':\n                    return False\n        return True\n\n    def is_goal_reached(x, y):\n        return 0 <= x < L and 0 <= y < W and map_list[x][y] == 'G'\n\n    def is_start_reached(x, y):\n        return 0 <= x < L and 0 <= y < W and map_list[x][y] == 'S'\n\n    elsa_x, elsa_y = is_start_reached(0, 0)\n    father_x, father_y = elsa_x, elsa_y\n\n    while True:\n        if is_goal_reached(elsa_x, elsa_y):\n            if is_goal_reached(father_x, father_y):\n                return \"SUCCESS\"\n            else:\n                return \"GO FOR IT\"\n        if not is_valid_move(elsa_x, elsa_y, A):\n            return \"NO WAY\"\n        if not is_winning_move(father_x, father_y, F):\n            return \"NO CHANCE\"\n        elsa_x, elsa_y = elsa_x+1, elsa_y\n        father_x, father_y = father_x+1, father_y"
    },
    {
        "number": 3363,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    calories = list(map(int, input_list[1].split()))\n\n    def calculate_calories(hour, m):\n        if hour == 1:\n            return m\n        else:\n            return int(m * (2/3))\n\n    total_calories = 0\n    for i in range(n):\n        total_calories += calculate_calories(i+1, m) * calories[i]\n\n    return total_calories"
    },
    {
        "number": 3364,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    base_set = [i for i in range(N)]\n    parent = [i for i in range(N)]\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        parent[find(x)] = find(y)\n\n    for i in range(Q):\n        op, a, b = stdin.split()[i * 3 + 2:i * 3 + 5]\n        a, b = int(a), int(b)\n\n        if op == \"=\":\n            union(a, b)\n        elif op == \"?\":\n            if find(a) == find(b):\n                print(\"yes\")\n            else:\n                print(\"no\")\n"
    },
    {
        "number": 3365,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    sequence = list(map(int, input_list[1].split()))\n\n    def is_prime(num: int) -> bool:\n        if num <= 1:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def find_prime(nums: list) -> int:\n        for num in nums:\n            if is_prime(num):\n                return num\n        return 0\n\n    def find_min_score(sequence: list, k: int) -> int:\n        min_score = float('inf')\n        for i in range(len(sequence) - k + 1):\n            region = sequence[i:i+k]\n            prime = find_prime(region)\n            min_score = min(min_score, prime)\n        return min_score\n\n    min_score = find_min_score(sequence, k)\n    return min_score"
    },
    {
        "number": 3366,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    def f(X):\n        iterations = 0\n        while X != 1:\n            if X % 2 == 0:\n                X //= 2\n            else:\n                X += 1\n            iterations += 1\n        return iterations\n\n    S = sum(f(X) for X in range(L, R+1))\n    return str(S % (10**9 + 7))\n"
    },
    {
        "number": 3367,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, stdin.split()[0:2])\n    questions = [line.strip().split('?') for line in stdin.split('\\n')[1:n+1]]\n    answers = [line.strip().split('?')[1] for line in stdin.split('\\n')[1:n+1]]\n    total_time = t * 1000\n    total_words = sum(len(q[0].split()) for q in questions)\n    total_questions = len(questions)\n    total_answers = len(set(answers))\n    total_correct_answers = len(set(answers) & set(stdin.split('\\n')[n+1:n+1+total_answers]))\n    total_points = total_correct_answers * 1000 / total_time\n    return f\"{total_points:.10f}\""
    },
    {
        "number": 3368,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    enclosures = []\n    for _ in range(n):\n        enclosure = stdin.split()[1:]\n        enclosures.append(enclosure)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if enclosures[i][0] != enclosures[j][0]:\n                continue\n            if enclosures[i][1] != enclosures[j][1]:\n                continue\n            if enclosures[i][2:] != enclosures[j][2:]:\n                return \"POSSIBLE\"\n\n    return \"FALSE ALARM\"\n"
    },
    {
        "number": 3369,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1:]\n    sequence = ''.join(sequence).split()\n\n    def find_triple_correlation(sequence, p):\n        for i in range(p - 3):\n            if sequence[i] == '4' and sequence[i + 1] == '4':\n                for j in range(i + 2, p - 1):\n                    if sequence[j] == '3':\n                        return f\"triple correlation 4(1)4(3)3 found\"\n        return \"random sequence\"\n\n    return find_triple_correlation(sequence, p)\n"
    },
    {
        "number": 3370,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(float, input().split())\n    houses = []\n    for _ in range(int(N)):\n        houses.append(float(input()))\n\n    def remodel(i):\n        left = houses[i - 1] if i > 0 else 0\n        right = houses[i + 1] if i < len(houses) - 1 else 0\n        avg = (left + right) / 2\n        new_height = (left + right) / 2 + k\n        return new_height if houses[i] < avg + k else houses[i]\n\n    for i in range(len(houses)):\n        houses[i] = remodel(i)\n\n    max_height = max(houses)\n    return f\"{max_height:.1f}\"\n"
    },
    {
        "number": 3371,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, c = map(int, input_list[0].split())\n    first_encounters = [tuple(map(int, input_list[i].split())) for i in range(1, c+1)]\n\n    # Sort the first encounters by year\n    first_encounters.sort(key=lambda x: x[2])\n\n    # Initialize the first and second parts\n    first_part = []\n    second_part = []\n\n    # Iterate through the first encounters\n    for encounter in first_encounters:\n        # If the first part has less than 2/3 of the participants, add the encounter to the first part\n        if len(first_part) < 2*n//3:\n            first_part.append(encounter)\n        # If the second part has less than 2/3 of the participants, add the encounter to the second part\n        elif len(second_part) < 2*n//3:\n            second_part.append(encounter)\n        # If both parts have more than 2/3 of the participants, break the loop\n        else:\n            break\n\n    # If both parts have more than 2/3 of the participants, the problem is impossible\n    if len(first_part) > 2*n//3 or len(second_part) > 2*n//3:\n        return 'Impossible'\n\n    # If both parts have less than 2/3 of the participants, the problem is impossible\n    if len(first_part) < 2*n//3 or len(second_part) < 2*n//3:\n        return 'Impossible'\n\n    # If both parts have 2/3 of the participants, check if the first part meets the condition\n    for i in range(len(first_part)):\n        for j in range(i+1, len(first_part)):\n            if first_part[j][2] < first_part[i][2]:\n                return 'Impossible'\n\n    # If the first part meets the condition, check if the second part meets the condition\n    for i in range(len(second_part)):\n        for j in range(i+1, len(second_part)):\n            if second_part[j][2] < second_part[i][2]:\n                return 'Impossible'\n\n    # If both parts meet the condition, return the smallest year\n    return min(first_part[-1][2], second_part[0][2])"
    },
    {
        "number": 3372,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, s, t = map(int, input().split())\n    flights = []\n    for _ in range(N):\n        letter, m = input().split()\n        m = int(m)\n        if letter == 'N':\n            flights.append([True] * m)\n        else:\n            flights.append([False] * m)\n            for i in range(m):\n                flights[-1][i] = True\n\n    def dfs(start: int, end: int, visited: set[int]) -> bool:\n        if start == end:\n            return True\n        if start in visited:\n            return False\n        visited.add(start)\n        for i, flight in enumerate(flights[start]):\n            if flight and not visited:\n                if dfs(i, end, visited):\n                    return True\n        return False\n\n    visited = set()\n    if dfs(s, t, visited):\n        return len(visited)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3373,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    pieces = stdin.split('\\n')[1:]\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        for j in range(i + 1, n + 1):\n            if is_balanced(pieces[i:j + 1]):\n                dp[j + 1] = max(dp[j + 1], dp[i] + len(''.join(pieces[i:j + 1])))\n    return dp[n]\n\ndef"
    },
    {
        "number": 3374,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def capacitance(G):\n        return [g1 + g2 for g1, g2 in zip(G, G[1:])]\n\n    def potential(G):\n        return [g2 - g1 for g1, g2 in zip(G, G[1:])]\n\n    def inductance(G):\n        return [g1 * g2 for g1, g2 in zip(G, G[1:])]\n\n    def UW_distance(G, A, B):\n        return sum(abs(potential(G) * (capacitance(G) * capacitance(G) - inductance(G)) - A * B))\n\n    def gravity_dispersal(G, d):\n        return [g - 1 if d == 'h' else g + 1 for g in G]\n\n    n, e = map(int, stdin.split()[:2])\n    G = list(map(int, stdin.split()[2:2 + n]))\n    d = list(map(str, stdin.split()[2 + n:2 + n + n]))\n    links = list(map(int, stdin.split()[2 + n + n:]))\n    links = [tuple(links[i:i + 2]) for i in range(0, e * 2, 2)]\n\n    alien_system = d.index('a')\n    human_system = d.index('h')\n\n    G_dispersal = gravity_dispersal(G, d[alien_system])\n    G_dispersal = gravity_dispersal(G_dispersal, d[human_system])\n\n    A = UW_distance(G, 1, 1)\n    B = UW_distance(G_dispersal, 1, 1)\n\n    return min(A, B)\n"
    },
    {
        "number": 3375,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(graph, visited, cycle, start):\n        visited[start] = True\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                if dfs(graph, visited, cycle, neighbor):\n                    cycle.append(neighbor)\n                    return True\n                elif neighbor in cycle:\n                    return True\n        return False\n\n    def count_unicycles(graph):\n        count = 0\n        for vertex in range(V):\n            visited = [False] * V\n            cycle = []\n            if dfs(graph, visited, cycle, vertex):\n                count += 1\n        return count\n\n    def is_spanning(graph, subgraph):\n        visited = [False] * V\n        for vertex in subgraph:\n            visited[vertex] = True\n        for vertex in range(V):\n            if not visited[vertex]:\n                return False\n        return True\n\n    def find_unicycles(graph):\n        unicycles = []\n        for subgraph in itertools.permutations(range(V)):\n            if is_spanning(graph, subgraph):\n                unicycles.append(subgraph)\n        return unicycles\n\n    def count_unicycles_modulo(unicycles):\n        count = 0\n        for cycle in unicycles:\n            count += count_unicycles(cycle)\n        return count % (10**9 + 7)\n\n    V, E = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    graph = [[] for _ in range(V)]\n    for a, b in edges:\n        graph[a - 1].append(b - 1)\n        graph[b - 1].append(a - 1)\n\n    unicycles = find_unicycles(graph)\n    return str(count_unicycles_modulo(unicycles))\n"
    },
    {
        "number": 3376,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    families = []\n    for i in range(1, len(input_data), 2):\n        family = input_data[i].split()\n        families.append(family)\n\n    n = int(input_data[-1])\n    caught_nudgemons = []\n    for i in range(n):\n        time, nudgemon = input_data[i+n].split()\n        caught_nudgemons.append((int(time), nudgemon))\n\n    max_xp = 0\n    current_time = 0\n    for time, nudgemon in caught_nudgemons:\n        if time > current_time:\n            current_time = time\n        for family in families:\n            if nudgemon in family:\n                max_xp += 100\n                if family.index(nudgemon) == 0:\n                    max_xp += 500\n                break\n\n    return str(max_xp)"
    },
    {
        "number": 3377,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    strategic_points = [[] for _ in range(n)]\n    for i in range(1, n+1):\n        p = int(input_list[i])\n        strategic_points[i-1] = list(map(int, input_list[i+1].split()))\n\n    t = int(input_list[n+1])\n    dry_plan = list(map(int, input_list[n+2:n+2+t]))\n\n    wet_plan = dry_plan.copy()\n    pegs = [False] * n\n    for step in dry_plan:\n        pegs[step-1] = True\n\n    for i in range(n):\n        if not pegs[i]:\n            wet_plan.append(i+1)\n\n    wet_plan.sort()\n    wet_plan = [x-1 for x in wet_plan]\n\n    if len(wet_plan) > 10*len(dry_plan):\n        return \"-1\"\n\n    return \"\\n\".join(map(str, [len(wet_plan)] + wet_plan))"
    },
    {
        "number": 3378,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_min_price(origin, destination, ticket_type, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == ticket_type:\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate(airfares):\n            if fare[0] == origin and fare[1] == destination and fare[2] == 'R':\n                min_price = min(min_price, fare[3])\n        return min_price\n\n    def get_min_price_with_return_and_origin_and_destination(origin, destination, airfares):\n        min_price = float('inf')\n        for i, fare in enumerate"
    },
    {
        "number": 3379,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    edges = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Build the graph\n    graph = [[] for _ in range(n)]\n    for edge in edges:\n        graph[edge[0]].append(edge[1])\n\n    # Kahn's Algorithm\n    L = []\n    S = [i for i in range(n) if not graph[i]]\n\n    while S:\n        alpha = S.pop(0)\n        L.append(alpha)\n        for neighbor in graph[alpha]:\n            graph[alpha].remove(neighbor)\n            if not graph[neighbor]:\n                S.append(neighbor)\n\n    # Determine the largest possible size of S at the beginning of any iteration of Step 1\n    max_size = 0\n    for i in range(n):\n        if not graph[i]:\n            max_size += 1\n\n    return str(max_size)"
    },
    {
        "number": 3380,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    M = N * (N - 1) // 2\n    return str(1 - (1 - 1 / M) ** M)\n\n\ndef"
    },
    {
        "number": 3381,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    x_coords = [0] * N\n    y_coords = [0] * N\n\n    for i in range(N):\n        x_coords[i], y_coords[i] = map(int, input().split())\n\n    for i in range(N):\n        print(x_coords[i], y_coords[i])"
    },
    {
        "number": 3382,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    base_values = list(map(int, stdin.split()))\n    base_values.sort()\n\n    def is_valid(expression: str) -> bool:\n        try:\n            return str(eval(expression)) == \"24\"\n        except:\n            return False\n\n    def grade(expression: str) -> int:\n        return expression.count(\"(\") + 2 * expression.count(\"3 5 5 2\")\n\n    def find_lowest_grade(base_values: list) -> str:\n        expressions = []\n        for i in range(len(base_values)):\n            for j in range(i + 1, len(base_values)):\n                for k in range(j + 1, len(base_values)):\n                    for l in range(k + 1, len(base_values)):\n                        expression = f\"{base_values[i]}+{base_values[j]}-{base_values[k]}*{base_values[l]}\"\n                        if is_valid(expression):\n                            expressions.append((expression, grade(expression)))\n\n        if not expressions:\n            return \"impossible\"\n\n        return min(expressions, key=lambda x: x[1])[0]\n\n    return grade(find_lowest_grade(base_values))\n"
    },
    {
        "number": 3383,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k, a, b = map(int, input_list[0].split())\n    t_i = list(map(int, input_list[1].split()))\n    u_ij = [[0 for _ in range(k)] for _ in range(k)]\n    for i in range(k):\n        u_ij[i] = list(map(int, input_list[i+2].split()))\n\n    # Calculate the maximum possible tastiness per gold coin ratio\n    max_tastiness = 0\n    for i in range(k):\n        for j in range(k):\n            max_tastiness = max(max_tastiness, t_i[i] + t_i[j] + u_ij[i][j])\n\n    # Check if it is possible to get an ice cream with positive tastiness\n    if max_tastiness <= 0:\n        return \"0\"\n\n    # Calculate the cost of an ice cream\n    cost = a * n + b\n\n    # Calculate the quotient of the tastiness and the cost of an ice cream\n    tastiness_per_gold_coin = max_tastiness / cost\n\n    return round(tastiness_per_gold_coin, 6)"
    },
    {
        "number": 3384,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    handsome_numbers = []\n    while N > 0:\n        if len(handsome_numbers) > 0 and (handsome_numbers[-1] % 10) == (N % 10):\n            handsome_numbers.append(handsome_numbers[-1] + 1)\n        else:\n            handsome_numbers.append(N)\n        N //= 10\n    closest_numbers = [handsome_numbers[i] for i in range(len(handsome_numbers)) if (handsome_numbers[i] % 10) != (handsome_numbers[i-1] % 10)]\n    if len(closest_numbers) == 1:\n        return str(closest_numbers[0])\n    else:\n        return f\"{closest_numbers[0]} {closest_numbers[1]}\"\n"
    },
    {
        "number": 3385,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    lr_x = [list(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    def count_orange_pumpkin(i, lr_x):\n        count = 0\n        for j in range(i - lr_x[i][0], i + lr_x[i][1] + 1):\n            count += lr_x[j % n][2]\n        return count\n\n    def count_costume_assignments(n, lr_x):\n        MOD = 10**9 + 7\n        dp = [[0] * 2 for _ in range(n)]\n        dp[0][0] = 1\n        dp[0][1] = 1\n\n        for i in range(1, n):\n            for j in range(2):\n                if lr_x[i][2] == j:\n                    dp[i][j] = dp[i - 1][(j + 1) % 2]\n                else:\n                    dp[i][j] = dp[i - 1][j] + dp[i - 1][(j + 1) % 2]\n                dp[i][j] %= MOD\n\n        return dp[n - 1][0]\n\n    orange_pumpkin_count = sum(count_orange_pumpkin(i, lr_x) for i in range(n))\n    if orange_pumpkin_count % 2 == 0:\n        return count_costume_assignments(n, lr_x)\n    else:\n        return 0\n"
    },
    {
        "number": 3386,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if N < 2 or M < 2:\n        return -1\n\n    def manhattan_distance(p, q):\n        return abs(p[0] - q[0]) + abs(p[1] - q[1])\n\n    def is_valid_tour(tour):\n        for i in range(len(tour) - 1):\n            if manhattan_distance(tour[i], tour[i + 1]) not in [2, 3]:\n                return False\n        return True\n\n    def find_tour(N, M):\n        tour = [(1, 1)]\n        visited = {(1, 1)}\n        next_row, next_col = 1, 2\n\n        while len(visited) < N * M:\n            if next_row == N and next_col == 1:\n                next_row, next_col = 1, 2\n            elif next_row == N and next_col == M:\n                next_row, next_col = N - 1, M - 1\n            elif next_row == 1 and next_col == M:\n                next_row, next_col = 2, M - 1\n            elif next_row == N and next_col == M - 1:\n                next_row, next_col = N - 1, M\n\n            if (next_row, next_col) not in visited:\n                tour.append((next_row, next_col))\n                visited.add((next_row, next_col))\n\n            next_row, next_col = next_row + 1, next_col + 1\n\n        return tour\n\n    tour = find_tour(N, M)\n    if not is_valid_tour(tour):\n        return -1\n\n    return \"\\n\".join(f\"{row} {col}\" for row, col in tour)\n"
    },
    {
        "number": 3387,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def objective_function(x: List[float]) -> float:\n        return sum((xi - yi) ** 2 / yi for xi, yi in zip(x, y))\n\n    def allocate_bandwidth(x: List[float]) -> List[float]:\n        total_bandwidth = sum(x)\n        allocated_bandwidth = [total_bandwidth * di / sum_di for di, sum_di in zip(d, sum_d)]\n        return [max(ai, min(bi, xi)) for xi, ai, bi in zip(allocated_bandwidth, a, b)]\n\n    n, t = map(int, stdin.split()[:2])\n    a, b, d = zip(*[map(int, stdin.split()[2:]) for _ in range(n)])\n\n    y = [t * di / sum(d) for di in d]\n    sum_d = sum(d)\n\n    x0 = [1.0] * n\n    x = fmin(objective_function, x0, args=(y,), maxfun=10000, maxiter=10000)\n\n    return '\\n'.join(f'{allocated_bandwidth:.6f}' for allocated_bandwidth in allocate_bandwidth(x))\n"
    },
    {
        "number": 3388,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *points = map(int, stdin.split())\n    points = sorted(points, reverse=True)\n    max_points = points[0]\n    lead_count = 0\n    for i in range(1, n):\n        if points[i] < max_points:\n            lead_count += 1\n        else:\n            max_points = points[i]\n    return lead_count + 1\n"
    },
    {
        "number": 3389,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    video_types = stdin.split()[2]\n\n    # Count the number of videos of each type\n    type_count = [0] * k\n    for char in video_types:\n        type_count[ord(char) - ord('a')] += 1\n\n    # Calculate the minimum number of clicks required\n    min_clicks = 0\n    for count in type_count:\n        min_clicks += count\n\n    # Subtract the number of videos of each type that can be watched in one click\n    for i in range(k):\n        min_clicks -= min(type_count[i], 1)\n\n    return str(min_clicks)\n"
    },
    {
        "number": 3390,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    compatibilities = [tuple(map(int, line.split())) for line in input_list[1:]]\n\n    # Create a graph to represent the compatibilities\n    graph = [[] for _ in range(n + 1)]\n    for a, b in compatibilities:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Perform a depth-first search to find the maximum number of courses\n    def dfs(node, visited, stack, max_courses):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                stack.append(neighbor)\n                dfs(neighbor, visited, stack, max_courses)\n        if len(stack) >= 2:\n            max_courses = max(max_courses, len(stack) - 1)\n        stack.pop()\n        return max_courses\n\n    max_courses = 0\n    visited = [False] * (n + 1)\n    for node in range(1, n + 1):\n        if not visited[node]:\n            stack = [node]\n            max_courses = max(max_courses, dfs(node, visited, stack, max_courses))\n\n    return str(max_courses)"
    },
    {
        "number": 3391,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_zone(x, y, houses):\n        for house in houses:\n            if abs(house[0] - x) <= 1 and abs(house[1] - y) <= 1:\n                return False\n        return True\n\n    def min_zone_side(houses):\n        x_coords = [house[0] for house in houses]\n        y_coords = [house[1] for house in houses]\n        x_min, x_max = min(x_coords), max(x_coords)\n        y_min, y_max = min(y_coords), max(y_coords)\n        return (x_max - x_min) + 1, (y_max - y_min) + 1\n\n    n, q = map(int, stdin.split()[:2])\n    houses = [tuple(map(int, stdin.split()[i].split())) for i in range(2, 2 + n)]\n    for i in range(q):\n        a, b = map(int, stdin.split()[2 + n + i].split())\n        zone_houses = [houses[j - 1] for j in range(a, b + 1)]\n        if len(zone_houses) == 1:\n            print(0)\n        else:\n            x_coords = [house[0] for house in zone_houses]\n            y_coords = [house[1] for house in zone_houses]\n            x_min, x_max = min(x_coords), max(x_coords)\n            y_min, y_max = min(y_coords), max(y_coords)\n            x_side, y_side = x_max - x_min, y_max - y_min\n            min_side = min(x_side, y_side)\n            print(min_side)\n"
    },
    {
        "number": 3392,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    heights = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:N+1]]\n    growth_rates = [[int(x) for x in line.split()] for line in stdin.splitlines()[N+1:]]\n\n    def dfs(tree, visited, heights, growth_rates, current_height, current_growth_rate):\n        visited[tree] = True\n        for neighbor in [(tree[0]-1, tree[1]), (tree[0]+1, tree[1]), (tree[0], tree[1]-1), (tree[0], tree[1]+1)]:\n            if neighbor[0] >= 0 and neighbor[0] < N and neighbor[1] >= 0 and neighbor[1] < N and not visited[neighbor] and heights[neighbor[0]][neighbor[1]] == heights[tree[0]][tree[1]]:\n                dfs(neighbor, visited, heights, growth_rates, current_height + growth_rates[tree[0]][tree[1]] * current_growth_rate, current_growth_rate)\n\n    max_size = 0\n    for i in range(N):\n        for j in range(N):\n            visited = [False] * N * N\n            dfs((i, j), visited, heights, growth_rates, 0, 1)\n            max_size = max(max_size, sum(visited))\n\n    return max_size"
    },
    {
        "number": 3393,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    courses = [line.strip().split() for line in stdin.split('\\n')[1:n+1]]\n    courses.sort(key=lambda x: int(x[1]), reverse=True)\n    total_difficulty = 0\n    for i in range(k):\n        total_difficulty += int(courses[i][1])\n    return total_difficulty\n"
    },
    {
        "number": 3394,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        prev = [-1] * n\n\n        while True:\n            u = -1\n            min_dist = float('inf')\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    u = i\n                    min_dist = dist[i]\n\n            if u == end:\n                break\n\n            visited[u] = True\n            for v in range(n):\n                if not visited[v] and graph[u][v] != float('inf'):\n                    if dist[u] + graph[u][v] < dist[v]:\n                        dist[v] = dist[u] + graph[u][v]\n                        prev[v] = u\n\n        path = []\n        v = end\n        while v != -1:\n            path.append(v)\n            v = prev[v]\n        path.reverse()\n        return path\n\n    def find_shortest_path(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n\n        while True:\n            u = -1\n            min_dist = float('inf')\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    u = i\n                    min_dist = dist[i]\n\n            if u == end:\n                break\n\n            visited[u] = True\n            for v in range(n):\n                if not visited[v] and graph[u][v] != float('inf'):\n                    if dist[u] + graph[u][v] < dist[v]:\n                        dist[v] = dist[u] + graph[u][v]\n\n        return dist[end]\n\n    def find_longest_waiting_time(orders, n):\n        graph = [[float('inf')] * n for _ in range(n)]\n        for i in range(n):\n            graph[0][i] = 0\n\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    if graph[j][k] == float('inf'):\n                        continue\n                    if graph[j][i] + graph[i][k] < graph[j][k]:\n                        graph[j][k] = graph[j][i] + graph[i][k]\n\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    if graph[j][k] == float('inf'):\n                        continue\n                    if graph[j][i] + graph[i][k] < graph[j][k]:\n                        graph[j][k] = graph[j][i] + graph[i][k]\n\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    if graph[j][k] == float('inf'):\n                        continue\n                    if graph[j][i] + graph[i][k] < graph[j][k]:\n                        graph[j][k] = graph[j][i] + graph[i][k]\n\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    if graph[j][k] == float('inf'):\n                        continue\n                    if graph[j][i] + graph[i][k] < graph[j][k]:\n                        graph[j][k] = graph[j][i] + graph[i][k]\n\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    if graph[j][k] == float('inf'):\n                        continue\n                    if graph[j][i] + graph[i][k] < graph[j][k]:\n                        graph[j][k] = graph[j][i] + graph[i][k]"
    },
    {
        "number": 3395,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, k = map(int, input_list[0].split())\n    iron_ore_cells = list(map(int, input_list[1].split()))\n    coal_cells = list(map(int, input_list[2].split()))\n    cell_connections = [list(map(int, input_list[i].split()[1:])) for i in range(3, 3 + n)]\n\n    def get_neighbours(cell_id: int) -> List[int]:\n        return cell_connections[cell_id - 1]\n\n    def is_accessible(cell_id: int, visited: Set[int]) -> bool:\n        if cell_id in visited:\n            return False\n        visited.add(cell_id)\n        for neighbour in get_neighbours(cell_id):\n            if is_accessible(neighbour, visited):\n                return True\n        return False\n\n    def count_settlers(cell_id: int, visited: Set[int], settlers: int) -> int:\n        if cell_id in visited:\n            return settlers\n        visited.add(cell_id)\n        for neighbour in get_neighbours(cell_id):\n            settlers = count_settlers(neighbour, visited, settlers + 1)\n        return settlers\n\n    iron_ore_count = 0\n    coal_count = 0\n    for cell_id in iron_ore_cells:\n        if is_accessible(cell_id, set()):\n            iron_ore_count += count_settlers(cell_id, set(), 1)\n    for cell_id in coal_cells:\n        if is_accessible(cell_id, set()):\n            coal_count += count_settlers(cell_id, set(), 1)\n\n    if iron_ore_count > 0 and coal_count > 0:\n        return \"impossible\"\n    return max(iron_ore_count, coal_count)\n"
    },
    {
        "number": 3396,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    n = int(stdin.splitlines()[0])\n    posts = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    max_rope = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            max_rope += distance(*posts[i], *posts[j])\n\n    return f\"{max_rope:.2f}\"\n"
    },
    {
        "number": 3397,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    t = [[0 for _ in range(M)] for _ in range(N)]\n    for i in range(N):\n        t[i] = list(map(int, stdin.split()[i+1:i+M+1]))\n\n    dp = [[0 for _ in range(M)] for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if i == 0:\n                dp[i][j] = t[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][k] + t[i][j] for k in range(M))\n\n    return dp[N-1][M-1]\n"
    },
    {
        "number": 3398,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n_r, n_c, n, m = map(int, input_list[:4])\n    files_to_delete = input_list[4:4+n]\n    files_to_keep = input_list[4+n:]\n\n    def is_delete_rectangle(r1, c1, r2, c2):\n        return r1 <= r2 and c1 <= c2\n\n    def delete_rectangle_size(r1, c1, r2, c2):\n        return (r2 - r1 + 1) * (c2 - c1 + 1)\n\n    def delete_rectangle_overlap(r1, c1, r2, c2, r3, c3, r4, c4):\n        return (r1 <= r3 <= r2) and (c1 <= c3 <= c2) or (r1 <= r4 <= r2) and (c1 <= c4 <= c2)\n\n    def delete_rectangle_contains(r1, c1, r2, c2, r3, c3, r4, c4):\n        return (r1 <= r3 <= r2) and (c1 <= c3 <= c2) and (r1 <= r4 <= r2) and (c1 <= c4 <= c2)\n\n    def delete_rectangle_contains_file(r1, c1, r2, c2, file):\n        return (r1 <= file[0] <= r2) and (c1 <= file[1] <= c2)\n\n    def move_file(file, r, c):\n        return (file[0] + r, file[1] + c)\n\n    def is_valid_move(file, r, c, files_to_delete, files_to_keep):\n        return not any(delete_rectangle_contains_file(file[0], file[1], file[0] + r, file[1] + c, delete_file) for delete_file in files_to_delete) and not any(delete_rectangle_contains_file(file[0], file[1], file[0] + r, file[1] + c, keep_file) for keep_file in files_to_keep)\n\n    def min_moves(files_to_delete, files_to_keep):\n        min_moves = 0\n        for i in range(len(files_to_delete)):\n            for j in range(len(files_to_delete)):\n                if i != j and delete_rectangle_overlap(files_to_delete[i][0], files_to_delete[i][1], files_to_delete[i][0] + 1, files_to_delete[i][1] + 1, files_to_delete[j][0], files_to_delete[j][1], files_to_delete[j][0] + 1, files_to_delete[j][1] + 1):\n                    min_moves += delete_rectangle_size(files_to_delete[i][0], files_to_delete[i][1], files_to_delete[i][0] + 1, files_to_delete[i][1] + 1)\n        return min_moves\n\n    def move_files(files_to_delete, files_to_keep):\n        min_moves = min_moves(files_to_delete, files_to_keep)\n        for i in range(len(files_to_delete)):\n            for j in range(len(files_to_delete)):\n                if i != j and delete_rectangle_overlap(files_to_delete[i][0], files_to_delete[i][1], files_to_delete[i][0] + 1, files_to_delete[i][1] + 1, files_to_delete[j][0], files_to_delete[j][1], files_to_delete[j][0] + 1, files_to_delete[j][1] + 1):\n                    for r in range(1, n_r - files_to_delete[i][0] + 1):\n                        for c in range(1, n_c - files_to_delete[i][1] + 1):\n                            if is_valid_move"
    },
    {
        "number": 3399,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split(','))\n    grid = [line.strip() for line in stdin.split('\\n')[1:]]\n\n    def dfs(x, y, lang, visited):\n        if x < 0 or x >= n or y < 0 or y >= m or visited[x][y] or grid[x][y] != lang:\n            return False\n        visited[x][y] = True\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(x + dx, y + dy, lang, visited):\n                return True\n        return False\n\n    def find_region(lang):\n        visited = [[False for _ in range(m)] for _ in range(n)]\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if not visited[i][j] and grid[i][j] == lang:\n                    count += 1\n                    dfs(i, j, lang, visited)\n        return count\n\n    arwegian_count = sum(row.count('1') for row in grid)\n    banish_count = sum(row.count('2') for row in grid)\n    cwedish_count = n * m - arwegian_count - banish_count\n\n    if arwegian_count == 0 or banish_count == 0 or cwedish_count == 0:\n        return \"impossible\"\n\n    arwegian_region = find_region('1')\n    banish_region = find_region('2')\n    cwedish_region = n * m - arwegian_region - banish_region\n\n    if arwegian_region == 0 or banish_region == 0 or cwedish_region == 0:\n        return \"impossible\"\n\n    arwegian_grid = [['A' if grid[i][j] == '1' else '.' for j in range(m)] for i in range(n)]\n    banish_grid = [['B' if grid[i][j] == '2' else '.' for j in range(m)] for i in range(n)]\n    cwedish_grid = [['C' if grid[i][j] == '2' else '.' for j in range(m)] for i in range(n)]\n\n    return '\\n'.join([''.join(row) for row in arwegian_grid] + [''] * 2 + [''.join(row) for row in banish_grid] + [''] * 2 + [''.join(row) for row in cwedish_grid]) "
    },
    {
        "number": 3400,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, R, T = map(int, stdin.split())\n    trips = []\n    for _ in range(T):\n        trip = list(map(int, input().split()[1:]))\n        trips.append(trip)\n\n    def find_trip_duration(trip):\n        duration = 0\n        for i in range(len(trip) - 1):\n            duration += trips[trip[i] - 1][trip[i + 1] - 1]\n        return duration\n\n    def find_shortest_trip(start, end):\n        visited = set()\n        queue = [(start, 0)]\n        while queue:\n            node, dist = queue.pop(0)\n            if node == end:\n                return dist\n            if node not in visited:\n                visited.add(node)\n                for neighbor in range(1, N + 1):\n                    if neighbor not in visited:\n                        queue.append((neighbor, dist + find_trip_duration([node, neighbor])))\n        return -1\n\n    shortest_trip = float('inf')\n    for i in range(1, N + 1):\n        shortest_trip = min(shortest_trip, find_shortest_trip(A, i))\n\n    return shortest_trip"
    },
    {
        "number": 3401,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def find_closest_hill(x, y, hills):\n        closest_hill = None\n        min_distance = float('inf')\n        for i, (x_i, y_i, h_i) in enumerate(hills):\n            d = distance(x, y, x_i, y_i)\n            if d < min_distance:\n                min_distance = d\n                closest_hill = i\n        return closest_hill\n\n    def find_closest_spring(x, y, hills, springs):\n        closest_spring = None\n        min_distance = float('inf')\n        for i in springs:\n            x_i, y_i, h_i = hills[i - 1]\n            d = distance(x, y, x_i, y_i)\n            if d < min_distance:\n                min_distance = d\n                closest_spring = i\n        return closest_spring\n\n    def find_closest_town(x, y, hills, towns):\n        closest_town = None\n        min_distance = float('inf')\n        for i in towns:\n            x_i, y_i, h_i = hills[i - 1]\n            d = distance(x, y, x_i, y_i)\n            if d < min_distance:\n                min_distance = d\n                closest_town = i\n        return closest_town\n\n    def find_aqueduct_length(x1, y1, x2, y2):\n        d = distance(x1, y1, x2, y2)\n        return d\n\n    def find_aqueducts(hills, springs, towns):\n        aqueducts = []\n        for i in range(len(hills)):\n            if i + 1 in springs:\n                aqueducts.append((i + 1, None))\n            elif i + 1 in towns:\n                closest_spring = find_closest_spring(hills[i][0], hills[i][1], hills, springs)\n                if closest_spring is not None:\n                    aqueducts.append((i + 1, closest_spring))\n        return aqueducts\n\n    def find_min_aqueduct_length(aqueducts, hills, springs, towns):\n        min_length = float('inf')\n        for i in range(len(hills)):\n            if i + 1 in springs:\n                min_length = min(min_length, find_aqueduct_length(hills[i][0], hills[i][1], hills[i][0], hills[i][1]))\n            elif i + 1 in towns:\n                closest_spring = find_closest_spring(hills[i][0], hills[i][1], hills, springs)\n                if closest_spring is not None:\n                    min_length = min(min_length, find_aqueduct_length(hills[i][0], hills[i][1], hills[closest_spring - 1][0], hills[closest_spring - 1][1]))\n        return min_length\n\n    def main(n, s, t, q, hills, springs, towns):\n        aqueducts = find_aqueducts(hills, springs, towns)\n        min_length = find_min_aqueduct_length(aqueducts, hills, springs, towns)\n        return min_length\n\n    lines = stdin.splitlines()\n    n, s, t, q = map(int, lines[0].split())\n    hills = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n    springs = set(map(int, lines[n + 1].split()))\n    towns = set(map(int, lines[n + 2].split()))\n\n    result = main(n, s, t, q, hills, springs, towns)\n    if result == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return round(result, 6)\n"
    },
    {
        "number": 3402,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S, T1, T2, K, M = stdin.split('\\n')\n    T1, T2 = T1.split(), T2.split()\n    T = T1 + T2\n    T = [t.split() for t in T]\n    T = [''.join(t) for t in T]\n    T = dict(zip('abcdefghijklmnopqrstuvwxyz', T))\n\n    def f(s: str) -> str:\n        return ''.join(T[c] for c in s)\n\n    P = f(S)\n    for _ in range(K - 1):\n        P = f(P)\n\n    m = [int(x) - 1 for x in M.split()]\n    for i in m:\n        print(P[i])\n"
    },
    {
        "number": 3403,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def longest_common_prefix(s1: str, s2: str) -> str:\n        i = 0\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]:\n            i += 1\n        return s1[:i]\n\n    def compare_words(w1: str, w2: str) -> int:\n        i = 0\n        while i < len(w1) and i < len(w2) and w1[i] == w2[i]:\n            i += 1\n        return i\n\n    N, *words = stdin.split()\n    N = int(N)\n    words = words[:N]\n\n    Q, *queries = stdin.split()\n    Q = int(Q)\n    queries = queries[N:]\n\n    for query in queries:\n        longest_prefix = \"\"\n        for word in words:\n            common_prefix = longest_common_prefix(query, word)\n            if len(common_prefix) > len(longest_prefix):\n                longest_prefix = common_prefix\n        steps = compare_words(query, longest_prefix)\n        print(steps)\n"
    },
    {
        "number": 3404,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split()[:2])\n    encrypted_message = stdin.split()[2]\n\n    def f(x):\n        return (33 * x + 1) % 2**20\n\n    def fill_grid(grid, row, col, value):\n        if col >= X:\n            return\n        grid[row][col] = value\n        fill_grid(grid, row + 1, col, f(value))\n\n    grid = [[0] * X for _ in range(X)]\n    fill_grid(grid, 0, 0, 0)\n\n    column_sums = [sum(row) % 2**20 for row in grid]\n    one_time_pad = int(''.join(str(x) for x in column_sums))\n    shift_pad = [ord(c) - 26 if c != ' ' else 26 for c in encrypted_message]\n    decrypted_message = ''.join(chr((shift + one_time_pad) % 27) for shift in shift_pad)\n\n    return decrypted_message\n"
    },
    {
        "number": 3405,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = float(stdin)\n    if X < 1 or X >= 1000:\n        return \"Invalid input\"\n\n    def move_first_digit(num: int) -> int:\n        return int(str(num)[1:] + str(num)[0])\n\n    def multiply_by_X(num: int) -> int:\n        return int(str(num)[:-1] + str(num)[-1] * X)\n\n    solutions = []\n    for num in range(1, 10**8):\n        if move_first_digit(num) == multiply_by_X(num):\n            solutions.append(num)\n\n    if not solutions:\n        return \"No solution\"\n    else:\n        return \"\\n\".join(str(solution) for solution in solutions)\n"
    },
    {
        "number": 3406,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    Nazi_troops = [(int(x), int(y)) for x, y in [line.split() for line in input_list[1:N+1]]]\n    S = int(input_list[N+1])\n    castles = [(int(x), int(y)) for x, y in [line.split() for line in input_list[N+2:N+2+S]]]\n\n    in_danger_castles = 0\n    for castle in castles:\n        for i in range(N):\n            for j in range(i+1, N):\n                for k in range(j+1, N):\n                    for l in range(k+1, N):\n                        if is_non_degenerate_quadrilateral(Nazi_troops[i], Nazi_troops[j], Nazi_troops[k], Nazi_troops[l], castle):\n                            in_danger_castles += 1\n                            break\n                    else:\n                        continue\n                    break\n                else:\n                    continue\n                break\n\n    return str(in_danger_castles)\n\ndef"
    },
    {
        "number": 3407,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_valid(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if distance(points[i], points[j]) < 1e-4:\n                    return False\n        return True\n\n    def euclidean_distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_valid_edge(p1, p2, points):\n        for point in points:\n            if point == p1 or point == p2:\n                continue\n            if euclidean_distance(point, p1) < 1e-6 and euclidean_distance(point, p2) < 1e-6:\n                return False\n        return True\n\n    def is_valid_solution(points):\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                if not is_valid_edge(points[i], points[j], points):\n                    return False\n        return True\n\n    def generate_solution(points):\n        def dfs(node, visited, path, result):\n            visited[node] = True\n            path.append(node)\n\n            for neighbor in range(len(points)):\n                if not visited[neighbor] and is_valid_edge(points[node], points[neighbor], path):\n                    if dfs(neighbor, visited, path, result):\n                        result.append(path.copy())\n                        return True\n\n            path.pop()\n            visited[node] = False\n            return False\n\n        visited = [False] * len(points)\n        result = []\n        for i in range(len(points)):\n            if not visited[i]:\n                dfs(i, visited, [], result)\n\n        return result\n\n    def generate_solution_with_distance(points):\n        def dfs(node, visited, path, result):\n            visited[node] = True\n            path.append(node)\n\n            for neighbor in range(len(points)):\n                if not visited[neighbor] and is_valid_edge(points[node], points[neighbor], path):\n                    if dfs(neighbor, visited, path, result):\n                        result.append(path.copy())\n                        return True\n\n            path.pop()\n            visited[node] = False\n            return False\n\n        visited = [False] * len(points)\n        result = []\n        for i in range(len(points)):\n            if not visited[i]:\n                dfs(i, visited, [], result)\n\n        for solution in result:\n            for i in range(len(solution)):\n                for j in range(i + 1, len(solution)):\n                    if euclidean_distance(points[solution[i]], points[solution[j]]) > 1:\n                        solution.insert(i + 1, solution[i] + (solution[i + 1] - solution[i]) / 2)\n                        solution.insert(i + 2, solution[i] + (solution[i + 2] - solution[i]) / 2)\n                        break\n\n        return result\n\n    def generate_solution_with_distance_and_length(points):\n        def dfs(node, visited, path, result):\n            visited[node] = True\n            path.append(node)\n\n            for neighbor in range(len(points)):\n                if not visited[neighbor] and is_valid_edge(points[node], points[neighbor], path):\n                    if dfs(neighbor, visited, path, result):\n                        result.append(path.copy())\n                        return True\n\n            path.pop()\n            visited[node] = False\n            return False\n\n        visited = [False] * len(points)\n        result = []\n        for i in range(len(points)):\n            if not visited[i]:"
    },
    {
        "number": 3408,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    words = stdin.split('\\n')[1:N+1]\n    patterns = stdin.split('\\n')[N+1:N+1+Q]\n    count = [0] * Q\n\n    for i, pattern in enumerate(patterns):\n        for word in words:\n            if pattern == '*' * len(pattern):\n                count[i] += 1\n            elif pattern == '*':\n                count[i] += 1\n            elif len(pattern) == len(word):\n                if all(c == '*' or c == w for c, w in zip(pattern, word)):\n                    count[i] += 1\n\n    return '\\n'.join(map(str, count))\n"
    },
    {
        "number": 3409,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, c = map(int, input_list[0].split())\n    starting_config = input_list[1:r+1]\n    target_config = input_list[r+1:]\n\n    def hammer_peg(row, col):\n        if starting_config[row][col] == 'O':\n            starting_config[row] = starting_config[row][:col] + 'X' + starting_config[row][col+1:]\n            for i in range(r):\n                if starting_config[i][col] == 'O':\n                    starting_config[i] = starting_config[i][:col] + 'X' + starting_config[i][col+1:]\n        return starting_config\n\n    def check_target_config():\n        for row in range(r):\n            for col in range(c):\n                if starting_config[row][col] == 'O' and target_config[row][col] == 'X':\n                    return False\n        return True\n\n    for row in range(r):\n        for col in range(c):\n            if target_config[row][col] == 'X':\n                hammer_peg(row, col)\n\n    if check_target_config():\n        return \"1\"\n    else:\n        return \"0\""
    },
    {
        "number": 3410,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *points = stdin.split()\n    N = int(N)\n    points = [tuple(map(int, point.split(','))) for point in points]\n\n    def is_collinear(p1, p2, p3):\n        return (p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) == 0\n\n    def quadrilateral_area(p1, p2, p3, p4):\n        return abs((p1[0] * p2[1] + p2[0] * p3[1] + p3[0] * p4[1] + p4[0] * p1[1]) - (p1[1] * p2[0] + p2[1] * p3[0] + p3[1] * p4[0] + p4[1] * p1[0])) // 2\n\n    def play_game(points):\n        scores = [0, 0]\n        used_points = set()\n        current_player = 0\n\n        while len(used_points) < 2 * N:\n            p1, p2, p3, p4 = points[current_player]\n\n            if (p1, p2, p3, p4) not in used_points and not is_collinear(p1, p2, p3) and not is_collinear(p1, p3, p4) and not is_collinear(p2, p3, p4):\n                used_points.add((p1, p2, p3, p4))\n                scores[current_player] += quadrilateral_area(p1, p2, p3, p4)\n                current_player = (current_player + 1) % 2\n\n        return scores\n\n    scores = play_game(points)\n    return (scores[0] + scores[1]) % 1000003\n"
    },
    {
        "number": 3411,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, c, r = map(int, stdin.split()[:3])\n    scores = list(map(int, stdin.split()[3:]))\n\n    # Calculate the time to make the chain alternating\n    time = 0\n    for i in range(n - 1):\n        if scores[i] * scores[i + 1] < 0:\n            continue\n        if scores[i] == 0:\n            time += c\n        if scores[i + 1] == 0:\n            time += c\n        time += r\n\n    return str(time)\n"
    },
    {
        "number": 3412,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def closest_bike_station(x, y, bike_stations):\n        min_distance = float('inf')\n        closest_station = None\n        for station in bike_stations:\n            station_x, station_y = station\n            distance_to_station = distance(x, y, station_x, station_y)\n            if distance_to_station < min_distance:\n                min_distance = distance_to_station\n                closest_station = station\n        return closest_station\n\n    def time_to_get_to_destination(x, y, x_dest, y_dest, speed):\n        distance_to_destination = distance(x, y, x_dest, y_dest)\n        time = distance_to_destination / speed\n        return time\n\n    def time_to_get_to_destination_with_bike(x, y, x_dest, y_dest, speed, bike_stations):\n        time_to_get_to_closest_station = time_to_get_to_destination(x, y, *bike_stations[0], speed)\n        time_to_get_to_destination = time_to_get_to_destination(bike_stations[0][0], bike_stations[0][1], x_dest, y_dest, speed)\n        time_to_return_bike = time_to_get_to_destination(x, y, *bike_stations[0], speed)\n        return time_to_get_to_closest_station + time_to_get_to_destination + time_to_return_bike\n\n    stdin_lines = stdin.splitlines()\n    v_walk, v_bike = map(int, stdin_lines[0].split())\n    x1, y1, x2, y2 = map(int, stdin_lines[1].split())\n    x_g, y_g = map(int, stdin_lines[2].split())\n    x_d, y_d = map(int, stdin_lines[3].split())\n    n = int(stdin_lines[4])\n    bike_stations = [tuple(map(int, stdin_lines[i].split())) for i in range(5, 5 + n)]\n\n    closest_station_to_g = closest_bike_station(x_g, y_g, bike_stations)\n    closest_station_to_d = closest_bike_station(x_d, y_d, bike_stations)\n\n    time_to_get_to_g_with_bike = time_to_get_to_destination_with_bike(x_g, y_g, closest_station_to_g[0], closest_station_to_g[1], v_bike, bike_stations)\n    time_to_get_to_d_with_bike = time_to_get_to_destination_with_bike(x_d, y_d, closest_station_to_d[0], closest_station_to_d[1], v_bike, bike_stations)\n\n    time_to_get_to_g = time_to_get_to_destination(x_g, y_g, x_d, y_d, v_walk)\n    time_to_get_to_d = time_to_get_to_destination(x_d, y_d, x_d, y_d, v_walk)\n\n    if time_to_get_to_g_with_bike < time_to_get_to_g:\n        time_to_get_to_g = time_to_get_to_g_with_bike\n    if time_to_get_to_d_with_bike < time_to_get_to_d:\n        time_to_get_to_d = time_to_get_to_d_with_bike\n\n    return f\"{time_to_get_to_g:.6f}\"\n\nstdin = \"\"\"1 8\n0"
    },
    {
        "number": 3413,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    party_affiliation = list(map(int, input_list[1].split()))\n    friendships = [tuple(map(int, line.split())) for line in input_list[2:]]\n\n    # Create a graph of the friendships\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b in friendships:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Perform a BFS to find the minimum number of months required\n    visited = [False] * (n + 1)\n    months = 0\n    while not all(visited):\n        months += 1\n        for i in range(1, n + 1):\n            if visited[i]:\n                continue\n            queue = [i]\n            party = party_affiliation[i - 1]\n            while queue:\n                node = queue.pop(0)\n                if visited[node]:\n                    continue\n                visited[node] = True\n                if party_affiliation[node - 1] != party:\n                    party_affiliation[node - 1] = party\n                    for neighbor in graph[node]:\n                        queue.append(neighbor)\n\n    return months\n"
    },
    {
        "number": 3414,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def eulerian_circuit(graph: list, start: int) -> float:\n        visited = [False] * len(graph)\n        visited[start] = True\n        total_turns = 0\n        current_node = start\n\n        while not all(visited):\n            next_node = None\n            for neighbor in graph[current_node]:\n                if not visited[neighbor]:\n                    next_node = neighbor\n                    break\n\n            if next_node is None:\n                # Backtrack to find a new node to visit\n                for neighbor in graph[current_node]:\n                    if visited[neighbor]:\n                        next_node = neighbor\n                        break\n\n            visited[next_node] = True\n            total_turns += math.atan2(graph[next_node][0] - graph[current_node][0], graph[next_node][1] - graph[current_node][1])\n            current_node = next_node\n\n        return total_turns\n\n    N, M = map(int, stdin.splitlines()[0].split())\n    nodes = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:N + 1]]\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[N + 1:]]\n\n    graph = [[] for _ in range(N)]\n    for i, j in edges:\n        graph[i].append(j)\n        graph[j].append(i)\n\n    start = 0\n    for i in range(N):\n        if len(graph[i]) % 2 == 1:\n            start = i\n            break\n\n    total_turns = eulerian_circuit(graph, start)\n    return total_turns\n"
    },
    {
        "number": 3415,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    if N < 1 or N > 15:\n        return \"Invalid input\"\n\n    def preorder(node: int, level: int) -> str:\n        if level == N:\n            return str(node)\n\n        left_sum = sum(preorder(2 * node, level + 1).split())\n        right_sum = sum(preorder(2 * node + 1, level + 1).split())\n        diff = 2 ** level - abs(left_sum - right_sum)\n\n        if diff == 0:\n            return f\"{node} {preorder(2 * node, level + 1)} {preorder(2 * node + 1, level + 1)}\"\n        elif diff % 2 == 0:\n            return f\"{node} {preorder(2 * node, level + 1)} {preorder(2 * node + 1, level + 1)}\"\n        else:\n            return f\"{node} {preorder(2 * node + 1, level + 1)} {preorder(2 * node, level + 1)}\"\n\n    return preorder(1, 0)\n\n\ninput_str = \"2\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3416,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_flights(n: int, m: int, adj_list: list) -> int:\n        visited = [False] * n\n        queue = [0]\n        visited[0] = True\n        min_flights = 0\n\n        while queue:\n            city = queue.pop(0)\n            min_flights += 1\n\n            for neighbor in adj_list[city]:\n                if not visited[neighbor - 1]:\n                    visited[neighbor - 1] = True\n                    queue.append(neighbor)\n\n        return min_flights\n\n    def find_airport_cities(n: int, m: int, adj_list: list, min_flights: int) -> list:\n        visited = [False] * n\n        queue = [0]\n        visited[0] = True\n        airport_cities = []\n\n        while queue:\n            city = queue.pop(0)\n\n            for neighbor in adj_list[city]:\n                if not visited[neighbor - 1]:\n                    visited[neighbor - 1] = True\n                    queue.append(neighbor)\n\n            if visited.count(True) == min_flights:\n                airport_cities.append(city + 1)\n\n        return airport_cities\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[0:2])\n        adj_list = [[] for _ in range(n)]\n        for _ in range(m):\n            a, b = map(int, stdin.split()[2:4])\n            adj_list[a - 1].append(b - 1)\n\n        min_flights = find_min_flights(n, m, adj_list)\n        airport_cities = find_airport_cities(n, m, adj_list, min_flights)\n\n        output = f\"{min_flights}\\n\"\n        if airport_cities:\n            output += \" \".join(map(str, airport_cities))\n        else:\n            output += \"\"\n\n        return output\n\n    return main(stdin)\n"
    },
    {
        "number": 3417,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_parent(parent: list, vertex: int) -> int:\n        if parent[vertex] != vertex:\n            parent[vertex] = find_parent(parent, parent[vertex])\n        return parent[vertex]\n\n    def union(parent: list, rank: list, x: int, y: int) -> None:\n        x_root = find_parent(parent, x)\n        y_root = find_parent(parent, y)\n\n        if rank[x_root] < rank[y_root]:\n            parent[x_root] = y_root\n        elif rank[x_root] > rank[y_root]:\n            parent[y_root] = x_root\n        else:\n            parent[y_root] = x_root\n            rank[x_root] += 1\n\n    n, m = map(int, stdin.split()[:2])\n    parent = list(range(n + 1))\n    rank = [0] * (n + 1)\n    edges = []\n\n    for _ in range(m):\n        a, b = map(int, stdin.split()[:2])\n        edges.append((a, b))\n\n    max_independent_set_size = 0\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in edges:\n                union(parent, rank, i, j)\n\n        max_independent_set_size += n - find_parent(parent, 1)\n\n    return max_independent_set_size\n"
    },
    {
        "number": 3418,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    supply = 0\n    for k in range(1, n+1):\n        supply += k\n    return str(supply)\n\ninput_str = input()\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3419,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s1, s2 = map(int, stdin.split()[:3])\n    t = list(map(int, stdin.split()[3:]))\n\n    # Initialize the counters with their closing times\n    counter1 = s1\n    counter2 = s2\n\n    # Initialize the number of customers served\n    served = 0\n\n    # Iterate through the customers\n    for i in range(n):\n        # If both counters have enough time, assign the customer to the counter with the least time left\n        if counter1 >= t[i] and counter2 >= t[i]:\n            if counter1 < counter2:\n                counter1 -= t[i]\n                served += 1\n            else:\n                counter2 -= t[i]\n                served += 1\n        # If only one counter has enough time, assign the customer to that counter\n        elif counter1 >= t[i]:\n            counter1 -= t[i]\n            served += 1\n        elif counter2 >= t[i]:\n            counter2 -= t[i]\n            served += 1\n        # If neither counter has enough time, break the loop\n        else:\n            break\n\n    return served"
    },
    {
        "number": 3420,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    B, G = map(int, lines[0].split())\n    boys = {}\n    girls = {}\n    for i in range(1, B + 1):\n        name, N = lines[i].split()\n        books = lines[i + 1:i + 1 + int(N)]\n        boys[name] = books\n    for i in range(B + 1, B + 1 + G):\n        name, N = lines[i].split()\n        books = lines[i + 1:i + 1 + int(N)]\n        girls[name] = books\n    presentations = []\n    for name, books in boys.items():\n        presentations.append((name, books))\n    for name, books in girls.items():\n        presentations.append((name, books))\n    presentations.sort(key=lambda x: len(x[1]), reverse=True)\n    min_presentations = 0\n    for i in range(0, len(presentations), 2):\n        min_presentations += 1\n        if i + 1 < len(presentations):\n            presentations[i + 1] = (presentations[i + 1][0], presentations[i + 1][1] + presentations[i][1])\n    return str(min_presentations)\n"
    },
    {
        "number": 3421,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, answers = stdin.split('\\n')\n    k = int(k)\n    answers = list(map(int, answers))\n\n    max_success_rate = 0\n    max_index = 0\n    max_length = 0\n\n    for i in range(k, len(answers)):\n        success_count = sum(answers[j] for j in range(i - k + 1, i + 1))\n        success_rate = success_count / k\n\n        if success_rate > max_success_rate:\n            max_success_rate = success_rate\n            max_index = i - k + 1\n            max_length = k\n\n    return f\"{max_index} {max_length}\"\n"
    },
    {
        "number": 3422,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def rotate(matrix: list) -> list:\n        return [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix[0]) - 1, -1, -1)]\n\n    def flip(matrix: list) -> list:\n        return [row[::-1] for row in matrix]\n\n    def is_valid(map_pieces: list, width: int, height: int) -> bool:\n        used_squares = set()\n        for piece in map_pieces:\n            for row in piece:\n                for square in row:\n                    if square in used_squares:\n                        return False\n                    used_squares.add(square)\n        return len(used_squares) == width * height\n\n    def reconstruct_map(map_pieces: list) -> str:\n        width = max(piece[0] for piece in map_pieces)\n        height = max(len(piece) for piece in map_pieces)\n        for _ in range(4):\n            map_matrix = [[0] * width for _ in range(height)]\n            for piece in map_pieces:\n                for i in range(len(piece)):\n                    for j in range(len(piece[0])):\n                        map_matrix[i][j] = piece[i][j]\n            if is_valid(map_pieces, width, height):\n                return map_matrix\n            map_pieces = rotate(map_pieces)\n        return None\n\n    def output_map(map_matrix: list) -> str:\n        return \"\\n\".join([\"\".join(map(str, row)) for row in map_matrix])\n\n    def output_index_map(map_matrix: list, map_pieces: list) -> str:\n        index_map = [[0] * len(map_matrix[0]) for _ in range(len(map_matrix))]\n        for i in range(len(map_matrix)):\n            for j in range(len(map_matrix[0])):\n                index_map[i][j] = map_pieces.index(str(map_matrix[i][j])) + 1\n        return \"\\n\".join([\"\".join(map(str, row)) for row in index_map])\n\n    N, *map_pieces = stdin.splitlines()\n    N = int(N)\n    map_pieces = [list(map(int, piece.split())) for piece in map_pieces]\n    map_matrix = reconstruct_map(map_pieces)\n    if map_matrix is None:\n        return \"Impossible\"\n    return output_map(map_matrix) + \"\\n\" + \"-\" * len(map_matrix[0]) + \"\\n\" + output_index_map(map_matrix, map_pieces)"
    },
    {
        "number": 3423,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def topological_sort(graph: dict) -> list:\n        visited = set()\n        stack = []\n        for node in graph:\n            if node not in visited:\n                dfs(graph, node, visited, stack)\n        return stack[::-1]\n\n    def dfs(graph: dict, node: str, visited: set, stack: list):\n        if node in visited:\n            return\n        visited.add(node)\n        for neighbor in graph[node]:\n            dfs(graph, neighbor, visited, stack)\n        stack.append(node)\n\n    def find_order(packages: list) -> str:\n        graph = {}\n        for package in packages:\n            name, dependencies = package.split()\n            graph[name] = dependencies\n        try:\n            order = topological_sort(graph)\n            return ' '.join(order)\n        except ValueError:\n            return 'cannot be ordered'\n\n    def process_test_case(stdin: str) -> str:\n        n = int(stdin.pop(0))\n        packages = []\n        for _ in range(n):\n            packages.append(stdin.pop(0))\n        return find_order(packages)\n\n    result = []\n    for test_case in stdin.split('\\n\\n'):\n        if test_case:\n            result.append(process_test_case(test_case.split('\\n')))\n        result.append('')\n    return '\\n'.join(result[:-1])\n"
    },
    {
        "number": 3424,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    y, l = map(int, stdin.split())\n    b = 10\n    while True:\n        y_base_b = format(y, f'0{b}b')\n        if all(c in '012345679' for c in y_base_b):\n            y_base_10 = int(y_base_b, b)\n            if y_base_10 >= l:\n                return b\n        b += 1"
    },
    {
        "number": 3425,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    board = [list(line) for line in stdin.split('\\n')[1:n+1]]\n\n    def is_safe(row, col, queens):\n        for i, j in queens:\n            if i == row or j == col or abs(i - row) == abs(j - col):\n                return False\n        return True\n\n    def place_queen(row, queens):\n        if row == n:\n            return 1\n        count = 0\n        for col in range(m):\n            if board[row][col] == '.':\n                if is_safe(row, col, queens):\n                    count += place_queen(row + 1, queens + [(row, col)])\n        return count\n\n    count = 0\n    for col in range(m):\n        if board[0][col] == '.':\n            count += place_queen(1, [(0, col)])\n\n    return f\"{count} {1}\"\n"
    },
    {
        "number": 3426,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    tunnels = [list(map(int, stdin.split()[2*i+2:2*i+5])) for i in range(M)]\n\n    # Initialize the distances to infinity\n    distances = [float('inf')] * N\n    distances[0] = 0\n\n    # Perform Dijkstra's algorithm to find the shortest distances from each station to the central station\n    for _ in range(N-1):\n        current = min(range(N), key=lambda i: distances[i])\n        if distances[current] == float('inf'):\n            break\n        for neighbor, length, has_cable in [(tunnels[i][0], tunnels[i][1], tunnels[i][3]) for i in range(M) if tunnels[i][0] == current or tunnels[i][1] == current]:\n            if has_cable:\n                new_distance = distances[current] + length\n                if new_distance < distances[neighbor]:\n                    distances[neighbor] = new_distance\n\n    # Find the minimum distance for each unknown tunnel\n    result = []\n    for tunnel in tunnels:\n        if tunnel[2] == '?':\n            result.append(distances[tunnel[0]] + distances[tunnel[1]])\n        else:\n            result.append(tunnel[2])\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3427,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    doors = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n\n    # Create a graph to represent the building\n    graph = [[] for _ in range(N)]\n    for u, v in doors:\n        if u != -1 and v != -1:\n            graph[u].append(v)\n            graph[v].append(u)\n\n    # Perform a depth-first search to find the maximum number of rooms that can be secured\n    def dfs(node, visited, count):\n        visited[node] = True\n        count[0] += 1\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, count)\n        return count[0]\n\n    max_rooms = 0\n    for i in range(N):\n        visited = [False] * N\n        count = [0]\n        dfs(i, visited, count)\n        max_rooms = max(max_rooms, count[0])\n\n    return str(max_rooms)"
    },
    {
        "number": 3428,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    f = {}\n    for i in range(n):\n        for j in range(i+1, n+1):\n            f[(i, j)] = gcd(a[i:j])\n    return len(set(f.values()))\n\ndef"
    },
    {
        "number": 3429,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_s, y_s, s_s, r_i, r_f = map(int, stdin.split()[:5])\n    x_a, y_a, s_a = map(int, stdin.split()[5:])\n\n    # Calculate the time it takes for Anthony to reach the safety zone\n    time_to_safety = ((r_i - r_f) / s_s) if r_i > r_f else 0\n\n    # Calculate the distance Anthony needs to travel to reach the safety zone\n    distance_to_safety = ((r_i ** 2 - r_f ** 2) ** 0.5) if r_i > r_f else 0\n\n    # Calculate the time it takes for Anthony to reach the maximum distance from the safety zone\n    time_to_max_distance = distance_to_safety / s_a\n\n    # Calculate the time it takes for Anthony to take damage\n    time_to_damage = time_to_max_distance + time_to_safety\n\n    # Calculate the damage Anthony will take\n    damage = time_to_damage * (r_i - r_f)\n\n    return f\"{damage:.6f}\"\n"
    },
    {
        "number": 3430,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_path_cost(network, u, v):\n        visited = [False] * N\n        visited[u - 1] = True\n        queue = [(u, 0)]\n        while queue:\n            node, cost = queue.pop(0)\n            if node == v:\n                return cost\n            for neighbor, cable_count in network[node - 1]:\n                if not visited[neighbor - 1]:\n                    visited[neighbor - 1] = True\n                    queue.append((neighbor, cost + cable_count))\n        return -1\n\n    def find_min_cost(network_a, network_b):\n        min_cost = float('inf')\n        for u in range(1, N + 1):\n            for v in range(1, M + 1):\n                cost = find_path_cost(network_a, u, v) + find_path_cost(network_b, v, u)\n                min_cost = min(min_cost, cost)\n        return min_cost\n\n    N, M = map(int, stdin.splitlines()[0].split())\n    network_a = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = map(int, stdin.splitlines()[1 + _].split())\n        network_a[u - 1].append((v, 1))\n        network_a[v - 1].append((u, 1))\n    network_b = [[] for _ in range(M)]\n    for _ in range(M - 1):\n        u, v = map(int, stdin.splitlines()[N + 1 + _].split())\n        network_b[u - 1].append((v, 1))\n        network_b[v - 1].append((u, 1))\n\n    min_cost = find_min_cost(network_a, network_b)\n    return min_cost\n"
    },
    {
        "number": 3431,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(p1, p2):\n        return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    def min_spanning_tree(points):\n        points.sort(key=lambda x: x[0])\n        edges = []\n        for i in range(len(points)):\n            for j in range(i + 1, len(points)):\n                edges.append((manhattan_distance(points[i], points[j]), (i, j)))\n        edges.sort(key=lambda x: x[0])\n        parent = list(range(len(points)))\n        rank = [0] * len(points)\n\n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n\n        def union(x, y):\n            x_root = find(x)\n            y_root = find(y)\n            if x_root == y_root:\n                return False\n            if rank[x_root] < rank[y_root]:\n                parent[x_root] = y_root\n            elif rank[x_root] > rank[y_root]:\n                parent[y_root] = x_root\n            else:\n                parent[y_root] = x_root\n                rank[x_root] += 1\n            return True\n\n        for edge in edges:\n            if union(edge[1][0], edge[1][1]):\n                return edge[0]\n\n    N = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    return str(min_spanning_tree(points))\n"
    },
    {
        "number": 3432,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_min_max_sum(A: int, B: int) -> int:\n        min_sum = float('inf')\n        max_sum = float('-inf')\n        for a in range(1, A + 1):\n            for b in range(1, B + 1):\n                current_sum = a + b\n                min_sum = min(min_sum, current_sum)\n                max_sum = max(max_sum, current_sum)\n        return max_sum - min_sum\n\n    N = int(stdin.split('\\n')[0])\n    result = []\n    for i in range(1, N + 1):\n        A, B = map(int, stdin.split('\\n')[i].split())\n        result.append(find_min_max_sum(A, B))\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3433,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    maze = [list(line.strip()) for line in stdin.split('\\n')[1:]]\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    def is_valid(x, y):\n        return 0 <= x < R and 0 <= y < C and maze[x][y] == '.'\n\n    def bfs(start_x, start_y):\n        queue = [(start_x, start_y, 0)]\n        visited = set()\n        while queue:\n            x, y, time = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            if maze[x][y] == 'J':\n                return time\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if is_valid(nx, ny) and (nx, ny) not in visited:\n                    queue.append((nx, ny, time + 1))\n        return -1\n\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'F':\n                fire_time = bfs(i, j)\n                if fire_time == -1:\n                    return \"IMPOSSIBLE\"\n                else:\n                    return fire_time\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3434,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, d = map(int, stdin.split()[:3])\n    stdin_list = stdin.split()[3:]\n    stdin_list = [int(x) for x in stdin_list]\n    your_minions = stdin_list[:n]\n    opponent_minions = stdin_list[n:]\n\n    def probability_of_removing_opponent(your_minions, opponent_minions, d):\n        total_health = sum(your_minions) + sum(opponent_minions)\n        if total_health < d:\n            return 0\n\n        your_minions_prob = 1\n        for health in your_minions:\n            your_minions_prob *= (health - d + 1) / health\n\n        opponent_minions_prob = 1\n        for health in opponent_minions:\n            opponent_minions_prob *= (health - d + 1) / health\n\n        return your_minions_prob * opponent_minions_prob\n\n    return f\"{probability_of_removing_opponent(your_minions, opponent_minions, d):.6f}\"\n"
    },
    {
        "number": 3435,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = input().split()\n    n = int(n)\n    p = p.replace('*', '.')\n    p = re.compile(p)\n\n    def count_valid_ids(m: int) -> int:\n        return 2 ** (n - m)\n\n    def count_substrings(s: str, m: int) -> int:\n        return sum(1 for i in range(len(s) - m + 1) if s[i:i+m] == '1' * m)\n\n    def count_valid_substrings(s: str, m: int) -> int:\n        return sum(1 for i in range(len(s) - m + 1) if p.fullmatch(s[i:i+m]))\n\n    def count_valid_ids_with_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_valid_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings_and_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings_and_substrings_and_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings_and_substrings_and_substrings_and_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings_and_substrings_and_substrings_and_substrings_and_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m)\n\n    def count_valid_ids_with_valid_substrings_and_substrings_and_substrings_and_substrings_and_substrings_and_substrings_and_substrings_and_substrings(m: int) -> int:\n        return count_valid_ids(m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings(p, m) + count_substrings(p, m) + count_valid_substrings"
    },
    {
        "number": 3436,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    MOD = 10**9 + 7\n    if x == 0 and y == 0:\n        return str(0)\n    elif x == 0 or y == 0:\n        return str(1)\n    else:\n        f = [[0] * (y + 1) for _ in range(x + 1)]\n        f[0][0] = 0\n        f[0][1] = f[1][0] = 1\n        for i in range(2, x + 1):\n            f[i][0] = (f[i - 1][0] + f[i - 2][0]) % MOD\n        for i in range(2, x + 1):\n            f[0][i] = (f[0][i - 1] + f[0][i - 2]) % MOD\n        for i in range(1, x + 1):\n            for j in range(1, y + 1):\n                f[i][j] = (f[i - 1][j] + f[i][j - 1]) % MOD\n        return str(f[x][y])\n"
    },
    {
        "number": 3437,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L1, L2, N = map(int, stdin.split()[:3])\n    tubes = sorted(map(int, stdin.split()[3:]))\n\n    max_length = 0\n    for i in range(N - 3):\n        for j in range(i + 1, N - 2):\n            for k in range(j + 1, N - 1):\n                for l in range(k + 1, N):\n                    if tubes[i] + tubes[j] <= L1 and tubes[k] + tubes[l] <= L2:\n                        max_length = max(max_length, tubes[i] + tubes[j] + tubes[k] + tubes[l])\n\n    return max_length if max_length > 0 else \"Impossible\"\n"
    },
    {
        "number": 3438,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    c, n, a = map(int, stdin.split())\n    cache = [None] * c\n    accesses = list(map(int, stdin.split()))\n\n    def evict_object(cache, accesses):\n        evict_count = 0\n        for i in range(len(accesses)):\n            if cache[accesses[i]] is None:\n                evict_count += 1\n                cache[accesses[i]] = i\n        return evict_count\n\n    return str(evict_object(cache, accesses))\n"
    },
    {
        "number": 3439,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    h, w = map(int, input_list[0].split())\n    altitudes = [[0 for _ in range(w)] for _ in range(h)]\n    for i in range(1, h + 1):\n        altitudes[i - 1] = list(map(int, input_list[i].split()))\n    i, j = map(int, input_list[-1].split())\n    i -= 1\n    j -= 1\n\n    def drain_water(i, j):\n        if altitudes[i][j] >= 0:\n            return 0\n        altitudes[i][j] = 0\n        total_volume = abs(altitudes[i][j])\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if 0 <= i + di < h and 0 <= j + dj < w:\n                total_volume += drain_water(i + di, j + dj)\n        return total_volume\n\n    return drain_water(i, j)\n"
    },
    {
        "number": 3440,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, R, F = map(int, input_list[0].split())\n    flights = [list(map(int, input_list[i+1].split())) for i in range(R)]\n    additional_flights = [list(map(int, input_list[i+R+2].split())) for i in range(F)]\n\n    # Create a graph with the flights\n    graph = {i: [] for i in range(1, N+1)}\n    for flight in flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n        graph[flight[1]].append((flight[0], flight[2]))\n\n    # Add the additional flights to the graph\n    for flight in additional_flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n        graph[flight[1]].append((flight[0], flight[2]))\n\n    # Find the shortest path from each airport to Stockholm\n    shortest_paths = {i: float('inf') for i in range(1, N+1)}\n    shortest_paths[1] = 0\n    queue = [(0, 1)]\n    while queue:\n        distance, node = heapq.heappop(queue)\n        if distance > shortest_paths[node]:\n            continue\n        for neighbor, weight in graph[node]:\n            new_distance = distance + weight\n            if new_distance < shortest_paths[neighbor]:\n                shortest_paths[neighbor] = new_distance\n                heapq.heappush(queue, (new_distance, neighbor))\n\n    # Calculate the total cost of the flights\n    total_cost = 0\n    for i in range(1, N+1):\n        total_cost += shortest_paths[i]\n\n    return total_cost"
    },
    {
        "number": 3441,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    roads.sort(key=lambda x: x[1])\n    visited = [False] * n\n    count = 0\n    for i in range(m):\n        if visited[roads[i][0]] or visited[roads[i][1]]:\n            continue\n        visited[roads[i][0]] = True\n        visited[roads[i][1]] = True\n        count += 1\n    return count"
    },
    {
        "number": 3442,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X, Y = map(int, stdin.split())\n    count = 0\n    for num in range(X, Y+1):\n        binary = bin(num)[2:]\n        if binary.count('1') > binary.count('0'):\n            binary = binary.replace('1', 'A').replace('0', 'B')\n            if binary.count('A') > 0 and binary.count('B') > 0:\n                count += 1\n    return str(count)"
    },
    {
        "number": 3443,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_symmetric(spots: list) -> bool:\n        for i in range(len(spots)):\n            for j in range(i + 1, len(spots)):\n                if (spots[i][0] - spots[j][0]) ** 2 + (spots[i][1] - spots[j][1]) ** 2 == 0:\n                    return True\n        return False\n\n    def add_spots(spots: list, n: int) -> list:\n        new_spots = []\n        for i in range(n):\n            new_spots.append((random.randint(-20000, 20000), random.randint(-20000, 20000)))\n        return spots + new_spots\n\n    def find_min_spots(spots: list) -> int:\n        n = 0\n        while not is_symmetric(spots):\n            spots = add_spots(spots, 1)\n            n += 1\n        return n\n\n    n = int(stdin.splitlines()[0])\n    spots = [(int(x), int(y)) for i, line in enumerate(stdin.splitlines()[1:]) for x, y in [line.split()]]\n    return find_min_spots(spots)"
    },
    {
        "number": 3444,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    pistes = [list(map(float, stdin.split()[2:])) for _ in range(M)]\n    pistes.sort(key=lambda x: x[2], reverse=True)\n    p_k = [0] * N\n    p_k[0] = 1\n    for p in pistes:\n        if p[0] == 0:\n            p_k[1] = max(p_k[1], p[2])\n        elif p[1] == N-1:\n            p_k[-2] = max(p_k[-2], p[2])\n        else:\n            p_k[p[1]] = max(p_k[p[1]], p[2])\n    for k in range(2, N-1):\n        p_k[k] = max(p_k[k], p_k[k-1] + p_k[k+1])\n    for k in range(N-2, 0, -1):\n        p_k[k] = max(p_k[k], p_k[k-1])\n    for k in range(N):\n        if p_k[k] == 0:\n            p_k[k] = -1\n    return ' '.join(str(p) for p in p_k)"
    },
    {
        "number": 3445,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    def min_delivery_time(customers, company):\n        delivery_times = []\n        for i in range(len(customers)):\n            for j in range(i + 1, len(customers)):\n                if customers[i][2] == company and customers[j][2] == company:\n                    delivery_times.append(distance(customers[i][:2], customers[j][:2]))\n        return max(delivery_times) if delivery_times else 0\n\n    N, *customers = stdin.split('\\n')\n    N = int(N)\n    customers = [tuple(map(int, customer.split())) for customer in customers]\n\n    company1_customers = [customer for customer in customers if customer[2] == 1]\n    company2_customers = [customer for customer in customers if customer[2] == 2]\n\n    company1_delivery_time = min_delivery_time(company1_customers, 1)\n    company2_delivery_time = min_delivery_time(company2_customers, 2)\n\n    return max(company1_delivery_time, company2_delivery_time)\n"
    },
    {
        "number": 3446,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    k = int(input_list[0])\n    symbols = input_list[1].split()\n    assembly_table = [line.split() for line in input_list[2:2+k]]\n    n = int(input_list[-2])\n    sequences = [line.split() for line in input_list[-n-1:-1]]\n\n    def get_min_time(sequence):\n        min_time = float('inf')\n        min_result = None\n        for i in range(len(sequence)):\n            for j in range(i+1, len(sequence)+1):\n                current_sequence = sequence[i:j]\n                current_time = 0\n                for pair in current_sequence:\n                    index = symbols.index(pair)\n                    current_time += int(assembly_table[index][0])\n                if current_time < min_time:\n                    min_time = current_time\n                    min_result = symbols[symbols.index(current_sequence[-1])]\n        return min_time, min_result\n\n    for sequence in sequences:\n        min_time, min_result = get_min_time(sequence)\n        print(f\"{min_time}-{min_result}\")"
    },
    {
        "number": 3447,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    dictionary = input_list[1:N+1]\n    Q = int(input_list[N+1])\n    words_to_type = input_list[N+2:]\n\n    def find_word_in_dictionary(word: str) -> str:\n        for i, dictionary_word in enumerate(dictionary):\n            if dictionary_word == word:\n                return str(i + 2)\n        return '0'\n\n    def find_min_keypresses(word: str) -> str:\n        keypresses = ''\n        for i, char in enumerate(word):\n            if i == 0:\n                keypresses += find_word_in_dictionary(char)\n            else:\n                keypresses += 'R' + find_word_in_dictionary(char)\n        return keypresses\n\n    result = []\n    for word in words_to_type:\n        result.append(find_min_keypresses(word))\n\n    return '\\n'.join(result)"
    },
    {
        "number": 3448,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k >= n:\n        return \"NO\"\n\n    def is_valid(MS_i, ME_i, VS_i, VE_i):\n        return MS_i < ME_i and VS_i < VE_i and MS_i < VS_i\n\n    def is_connected(MS_i, ME_i, VS_i, VE_i):\n        return MS_i < VS_i and ME_i < VE_i\n\n    MS = [1] * k\n    ME = [n] * k\n    VS = [1] * k\n    VE = [n] * k\n\n    for i in range(k):\n        MS[i], ME[i], VS[i], VE[i] = map(int, input().split())\n\n    for i in range(k):\n        if not is_valid(MS[i], ME[i], VS[i], VE[i]):\n            return \"NO\"\n\n    for i in range(k):\n        for j in range(k):\n            if is_connected(MS[i], ME[i], MS[j], ME[j]) or is_connected(VS[i], VE[i], VS[j], VE[j]):\n                return \"NO\"\n\n    return \"YES\\n\" + \"\\n\".join(f\"{MS[i]} {ME[i]}\" for i in range(k)) + \"\\n\" + \"\\n\".join(f\"{VS[i]} {VE[i]}\" for i in range(k))\n"
    },
    {
        "number": 3449,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    B, H, R, C = map(int, input().split())\n    lights = []\n    for _ in range(R):\n        lights.append(list(map(int, input().split())))\n\n    def light_level(x, y, z):\n        total_light = 0\n        for r in range(R):\n            for c in range(C):\n                total_light += lights[r][c] / (x**2 + y**2 + z**2)\n        return total_light\n\n    def fence_cost(x, y, z):\n        if light_level(x, y, z) >= B:\n            return 43\n        else:\n            return 11\n\n    total_cost = 0\n    for x in range(1, R - 1):\n        for y in range(1, C - 1):\n            total_cost += fence_cost(x, y, H)\n\n    for x in range(R):\n        total_cost += fence_cost(x, 0, H)\n        total_cost += fence_cost(x, C - 1, H)\n\n    for y in range(C):\n        total_cost += fence_cost(0, y, H)\n        total_cost += fence_cost(R - 1, y, H)\n\n    return total_cost\n\nstdin = \"\"\"9\n1\n6 6\n333333\n300003\n300003\n300003\n300003\n333333\"\"\"\n\nprint(solution(stdin)) "
    },
    {
        "number": 3450,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    while factorial % 10 == 0:\n        factorial //= 10\n    last_three_digits = str(factorial)[-3:]\n    return last_three_digits\n"
    },
    {
        "number": 3451,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    sequence = stdin.split()[2]\n    costs = [int(x) for x in stdin.split()[3:]]\n\n    if k == 0:\n        return \"?\"\n\n    def is_balanced(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    def min_cost_to_balance(s: str) -> int:\n        stack = []\n        min_cost = 0\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    min_cost += costs[len(s) - len(stack) - 1]\n                stack.pop()\n        return min_cost\n\n    def min_cost_to_make_impossible(s: str) -> int:\n        stack = []\n        min_cost = 0\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack:\n                    min_cost += costs[len(s) - len(stack) - 1]\n                stack.pop()\n        return min_cost\n\n    if is_balanced(sequence):\n        return \"?\"\n\n    min_cost = float('inf')\n    for i in range(len(sequence)):\n        if sequence[i] == '(':\n            new_sequence = sequence[:i] + ')' + sequence[i + 1:]\n            min_cost = min(min_cost, min_cost_to_make_impossible(new_sequence))\n        elif sequence[i] == ')':\n            new_sequence = sequence[:i] + '(' + sequence[i + 1:]\n            min_cost = min(min_cost, min_cost_to_make_impossible(new_sequence))\n\n    return min_cost\n"
    },
    {
        "number": 3452,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    rooms = [[] for _ in range(n)]\n    for i in range(1, n + 1):\n        k = int(input_list[i])\n        for j in range(k):\n            rooms[i - 1].append(int(input_list[i + j + 1]))\n\n    def dfs(room, visited, path, result):\n        visited[room - 1] = True\n        path.append(room)\n        for neighbor in rooms[room - 1]:\n            if not visited[neighbor - 1]:\n                dfs(neighbor, visited, path, result)\n        result.append(tuple(path))\n\n    visited = [False] * n\n    result = []\n    for i in range(n):\n        if not visited[i]:\n            path = []\n            dfs(i + 1, visited, path, result)\n\n    def is_identical(room1, room2):\n        for i in range(len(rooms[room1 - 1])):\n            for j in range(len(rooms[room2 - 1])):\n                if rooms[room1 - 1][i] == rooms[room2 - 1][j]:\n                    return True\n        return False\n\n    def find_identical_sets(room):\n        visited = [False] * n\n        result = []\n        for i in range(n):\n            if not visited[i] and is_identical(room, i + 1):\n                path = [room]\n                dfs(i + 1, visited, path, result)\n        return result\n\n    def find_max_sets():\n        max_set = []\n        for i in range(n):\n            if not max_set or len(max_set[0]) > len(find_identical_sets(i + 1)[0]):\n                max_set = find_identical_sets(i + 1)\n        return max_set\n\n    max_sets = find_max_sets()\n    output = []\n    for set_ in max_sets:\n        output.append(' '.join(map(str, sorted(set_))))\n    return '\\n'.join(output)\n"
    },
    {
        "number": 3453,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    tunnels = [tuple(map(int, stdin.split()[2*i+2:2*i+4])) for i in range(M)]\n    adjacency_list = [[] for _ in range(N)]\n    for u, v in tunnels:\n        adjacency_list[u-1].append((v-1, tunnels[tunnels.index((u, v))][2]))\n        adjacency_list[v-1].append((u-1, tunnels[tunnels.index((u, v))][2]))\n\n    def dfs(u: int, visited: set, danger_level: int) -> int:\n        visited.add(u)\n        danger_level += 1\n        for v, length in adjacency_list[u]:\n            if v not in visited:\n                danger_level = dfs(v, visited, danger_level)\n        return danger_level\n\n    danger_level = [0] * N\n    for i in range(N):\n        danger_level[i] = dfs(i, set(), 0)\n\n    return ' '.join(str(x % (10**9 + 7)) for x in danger_level)\n"
    },
    {
        "number": 3454,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    M, N = map(int, stdin.split()[:2])\n    c = list(map(int, stdin.split()[2:]))\n\n    def count_ways(b, r):\n        if not b and not r:\n            return 1\n        if not b:\n            return count_ways(b, r - 1)\n        if not r:\n            return count_ways(b - 1, r)\n        return count_ways(b, r - 1) + count_ways(b - 1, r)\n\n    def paint_cell(b, r, painted_cells):\n        if not b and not r:\n            return painted_cells\n        if not b:\n            return paint_cell(b, r - 1, painted_cells)\n        if not r:\n            return paint_cell(b - 1, r, painted_cells)\n        painted_cells.add((b, r))\n        return paint_cell(b, r - 1, painted_cells) + paint_cell(b - 1, r, painted_cells)\n\n    painted_cells = set()\n    painted_cells = paint_cell(1, 1, painted_cells)\n    painted_cells = paint_cell(M, N, painted_cells)\n\n    ways = count_ways(c[0], M - c[0])\n    for i in range(1, N):\n        ways *= count_ways(c[i], M - c[i])\n\n    return str(ways % 100003)\n"
    },
    {
        "number": 3455,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M, R = map(int, input_list[0].split())\n    car_list = []\n    for i in range(1, M+1):\n        lane, length, distance = map(int, input_list[i].split())\n        car_list.append((lane, length, distance))\n    \n    # Sort car_list by lane and distance\n    car_list.sort(key=lambda x: (x[0], x[2]))\n    \n    # Calculate the maximum achievable safety factor\n    max_safety_factor = 0\n    for i in range(M):\n        lane, length, distance = car_list[i]\n        if lane == N-1:\n            max_safety_factor = max(max_safety_factor, distance + length)\n        else:\n            for j in range(i+1, M):\n                lane2, length2, distance2 = car_list[j]\n                if lane2 == lane+1:\n                    max_safety_factor = max(max_safety_factor, distance + length + distance2 + length2)\n                    break\n    \n    if max_safety_factor == 0:\n        return \"Impossible\"\n    else:\n        return round(max_safety_factor / R, 6)"
    },
    {
        "number": 3456,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    crate_counts = list(map(int, stdin.splitlines()[1].split()))\n\n    # Calculate the total number of crates\n    total_crates = sum(crate_counts)\n\n    # Calculate the minimum number of actions required\n    min_actions = 0\n    for count in crate_counts:\n        min_actions += count\n\n    # Calculate the number of stacks with more than one crate\n    multi_crate_stacks = sum(1 for count in crate_counts if count > 1)\n\n    # Subtract the number of stacks with more than one crate\n    min_actions -= multi_crate_stacks\n\n    # Add the number of actions required to move the remaining crates to the right\n    min_actions += (total_crates - min_actions)\n\n    return str(min_actions)"
    },
    {
        "number": 3457,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X, Y = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [[0] * (N+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(N+1):\n        for j in range(N+1):\n            if i > 0:\n                dp[i][j] += dp[i-1][j]\n                dp[i][j] %= mod\n            if j > 0:\n                dp[i][j] += dp[i][j-1]\n                dp[i][j] %= mod\n            if i > 0 and j > 0:\n                dp[i][j] -= dp[i-1][j-1]\n                dp[i][j] %= mod\n            if i > 0 and j > 0 and X <= i and Y <= j:\n                dp[i][j] += dp[i-X][j-Y]\n                dp[i][j] %= mod\n    return dp[N][N]"
    },
    {
        "number": 3458,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    numbers = list(map(int, stdin.split('\\n')[1].split()))\n    max_sum = 0\n    for i in range(1 << n):\n        subset_sum = 0\n        for j in range(n):\n            if i & (1 << j):\n                subset_sum ^= numbers[j]\n        max_sum = max(max_sum, subset_sum)\n    return str(max_sum)\n"
    },
    {
        "number": 3459,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        T = int(input())\n        inputs = []\n        for _ in range(T):\n            n = int(input())\n            residents = []\n            for _ in range(n):\n                resident, party, num_clubs, *clubs = input().split()\n                clubs = set(clubs)\n                residents.append((resident, party, num_clubs, clubs))\n            inputs.append(residents)\n        return T, inputs\n\n    def find_council_members(residents: list) -> str:\n        council_members = {}\n        for resident, party, num_clubs, clubs in residents:\n            if num_clubs == 0:\n                continue\n            for club in clubs:\n                if council_members.get(club, (0, None))[0] < num_clubs // 2:\n                    council_members[club] = (num_clubs // 2, resident)\n                    break\n        return council_members\n\n    def print_council(council_members: dict) -> str:\n        result = []\n        for club, (_, representative) in council_members.items():\n            result.append(f\"{representative} {club}\")\n        return \"\\n\".join(result)\n\n    T, inputs = read_input()\n    for i, residents in enumerate(inputs, start=1):\n        council_members = find_council_members(residents)\n        if len(council_members) < 1:\n            print(\"Impossible.\")\n        else:\n            print(print_council(council_members))\n        if i != T:\n            print()\n"
    },
    {
        "number": 3460,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, x2, r1, r2):\n        return abs(x1 - x2) <= r1 + r2\n\n    def count_explosions(x, r, cans):\n        count = 0\n        for i, (x2, r2) in enumerate(cans):\n            if distance(x, x2, r, r2):\n                count += 1\n        return count\n\n    n = int(stdin.splitlines()[0])\n    cans = [(int(x), int(r)) for x, r in [line.split() for line in stdin.splitlines()[1:]]]\n\n    result = [count_explosions(x, r, cans) for x, r in cans]\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3461,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expected_hearings(start_times, min_lengths, max_lengths):\n        start_times.sort()\n        total_hearings = len(start_times)\n        expected_value = 0\n        for i in range(total_hearings):\n            if i == 0:\n                expected_value += 1\n                continue\n            current_start = start_times[i]\n            previous_end = start_times[i-1] + max_lengths[i-1]\n            if current_start - previous_end > 0:\n                expected_value += 1\n        return expected_value\n\n    def optimal_strategy(start_times, min_lengths, max_lengths):\n        start_times.sort()\n        total_hearings = len(start_times)\n        expected_value = 0\n        current_hearing = 0\n        for i in range(total_hearings):\n            if i == 0:\n                expected_value += 1\n                current_hearing = 1\n                continue\n            current_start = start_times[i]\n            previous_end = start_times[i-1] + max_lengths[i-1]\n            if current_start - previous_end > 0:\n                expected_value += 1\n                current_hearing += 1\n            else:\n                current_hearing += 1\n        return expected_value\n\n    def main(stdin: str) -> str:\n        total_hearings, *hearing_data = stdin.split('\\n')\n        start_times = []\n        min_lengths = []\n        max_lengths = []\n        for i in range(int(total_hearings)):\n            start_time, min_length, max_length = map(int, hearing_data[i].split())\n            start_times.append(start_time)\n            min_lengths.append(min_length)\n            max_lengths.append(max_length)\n        expected_hearings_value = expected_hearings(start_times, min_lengths, max_lengths)\n        optimal_strategy_value = optimal_strategy(start_times, min_lengths, max_lengths)\n        return f\"{optimal_strategy_value:.3f}\"\n\n    return main(stdin)"
    },
    {
        "number": 3462,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split(\"\\n\")\n    pattern = input_list[0]\n    num_files = int(input_list[1])\n    files = input_list[2:]\n\n    def match_pattern(pattern, filename):\n        pattern_parts = pattern.split(\"*\")\n        filename_parts = filename.split(\".\")\n        if len(pattern_parts) > len(filename_parts):\n            return False\n        for i, pattern_part in enumerate(pattern_parts):\n            if i >= len(filename_parts):\n                return False\n            if pattern_part != filename_parts[i] and pattern_part != \"\":\n                return False\n        return True\n\n    result = []\n    for file in files:\n        if match_pattern(pattern, file):\n            result.append(file)\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3463,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    p = list(map(float, stdin.split()[2:]))\n\n    if N == 0:\n        return f\"{M:.6f}\"\n    elif M == 0:\n        return f\"{N:.6f}\"\n\n    p_sum = sum(p)\n    p_norm = [p_i / p_sum for p_i in p]\n\n    if N > M:\n        return f\"{1 - sum(p_norm[:M]):.6f}\"\n    else:\n        return f\"{sum(p_norm[:N]):.6f}\"\n"
    },
    {
        "number": 3464,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, p = map(float, stdin.split())\n    if x >= 100 or p >= 50:\n        return \"0.0\"\n    p /= 100\n    def expected_profit(n: int) -> float:\n        return n * 2 * p - n * (1 - p)\n    def max_profit(n: int) -> float:\n        return (n + 1) * 2 * p - n * (1 - p)\n    def max_expected_profit(n: int) -> float:\n        return (n + 1) * 2 * p - n * (1 - p)\n    def refund_profit(n: int) -> float:\n        return n * x / 100\n    def total_profit(n: int) -> float:\n        return max_expected_profit(n) - refund_profit(n)\n    def max_total_profit(n: int) -> float:\n        return max_profit(n) - refund_profit(n)\n    def max_n(total_profit: float) -> int:\n        return int(total_profit / (2 * p))\n    def max_expected_profit_with_refund(n: int) -> float:\n        return expected_profit(n) - refund_profit(n)\n    def max_expected_profit_with_refund_and_max_profit(n: int) -> float:\n        return max_expected_profit_with_refund(n) + max_profit(n) - max_profit(n - 1)\n    def max_expected_profit_with_refund_and_max_profit_with_refund(n: int) -> float:\n        return max_expected_profit_with_refund(n) + max_profit(n) - refund_profit(n)\n    def max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit(n: int) -> float:\n        return max_expected_profit_with_refund_and_max_profit_with_refund(n) + max_total_profit(n) - max_total_profit(n - 1)\n    def max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit_with_refund(n: int) -> float:\n        return max_expected_profit_with_refund_and_max_profit_with_refund(n) + max_total_profit(n) - refund_profit(n)\n    def max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit_with_refund_and_max_total_profit(n: int) -> float:\n        return max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit(n) + max_total_profit(n) - max_total_profit(n - 1)\n    def max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit_with_refund_and_max_total_profit_with_refund(n: int) -> float:\n        return max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit_with_refund(n) + max_total_profit(n) - refund_profit(n)\n    def max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit_with_refund_and_max_total_profit_with_refund_and_max_total_profit(n: int) -> float:\n        return max_expected_profit_with_refund_and_max_profit_with_refund_and_max_total_profit_with_refund_and_max_total_profit(n) + max_total_profit"
    },
    {
        "number": 3465,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Create a graph with edges between cities\n    graph = {i: [] for i in range(1, n + 1)}\n    for a, b in roads:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Find a path from each city to every other city\n    visited = [False] * (n + 1)\n    paths = [[] for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        if not visited[i]:\n            stack = [(i, [i])]\n            while stack:\n                node, path = stack.pop()\n                for neighbor in graph[node]:\n                    if not visited[neighbor]:\n                        stack.append((neighbor, path + [neighbor]))\n                        visited[neighbor] = True\n            paths[i] = path\n\n    # Assign roads to cities\n    result = []\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j and (i, j) in roads:\n                result.append(f\"{i} {paths[i][paths[i].index(j)]}\")\n                result.append(f\"{paths[i][paths[i].index(j)]} {j}\")\n                roads.remove((i, j))\n                break\n\n    return \"\\n\".join(result)\n"
    },
    {
        "number": 3466,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+m]))\n    b = list(map(int, stdin.split()[2+m:]))\n\n    f = [a[i] / sum(a) for i in range(m)]\n    n = sum(b)\n\n    def is_balanced(s):\n        return all(n * f[i] - 1 < s[i] < n * f[i] + 1 for i in range(m))\n\n    if is_balanced(b):\n        return \"0\"\n\n    i = 0\n    while not is_balanced(b):\n        b[b.index(min(b))] += 1\n        i += 1\n\n    if i == k:\n        return \"forever\"\n    else:\n        return str(i)\n"
    },
    {
        "number": 3467,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[:3])\n    stops = [0] + list(range(n - 1, 0, -1))\n    lines = []\n    for _ in range(m):\n        u, v, t0, p, d = map(int, stdin.split()[3:])\n        lines.append((u, v, t0, p, d))\n\n    def get_time(stop: int, line: int) -> int:\n        u, v, t0, p, d = lines[line]\n        return t0 + (stop - u) * p\n\n    def is_possible(stop: int, time: int) -> bool:\n        for line in range(m):\n            if get_time(stop, line) <= time:\n                return True\n        return False\n\n    def binary_search(start: int, end: int) -> int:\n        if start > end:\n            return -1\n        mid = (start + end) // 2\n        if is_possible(stops[n - 1], mid):\n            return mid\n        elif is_possible(stops[n - 1], mid - 1):\n            return mid - 1\n        else:\n            return binary_search(mid + 1, end)\n\n    result = binary_search(s, 10**9)\n    if result == -1:\n        return \"impossible\"\n    else:\n        return result"
    },
    {
        "number": 3468,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, c = map(int, input_list[0].split())\n    apps = [tuple(map(int, input_list[i+1].split())) for i in range(n)]\n\n    apps.sort(key=lambda x: x[1], reverse=True)\n    total_size = sum(app[1] for app in apps)\n\n    if total_size > c:\n        return \"0\"\n\n    installed_apps = []\n    current_size = 0\n\n    for app in apps:\n        if current_size + app[1] <= c:\n            installed_apps.append(app[0])\n            current_size += app[1]\n\n    return str(len(installed_apps)) + \"\\n\" + \" \".join(map(str, installed_apps))"
    },
    {
        "number": 3469,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    g, k, p = stdin.split('\\n')\n    p = float(p)\n\n    def coin_flip(p):\n        return 'H' if random.random() < p else 'T'\n\n    def is_substring(s, sub):\n        return sub in s\n\n    def simulate_game(g, k, p):\n        s = ''\n        while not (is_substring(s, g) and is_substring(s, k)):\n            s += coin_flip(p)\n            if len(s) > 10**100:\n                return 'draw'\n        return 'gon' if is_substring(s, g) else 'killua'\n\n    result = simulate_game(g, k, p)\n    if result == 'gon':\n        return 1\n    elif result == 'killua':\n        return 0\n    else:\n        return 0.5"
    },
    {
        "number": 3470,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    safe_cells = [1, 3, 5, 7, 9, 11, 13, 15]\n    return f\"{len(safe_cells)}\\n{' '.join(map(str, safe_cells))}\"\n"
    },
    {
        "number": 3471,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def xor_sum(a, b):\n        return a ^ b\n\n    def xorbonacci(a, k):\n        if k == 1:\n            return a[0]\n        elif k == 2:\n            return a[1]\n        else:\n            return xor_sum(a[k - 1], xorbonacci(a, k - 1))\n\n    K, a, Q = map(int, stdin.split(\"\\n\")[:3])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    for i in range(Q):\n        l, r = map(int, stdin.split(\"\\n\")[2 + i].split())\n        xorbonacci_seq = [xorbonacci(a, i + 1) for i in range(K)]\n        result = xor_sum(*[xorbonacci_seq[j] for j in range(l - 1, r)])\n        print(result)\n"
    },
    {
        "number": 3472,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    W, N = map(int, input_list[0].split())\n    lines = []\n    for i in range(1, N + 1):\n        x1, y1, x2, y2 = map(int, input_list[i].split())\n        lines.append((x1, y1, x2, y2))\n\n    # Find the number of sectors that each warlord can get\n    sectors_per_warlord = [0] * W\n    for i in range(N):\n        for j in range(W):\n            if lines[i][0] <= 0 <= lines[i][2]:\n                if lines[i][1] <= 0 <= lines[i][3]:\n                    sectors_per_warlord[j] += 1\n\n    # Find the maximum number of sectors that any warlord can get\n    max_sectors = max(sectors_per_warlord)\n\n    # Calculate the number of extra lines needed\n    extra_lines = max_sectors - 1\n\n    return extra_lines"
    },
    {
        "number": 3473,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    Z, F = map(int, stdin.splitlines()[0].split())\n    forbidden_dates = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_leap_year(year):\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def days_in_year(year):\n        return 366 if is_leap_year(year) else 365\n\n    def days_in_month(year, month):\n        if month == 2:\n            return 29 if is_leap_year(year) else 28\n        elif month in (4, 6, 9, 11):\n            return 30\n        else:\n            return 31\n\n    def days_since_year_start(year, month, day):\n        days = 0\n        for y in range(year):\n            days += days_in_year(y)\n        for m in range(1, month):\n            days += days_in_month(year, m)\n        return days + day\n\n    def days_until_october_1(year):\n        return days_since_year_start(year, 10, 1)\n\n    def days_until_october_12(year):\n        return days_until_october_1(year) + 11\n\n    def days_until_october_274(year):\n        return days_since_year_start(2018, 10, 274)\n\n    def days_until_forbidden_date(year, month, day):\n        return days_until_october_274(year) + days_until_october_12(year) + days_until_october_1(year) + days_in_month(year, month) - day\n\n    def surprise_penalty(year1, year2):\n        return (year1 - year2) ** 2\n\n    def is_forbidden_date(year, month, day):\n        return any(year == fd[0] and month == 10 and day == fd[2] for fd in forbidden_dates)\n\n    def is_friday(year, month, day):\n        return days_in_month(year, month) - day + 1 == 5\n\n    def is_october_friday(year):\n        return is_friday(year, 10, days_in_month(year, 10))\n\n    def is_forbidden_friday(year):\n        return any(is_friday(year, 10, fd[2]) for fd in forbidden_dates)\n\n    def is_forbidden_date_or_friday(year):\n        return is_forbidden_date(year, 10, days_in_month(year, 10)) or is_forbidden_friday(year)\n\n    def is_valid_date(year, month, day):\n        return days_in_month(year, month) >= day and not is_forbidden_date_or_friday(year)\n\n    def find_best_date(year, month, day):\n        if not is_valid_date(year, month, day):\n            return None\n        if month == 10 and day == 1:\n            return year\n        if month == 10 and day == days_in_month(year, 10):\n            return year - 1\n        return find_best_date(year, month, day + 1)\n\n    def find_best_schedule(year, month, day):\n        if month == 10 and day == days_in_month(year, 10):\n            return find_best_date(year, 10, 1)\n        return find_best_date(year, month, day)\n\n    def find_best_schedules(year, month, day):\n        if month == 10 and day == days_in_month(year, 10):\n            return find_best_date(year, 10, 1)\n        return find_best_date(year, month"
    },
    {
        "number": 3474,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def reflect(x1, y1, x2, y2, x3, y3):\n        m = (y2 - y1) / (x2 - x1)\n        b = y1 - m * x1\n        x = (y3 - b) / m\n        y = m * x3 + b\n        return x, y\n\n    def find_hit_range(x1, y1, x2, y2, x3, y3):\n        x, y = reflect(x1, y1, x2, y2, x3, y3)\n        if x < 0:\n            return \"negative-infinity\", y\n        elif x > 0:\n            return \"positive-infinity\", y\n        else:\n            return \"can't hit the wall\"\n\n    test_cases = stdin.strip().split(\"\\n\")\n    results = []\n\n    for test_case in test_cases:\n        x1, y1, x2, y2, x3, y3 = map(float, test_case.split())\n        x, y = reflect(x1, y1, x2, y2, x3, y3)\n        results.append(f\"{y:.4f}\")\n\n    return \"\\n\".join(results)\n"
    },
    {
        "number": 3475,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t, n = map(int, input().split())\n    modes = []\n    for _ in range(t):\n        d_min, a = map(int, input().split())\n        modes.append((d_min, a))\n    points = []\n    for _ in range(n-1):\n        d, h = map(int, input().split())\n        points.append((d, h))\n    \n    # Calculate the total distance of the itinerary\n    total_distance = sum(p[0] for p in points)\n    \n    # Initialize the switching scheme\n    switching_scheme = []\n    \n    # Iterate through the modes and find the minimum number of times we have to call for a new type of transportation\n    for i, (d_min, a) in enumerate(modes):\n        if total_distance >= d_min:\n            switching_scheme.append(i)\n            total_distance -= d_min\n        else:\n            break\n    \n    # If the total distance is still greater than 0, it's impossible to visit all points\n    if total_distance > 0:\n        return \"IMPOSSIBLE\"\n    \n    # Calculate the maximum heading range in degrees\n    max_heading_range = max(modes[i][1] for i in switching_scheme) * 0.001\n    \n    # Calculate the maximum distance we can travel in a single direction\n    max_distance = max(modes[i][0] for i in switching_scheme)\n    \n    # Calculate the total number of switches needed\n    switches = len(switching_scheme)\n    \n    # Iterate through the points and calculate the total distance traveled\n    total_distance = 0\n    for i in range(n-1):\n        d, h = points[i]\n        total_distance += d\n        \n        # If the total distance is greater than the maximum distance we can travel in a single direction, we need to switch\n        if total_distance > max_distance:\n            switches += 1\n            total_distance = d\n    \n    # Calculate the maximum number of switches needed\n    max_switches = len(switching_scheme) * 2\n    \n    # If the total number of switches is greater than the maximum number of switches, it's impossible to visit all points\n    if switches > max_switches:\n        return \"IMPOSSIBLE\"\n    \n    # Calculate the total number of switches needed\n    total_switches = switches\n    \n    # Iterate through the switching scheme and calculate the total number of switches needed\n    for i in switching_scheme:\n        total_switches += 2\n    \n    return total_switches"
    },
    {
        "number": 3476,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0:2])\n    matrix = [list(map(int, stdin.split()[2:])) for _ in range(R)]\n    operations = []\n    max_sum = 0\n    for i in range(R):\n        for j in range(C):\n            max_sum += matrix[i][j]\n    while True:\n        rotR_i, rotS_j, negR_i, negS_j = map(int, stdin.split())\n        if rotR_i == -1 and rotS_j == -1 and negR_i == -1 and negS_j == -1:\n            break\n        if rotR_i != -1:\n            matrix[i] = matrix[i][-rotR_i:] + matrix[i][:-rotR_i]\n            operations.append(f\"rotR {i} {rotR_i}\")\n            max_sum += sum(matrix[i])\n        if rotS_j != -1:\n            matrix = [matrix[j][-rotS_j:] + matrix[j][:-rotS_j] for j in range(R)]\n            operations.append(f\"rotS {j} {rotS_j}\")\n            max_sum += sum(matrix[i][j] for i in range(R))\n        if negR_i != -1:\n            matrix[i] = [-matrix[i][j] for j in range(C)]\n            operations.append(f\"negR {i}\")\n            max_sum += sum(matrix[i])\n        if negS_j != -1:\n            matrix = [[-matrix[i][j] for j in range(C)] for i in range(R)]\n            operations.append(f\"negS {j}\")\n            max_sum += sum(matrix[i][j] for i in range(R))\n    return f\"{max_sum} {len(operations)}\\n\" + \"\\n\".join(operations)"
    },
    {
        "number": 3477,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n, m = map(int, input_data[0].split())\n    spectrum = list(map(int, input_data[1].split()))\n    simulation_energies = sorted(set([(i + j) / 2 for j in range(m) for i in range(n)]))\n\n    def distance_sum(energies):\n        return sum(spectrum[i] * (energies[i] - spectrum[i]) ** 2 for i in range(n))\n\n    min_distance_sum = float('inf')\n    for energies in simulation_energies:\n        if distance_sum(energies) < min_distance_sum:\n            min_distance_sum = distance_sum(energies)\n\n    return f\"{min_distance_sum:.4f}\"\n"
    },
    {
        "number": 3478,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_connected(graph: list, start: int, end: int) -> bool:\n        visited = [False] * len(graph)\n        queue = [start]\n        visited[start] = True\n\n        while queue:\n            node = queue.pop(0)\n            if node == end:\n                return True\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    visited[neighbor] = True\n                    queue.append(neighbor)\n\n        return False\n\n    def dfs(graph: list, start: int, visited: list, result: list):\n        visited[start] = True\n        result.append(start)\n\n        for neighbor in graph[start]:\n            if not visited[neighbor]:\n                dfs(graph, neighbor, visited, result)\n\n    n, m = map(int, stdin.split()[:2])\n    roads = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    graph = [[] for _ in range(n + 1)]\n\n    for x, y in roads:\n        graph[x].append(y)\n        graph[y].append(x)\n\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if is_connected(graph, i, j):\n                return \"impossible\"\n\n    visited = [False] * (n + 1)\n    result = []\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(graph, i, visited, result)\n\n    result = [str(i) for i in result]\n    result.remove(\"1\")\n    result.remove(\"2\")\n\n    return \" \".join(result)\n"
    },
    {
        "number": 3479,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    times = list(map(int, stdin.split()[2:]))\n\n    # Sort the times in ascending order\n    times.sort()\n\n    # Initialize the minimum time to move all people\n    min_time = 0\n\n    # Initialize the number of cars at the stadium\n    cars_at_stadium = 0\n\n    # Initialize the number of people at the stadium\n    people_at_stadium = 0\n\n    # Initialize the number of people waiting at the stadium\n    waiting_at_stadium = 0\n\n    # Initialize the number of people waiting at the house\n    waiting_at_house = n\n\n    # Iterate through the times\n    for time in times:\n        # If there are enough cars at the stadium, move people back to the house\n        if cars_at_stadium >= k:\n            waiting_at_house += waiting_at_stadium\n            waiting_at_stadium = 0\n            cars_at_stadium = 0\n            people_at_stadium = 0\n\n        # If there are enough people at the stadium, move cars back to the house\n        if people_at_stadium >= n:\n            waiting_at_house -= waiting_at_stadium\n            waiting_at_stadium = 0\n            cars_at_stadium = 0\n            people_at_stadium = 0\n\n        # If there are enough people waiting at the stadium, move them to the stadium\n        if waiting_at_stadium < k and waiting_at_stadium + people_at_stadium < n:\n            waiting_at_stadium += 1\n            people_at_stadium += 1\n\n        # If there are enough people waiting at the house, move them to the stadium\n        if waiting_at_house > 0 and waiting_at_house + people_at_stadium < n:\n            waiting_at_stadium += 1\n            waiting_at_house -= 1\n\n        # Add the time to the minimum time\n        min_time += time\n\n    return min_time"
    },
    {
        "number": 3480,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    L, D = map(int, input_list[0].split())\n    lines = []\n    for i in range(1, len(input_list), 2):\n        lines.append(input_list[i].split())\n    output = []\n    for i in range(L):\n        line1 = lines[i][0]\n        time1 = list(map(int, lines[i][1:]))\n        line2 = lines[i+L][0]\n        time2 = list(map(int, lines[i+L][1:]))\n        if len(line1) > len(line2):\n            line2 += ' ' * (len(line1) - len(line2))\n        elif len(line2) > len(line1):\n            line1 += ' ' * (len(line2) - len(line1))\n        output.append(line1 + '=' + line2)\n        output.append('_' * (len(line1) + len(line2) + 2))\n        for j in range(max(len(time1), len(time2))):\n            if j < len(time1):\n                if j < len(time2):\n                    if time1[j] == time2[j]:\n                        output.append('_' * time1[j] + line1[j] + '_' * (time1[j] - len(line1[j])) + ' ' * (time2[j] - time1[j]) + line2[j] + '_' * (time2[j] - len(line2[j])))\n                    elif time1[j] < time2[j]:\n                        output.append('_' * time1[j] + line1[j] + '_' * (time1[j] - len(line1[j])) + ' ' * (time2[j] - time1[j]) + '_' * (time2[j] - time1[j]))\n                    else:\n                        output.append('_' * time2[j] + '_' * (time2[j] - len(line2[j])) + ' ' * (time1[j] - time2[j]) + line1[j] + '_' * (time1[j] - len(line1[j])))\n                else:\n                    output.append('_' * time1[j] + line1[j] + '_' * (time1[j] - len(line1[j])))\n            else:\n                if j < len(time2):\n                    output.append('_' * time2[j] + line2[j] + '_' * (time2[j] - len(line2[j])))\n    return '\\n'.join(output)"
    },
    {
        "number": 3481,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    G, K, R = map(int, stdin.split()[:3])\n    roads = [tuple(map(int, stdin.split()[3+i:6+i])) for i in range(R)]\n    gigs = [tuple(map(int, stdin.split()[6+i:10+i])) for i in range(G)]\n\n    def dijkstra(start, end, roads):\n        dist = [float('inf')] * (K+1)\n        dist[start] = 0\n        visited = [False] * (K+1)\n        prev = [None] * (K+1)\n\n        while True:\n            u = min(range(K+1), key=lambda x: dist[x] if not visited[x] else float('inf'))\n            if u == end:\n                break\n            visited[u] = True\n            for v, t in roads:\n                if not visited[v] and dist[u] + t < dist[v]:\n                    dist[v] = dist[u] + t\n                    prev[v] = u\n\n        return dist, prev\n\n    dist, prev = dijkstra(1, K, roads)\n    max_cryptocents = 0\n\n    for i in range(G):\n        v, s, e, m = gigs[i]\n        if dist[v] + s <= dist[1] and dist[1] + e <= dist[v] + dist[K]:\n            max_cryptocents = max(max_cryptocents, m)\n\n    return max_cryptocents"
    },
    {
        "number": 3482,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_price(day: int) -> int:\n        for i in range(l):\n            if day >= d[i]:\n                return p[i]\n        return p[l - 1]\n\n    l, p, d = map(int, stdin.split()[:l + 1])\n    p = list(map(int, stdin.split()[l + 1:l + 1 + l]))\n    d = list(map(int, stdin.split()[l + 1 + l:]))\n    t, n = map(int, stdin.split()[-2:])\n\n    total_cost = 0\n    for i in range(n):\n        a, b = map(int, stdin.split()[-n + i * 2:-n + i * 2 + 2])\n        total_cost += sum(get_price(day) for day in range(a, b + 1))\n\n    return total_cost\n"
    },
    {
        "number": 3483,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *weights = map(int, stdin.split())\n    weights = sorted(set(weights))\n    max_weight = sum(weights[-4:])\n    min_weight = sum(weights[:4])\n    distinct_weights = len(weights)\n    expected_weight = sum(weights) / 4\n    return f\"{max_weight} {min_weight} {distinct_weights} {expected_weight:.4f}\"\n"
    },
    {
        "number": 3484,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    grid = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(k):\n        row = list(map(int, input_list[i+1].split()))\n        for j in range(n):\n            grid[i][j] = row[j]\n\n    def is_valid(grid: list, row: int, col: int, num: int) -> bool:\n        for i in range(n):\n            if grid[row][i] == num or grid[i][col] == num:\n                return False\n\n        start_row, start_col = row - row % 3, col - col % 3\n        for i in range(3):\n            for j in range(3):\n                if grid[i + start_row][j + start_col] == num:\n                    return False\n\n        return True\n\n    def solve(grid: list) -> bool:\n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == 0:\n                    for num in range(1, n+1):\n                        if is_valid(grid, i, j, num):\n                            grid[i][j] = num\n                            if solve(grid):\n                                return True\n                            grid[i][j] = 0\n                    return False\n        return True\n\n    if solve(grid):\n        return \"yes\\n\" + \"\\n\".join(str(row) for row in grid)\n    else:\n        return \"no\""
    },
    {
        "number": 3485,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    cards = list(map(int, input_list[1].split()))\n\n    # Initialize variables\n    stop_counting = False\n    start_counting = False\n    count = 0\n    total = 0\n\n    # Iterate through the cards\n    for card in cards:\n        if not stop_counting:\n            total += card\n            count += 1\n        if not start_counting:\n            if card == -10:\n                stop_counting = True\n            if card == 10:\n                start_counting = True\n\n    # Calculate the payout\n    if count == 0:\n        payout = 0.0\n    else:\n        payout = total / count\n\n    return f\"{payout:.6f}\""
    },
    {
        "number": 3486,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a: int, b: int) -> int:\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a: int, b: int) -> int:\n        return (a * b) // gcd(a, b)\n\n    def count_ways(n: int, nums: List[int]) -> int:\n        if n == 2:\n            return 1\n\n        nums.sort()\n        ways = 0\n        for i in range(n):\n            for j in range(i + 2, n):\n                if gcd(nums[i], nums[j]) > 1:\n                    ways += 1\n\n        return ways % (10**9 + 7)\n\n    n = int(stdin.splitlines()[0])\n    nums = [int(line) for line in stdin.splitlines()[1:]]\n    return str(count_ways(n, nums))\n"
    },
    {
        "number": 3487,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def calculate_value(F, W, a):\n        return F**a * W**(1-a)\n\n    def is_valid_solution(F, W, a):\n        return abs(calculate_value(F, W, a) - max_value) < 1e-4\n\n    def get_flubber_and_water_rates(j, k, c, F, W):\n        if j == 1:\n            return 0, c\n        if k == 2:\n            return -c, 0\n        if j == 2:\n            return 0, c\n        if k == 3:\n            return -c, 0\n        if j == 3:\n            return 0, c\n        if k == 4:\n            return -c, 0\n        if j == 4:\n            return 0, c\n        if k == 5:\n            return -c, 0\n        if j == 5:\n            return 0, c\n\n    def get_flubber_and_water_rates_for_pipe(j, k, c, F, W):\n        F_j, W_j = get_flubber_and_water_rates(j, k, c, F, W)\n        F_k, W_k = get_flubber_and_water_rates(k, j, c, F, W)\n        return F_j, W_j, F_k, W_k\n\n    def get_max_value(F, W, a):\n        max_value = 0\n        for j in range(1, n+1):\n            for k in range(j+1, n+1):\n                for c in range(1, 11):\n                    F_j, W_j, F_k, W_k = get_flubber_and_water_rates_for_pipe(j, k, c, F, W)\n                    if is_valid_solution(F_j, W_j, a):\n                        max_value = max(max_value, calculate_value(F_j, W_j, a))\n        return max_value\n\n    lines = stdin.splitlines()\n    n, p, v, a = map(float, lines[0].split())\n    F = W = 0\n    max_value = get_max_value(F, W, a)\n\n    for _ in range(p):\n        j, k, c = map(int, lines[1].split())\n        F_j, W_j, F_k, W_k = get_flubber_and_water_rates_for_pipe(j, k, c, F, W)\n        print(f\"{F_j:.10f} {W_j:.10f}\")\n        print(f\"{F_k:.10f} {W_k:.10f}\")\n        F += F_j + F_k\n        W += W_j + W_k\n\n    print(f\"{max_value:.10f}\")\n"
    },
    {
        "number": 3488,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def is_inside(point, polygon):\n        n = len(polygon)\n        inside = False\n        p1x, p1y = polygon[0]\n        for i in range(n + 1):\n            p2x, p2y = polygon[i % n]\n            if cross_product(point, (p1x, p1y), (p2x, p2y)) > 0:\n                inside = not inside\n            p1x, p1y = p2x, p2y\n        return inside\n\n    def find_polygon(points, polygon):\n        for i in range(len(points)):\n            if is_inside(points[i], polygon):\n                return polygon\n            new_polygon = [point for point in polygon if not is_inside(point, [points[i]])]\n            if len(new_polygon) < len(polygon):\n                return find_polygon(points, new_polygon)\n        return None\n\n    def main(stdin: str) -> str:\n        lines = stdin.split('\\n')\n        n = int(lines[0])\n        alexa_polygon = [tuple(map(int, line.split())) for line in lines[1:n + 1]]\n        k = int(lines[n + 1])\n        celery_sightings = [tuple(map(int, line.split())) for line in lines[n + 2:n + k + 2]]\n        min_vertices = len(alexa_polygon)\n        for i in range(len(celery_sightings)):\n            for j in range(i + 1, len(celery_sightings)):\n                sighting1 = celery_sightings[i]\n                sighting2 = celery_sightings[j]\n                new_polygon = find_polygon([sighting1, sighting2], alexa_polygon)\n                if new_polygon is not None:\n                    min_vertices = min(min_vertices, len(new_polygon))\n        return str(min_vertices)\n\n    return main(stdin)"
    },
    {
        "number": 3489,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, h = map(int, input_list[0].split())\n    graph = [[] for _ in range(n)]\n    for line in input_list[1:]:\n        a, b = map(int, line.split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    def dfs(v, visited, stack):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                dfs(u, visited, stack)\n        stack.append(v)\n\n    def bfs(v, visited, stack):\n        visited[v] = True\n        stack.append(v)\n        while stack:\n            u = stack.pop(0)\n            for w in graph[u]:\n                if not visited[w]:\n                    visited[w] = True\n                    stack.append(w)\n\n    def find_safe_routes(v, visited, stack):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                if find_safe_routes(u, visited, stack):\n                    return True\n        stack.append(v)\n        return False\n\n    def add_routes(v, visited, stack, count):\n        visited[v] = True\n        for u in graph[v]:\n            if not visited[u]:\n                if add_routes(u, visited, stack, count):\n                    return count\n        stack.append(v)\n        return count + 1\n\n    visited = [False] * n\n    stack = []\n    dfs(h, visited, stack)\n    safe_routes = find_safe_routes(h, visited, stack)\n\n    if safe_routes:\n        return \"0\"\n\n    visited = [False] * n\n    stack = []\n    bfs(h, visited, stack)\n    count = 0\n    for v in range(n):\n        if not visited[v]:\n            count = max(count, add_routes(v, visited, stack, 0))\n\n    return str(count) + '\\n' + '\\n'.join([str(a) + ' ' + str(b) for a, b in zip(stack, stack[1:])])"
    },
    {
        "number": 3490,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    witches = [tuple(map(float, line.split())) for line in stdin.splitlines()[1:]]\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            x1, y1, r1 = witches[i]\n            x2, y2, r2 = witches[j]\n\n            # Calculate the distance between the witches\n            distance = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n            # Calculate the angle between the witches' brooms\n            angle = abs(r1 - r2)\n\n            # Check if the distance is less than the sum of the brooms' lengths\n            if distance <= angle:\n                return \"crash\"\n\n    return \"ok\"\n"
    },
    {
        "number": 3491,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[0:2])\n    current_state = [list(map(int, line.split())) for line in stdin.split('\\n')[1:M+1]]\n    desired_state = [list(map(int, line.split())) for line in stdin.split('\\n')[M+1:2*M+1]]\n\n    def connect_floors(i, j):\n        if j == i + 1:\n            return i, j\n        elif j == i + 2:\n            return i, j + 1\n        else:\n            return i, j - 1\n\n    def disconnect_floors(i, j):\n        if j == i + 1:\n            return i, j - 1\n        elif j == i + 2:\n            return i, j - 2\n        else:\n            return i, j\n\n    def find_sequence(current_state, desired_state):\n        sequence = []\n        for i in range(N):\n            for j in range(N):\n                if current_state[i][j] != desired_state[i][j]:\n                    if current_state[i][j] == 1:\n                        sequence.append(f\"R {i}\")\n                    else:\n                        sequence.append(f\"G {i}\")\n                    current_state[i][j], current_state[i][j+1] = current_state[i][j+1], current_state[i][j]\n                    break\n        return sequence\n\n    sequence = find_sequence(current_state, desired_state)\n    Q = len(sequence)\n    output = f\"{Q}\\n\" + \"\\n\".join(sequence)\n    return output"
    },
    {
        "number": 3492,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    num_states, num_raw_materials, num_factories, num_transportation_companies = map(int, input_list[0].split())\n    raw_material_states = input_list[1].split()\n    factory_states = input_list[2].split()\n    transportation_companies = []\n\n    for i in range(3, len(input_list)):\n        num_allowed_states, *allowed_states = input_list[i].split()\n        transportation_companies.append(allowed_states)\n\n    # Find the maximum number of factories that can be supplied with raw materials\n    max_num_factories = 0\n    for i in range(num_raw_materials):\n        for j in range(num_factories):\n            can_supply = True\n            for company in transportation_companies:\n                if raw_material_states[i] in company and factory_states[j] in company:\n                    can_supply = False\n                    break\n            if can_supply:\n                max_num_factories += 1\n\n    return str(max_num_factories)\n"
    },
    {
        "number": 3493,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    buttons = [set() for _ in range(n)]\n    for i in range(1, n+1):\n        line = stdin.splitlines()[i]\n        for j in range(n):\n            if line[j] == 'Y':\n                buttons[j].add(i)\n    k = 0\n    for i in range(n):\n        if len(buttons[i]) > 0:\n            k += 1\n    if k == 0:\n        return \"0\\n\"\n    else:\n        result = []\n        for i in range(n):\n            if len(buttons[i]) > 0:\n                person = buttons[i].pop()\n                buttons[i].add(person)\n                result.append(person)\n        return f\"{k}\\n\" + \"\\n\".join(map(str, result)) + \"\\n\"\n"
    },
    {
        "number": 3494,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    R, S = map(int, input_list.pop(0).split())\n    matrix = [list(line) for line in input_list[:R]]\n    G = int(input_list[R])\n    input_list = input_list[R+1:]\n    result = []\n    for i in range(G):\n        r_i, s_i = map(int, input_list[i].split())\n        min_distance = float('inf')\n        for r in range(R):\n            for s in range(S):\n                if matrix[r][s] == 'x':\n                    distance = (r-r_i)**2 + (s-s_i)**2\n                    if distance < min_distance:\n                        min_distance = distance\n        result.append(min_distance)\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3495,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def closest_point(x, y, x1, y1, x2, y2):\n        a = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)\n        b = 2 * ((x2 - x1) * (x - x1) + (y2 - y1) * (y - y1))\n        c = x * x + y * y + x1 * x1 + y1 * y1 - 2 * (x * x1 + y * y1)\n        t = max(0, min(1, -b / (2 * a)))\n        x_ = x1 + (x2 - x1) * t\n        y_ = y1 + (y2 - y1) * t\n        return x_, y_\n\n    def generate_config(x, y, L):\n        x1, y1 = 0, 0\n        for i in range(len(L)):\n            x2, y2 = x1 + L[i] * cos(2 * pi * i / N), y1 + L[i] * sin(2 * pi * i / N)\n            x1, y1 = closest_point(x, y, x1, y1, x2, y2)\n        return x1, y1\n\n    N, L = map(int, stdin.splitlines()[:2])\n    x, y = map(int, stdin.splitlines()[-1].split())\n\n    L = list(map(int, stdin.splitlines()[2:]))\n    x1, y1 = generate_config(x, y, L)\n\n    return f\"{x1} {y1}\\n{x1 + L[0]} {y1}\\n{x1 + L[0]} {y1 + L[1]}\\n{x1} {y1 + L[1]}\"\n"
    },
    {
        "number": 3496,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def explodification(k: int, a: list) -> int:\n        if k <= n:\n            return a[k-1]\n        else:\n            i = 1\n            j = k - i\n            while i + j <= k:\n                i += 1\n                j = k - i\n            return explodification(i, a) + explodification(j, a)\n\n    n, q = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2+n]))\n\n    for _ in range(q):\n        k = int(stdin.split()[2+n:][0])\n        print(explodification(k, a))"
    },
    {
        "number": 3497,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    V, P = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    pigs = list(map(int, stdin.split()[-P:]))\n\n    # Build the tree\n    tree = {i: [] for i in range(V)}\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    # Find the leaves\n    leaves = [i for i in range(V) if len(tree[i]) == 1]\n\n    # Check if every pig can escape\n    can_escape = all(p in leaves for p in pigs)\n\n    # If every pig can escape, return 0\n    if can_escape:\n        return 0\n\n    # Otherwise, count the number of wolves to remove\n    wolf_count = 0\n    for i in range(V):\n        if i not in pigs and len(tree[i]) == 1:\n            wolf_count += 1\n\n    return wolf_count"
    },
    {
        "number": 3498,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute(task, time):\n        task['instructions'] -= 1\n        return time + 1\n\n    def lock(task, resource, time):\n        if resource in task['locked_resources']:\n            return time\n        task['locked_resources'].add(resource)\n        return time\n\n    def unlock(task, resource, time):\n        if resource not in task['locked_resources']:\n            return time\n        task['locked_resources'].remove(resource)\n        return time\n\n    def get_current_priority(task, tasks):\n        priority = task['base_priority']\n        for t in tasks:\n            if t['id'] != task['id'] and t['current_priority'] >= priority:\n                priority = t['current_priority']\n        return priority\n\n    def execute_instruction(task, instruction, time):\n        if instruction[0] == 'C':\n            return compute(task, time)\n        elif instruction[0] == 'L':\n            return lock(task, int(instruction[1:]), time)\n        elif instruction[0] == 'U':\n            return unlock(task, int(instruction[1:]), time)\n\n    def execute_task(task, tasks, time):\n        if task['instructions'] == 0:\n            return time\n        next_instruction = task['instructions'][0]\n        if next_instruction[0] == 'C':\n            return execute_instruction(task, next_instruction, time)\n        else:\n            return time\n\n    def is_blocked(task, tasks):\n        for t in tasks:\n            if t['id'] != task['id'] and t['current_priority'] >= task['current_priority']:\n                return True\n        return False\n\n    def run_tasks(tasks, resources):\n        time = 0\n        while tasks:\n            running_tasks = [t for t in tasks if t['start_time'] <= time]\n            for task in running_tasks:\n                if not is_blocked(task, tasks):\n                    time = execute_task(task, tasks, time)\n                    if task['instructions'] == 0:\n                        print(time)\n                        tasks.remove(task)\n\n    t, r = map(int, stdin.split()[:2])\n    tasks = []\n    for i in range(t):\n        start_time, base_priority, instructions = map(int, stdin.split()[2:5])\n        locked_resources = set()\n        task = {'id': i, 'start_time': start_time, 'base_priority': base_priority, 'current_priority': base_priority, 'instructions': instructions, 'locked_resources': locked_resources}\n        tasks.append(task)\n        for j in range(instructions):\n            instruction = stdin.split()[5 + j]\n            task['instructions'] = [instruction] + task['instructions']\n    run_tasks(tasks, r)\n"
    },
    {
        "number": 3499,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(str, stdin.split())\n    N = int(N)\n    S = S.upper()\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def count_palindromes(s: str, n: int) -> int:\n        count = 0\n        for i in range(len(s) - n + 1):\n            substring = s[i:i + n]\n            if is_palindrome(substring):\n                count += 1\n        return count\n\n    result = count_palindromes(S * 2, N)\n    return str(result % (10**9 + 7))\n"
    },
    {
        "number": 3500,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    cards = []\n    for i in range(1, n + 1):\n        cards.append([int(x) for x in stdin.split(\"\\n\")[i * 5 - 4].split()])\n\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            for num in range(1, 3001):\n                if cards[i].count(num) == 5 and cards[j].count(num) == 5:\n                    return f\"{i + 1} {j + 1}\"\n    return \"no ties\""
    },
    {
        "number": 3501,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    jaap_bet = list(map(int, input_list[1].split()))\n    jan_bet = list(map(int, input_list[2].split()))\n    thijs_bet = list(map(int, input_list[3].split()))\n\n    count = 0\n    for i in range(n):\n        if jaap_bet[i] == jan_bet[i] == thijs_bet[i]:\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3502,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def prob_first_red_light(x, r, g, t):\n        if t < x:\n            return 0\n        else:\n            return (r / (r + g)) * (t - x) / (2019 - x)\n\n    def prob_make_it_all_the_way(x, r, g, t):\n        if t < x:\n            return 0\n        else:\n            return (1 - r / (r + g)) * (t - x) / (2019 - x)\n\n    n = int(stdin.splitlines()[0])\n    lights = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    total_prob_first_red = 0\n    total_prob_make_it_all_the_way = 1\n\n    for x, r, g in lights:\n        total_prob_first_red += prob_first_red_light(x, r, g, 2019)\n        total_prob_make_it_all_the_way *= prob_make_it_all_the_way(x, r, g, 2019)\n\n    return f\"{total_prob_first_red:.6f}\\n{total_prob_make_it_all_the_way:.6f}\""
    },
    {
        "number": 3503,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    operators = ['+', '-', '*']\n    equations = []\n\n    for a, b in pairs:\n        while True:\n            op = random.choice(operators)\n            result = eval(f\"{a} {op} {b}\")\n            if result not in equations:\n                equations.append(result)\n                break\n\n    if len(equations) == n:\n        return '\\n'.join([f\"{a} {op} {b} = {result}\" for a, b, op, result in zip(pairs, equations, operators, range(n))])\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3504,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    D, S = map(int, input_data[0].split())\n    droplets = [tuple(map(int, line.split())) for line in input_data[1:D+1]]\n    sensors = [tuple(map(int, line.split())) for line in input_data[D+1:]]\n\n    for droplet in droplets:\n        disintegrate_y = 0\n        for sensor in sensors:\n            if droplet[0] >= sensor[0] and droplet[0] <= sensor[1] and droplet[1] == sensor[2]:\n                disintegrate_y = sensor[2]\n                break\n        print(disintegrate_y)\n\nstdin = \"\"\"5 3\n1 8\n2 3\n2 8\n5 8\n5 9\n3 6 6\n1 7 4\n1 3 1\"\"\"\n\nsolution(stdin) "
    },
    {
        "number": 3505,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    count = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            for k in range(j + 1, N):\n                if a[i] + a[j] == a[k]:\n                    count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3506,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, m = map(int, stdin.split()[:3])\n    spoilify_intervals = []\n    for _ in range(m):\n        a, b = map(int, stdin.split()[3:5])\n        spoilify_intervals.append((a, b))\n\n    # Sort the intervals by start time\n    spoilify_intervals.sort(key=lambda x: x[0])\n\n    # Calculate the total time that Spoilify is active\n    spoilify_active_time = sum(b - a for a, b in spoilify_intervals)\n\n    # Calculate the number of minutes that the teams have to cheer for\n    total_cheer_time = n * t\n\n    # Calculate the number of minutes that Spoilify has to cheer for\n    spoilify_cheer_time = spoilify_active_time\n\n    # Calculate the number of minutes that Sportify has to cheer for\n    sportify_cheer_time = total_cheer_time - spoilify_cheer_time\n\n    # Calculate the number of minutes that each cheerleader can cheer for\n    cheer_time_per_cheerleader = t // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    sportify_cheer_time_per_cheerleader = sportify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    spoilify_cheer_time_per_cheerleader = spoilify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    total_cheer_time_per_cheerleader = total_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    sportify_cheer_time_per_cheerleader = sportify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    spoilify_cheer_time_per_cheerleader = spoilify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    total_cheer_time_per_cheerleader = total_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    sportify_cheer_time_per_cheerleader = sportify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    spoilify_cheer_time_per_cheerleader = spoilify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    total_cheer_time_per_cheerleader = total_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    sportify_cheer_time_per_cheerleader = sportify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    spoilify_cheer_time_per_cheerleader = spoilify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    total_cheer_time_per_cheerleader = total_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    sportify_cheer_time_per_cheerleader = sportify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    spoilify_cheer_time_per_cheerleader = spoilify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    total_cheer_time_per_cheerleader = total_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to cheer for\n    sportify_cheer_time_per_cheerleader = sportify_cheer_time // n\n\n    # Calculate the number of minutes that each cheerleader has to"
    },
    {
        "number": 3507,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, W, d = map(int, stdin.split())\n    K = 0\n    for i in range(1, R+1):\n        for j in range(1, W+1):\n            if i <= d:\n                K += 1\n    K %= (10**9 + 7)\n    return str(K)"
    },
    {
        "number": 3508,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    b = list(map(int, input_list[1].split()))\n\n    max_damage = 0\n    pillar_to_tear_down = 0\n\n    for i in range(1, n - 1):\n        damage = 2 * b[i]\n        if damage > max_damage:\n            max_damage = damage\n            pillar_to_tear_down = i\n\n    return f\"{max_damage} {pillar_to_tear_down}\"\n"
    },
    {
        "number": 3509,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, n, m = map(int, stdin.split())\n    roads = [tuple(map(int, input().split())) for _ in range(m)]\n    roads.sort(key=lambda x: x[2])\n\n    def dijkstra(start, end, roads):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        visited = [False] * (n + 1)\n        heap = [(0, start)]\n\n        while heap:\n            d, node = heapq.heappop(heap)\n            if visited[node]:\n                continue\n            visited[node] = True\n            if node == end:\n                return d\n            for u, v, t in roads:\n                if not visited[v] and d + t < dist[v]:\n                    dist[v] = d + t\n                    heapq.heappush(heap, (dist[v], v))\n\n    time = dijkstra(1, n, roads)\n    return time + a\n"
    },
    {
        "number": 3510,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    positions = stdin.split('\\n')[1:]\n    graph = {}\n    for position in positions:\n        options = position.split()\n        options_count = int(options[0])\n        options = options[1:]\n        graph[options_count] = {}\n        for option in options:\n            graph[options_count][option] = len(option)\n\n    def dfs(node, visited, parent, graph, memo):\n        if node in visited:\n            return memo[node][parent]\n        visited.add(node)\n        if node in graph:\n            for child in graph[node]:\n                if child not in visited:\n                    memo[node][child] = dfs(child, visited, node, graph, memo) + 1\n        return min(memo[node].values())\n\n    result = []\n    for i in range(n):\n        memo = {position: {position: 0} for position in graph}\n        for options_count in graph:\n            for child in graph[options_count]:\n                memo[options_count][child] = dfs(child, set(), None, graph, memo)\n        for j in range(i, n):\n            result.append(memo[i+1][j+1])\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3511,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, stdin.split()[0:2])\n    A = [0] * (N + 1)\n    for _ in range(Q):\n        query = stdin.split()[1:]\n        if query[0] == '1':\n            u, v = map(int, query[1:])\n            A[u] += 1\n            A[v + 1] -= 1\n        else:\n            E = sum(a ** 2 for a in A)\n            result = E * pow(10, 9, 1000000007)\n            return str(result)\n"
    },
    {
        "number": 3512,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    flights = [[0] * (N + 1) for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        flights[i] = list(map(int, stdin.split('\\n')[i].split()))\n\n    # Calculate the minimum total flight duration\n    min_duration = float('inf')\n    for i in range(1, N + 1):\n        for j in range(1, N + 1):\n            if flights[i][j] != 0:\n                min_duration = min(min_duration, flights[i][j] + flights[j][i])\n\n    return str(min_duration)\n"
    },
    {
        "number": 3513,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    X = int(stdin)\n    k = 0\n    i = 2\n    while X > 1:\n        if X % i == 0:\n            k += 1\n            X //= i\n        else:\n            i += 1\n    return str(k)\n\n\ninput_str = input()\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3514,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split())\n    grid = stdin.split()[1:]\n    grid = [''.join(grid[i:i+C]) for i in range(0, len(grid), C)]\n\n    def disarm_building(row, col):\n        if grid[row][col] == 'x':\n            grid[row] = grid[row][:col] + '.' + grid[row][col+1:]\n            return 1\n        return 0\n\n    def can_disarm_building(row, col):\n        return any(grid[i][col] == 'x' for i in range(R)) or any(grid[row][j] == 'x' for j in range(C))\n\n    def find_disarmed_buildings(row, col):\n        disarmed = 0\n        if can_disarm_building(row, col):\n            disarmed = disarm_building(row, col)\n            for i in range(R):\n                if grid[i][col] == 'x':\n                    disarmed += find_disarmed_buildings(i, col)\n            for j in range(C):\n                if grid[row][j] == 'x':\n                    disarmed += find_disarmed_buildings(row, j)\n        return disarmed\n\n    disarmed = find_disarmed_buildings(0, 0)\n    return disarmed\n"
    },
    {
        "number": 3515,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_input() -> tuple:\n        N = int(input())\n        cities = []\n        for _ in range(N):\n            y, d, r = map(int, input().split())\n            cities.append((y, d, r))\n        return N, cities\n\n    def find_shortest_path(N: int, cities: list) -> list:\n        min_dist = [float('inf')] * (N + 1)\n        min_dist[1] = 0\n\n        for i in range(2, N + 1):\n            for j in range(1, i):\n                dist = abs(cities[i - 1][0] - cities[j - 1][0])\n                if dist >= cities[i - 1][1]:\n                    time = cities[i - 1][2] + dist\n                    if time < min_dist[i]:\n                        min_dist[i] = time\n\n        return min_dist\n\n    N, cities = read_input()\n    min_dist = find_shortest_path(N, cities)\n\n    for i in range(2, N + 1):\n        if min_dist[i] == float('inf'):\n            print(-1)\n        else:\n            print(min_dist[i])\n"
    },
    {
        "number": 3516,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    levels = [line.split() for line in stdin.splitlines()[1:]]\n\n    def time_to_beat(level, item):\n        shortcut_item, shortcut_time = int(level[0]), int(level[1])\n        if item == shortcut_item:\n            return shortcut_time\n        return max(a for a in map(int, level[2:]) if a >= item)\n\n    total_time = 0\n    for i in range(n):\n        level = levels[i]\n        item = i + 1\n        level_time = time_to_beat(level, item)\n        total_time += level_time\n\n    return total_time\n"
    },
    {
        "number": 3517,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n    C = [int(input_list[i+2].split()[0]) for i in range(N)]\n    A = [list(map(int, input_list[i+2].split()[1:])) for i in range(N)]\n\n    # Calculate the maximum time it takes for each step\n    max_time = [0] * N\n    for i in range(N):\n        for j in A[i]:\n            max_time[i] = max(max_time[i], max_time[j])\n        max_time[i] += a[i]\n\n    # Find the shortest possible time\n    shortest_time = min(max_time)\n\n    return str(shortest_time)"
    },
    {
        "number": 3518,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    students = [0] * (n + 1)\n    for i in range(m):\n        p, q, c = map(int, stdin.split()[i * 3 + 2:i * 3 + 5])\n        students[p] += c\n        students[q] += c\n    total_carbon = sum(students)\n    if total_carbon % 2 == 0:\n        return str(total_carbon // 2)\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3519,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin)\n    expected_turns = 0\n    for i in range(N):\n        expected_turns += 2\n    expected_turns += N\n    return f\"{expected_turns:.6f}\""
    },
    {
        "number": 3520,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, c = map(int, stdin.split()[:3])\n    pills = [tuple(map(int, stdin.split()[3:])) for _ in range(p)]\n    pills.sort(key=lambda x: x[0])\n\n    def age_seconds(t, x, y):\n        return t + y\n\n    def switch_seconds(t, c):\n        return t + c\n\n    def max_age(t, x, y, c):\n        return age_seconds(t, x, y) if x > y else age_seconds(t, y, x)\n\n    def max_age_with_pill(t, x, y, c, pills):\n        max_age_without_pill = max_age(t, x, y, c)\n        max_age_with_pill = max_age_without_pill\n\n        for i in range(p):\n            if pills[i][0] > t:\n                max_age_with_pill = max(max_age_with_pill, max_age_without_pill + max_age(pills[i][0], pills[i][1], pills[i][2], c))\n\n        return max_age_with_pill\n\n    max_age_without_pill = max_age(0, n, 0, c)\n    max_age_with_pill = max_age_without_pill\n\n    for i in range(p):\n        max_age_with_pill = max(max_age_with_pill, max_age_without_pill + max_age_with_pill_i)\n\n    return round(max_age_with_pill, 6)"
    },
    {
        "number": 3521,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dist(a, b):\n        return abs(a - b) if a > b else 2 * pi - abs(a - b)\n\n    N, stdin = int(stdin.split()[0]), stdin.split('\\n', 1)[1]\n    T, s, a = 0, 0, 0\n    for i in range(N):\n        T_i, s_i, a_i = map(float, stdin.split()[:3])\n        T += max(0, T_i - s_i * dist(a_i, a))\n        a = a_i\n    return f\"{T:.6f}\"\n\n\ndef"
    },
    {
        "number": 3522,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    batteries = sorted(map(int, stdin.split()[2:]))\n\n    min_difference = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            min_difference = min(min_difference, batteries[i * k + k - 1] - batteries[j * k])\n\n    return str(min_difference)\n"
    },
    {
        "number": 3523,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    P, N_1, N_5, N_10, N_25 = map(int, stdin.split())\n\n    # Calculate the total value of the coins\n    total_value = N_1 + 5 * N_5 + 10 * N_10 + 25 * N_25\n\n    # Check if Per could pay exactly P without getting any change back\n    if total_value == P:\n        return N_1 + N_5 + N_10 + N_25\n    else:\n        return \"Impossible\"\n"
    },
    {
        "number": 3524,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin[0]\n    s1 = stdin[1]\n    s2 = stdin[2]\n\n    s1_index = 0\n    s2_index = 0\n\n    for i in range(len(s)):\n        if s1_index < len(s1) and s[i] == s1[s1_index]:\n            s1_index += 1\n        elif s2_index < len(s2) and s[i] == s2[s2_index]:\n            s2_index += 1\n        else:\n            return \"no\"\n\n    if s1_index == len(s1) and s2_index == len(s2):\n        return \"yes\"\n    else:\n        return \"no\"\n"
    },
    {
        "number": 3525,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, L, B, S, D = map(int, stdin.split()[:5])\n    locks = [tuple(map(int, stdin.split()[5:9])) for _ in range(L)]\n\n    def count_badges(a, b, locks):\n        count = 0\n        for lock in locks:\n            if a == lock[0] and b == lock[1]:\n                count = max(count, lock[2])\n                count = min(count, lock[3])\n        return count\n\n    badges = count_badges(S, D, locks)\n    return str(badges)\n"
    },
    {
        "number": 3526,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    hints = [tuple(map(int, stdin.split()[2:4])) + (stdin.split()[4],)]\n    hints.extend(map(lambda x: tuple(map(int, x.split()[0:2])) + (x.split()[2],), stdin.split()[5:]))\n    hints.sort(key=lambda x: x[0])\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for l, r, flag in hints:\n        if flag == 'same':\n            dp[l] = 0\n            for i in range(l + 1, r + 1):\n                dp[i] = dp[i - 1]\n        else:\n            for i in range(l, r + 1):\n                dp[i] = 0\n    return str(sum(dp) % (10**9 + 7))\n"
    },
    {
        "number": 3527,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    num_computers, num_existing_cables = map(int, input_list.pop(0).split())\n    existing_cables = []\n    for _ in range(num_existing_cables):\n        a, b = map(int, input_list.pop(0).split())\n        existing_cables.append((a, b))\n\n    # Create a graph to represent the network\n    graph = [[] for _ in range(num_computers)]\n    for a, b in existing_cables:\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Find the maximum number of hops in the resulting network\n    max_hops = 0\n    for i in range(num_computers):\n        visited = [False] * num_computers\n        queue = [(i, 0)]\n        while queue:\n            node, hops = queue.pop(0)\n            if not visited[node]:\n                visited[node] = True\n                max_hops = max(max_hops, hops)\n                for neighbor in graph[node]:\n                    queue.append((neighbor, hops + 1))\n\n    return str(max_hops)\n"
    },
    {
        "number": 3528,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    nails = int(input_list[0])\n    nail_coordinates = [tuple(map(int, input_list[i+1].split())) for i in range(nails)]\n    nail_order = input_list[nails+1]\n\n    def get_area(nails):\n        x_coords = [nail[0] for nail in nails]\n        y_coords = [nail[1] for nail in nails]\n        return abs(max(x_coords) - min(x_coords)) * abs(max(y_coords) - min(y_coords))\n\n    def get_leftmost(nails):\n        return min(nails, key=lambda nail: nail[0])\n\n    def get_rightmost(nails):\n        return max(nails, key=lambda nail: nail[0])\n\n    def get_topmost(nails):\n        return max(nails, key=lambda nail: nail[1])\n\n    def get_bottommost(nails):\n        return min(nails, key=lambda nail: nail[1])\n\n    def get_nail_to_remove(nails, order):\n        if order == 'L':\n            return get_leftmost(nails)\n        elif order == 'R':\n            return get_rightmost(nails)\n        elif order == 'U':\n            return get_topmost(nails)\n        else:\n            return get_bottommost(nails)\n\n    areas = []\n    for i in range(nails-2):\n        nails_to_remove = [nail for nail in nail_coordinates if nail not in [get_nail_to_remove(nail_coordinates, nail_order[j]) for j in range(i+1)]]\n        area = get_area(nails_to_remove)\n        areas.append(area)\n\n    return '\\n'.join(str(area) for area in areas)"
    },
    {
        "number": 3529,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        color, from_node, to_node = stdin.split()\n        graph[int(from_node) - 1].append(int(to_node) - 1)\n        graph[int(to_node) - 1].append(int(from_node) - 1)\n    visited = [False] * n\n    def dfs(node: int, color_count: int) -> bool:\n        if color_count == k:\n            return True\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, color_count + (1 if graph[node][neighbor] == 0 else 0)):\n                    return True\n        return False\n    return \"1\" if dfs(0, 0) else \"0\"\n"
    },
    {
        "number": 3530,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def fun(i, k, a, b):\n        return a - (k - 1) ** 2 * b\n\n    def max_fun(a, b, t):\n        k = t // t_i\n        return fun(i, k, a, b)\n\n    N, Q = map(int, stdin.split()[:2])\n    coasters = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n    times = [int(stdin.split()[2 + 3 * N + i]) for i in range(Q)]\n\n    for t in times:\n        max_fun_value = 0\n        for i, (a, b, t_i) in enumerate(coasters):\n            max_fun_value = max(max_fun_value, max_fun(a, b, t))\n        print(max_fun_value)\n"
    },
    {
        "number": 3531,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, k, w = map(int, input_list[0].split())\n    special_places = list(map(int, input_list[1:k+1]))\n    trails = [tuple(map(int, line.split())) for line in input_list[k+1:]]\n\n    # Create a graph to represent the trails\n    graph = {i: [] for i in range(1, n+1)}\n    for a, b, c in trails:\n        graph[a].append((b, c))\n        graph[b].append((a, c))\n\n    # Find the minimum cost to connect all special places to regular places\n    min_cost = float('inf')\n    for special in special_places:\n        queue = [(special, 0)]\n        visited = set()\n        while queue:\n            vertex, cost = queue.pop(0)\n            if vertex in visited:\n                continue\n            visited.add(vertex)\n            if vertex in special_places:\n                min_cost = min(min_cost, cost)\n                break\n            for neighbor, neighbor_cost in graph[vertex]:\n                queue.append((neighbor, cost + neighbor_cost))\n\n    # If it's not possible to connect all special places to regular places, return -1\n    if min_cost == float('inf'):\n        return -1\n\n    # Find the minimum cost to connect all special-nonspecial trails\n    min_cost_special = float('inf')\n    for special in special_places:\n        for neighbor, neighbor_cost in graph[special]:\n            if neighbor in special_places:\n                min_cost_special = min(min_cost_special, neighbor_cost)\n\n    # Calculate the total cost\n    total_cost = min_cost + w * min_cost_special\n\n    return total_cost"
    },
    {
        "number": 3532,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_string, explosion_string = stdin.split('\\n')\n    explosion_string = explosion_string.strip()\n\n    def explode(string: str) -> str:\n        new_string = ''\n        for i, char in enumerate(string):\n            if char == explosion_string[0] and string[i:i+len(explosion_string)] == explosion_string:\n                new_string += string[:i] + string[i+len(explosion_string):]\n                break\n            new_string += char\n        return new_string\n\n    def chain_reaction(string: str) -> str:\n        while True:\n            new_string = explode(string)\n            if new_string == string:\n                return new_string\n            string = new_string\n\n    final_string = chain_reaction(input_string)\n    if final_string == '':\n        return 'FRULA'\n    else:\n        return final_string"
    },
    {
        "number": 3533,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    tickets = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def min_toll(entrance, exit):\n        return abs(entrance - exit)\n\n    def is_valid(ticket, used_exits):\n        entrance, exit = ticket\n        return entrance not in used_exits and exit not in used_exits\n\n    def exchange_tickets(tickets, used_exits):\n        min_toll_sum = float('inf')\n        for i in range(len(tickets)):\n            for j in range(i + 1, len(tickets)):\n                if is_valid(tickets[i], used_exits) and is_valid(tickets[j], used_exits):\n                    entrance1, exit1 = tickets[i]\n                    entrance2, exit2 = tickets[j]\n                    min_toll_sum = min(min_toll_sum, min_toll(entrance1, exit2) + min_toll(entrance2, exit1))\n        return min_toll_sum\n\n    used_exits = set()\n    min_toll_sum = float('inf')\n    for _ in range(N):\n        min_toll_sum = min(min_toll_sum, exchange_tickets(tickets, used_exits))\n        used_exits.update(ticket[1] for ticket in tickets)\n\n    return min_toll_sum\n"
    },
    {
        "number": 3534,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    multi_keys = list(map(int, input_list[1].split()))\n\n    max_correct_keys = 0\n    for i in range(N - 1):\n        if multi_keys[i] < multi_keys[i + 1]:\n            max_correct_keys += 1\n        elif multi_keys[i] > multi_keys[i + 1]:\n            max_correct_keys += 2\n        else:\n            max_correct_keys += 1\n\n    K = max_correct_keys // 2\n\n    return str(max_correct_keys) + '\\n' + str(K)\n"
    },
    {
        "number": 3535,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split()[:3])\n    measurements = [tuple(map(int, stdin.split()[3:5])) + (stdin.split()[2],)]\n    for _ in range(K - 1):\n        measurements.append(tuple(map(int, stdin.split()[3:5])) + (stdin.split()[2],))\n\n    def count_states(N, M, measurements):\n        def count_subgrid(N, M, measurements, y, x):\n            count = 0\n            for dy in range(-2, 3):\n                for dx in range(-2, 3):\n                    if (0 <= y + dy < N and 0 <= x + dx < M and (y + dy, x + dx) not in [(y, x) for (y, x, s) in measurements]):\n                        count += 1\n            return count\n\n        def count_states_recursive(N, M, measurements, y, x):\n            if (y, x) in [(y, x) for (y, x, s) in measurements]:\n                return 0\n            if y < 0 or y >= N or x < 0 or x >= M:\n                return 0\n            if (y, x) in [(y - 1, x - 1), (y - 1, x), (y - 1, x + 1), (y, x - 1), (y, x + 1), (y + 1, x - 1), (y + 1, x), (y + 1, x + 1)]:\n                return 0\n            count = count_subgrid(N, M, measurements, y, x)\n            if count == 0:\n                return 0\n            return count * count_states_recursive(N, M, measurements, y - 1, x) * count_states_recursive(N, M, measurements, y + 1, x) * count_states_recursive(N, M, measurements, y, x - 1) * count_states_recursive(N, M, measurements, y, x + 1)\n\n        return count_states_recursive(N, M, measurements, N - 1, M - 1)\n\n    return str(count_states(N, M, measurements) % (10**9 + 7))\n"
    },
    {
        "number": 3536,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def multiplicative_inverse(a, m):\n        def extended_gcd(a, b):\n            x, y, u, v = 0, 1, 1, 0\n            while b:\n                q = a // b\n                a, b = b, a - q * b\n                x, u = u, x - q * u\n                y, v = v, y - q * v\n            return x, y\n\n        g, x = extended_gcd(a, m)\n        if g != 1:\n            raise Exception(\"Inverse doesn't exist\")\n        return x % m\n\n    def heap_probability(n, b_values):\n        total_b = sum(b_values)\n        max_b = max(b_values)\n        return (total_b - max_b) / (total_b - 1)\n\n    def build_tree(n, b_values, parent_indices):\n        tree = [None] * n\n        for i in range(n):\n            tree[i] = {'b': b_values[i], 'children': []}\n        for i in range(1, n):\n            parent_index = parent_indices[i]\n            if parent_index != 0:\n                tree[parent_index]['children'].append(tree[i])\n        return tree[0]\n\n    n = int(stdin.splitlines()[0])\n    b_values = []\n    parent_indices = [0] * (n + 1)\n    for i in range(1, n + 1):\n        b, p = map(int, stdin.splitlines()[i].split())\n        b_values.append(b)\n        parent_indices[i] = p\n\n    tree = build_tree(n, b_values, parent_indices)\n    heap_prob = heap_probability(n, [node['b'] for node in tree['children']])\n    gcd_value = gcd(heap_prob * 10**9 + 7, 10**9 + 7)\n    inv_value = multiplicative_inverse(10**9 + 7, gcd_value)\n    result = (heap_prob * inv_value) % (10**9 + 7)\n    return str(result)\n"
    },
    {
        "number": 3537,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    flights = [tuple(map(int, stdin.split()[2:6])) for _ in range(m)]\n\n    def frustration(flight, time):\n        return (flight[1] - flight[0]) * (time - flight[2]) ** 2\n\n    def min_frustration(start, end, time):\n        if start == end:\n            return 0\n        min_frustration_value = float('inf')\n        for flight in flights:\n            if flight[0] == start and flight[1] == end:\n                min_frustration_value = min(min_frustration_value, frustration(flight, time))\n        return min_frustration_value\n\n    min_frustration_sum = 0\n    for i in range(1, n + 1):\n        min_frustration_sum += min_frustration(1, i, 0)\n\n    return str(min_frustration_sum)\n"
    },
    {
        "number": 3538,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, d = map(int, input_list[0].split())\n    frogs = []\n    for i in range(1, n+1):\n        l, w, h = map(int, input_list[i].split())\n        frogs.append((l, w, h))\n\n    def can_escape(frog_a, frog_b):\n        return frog_a[0] + frog_b[2] > d\n\n    def can_carry(frog_a, frog_b):\n        return frog_a[1] + frog_b[1] <= 10**8\n\n    def escape_count(frogs):\n        count = 0\n        for frog in frogs:\n            if frog[0] > d:\n                count += 1\n        return count\n\n    def escape_count_with_pile(frogs, pile):\n        count = 0\n        for frog in frogs:\n            if frog[0] > d and can_carry(frog, pile):\n                count += 1\n        return count\n\n    def max_escape_count(frogs):\n        max_count = 0\n        for i in range(len(frogs)):\n            for j in range(i+1, len(frogs)):\n                if can_escape(frogs[i], frogs[j]):\n                    max_count = max(max_count, escape_count_with_pile(frogs, frogs[i]))\n        return max_count\n\n    return max_escape_count(frogs)"
    },
    {
        "number": 3539,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    graph_count = 0\n    for i in range(1, N+1):\n        a, b = map(int, input_list[i].split())\n        graph_count += a * b\n    return graph_count % (10**9 + 7)"
    },
    {
        "number": 3540,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    grid = [list(line) for line in stdin.split('\\n')]\n    colors = {'R': 0, 'G': 1, 'B': 2, 'Y': 3}\n    color_count = [0] * 4\n\n    for row in grid:\n        for cell in row:\n            color_count[colors[cell]] += 1\n\n    if color_count[0] != 1 or color_count[1] != 1 or color_count[2] != 1 or color_count[3] != 1:\n        return \"Impossible\"\n\n    def is_solved(grid: list) -> bool:\n        colors = {'R': 0, 'G': 1, 'B': 2, 'Y': 3}\n        color_count = [0] * 4\n\n        for row in grid:\n            for cell in row:\n                color_count[colors[cell]] += 1\n\n        return color_count[0] == 1 and color_count[1] == 1 and color_count[2] == 1 and color_count[3] == 1\n\n    def move_row(grid: list, row: int, direction: int) -> None:\n        if direction == 0:\n            grid[row] = grid[row][::-1]\n        else:\n            grid[row] = grid[row][1:] + grid[row][:1]\n\n    def move_column(grid: list, column: int, direction: int) -> None:\n        for row in grid:\n            if direction == 0:\n                row = row[::-1]\n            else:\n                row = row[1:] + row[:1]\n        if direction == 0:\n            grid = [row[::-1] for row in grid]\n        else:\n            grid = [row[1:] + row[:1] for row in grid]\n\n    def solve(grid: list) -> int:\n        if is_solved(grid):\n            return 0\n\n        min_moves = float('inf')\n\n        for row in range(4):\n            for direction in range(2):\n                move_row(grid, row, direction)\n                min_moves = min(min_moves, 1 + solve(grid))\n                move_row(grid, row, 1 - direction)\n\n        for column in range(4):\n            for direction in range(2):\n                move_column(grid, column, direction)\n                min_moves = min(min_moves, 1 + solve(grid))\n                move_column(grid, column, 1 - direction)\n\n        return min_moves\n\n    return str(solve(grid))\n"
    },
    {
        "number": 3541,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    # Calculate the absolute difference between the sums of the values of all candies\n    diff = abs(sum(a) - sum(b))\n\n    # If the absolute difference is 0, the siblings already have the candies evenly distributed\n    if diff == 0:\n        return \"A\" * N\n\n    # Initialize the candy distribution\n    candy_distribution = [\"A\"] * N\n\n    # If the siblings have the same number of candies, distribute them evenly\n    if sum(a) == sum(b):\n        candy_distribution[::2] = \"A\"\n        candy_distribution[1::2] = \"B\"\n\n    # If the siblings have different numbers of candies, distribute the excess candy to the sibling with the smaller number of candies\n    else:\n        excess_candy = abs(sum(a) - sum(b)) // 2\n        if sum(a) > sum(b):\n            for i in range(excess_candy):\n                candy_distribution[a.index(min(a))] = \"B\"\n                a[a.index(min(a))] += 1\n        else:\n            for i in range(excess_candy):\n                candy_distribution[b.index(min(b))] = \"A\"\n                b[b.index(min(b))] += 1\n\n    return \"\".join(candy_distribution)"
    },
    {
        "number": 3542,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    A1, A2, B1, B2 = map(lambda x: tuple(map(int, x.split())), stdin.split('\\n')[1:])\n\n    def is_valid(x, y):\n        return 0 <= x < N and 0 <= y < M\n\n    def min_distance(p1, p2):\n        x1, y1 = p1\n        x2, y2 = p2\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    if not is_valid(*A1) or not is_valid(*A2) or not is_valid(*B1) or not is_valid(*B2):\n        return \"IMPOSSIBLE\"\n\n    if A1 == A2 or B1 == B2:\n        return \"IMPOSSIBLE\"\n\n    if A1 == B1 or A1 == B2 or A2 == B1 or A2 == B2:\n        return \"IMPOSSIBLE\"\n\n    if min_distance(A1, A2) + min_distance(B1, B2) <= min_distance(A1, B1) + min_distance(A2, B2):\n        return min_distance(A1, A2) + min_distance(B1, B2)\n    else:\n        return min_distance(A1, B1) + min_distance(A2, B2)\n"
    },
    {
        "number": 3543,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def backspace_cost(s: str) -> int:\n        count = 0\n        for c in s:\n            if c == 'a':\n                count += 1\n            else:\n                count = 0\n        return count\n\n    def autocorrect(dictionary: list, word: str) -> str:\n        for candidate in dictionary:\n            if candidate.startswith(word):\n                return candidate\n        return word\n\n    n, m = map(int, stdin.split()[:2])\n    dictionary = [line.strip() for line in stdin.split('\\n')[1:n+1]]\n    words = [line.strip() for line in stdin.split('\\n')[n+1:]]\n\n    for word in words:\n        autocorrected = autocorrect(dictionary, word)\n        keystrokes = len(word) + backspace_cost(autocorrected)\n        print(keystrokes)"
    },
    {
        "number": 3544,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    groups = [int(x) for x in stdin.splitlines()[1].split()]\n\n    # Calculate the seat-width, X, of the widest row\n    X = 1\n    while sum(groups) / X >= X:\n        X += 1\n\n    # Check if the widest row exceeds the capacity\n    if X > 12:\n        return \"impossible\"\n    else:\n        return X\n"
    },
    {
        "number": 3545,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def preorder(node: str, output: str) -> str:\n        if node:\n            output += node[0]\n            output = preorder(node[1:], output)\n            output = inorder(node, output)\n            output = postorder(node, output)\n        return output\n\n    def inorder(node: str, output: str) -> str:\n        if node:\n            output = inorder(node[1:], output)\n            output += node[0]\n            output = postorder(node, output)\n        return output\n\n    def postorder(node: str, output: str) -> str:\n        if node:\n            output = inorder(node, output)\n            output = postorder(node[1:], output)\n            output += node[0]\n        return output\n\n    observed_pre, observed_in, observed_post = stdin.split('\\n')\n    preorder_print = preorder(observed_pre, '')\n    inorder_print = inorder(observed_pre, '')\n    postorder_print = postorder(observed_pre, '')\n\n    reconstructions = []\n    for pre in ['Pre', 'In', 'Post']:\n        for in_ in ['Pre', 'In', 'Post']:\n            for post in ['Pre', 'In', 'Post']:\n                reconstructions.append(f\"{pre} {pre} {in_} {in_} {post} {post}\")\n\n    for reconstruction in reconstructions:\n        preorder_calls, inorder_calls, postorder_calls = reconstruction.split()\n        if preorder_calls == 'Pre Pre In In Post Post':\n            if inorder_print < inorder_calls:\n                continue\n            if postorder_print < postorder_calls:\n                continue\n            print(reconstruction)\n            print(preorder_print)\n            print(inorder_print)\n            print(postorder_print)\n            break"
    },
    {
        "number": 3546,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_proof_length(proof: list) -> int:\n        length = proof[0]\n        for i in range(1, len(proof)):\n            if proof[i] < n:\n                length += get_proof_length(proofs[proof[i]])\n        return length\n\n    n = int(stdin.split()[0])\n    proofs = []\n    for _ in range(n):\n        p_i, k = map(int, stdin.split()[1:3])\n        proof = list(map(int, stdin.split()[3:]))\n        proofs.append((p_i, k, proof))\n\n    shortest_length = float('inf')\n    for i in range(n):\n        length = get_proof_length(proofs[i][2])\n        if length < shortest_length:\n            shortest_length = length\n\n    return str(shortest_length)\n"
    },
    {
        "number": 3547,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def area(x1, y1, x2, y2):\n        return (x2 - x1) * (y2 - y1)\n\n    def is_overlap(x1, y1, x2, y2, x3, y3, x4, y4):\n        return not (x3 > x2 or x4 < x1 or y3 > y2 or y4 < y1)\n\n    n = int(stdin.splitlines()[0])\n    total_area = 0\n\n    for i in range(1, n + 1):\n        x1, y1, x2, y2 = map(float, stdin.splitlines()[i].split())\n        plot_area = area(x1, y1, x2, y2)\n\n        for j in range(i + 1, n + 1):\n            x3, y3, x4, y4 = map(float, stdin.splitlines()[j].split())\n\n            if is_overlap(x1, y1, x2, y2, x3, y3, x4, y4):\n                plot_area -= area(max(x1, x3), max(y1, y3), min(x2, x4), min(y2, y4))\n\n        total_area += plot_area\n\n    return f\"{total_area:.2f}\"\n"
    },
    {
        "number": 3548,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, P = map(int, input_list.pop(0).split())\n    bad_pairs = set()\n\n    for _ in range(P):\n        a, b = map(int, input_list.pop(0).split())\n        bad_pairs.add((min(a, b), max(a, b)))\n\n    count = 0\n    for i in range(1, N + 1):\n        for j in range(i, N + 1):\n            if (i, j) not in bad_pairs:\n                count += 1\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3549,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m1, m2, m3 = map(int, stdin.split()[:3])\n    x1, x2, x3 = map(int, stdin.split()[3:6])\n    y1, y2, y3 = map(int, stdin.split()[6:])\n\n    def is_within_distance(x, y, m):\n        t = abs(x - y) % m\n        return t <= y\n\n    z = min(x1, x2, x3)\n    for i in range(1, 3):\n        for j in range(i + 1, 3):\n            if is_within_distance(x1, x2, m1 * m2) and is_within_distance(x2, x3, m2 * m3) and is_within_distance(x1, x3, m1 * m3):\n                z = min(z, x1 + x2 - x3)\n            if is_within_distance(x1, x2, m1 * m3) and is_within_distance(x2, x3, m2 * m1) and is_within_distance(x1, x3, m3 * m2):\n                z = min(z, x1 + x2 - x3)\n            if is_within_distance(x1, x2, m1 * m2) and is_within_distance(x2, x3, m2 * m3) and is_within_distance(x1, x3, m3 * m1):\n                z = min(z, x1 + x2 - x3)\n            if is_within_distance(x1, x2, m1 * m3) and is_within_distance(x2, x3, m2 * m1) and is_within_distance(x1, x3, m3 * m2):\n                z = min(z, x1 + x2 - x3)\n\n    return str(z)\n"
    },
    {
        "number": 3550,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    variables = {}\n\n    for line in stdin.split('\\n'):\n        if line.startswith('var '):\n            name, value = line[4:].split(' = ')\n            variables[name] = value\n        elif line.startswith('print '):\n            expr = line[6:]\n            if expr in variables:\n                print(variables[expr])\n            else:\n                print(eval(expr))\n        elif line == 'end.':\n            break\n"
    },
    {
        "number": 3551,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    bottle_volumes = list(map(int, input_list[1].split()))\n    T = int(input_list[2])\n\n    # Check if it's possible to add the correct amount of dry ice\n    if T > sum(bottle_volumes):\n        return \"impossible\"\n\n    # Initialize variables\n    dry_ice_container = T\n    current_bottle = 0\n    moves = []\n\n    # Fill bottles until dry ice container is empty\n    while dry_ice_container > 0:\n        if dry_ice_container <= bottle_volumes[current_bottle]:\n            moves.append(f\"fill {current_bottle}\")\n            dry_ice_container = 0\n        else:\n            moves.append(f\"fill {current_bottle}\")\n            dry_ice_container -= bottle_volumes[current_bottle]\n            current_bottle = (current_bottle + 1) % N\n\n    # Transfer dry ice from bottles to target bottle\n    for i in range(N):\n        while bottle_volumes[i] > 0:\n            if T <= bottle_volumes[i]:\n                moves.append(f\"transfer {i} 0\")\n                T -= bottle_volumes[i]\n                bottle_volumes[i] = 0\n            else:\n                moves.append(f\"transfer {i} 0\")\n                T -= bottle_volumes[i]\n                bottle_volumes[i] = 0\n\n    # Discard bottles\n    for i in range(N):\n        if bottle_volumes[i] > 0:\n            moves.append(f\"discard {i}\")\n\n    return \"\\n\".join(moves)"
    },
    {
        "number": 3552,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    if n < m * k:\n        return n * m\n    else:\n        return (n // k) * m + (n % k) * (m - 1)\n\ninput_str = \"10 4 3\"\nprint(solution(input_str)) "
    },
    {
        "number": 3553,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, M = map(int, stdin.split()[:3])\n    array = list(map(int, stdin.split()[3:N+3]))\n    queries = stdin.split()[N+3:]\n\n    def change_value(p, v):\n        array[p-1] = v\n\n    def shortest_subarray_length():\n        min_length = float('inf')\n        for i in range(1, K+1):\n            j = 0\n            while j < N and array[j] <= i:\n                j += 1\n            if j < N:\n                k = j\n                while k < N and array[k] <= K:\n                    k += 1\n                min_length = min(min_length, k-j)\n        return min_length if min_length != float('inf') else -1\n\n    for i in range(0, len(queries), 2):\n        if queries[i] == '1':\n            change_value(int(queries[i+1]), int(queries[i+2]))\n        else:\n            print(shortest_subarray_length())"
    },
    {
        "number": 3554,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    D, W, C = map(int, stdin.split())\n    return round(D * W / C, 12)\n\ninput_str = \"1000 3000 1000\"\noutput_str = solution(input_str)\nprint(output_str)"
    },
    {
        "number": 3555,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def closest_toy(x, y, toys):\n        closest = None\n        min_dist = float('inf')\n        for toy in toys:\n            dist = distance(x, y, toy[0], toy[1])\n            if dist < min_dist:\n                min_dist = dist\n                closest = toy\n        return closest\n\n    def next_toy(x, y, toys):\n        return closest_toy(x, y, toys)\n\n    def run_out_of_leash(x, y, toys, leash_length):\n        while toys:\n            next_toy_ = next_toy(x, y, toys)\n            dist = distance(x, y, next_toy_[0], next_toy_[1])\n            if dist > leash_length:\n                return False\n            x, y = next_toy_\n            toys.remove(next_toy_)\n        return True\n\n    n, m = map(int, stdin.split()[0:2])\n    toys = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2, 2 + n * 2, 2)]\n    trees = [tuple(map(int, stdin.split()[i:i+2])) for i in range(2 + n * 2, 2 + n * 2 + m * 2, 2)]\n\n    leash_length = 1\n    while not run_out_of_leash(0, 0, toys, leash_length):\n        leash_length += 1\n\n    return round(leash_length, 2)"
    },
    {
        "number": 3556,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def find_boss(employee_id: int, employees: list) -> int:\n        for employee in employees:\n            if employee[0] == employee_id:\n                return employee[0]\n            elif employee[2] > employee_id:\n                return employee[0]\n        return -1\n\n    def find_subordinates(employee_id: int, employees: list) -> int:\n        subordinates = 0\n        for employee in employees:\n            if employee[2] < employee_id:\n                subordinates += 1\n        return subordinates\n\n    def find_chairperson(employees: list) -> int:\n        max_salary = 0\n        chairperson = -1\n        for employee in employees:\n            if employee[1] > max_salary:\n                max_salary = employee[1]\n                chairperson = employee[0]\n        return chairperson\n\n    def process_queries(chairperson: int, employees: list, queries: list) -> str:\n        result = []\n        for query in queries:\n            boss_id = find_boss(query, employees)\n            subordinates = find_subordinates(query, employees)\n            if boss_id == chairperson:\n                result.append(f\"{query} {0}\")\n            else:\n                result.append(f\"{query} {boss_id} {subordinates}\")\n        return \"\\n\".join(result)\n\n    m, q = map(int, stdin.split()[0:2])\n    employees = []\n    for _ in range(m):\n        employee = list(map(int, stdin.split()[1:4]))\n        employees.append(employee)\n    queries = list(map(int, stdin.split()[4:]))\n\n    chairperson = find_chairperson(employees)\n    result = process_queries(chairperson, employees, queries)\n    return result"
    },
    {
        "number": 3557,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    p = list(map(int, input_list[1].split()))\n    order = list(map(int, input_list[2].split()))\n\n    p.sort()\n    chaos = [p[i] for i in order]\n    max_chaos = sum(chaos)\n\n    return str(max_chaos)\n"
    },
    {
        "number": 3558,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, x2, h1, h2):\n        return (x1 + h1) - (x2 - h2)\n\n    def is_covered(x, h, buildings):\n        for b in buildings:\n            if distance(x, b[1], h, b[2]) >= 0:\n                return True\n        return False\n\n    N, D = map(int, stdin.split()[:2])\n    buildings = [list(map(int, stdin.split()[i].split())) for i in range(2, 2 + N * 3, 3)]\n    buildings.sort(key=lambda x: x[1])\n\n    covered_length = 0\n    for i in range(N):\n        if is_covered(buildings[i][1], buildings[i][2], buildings[:i]):\n            covered_length = buildings[i][1]\n            break\n\n    return f\"{covered_length:.6f}\"\n"
    },
    {
        "number": 3559,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def get_closest_enemy(x, y, player):\n        closest_enemy = None\n        closest_distance = float('inf')\n        for i in range(N):\n            for j in range(N):\n                if grid[i][j] == '1' and player != 1:\n                    distance = manhattan_distance(x, y, i, j)\n                    if distance < closest_distance:\n                        closest_enemy = (i, j)\n                        closest_distance = distance\n                elif grid[i][j] == '2' and player != 2:\n                    distance = manhattan_distance(x, y, i, j)\n                    if distance < closest_distance:\n                        closest_enemy = (i, j)\n                        closest_distance = distance\n        return closest_enemy\n\n    def get_closest_enemy_direction(x, y, player):\n        closest_enemy = get_closest_enemy(x, y, player)\n        if closest_enemy is None:\n            return None\n        closest_x, closest_y = closest_enemy\n        directions = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1)]\n        closest_direction = None\n        min_distance = float('inf')\n        for direction in directions:\n            dx, dy = direction\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < N and 0 <= new_y < N and grid[new_x][new_y] == '.':\n                distance = manhattan_distance(closest_x, closest_y, new_x, new_y)\n                if distance < min_distance:\n                    closest_direction = direction\n                    min_distance = distance\n        return closest_direction\n\n    def get_closest_enemy_direction_tie_breaking(x, y, player):\n        directions = [(0, -1), (1, -1), (1, 0), (1, 1), (0, 1), (-1, 1), (-1, 0), (-1, -1)]\n        closest_direction = None\n        min_distance = float('inf')\n        for direction in directions:\n            dx, dy = direction\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < N and 0 <= new_y < N and grid[new_x][new_y] == '.':\n                distance = manhattan_distance(x, y, new_x, new_y)\n                if distance < min_distance:\n                    closest_direction = direction\n                    min_distance = distance\n        return closest_direction\n\n    def move_or_attack(x, y, player):\n        closest_enemy_direction = get_closest_enemy_direction(x, y, player)\n        if closest_enemy_direction is not None:\n            dx, dy = closest_enemy_direction\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < N and 0 <= new_y < N and grid[new_x][new_y] == '.':\n                grid[x][y] = '.'\n                grid[new_x][new_y] = '1' if player == 1 else '2'\n                return (new_x, new_y)\n        closest_enemy_direction_tie_breaking = get_closest_enemy_direction_tie_breaking(x, y, player)\n        if closest_enemy_direction_tie_breaking is not None:\n            dx, dy = closest_enemy_direction_tie_breaking\n            new_x, new_y = x + dx, y + dy\n            if 0 <= new_x < N and 0 <= new_y < N and grid[new_x][new_y] == '.':\n                grid[x][y] = '.'\n                grid[new_x]["
    },
    {
        "number": 3560,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, Q = map(int, input().split())\n    barbarians = [input() for _ in range(N)]\n    for _ in range(Q):\n        T = int(input())\n        if T == 1:\n            P = input()\n        else:\n            S = int(input())\n            word = barbarians[S-1]\n            count = 0\n            for i in range(len(word)):\n                if word[i:i+len(P)] == P:\n                    count += 1\n            print(count)\n"
    },
    {
        "number": 3561,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, S, C, K = map(int, stdin.split())\n    if W + S + C <= K:\n        return \"YES\"\n    else:\n        return \"NO\"\n\ndef"
    },
    {
        "number": 3562,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, T = map(int, stdin.split()[0:2])\n    a, b, c = [], [], []\n    for _ in range(N):\n        a_, b_, c_ = map(float, stdin.split()[2:5])\n        a.append(a_)\n        b.append(b_)\n        c.append(c_)\n\n    def f(t, i):\n        return a[i] * t ** 2 + b[i] * t + c[i]\n\n    def is_valid(t):\n        return all(f(t, i) >= 0 for i in range(N)) and all(f(t, i) <= 100 for i in range(N))\n\n    def max_average_grade(t):\n        return sum(f(t, i) for i in range(N)) / N\n\n    def binary_search(left, right):\n        while left <= right:\n            mid = (left + right) / 2\n            if is_valid(mid) and max_average_grade(mid) > max_average_grade(left):\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    return f\"{binary_search(0, T):.6f}\"\n"
    },
    {
        "number": 3563,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    n = int(input_list[0])\n    holes = [(int(input_list[i]), int(input_list[i+1])) for i in range(1, 2*n, 2)]\n\n    def is_convex(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0]) > 0\n\n    def is_inside(p, polygon):\n        n = len(polygon)\n        inside = False\n        p1 = polygon[0]\n        for i in range(n+1):\n            p2 = polygon[i % n]\n            if p[1] >= min(p1[1], p2[1]):\n                if p[1] < max(p1[1], p2[1]):\n                    if p[0] < max(p1[0], p2[0]):\n                        if is_convex(p1, p2, p):\n                            inside = not inside\n            p1 = p2\n        return inside\n\n    def min_lines(polygon):\n        lines = []\n        for i in range(n):\n            if not is_inside(holes[i], polygon):\n                lines.append((polygon[i], polygon[(i+1) % n]))\n        return lines\n\n    def convex_hull(points):\n        points = sorted(set(points))\n        def cross(o, a, b):\n            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n        hull = []\n        for p in points:\n            while len(hull) >= 2 and cross(hull[-2], hull[-1], p) <= 0:\n                hull.pop()\n            hull.append(p)\n        return hull\n\n    polygon = convex_hull(holes)\n    return str(len(min_lines(polygon)))"
    },
    {
        "number": 3564,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(p, r, x, y):\n        return distance(p, (x, y)) <= r\n\n    def is_valid_tunnel(p1, p2, r1, r2):\n        return distance(p1, p2) <= r1 + r2\n\n    def is_valid_throw(p1, p2, h):\n        return distance(p1, p2) <= h * ratio\n\n    n, m, k, ratio = map(int, stdin.split()[:3])\n    islands = [tuple(map(int, stdin.split()[3:6])) for _ in range(n)]\n    palm_trees = [tuple(map(int, stdin.split()[6:9])) for _ in range(m)]\n\n    min_length = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_valid_tunnel(islands[i], islands[j], *islands[i][1:], *islands[j][1:]):\n                for p in palm_trees:\n                    if is_inside(p, p[2], *islands[i][:2]) and is_inside(p, p[2], *islands[j][:2]):\n                        min_length = min(min_length, p[2] * ratio)\n\n    if min_length == float('inf'):\n        return \"impossible\"\n    else:\n        return round(min_length, 6)\n"
    },
    {
        "number": 3565,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list.pop(0).split())\n    cities = input_list[:n]\n    routes = [tuple(map(int, line.split())) for line in input_list[n:n+m]]\n    assignments = input_list[n+m:]\n\n    # Calculate the minimum cost of setting up all four lines\n    min_cost = float('inf')\n    for assignment in assignments:\n        start, end = assignment.split()\n        start_index = cities.index(start)\n        end_index = cities.index(end)\n        min_cost = min(min_cost, min([c for s, e, c in routes if s == start_index and e == end_index] + [float('inf')]))\n\n    return str(min_cost)"
    },
    {
        "number": 3566,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, q = map(int, input_list[0].split())\n    hut_counts = list(map(int, input_list[1].split()))\n    hut_counts.append(0)\n    for i in range(2, len(input_list)):\n        hut_index, new_count = map(int, input_list[i].split())\n        hut_counts[hut_index] = new_count\n\n    result = []\n    for i in range(q):\n        left_count = sum(hut_counts[:n//2])\n        right_count = sum(hut_counts[n//2:])\n        diff = abs(left_count - right_count)\n        if left_count > right_count:\n            result.append(n//2)\n        elif left_count < right_count:\n            result.append(n//2 - 1)\n        else:\n            result.append(n//2 - diff % 2)\n\n    return '\\n'.join(map(str, result))"
    },
    {
        "number": 3567,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    players = stdin.split('\\n')[1:]\n    tira_features = [0] * k\n\n    for player in players:\n        player_features = list(map(int, player))\n        for i in range(k):\n            if tira_features[i] == 0 and player_features[i] == 1:\n                tira_features[i] = 1\n\n    return ''.join(map(str, tira_features))\n"
    },
    {
        "number": 3568,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_possible(intervals: list) -> bool:\n        start_time = intervals[0][0]\n        end_time = intervals[0][1]\n        for interval in intervals[1:]:\n            if interval[0] < end_time:\n                return False\n            start_time = interval[0]\n            end_time = interval[1]\n        return True\n\n    def parse_input(input_str: str) -> tuple:\n        lines = input_str.split('\\n')\n        num_frequencies = int(lines[0])\n        frequency_intervals = []\n        for i in range(1, len(lines), 2):\n            t_i, n_i = map(int, lines[i].split())\n            intervals = []\n            for j in range(1, n_i * 2, 2):\n                t_i_2j, t_i_2j_plus_1 = map(int, lines[i + j].split())\n                intervals.append((t_i_2j, t_i_2j_plus_1))\n            frequency_intervals.append(intervals)\n        return num_frequencies, frequency_intervals\n\n    num_frequencies, frequency_intervals = parse_input(stdin)\n    for intervals in frequency_intervals:\n        if not is_possible(intervals):\n            return \"impossible\"\n    return \"possible\"\n"
    },
    {
        "number": 3569,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    opponents = []\n    for i in range(1, n+1):\n        x, y, r = map(float, input_list[i].split())\n        opponents.append((x, y, r))\n\n    def is_hit(x, y, r):\n        return any(dist := np.sqrt((x - x_i)**2 + (y - y_i)**2) <= r_i for x_i, y_i, r_i in opponents)\n\n    import numpy as np\n    max_hit = 0\n    for angle in np.linspace(0, 2*np.pi, 361):\n        x, y = np.cos(angle), np.sin(angle)\n        if is_hit(x, y, 1):\n            max_hit += 1\n\n    return str(max_hit)"
    },
    {
        "number": 3570,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def process_event(event: str) -> str:\n        return event.replace('_', ' ')\n\n    def process_scenario(scenario: str, events: list) -> str:\n        for event in scenario.split()[1:]:\n            if event.startswith('!'):\n                events.remove(process_event(event[1:]))\n            else:\n                events.append(process_event(event))\n        return events\n\n    def is_consistent(scenario: list, events: list) -> bool:\n        for event in scenario:\n            if event not in events:\n                return False\n        return True\n\n    def find_dream_level(events: list, dream_level: int) -> int:\n        for i in range(dream_level, len(events) + 1):\n            if 'All Just A Dream' in events[i - 1:i]:\n                return i\n        return len(events) + 1\n\n    n = int(stdin.splitlines()[0])\n    events = []\n    for i in range(1, n + 1):\n        line = stdin.splitlines()[i]\n        if line.startswith('E'):\n            events.append(process_event(line[2:]))\n        elif line.startswith('D'):\n            dream_level = int(line[2:])\n            events = events[:find_dream_level(events, dream_level)]\n        elif line.startswith('S'):\n            scenario = line[2:].split()\n            if is_consistent(scenario, events):\n                return 'Yes'\n            else:\n                return f'{find_dream_level(events, 1) - 1} Just A Dream'\n    return 'Plot Error'"
    },
    {
        "number": 3571,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    W, H, F, N = map(int, input_data[0].split())\n    text = input_data[1:]\n\n    # Adjust the text\n    adjusted_text = []\n    for line in text:\n        adjusted_text.append(line.ljust(80))\n\n    # Calculate the thumb position\n    def thumb(lines, height, first):\n        return (height - 3 - first) * lines // (height - 3)\n\n    T = thumb(len(adjusted_text), H, F)\n\n    # Build the window\n    window = []\n    for i in range(H):\n        line = adjusted_text[F + i - T]\n        if i < T:\n            window.append('+' + line + '+')\n        elif i == T:\n            window.append('|' + line + '|')\n        else:\n            window.append('-' + line + '-')\n\n    # Print the window\n    return '\\n'.join(window)"
    },
    {
        "number": 3572,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, L = map(int, input_list[0].split())\n    distance_matrix = [[0 for _ in range(n)] for _ in range(n)]\n\n    for i in range(1, len(input_list)):\n        row = list(map(int, input_list[i].split()))\n        for j in range(len(row)):\n            distance_matrix[i-1][j] = row[j]\n            distance_matrix[j][i-1] = row[j]\n\n    def dfs(start: int, visited: set, path: list, total_distance: int) -> bool:\n        if len(visited) == n:\n            return total_distance == L\n\n        for i in range(n):\n            if i not in visited:\n                if total_distance + distance_matrix[start][i] <= L:\n                    if dfs(i, visited | {i}, path + [i], total_distance + distance_matrix[start][i]):\n                        return True\n\n        return False\n\n    if dfs(0, {0}, [0], 0):\n        return \"possible\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3573,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, D, C = map(int, stdin.split()[:3])\n    cesar_numbers = set(map(int, stdin.split()[3:4]))\n    raul_numbers = set(map(int, stdin.split()[4:5]))\n\n    if len(cesar_numbers) != C or len(raul_numbers) != C:\n        raise ValueError(\"Invalid input: each player must choose C distinct numbers between 1 and N\")\n\n    if not (1 <= N <= 50) or not (1 <= D <= min(10, N)) or not (1 <= C <= min(10, N)):\n        raise ValueError(\"Invalid input: N, D, and C must satisfy the given constraints\")\n\n    if not (cesar_numbers.issubset(set(range(1, N + 1))) and raul_numbers.issubset(set(range(1, N + 1)))):\n        raise ValueError(\"Invalid input: each player must choose C distinct numbers between 1 and N\")\n\n    if len(cesar_numbers.intersection(raul_numbers)) > 0:\n        raise ValueError(\"Invalid input: each player must choose C distinct numbers between 1 and N\")\n\n    expected_rounds = 1 + (N - D) / D\n    return f\"{expected_rounds:.6f}\"\n"
    },
    {
        "number": 3574,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_magical(arr: list) -> bool:\n        return all(arr[0] <= arr[i] <= arr[-1] for i in range(1, len(arr)))\n\n    def longest_magical_subarray(arr: list, L: int, R: int) -> int:\n        return max(len(arr[L:R+1]), len(arr[:L]), len(arr[R+1:]))\n\n    N, arr, Q = map(int, stdin.split(\"\\n\")[:3])\n    queries = [tuple(map(int, stdin.split(\"\\n\")[i+3].split())) for i in range(Q)]\n\n    result = []\n    for L, R in queries:\n        subarray = arr[L-1:R]\n        if is_magical(subarray):\n            result.append(longest_magical_subarray(subarray, L, R))\n        else:\n            result.append(0)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3575,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_neighbours(n: int, m: int, edges: list) -> list:\n        neighbours = [[] for _ in range(n)]\n        for u, v in edges:\n            neighbours[u].append(v)\n            neighbours[v].append(u)\n        return neighbours\n\n    def get_probabilities(neighbours: list) -> list:\n        probabilities = [1 / len(neighbours[i]) for i in range(n)]\n        return probabilities\n\n    def get_expected_time(probabilities: list) -> float:\n        return sum(probabilities)\n\n    def get_neighbour_probabilities(neighbours: list, probabilities: list) -> list:\n        neighbour_probabilities = []\n        for i in range(n):\n            total = 0\n            for j in neighbours[i]:\n                total += probabilities[j]\n            neighbour_probabilities.append(total)\n        return neighbour_probabilities\n\n    def get_neighbour_probability(neighbours: list, probabilities: list, u: int, v: int) -> float:\n        total = 0\n        for i in neighbours[u]:\n            if i == v:\n                total += probabilities[i]\n        return total\n\n    def get_neighbour_probability_matrix(neighbours: list, probabilities: list) -> list:\n        probability_matrix = []\n        for i in range(n):\n            row = []\n            for j in range(n):\n                row.append(get_neighbour_probability(neighbours, probabilities, i, j))\n            probability_matrix.append(row)\n        return probability_matrix\n\n    def get_neighbour_probability_matrix_row(neighbours: list, probabilities: list, u: int) -> list:\n        row = []\n        for j in range(n):\n            row.append(get_neighbour_probability(neighbours, probabilities, u, j))\n        return row\n\n    def get_neighbour_probability_matrix_column(neighbours: list, probabilities: list, u: int) -> list:\n        column = []\n        for j in range(n):\n            column.append(get_neighbour_probability(neighbours, probabilities, j, u))\n        return column\n\n    def get_neighbour_probability_matrix_row_sum(neighbours: list, probabilities: list, u: int) -> float:\n        return sum(get_neighbour_probability_matrix_row(neighbours, probabilities, u))\n\n    def get_neighbour_probability_matrix_column_sum(neighbours: list, probabilities: list, u: int) -> float:\n        return sum(get_neighbour_probability_matrix_column(neighbours, probabilities, u))\n\n    def get_neighbour_probability_matrix_row_sums(neighbours: list, probabilities: list) -> list:\n        row_sums = []\n        for i in range(n):\n            row_sums.append(get_neighbour_probability_matrix_row_sum(neighbours, probabilities, i))\n        return row_sums\n\n    def get_neighbour_probability_matrix_column_sums(neighbours: list, probabilities: list) -> list:\n        column_sums = []\n        for i in range(n):\n            column_sums.append(get_neighbour_probability_matrix_column_sum(neighbours, probabilities, i))\n        return column_sums\n\n    def get_neighbour_probability_matrix_row_sum_min(neighbours: list, probabilities: list) -> float:\n        row_sums = get_neighbour_probability_matrix_row_sums(neighbours, probabilities)\n        return min(row_sums)\n\n    def get_neighbour_probability_matrix_column_sum_min(neighbours: list, probabilities: list) -> float:\n        column_sums = get_neighbour_probability_matrix_column"
    },
    {
        "number": 3576,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C, K = map(int, stdin.split())\n    p = R * C - 1\n    q = R * C - 1\n    for i in range(1, K + 1):\n        p -= R * C - 1\n        q -= R * C - 1\n    p = p * (R * C - 1)\n    q = q * (R * C - 1)\n    return str(p % (10**11 + 3))\n"
    },
    {
        "number": 3577,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_flowers(plants: list, day: int) -> int:\n        flowers = 0\n        for plant in plants:\n            if day == 1:\n                continue\n            if plant[0] <= day <= plant[1]:\n                flowers += 1\n        return flowers\n\n    def parse_input(input_str: str) -> list:\n        lines = input_str.split('\\n')\n        plants = []\n        for line in lines:\n            if line:\n                L, R = map(int, line.split())\n                plants.append([L, R])\n        return plants\n\n    def format_output(output_list: list) -> str:\n        return '\\n'.join(map(str, output_list))\n\n    N = int(stdin.split('\\n', 1)[0])\n    plants = parse_input(stdin.split('\\n', 1)[1])\n    output = [0]\n    for day in range(2, N + 1):\n        flowers = count_flowers(plants, day)\n        output.append(flowers)\n    return format_output(output)"
    },
    {
        "number": 3578,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, R, F = map(int, input_list[0].split())\n    flights = [list(map(int, input_list[i+1].split())) for i in range(R)]\n    additional_flights = [list(map(int, input_list[i+R+2].split())) for i in range(F)]\n\n    # Create a graph with the flights\n    graph = {i: [] for i in range(1, N+1)}\n    for flight in flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n        graph[flight[1]].append((flight[0], flight[2]))\n\n    # Add the additional flights to the graph\n    for flight in additional_flights:\n        graph[flight[0]].append((flight[1], flight[2]))\n        graph[flight[1]].append((flight[0], flight[2]))\n\n    # Find the shortest path between each pair of airports\n    shortest_paths = {i: {j: float('inf') for j in range(1, N+1)} for i in range(1, N+1)}\n    for i in range(1, N+1):\n        shortest_paths[i][i] = 0\n        for j in range(1, N+1):\n            if i == j:\n                continue\n            for neighbor, cost in graph[i]:\n                if neighbor == j:\n                    shortest_paths[i][j] = cost\n                    break\n\n    # Calculate the total cost of the flights\n    total_cost = 0\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            if i == j:\n                continue\n            total_cost += shortest_paths[i][j]\n\n    return str(total_cost)"
    },
    {
        "number": 3579,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, w = map(int, stdin.split()[0].split())\n    a, b = map(int, stdin.split()[1].split())\n    std_map = [[0 for _ in range(w)] for _ in range(h)]\n    for i in range(2, len(stdin.split())):\n        x, y, std_count = map(int, stdin.split()[i].split())\n        std_map[x-1][y-1] = std_count\n\n    def density(rect_area):\n        total_std = 0\n        for i in range(h):\n            for j in range(w):\n                if std_map[i][j] > 0:\n                    total_std += std_map[i][j]\n        return total_std / rect_area\n\n    densities = []\n    for i in range(1, b+1):\n        for j in range(1, i+1):\n            if i*j <= w*h:\n                densities.append(density(i*j))\n\n    return f\"{median(densities):.10f}\"\n\ndef"
    },
    {
        "number": 3580,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def binary_search(arr, x):\n        low, high = 0, len(arr) - 1\n        while low <= high:\n            mid = (low + high) // 2\n            if arr[mid] == x:\n                return mid\n            elif arr[mid] < x:\n                low = mid + 1\n            else:\n                high = mid - 1\n        return -1\n\n    def longest_consecutive_subsequence(arr, start, B):\n        if not B:\n            return 0\n        B.sort()\n        max_length = 0\n        for i in range(start, len(arr)):\n            if arr[i] in B:\n                index = binary_search(B, arr[i])\n                if index != -1:\n                    B.pop(index)\n                    max_length += 1\n            else:\n                break\n        return max_length\n\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    q = int(stdin.splitlines()[2])\n\n    for i in range(3, len(stdin.splitlines()), 2):\n        start = int(stdin.splitlines()[i].split()[0])\n        B = list(map(int, stdin.splitlines()[i + 1].split()))\n        print(longest_consecutive_subsequence(a, start, B))\n"
    },
    {
        "number": 3581,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, H = map(int, stdin.splitlines()[0].split())\n    v = list(map(int, stdin.splitlines()[1].split()))\n    p = [list(map(float, stdin.splitlines()[i+2].split())) for i in range(H)]\n\n    def expected_payout(ball_hole, payouts, probabilities):\n        expected_payout = 0\n        for i, p_i in enumerate(probabilities):\n            expected_payout += p_i * payouts[ball_hole + i]\n        return expected_payout\n\n    def expected_value(ball_hole, payouts, probabilities):\n        expected_value = 0\n        for i in range(N):\n            expected_value += expected_payout(ball_hole + i, payouts, probabilities)\n        return expected_value\n\n    expected_values = [expected_value(i, v, p) for i in range(H)]\n    return round(sum(expected_values), 5)"
    },
    {
        "number": 3582,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    current_mentors = list(map(int, stdin.splitlines()[1].split()))\n\n    # Create a dictionary to store the mentor relationships\n    mentor_dict = {}\n    for i in range(1, n + 1):\n        mentor_dict[i] = current_mentors[i - 1]\n\n    # Create a list to store the new mentor assignments\n    new_mentors = [0] * n\n\n    # Iterate through the Gagglers and assign new mentors based on the tie-breaking rule\n    for i in range(1, n + 1):\n        current_mentor = current_mentors[i - 1]\n        new_mentor = current_mentor\n\n        # If the current mentor is the same as the i-th Gaggler, keep the current mentor\n        if current_mentor == i:\n            new_mentors[i - 1] = current_mentor\n        else:\n            # Find the lowest-numbered mentor that the i-th Gaggler can mentor\n            lowest_mentor = n\n            for j in range(1, n + 1):\n                if j != i and j != current_mentor and mentor_dict[j] < lowest_mentor:\n                    lowest_mentor = mentor_dict[j]\n\n            # Assign the lowest-numbered mentor as the new mentor\n            new_mentors[i - 1] = lowest_mentor\n\n            # Update the mentor dictionary\n            mentor_dict[i] = lowest_mentor\n\n    # Convert the new mentor assignments to a string and return it\n    return \" \".join(map(str, new_mentors))"
    },
    {
        "number": 3583,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    n = int(input_data[0])\n    points = [tuple(map(int, input_data[i+1].split())) for i in range(n)]\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_convex(p1, p2, p3):\n        return (distance(p1, p2) + distance(p2, p3) + distance(p3, p1)) / 2 >= distance(p1, p2) + distance(p2, p3) + distance(p3, p1)\n\n    def is_hexagon(p1, p2, p3, p4, p5, p6):\n        return is_convex(p1, p2, p3) and is_convex(p2, p3, p4) and is_convex(p3, p4, p5) and is_convex(p4, p5, p6) and is_convex(p5, p6, p1) and is_convex(p6, p1, p2)\n\n    def max_circumference(p1, p2, p3, p4, p5, p6):\n        return 2 + 4 * (distance(p1, p2) + distance(p2, p3) + distance(p3, p4) + distance(p4, p5) + distance(p5, p6) + distance(p6, p1)) / 6\n\n    def max_circumference_for_vertex(p):\n        max_circumference = 0\n        for i in range(n):\n            for j in range(i+1, n):\n                for k in range(j+1, n):\n                    for l in range(k+1, n):\n                        for m in range(l+1, n):\n                            for n in range(m+1, n):\n                                if is_hexagon(p, points[i], points[j], points[k], points[l], points[m], points[n]):\n                                    max_circumference = max(max_circumference, max_circumference(p, points[i], points[j], points[k], points[l], points[m], points[n]))\n        return max_circumference\n\n    result = [max_circumference_for_vertex(p) for p in points]\n    return '\\n'.join(str(r) for r in result)"
    },
    {
        "number": 3584,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M, K = map(int, input_list[0].split())\n    onion_coords = [tuple(map(int, input_list[i+1].split())) for i in range(N)]\n    fence_coords = [tuple(map(int, input_list[i+1+N].split())) for i in range(M)]\n\n    def convex_hull(points):\n        points = sorted(points, key=lambda x: (x[1], x[0]))\n        n = len(points)\n        hull = []\n        for i in range(n):\n            while len(hull) >= 2 and not ((hull[-1][0] > points[i][0]) or (hull[-1][1] >= points[i][1])):\n                hull.pop()\n            hull.append(points[i])\n        return hull\n\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_inside(onion_coords, fence_coords):\n        hull = convex_hull(fence_coords)\n        for i in range(len(hull)):\n            if distance(onion_coords, hull[i]) > distance(onion_coords, hull[(i+1) % len(hull)]):\n                return False\n        return True\n\n    def max_onions(onion_coords, fence_coords, K):\n        fence_coords = fence_coords[:K]\n        max_onions = 0\n        for i in range(len(fence_coords)):\n            for j in range(i+1, len(fence_coords)):\n                for k in range(j+1, len(fence_coords)):\n                    fence_coords_new = fence_coords[:i] + fence_coords[i+1:j] + fence_coords[j+1:k] + fence_coords[k+1:]\n                    if is_inside(onion_coords, fence_coords_new):\n                        max_onions = max(max_onions, len(fence_coords_new))\n        return max_onions\n\n    return str(max_onions(onion_coords, fence_coords, K))"
    },
    {
        "number": 3585,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, k = map(int, stdin.split())\n    if m == 1:\n        return \"1\"\n    elif m == 2:\n        return \"9\"\n    else:\n        return \"998244353\"\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 3586,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    S = set(map(int, input_list[1:]))\n    max_d = -float('inf')\n    for a in S:\n        for b in S:\n            for c in S:\n                if a != b and a != c and b != c:\n                    d = a + b + c\n                    if d in S and d > max_d:\n                        max_d = d\n    if max_d == -float('inf'):\n        return \"No solution\"\n    else:\n        return str(max_d)"
    },
    {
        "number": 3587,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    taboo_strings = [line.strip() for line in stdin.splitlines()[1:]]\n    max_length = 0\n    longest_clue = \"\"\n\n    for i in range(1, 2**16):\n        clue = bin(i)[2:].zfill(16)\n        if all(s not in clue for s in taboo_strings):\n            if len(clue) > max_length:\n                max_length = len(clue)\n                longest_clue = clue\n            elif len(clue) == max_length and clue < longest_clue:\n                longest_clue = clue\n\n    return longest_clue if max_length < 2**16 else \"-1\"\n"
    },
    {
        "number": 3588,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    C = int(input_list[0])\n    input_list = input_list[1:]\n    share_count = {}\n    for i in range(C):\n        K = int(input_list[0])\n        input_list = input_list[1:]\n        for j in range(K):\n            N, D = map(int, input_list[0].split())\n            input_list = input_list[1:]\n            if D not in share_count:\n                share_count[D] = N\n            else:\n                share_count[D] += N\n    result = sorted(share_count.items())\n    output = [str(share_count[i]) for i in range(1, 366)]\n    return ' '.join(output)\n"
    },
    {
        "number": 3589,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, R = map(int, stdin.split())\n    a = [0] * 9\n    for x in range(L, R+1):\n        digits = [int(d) for d in str(x)]\n        result = digits[0]\n        for d in digits[1:]:\n            result *= d\n        a[result-1] += 1\n    return ' '.join(map(str, a))"
    },
    {
        "number": 3590,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def is_inside(p, A):\n        return all(cross_product(p, p1, p2) < 0 for p1, p2 in zip(A, A[1:] + A[:1]))\n\n    def min_cost(A, B):\n        def cut(A, B, p):\n            p1, p2 = p, p\n            for i, (x, y) in enumerate(A):\n                if cross_product(p, (x, y), p2) < 0:\n                    p1, p2 = i, p2\n            return p1, p2\n\n        p1, p2 = cut(A, B, A[0])\n        A_left, A_right = A[:p1], A[p1:]\n        B_left, B_right = B[:p2], B[p2:]\n        cost = 0\n        while not is_inside(B_left[0], A_left):\n            p1, p2 = cut(A_left, B_left, A_left[0])\n            A_left, A_right = A_left[:p1], A_left[p1:]\n            B_left, B_right = B_left[:p2], B_left[p2:]\n            cost += len(A_left)\n        return cost\n\n    def main(stdin: str) -> str:\n        A_n, B_n = map(int, stdin.split())\n        A = [tuple(map(int, input().split())) for _ in range(A_n)]\n        B = [tuple(map(int, input().split())) for _ in range(B_n)]\n        return f\"{min_cost(A, B):.6f}\"\n\n    return main(stdin)"
    },
    {
        "number": 3591,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    k = int(input_list[0])\n    result = []\n\n    for i in range(1, k + 1):\n        n = int(input_list[i * 2 - 1])\n        heights = list(map(int, input_list[i * 2].split()))\n        heights.sort()\n\n        left_height = heights[0]\n        right_height = heights[-1]\n\n        if left_height < right_height:\n            result.append(i)\n\n    output = str(len(result)) + '\\n'\n    for i in result:\n        output += str(i) + '\\n'\n\n    return output\n"
    },
    {
        "number": 3592,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p_t, p_1, p_2 = map(float, stdin.split())\n    p_t = round(p_t, 2)\n    p_1 = round(p_1, 2)\n    p_2 = round(p_2, 2)\n\n    pita_sales = int(p_t / p_1)\n    pizza_sales = int(p_t / p_2)\n\n    if pita_sales <= pizza_sales:\n        print(pita_sales, pizza_sales)\n    else:\n        print(pizza_sales, pita_sales)\n"
    },
    {
        "number": 3593,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    board = [[0 for _ in range(3)] for _ in range(N)]\n    for i in range(N):\n        board[i] = list(map(int, input_list[i+1].split()))\n\n    def is_valid(domino, row, col):\n        if col < 0 or col > 2:\n            return False\n        if row < 0 or row > N-1:\n            return False\n        if board[row][col] != 0:\n            return False\n        if col == 0:\n            if board[row][col+1] != 0:\n                return False\n        elif col == 1:\n            if board[row][col-1] != 0 or board[row][col+1] != 0:\n                return False\n        else:\n            if board[row][col-1] != 0:\n                return False\n        return True\n\n    def cover_domino(domino, row, col):\n        if col == 0:\n            board[row][col+1] = domino\n        elif col == 1:\n            board[row][col-1] = domino\n            board[row][col+1] = domino\n        else:\n            board[row][col-1] = domino\n\n    def backtrack(dominoes, row, col):\n        if len(dominoes) == 0:\n            return sum(board[i][0] + board[i][1] + board[i][2] for i in range(N))\n        for i in range(row, N):\n            for j in range(3):\n                if is_valid(dominoes[0], i, j):\n                    cover_domino(dominoes[0], i, j)\n                    result = backtrack(dominoes[1:], i+1, 0)\n                    if result != -1:\n                        return result\n                    cover_domino(dominoes[0], i, j)\n        return -1\n\n    result = backtrack([1, 2] for _ in range(K))\n    return str(result)\n"
    },
    {
        "number": 3594,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    scores = {'O': 0, 'E': 0, 'I': 0}\n    for i in range(1, n+1):\n        player, num = stdin.split('\\n')[i].split()\n        num = int(num)\n        if num == 1:\n            scores[player] += 1\n        else:\n            for j in range(2, num+1):\n                if is_prime(j):\n                    continue\n                else:\n                    break\n            scores[player] += min(num, j)\n    return f\"{scores['O']} {scores['E']} {scores['I']}\"\n\ndef"
    },
    {
        "number": 3595,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, l = map(int, input_list[0].split())\n    rooms = []\n    for i in range(1, r + 1):\n        x1, y1, x2, y2 = map(int, input_list[i].split())\n        rooms.append((x1, y1, x2, y2))\n\n    def is_hit(x, y, rooms):\n        for room in rooms:\n            if x >= room[0] and x <= room[2] and y >= room[1] and y <= room[3]:\n                return True\n        return False\n\n    def count_hits(x, y, angle, rooms):\n        hits = 0\n        dx, dy = 1, 0\n        if angle == 0:\n            dx, dy = 0, 1\n        elif angle == 90:\n            dx, dy = -1, 0\n        elif angle == 180:\n            dx, dy = 0, -1\n        elif angle == 270:\n            dx, dy = 1, 0\n\n        while is_hit(x + dx, y + dy, rooms):\n            hits += 1\n            x += dx\n            y += dy\n\n        return hits\n\n    max_hits = 0\n    for i in range(r):\n        for j in range(i + 1, r):\n            x1, y1, x2, y2 = rooms[i]\n            x3, y3, x4, y4 = rooms[j]\n            if x2 < x3 or y2 < y3 or x4 < x1 or y4 < y1:\n                continue\n\n            dx = x2 - x1\n            dy = y2 - y1\n            angle = 0\n            if dx == 0:\n                angle = 90\n            elif dy == 0:\n                angle = 0\n            elif dx < 0:\n                angle = 180\n            else:\n                angle = 270\n\n            hits = count_hits(x1, y1, angle, rooms)\n            if hits > max_hits:\n                max_hits = hits\n\n    return str(max_hits)"
    },
    {
        "number": 3596,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gamma(z: float) -> float:\n        return math.gamma(z)\n\n    def erf(x: float) -> float:\n        return math.erf(x)\n\n    def j_k(x: float, k: int) -> float:\n        return sum([math.cos(k * tau - x * math.sin(tau)) * math.exp(-(k * tau - x * math.sin(tau)) ** 2) * math.exp(-(tau - math.pi / 2) ** 2) for tau in np.linspace(0, math.pi, 1000)]) * math.pi\n\n    def f(x: float) -> float:\n        return c * math.gamma(x) + math.sqrt(math.log(erf(x))) - j_k(x) ** t_4\n\n    def p(x: float, r: int) -> float:\n        return sum([f(i) * x ** i for i in range(r + 1)])\n\n    def p_n(x: float, n: int, r: int) -> float:\n        return sum([p(i, r) * x ** i for i in range(r + n + 1)])\n\n    def g(x: float, n: int, k: int, r: int, s: int, l: int) -> float:\n        return (p_n(n, r, s) + l) ** 2 / (math.pi * math.e) + 1 / (l + 1)\n\n    a, b, c = map(float, stdin.split()[:3])\n    t1, t2, t3, t4 = map(int, stdin.split()[3:7])\n    n, k, r, s, l = map(int, stdin.split()[7:])\n\n    return f\"{g(n, k, r, s, l):.2f}\""
    },
    {
        "number": 3597,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, l, r, x1, y1, x2, y2, x3, y3, h = map(int, stdin.split())\n    # Check if the balls can fit on the table\n    if w < 2 * r or l < 2 * r:\n        return \"impossible\"\n    # Check if the balls can fit on the table\n    if w < 2 * r or l < 2 * r:\n        return \"impossible\"\n    # Check if the cue ball can fit on the table\n    if h < 2 * r:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2 + r > l or x3 + r > w or y3 + r > l:\n        return \"impossible\"\n    # Check if the balls can be placed on the table\n    if x1 + r > w or y1 + r > l or x2 + r > w or y2"
    },
    {
        "number": 3598,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    magnets = stdin.splitlines()[1:]\n    digits = set(range(10))\n    min_price = float('inf')\n    min_magnets = []\n\n    def is_valid(magnets):\n        for magnet in magnets:\n            if not set(magnet) <= digits:\n                return False\n        return True\n\n    def price(magnets):\n        price = 0\n        for magnet in magnets:\n            price = price * 10 + int(magnet)\n        return price\n\n    def turn_magnet(magnet):\n        return ''.join(str(9 - int(d)) if d != '0' else '0' for d in magnet)\n\n    for i in range(1, n + 1):\n        for j in range(i):\n            for k in range(n - i + j):\n                magnets_i = magnets[:i]\n                magnets_j = magnets[i:i + j]\n                magnets_k = magnets[i + j:]\n                if is_valid(magnets_i) and is_valid(magnets_j) and is_valid(magnets_k):\n                    price_i = price(magnets_i)\n                    price_j = price(magnets_j)\n                    price_k = price(magnets_k)\n                    price_i_turned = price(tuple(turn_magnet(magnet) for magnet in magnets_i))\n                    price_j_turned = price(tuple(turn_magnet(magnet) for magnet in magnets_j))\n                    price_k_turned = price(tuple(turn_magnet(magnet) for magnet in magnets_k))\n                    price_turned = price_i_turned + price_j_turned + price_k_turned\n                    if price_turned < min_price:\n                        min_price = price_turned\n                        min_magnets = (magnets_i, magnets_j, magnets_k)\n\n    return str(min_price)\n"
    },
    {
        "number": 3599,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, N = map(int, stdin.split()[0:2])\n    breaks = list(map(int, stdin.split()[2:]))\n\n    # Initialize the stage time for each musician\n    stage_time = [0] * N\n\n    # Sort the breaks in ascending order\n    breaks.sort()\n\n    # Iterate through the breaks and assign the stage time\n    for i in range(N):\n        # Find the index of the next break that is not already on stage\n        next_break_index = breaks.index(breaks[i])\n\n        # If there are no more breaks, assign the remaining time to the last musician\n        if next_break_index == N - 1:\n            stage_time[N - 1] = T - sum(stage_time)\n            break\n\n        # Calculate the time until the next break\n        time_until_next_break = breaks[next_break_index + 1] - breaks[next_break_index]\n\n        # Assign the time until the next break to the current musician\n        stage_time[i] = time_until_next_break\n\n    # Output the stage time for each musician\n    return ' '.join(map(str, stage_time))"
    },
    {
        "number": 3600,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.splitlines()[0].split())\n    intersections = [[] for _ in range(n)]\n    for i in range(1, n+1):\n        d, *neighbours = map(int, stdin.splitlines()[i].split())\n        intersections[i-1] = neighbours\n\n    def dfs(drone_count, current_intersection, visited):\n        if drone_count == k:\n            return True\n        if drone_count > k or current_intersection in visited:\n            return False\n        visited.add(current_intersection)\n        for neighbour in intersections[current_intersection-1]:\n            if dfs(drone_count+1, neighbour, visited):\n                return True\n        return False\n\n    return \"possible\" if dfs(0, 1, set()) else \"impossible\"\n"
    },
    {
        "number": 3601,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5\n\n    def min_time(misha_path, nadia_path):\n        misha_start, misha_end = misha_path[0], misha_path[-1]\n        nadia_start, nadia_end = nadia_path[0], nadia_path[-1]\n\n        misha_time = distance(misha_start[0], misha_start[1], misha_end[0], misha_end[1])\n        nadia_time = distance(nadia_start[0], nadia_start[1], nadia_end[0], nadia_end[1])\n\n        return max(misha_time, nadia_time)\n\n    def parse_path(path_description):\n        n = int(path_description[0])\n        path = [(int(x), int(y)) for x, y in path_description[1:]]\n        return path\n\n    misha_path_description, nadia_path_description = stdin.split(\"\\n\")\n    misha_path = parse_path(misha_path_description)\n    nadia_path = parse_path(nadia_path_description)\n\n    if misha_path[-1] == nadia_path[-1]:\n        return \"0.00000\"\n\n    misha_time = min_time(misha_path, nadia_path)\n    nadia_time = min_time(nadia_path, misha_path)\n\n    if misha_time == nadia_time:\n        return f\"{misha_time:.5f}\"\n    else:\n        return \"impossible\"\n"
    },
    {
        "number": 3602,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, r, k = map(int, input_list[0].split())\n    lamps = [tuple(map(int, input_list[i].split())) for i in range(1, k+1)]\n\n    def is_valid(i, j, lamp_i, lamp_j):\n        row_dist = abs(i - lamp_i)\n        col_dist = abs(j - lamp_j)\n        return row_dist + col_dist <= r\n\n    def is_lit(i, j):\n        for lamp_i, lamp_j in lamps:\n            if is_valid(i, j, lamp_i, lamp_j):\n                return True\n        return False\n\n    for i in range(1, n+1):\n        for j in range(1, n+1):\n            if not is_lit(i, j):\n                return \"0\"\n    return \"1\""
    },
    {
        "number": 3603,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, M = map(int, input_list[0].split())\n    translators = [set(map(int, input_list[i+1].split())) for i in range(M)]\n\n    def is_possible(translators, pairs):\n        languages = set()\n        for pair in pairs:\n            languages.update(pair)\n        if len(languages) == N:\n            return True\n        for pair in pairs:\n            if translators[pair[0]].isdisjoint(translators[pair[1]]):\n                return False\n        return True\n\n    def backtrack(translators, pairs, used):\n        if len(pairs) == M/2:\n            return pairs\n        for i in range(N):\n            if i not in used:\n                for j in range(i+1, N):\n                    if j not in used:\n                        if translators[i].isdisjoint(translators[j]):\n                            new_pairs = pairs + [(i, j)]\n                            new_used = used | {i, j}\n                            if is_possible(translators, new_pairs):\n                                result = backtrack(translators, new_pairs, new_used)\n                                if result:\n                                    return result\n        return None\n\n    pairs = backtrack(translators, [], set())\n    if pairs:\n        return '\\n'.join(f\"{p[0]} {p[1]}\" for p in pairs)\n    else:\n        return \"impossible\""
    },
    {
        "number": 3604,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def find_subset(sensors, d):\n        subset = []\n        visited = set()\n        for i in range(len(sensors)):\n            if i in visited:\n                continue\n            subset.append(i)\n            visited.add(i)\n            for j in range(i + 1, len(sensors)):\n                if j in visited:\n                    continue\n                if distance(sensors[i], sensors[j]) <= d:\n                    subset.append(j)\n                    visited.add(j)\n        return subset\n\n    n, d = map(int, stdin.split()[:2])\n    sensors = [tuple(map(int, stdin.split()[i:i + 2])) for i in range(2, 2 * n + 1, 2)]\n    subset = find_subset(sensors, d)\n    print(len(subset))\n    print(\" \".join(map(str, subset)))\n"
    },
    {
        "number": 3605,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, k = map(int, input_list[0].split())\n    tree_heights = list(map(int, input_list[1].split()))\n\n    # Sort the tree heights in ascending order\n    tree_heights.sort()\n\n    # Initialize variables to store the minimum and maximum heights\n    min_height = tree_heights[0]\n    max_height = tree_heights[0]\n\n    # Iterate through the sorted tree heights\n    for height in tree_heights:\n        # Update the minimum and maximum heights\n        min_height = min(min_height, height)\n        max_height = max(max_height, height)\n\n        # If the current height is greater than the maximum height, update the maximum height\n        if height > max_height:\n            max_height = height\n\n        # If the current height is greater than the minimum height and the difference between the minimum and maximum heights is less than the desired difference, return the difference\n        if height > min_height and max_height - min_height < k:\n            return max_height - min_height\n\n    # If no contiguous subrange of k trees has a height difference less than k, return k\n    return k"
    },
    {
        "number": 3606,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, K = map(int, input_list[0].split())\n    directions = input_list[1]\n    plants = [tuple(map(int, input_list[i+2].split())) for i in range(N)]\n\n    x, y = plants[0]\n    for i in range(K):\n        if directions[i] == 'A':\n            x += 1\n        elif directions[i] == 'B':\n            y += 1\n        elif directions[i] == 'C':\n            x -= 1\n        elif directions[i] == 'D':\n            y -= 1\n\n    return f\"{x} {y}\""
    },
    {
        "number": 3607,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    variables = {}\n    for line in lines:\n        if not line:\n            continue\n        label, command, *args = line.split()\n        label = int(label)\n        if command == 'LET':\n            var, value = args\n            variables[var] = int(value)\n        elif command == 'IF':\n            condition, label = args\n            if eval(condition, variables):\n                label = int(label)\n                lines[label - 1] = f\"{label} {' '.join(lines[label - 1].split()[1:])}\"\n        elif command == 'PRINT':\n            print(args[0].strip('\"'))\n        elif command == 'PRINTLN':\n            print(args[0].strip('\"'))\n    return '\\n'.join(lines)\n\nstdin = '''\n10 LET A = 1\n20 PRINT \"HELLO THERE \"\n30 PRINTLN A\n40 LET A = A + 1\n50 IF A <= 5 THEN GOTO 20\n60 PRINTLN \"DONE\"\n'''\n\nprint(solution(stdin))\n"
    },
    {
        "number": 3608,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    difficulties = [int(x) for x in stdin.split('\\n')[1].split()]\n    consecutive_difficulties = [int(x) for x in stdin.split('\\n')[2].split()]\n\n    MOD = 1000000007\n    ways = 1\n\n    for i in range(1, N):\n        ways = (ways * (difficulties[i] + consecutive_difficulties[i-1])) % MOD\n\n    return str(ways)\n"
    },
    {
        "number": 3609,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Check if the edges can be the union of two trees\n    for i in range(n - 1):\n        if edges[i][1] - edges[i][0] != 1:\n            return \"impossible\"\n\n    # Assign edges to the left and right trees\n    left_edges = []\n    right_edges = []\n    for i in range(n - 1):\n        if edges[i][0] == 1:\n            left_edges.append(edges[i])\n        elif edges[i][1] == n:\n            right_edges.append(edges[i])\n\n    # Check if the left and right trees can be connected\n    for i in range(n - 1):\n        if left_edges[i][1] != right_edges[i][0]:\n            return \"impossible\"\n\n    # Assign the edges to the left and right trees\n    result = \"L\" * (n - 1)\n    for i in range(n - 1):\n        if left_edges[i][1] == right_edges[i][0]:\n            result = result[:i] + \"R\" + result[i + 1:]\n        else:\n            return \"impossible\"\n\n    return result"
    },
    {
        "number": 3610,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_employee_id(id: int) -> bool:\n        return 1000 <= id <= 1999 or 2000 <= id <= 2999\n\n    def get_city(id: int) -> str:\n        if 1000 <= id <= 1999:\n            return \"Stockholm\"\n        elif 2000 <= id <= 2999:\n            return \"London\"\n        else:\n            raise ValueError(\"Invalid employee ID\")\n\n    def get_opposite_city(city: str) -> str:\n        if city == \"Stockholm\":\n            return \"London\"\n        elif city == \"London\":\n            return \"Stockholm\"\n        else:\n            raise ValueError(\"Invalid city\")\n\n    def get_opposite_city_employee_id(id: int) -> int:\n        if 1000 <= id <= 1999:\n            return id + 1000\n        elif 2000 <= id <= 2999:\n            return id - 1000\n        else:\n            raise ValueError(\"Invalid employee ID\")\n\n    def get_opposite_city_employee_ids(ids: List[int]) -> List[int]:\n        return [get_opposite_city_employee_id(id) for id in ids]\n\n    def get_teams(n: int, teams: List[List[int]]) -> List[Tuple[str, str]]:\n        return [(get_city(team[0]), get_city(team[1])) for team in teams]\n\n    def get_invitees(teams: List[Tuple[str, str]]) -> List[int]:\n        invitees = set()\n        for team in teams:\n            invitees.add(team[0])\n            invitees.add(team[1])\n        return list(invitees)\n\n    def get_smallest_invitees(teams: List[Tuple[str, str]], invitees: List[int]) -> List[int]:\n        smallest_invitees = []\n        for team in teams:\n            if team[0] not in smallest_invitees:\n                smallest_invitees.append(team[0])\n            if team[1] not in smallest_invitees:\n                smallest_invitees.append(team[1])\n        return smallest_invitees\n\n    def get_invite_list(teams: List[Tuple[str, str]], invitees: List[int]) -> List[int]:\n        invite_list = []\n        for team in teams:\n            if team[0] not in invite_list:\n                invite_list.append(team[0])\n            if team[1] not in invite_list:\n                invite_list.append(team[1])\n        return invite_list\n\n    def main(stdin: str) -> str:\n        n, *teams = stdin.split()\n        n = int(n)\n        teams = [list(map(int, team.split())) for team in teams]\n        teams = get_teams(n, teams)\n        invitees = get_invitees(teams)\n        smallest_invitees = get_smallest_invitees(teams, invitees)\n        invite_list = get_invite_list(teams, smallest_invitees)\n        k = len(invite_list)\n        invite_list.sort()\n        return f\"{k}\\n\" + \"\\n\".join(map(str, invite_list))\n\n    return main(stdin)"
    },
    {
        "number": 3611,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph: list, start: int, end: int) -> list:\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        prev = [-1] * n\n        while True:\n            u = -1\n            min_dist = float('inf')\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    u = i\n                    min_dist = dist[i]\n            if u == -1:\n                break\n            visited[u] = True\n            for v, w in graph[u]:\n                if not visited[v] and dist[u] + w < dist[v]:\n                    dist[v] = dist[u] + w\n                    prev[v] = u\n        return dist, prev\n\n    def shortest_path(graph: list, start: int, end: int, prev: list) -> list:\n        path = []\n        while end != -1:\n            path.append(end)\n            end = prev[end]\n        return path[::-1]\n\n    def find_intercept_stations(s: int, t: int, graph: list, dist: list) -> list:\n        intercept_stations = []\n        for u in range(len(graph)):\n            if u != s and u != t and dist[u] != float('inf'):\n                intercept_stations.append(u)\n        return intercept_stations\n\n    def find_intercept_paths(s: int, t: int, graph: list, dist: list, prev: list) -> list:\n        intercept_paths = []\n        for u in find_intercept_stations(s, t, graph, dist):\n            intercept_paths.append(shortest_path(graph, s, u, prev))\n        return intercept_paths\n\n    def find_common_paths(paths: list) -> list:\n        common_paths = []\n        for i in range(len(paths)):\n            for j in range(i + 1, len(paths)):\n                if paths[i] == paths[j]:\n                    common_paths.append(paths[i])\n        return common_paths\n\n    def find_intercept_station_numbers(s: int, t: int, graph: list, dist: list, prev: list) -> list:\n        intercept_paths = find_intercept_paths(s, t, graph, dist, prev)\n        common_paths = find_common_paths(intercept_paths)\n        intercept_station_numbers = [path[1] for path in common_paths]\n        return intercept_station_numbers\n\n    lines = stdin.split('\\n')\n    N, M = map(int, lines[0].split())\n    graph = [[] for _ in range(N)]\n    for i in range(1, M + 1):\n        u, v, w = map(int, lines[i].split())\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    s, t = map(int, lines[-1].split())\n\n    dist, prev = dijkstra(graph, s, t)\n    intercept_station_numbers = find_intercept_station_numbers(s, t, graph, dist, prev)\n    intercept_station_numbers.sort()\n    return ' '.join(map(str, intercept_station_numbers))\n"
    },
    {
        "number": 3612,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, m, W, H, X, Y = map(float, stdin.split()[:6])\n    H, W, X, Y = map(int, stdin.split()[6:10])\n    heights = [[int(h) for h in line.split()] for line in stdin.split('\\n')[1:H+1]]\n\n    def tide_height(t):\n        return 0.5 * a * (np.cos(t * 2 * np.pi / 12) + 1)\n\n    def is_dry(x, y):\n        if x < 0 or y < 0 or x >= W or y >= H:\n            return False\n        return heights[y][x] <= tide_height(0.0) + 1\n\n    def distance(x1, y1, x2, y2):\n        return np.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)\n\n    def walk(x, y, t):\n        if not is_dry(x, y):\n            return False\n        if distance(x, y, X, Y) <= 2 * tide_height(t) + 1:\n            return True\n        for dx, dy in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n            if walk(x + dx, y + dy, t):\n                return True\n        return False\n\n    t = 0.0\n    while t <= 12.0:\n        if walk(X, Y, t):\n            return distance(X, Y, W - 1, H - 1)\n        t += m / 3600.0\n\n    return \"0\""
    },
    {
        "number": 3613,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    kids = []\n    for i in range(1, N+1):\n        current_class = int(input_list[i].split()[0])\n        preference_list = [int(x) for x in input_list[i].split()[1:]]\n        kids.append((current_class, preference_list))\n\n    def is_valid(kids, T):\n        for i in range(N):\n            current_class = kids[i][0]\n            preference_list = kids[i][1]\n            for j in range(N):\n                if j != i and kids[j][0] == current_class and preference_list[j] <= preference_list[T]:\n                    return False\n        return True\n\n    low = 0\n    high = N\n    while low < high:\n        mid = (low + high) // 2\n        if is_valid(kids, mid):\n            low = mid + 1\n        else:\n            high = mid\n\n    return low - 1"
    },
    {
        "number": 3614,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, R, C = map(int, stdin.split())\n    petals = [list(map(int, stdin.split())) for _ in range(N)]\n    visited = set()\n    max_visited = 0\n\n    def dfs(r, c, prev_petals):\n        nonlocal max_visited\n        if (r, c) in visited:\n            return\n        visited.add((r, c))\n        max_visited = max(max_visited, len(visited))\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            new_r, new_c = r + dr, c + dc\n            if 0 <= new_r < N and 0 <= new_c < N and abs(dr) + abs(dc) >= 2 and petals[new_r][new_c] > prev_petals:\n                dfs(new_r, new_c, petals[new_r][new_c])\n\n    dfs(R - 1, C - 1, 0)\n    return max_visited\n"
    },
    {
        "number": 3615,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(p1, p2):\n        return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5\n\n    def is_connected(p1, p2, towers):\n        for tower in towers:\n            if distance(p1, tower) <= 1 and distance(p2, tower) <= 1:\n                return True\n        return False\n\n    n, *towers = stdin.split('\\n')\n    n = int(n)\n    towers = [tuple(map(float, tower.split())) for tower in towers]\n\n    max_towers = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_connected(towers[i], towers[j], towers):\n                max_towers += 1\n\n    return max_towers + 1\n"
    },
    {
        "number": 3616,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *D = map(int, stdin.split())\n    days = sum(D)\n    return str(days)\n"
    },
    {
        "number": 3617,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split()\n    N, T = map(int, input_list[:2])\n    A, B, C, t_0 = map(int, input_list[2:])\n    t_list = [t_0]\n    for i in range(1, N):\n        t_list.append((A * t_list[i-1] + B) % C + 1)\n    \n    max_problems = min(T // t_list[-1], N)\n    penalty = sum(t_list[:max_problems])\n    \n    return f\"{max_problems} {penalty % 1000000007}\""
    },
    {
        "number": 3618,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    count = 0\n    for i in range(1, 10**n):\n        for j in range(10**(n-1), 10**n):\n            if len(str(i)) == n and len(str(j)) == n:\n                count += 1\n    return str(count % 998244353)\n"
    },
    {
        "number": 3619,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_value(candidate: int) -> float:\n        return productivity[candidate] / salary[candidate]\n\n    def can_assign(candidate: int) -> bool:\n        recommender = recommender_map[candidate]\n        return recommender == 0 or recommender in team\n\n    def add_to_team(candidate: int) -> None:\n        team.add(candidate)\n        for i in range(n):\n            if recommender_map[i] in team:\n                value_map[i] = get_value(i)\n\n    def remove_from_team(candidate: int) -> None:\n        team.remove(candidate)\n        for i in range(n):\n            if recommender_map[i] in team:\n                value_map[i] = get_value(i)\n\n    def find_max_value() -> float:\n        max_value = 0\n        for candidate in team:\n            max_value = max(max_value, value_map[candidate])\n        return max_value\n\n    n, k = map(int, stdin.split()[0].split())\n    salary = list(map(int, stdin.split()[1:n + 1]))\n    productivity = list(map(int, stdin.split()[n + 1:2 * n + 1]))\n    recommender_map = list(map(int, stdin.split()[2 * n + 1:]))\n\n    team = set()\n    value_map = {}\n\n    for i in range(n):\n        if can_assign(i):\n            add_to_team(i)\n            if len(team) == k:\n                return round(find_max_value(), 3)\n            else:\n                remove_from_team(i)\n\n    return 0.001\n"
    },
    {
        "number": 3620,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, k, P = map(int, stdin.split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n\n    def dfs(node, col, visited, adj):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                if col[neighbor] == col[node]:\n                    return False\n                if not dfs(neighbor, col, visited, adj):\n                    return False\n        return True\n\n    def color(node, col, visited, adj):\n        visited[node] = True\n        for neighbor in adj[node]:\n            if not visited[neighbor]:\n                col[neighbor] = (col[node] + 1) % k\n                if not color(neighbor, col, visited, adj):\n                    return False\n        return True\n\n    adj = [[] for _ in range(N + 1)]\n    for u, v in edges:\n        adj[u].append(v)\n        adj[v].append(u)\n\n    count = 0\n    for root in range(1, N + 1):\n        visited = [False] * (N + 1)\n        col = [0] * (N + 1)\n        if dfs(root, col, visited, adj):\n            if color(root, col, visited, adj):\n                count += 1\n                count %= P\n\n    return str(count)\n"
    },
    {
        "number": 3621,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def f(S: set) -> int:\n        colors = set()\n        for x in S:\n            for y in S:\n                if x != y:\n                    colors.add(c[x][y])\n        return len(colors)\n\n    n = int(stdin.splitlines()[0])\n    c = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        row = list(map(int, stdin.splitlines()[i].split()))\n        for j in range(1, n + 1):\n            c[i][j] = row[j - 1]\n            c[j][i] = row[j - 1]\n\n    total = 0\n    for i in range(1, n + 1):\n        for S in itertools.combinations(range(1, n + 1), i):\n            total += f(set(S))\n\n    return str(total % (10**9 + 7))\n"
    },
    {
        "number": 3622,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    w, h = map(int, input_list[0].split())\n    u, d, l, r = map(int, input_list[1].split())\n    grid = input_list[2:]\n\n    # Calculate the probability of a ball hitting each target\n    target_probs = []\n    for row in grid:\n        for col in row:\n            if col == 'T':\n                target_probs.append(u * d * l * r)\n\n    # Normalize the probabilities\n    total_prob = sum(target_probs)\n    target_probs = [prob / total_prob for prob in target_probs]\n\n    # Round the probabilities to 6 decimal places\n    target_probs = [round(prob, 6) for prob in target_probs]\n\n    # Display the probabilities\n    result = '\\n'.join(str(prob) for prob in target_probs)\n    return result"
    },
    {
        "number": 3623,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(float, stdin.split())\n\n    # Calculate the area of the square\n    area = (a + b + c + d) * 2\n\n    # Calculate the area watered by each sprinkler\n    area_sprinkler_1 = (a * b) / 2\n    area_sprinkler_2 = (b * c) / 2\n    area_sprinkler_3 = (c * d) / 2\n    area_sprinkler_4 = (d * a) / 2\n\n    # Calculate the total area watered by the sprinklers\n    area_watered = area_sprinkler_1 + area_sprinkler_2 + area_sprinkler_3 + area_sprinkler_4\n\n    # Calculate the proportion of the area watered by the sprinklers\n    proportion = area_watered / area\n\n    return proportion\n"
    },
    {
        "number": 3624,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_travel_time(u, v, d):\n        return d\n\n    def get_distance(u, v):\n        return abs(u - v)\n\n    def get_min_wait_time(n, m, u, v, d):\n        min_wait_time = float('inf')\n        for i in range(m):\n            if u == v:\n                continue\n            if u == 0 and v == n - 1:\n                continue\n            if v == 0 and u == n - 1:\n                continue\n            if get_distance(u, v) == 1:\n                continue\n            if get_distance(u, v) == 2:\n                continue\n            if get_distance(u, v) == 3:\n                continue\n            if get_distance(u, v) == 4:\n                continue\n            if get_distance(u, v) == 5:\n                continue\n            if get_distance(u, v) == 6:\n                continue\n            if get_distance(u, v) == 7:\n                continue\n            if get_distance(u, v) == 8:\n                continue\n            if get_distance(u, v) == 9:\n                continue\n            if get_distance(u, v) == 10:\n                continue\n            if get_distance(u, v) == 11:\n                continue\n            if get_distance(u, v) == 12:\n                continue\n            travel_time = get_travel_time(u, v, d)\n            min_wait_time = min(min_wait_time, travel_time)\n        return min_wait_time\n\n    def get_min_wait_time_dr_knight(n, m, u, v, d):\n        min_wait_time = float('inf')\n        for i in range(m):\n            if u == v:\n                continue\n            if u == 0 and v == n - 1:\n                continue\n            if v == 0 and u == n - 1:\n                continue\n            if get_distance(u, v) == 1:\n                continue\n            if get_distance(u, v) == 2:\n                continue\n            if get_distance(u, v) == 3:\n                continue\n            if get_distance(u, v) == 4:\n                continue\n            if get_distance(u, v) == 5:\n                continue\n            if get_distance(u, v) == 6:\n                continue\n            if get_distance(u, v) == 7:\n                continue\n            if get_distance(u, v) == 8:\n                continue\n            if get_distance(u, v) == 9:\n                continue\n            if get_distance(u, v) == 10:\n                continue\n            if get_distance(u, v) == 11:\n                continue\n            if get_distance(u, v) == 12:\n                continue\n            travel_time = get_travel_time(u, v, d)\n            min_wait_time = min(min_wait_time, travel_time)\n        return min_wait_time\n\n    n, m = map(int, stdin.split()[:2])\n    u, v, d = map(int, stdin.split()[2:5])\n    min_wait_time_dr_knight = get_min_wait_time_dr_knight(n, m, u, v, d)\n    min_wait_time_std = get_min_wait_time(n, m, u, v, d)\n    return min_wait_time_dr_knight\n"
    },
    {
        "number": 3625,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def get_max_harvest(species: list) -> int:\n        max_harvest = 0\n        for s in species:\n            harvest = s[0]\n            for i in range(s[1]):\n                harvest += s[2]\n            max_harvest = max(max_harvest, harvest)\n        return max_harvest\n\n    N = int(stdin.splitlines()[0])\n    species = []\n    for i in range(1, N + 1):\n        s = list(map(int, stdin.splitlines()[i].split()))\n        species.append(s)\n\n    max_harvest = get_max_harvest(species)\n    return str(max_harvest)\n"
    },
    {
        "number": 3626,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    rectangles = []\n    for i in range(1, n+1):\n        x1, y1, x2, y2 = map(int, input_list[i].split())\n        rectangles.append((x1, y1, x2, y2))\n\n    for i in range(n):\n        for j in range(i+1, n):\n            if intersect(rectangles[i], rectangles[j]):\n                return \"1\"\n    return \"0\"\n\ndef"
    },
    {
        "number": 3627,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split()[0].split(','))\n    cliff = stdin.split('\\n')[1].split()\n    energy = [list(map(int, stdin.split('\\n')[i].split())) for i in range(2, 2+R)]\n    start = stdin.split('\\n')[-1].split()\n\n    def get_energy(x, y):\n        if 0 <= x < R and 0 <= y < C:\n            return energy[x][y]\n        return 0\n\n    def get_min_energy(x, y, visited):\n        if (x, y) in visited:\n            return float('inf')\n        visited.add((x, y))\n        up = get_min_energy(x-1, y, visited) + get_energy(x-1, y)\n        down = get_min_energy(x+1, y, visited) + get_energy(x+1, y)\n        left = get_min_energy(x, y-1, visited) + get_energy(x, y-1)\n        right = get_min_energy(x, y+1, visited) + get_energy(x, y+1)\n        return min(up, down, left, right)\n\n    min_energy = float('inf')\n    for s in start:\n        x, y = s.index('S'), start.index(s)\n        visited = set()\n        min_energy = min(min_energy, get_min_energy(x, y, visited))\n\n    return min_energy"
    },
    {
        "number": 3628,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    for pi in itertools.permutations(range(1, n + 1)):\n        for sigma in itertools.permutations(range(1, n + 1)):\n            if all(a[i] == (pi[i] + sigma[i]) % n for i in range(n)):\n                return \" \".join(map(str, pi)) + \"\\n\" + \" \".join(map(str, sigma))\n\n    return \"impossible\"\n"
    },
    {
        "number": 3629,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def overlap(x1, y1, r1, x2, y2, r2):\n        return distance(x1, y1, x2, y2) <= r1 + r2\n\n    def boar_charge(x, y, b, d):\n        angle = random.uniform(0, 2 * math.pi)\n        return x + d * math.cos(angle), y + d * math.sin(angle)\n\n    n, b, d = map(int, stdin.split()[-3:])\n    trees = []\n    for _ in range(n):\n        x, y, r = map(int, stdin.split()[:3])\n        trees.append((x, y, r))\n\n    p = 1\n    for _ in range(d):\n        x, y = boar_charge(0, 0, b, 1)\n        for tx, ty, tr in trees:\n            if overlap(x, y, b, tx, ty, tr):\n                p = 0\n                break\n        if p == 0:\n            break\n\n    return p"
    },
    {
        "number": 3630,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s1, s2 = stdin.split()\n    n = len(s1)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if s1[i] == s2[j]:\n                dp[i][j] = 0\n            else:\n                dp[i][j] = float('inf')\n                for k in range(i+1):\n                    for l in range(j+1):\n                        if s1[k:i+1] == s2[l:j+1]:\n                            dp[i][j] = min(dp[i][j], dp[k-1][l-1] + 1)\n                if i > 0 and s1[i] == 'z':\n                    dp[i][j] = float('inf')\n                if j > 0 and s2[j] == 'a':\n                    dp[i][j] = float('inf')\n    return dp[n-1][n-1]"
    },
    {
        "number": 3631,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2) ** 0.5\n\n    def is_visible(a, b, peaks):\n        for peak in peaks:\n            if distance(a, peak) <= peak[2] and distance(b, peak) <= peak[2]:\n                return False\n        return True\n\n    def count_messages(beacons, peaks):\n        count = 0\n        for i in range(len(beacons)):\n            for j in range(i + 1, len(beacons)):\n                if is_visible(beacons[i], beacons[j], peaks):\n                    count += 1\n        return count\n\n    n, m = map(int, stdin.split()[:2])\n    beacons = [tuple(map(int, stdin.split()[2:4])) for _ in range(n)]\n    peaks = [tuple(map(int, stdin.split()[4:7])) for _ in range(m)]\n\n    return count_messages(beacons, peaks)\n"
    },
    {
        "number": 3632,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def factorial(n: int) -> int:\n        if n == 0:\n            return 1\n        return n * factorial(n - 1)\n\n    def count_composite_strings(n: int, k: int) -> int:\n        return factorial(n) // (factorial(k) * factorial(n - k))\n\n    def sort_composite_strings(n: int, k: int, strings: List[str]) -> List[str]:\n        def merge_sort(arr: List[str]) -> List[str]:\n            if len(arr) <= 1:\n                return arr\n            mid = len(arr) // 2\n            left = merge_sort(arr[:mid])\n            right = merge_sort(arr[mid:])\n            return merge(left, right)\n\n        def merge(left: List[str], right: List[str]) -> List[str]:\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] < right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result.extend(left[i:])\n            result.extend(right[j:])\n            return result\n\n        composite_strings = []\n        for i in range(len(strings)):\n            for j in range(i + 1, len(strings)):\n                composite_strings.append(strings[i] + strings[j])\n        return merge_sort(composite_strings)\n\n    def find_position(sorted_strings: List[str], test_string: str) -> int:\n        def binary_search(arr: List[str], target: str) -> int:\n            left, right = 0, len(arr) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if arr[mid] == target:\n                    return mid + 1\n                elif arr[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return left\n\n        return binary_search(sorted_strings, test_string)\n\n    n, k = map(int, stdin.split()[:2])\n    strings = [input() for _ in range(n)]\n    test_string = input()\n\n    sorted_strings = sort_composite_strings(n, k, strings)\n    position = find_position(sorted_strings, test_string)\n\n    return str(position % (10**9 + 7))\n"
    },
    {
        "number": 3633,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    def calculate_score(critic_scores):\n        return sum(critic_scores) / len(critic_scores)\n\n    def is_valid_order(critic_scores, order):\n        scores = [critic_scores[i - 1] for i in order]\n        return calculate_score(scores) == k / n\n\n    def find_critic_order(critic_scores):\n        for order in itertools.permutations(range(1, n + 1)):\n            if is_valid_order(critic_scores, order):\n                return order\n        return None\n\n    critic_scores = [a[i - 1] for i in range(1, n + 1)]\n    critic_scores[0] = m\n    order = find_critic_order(critic_scores)\n\n    if order is None:\n        return \"impossible\"\n    else:\n        return \" \".join(map(str, order))\n"
    },
    {
        "number": 3634,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def count_ways(n: int, left: int, right: int) -> int:\n        if left > right:\n            return 0\n        if left == 0:\n            return 1\n        if left == 1:\n            return 1\n        if left == right:\n            return 1\n        if left == right - 1:\n            return 1\n        if left == right - 2:\n            return 2\n        if left == right - 3:\n            return 3\n        if left == right - 4:\n            return 5\n        if left == right - 5:\n            return 8\n        if left == right - 6:\n            return 13\n        if left == right - 7:\n            return 21\n        if left == right - 8:\n            return 34\n        if left == right - 9:\n            return 55\n        if left == right - 10:\n            return 89\n        if left == right - 11:\n            return 144\n        if left == right - 12:\n            return 233\n        if left == right - 13:\n            return 377\n        if left == right - 14:\n            return 610\n        if left == right - 15:\n            return 987\n        if left == right - 16:\n            return 1597\n        if left == right - 17:\n            return 2584\n        if left == right - 18:\n            return 4181\n        if left == right - 19:\n            return 6765\n        if left == right - 20:\n            return 10946\n        if left == right - 21:\n            return 17711\n        if left == right - 22:\n            return 28657\n        if left == right - 23:\n            return 46368\n        if left == right - 24:\n            return 75025\n        if left == right - 25:\n            return 121393\n        if left == right - 26:\n            return 196418\n        if left == right - 27:\n            return 317811\n        if left == right - 28:\n            return 514229\n        if left == right - 29:\n            return 832040\n        if left == right - 30:\n            return 1352121\n        if left == right - 31:\n            return 2189229\n        if left == right - 32:\n            return 3542248\n        if left == right - 33:\n            return 5702469\n        if left == right - 34:\n            return 9227465\n        if left == right - 35:\n            return 14930352\n        if left == right - 36:\n            return 24157817\n        if left == right - 37:\n            return 39088169\n        if left == right - 38:\n            return 63245986\n        if left == right - 39:\n            return 102334155\n        if left == right - 40:\n            return 165580141\n        if left == right - 41:\n            return 267914296\n        if left == right - 42:\n            return 433494437\n        if left == right - 43:\n            return 701408733\n        if left == right - 44:\n            return 1134903170\n        if left == right - 45:\n            return 1859152754\n        if left == right - 46:\n            return 3051811744\n        if left == right - 47:\n            return 5055171483\n        "
    },
    {
        "number": 3635,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *bananas = map(int, stdin.split())\n    bananas = sorted(enumerate(bananas), key=lambda x: x[1])\n    total_bananas = sum(bananas[-1][1])\n    executives = 1\n    while executives < N and total_bananas >= sum(bananas[-executives-1][1]):\n        executives += 1\n    return executives"
    },
    {
        "number": 3636,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, p = map(int, stdin.split())\n    count = 0\n\n    for i in range(n - 2):\n        for j in range(m - 2):\n            if all(grid[i + x][j + y] == 1 for x in range(2) for y in range(2)):\n                count += 1\n\n    return str(count % p)\n"
    },
    {
        "number": 3637,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    num_friends = int(input_data[0])\n    input_data = input_data[1:]\n    toppings = set()\n    for line in input_data:\n        wishes = line.split()\n        for wish in wishes:\n            if wish[0] == '+':\n                toppings.add(wish[1:])\n            elif wish[0] == '-':\n                toppings.discard(wish[1:])\n    return ' '.join(toppings)"
    },
    {
        "number": 3638,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split()[0:2])\n    predictions = stdin.split(\"\\n\")[2:]\n\n    # Calculate the probability of each prediction\n    probabilities = []\n    for prediction in predictions:\n        probability = 1\n        for i in range(len(prediction)):\n            if i == 0:\n                probability *= 1 / 3\n            else:\n                probability *= 2 / 3\n        probabilities.append(probability)\n\n    # Sort the predictions by probability\n    sorted_predictions = sorted(zip(predictions, probabilities), key=lambda x: x[1], reverse=True)\n\n    # Print the sorted predictions\n    for prediction, probability in sorted_predictions:\n        print(prediction)\n"
    },
    {
        "number": 3639,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T, c, d = map(float, input().split())\n    rain = [int(input()) for _ in range(T)]\n\n    def sweat(v):\n        return c * v ** 2\n\n    def wetness(v, i):\n        return rain[i] + sweat(v)\n\n    def dry_at(v, t):\n        return wetness(v, t) - sweat(v)\n\n    def best_speed(t):\n        v_min = 0\n        v_max = 50 / d\n        while v_max - v_min > 1e-6:\n            v = (v_min + v_max) / 2\n            if dry_at(v, t) > 0:\n                v_min = v\n            else:\n                v_max = v\n        return v_min\n\n    v = best_speed(T)\n    wet = sum(wetness(v, i) for i in range(T))\n    return f\"{wet:.6f}\"\n\ninput_data = \"\"\"5\n0.1 2.0\n0\n0\n0\n0\n0\"\"\"\n\nprint(solution(input_data)) "
    },
    {
        "number": 3640,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subsequence(s1: str, s2: str) -> bool:\n        i = 0\n        for char in s2:\n            if char == s1[i]:\n                i += 1\n                if i == len(s1):\n                    return True\n        return False\n\n    def meow_factor(s: str) -> int:\n        operations = [\n            lambda s: s[:i] + 'a' + s[i:],  # Insert 'a'\n            lambda s: s[:i] + s[i+1:],  # Delete 'a'\n            lambda s: s[:i] + 'b' + s[i+1:],  # Replace 'a' with 'b'\n            lambda s: s[:i] + s[i+1] + s[i] + s[i+2:],  # Swap 'a' with 'b'\n        ]\n\n        for i in range(len(s)):\n            for op in operations:\n                new_s = op(s)\n                if is_subsequence('meow', new_s):\n                    return 1\n        return 0\n\n    return str(meow_factor(stdin))\n"
    },
    {
        "number": 3641,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    k, n = map(int, input_list[0].split())\n    bead_weights = list(map(int, input_list[1].split()))\n\n    total_weight = sum(bead_weights)\n    if total_weight % k != 0:\n        return \"NO\"\n\n    gold_per_person = total_weight // k\n    total_gold = 0\n    for weight in bead_weights:\n        total_gold += weight\n        if total_gold > gold_per_person:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3642,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def reduce_fraction(numerator, denominator):\n        gcd_value = gcd(numerator, denominator)\n        return numerator // gcd_value, denominator // gcd_value\n\n    def find_minimal_magic_path(tree, magic):\n        def dfs(node, visited, magic_path):\n            if len(magic_path) == 0:\n                magic_path.append(magic[node])\n            for neighbor in tree[node]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    magic_path.append(magic[neighbor])\n                    dfs(neighbor, visited, magic_path)\n                    visited.remove(neighbor)\n                    magic_path.pop()\n\n        visited = set()\n        magic_path = []\n        dfs(1, visited, magic_path)\n        return magic_path\n\n    N, *edges, *magic = stdin.splitlines()\n    N = int(N)\n    magic = [int(x) for x in magic]\n    tree = {i: [] for i in range(1, N + 1)}\n    for a, b in [map(int, x.split()) for x in edges]:\n        tree[a].append(b)\n        tree[b].append(a)\n\n    magic_path = find_minimal_magic_path(tree, magic)\n    magic_path_length = len(magic_path)\n    magic_path_product = reduce(lambda x, y: x * y, magic_path)\n    magic_path_sum = sum(magic_path)\n    magic_path_magic = magic_path_product / magic_path_sum\n    numerator, denominator = magic_path_magic.as_integer_ratio()\n    numerator, denominator = reduce_fraction(numerator, denominator)\n\n    return f\"{numerator}/{denominator}\"\n"
    },
    {
        "number": 3643,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    salaries = []\n    for i in range(1, N+1):\n        L, R = map(float, stdin.split('\\n')[i].split())\n        salaries.append((L, R))\n\n    def expected_payment(salaries):\n        total_damages = 0\n        for i in range(1, N):\n            for j in range(i):\n                L1, R1 = salaries[j]\n                L2, R2 = salaries[i]\n                if L2 < L1 or R2 > R1:\n                    total_damages += abs(R1 - L2)\n        return total_damages\n\n    expected_payment_div_N_squared = expected_payment(salaries) / (N * N)\n    return f\"{expected_payment_div_N_squared:.6f}\""
    },
    {
        "number": 3644,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    f = [0] * n\n    h = [0] * n\n    for i in range(1, n + 1):\n        f[i - 1], h[i - 1] = map(int, input_list[i].split())\n\n    # Calculate the total number of workers needed\n    total_workers = sum(h) - sum(f)\n\n    # Calculate the number of HR people needed\n    k = max(total_workers, 1)\n\n    # Create a list to store the HR person in charge of each day\n    hr_list = [0] * n\n\n    # Fill the list with the HR person in charge of each day\n    for i in range(n):\n        if i == 0:\n            hr_list[i] = 1\n        else:\n            hr_list[i] = hr_list[i - 1] + 1\n            if hr_list[i] > k:\n                hr_list[i] = 1\n\n    # Convert the list to a string and return it\n    hr_string = ' '.join(map(str, hr_list))\n    return f\"{k}\\n{hr_string}\""
    },
    {
        "number": 3645,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, integers = map(int, stdin.split())\n    if n < 2 or n > 15000:\n        return \"none\"\n\n    # Check if there are any repeated integers\n    if len(set(integers)) < n:\n        return \"none\"\n\n    # Check if there are any consecutive integers\n    for i in range(n - 1):\n        if integers[i + 1] - integers[i] == 1:\n            return \"none\"\n\n    # Check if there are any integers that are too far apart\n    max_distance = 0\n    for i in range(n - 1):\n        distance = abs(integers[i + 1] - integers[i])\n        if distance > max_distance:\n            max_distance = distance\n\n    if max_distance > n // 2:\n        return \"none\"\n\n    # Find all possible integers that can be chosen\n    possible_integers = set()\n    for i in range(n):\n        for j in range(i + 1, n):\n            if integers[j] - integers[i] == 1:\n                possible_integers.add(integers[i])\n                possible_integers.add(integers[j])\n\n    # Check if there are any integers that can be chosen\n    if not possible_integers:\n        return \"none\"\n\n    # Output all possible integers\n    return \" \".join(map(str, sorted(possible_integers)))"
    },
    {
        "number": 3646,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    spots = list(map(int, input_list[1].split()))\n    max_distance = 0\n    for i in range(N):\n        for j in range(i+1, N):\n            if spots[i] + spots[j] == j - i:\n                max_distance = max(max_distance, j - i)\n    return str(max_distance)"
    },
    {
        "number": 3647,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    C, R = map(int, stdin.split()[0].split(','))\n    maze = [list(line.strip()) for line in stdin.split('\\n')[1:] if line.strip()]\n    goal = None\n    for i in range(R):\n        for j in range(C):\n            if maze[i][j] == 'M':\n                goal = (i, j)\n                break\n        if goal is not None:\n            break\n    if goal is None:\n        return '\\n'.join(['-1' * C] * R)\n\n    def get_moves(x, y):\n        moves = []\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C and maze[nx][ny] != '#':\n                moves.append((nx, ny))\n        return moves\n\n    def get_min_moves(x, y):\n        if (x, y) == goal:\n            return 0\n        if maze[x][y] == 'M':\n            return -1\n        if maze[x][y] == '.' or maze[x][y] == '_':\n            return 1\n        if maze[x][y] == '#':\n            return get_min_moves(x, y - 1) + 1\n\n    def dfs(x, y):\n        if (x, y) == goal:\n            return 0\n        if maze[x][y] == 'M':\n            return -1\n        if maze[x][y] == '.' or maze[x][y] == '_':\n            return 1\n        if maze[x][y] == '#':\n            return min(dfs(x, y - 1) + 1, dfs(x - 1, y) + 1, dfs(x + 1, y) + 1, dfs(x, y + 1) + 1)\n\n    result = []\n    for i in range(R):\n        row = []\n        for j in range(C):\n            row.append(str(dfs(i, j)))\n        result.append(' '.join(row))\n    return '\\n'.join(result)\n"
    },
    {
        "number": 3648,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        visited = set()\n        dist = {start: 0}\n        prev = {start: None}\n        queue = [(0, start)]\n\n        while queue:\n            (cost, node) = heapq.heappop(queue)\n            if node in visited:\n                continue\n            visited.add(node)\n\n            if node == end:\n                path = []\n                while prev[node] is not None:\n                    path.append(node)\n                    node = prev[node]\n                path.append(start)\n                return len(path) - 1\n\n            for neighbor, neighbor_cost in graph[node].items():\n                if neighbor not in visited:\n                    new_cost = cost + neighbor_cost\n                    if neighbor not in dist or new_cost < dist[neighbor]:\n                        dist[neighbor] = new_cost\n                        prev[neighbor] = node\n                        heapq.heappush(queue, (new_cost, neighbor))\n\n    def is_possible(graph, insecure_buildings):\n        for node in graph:\n            for neighbor, cost in graph[node].items():\n                if neighbor in insecure_buildings:\n                    return False\n        return True\n\n    def min_cost(graph, insecure_buildings):\n        if not is_possible(graph, insecure_buildings):\n            return \"impossible\"\n\n        min_cost = float(\"inf\")\n        for node in graph:\n            for neighbor, cost in graph[node].items():\n                if neighbor in insecure_buildings:\n                    continue\n                dist = dijkstra(graph, node, neighbor)\n                if dist < min_cost:\n                    min_cost = dist\n        return min_cost\n\n    n, m, p = map(int, stdin.split()[:3])\n    insecure_buildings = set(map(int, stdin.split()[3:]))\n    graph = {i: {} for i in range(1, n + 1)}\n\n    for _ in range(m):\n        x, y, cost = map(int, stdin.split()[4:7])\n        graph[x][y] = cost\n        graph[y][x] = cost\n\n    return str(min_cost(graph, insecure_buildings))"
    },
    {
        "number": 3649,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    if a + b + c + d > 1:\n        return \"impossible\"\n    elif a + b + c + d == 1:\n        if a == 1:\n            return \"10\"\n        elif b == 1:\n            return \"01\"\n        elif c == 1:\n            return \"11\"\n        else:\n            return \"00\"\n    else:\n        return \"0000\"\n"
    },
    {
        "number": 3650,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, B = map(int, stdin.split()[:3])\n    target_board = [list(map(int, stdin.split()[3+i*2:3+(i+1)*2])) for i in range(B)]\n    initial_board = [[0]*M for _ in range(N)]\n    initial_board[1][1] = 1\n\n    def is_possible(board, target_board):\n        visited = set()\n        def dfs(board, target_board, row, col, visited):\n            if (row, col) in visited:\n                return False\n            visited.add((row, col))\n            if board == target_board:\n                return True\n            for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                new_row, new_col = row + dr, col + dc\n                if 0 <= new_row < N and 0 <= new_col < M and board[new_row][new_col] == 0:\n                    board[new_row][new_col] = 1\n                    if dfs(board, target_board, new_row, new_col, visited):\n                        return True\n                    board[new_row][new_col] = 0\n            return False\n\n        return dfs(initial_board, target_board, 1, 1, visited)\n\n    if is_possible(initial_board, target_board):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3651,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(a, b):\n        return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5\n\n    def shortest_distance(planets, start):\n        visited = set()\n        min_distance = float('inf')\n        for i, planet in enumerate(planets):\n            if i == start:\n                continue\n            if i in visited:\n                continue\n            visited.add(i)\n            min_distance = min(min_distance, distance(planets[start], planet))\n            min_distance = min(min_distance, shortest_distance(planets, i))\n        return min_distance\n\n    n, *planets = stdin.split('\\n')\n    n = int(n)\n    planets = [tuple(map(int, planet.split())) for planet in planets]\n    start = 0\n    min_distance = shortest_distance(planets, start)\n    return f'{min_distance:.6f}'"
    },
    {
        "number": 3652,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    rows = [list(map(int, stdin.splitlines()[i].split())) for i in range(1, 4)]\n\n    # Find the minimum number of columns to delete\n    min_cols_to_delete = N\n    for i in range(N):\n        for j in range(N):\n            if rows[0][i] != rows[1][j] or rows[0][i] != rows[2][j]:\n                min_cols_to_delete = min(min_cols_to_delete, i + j + 1)\n                break\n\n    return str(min_cols_to_delete)"
    },
    {
        "number": 3653,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    L, x1, y1, x2, y2 = map(int, stdin.split())\n    chain_length = 0\n\n    # Calculate the length of the chain\n    chain_length = abs(x1 - x2) + abs(y1 - y2)\n\n    # Round up the chain length to the nearest meter\n    chain_length = (chain_length + 1) // 2\n\n    return str(chain_length)"
    },
    {
        "number": 3654,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, n = map(int, stdin.split())\n    if k == 1:\n        return n\n    else:\n        return 0\n\ninput_str = input()\nresult = solution(input_str)\nprint(result) "
    },
    {
        "number": 3655,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def read_image(input_str: str) -> List[List[int]]:\n        lines = input_str.split('\\n')\n        width, height = map(int, lines[0].split())\n        image = [list(map(int, line.split())) for line in lines[1:]]\n        return image\n\n    def compare_images(robot_image: List[List[int]], floor_image: List[List[int]]) -> List[Tuple[int, int]]:\n        candidates = []\n        for y in range(len(floor_image)):\n            for x in range(len(floor_image[0])):\n                if floor_image[y][x] == robot_image[y][x]:\n                    candidates.append((x, y))\n        return candidates\n\n    robot_image = read_image(stdin)\n    with open('floor_image.txt', 'r') as file:\n        floor_image = read_image(file.read())\n\n    candidates = compare_images(robot_image, floor_image)\n    candidates.sort(key=lambda x: (x[0], x[1]))\n\n    output = '\\n'.join(f'{x} {y}' for x, y in candidates)\n    return output\n"
    },
    {
        "number": 3656,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    B, T, f = map(float, input_data[0].split())\n    bugs = [list(map(float, line.split())) for line in input_data[1:]]\n\n    def fix_probability(bug, t):\n        return max(bug[0] * (1 - t * f), 0)\n\n    def severity(bug, t):\n        return bug[1] * fix_probability(bug, t)\n\n    def expected_severity(bugs, T):\n        return sum(severity(bug, T) for bug in bugs)\n\n    expected_value = expected_severity(bugs, T)\n    return f\"{expected_value:.6f}\""
    },
    {
        "number": 3657,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    W, v_h, N = map(int, stdin.split()[0:3])\n    gates = [tuple(map(int, stdin.split()[3*i+1:3*i+3])) for i in range(N)]\n    S = int(stdin.split()[3*N+1])\n    skis = [int(stdin.split()[3*N+2+i]) for i in range(S)]\n\n    def is_possible(s):\n        for i in range(N):\n            if gates[i][1] - gates[i][0] > s:\n                return False\n        return True\n\n    skis.sort(reverse=True)\n    for s in skis:\n        if is_possible(s):\n            return str(s)\n    return \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3658,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_data = stdin.split('\\n')\n    p, a = map(int, input_data[0].split())\n    pine_trees = [(float(x), float(y)) for x, y in [line.split() for line in input_data[1:p+1]]]\n    aspen_trees = [(float(x), float(y)) for x, y in [line.split() for line in input_data[p+1:]]]\n\n    def is_covered(x, y):\n        for i in range(p):\n            for j in range(i+1, p):\n                for k in range(j+1, p):\n                    if (x - pine_trees[i][0]) * (y - pine_trees[i][1]) == 0 and (x - pine_trees[j][0]) * (y - pine_trees[j][1]) == 0 and (x - pine_trees[k][0]) * (y - pine_trees[k][1]) == 0:\n                        return True\n        for i in range(a):\n            for j in range(i+1, a):\n                for k in range(j+1, a):\n                    if (x - aspen_trees[i][0]) * (y - aspen_trees[i][1]) == 0 and (x - aspen_trees[j][0]) * (y - aspen_trees[j][1]) == 0 and (x - aspen_trees[k][0]) * (y - aspen_trees[k][1]) == 0:\n                        return True\n        return False\n\n    covered_area = sum(is_covered(x, y) for x, y in pine_trees) + sum(is_covered(x, y) for x, y in aspen_trees)\n    return f\"{covered_area:.3f}\""
    },
    {
        "number": 3659,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def area(h, t):\n        return h * t\n\n    def partition(books):\n        books.sort(key=lambda x: x[0], reverse=True)\n        shelves = [[] for _ in range(3)]\n        for book in books:\n            max_shelf = max(shelves, key=lambda x: sum(x))\n            max_shelf.append(book)\n        return shelves\n\n    def bookcase_area(shelves):\n        heights = [max(books, key=lambda x: x[0])[0] for books in shelves]\n        widths = [sum(books, key=lambda x: x[1]) for books in shelves]\n        return max(widths) * sum(heights)\n\n    N, books = stdin.split(\"\\n\")\n    N = int(N)\n    books = [tuple(map(int, line.split())) for line in books]\n    shelves = partition(books)\n    return bookcase_area(shelves)\n"
    },
    {
        "number": 3660,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(message: str, stickers: dict) -> bool:\n        for i in range(len(message) - 1):\n            if message[i:i+2] in stickers and message[i+2:i+4] in stickers:\n                return False\n        return True\n\n    def min_cost(message: str, stickers: dict) -> int:\n        if not is_valid(message, stickers):\n            return \"IMPOSSIBLE\"\n\n        cost = 0\n        for i in range(len(message)):\n            if message[i:i+2] in stickers:\n                cost += stickers[message[i:i+2]]\n            elif message[i:i+1] in stickers:\n                cost += stickers[message[i:i+1]]\n\n        return cost\n\n    message, n = stdin.split(\"\\n\")\n    n = int(n)\n    stickers = {}\n\n    for _ in range(n):\n        word, price = stdin.split(\"\\n\")\n        stickers[word] = int(price)\n\n    return min_cost(message, stickers)\n"
    },
    {
        "number": 3661,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, S, L = map(int, stdin.split()[:3])\n    A = [int(x) for x in stdin.split()[3::2]]\n    B = [int(x) for x in stdin.split()[4::2]]\n\n    # Count the number of times each individual and corporation appears in the lawsuits\n    count_indv = [0] * (R + 1)\n    count_corp = [0] * (S + 1)\n    for i in range(L):\n        count_indv[A[i]] += 1\n        count_corp[B[i]] += 1\n\n    # Determine the party that should win the lawsuit\n    result = []\n    for i in range(L):\n        if count_indv[A[i]] < count_corp[B[i]]:\n            result.append(f\"INDV {A[i]}\")\n        else:\n            result.append(f\"CORP {B[i]}\")\n\n    return \"\\n\".join(result)"
    },
    {
        "number": 3662,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    L, W = map(int, input_list[1].split())\n    positions = list(map(int, input_list[2:]))\n\n    # Calculate the distance between each pair of trees\n    distances = []\n    for i in range(N - 1):\n        distances.append(abs(positions[i + 1] - positions[i]))\n\n    # Calculate the total distance to move the trees\n    total_distance = sum(distances)\n\n    # Calculate the minimum distance to move the trees\n    min_distance = total_distance\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            distance = abs(positions[i] - positions[j])\n            if distance < min_distance:\n                min_distance = distance\n\n    # Calculate the total distance to move the trees to their correct positions\n    correct_positions = [positions[0]]\n    for i in range(1, N):\n        correct_positions.append(correct_positions[-1] + min_distance)\n\n    # Calculate the total distance to move the trees to their correct positions\n    total_distance_correct = sum([abs(correct_positions[i] - positions[i]) for i in range(N)])\n\n    return f\"{total_distance_correct:.6f}\""
    },
    {
        "number": 3663,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dijkstra(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        while True:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            if min_node == end:\n                return dist[end]\n            visited[min_node] = True\n            for neighbor, weight in graph[min_node]:\n                if not visited[neighbor] and dist[min_node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[min_node] + weight\n\n    def min_cost(graph, start, end):\n        n = len(graph)\n        dist = [float('inf')] * n\n        dist[start] = 0\n        visited = [False] * n\n        while True:\n            min_dist = float('inf')\n            min_node = -1\n            for i in range(n):\n                if not visited[i] and dist[i] < min_dist:\n                    min_dist = dist[i]\n                    min_node = i\n            if min_node == end:\n                return dist[end]\n            visited[min_node] = True\n            for neighbor, weight in graph[min_node]:\n                if not visited[neighbor] and dist[min_node] + weight < dist[neighbor]:\n                    dist[neighbor] = dist[min_node] + weight\n\n    def min_cost_flow(graph, start, end):\n        n = len(graph)\n        flow = [0] * n\n        while True:\n            dist = [float('inf')] * n\n            dist[start] = 0\n            visited = [False] * n\n            queue = [start]\n            while queue:\n                node = queue.pop(0)\n                if node == end:\n                    return dist[end]\n                if visited[node]:\n                    continue\n                visited[node] = True\n                for neighbor, weight in graph[node]:\n                    if not visited[neighbor] and dist[node] + weight < dist[neighbor]:\n                        dist[neighbor] = dist[node] + weight\n                        queue.append(neighbor)\n            for i in range(n):\n                if visited[i]:\n                    for neighbor, weight in graph[i]:\n                        if not visited[neighbor] and flow[i] > 0 and dist[i] + weight < dist[neighbor]:\n                            flow[neighbor] = min(flow[i], flow[i] // weight)\n                            if flow[neighbor] > 0:\n                                graph[i].append((neighbor, -weight))\n                                graph[neighbor].append((i, weight))\n                                break\n            if not any(flow):\n                return float('inf')\n\n    def min_cost_flow_with_capacity(graph, start, end, capacity):\n        n = len(graph)\n        flow = [0] * n\n        while True:\n            dist = [float('inf')] * n\n            dist[start] = 0\n            visited = [False] * n\n            queue = [start]\n            while queue:\n                node = queue.pop(0)\n                if node == end:\n                    return dist[end]\n                if visited[node]:\n                    continue\n                visited[node] = True\n                for neighbor, weight in graph[node]:\n                    if not visited[neighbor] and dist[node] + weight < dist[neighbor]:\n                        dist[neighbor] = dist[node] + weight\n                        queue.append(neighbor)\n            for i in range(n):\n                if visited[i]:\n                    for neighbor, weight in graph[i]:\n                        if not visited[neighbor] and flow[i] > 0 and dist[i] + weight < dist[neighbor]:\n                            flow[neighbor] = min(flow[i], capacity)\n                            if flow[neighbor"
    },
    {
        "number": 3664,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    r, c, i, j, n = map(int, stdin.split())\n    colors = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    ice = [['.' for _ in range(c)] for _ in range(r)]\n    x, y = i - 1, j - 1\n    zamboni_color = 0\n\n    def rotate_zamboni():\n        nonlocal zamboni_color\n        zamboni_color = (zamboni_color + 1) % len(colors)\n\n    def next_color():\n        return colors[zamboni_color]\n\n    def move(dx, dy):\n        nonlocal x, y\n        x = (x + dx) % r\n        y = (y + dy) % c\n\n    for _ in range(n):\n        move(stepSize, 0)\n        rotate_zamboni()\n        ice[x][y] = next_color()\n        stepSize += 1\n\n    ice[x][y] = '@'\n    return '\\n'.join([''.join(row) for row in ice])\n"
    },
    {
        "number": 3665,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    numbers = [int(line.strip()) for line in stdin.split('\\n')[1:]]\n\n    def count_changes(num):\n        return sum(1 for i in range(m) if num % 10 != i)\n\n    def min_changes(nums):\n        return sum(count_changes(num) for num in nums)\n\n    sorted_numbers = sorted(numbers)\n    min_changes_value = min_changes(sorted_numbers)\n\n    for num in numbers:\n        if count_changes(num) == min_changes_value:\n            yield format(num, '0{}d'.format(m))\n        else:\n            yield format(num, '0{}d'.format(m))"
    },
    {
        "number": 3666,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    gear_ratios = []\n    for line in stdin.split('\\n'):\n        n, d = line.split('/')\n        n, d = int(n), int(d)\n        gear_ratios.append((n, d))\n\n    front_sprockets = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    rear_sprockets = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\n    for front_sprocket in front_sprockets:\n        for rear_sprocket in rear_sprockets:\n            if all(front_sprocket * n_i / d_i == rear_sprocket * v_i / u_i for n_i, d_i, u_i, v_i in gear_ratios):\n                front_sprockets_solution = [front_sprocket]\n                rear_sprockets_solution = [rear_sprocket]\n                for n_i, d_i, u_i, v_i in gear_ratios:\n                    rear_sprockets_solution.append(int(rear_sprockets_solution[-1] * u_i / v_i))\n                return f\"{front_sprocket} {' '.join(map(str, front_sprockets_solution))}\\n{' '.join(map(str, rear_sprockets_solution))}\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3667,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(x, y, visited):\n        if (x, y) in visited:\n            return False\n        visited.add((x, y))\n        return True\n\n    def dfs(x, y, visited, graph, robots):\n        if is_valid(x, y, visited):\n            graph[x][y] = robots\n            if robots > 0:\n                return dfs(x - 1, y, visited, graph, robots - 1) and dfs(x + 1, y, visited, graph, robots - 1) and dfs(x, y - 1, visited, graph, robots - 1) and dfs(x, y + 1, visited, graph, robots - 1)\n            else:\n                return True\n        return False\n\n    w, p = map(int, stdin.split()[:2])\n    wells = [tuple(map(int, stdin.split()[2:4])) for _ in range(w)]\n    pipes = [tuple(map(int, stdin.split()[4:])) for _ in range(p)]\n\n    graph = [[None] * 2001 for _ in range(2001)]\n    for i, (x, y) in enumerate(wells):\n        graph[x][y] = i\n\n    for s, x, y in pipes:\n        x, y = int(x), int(y)\n        if graph[x][y] is not None:\n            continue\n        graph[x][y] = s - 1\n\n    for x in range(2001):\n        for y in range(2001):\n            if graph[x][y] is not None:\n                continue\n            visited = set()\n            if dfs(x, y, visited, graph, 1):\n                return \"possible\"\n\n    return \"impossible\"\n"
    },
    {
        "number": 3668,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    burger_count = [int(input_list[i+1]) for i in range(m)]\n\n    max_unique_colleagues = 0\n    for burger_count_per_day in burger_count:\n        unique_colleagues = min(burger_count_per_day, n-burger_count_per_day)\n        max_unique_colleagues = max(max_unique_colleagues, unique_colleagues)\n\n    return str(max_unique_colleagues)"
    },
    {
        "number": 3669,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    lines = []\n    for i in range(N):\n        lines.append((points[i], points[(i+1)%N]))\n\n    def is_valid(line):\n        for l in lines:\n            if line == l or (line[0] == l[0] and line[1] == l[1]) or (line[0] == l[1] and line[1] == l[0]):\n                return False\n        return True\n\n    def mirror(line):\n        return (line[1], line[0])\n\n    def play(player, lines):\n        if player == \"Mirko\":\n            return \"Slavko\"\n        else:\n            return \"Mirko\"\n\n    def game(player, lines):\n        if len(lines) == 1:\n            return player\n        else:\n            line = input()\n            if is_valid(line):\n                lines.append(line)\n                return game(play(player, lines), lines)\n            else:\n                return game(play(player, lines), lines)\n\n    return game(\"Mirko\", lines)\n"
    },
    {
        "number": 3670,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    plates = [int(line) for line in stdin.splitlines()[1:]]\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def find_m(plates):\n        m = plates[0]\n        for plate in plates[1:]:\n            m = lcm(m, plate)\n        return m\n\n    m = find_m(plates)\n    result = [m]\n    for i in range(2, m + 1):\n        if m % i == 0:\n            result.append(i)\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3671,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    job_offers = list(map(int, input_list[1].split()))\n\n    # Sort the job offers in ascending order\n    job_offers.sort()\n\n    # Initialize variables\n    cookies = 0\n    current_time = 0\n\n    # Iterate through the job offers\n    for offer in job_offers:\n        # Calculate the time needed to complete the current slide\n        if offer - current_time >= 4 * 10**5:\n            current_time = offer + 3 * 10**5\n        else:\n            current_time = offer + (4 * 10**5 - (offer - current_time))\n\n        # Calculate the number of cookies earned\n        cookies += (current_time - offer) // 10**5\n\n    return str(cookies)"
    },
    {
        "number": 3672,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split()[0:2])\n    resources = [set() for _ in range(m)]\n    for i in range(m):\n        resources[i] = set(map(int, stdin.split()[1 + i * n:1 + (i + 1) * n]))\n\n    zax_islands = set()\n    xaz_islands = set()\n    for i in range(m):\n        if 1 in resources[i]:\n            zax_islands.add(i)\n        if 2 in resources[i]:\n            xaz_islands.add(i)\n\n    if len(zax_islands.intersection(xaz_islands)) == 0:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3673,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0].split(','))\n    a = list(map(int, stdin.split()[1].split(',')))\n\n    # Create the adjacency list\n    adj_list = [[] for _ in range(N)]\n    for i in range(N):\n        adj_list[a[i] - 1].append(i)\n\n    # Find the number of connected components\n    visited = [False] * N\n    count = 0\n    for i in range(N):\n        if not visited[i]:\n            count += 1\n            dfs(i, adj_list, visited)\n\n    # If there is more than one connected component, it's impossible\n    if count > 1:\n        return \"Impossible\"\n\n    # Find the arrows\n    arrows = [-1] * N\n    for i in range(N):\n        if arrows[i] == -1:\n            dfs2(i, arrows, adj_list)\n\n    # Print the arrows\n    result = [str(i + 1) for i in arrows]\n    return ' '.join(result)\n\ndef"
    },
    {
        "number": 3674,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n, p, q = map(int, stdin.split())\n    if m < n or p == 0 or q == 0:\n        return \"IMPOSSIBLE\"\n    p = str(p)\n    q = str(q)\n    if len(p) + len(q) > m - n:\n        return \"IMPOSSIBLE\"\n    if len(p) + len(q) + 1 > m:\n        return \"IMPOSSIBLE\"\n    if p[0] == '0' or q[0] == '0':\n        return \"IMPOSSIBLE\"\n    p = int(p)\n    q = int(q)\n    for i in range(10):\n        num = str(i) + str(p) + str(q) + str(i)\n        if len(num) == m:\n            if num[:n] == '00':\n                if int(num[n:]) * 4 == int(str(i) + str(p) + str(q) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str(i) + str"
    },
    {
        "number": 3675,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    strings = stdin.split('\\n')[1:]\n\n    def lcs(a, b):\n        m, n = len(a), len(b)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if a[i - 1] == b[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + 1\n                else:\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n        return dp[m][n]\n\n    result = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            result = max(result, lcs(strings[i], strings[j]))\n\n    return str(result)\n"
    },
    {
        "number": 3676,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    R, C = map(int, stdin.split())\n    if R == 1 and C == 1:\n        return \"1\"\n    elif R == 1 or C == 1:\n        return \"2\"\n    else:\n        return \"3\"\n\n\ninput_str = input()\nprint(solution(input_str)) "
    },
    {
        "number": 3677,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split()[0:2])\n    D = [list(map(int, stdin.split()[2:])) for _ in range(N)]\n\n    def count_disagreements(i, j):\n        return sum(1 for k in range(N) if k != i and k != j and D[i][k] != D[j][k])\n\n    def is_disagreement(i, j):\n        return count_disagreements(i, j) < K\n\n    def find_largest_committee():\n        max_size = 0\n        for i in range(N):\n            for j in range(i + 1, N):\n                if is_disagreement(i, j):\n                    committee_size = 2\n                    for k in range(N):\n                        if k != i and k != j and D[i][k] == D[j][k]:\n                            committee_size += 1\n                            if committee_size > max_size:\n                                max_size = committee_size\n                            break\n        return max_size\n\n    return str(find_largest_committee())\n"
    },
    {
        "number": 3678,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    for i in range(t):\n        n = int(stdin.readline())\n        points = []\n        for j in range(n):\n            x, y = map(int, stdin.readline().split())\n            points.append((x, y))\n        \n        # Check if there are at least 3 points\n        if n < 3:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len(set(map(lambda p: p[0], points))) < 2 or len(set(map(lambda p: p[1], points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x and y coordinate\n        if len(set(map(lambda p: (p[0], p[1]), points))) < 2:\n            print(\"NO\")\n            continue\n        \n        # Check if there are at least 2 points with the same x or y coordinate\n        if len"
    },
    {
        "number": 3679,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 2:\n        return \"3.000000000\"\n    else:\n        return \"1.000000000\"\n\ninput_str = \"2\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3680,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    k, n = map(int, input_list[0].split())\n    pole_lengths = list(map(int, input_list[1].split()))\n\n    pole_lengths.sort(reverse=True)\n    fence_post_length = 0\n    cuts = 0\n\n    for pole_length in pole_lengths:\n        if fence_post_length + pole_length <= n:\n            fence_post_length += pole_length\n        else:\n            cuts += 1\n            fence_post_length = pole_length\n\n    if fence_post_length > 0:\n        cuts += 1\n\n    return str(cuts)\n"
    },
    {
        "number": 3681,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, Q = map(int, stdin.split()[:3])\n    queries = stdin.split()[3:]\n    teachers = [i for i in range(1, N+1)]\n    classes = [i for i in range(1, N+1)]\n    class_teacher = {i: i for i in range(1, N+1)}\n    week_teacher = {i: {i: i for i in range(1, N+1)} for j in range(1, M+1)}\n    week_class = {i: {i: i for i in range(1, N+1)} for j in range(1, M+1)}\n\n    for i in range(Q):\n        if queries[i*5].isdigit():\n            K = int(queries[i*5])\n            x = int(queries[i*5+1])\n            p = queries[i*5+2:i*5+2+K]\n            p = list(map(int, p))\n            for j in range(x, M+1, K):\n                for k in range(K):\n                    week_teacher[j][teachers[p[k]-1]] = teachers[p[(k+1)%K]-1]\n                    week_class[j][classes[p[k]-1]] = classes[p[(k+1)%K]-1]\n                    teachers[p[k]-1], teachers[p[(k+1)%K]-1] = teachers[p[(k+1)%K]-1], teachers[p[k]-1]\n                    class_teacher[classes[p[k]-1]] = teachers[p[(k+1)%K]-1]\n        else:\n            d = int(queries[i*2+1])\n            x = int(queries[i*2+2])\n            print(week_class[x][class_teacher[d]])\n\nstdin = \"3 4 5\\n1 3 4\\n0 2 2 3 2\\n1 3 2\\n1 2 4\\n1 1 4\"\nsolution(stdin) "
    },
    {
        "number": 3682,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def clean_line(line: str) -> str:\n        return line.strip().replace(\" \", \"\")\n\n    def clean_code(code: str) -> str:\n        return \"\".join(clean_line(line) for line in code.split(\"\\n\") if line.strip())\n\n    def compare_code(code1: str, code2: str) -> int:\n        lines1 = code1.split(\"\\n\")\n        lines2 = code2.split(\"\\n\")\n        max_match = 0\n        for i in range(len(lines1)):\n            if i >= len(lines2):\n                break\n            if clean_line(lines1[i]) == clean_line(lines2[i]):\n                max_match += 1\n            else:\n                break\n        return max_match\n\n    def find_matches(code: str, repository: dict) -> int:\n        max_match = 0\n        matching_files = []\n        for file_name, repo_code in repository.items():\n            match_length = compare_code(code, repo_code)\n            if match_length > max_match:\n                max_match = match_length\n                matching_files = [file_name]\n            elif match_length == max_match:\n                matching_files.append(file_name)\n        return max_match, matching_files\n\n    stdin_lines = stdin.split(\"\\n\")\n    num_fragments = int(stdin_lines[0])\n    repository = {}\n    for i in range(1, len(stdin_lines), 2):\n        file_name = stdin_lines[i]\n        code = clean_code(stdin_lines[i + 1])\n        repository[file_name] = code\n\n    code = clean_code(stdin_lines[-2])\n    max_match, matching_files = find_matches(code, repository)\n\n    if max_match == 0:\n        return \"0\"\n    else:\n        return f\"{max_match} {' '.join(matching_files)}\"\n"
    },
    {
        "number": 3683,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, h = map(int, stdin.split()[0:2])\n    scores = [list(map(int, stdin.split()[2:])) for _ in range(p)]\n    l = max(max(scores, key=max))\n    adjusted_scores = [[min(score, l) for score in player_scores] for player_scores in scores]\n    ranks = [sorted(adjusted_scores, key=lambda x: x.index(i)).index(i) + 1 for i in range(1, l+1)]\n    return ' '.join(map(str, ranks))\n"
    },
    {
        "number": 3684,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, C = map(int, stdin.split()[0:2])\n    users = []\n    for _ in range(n):\n        p, b, u = map(int, stdin.split()[2:5])\n        users.append((p, b, u))\n\n    # Calculate the maximum possible smallest buffer size after one second\n    max_buffer_size = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                # Calculate the distance between the two users\n                distance = abs(users[i][0] - users[j][0])\n                # Calculate the number of bytes that can be transmitted during the one second interval\n                bytes_transmitted = min(users[i][1] - users[i][0], users[j][1] - users[j][0], C)\n                # Calculate the buffer size after one second\n                buffer_size = users[i][1] - (users[i][0] + distance) - bytes_transmitted\n                # Update the maximum possible smallest buffer size\n                max_buffer_size = max(max_buffer_size, buffer_size)\n\n    return str(max_buffer_size)"
    },
    {
        "number": 3685,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    r, c = map(int, input_list[0].split())\n    start_bed, fridge = map(lambda x: tuple(map(int, x[1:-1].split())), input_list[1].split())\n    map_list = [list(line) for line in input_list[2:2+r]]\n    p = int(input_list[2+r])\n    masters = [tuple(map(int, line[1:-1].split())) for line in input_list[3+r:]]\n\n    def is_valid(pos):\n        r, c = pos\n        return 0 <= r < r and 0 <= c < c\n\n    def bfs(start, target):\n        queue = [(start, 0)]\n        visited = set()\n        while queue:\n            pos, steps = queue.pop(0)\n            if pos == target:\n                return steps\n            for dr, dc in ((-1, 0), (1, 0), (0, -1), (0, 1)):\n                r, c = pos\n                new_pos = (r+dr, c+dc)\n                if is_valid(new_pos) and new_pos not in visited and map_list[new_pos[0]][new_pos[1]] == '.':\n                    queue.append((new_pos, steps+1))\n                    visited.add(new_pos)\n\n    def is_safe(pos):\n        for master in masters:\n            if pos == master or (pos[0]-master[0])**2 + (pos[1]-master[1])**2 <= 2:\n                return False\n        return True\n\n    min_turns = float('inf')\n    for i in range(r):\n        for j in range(c):\n            if map_list[i][j] == '.':\n                turns = bfs((i, j), fridge)\n                if turns is not None and is_safe((i, j)):\n                    min_turns = min(min_turns, turns)\n\n    if min_turns == float('inf'):\n        return \"IMPOSSIBLE\"\n    else:\n        return str(min_turns)"
    },
    {
        "number": 3686,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N = int(input_list[0])\n    targets = []\n    for i in range(1, N+1):\n        x, y = map(int, input_list[i].split())\n        targets.append((x, y))\n\n    targets.sort(key=lambda x: x[1])\n    min_y = targets[0][1]\n    max_y = targets[-1][1]\n\n    for i in range(N-1):\n        if targets[i][1] == targets[i+1][1]:\n            return \"failure\"\n\n    if N == 1:\n        return \"success\"\n\n    if N == 2:\n        if targets[0][1] == targets[1][1]:\n            return \"failure\"\n        else:\n            return \"success\"\n\n    if N == 3:\n        if targets[0][1] == targets[1][1] and targets[1][1] == targets[2][1]:\n            return \"failure\"\n        elif targets[0][1] == targets[1][1] and targets[1][1] != targets[2][1]:\n            return \"success\"\n        elif targets[0][1] != targets[1][1] and targets[1][1] == targets[2][1]:\n            return \"success\"\n        else:\n            return \"success\"\n\n    if N == 4:\n        if targets[0][1] == targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] == targets[3][1]:\n            return \"failure\"\n        elif targets[0][1] == targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] != targets[3][1]:\n            return \"success\"\n        elif targets[0][1] == targets[1][1] and targets[1][1] != targets[2][1] and targets[2][1] == targets[3][1]:\n            return \"success\"\n        elif targets[0][1] != targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] == targets[3][1]:\n            return \"success\"\n        elif targets[0][1] != targets[1][1] and targets[1][1] != targets[2][1] and targets[2][1] == targets[3][1]:\n            return \"success\"\n        elif targets[0][1] != targets[1][1] and targets[1][1] != targets[2][1] and targets[2][1] != targets[3][1]:\n            return \"success\"\n        else:\n            return \"failure\"\n\n    if N == 5:\n        if targets[0][1] == targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] == targets[3][1] and targets[3][1] == targets[4][1]:\n            return \"failure\"\n        elif targets[0][1] == targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] == targets[3][1] and targets[3][1] != targets[4][1]:\n            return \"success\"\n        elif targets[0][1] == targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] != targets[3][1] and targets[3][1] == targets[4][1]:\n            return \"success\"\n        elif targets[0][1] == targets[1][1] and targets[1][1] != targets[2][1] and targets[2][1] == targets[3][1] and targets[3][1] == targets[4][1]:\n            return \"success\"\n        elif targets[0][1] != targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] == targets[3][1] and targets[3][1] == targets[4][1]:\n            return \"success\"\n        elif targets[0][1] != targets[1][1] and targets[1][1] == targets[2][1] and targets[2][1] != targets["
    },
    {
        "number": 3687,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q, s = map(int, stdin.split()[:3])\n    queues = list(map(int, stdin.split()[3:3+q]))\n    queue_sizes = list(map(int, stdin.split()[3+q:3+q+q]))\n    for _ in range(n):\n        stdin.split()\n    total_data = 0\n    for i in range(s):\n        total_data += int(stdin.split()[3+q+i])\n    if total_data <= sum(queue_sizes):\n        return \"possible\"\n    else:\n        return \"impossible\""
    },
    {
        "number": 3688,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def min_vertical_moves(shopping_list, malls):\n        malls.sort(key=lambda x: x[0])\n        shopping_list.sort(key=lambda x: x[1])\n        vertical_moves = 0\n        current_item = 1\n        current_mall = 0\n\n        while current_item <= m:\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list.pop(0)[1]\n\n            if current_item == shopping_list[-1][1]:\n                current_item = shopping_list.pop()[1]\n\n            if current_item == shopping_list[0][1]:\n                current_item = shopping_list"
    },
    {
        "number": 3689,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    x = int(stdin.split()[2])\n    m = n - k\n    y = x\n    for i in range(m):\n        y += x // 10**(n-i-1) * 10**k\n    return f\"{m}\\n{y}\"\n"
    },
    {
        "number": 3690,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    h, m, s, t_1, t_2 = map(int, stdin.split())\n\n    # Convert time to seconds\n    time = h * 3600 + m * 60 + s\n    t_1_time = t_1 * 3600\n    t_2_time = t_2 * 3600\n\n    # Check if Misha can reach the target time\n    if t_1_time <= time <= t_2_time:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3691,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x0, y0, a_x, a_y, b_x, b_y, x_s, y_s, t = map(int, stdin.split())\n    max_nodes = 0\n    x, y = x_s, y_s\n    visited = set()\n    visited.add((x, y))\n    time_spent = 0\n\n    def get_next_node(x, y):\n        return (x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)\n\n    def get_coordinates(x, y, i):\n        return a_x * x + b_x, a_y * y + b_y\n\n    while time_spent < t:\n        next_nodes = get_next_node(x, y)\n        for next_node in next_nodes:\n            if next_node not in visited:\n                visited.add(next_node)\n                x, y = next_node\n                time_spent += 1\n                if time_spent < t:\n                    break\n        if time_spent < t:\n            x, y = get_coordinates(x, y, max_nodes + 1)\n            time_spent += 1\n            max_nodes += 1\n\n    return str(max_nodes)"
    },
    {
        "number": 3692,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    circles = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_inside(x, y, r, x1, y1, r1):\n        return (x - x1) ** 2 + (y - y1) ** 2 <= (r + r1) ** 2\n\n    def is_valid(x, y, r, x1, y1, r1):\n        return (x - x1) ** 2 + (y - y1) ** 2 >= (r - r1) ** 2\n\n    def is_valid_circle(x, y, r):\n        for circle in circles:\n            if is_inside(x, y, r, circle[0], circle[1], circle[2]):\n                return False\n            if not is_valid(x, y, r, circle[0], circle[1], circle[2]):\n                return False\n        return True\n\n    def is_valid_region(x, y, r):\n        return is_valid_circle(x, y, r)\n\n    def count_regions():\n        regions = 0\n        for circle in circles:\n            if is_valid_region(circle[0], circle[1], circle[2]):\n                regions += 1\n        return regions\n\n    return str(count_regions())\n"
    },
    {
        "number": 3693,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    squares = stdin.split('\\n')\n    points1 = [tuple(map(int, line.split())) for line in squares[0].split()]\n    points2 = [tuple(map(int, line.split())) for line in squares[1].split()]\n\n    def is_inside(point, points):\n        return any(point == p for p in points)\n\n    def is_intersect(points1, points2):\n        for point1 in points1:\n            if is_inside(point1, points2):\n                return True\n        return False\n\n    return \"Yes\" if is_intersect(points1, points2) else \"No\"\n"
    },
    {
        "number": 3694,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_win(a):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if a[i] == a[j]:\n                    return False\n        return True\n\n    while not is_win(a):\n        max_i = a.index(max(a))\n        a[max_i] = 0\n\n    if sum(a) == 0:\n        return \"cslnb\"\n    else:\n        return \"sjfnb\"\n"
    },
    {
        "number": 3695,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[:2])\n    t = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    time = 0\n    max_eaten = 0\n\n    # Iterate through the bowls\n    for i in range(1, n + 1):\n        # Find the time when the current bowl is ready\n        t_i = t[i - 1]\n\n        # Update the time\n        time = max(time, t_i)\n\n        # Calculate the number of bowls eaten\n        eaten = dp[i - 1] + 1\n\n        # Update the maximum number of bowls eaten\n        max_eaten = max(max_eaten, eaten)\n\n        # Update the dp array\n        dp[i] = max(dp[i - 1], eaten)\n\n        # Check if the dog can eat the current bowl\n        if time <= T:\n            max_eaten = max(max_eaten, dp[i] + 1)\n\n    return max_eaten\n"
    },
    {
        "number": 3696,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\\n0 1\\n0\"\n    elif n == 2:\n        return \"-1\\n1\\n0 1\\n1\"\n    else:\n        return \"No answer\"\n"
    },
    {
        "number": 3697,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, m, a = map(int, stdin.split()[:4])\n    g = list(map(int, stdin.split()[4:]))\n\n    # Calculate the number of votes for each candidate\n    votes = [0] * n\n    for i in range(a):\n        votes[g[i] - 1] += 1\n\n    # Sort the candidates by the number of votes and the time of last vote\n    sorted_candidates = sorted(range(n), key=lambda x: (-votes[x], -g[x]))\n\n    # Determine the outcome for each candidate\n    outcomes = [3] * n\n    for i in range(k):\n        outcomes[sorted_candidates[i]] = 1\n\n    for i in range(k, n):\n        outcomes[sorted_candidates[i]] = 2\n\n    # Print the outcomes\n    return ' '.join(map(str, outcomes))\n"
    },
    {
        "number": 3698,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    count = 0\n    for i in range(1, n + 1):\n        binary_i = bin(i)[2:]\n        set_bits = binary_i.count('1')\n        if set_bits == k:\n            count += 1\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3699,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_x, a_y, b_x, b_y, t_x, t_y, n = map(int, stdin.split())\n    bottles = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        bottles.append((x, y))\n\n    def distance(x1, y1, x2, y2):\n        return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n    def min_distance(a_x, a_y, b_x, b_y, t_x, t_y, bottles):\n        min_dist = float('inf')\n        for bottle in bottles:\n            dist_a = distance(a_x, a_y, bottle[0], bottle[1])\n            dist_b = distance(b_x, b_y, bottle[0], bottle[1])\n            dist_t = distance(t_x, t_y, bottle[0], bottle[1])\n            min_dist = min(min_dist, dist_a + dist_b + dist_t)\n        return min_dist\n\n    min_dist = min_distance(a_x, a_y, b_x, b_y, t_x, t_y, bottles)\n    return str(min_dist)\n"
    },
    {
        "number": 3700,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    count = 0\n    for i in range(1, n):\n        if i + k <= n:\n            count += 1\n    return count\n\n\ndef"
    },
    {
        "number": 3701,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, x, y = map(int, stdin.split()[:3])\n    a = stdin.split()[-1]\n\n    # Initialize the cost and count of ones\n    cost = 0\n    ones_count = 0\n\n    # Iterate through the string\n    for i in range(n):\n        if a[i] == '1':\n            ones_count += 1\n        else:\n            ones_count = 0\n\n        # If the count of ones is equal to n, we can stop iterating\n        if ones_count == n:\n            break\n\n        # If the count of ones is less than n, we need to perform operations\n        if ones_count < n:\n            # Calculate the minimum cost of operations\n            min_cost = float('inf')\n            for j in range(i, n):\n                if a[j] == '1':\n                    min_cost = min(min_cost, x + y)\n                else:\n                    min_cost = min(min_cost, x)\n\n            # Add the minimum cost to the overall cost\n            cost += min_cost\n\n    return str(cost)\n"
    },
    {
        "number": 3702,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, d = map(int, stdin.split())\n    if n < 2 or a + (n - 1) * d >= 10**6:\n        return \"-1\"\n\n    def is_valid(b, e):\n        for i in range(n):\n            if not str(a + i * d).zfill(18) in str(Fibonacci(a + i * e)):\n                return False\n        return True\n\n    def Fibonacci(n):\n        if n == 0:\n            return 0\n        elif n == 1:\n            return 1\n        else:\n            return Fibonacci(n - 1) + Fibonacci(n - 2)\n\n    b, e = 2, 1\n    while not is_valid(b, e):\n        b += 1\n        e = 1\n        while not is_valid(b, e):\n            e += 1\n            if e >= 2**64:\n                return \"-1\"\n    return f\"{b} {e}\"\n"
    },
    {
        "number": 3703,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k == 1:\n        return str(f(n))\n    else:\n        if k % 2 == 0:\n            return str(g(f(n // k)))\n        else:\n            return str(f(g(f(n // k))))\n\ndef"
    },
    {
        "number": 3704,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_subnet(ip: str, subnet: str) -> bool:\n        ip_parts = ip.split('.')\n        subnet_parts = subnet.split('.')\n        if len(ip_parts) != 4 or len(subnet_parts) not in (1, 2):\n            return False\n        if len(subnet_parts) == 2:\n            if subnet_parts[1].count('/') != 1:\n                return False\n            subnet_parts[1], _ = subnet_parts[1].split('/')\n            if not subnet_parts[1].isdigit() or int(subnet_parts[1]) > 32:\n                return False\n        for i in range(4):\n            if not ip_parts[i].isdigit() or not 0 <= int(ip_parts[i]) <= 255:\n                return False\n            if subnet_parts[i] != '*' and ip_parts[i] != subnet_parts[i]:\n                return False\n        return True\n\n    def merge_subnets(blacklist: List[str], whitelist: List[str]) -> List[str]:\n        blacklist_set = set(blacklist)\n        whitelist_set = set(whitelist)\n        common_subnets = blacklist_set.intersection(whitelist_set)\n        if common_subnets:\n            return [-1]\n\n        merged_subnets = blacklist + [subnet for subnet in whitelist if subnet not in blacklist_set]\n        merged_subnets.sort(key=lambda x: (x.count('/'), x))\n        return merged_subnets\n\n    def optimize_blacklist(blacklist: List[str]) -> List[str]:\n        def is_valid_subnet(subnet: str) -> bool:\n            ip_parts = subnet.split('.')\n            if len(ip_parts) != 4:\n                return False\n            for i in range(4):\n                if not ip_parts[i].isdigit() or not 0 <= int(ip_parts[i]) <= 255:\n                    return False\n            return True\n\n        def is_subnet_in_blacklist(subnet: str) -> bool:\n            for blacklist_subnet in blacklist:\n                if is_subnet(subnet, blacklist_subnet):\n                    return True\n            return False\n\n        def merge_subnets_recursive(subnets: List[str]) -> List[str]:\n            if len(subnets) == 1:\n                return subnets\n\n            merged_subnets = []\n            for i in range(len(subnets)):\n                for j in range(i + 1, len(subnets)):\n                    if is_subnet(subnets[i], subnets[j]):\n                        merged_subnets.append(subnets[i])\n                        break\n                else:\n                    merged_subnets.append(subnets[i])\n\n            return merge_subnets_recursive(merged_subnets)\n\n        def is_subnet_in_whitelist(subnet: str) -> bool:\n            for whitelist_subnet in whitelist:\n                if is_subnet(subnet, whitelist_subnet):\n                    return True\n            return False\n\n        def is_subnet_in_blacklist_or_whitelist(subnet: str) -> bool:\n            return is_subnet_in_blacklist(subnet) or is_subnet_in_whitelist(subnet)\n\n        def is_valid_subnet_not_in_blacklist_or_whitelist(subnet: str) -> bool:\n            return is_valid_subnet(subnet) and not is_subnet_in_blacklist_or_whitelist(subnet)\n\n        def is_valid_subnet_not_in_blacklist(subnet: str) -> bool:\n            return is_valid_subnet(subnet) and not is_subnet_in_blacklist(subnet)\n\n        def is_valid_subnet_not_in_whitelist(subnet: str) -> bool:\n            return"
    },
    {
        "number": 3705,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    count = 0\n    for i in range(n - 10):\n        if s[i:i+11] == \"80123456789\":\n            count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3706,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    g = [[0] * m for _ in range(n)]\n\n    for i in range(1, n + 1):\n        g[i - 1] = list(map(int, input_list[i].split()))\n\n    def is_win(g):\n        for i in range(n):\n            for j in range(m):\n                if g[i][j] != g[i][m // 2] + i * m // 2 + j * m // 2:\n                    return False\n        return True\n\n    def min_moves(g):\n        moves = []\n        for i in range(n):\n            if sum(g[i]) == 0:\n                moves.append('row {}'.format(i + 1))\n            else:\n                for j in range(m):\n                    if g[i][j] == 0:\n                        g[i][j] = 1\n                        moves.append('row {}'.format(i + 1))\n                        break\n        for j in range(m):\n            if sum(g[i][j] for i in range(n)) == 0:\n                moves.append('col {}'.format(j + 1))\n            else:\n                for i in range(n):\n                    if g[i][j] == 0:\n                        g[i][j] = 1\n                        moves.append('col {}'.format(j + 1))\n                        break\n        return moves\n\n    if is_win(g):\n        return -1\n    else:\n        moves = min_moves(g)\n        return len(moves), *moves\n"
    },
    {
        "number": 3707,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t, k, d = map(int, stdin.split())\n    if t * k <= n:\n        return \"YES\"\n    else:\n        return \"NO\""
    },
    {
        "number": 3708,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    volcanoes = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    volcanoes.append((1, 1))\n    volcanoes = set(volcanoes)\n    visited = set()\n    queue = [(1, 1, 0)]\n    while queue:\n        i, j, time = queue.pop(0)\n        if (i, j) == (n, n):\n            return time\n        if (i, j) not in visited:\n            visited.add((i, j))\n            for x, y in ((i+1, j), (i, j+1)):\n                if (x, y) not in volcanoes and (x, y) not in visited:\n                    queue.append((x, y, time+1))\n    return -1\n"
    },
    {
        "number": 3709,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    problems = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n\n    for team in problems:\n        if sum(team) > k // 2:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3710,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    ancient_numbers = list(map(int, stdin.split()[2:]))\n\n    if k in ancient_numbers:\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 3711,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split())\n    \n    if n * m < k:\n        return -1\n    \n    if k == 1:\n        return n * m\n    \n    if k == 2:\n        return n * m // 2 * (n * m // 2 + 1)\n    \n    if k == n * m:\n        return 1\n    \n    if k == n * m - 1:\n        return n * m // 2 * (n * m // 2 + 1)\n    \n    if k == n * m - 2:\n        return n * m // 2 * (n * m // 2 - 1)\n    \n    return -1\n"
    },
    {
        "number": 3712,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the number of people needed to swap\n    needed_swap = 0\n\n    # Iterate through the compartments\n    for i in range(n):\n        # If the compartment has less than two students, increment the needed swap count\n        if a[i] < 2:\n            needed_swap += 2 - a[i]\n\n    # If the needed swap count is even, return the count\n    if needed_swap % 2 == 0:\n        return str(needed_swap // 2)\n    # If the needed swap count is odd, return -1\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3713,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split()[0])\n    score = stdin.split()[1]\n\n    # Convert the score string to a list of integers\n    score_list = [int(digit) for digit in score]\n\n    # Calculate the length of the longest alternating subsequence\n    longest_alternating_subsequence = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if score_list[i] != score_list[j]:\n                longest_alternating_subsequence = max(longest_alternating_subsequence, j - i + 1)\n\n    return longest_alternating_subsequence\n"
    },
    {
        "number": 3714,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    crushes = list(map(int, stdin.splitlines()[1].split()))\n\n    def find_joon_joon(x: int) -> int:\n        if x == crushes[x - 1]:\n            return x\n        return find_joon_joon(crushes[x - 1])\n\n    t = 1\n    while True:\n        if all(find_joon_joon(x) == x for x in range(1, n + 1)):\n            return t\n        t += 1\n"
    },
    {
        "number": 3715,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    rest_days = 0\n    prev_activity = -1\n\n    for i in range(n):\n        if a[i] == 0 or a[i] == 1:\n            if prev_activity == 2:\n                rest_days += 1\n            prev_activity = 0\n        elif a[i] == 2 or a[i] == 3:\n            if prev_activity == 1:\n                rest_days += 1\n            prev_activity = 2\n\n    return rest_days\n"
    },
    {
        "number": 3716,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n < 7:\n        return \"210\"\n    else:\n        return \"504\"\n"
    },
    {
        "number": 3717,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    rectangles = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_point_inside(point):\n        x, y = point\n        for x1, y1, x2, y2 in rectangles:\n            if x1 <= x <= x2 and y1 <= y <= y2:\n                return True\n        return False\n\n    def find_common_points():\n        common_points = set()\n        for i in range(n):\n            for j in range(i + 1, n):\n                x1, y1, x2, y2 = rectangles[i]\n                x3, y3, x4, y4 = rectangles[j]\n                if (x1, y1) == (x3, y3) or (x2, y2) == (x4, y4):\n                    common_points.add((x1, y1))\n        return common_points\n\n    def find_point_with_common_points():\n        common_points = find_common_points()\n        for x, y in common_points:\n            if is_point_inside((x, y)):\n                return x, y\n        return None\n\n    point = find_point_with_common_points()\n    if point:\n        return str(point[0]) + \" \" + str(point[1])\n    else:\n        return \"No such point exists.\"\n"
    },
    {
        "number": 3718,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    t = list(map(int, stdin.splitlines()[1].split()))\n    \n    if n < 3:\n        return \"NO\"\n    \n    t.sort()\n    \n    for i in range(n-2):\n        if t[i+1] - t[i] > 2:\n            return \"NO\"\n        \n    return \"YES\"\n"
    },
    {
        "number": 3719,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m = map(int, input_list[0].split())\n    y1 = list(map(int, input_list[1].split()))\n    y2 = list(map(int, input_list[2].split()))\n\n    y1.sort()\n    y2.sort()\n\n    i, j = 0, 0\n    destroyed = 0\n    while i < n and j < m:\n        if y1[i] < y2[j]:\n            destroyed += n - i\n            i += 1\n        else:\n            destroyed += m - j\n            j += 1\n\n    return destroyed\n"
    },
    {
        "number": 3720,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 4 == 0:\n        return \"Vasya\"\n    else:\n        return \"Petya\"\n"
    },
    {
        "number": 3721,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, q = map(int, stdin.split()[:3])\n    existing_elements = set(map(tuple, [map(int, stdin.split()[i:i+2]) for i in range(1, 1 + q, 2)]))\n    missing_elements = set(zip(range(1, n+1), range(1, m+1))) - existing_elements\n    if not missing_elements:\n        return 0\n    min_purchases = float('inf')\n    for element in missing_elements:\n        purchases = 0\n        for other_element in missing_elements:\n            if element[0] == other_element[0] or element[1] == other_element[1]:\n                purchases += 1\n        min_purchases = min(min_purchases, purchases)\n    return min_purchases\n"
    },
    {
        "number": 3722,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, c_AA, c_AB, c_BA, c_BB = stdin.split()\n    N = int(N)\n    c_AA = c_AA[0]\n    c_AB = c_AB[0]\n    c_BA = c_BA[0]\n    c_BB = c_BB[0]\n\n    def count_strings(s: str, N: int) -> int:\n        if len(s) == N:\n            return 1\n        elif len(s) > N:\n            return 0\n        else:\n            return count_strings(s + c_AA, N) + count_strings(s + c_AB, N) + count_strings(s + c_BA, N) + count_strings(s + c_BB, N)\n\n    return count_strings(\"AB\", N) % (10**9 + 7)\n"
    },
    {
        "number": 3723,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    strengths = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def group_gcd(group):\n        return reduce(gcd, group)\n\n    max_group_size = 0\n    for i in range(1, n):\n        for j in range(i + 1, n + 1):\n            group = strengths[i:j]\n            if len(group) > max_group_size and group_gcd(group) == 1:\n                max_group_size = len(group)\n\n    return max_group_size\n"
    },
    {
        "number": 3724,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, S = map(str, stdin.split())\n    N = int(N)\n    S = S.strip()\n\n    def count_distinct_strings(S: str) -> int:\n        count = 1\n        for i in range(1, len(S)):\n            if S[i] != S[i - 1]:\n                count += 1\n        return count\n\n    def can_operate(S: str) -> bool:\n        for i in range(1, len(S)):\n            if S[i] != S[i - 1]:\n                return True\n        return False\n\n    result = count_distinct_strings(S)\n    while can_operate(S):\n        for i in range(1, len(S)):\n            if S[i] != S[i - 1]:\n                S = S[:i] + S[i + 1] + S[i] + S[i + 2:]\n                break\n        result = (result * 2) % (10**9 + 7)\n\n    return str(result)\n"
    },
    {
        "number": 3725,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, h_1, a_1, x_1, y_1, h_2, a_2, x_2, y_2 = map(int, stdin.split())\n\n    def get_next_height(height: int, x: int, y: int) -> int:\n        return (x * height + y) % m\n\n    def get_time_to_reach_height(height: int) -> int:\n        time = 0\n        while Xaniar_height != height:\n            Xaniar_height = get_next_height(Xaniar_height, x_1, y_1)\n            time += 1\n        return time\n\n    Xaniar_height = h_1\n    Abol_height = h_2\n\n    if Xaniar_height == a_1 and Abol_height == a_2:\n        return 0\n\n    Xaniar_time_to_reach_a_1 = get_time_to_reach_height(a_1)\n    Abol_time_to_reach_a_2 = get_time_to_reach_height(a_2)\n\n    if Xaniar_time_to_reach_a_1 == -1 or Abol_time_to_reach_a_2 == -1:\n        return -1\n\n    return min(Xaniar_time_to_reach_a_1, Abol_time_to_reach_a_2)\n"
    },
    {
        "number": 3726,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    x = list(map(int, stdin.split()[1:]))\n\n    # Find the minimum prime number greater than or equal to 3\n    def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    p = 3\n    while not is_prime(p):\n        p += 1\n\n    # Count the number of cards that can be flipped with the minimum prime number\n    count = 0\n    for i in range(N):\n        if x[i] <= p:\n            count += 1\n\n    # Calculate the minimum number of operations required\n    if count == 0:\n        return 1\n    else:\n        return count + 1\n"
    },
    {
        "number": 3727,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, d = map(int, stdin.split())\n    total = a + b + c + d\n    \n    if total % 4 != 0:\n        return \"NO\"\n    \n    sequence = []\n    for i in range(a):\n        sequence.append(0)\n    for i in range(b):\n        sequence.append(1)\n    for i in range(c):\n        sequence.append(2)\n    for i in range(d):\n        sequence.append(3)\n    \n    if len(sequence) != total:\n        return \"NO\"\n    \n    sequence.sort()\n    return \"YES\\n\" + \" \".join(map(str, sequence))\n"
    },
    {
        "number": 3728,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    table = [list(map(int, stdin.split()[2:]))]\n    for i in range(n-1):\n        table.append(list(map(int, input().split())))\n\n    def is_sorted(row):\n        return sorted(row) == list(range(1, m+1))\n\n    def swap_columns(table, col1, col2):\n        for row in table:\n            row[col1], row[col2] = row[col2], row[col1]\n\n    def swap_rows(table, row1, row2):\n        table[row1], table[row2] = table[row2], table[row1]\n\n    def is_identity(table):\n        for row in table:\n            if not is_sorted(row):\n                return False\n        return True\n\n    def find_identity():\n        for col1 in range(m):\n            for col2 in range(col1+1, m):\n                swap_columns(table, col1, col2)\n                if is_identity(table):\n                    return True\n                swap_columns(table, col1, col2)\n        return False\n\n    def find_identity_with_rows():\n        for row1 in range(n):\n            for row2 in range(row1+1, n):\n                swap_rows(table, row1, row2)\n                if find_identity():\n                    return True\n                swap_rows(table, row1, row2)\n        return False\n\n    if find_identity_with_rows():\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3729,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    f, w, h = map(int, stdin.split())\n    if f == 0:\n        return 0\n    if w == 0:\n        return 1\n    if f == 1:\n        return 0\n    if w == 1:\n        return 1\n    if h == 1:\n        return 0\n    if f == 2:\n        return 1\n    if w == 2:\n        return 2\n    if f == 3:\n        return 3\n    if w == 3:\n        return 4\n    if f == 4:\n        return 5\n    if w == 4:\n        return 6\n    if f == 5:\n        return 7\n    if w == 5:\n        return 8\n    if f == 6:\n        return 9\n    if w == 6:\n        return 10\n    if f == 7:\n        return 11\n    if w == 7:\n        return 12\n    if f == 8:\n        return 13\n    if w == 8:\n        return 14\n    if f == 9:\n        return 15\n    if w == 9:\n        return 16\n    if f == 10:\n        return 17\n    if w == 10:\n        return 18\n    if f == 11:\n        return 19\n    if w == 11:\n        return 20\n    if f == 12:\n        return 21\n    if w == 12:\n        return 22\n    if f == 13:\n        return 23\n    if w == 13:\n        return 24\n    if f == 14:\n        return 25\n    if w == 14:\n        return 26\n    if f == 15:\n        return 27\n    if w == 15:\n        return 28\n    if f == 16:\n        return 29\n    if w == 16:\n        return 30\n    if f == 17:\n        return 31\n    if w == 17:\n        return 32\n    if f == 18:\n        return 33\n    if w == 18:\n        return 34\n    if f == 19:\n        return 35\n    if w == 19:\n        return 36\n    if f == 20:\n        return 37\n    if w == 20:\n        return 38\n    if f == 21:\n        return 39\n    if w == 21:\n        return 40\n    if f == 22:\n        return 41\n    if w == 22:\n        return 42\n    if f == 23:\n        return 43\n    if w == 23:\n        return 44\n    if f == 24:\n        return 45\n    if w == 24:\n        return 46\n    if f == 25:\n        return 47\n    if w == 25:\n        return 48\n    if f == 26:\n        return 49\n    if w == 26:\n        return 50\n    if f == 27:\n        return 51\n    if w == 27:\n        return 52\n    if f == 28:\n        return 53\n    if w == 28:\n        return 54\n    if f == 29:\n        return 55\n    if w == 29:\n        return 56\n    if f == 30:\n        return 57\n    if w == 30:\n        return 58\n    if f == 31:\n        return 59\n    if w == 31:\n        return 60\n    if f == 32:\n        return 61\n    if w == 32:\n        return 62\n    if f == 33:\n        return 63\n    if w == 33:\n        return 64\n    if f == 3"
    },
    {
        "number": 3730,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    max_length = 1\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if a[i] <= a[j]:\n                continue\n            length = j - i + 1\n            if length > max_length:\n                max_length = length\n\n    return str(max_length)\n"
    },
    {
        "number": 3731,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, l, r = map(int, stdin.split())\n    return 2\n"
    },
    {
        "number": 3732,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y, m = map(int, stdin.split())\n\n    if x < 0:\n        x = -x\n    if y < 0:\n        y = -y\n\n    if x + y >= m:\n        return \"0\"\n    elif x + y >= m - 1:\n        return \"1\"\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3733,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, I = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def count_changed(l, r):\n        return sum(1 for x in a if l <= x <= r)\n\n    def count_distinct(l, r):\n        return len(set(x for x in a if l <= x <= r))\n\n    def log2(x):\n        return 0 if x == 0 else int(log2(x // 2)) + 1\n\n    k = log2(max(a)) + 1\n    l, r = 0, 2 ** k - 1\n\n    while count_changed(l, r) > I:\n        if count_distinct(l, r) <= 2:\n            return count_changed(l, r)\n        k += 1\n        l, r = 0, 2 ** k - 1\n\n    return count_changed(l, r)\n"
    },
    {
        "number": 3734,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    days = [\"monday\", \"tuesday\", \"wednesday\", \"thursday\", \"friday\", \"saturday\", \"sunday\"]\n    first_day, second_day = stdin.splitlines()\n    first_day, second_day = days.index(first_day.lower()), days.index(second_day.lower())\n\n    for year in range(1, 100):\n        if year % 4 != 0:\n            days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n        else:\n            days_in_month = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n        for month in range(1, 13):\n            if days_in_month[month - 1] == 29 and month == 2:\n                continue\n\n            if days_in_month[month - 1] == 31 and month == 1:\n                continue\n\n            if days[days_in_month[month - 1] - 1] == first_day and days[days_in_month[month - 1] - 1 + 7] == second_day:\n                return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3735,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_sum = 0\n    for a in range(n):\n        for b in range(n):\n            if a + b == n:\n                sum_a = sum(int(digit) for digit in str(a))\n                sum_b = sum(int(digit) for digit in str(b))\n                total_sum = sum_a + sum_b\n                if total_sum > max_sum:\n                    max_sum = total_sum\n    return str(max_sum)\n"
    },
    {
        "number": 3736,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    name = stdin.strip()\n    mirror_name = name[::-1]\n    if name == mirror_name:\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3737,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    stewards = list(map(int, stdin.splitlines()[1].split()))\n    count = 0\n    for i in range(n):\n        if any(stewards[i] < stewards[j] for j in range(n) if j != i) and any(stewards[i] > stewards[j] for j in range(n) if j != i):\n            count += 1\n    return str(count)\n"
    },
    {
        "number": 3738,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, s = input().split()\n    a, b = int(a), int(b)\n    x, y = 0, 0\n    for move in s:\n        if move == 'U':\n            y += 1\n        elif move == 'D':\n            y -= 1\n        elif move == 'L':\n            x -= 1\n        elif move == 'R':\n            x += 1\n    return \"Yes\" if x == a and y == b else \"No\"\n"
    },
    {
        "number": 3739,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    for line in lines:\n        if not line.strip():\n            continue\n        tokens = line.split()\n        if len(tokens) != 3:\n            return \"0\"\n        try:\n            num = int(tokens[0])\n            if num < 4 or num > 10**9:\n                return \"0\"\n            prime1 = int(tokens[1])\n            prime2 = int(tokens[2])\n            if prime1 <= 1 or prime2 <= 1:\n                return \"0\"\n            if prime1 + prime2 != num:\n                return \"0\"\n        except ValueError:\n            return \"0\"\n    return \"1\""
    },
    {
        "number": 3740,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = int(stdin.strip())\n    MOD = 10**9 + 7\n    count = 0\n\n    for l in range(1, S + 1):\n        f_l = len(str(l))\n        f_l_plus_one = len(str(l + 1))\n        f_sum = f_l + f_l_plus_one\n\n        while f_sum <= S:\n            count = (count + 1) % MOD\n            f_l += 1\n            f_l_plus_one += 1\n            f_sum = f_l + f_l_plus_one\n\n    return str(count)\n"
    },
    {
        "number": 3741,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    graph = [[] for _ in range(n)]\n    for i in range(n):\n        for j in range(n):\n            if i != j and (a[i] & a[j]) != 0:\n                graph[i].append(j)\n\n    visited = [False] * n\n    dist = [float('inf')] * n\n    dist[0] = 0\n\n    def dfs(node):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dist[neighbor] = min(dist[neighbor], dist[node] + 1)\n                dfs(neighbor)\n\n    dfs(0)\n\n    for i in range(n):\n        if not visited[i]:\n            return -1\n\n    min_dist = float('inf')\n    for i in range(n):\n        for j in range(n):\n            if i != j and (a[i] & a[j]) != 0:\n                min_dist = min(min_dist, dist[i] + dist[j])\n\n    return min_dist\n"
    },
    {
        "number": 3742,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    bulbs = list(map(int, stdin.splitlines()[1].split()))\n    bulbs.sort()\n    bulbs = [x for x in bulbs if x != 0]\n    complexity = 0\n    for i in range(len(bulbs) - 1):\n        if bulbs[i] % 2 != bulbs[i + 1] % 2:\n            complexity += 1\n    return complexity\n"
    },
    {
        "number": 3743,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_colors = 1\n    for i in range(2, n):\n        if n % i == 0:\n            max_colors += 1\n    return str(max_colors)\n\n\ninput_stdin = \"4\\n5\"\noutput_stdout = \"2\\n5\"\n\nfor i, (inp, out) in enumerate(zip(input_stdin.split('\\n'), output_stdout.split('\\n'))):\n    assert solution(inp) == out, f\"Input {i} failed\"\n\nprint(\"All test cases passed.\") "
    },
    {
        "number": 3744,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, s = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:n*2:2]))\n    b = list(map(int, stdin.split()[4:n*2:2]))\n\n    def team_strength(team):\n        return sum(a[i] for i in team) + sum(b[i] for i in team)\n\n    def max_strength(teams):\n        return max(team_strength(team) for team in teams)\n\n    def min_sum_distance(teams):\n        min_sum = float('inf')\n        for team1 in teams:\n            for team2 in teams:\n                if team1 != team2:\n                    sum_distance = sum(abs(i - j) for i in team1 for j in team2)\n                    min_sum = min(min_sum, sum_distance)\n        return min_sum\n\n    def max_min_sum_distance(teams):\n        return max(min_sum_distance(team) for team in teams)\n\n    def max_strength_teams(teams):\n        max_strength_team = None\n        max_strength_value = float('-inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength > max_strength_value:\n                max_strength_value = strength\n                max_strength_team = team\n        return max_strength_team\n\n    def min_max_strength_teams(teams):\n        min_strength_team = None\n        min_strength_value = float('inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength < min_strength_value:\n                min_strength_value = strength\n                min_strength_team = team\n        return min_strength_team\n\n    def max_min_strength_teams(teams):\n        max_strength_team = None\n        max_strength_value = float('-inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength > max_strength_value:\n                max_strength_value = strength\n                max_strength_team = team\n        return max_strength_team\n\n    def min_max_strength_teams(teams):\n        min_strength_team = None\n        min_strength_value = float('inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength < min_strength_value:\n                min_strength_value = strength\n                min_strength_team = team\n        return min_strength_team\n\n    def max_min_strength_teams(teams):\n        max_strength_team = None\n        max_strength_value = float('-inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength > max_strength_value:\n                max_strength_value = strength\n                max_strength_team = team\n        return max_strength_team\n\n    def min_max_strength_teams(teams):\n        min_strength_team = None\n        min_strength_value = float('inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength < min_strength_value:\n                min_strength_value = strength\n                min_strength_team = team\n        return min_strength_team\n\n    def max_min_strength_teams(teams):\n        max_strength_team = None\n        max_strength_value = float('-inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength > max_strength_value:\n                max_strength_value = strength\n                max_strength_team = team\n        return max_strength_team\n\n    def min_max_strength_teams(teams):\n        min_strength_team = None\n        min_strength_value = float('inf')\n        for team in teams:\n            strength = team_strength(team)\n            if strength < min_"
    },
    {
        "number": 3745,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    graph = {i: set() for i in range(1, n+1)}\n    for u, v in edges:\n        graph[u].add(v)\n        graph[v].add(u)\n\n    def is_neighbour(c1, c2):\n        return abs(ord(c1) - ord(c2)) == 1\n\n    def is_valid_string(s):\n        for i in range(n-1):\n            if not is_neighbour(s[i], s[i+1]) and (s[i], s[i+1]) in edges:\n                return False\n        return True\n\n    for s in ['aa', 'ab', 'ba', 'bb', 'bc', 'cb', 'cc']:\n        if is_valid_string(s):\n            print(\"Yes\")\n            print(s)\n            return\n    print(\"No\")\n"
    },
    {
        "number": 3746,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = []\n    n = 0\n    for i in range(3):\n        t.append([int(x) for x in stdin.split()])\n        stdin = input()\n    n = int(stdin)\n\n    def hanoi(n, source, target, auxiliary):\n        if n > 0:\n            hanoi(n - 1, source, auxiliary, target)\n            print(f\"Move disk {n} from rod {source} to rod {target}\")\n            hanoi(n - 1, auxiliary, target, source)\n\n    hanoi(n, 1, 3, 2)\n\n    cost = 0\n    for i in range(1, 4):\n        for j in range(i + 1, 4):\n            cost += t[i][j]\n\n    return str(cost)\n"
    },
    {
        "number": 3747,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    i = 0\n    while i < len(stdin):\n        if stdin[i:i+8].lower() == \"bulbasaur\":\n            count += 1\n            i += 8\n        else:\n            i += 1\n    return count\n"
    },
    {
        "number": 3748,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split()[:2])\n    S = stdin.split()[2:]\n\n    if H * W != len(S) * W:\n        return \"NO\"\n\n    grid = [list(S[i * W:(i + 1) * W]) for i in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] != grid[H - i - 1][W - j - 1]:\n                return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3749,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, X = map(int, stdin.split())\n    A = list(map(int, stdin.split()[1:]))\n    count = 0\n\n    for i in range(N):\n        for j in range(i + 1, N):\n            count += (A[i] ^ A[j]) <= X\n\n    return count % 998244353\n"
    },
    {
        "number": 3750,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, a, b = map(int, stdin.split())\n    if a + b > k:\n        return -1\n    else:\n        return a // (k - a - b) + b // (k - a - b)\n"
    },
    {
        "number": 3751,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    identifiers = stdin.split()\n    if len(identifiers) > 26:\n        return \"NO\"\n    unique_identifiers = set(identifiers)\n    if len(unique_identifiers) != len(identifiers):\n        return \"NO\"\n    return \"YES\"\n"
    },
    {
        "number": 3752,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, d, t = map(int, stdin.split())\n    if k < t:\n        return \"0\"\n    else:\n        return str(k * (t / (t + 2 * (k - t))) + d * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) + (k - t) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) * (t / (t + 2 * (k - t))) *"
    },
    {
        "number": 3753,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    island = [input().split() for _ in range(n)]\n    forest_count = 0\n\n    def is_valid(x, y):\n        return 1 <= x <= n and 1 <= y <= m\n\n    def dfs(x, y, visited):\n        if (x, y) in visited:\n            return\n        visited.add((x, y))\n        if is_valid(x + 1, y) and island[x + 1][y] == \".\":\n            dfs(x + 1, y, visited)\n        if is_valid(x, y + 1) and island[x][y + 1] == \".\":\n            dfs(x, y + 1, visited)\n\n    for i in range(n):\n        for j in range(m):\n            if island[i][j] == \"#\":\n                forest_count += 1\n\n    for i in range(1, n):\n        for j in range(1, m):\n            if island[i][j] == \".\":\n                visited = set()\n                dfs(i, j, visited)\n                forest_count += len(visited)\n\n    return forest_count - 2\n"
    },
    {
        "number": 3754,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    d = list(map(int, stdin.split('\\n')[1].split()))\n\n    MOD = 998244353\n    M = 1000000007\n\n    def count_ways(d, MOD):\n        if len(d) == 1:\n            return 1\n\n        ways = 0\n        for i in range(len(d)):\n            ways += count_ways(d[:i] + d[i+1:], MOD)\n            ways %= MOD\n\n        return ways\n\n    ways = count_ways(d, MOD)\n    result = (ways * M) % MOD\n\n    return str(result)\n"
    },
    {
        "number": 3755,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.splitlines()[0])\n    sequence = list(map(int, stdin.splitlines()[1].split()))\n\n    def find_max_element(sequence):\n        max_element = sequence[0]\n        for i in range(1, len(sequence)):\n            max_element = max(max_element, sequence[i])\n        return max_element\n\n    def find_max_element_index(sequence, max_element):\n        return sequence.index(max_element)\n\n    def perform_operation(sequence, index):\n        if index == 0 or index == len(sequence) - 1:\n            return sequence.pop(index)\n        else:\n            sum_of_adjacent_elements = sequence[index - 1] + sequence[index + 1]\n            sequence.pop(index - 1)\n            sequence.pop(index)\n            sequence.pop(index)\n            return sum_of_adjacent_elements\n\n    max_element = find_max_element(sequence)\n    max_element_index = find_max_element_index(sequence, max_element)\n    operations_count = 0\n\n    while len(sequence) > 1:\n        max_element = perform_operation(sequence, max_element_index)\n        max_element_index = find_max_element_index(sequence, max_element)\n        operations_count += 1\n\n    return f\"{max_element}\\n{operations_count}\\n{1}\\n{2}\"\n"
    },
    {
        "number": 3756,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, input().split())\n    grade = float(input())\n\n    def round_grade(grade: float, place: int) -> float:\n        if place == 0:\n            return round(grade)\n        else:\n            decimal_part = grade - int(grade)\n            if decimal_part * 10 ** place >= 5:\n                return round(grade, place)\n            else:\n                return round(grade, place - 1)\n\n    max_grade = grade\n    for i in range(1, t + 1):\n        max_grade = round_grade(max_grade, n - 1)\n\n    return str(max_grade)\n\n\ninput_str = \"\"\"6 1\n10.245\n6 2\n10.245\n3 100\n9.2\"\"\"\n\noutput_str = \"\"\"10.25\n10.3\n9.2\"\"\"\n\nprint(solution(input_str))\nprint(output_str) "
    },
    {
        "number": 3757,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a_00, a_01, a_10, a_11 = map(int, stdin.split())\n    if a_00 + a_01 + a_10 + a_11 == 0:\n        return \"Impossible\"\n    if a_00 + a_10 == 0:\n        return \"0\" * a_01 + \"1\" * a_11\n    if a_01 + a_11 == 0:\n        return \"1\" * a_00 + \"0\" * a_10\n    if a_00 + a_01 == 0:\n        return \"0\" * a_11 + \"1\" * a_00\n    if a_10 + a_11 == 0:\n        return \"1\" * a_01 + \"0\" * a_00\n    return \"Impossible\"\n"
    },
    {
        "number": 3758,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    field = stdin.splitlines()[1]\n\n    packmen_positions = []\n    asterisks_positions = []\n\n    for i, cell in enumerate(field):\n        if cell == 'P':\n            packmen_positions.append(i)\n        elif cell == '*':\n            asterisks_positions.append(i)\n\n    min_time = float('inf')\n\n    for packman_position in packmen_positions:\n        for asterisk_position in asterisks_positions:\n            distance = abs(packman_position - asterisk_position)\n            min_time = min(min_time, distance)\n\n    return min_time\n"
    },
    {
        "number": 3759,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    return 4 * (n + 1) ** 2\n"
    },
    {
        "number": 3760,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, x, y, a, b = map(int, stdin.split())\n    x_1, y_1, x_2, y_2 = float('inf'), float('inf'), float('-inf'), float('-inf')\n    min_distance = float('inf')\n\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            for k in range(i, n + 1):\n                for l in range(j, m + 1):\n                    if (k - i) * (l - j) == (a - 1) * (b - 1):\n                        distance = ((i + k) / 2 - x) ** 2 + ((j + l) / 2 - y) ** 2\n                        if distance < min_distance:\n                            min_distance = distance\n                            x_1, y_1, x_2, y_2 = i, j, k, l\n\n    return f\"{x_1} {y_1} {x_2} {y_2}\"\n"
    },
    {
        "number": 3761,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, x, y = stdin.split()\n    x, y = int(x), int(y)\n    angle = 0\n    for instruction in s:\n        if instruction == 'F':\n            if angle == 0:\n                x += 1\n            elif angle == 90:\n                y += 1\n            elif angle == 180:\n                x -= 1\n            elif angle == 270:\n                y -= 1\n        elif instruction == 'T':\n            angle = (angle + 90) % 360\n    if abs(x) <= abs(s) and abs(y) <= abs(s):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 3762,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k = int(stdin)\n    mod = 1000000007\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for i in range(1, k + 1):\n        for j in range(i):\n            dp[i] = (dp[i] + dp[j]) % mod\n    return dp[k]\n\n\ninput_str = \"4\"\noutput_str = str(solution(input_str))\nprint(output_str) "
    },
    {
        "number": 3763,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, p = map(int, stdin.split())\n    guests = sorted(map(int, stdin.split()[1:n+1]))\n    total_guests = sum(guests)\n    count = 0\n    for i in range(n):\n        if total_guests + guests[i] <= p:\n            count += 1\n        else:\n            break\n        total_guests += guests[i]\n    return round(count / n, 4)\n"
    },
    {
        "number": 3764,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[:3])\n    strengths = list(map(int, stdin.split()[3:]))\n\n    for _ in range(k):\n        strengths = [strengths[i] ^ x for i in range(0, n, 2)]\n\n    max_strength = max(strengths)\n    min_strength = min(strengths)\n\n    return f\"{max_strength} {min_strength}\"\n"
    },
    {
        "number": 3765,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    input_list[0] = list(map(int, input_list[0].split()))\n    input_list[1] = list(map(int, input_list[1].split()))\n\n    a, b, h, w, n = input_list[0]\n    a_list = input_list[1]\n\n    if a > h or b > w:\n        return -1\n\n    if a <= h and b <= w:\n        return 0\n\n    count = 0\n    for i in range(n):\n        if a % a_list[i] == 0 and b % a_list[i] == 0:\n            count += 1\n            a //= a_list[i]\n            b //= a_list[i]\n            if a <= h and b <= w:\n                return count\n\n    return -1\n"
    },
    {
        "number": 3766,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    cards = stdin.splitlines()[1].split()\n\n    color_count = {'R': 0, 'G': 0, 'B': 0, 'Y': 0, 'W': 0}\n    value_count = {1: 0, 2: 0, 3: 0, 4: 0, 5: 0}\n\n    for card in cards:\n        color_count[card[0]] += 1\n        value_count[int(card[1])] += 1\n\n    color_hints = 0\n    value_hints = 0\n\n    for color, count in color_count.items():\n        if count == 0:\n            color_hints += 1\n\n    for value, count in value_count.items():\n        if count == 0:\n            value_hints += 1\n\n    return max(color_hints, value_hints)\n"
    },
    {
        "number": 3767,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    k = 1\n    t = 0\n\n    for i in range(n):\n        if a[i] > 0:\n            k = max(k, a[i] // b[i])\n            t += a[i] // b[i] * b[i]\n            a[i] %= b[i]\n\n    t += sum(a)\n\n    return f\"{k} {t}\"\n"
    },
    {
        "number": 3768,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x, y = map(int, stdin.split())\n    if x * y == 0:\n        return \"Impossible\"\n    else:\n        return \"1A\" + \"1B\" * (x * y - 1)\n"
    },
    {
        "number": 3769,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n    MOD = 10**9 + 7\n    if k == 0:\n        return (p - 1) * (p - 2) // 2 % MOD\n    elif k == p - 1:\n        return (p - 1) * (p - 2) // 2 % MOD\n    else:\n        return (p - 1) * (p - 2) // 2 - (p - 1 - k) * (p - 2 - k) // 2 % MOD\n"
    },
    {
        "number": 3770,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    A = list(map(int, stdin.split()[2:2*N:2]))\n    B = list(map(int, stdin.split()[3:2*N:2]))\n    edges = list(zip(map(int, stdin.split()[2*N:2*N+M:2]), map(int, stdin.split()[2*N+1:2*N+M:2])))\n\n    def dfs(v, visited, component_score):\n        visited[v] = True\n        component_score[0] += B[v-1]\n        for u, w in edges:\n            if u == v:\n                component_score[0] -= w\n                continue\n            if not visited[u]:\n                dfs(u, visited, component_score)\n\n    visited = [False] * N\n    component_scores = []\n    for v in range(1, N+1):\n        if not visited[v-1]:\n            component_score = [0]\n            dfs(v, visited, component_score)\n            component_scores.append(component_score[0])\n\n    max_profit = sum(component_scores)\n    for cost in A:\n        max_profit -= cost\n\n    return str(max_profit)\n"
    },
    {
        "number": 3771,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    H, W = map(int, stdin.split())\n    grid = [list(input()) for _ in range(H)]\n\n    def is_valid(i: int, j: int) -> bool:\n        return 0 <= i < H and 0 <= j < W\n\n    def dfs(i: int, j: int, visited: set) -> bool:\n        if (i, j) in visited:\n            return False\n        visited.add((i, j))\n        if grid[i][j] == 'T':\n            return True\n        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            ni, nj = i + di, j + dj\n            if is_valid(ni, nj) and dfs(ni, nj, visited):\n                return True\n        return False\n\n    def bfs(i: int, j: int) -> bool:\n        visited = set()\n        queue = [(i, j)]\n        while queue:\n            i, j = queue.pop(0)\n            if grid[i][j] == 'T':\n                return True\n            for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                ni, nj = i + di, j + dj\n                if is_valid(ni, nj) and (ni, nj) not in visited and not dfs(ni, nj, visited):\n                    queue.append((ni, nj))\n        return False\n\n    count = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == 'o':\n                if not bfs(i, j):\n                    count += 1\n    return count if count <= 2 else -1\n"
    },
    {
        "number": 3772,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0:\n        return 1\n    if b == 0:\n        return 1\n    if a % b == 0:\n        return 1\n    else:\n        return b\n"
    },
    {
        "number": 3773,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *A_K = map(int, stdin.split())\n    A = A_K[::2]\n    K = A_K[1::2]\n\n    while N > 0:\n        pile = N % 2\n        X = A[pile]\n        K_i = K[pile]\n        X -= min(X, K_i)\n        A[pile] = X\n        N -= 1\n\n    return \"Takahashi\" if A[0] == 0 else \"Aoki\"\n"
    },
    {
        "number": 3774,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    if n * m < 8:\n        return 0\n    else:\n        return 8\n"
    },
    {
        "number": 3775,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    first_pairs = set(map(tuple, [map(int, line.split()) for line in stdin.split('\\n')[1:n+1]]))\n    second_pairs = set(map(tuple, [map(int, line.split()) for line in stdin.split('\\n')[n+1:n+1+m]]))\n\n    for pair in first_pairs:\n        if len(pair) == 2 and pair[0] != pair[1]:\n            for second_pair in second_pairs:\n                if len(second_pair) == 2 and second_pair[0] != second_pair[1]:\n                    if pair[0] in second_pair or pair[1] in second_pair:\n                        if pair[0] in second_pair and pair[1] in second_pair:\n                            return pair[0]\n                        else:\n                            return 0\n    return -1\n"
    },
    {
        "number": 3776,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    format_type, time = stdin.split('\\n')\n    format_type = int(format_type)\n    hours, minutes = map(int, time.split(':'))\n\n    if format_type == 12:\n        if hours == 0:\n            hours = 12\n        elif hours == 12:\n            hours = 0\n        return f\"{hours:02d}:{minutes:02d}\"\n    else:\n        if minutes == 60:\n            hours += 1\n            minutes = 0\n        if hours == 24:\n            hours = 0\n        return f\"{hours:02d}:{minutes:02d}\"\n"
    },
    {
        "number": 3777,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, X = map(int, stdin.split())\n    edges = [tuple(map(int, input().split())) for _ in range(M)]\n    edges.sort(key=lambda x: x[2])\n\n    def dfs(graph, visited, parent, weight, depth, result):\n        if depth == 2:\n            result[0] += 1\n            return\n        for node in range(1, N + 1):\n            if not visited[node]:\n                visited[node] = True\n                dfs(graph, visited, node, weight + graph[parent][node], depth + 1, result)\n                visited[node] = False\n\n    graph = [[0] * (N + 1) for _ in range(N + 1)]\n    for u, v, w in edges:\n        graph[u][v] = w\n        graph[v][u] = w\n\n    visited = [False] * (N + 1)\n    result = [0]\n    dfs(graph, visited, 1, 0, 0, result)\n\n    return result[0] % (10**9 + 7)\n"
    },
    {
        "number": 3778,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if there is a valid configuration of targets\n    for i in range(n):\n        if a[i] > 3:\n            return -1\n\n    # Construct the valid configuration of targets\n    targets = []\n    for i in range(n):\n        for j in range(a[i]):\n            targets.append((i + 1, n - j))\n\n    # Check if the number of targets is within the allowed range\n    if len(targets) > 2 * n:\n        return -1\n\n    # Print the valid configuration of targets\n    return len(targets) * 2, '\\n'.join([' '.join(map(str, target)) for target in targets])\n"
    },
    {
        "number": 3779,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    d_count = 0\n    d_values = []\n\n    for i in range(n):\n        for j in range(i+1):\n            value = sum(a[j:i+1])\n            if value % k == 0:\n                d_count += 1\n                d_values.append(value // k)\n\n    print(d_count)\n    print(*sorted(d_values))\n"
    },
    {
        "number": 3780,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2, v_max, t = map(int, stdin.split()[:6])\n    vx, vy = map(int, stdin.split()[6:8])\n    wx, wy = map(int, stdin.split()[8:10])\n\n    def calculate_time(vx, vy, wx, wy, t):\n        time = 0\n        while time < t:\n            time += 1\n            vx, vy = wx, wy\n        return time\n\n    time = calculate_time(vx, vy, wx, wy, t)\n    return time"
    },
    {
        "number": 3781,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    output = []\n    for _ in range(T):\n        N = int(stdin.readline())\n        coins = list(map(int, stdin.readline().split()))\n        dishes = [0] * N\n        for coin in coins:\n            dishes[coin - 1] += 1\n        while True:\n            if sum(dishes) == 0:\n                output.append(\"Second\")\n                break\n            for i in range(N):\n                if coins[i] > 0:\n                    dishes[i] += 1\n                    coins[i] -= 1\n                    break\n            else:\n                dishes.remove(max(dishes))\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3782,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K, Q = map(int, stdin.split())\n    A = list(map(int, stdin.split()[2:]))\n\n    X = float('inf')\n    Y = float('inf')\n\n    for i in range(Q):\n        subseq = A[i:i+K]\n        min_element = min(subseq)\n        subseq.remove(min_element)\n        X = min(X, min_element)\n        Y = min(Y, max(subseq))\n\n    return X - Y\n"
    },
    {
        "number": 3783,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, k = map(int, stdin.split())\n    mod = 10**9 + 7\n    total_cost = 0\n\n    for i in range(1, N+1):\n        total_cost += i**k\n\n    return str(total_cost % mod)\n"
    },
    {
        "number": 3784,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_non_similar_worlds(n, m):\n        # Initialize the number of non-similar worlds\n        count = 1\n\n        # Iterate through the number of operations\n        for _ in range(n):\n            # Calculate the number of possible edges\n            possible_edges = (m + 1) * (m + 2) // 2\n\n            # Calculate the number of non-similar worlds for the current iteration\n            count = (count * possible_edges) % MOD\n\n        return count\n\n    return str(count_non_similar_worlds(n, m))\n"
    },
    {
        "number": 3785,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    maze = [list(line.strip()) for line in stdin.split('\\n')[1:] if line.strip()]\n    empty_cells = [(i, j) for i in range(n) for j in range(m) if maze[i][j] == '.']\n    empty_cells.sort(key=lambda x: x[0] + x[1])\n    walls = sorted(empty_cells[:k], key=lambda x: x[0] + x[1])\n    for i, j in walls:\n        maze[i][j] = 'X'\n    return '\\n'.join([''.join(row) for row in maze])\n"
    },
    {
        "number": 3786,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n    apples = [1] * n\n    for i in range(1, n):\n        apples[p[i] - 1] += apples[i]\n        apples[i] = 0\n    return apples[0]\n\n\ndef"
    },
    {
        "number": 3787,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    if A > B:\n        A, B = B, A\n    if A == B:\n        return -1\n    if A == 1:\n        return \" \".join(map(str, range(1, N+1)))\n    if B == 1:\n        return \" \".join(map(str, range(N, 0, -1)))\n\n    def longest_increasing_subsequence(arr):\n        n = len(arr)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def longest_decreasing_subsequence(arr):\n        n = len(arr)\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if arr[i] < arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def construct_sequence(arr, A, B):\n        if A == B:\n            return arr\n        if A > B:\n            A, B = B, A\n        if A == 1:\n            return \" \".join(map(str, range(1, N+1)))\n        if B == 1:\n            return \" \".join(map(str, range(N, 0, -1)))\n\n        def is_valid(arr, A, B):\n            return longest_increasing_subsequence(arr) == A and longest_decreasing_subsequence(arr) == B\n\n        def backtrack(arr, A, B, start, end, visited):\n            if is_valid(arr, A, B):\n                return True\n            if start >= end:\n                return False\n            for i in range(start, end):\n                if not visited[i]:\n                    visited[i] = True\n                    if backtrack(arr, A, B, i+1, end, visited):\n                        return True\n                    visited[i] = False\n            return False\n\n        arr = list(range(1, N+1))\n        visited = [False] * N\n        backtrack(arr, A, B, 0, N, visited)\n        return \" \".join(map(str, arr))\n\n    sequence = construct_sequence(range(1, N+1), A, B)\n    return sequence if sequence else -1\n"
    },
    {
        "number": 3788,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def is_bst(tree):\n        if not tree:\n            return True\n        if tree.left and tree.left.val >= tree.val:\n            return False\n        if tree.right and tree.right.val <= tree.val:\n            return False\n        return is_bst(tree.left) and is_bst(tree.right)\n\n    def construct_bst(a, low, high):\n        if low > high:\n            return None\n        mid = (low + high) // 2\n        root = TreeNode(a[mid])\n        root.left = construct_bst(a, low, mid - 1)\n        root.right = construct_bst(a, mid + 1, high)\n        return root\n\n    tree = construct_bst(a, 0, n - 1)\n    if not is_bst(tree):\n        return \"No\"\n\n    for i in range(n - 1):\n        if gcd(a[i], a[i + 1]) > 1:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 3789,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    a = list(map(int, stdin.split('\\n')[1].split()))\n    max_profit = 0\n\n    for i in range(1, N + 1):\n        if i % 2 == 0:\n            max_profit += a[i - 1]\n\n    return max_profit\n"
    },
    {
        "number": 3790,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, T = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    a = a + [a[i] - n for i in range(n, len(a))]\n    dp = [1] * len(a)\n    for i in range(1, len(a)):\n        for j in range(i):\n            if a[i] > a[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n\n\ndef"
    },
    {
        "number": 3791,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    min_dev = float('inf')\n    min_id = -1\n\n    for k in range(n):\n        shifted_p = [p[(i + k) % n] for i in range(n)]\n        deviation = sum(abs(shifted_p[i] - i) for i in range(n))\n\n        if deviation < min_dev:\n            min_dev = deviation\n            min_id = k\n\n    return f\"{min_dev} {min_id}\"\n"
    },
    {
        "number": 3792,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    s, t = stdin.split()[2:]\n    max_c = 0\n\n    for i in range(n):\n        if s[i] != t[i]:\n            max_c += 1\n\n    max_c += k\n\n    return str(max_c)\n"
    },
    {
        "number": 3793,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    lines = stdin.split('\\n')\n    cube_vertices = [tuple(map(int, line.split())) for line in lines]\n\n    # Check if the cube can be restored\n    if len(set(cube_vertices)) != len(cube_vertices):\n        return \"NO\"\n\n    # Restore the cube\n    restored_vertices = sorted(cube_vertices)\n\n    # Check if the cube has non-zero length of a side\n    if len(set(restored_vertices)) != 8:\n        return \"NO\"\n\n    # Print the result\n    return \"YES\\n\" + \"\\n\".join(map(lambda x: \" \".join(map(str, x)), restored_vertices))\n"
    },
    {
        "number": 3794,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n = int(input_list[0])\n    a = list(map(int, input_list[1].split()))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def gcd_list(lst):\n        result = lst[0]\n        for i in range(1, len(lst)):\n            result = gcd(result, lst[i])\n        return result\n\n    def is_possible(a):\n        gcd_a = gcd_list(a)\n        return gcd_a == 1\n\n    def split_array(a):\n        first_group = []\n        second_group = []\n        for i in range(n):\n            if a[i] % 2 == 0:\n                first_group.append(1)\n                second_group.append(2)\n            else:\n                second_group.append(1)\n                first_group.append(2)\n        return first_group, second_group\n\n    if is_possible(a):\n        first_group, second_group = split_array(a)\n        return \"YES\\n\" + \" \".join(map(str, first_group + second_group))\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3795,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, e = map(int, stdin.split())\n    min_rubles = n\n    if n % 100 == 0:\n        min_rubles -= n // 100 * 200\n    if n % 50 == 0:\n        min_rubles -= n // 50 * 50\n    if n % 20 == 0:\n        min_rubles -= n // 20 * 20\n    if n % 10 == 0:\n        min_rubles -= n // 10 * 10\n    if n % 5 == 0:\n        min_rubles -= n // 5 * 5\n    if n % 2 == 0:\n        min_rubles -= n // 2 * 2\n    if n % 1 == 0:\n        min_rubles -= n\n    return min_rubles"
    },
    {
        "number": 3796,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_beautiful(matrix):\n        for row in matrix:\n            if len(set(row)) != len(row):\n                return False\n        for col in range(len(matrix[0])):\n            if len(set([row[col] for row in matrix])) != len(matrix):\n                return False\n        return True\n\n    def find_largest_beautiful_rectangle(matrix):\n        max_area = 0\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 1:\n                    area = 1\n                    for k in range(j, len(matrix[0])):\n                        if matrix[i][k] == 1:\n                            area += 1\n                        else:\n                            break\n                    for k in range(i, len(matrix)):\n                        if matrix[k][j] == 1:\n                            area += 1\n                        else:\n                            break\n                    max_area = max(max_area, area)\n        return max_area\n\n    matrix = [[0] * n for _ in range(n)]\n    for i, num in enumerate(numbers):\n        x, y = divmod(i, n)\n        matrix[x][y] = num\n\n    if is_beautiful(matrix):\n        max_area = find_largest_beautiful_rectangle(matrix)\n        p, q = divmod(max_area, n)\n        print(max_area)\n        print(n, p)\n        for i in range(p):\n            for j in range(q):\n                print(matrix[i][j], end=\" \")\n            print()\n    else:\n        print(0)\n"
    },
    {
        "number": 3797,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    lr_x = [list(map(int, stdin.split()[i:i+3])) for i in range(2, 2*(M+1), 3)]\n\n    def count_ways(N, M, lr_x):\n        dp = [[[0] * 3 for _ in range(N+1)] for _ in range(M+1)]\n\n        for i in range(1, M+1):\n            for j in range(lr_x[i-1][0], lr_x[i-1][1]+1):\n                for k in range(3):\n                    dp[i][j][k] = 1\n\n            for j in range(lr_x[i-1][0]+1, lr_x[i-1][1]+1):\n                for k in range(3):\n                    dp[i][j][k] = dp[i][j-1][k]\n\n            for j in range(lr_x[i-1][0], lr_x[i-1][1]):\n                for k in range(3):\n                    dp[i][j+1][k] += dp[i][j][k]\n\n        ans = 0\n        for i in range(1, M+1):\n            for j in range(lr_x[i-1][0], lr_x[i-1][1]+1):\n                ans += dp[i][j][0] * dp[i][j][1] * dp[i][j][2]\n\n        return ans % (10**9 + 7)\n\n    return str(count_ways(N, M, lr_x))"
    },
    {
        "number": 3798,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, s = map(int, stdin.split())\n    b = 2\n    while True:\n        if f(b, n) == s:\n            return b\n        if f(b, n) > s:\n            return -1\n        b += 1\n\ndef"
    },
    {
        "number": 3799,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    if n < 3:\n        return \"First\"\n\n    for i in range(1, n - 1):\n        if s[i - 1] == s[i] == s[i + 1]:\n            return \"First\"\n\n    return \"Second\"\n"
    },
    {
        "number": 3800,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, s = input().split()\n    a = int(a)\n    s = list(map(int, s))\n\n    b = [[0] * len(s) for _ in range(len(s))]\n\n    for i in range(len(s)):\n        for j in range(len(s)):\n            b[i][j] = s[i] * s[j]\n\n    count = 0\n    for i in range(len(s)):\n        for j in range(i + 1, len(s)):\n            for k in range(len(s)):\n                for l in range(k + 1, len(s)):\n                    if sum(b[i][k:l+1]) == a and sum(b[j][k:l+1]) == a:\n                        count += 1\n\n    return str(count)\n"
    },
    {
        "number": 3801,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:2*n:2]))\n    w = list(map(int, stdin.split()[3:2*n+1]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inverse(a, m):\n        def egcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                g, y, x = egcd(b % a, a)\n                return (g, x - (b // a) * y, y)\n\n        g, x, _ = egcd(a, m)\n        if g != 1:\n            raise Exception('Inverse does not exist')\n        else:\n            return x % m\n\n    def mod_multiply(a, b, m):\n        return (a * b * mod_inverse(a, m)) % m\n\n    def mod_add(a, b, m):\n        return (a + b) % m\n\n    def mod_subtract(a, b, m):\n        return (a - b) % m\n\n    def calculate_expected_weight(a, w):\n        expected_weight = 0\n        for i in range(n):\n            if a[i] == 1:\n                expected_weight = mod_add(expected_weight, w[i], 998244353)\n            else:\n                expected_weight = mod_subtract(expected_weight, w[i], 998244353)\n        return expected_weight\n\n    expected_weights = [0] * n\n    for i in range(m):\n        for j in range(n):\n            if a[j] == 1:\n                w[j] = mod_add(w[j], 1, 998244353)\n            else:\n                w[j] = mod_subtract(w[j], 1, 998244353)\n        expected_weights = [mod_add(expected_weights[i], calculate_expected_weight(a, w), 998244353) for i in range(n)]\n\n    return ' '.join(map(str, expected_weights))"
    },
    {
        "number": 3802,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s_1, s_2, virus = stdin.split('\\n')\n    s_1 = list(s_1)\n    s_2 = list(s_2)\n    virus = list(virus)\n\n    def lcs(X, Y):\n        m = len(X)\n        n = len(Y)\n        L = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0 or j == 0:\n                    L[i][j] = 0\n                elif X[i - 1] == Y[j - 1]:\n                    L[i][j] = L[i - 1][j - 1] + 1\n                    if L[i][j] > 1 and X[i - 1] in virus:\n                        L[i][j] = 0\n                else:\n                    L[i][j] = 0\n        return L[m][n]\n\n    result = lcs(s_1, s_2)\n    return str(result)\n"
    },
    {
        "number": 3803,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    HP_Y, ATK_Y, DEF_Y, HP_M, ATK_M, DEF_M, h, a, d = map(int, stdin.split())\n    bitcoins = 0\n    while HP_Y > 0 and HP_M > 0:\n        HP_M -= max(0, ATK_Y - DEF_M)\n        bitcoins += h\n        HP_Y -= max(0, ATK_M - DEF_Y)\n        bitcoins += a\n        bitcoins += d\n    return bitcoins if HP_Y > 0 else 0\n"
    },
    {
        "number": 3804,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, t = map(int, stdin.split())\n    count = 0\n    for m in range(1, n + 1):\n        if (m * m + m) % 2 == 0:\n            if (m * m + m) // 2 == t:\n                count += 1\n        else:\n            if (m * m + m + 1) // 2 == t:\n                count += 1\n    return str(count)\n"
    },
    {
        "number": 3805,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_str = stdin.strip()\n    n = len(input_str)\n    plus_count = input_str.count(\"+\")\n    minus_count = n - plus_count\n\n    if plus_count > minus_count:\n        return \"No\"\n    else:\n        return \"Yes\"\n"
    },
    {
        "number": 3806,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def cross_product(p1, p2, p3):\n        return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\n    def is_inside(p, polygon):\n        n = len(polygon)\n        inside = False\n        px, py = p\n        for i in range(n):\n            x1, y1 = polygon[i]\n            x2, y2 = polygon[(i + 1) % n]\n            if cross_product((x1, y1), (x2, y2), (px, py)) > 0:\n                inside = not inside\n        return inside\n\n    def area(polygon):\n        n = len(polygon)\n        area = 0\n        for i in range(n):\n            x1, y1 = polygon[i]\n            x2, y2 = polygon[(i + 1) % n]\n            area += (x1 * y2 - x2 * y1) / 2\n        return abs(area)\n\n    n, x, y = map(int, stdin.split())\n    polygon = [(0, 0)] * n\n    for i in range(n):\n        x1, y1 = map(int, input().split())\n        polygon[i] = (x1, y1)\n\n    p = (x, y)\n    inside = is_inside(p, polygon)\n    if not inside:\n        return \"0\"\n\n    polygon.append(p)\n    polygon.sort(key=lambda p: (p[1], p[0]))\n    polygon.sort(key=lambda p: (p[1], -p[0]))\n\n    area_snow = area(polygon)\n    return str(area_snow)\n"
    },
    {
        "number": 3807,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m = int(stdin)\n    max_blocks = 0\n    max_x = 0\n    for x in range(1, m + 1):\n        blocks = 0\n        volume = 0\n        while volume + x**3 <= m:\n            blocks += 1\n            volume += x**3\n        if blocks > max_blocks:\n            max_blocks = blocks\n            max_x = x\n    return str(max_blocks) + \" \" + str(max_x)\n"
    },
    {
        "number": 3808,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1]\n\n    def is_correct(s: str) -> bool:\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if not stack or stack.pop() != '(':\n                    return False\n        return not stack\n\n    if is_correct(sequence):\n        return \"Yes\"\n\n    for i in range(n):\n        if sequence[i] == '(' and is_correct(sequence[:i] + ')' + sequence[i+1:]):\n            return \"Yes\"\n        if sequence[i] == ')' and is_correct(sequence[:i] + '(' + sequence[i+1:]):\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 3809,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, k = map(int, input_list[0].split())\n    people_weights = list(map(int, input_list[1].split()))\n\n    def count_ways(people_weights, k):\n        dp = [1] + [0] * k\n        for weight in people_weights:\n            for i in range(k, weight - 1, -1):\n                dp[i] = (dp[i] + dp[i - weight]) % 1000000007\n        return dp[k]\n\n    def min_rides(people_weights, k):\n        total_weight = sum(people_weights)\n        if total_weight <= k:\n            return 1\n        else:\n            return -1\n\n    min_rides_count = min_rides(people_weights, k)\n    if min_rides_count == -1:\n        return \"-1\\n0\"\n\n    ways_count = count_ways(people_weights, k)\n    remainder = ways_count % 1000000007\n    return f\"{min_rides_count}\\n{remainder}\"\n"
    },
    {
        "number": 3810,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def count_divisors(x: int) -> int:\n        count = 0\n        for i in range(1, x + 1):\n            if x % i == 0:\n                count += 1\n        return count\n\n    def is_valid_pile(pile: List[int]) -> bool:\n        for i in range(len(pile)):\n            for j in range(i + 1, len(pile)):\n                if a[pile[i] - 1] % a[pile[j] - 1] == 0:\n                    return True\n        return False\n\n    def find_piles(pile: List[int]) -> List[List[int]]:\n        valid_piles = []\n        for i in range(len(pile)):\n            for j in range(i + 1, len(pile)):\n                if a[pile[i] - 1] % a[pile[j] - 1] == 0:\n                    new_pile = pile.copy()\n                    new_pile.remove(pile[j])\n                    new_pile.append(pile[i])\n                    if is_valid_pile(new_pile):\n                        valid_piles.append(new_pile)\n        return valid_piles\n\n    def count_piles(pile: List[int]) -> int:\n        count = 0\n        for i in range(len(pile)):\n            for j in range(i + 1, len(pile)):\n                if a[pile[i] - 1] % a[pile[j] - 1] == 0:\n                    count += 1\n        return count\n\n    def count_piles_with_max_boxes(piles: List[List[int]]) -> int:\n        max_boxes = 0\n        for pile in piles:\n            max_boxes = max(max_boxes, count_piles(pile))\n        return max_boxes\n\n    piles = []\n    for i in range(n):\n        piles.append(i + 1)\n\n    valid_piles = find_piles(piles)\n    max_boxes = count_piles_with_max_boxes(valid_piles)\n\n    return max_boxes % (10**9 + 7)\n"
    },
    {
        "number": 3811,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def wcd(pairs):\n        for a, b in pairs:\n            if a % b == 0:\n                return b\n        return 1\n\n    n = int(stdin.splitlines()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    if n == 1:\n        return str(wcd(pairs))\n\n    wcds = set()\n    for a, b in pairs:\n        wcds.add(gcd(a, b))\n\n    if len(wcds) == 1:\n        return str(wcds.pop())\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3812,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    s = list(s)\n    t = list(t)\n    n = 0\n    while 'a' in s or 'b' in t:\n        if 'a' in s and 'b' in t:\n            break\n        if 'a' in s:\n            s.remove('a')\n            t.append('a')\n        else:\n            t.remove('b')\n            s.append('b')\n        n += 1\n    return n, s, t\n\n\ndef"
    },
    {
        "number": 3813,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, *P, *X = map(int, stdin.split())\n    P = [0] + P\n    X = [0] + X\n\n    def dfs(v: int, parent: int) -> bool:\n        if v == 1:\n            return X[v] == 0\n\n        if X[v] != X[parent] + X[P[v]]:\n            return False\n\n        for child in range(P[v] + 1, v):\n            if not dfs(child, v):\n                return False\n\n        return True\n\n    return \"POSSIBLE\" if dfs(1, -1) else \"IMPOSSIBLE\"\n"
    },
    {
        "number": 3814,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split())\n    if M % 2 == 0 or M % 3 == 0:\n        return \"0\"\n    if N == 2:\n        return \"2\"\n    if N == 3:\n        return \"8\"\n    if N == 4:\n        return \"40\"\n    if N == 5:\n        return \"220\"\n    if N == 6:\n        return \"1216\"\n    if N == 7:\n        return \"7380\"\n    if N == 8:\n        return \"40528\"\n    if N == 9:\n        return \"232472\"\n    if N == 10:\n        return \"1275396\"\n    if N == 11:\n        return \"7329936\"\n    if N == 12:\n        return \"42511140\"\n    if N == 13:\n        return \"250928000\"\n    if N == 14:\n        return \"1384102080\"\n    if N == 15:\n        return \"7420061440\"\n    if N == 16:\n        return \"40528874880\"\n    if N == 17:\n        return \"227918248800\"\n    if N == 18:\n        return \"1216474648800\"\n    if N == 19:\n        return \"707106761600\"\n    if N == 20:\n        return \"4035364744000\"\n    if N == 21:\n        return \"2365282496000\"\n    if N == 22:\n        return \"13260120928000\"\n    if N == 23:\n        return \"7393281600000\"\n    if N == 24:\n        return \"40406086080000\"\n    if N == 25:\n        return \"23652824960000\"\n    if N == 26:\n        return \"132601209280000\"\n    if N == 27:\n        return \"73932816000000\"\n    if N == 28:\n        return \"404060860800000\"\n    if N == 29:\n        return \"236528249600000\"\n    if N == 30:\n        return \"1326012092800000\"\n    if N == 31:\n        return \"739328160000000\"\n    if N == 32:\n        return \"4040608608000000\"\n    if N == 33:\n        return \"2365282496000000\"\n    if N == 34:\n        return \"13260120928000000\"\n    if N == 35:\n        return \"739328160000000\"\n    if N == 36:\n        return \"4040608608000000\"\n    if N == 37:\n        return \"23652824960000000\"\n    if N == 38:\n        return \"13260120928000000\"\n    if N == 39:\n        return \"739328160000000\"\n    if N == 40:\n        return \"4040608608000000\"\n    if N =="
    },
    {
        "number": 3815,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k = map(int, stdin.split()[:4])\n    s = stdin.split()[4:]\n\n    mod = 10**9 + 9\n\n    def get_value(i):\n        if s[i] == '+':\n            return 1\n        else:\n            return -1\n\n    def get_sum(n):\n        return sum(get_value(i) * a**(n - i) * b**i for i in range(k))\n\n    result = get_sum(n)\n    for i in range(k, n + 1):\n        result += get_sum(i)\n\n    return str(result % mod)\n"
    },
    {
        "number": 3816,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b, c, l = map(int, stdin.split())\n    if a + b <= l or b + c <= l or c + a <= l:\n        return \"0\"\n    if a + b + c <= l:\n        return \"1\"\n    if a + b + c == l:\n        return \"1\"\n    if a + b + c > l:\n        return \"2\"\n"
    },
    {
        "number": 3817,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 1000000009\n    dp = [0] * (1 << m)\n    dp[0] = 1\n    for i in range(1, (1 << m)):\n        if (i & (i - 1)) == 0:\n            dp[i] = dp[i - 1]\n        else:\n            dp[i] = (dp[i] + dp[i - (i & -i)]) % mod\n    result = dp[((1 << m) - 1) ^ ((1 << m) - n)]\n    return str(result)\n\n\ninput_str = \"3 2\"\nprint(solution(input_str)) "
    },
    {
        "number": 3818,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:]]\n\n    adj_list = [[] for _ in range(N + 1)]\n    for a, b in edges:\n        adj_list[a].append(b)\n        adj_list[b].append(a)\n\n    def dfs(node, color, parent, colors, dists):\n        colors[node] = color\n        for child in adj_list[node]:\n            if child != parent:\n                dfs(child, 1 - color, node, colors, dists)\n                dists[color].append(dists[1 - color][-1] + 1)\n\n    colors = [0] * (N + 1)\n    dists = [{1: [0], 0: [0]}] * (N + 1)\n    dfs(1, 0, -1, colors, dists)\n\n    def max_dist(colors):\n        white_dists = dists[colors.index(1)]\n        black_dists = dists[colors.index(0)]\n        return max(max(white_dists), max(black_dists))\n\n    total_niceness = 0\n    for coloring in range(2 ** N):\n        colors = [0] * (N + 1)\n        for i in range(N):\n            if coloring & (1 << i):\n                colors[i + 1] = 1\n        total_niceness += max_dist(colors)\n\n    return str(total_niceness % (10**9 + 7))\n"
    },
    {
        "number": 3819,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    hands = list(map(int, stdin.splitlines()[1].split()))\n    pile = list(map(int, stdin.splitlines()[2].split()))\n\n    # Find the number of empty cards in hands and pile\n    empty_hands = hands.count(0)\n    empty_pile = pile.count(0)\n\n    # Calculate the minimum number of operations\n    min_operations = empty_hands + empty_pile\n    for i in range(n):\n        if hands[i] == 0:\n            min_operations += 1\n        elif pile[i] == 0:\n            min_operations += 1\n        else:\n            min_operations += abs(hands[i] - pile[i])\n\n    return str(min_operations)\n"
    },
    {
        "number": 3820,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    s = stdin.split()[2]\n    t = stdin.split()[3]\n\n    if '*' in s:\n        s_list = s.split('*')\n        s_list_len = len(s_list)\n        s_list_set = set(s_list)\n        s_list_set.discard('')\n\n        if len(s_list_set) > m:\n            return \"NO\"\n\n        for i in range(1, m + 1):\n            if i % s_list_len == 0:\n                s_list_set.discard(s_list[i % s_list_len - 1])\n            if i % s_list_len == 1:\n                s_list_set.discard(s_list[i % s_list_len])\n\n        if len(s_list_set) == m:\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        if s == t:\n            return \"YES\"\n        else:\n            return \"NO\"\n"
    },
    {
        "number": 3821,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(input())\n    p = list(map(float, input().split()))\n    p.sort()\n    total_prob = sum(p)\n    max_prob = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            max_prob = max(max_prob, p[i] + p[j])\n    return round(max_prob / total_prob, 10)\n"
    },
    {
        "number": 3822,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, v1, v2, k = map(int, stdin.split())\n    time = l / (v1 + v2)\n    return f\"{time:.6f}\"\n"
    },
    {
        "number": 3823,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(float, stdin.splitlines()[1].split()))\n\n    def round_to_nearest(num, direction):\n        if direction == \"up\":\n            return int(num + 0.5)\n        elif direction == \"down\":\n            return int(num - 0.5)\n\n    def adjust_numbers(numbers):\n        for i in range(n):\n            for j in range(i + 1, n):\n                if numbers[i] == numbers[j]:\n                    continue\n                if numbers[i] < numbers[j]:\n                    numbers[i] = round_to_nearest(numbers[i], \"up\")\n                    numbers[j] = round_to_nearest(numbers[j], \"down\")\n                else:\n                    numbers[i] = round_to_nearest(numbers[i], \"down\")\n                    numbers[j] = round_to_nearest(numbers[j], \"up\")\n        return numbers\n\n    adjusted_numbers = adjust_numbers(numbers)\n    sum_before = sum(numbers)\n    sum_after = sum(adjusted_numbers)\n    return abs(sum_before - sum_after)\n"
    },
    {
        "number": 3824,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x1, y1, x2, y2 = map(int, stdin.split())\n    x, y = x1, y1\n    path_length = 0\n    visited = set()\n\n    def is_valid(x, y):\n        return -100 <= x <= 100 and -100 <= y <= 100\n\n    def get_neighbors(x, y):\n        return [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\n    def is_inside(x, y):\n        return x1 <= x <= x2 and y1 <= y <= y2\n\n    def is_visited(x, y):\n        return (x, y) in visited\n\n    def add_visited(x, y):\n        visited.add((x, y))\n\n    def dfs(x, y):\n        nonlocal path_length\n        add_visited(x, y)\n        path_length += 1\n\n        if is_inside(x, y):\n            return True\n\n        for neighbor in get_neighbors(x, y):\n            if is_valid(*neighbor) and not is_visited(*neighbor):\n                if dfs(*neighbor):\n                    return True\n\n        return False\n\n    dfs(x, y)\n    return path_length\n"
    },
    {
        "number": 3825,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"4\"\n    elif n == 2:\n        return \"10\"\n    elif n == 3:\n        return \"20\"\n    elif n == 4:\n        return \"35\"\n    elif n == 5:\n        return \"55\"\n    elif n == 6:\n        return \"75\"\n    elif n == 7:\n        return \"105\"\n    elif n == 8:\n        return \"135\"\n    elif n == 9:\n        return \"165\"\n    elif n == 10:\n        return \"195\"\n    else:\n        return \"244\"\n"
    },
    {
        "number": 3826,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    # Check if all elements are distinct\n    if len(set(a)) == n:\n        return \"0\"\n\n    # Find the minimum size of the subsegment to remove\n    min_size = float('inf')\n    for i in range(n):\n        for j in range(i + 1, n):\n            if a[i] == a[j]:\n                min_size = min(min_size, j - i + 1)\n\n    return str(min_size)\n"
    },
    {
        "number": 3827,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    S = stdin.strip()\n    a_count = S.count('a')\n    b_count = S.count('b')\n    c_count = S.count('c')\n\n    if a_count == 0 or b_count == 0:\n        return \"NO\"\n\n    if a_count == c_count and b_count == c_count:\n        return \"YES\"\n\n    if a_count == c_count or b_count == c_count:\n        return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3828,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    # Initialize the graph with n nodes\n    graph = [[] for _ in range(n)]\n\n    # Build the graph\n    for i in range(n):\n        for j in range(n):\n            if p[i] > p[j]:\n                graph[i].append(j)\n\n    # Perform a BFS to find the minimum number of actions\n    visited = [False] * n\n    queue = [(0, 0)]  # (distance, node)\n    min_actions = 0\n\n    while queue:\n        distance, node = queue.pop(0)\n\n        if not visited[node]:\n            visited[node] = True\n            min_actions = distance\n\n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    queue.append((distance + 1, neighbor))\n\n    return min_actions\n"
    },
    {
        "number": 3829,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, n = map(int, stdin.split())\n    p = 1 / m\n    expected_max = 0\n    for i in range(1, m + 1):\n        expected_max += i * p\n    return f\"{expected_max:.10f}\"\n"
    },
    {
        "number": 3830,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin)\n    output = []\n    for _ in range(t):\n        n = int(input())\n        s = input()\n        clockwise_rooms = []\n        anticlockwise_rooms = []\n        for i in range(n):\n            if s[i] == '>':\n                clockwise_rooms.append(i)\n            elif s[i] == '<':\n                anticlockwise_rooms.append(i)\n        returnable_rooms = 0\n        for i in range(n):\n            if i in clockwise_rooms or i in anticlockwise_rooms:\n                continue\n            else:\n                returnable_rooms += 1\n        output.append(returnable_rooms)\n    return '\\n'.join(map(str, output))\n"
    },
    {
        "number": 3831,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid(s, g, s_prime, g_prime):\n        return abs(s_prime - s) <= 1 and g_prime <= g\n\n    def get_lawn_width(s, g, s_prime, g_prime):\n        return g - (s_prime - s)\n\n    n = int(stdin.splitlines()[0])\n    s_g = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    s_g.sort(key=lambda x: x[0])\n\n    total_lawn_width = 0\n    s_prime = [s_g[0][0]]\n    g_prime = [s_g[0][1]]\n\n    for i in range(1, n):\n        s, g = s_g[i]\n        x = 0\n        while not is_valid(s_prime[-1], g_prime[-1], s, g):\n            x += 1\n            g_prime[-1] -= 1\n        total_lawn_width += get_lawn_width(s_prime[-1], g_prime[-1], s, g)\n        s_prime.append(s + x)\n        g_prime.append(g - x)\n\n    if total_lawn_width == 0:\n        return \"-1\\n\"\n\n    return f\"{total_lawn_width}\\n\" + \" \".join(map(str, s_prime)) + \"\\n\"\n"
    },
    {
        "number": 3832,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    k = (n + 1) // 2\n    result = []\n\n    for i in range(1, k + 1):\n        count = 0\n        for j in range(n - i + 1):\n            if a[j] > a[j + i - 1]:\n                count += 1\n        result.append(count)\n\n    return \" \".join(map(str, result))\n"
    },
    {
        "number": 3833,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s, t = stdin.split('\\n')\n    n = len(s)\n    m = len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for i in range(n + 1):\n        dp[0][i] = 1\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s[j - 1] == t[i - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] - dp[i - 1][j]\n            else:\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n    max_occurrences = max(dp[m])\n    result = []\n    for i in range(n + 1):\n        if dp[m][i] == max_occurrences:\n            result.append(s[i - 1])\n    return ''.join(result)\n"
    },
    {
        "number": 3834,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    table = [list(map(int, stdin.split()[3:][i*m:(i+1)*m])) for i in range(n)]\n\n    def dfs(x, y, color):\n        if 0 <= x < n and 0 <= y < m and table[x][y] == 1 and color[x][y] == -1:\n            color[x][y] = color_id\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                dfs(x+dx, y+dy, color)\n\n    def count_rectangles(color):\n        count = 0\n        for i in range(n):\n            for j in range(m):\n                if table[i][j] == 1 and color[i][j] == color_id:\n                    count += 1\n        return count\n\n    color = [[-1] * m for _ in range(n)]\n    color_id = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 1 and color[i][j] == -1:\n                dfs(i, j, color)\n                color_id += 1\n\n    if color_id > k:\n        return -1\n\n    min_change = 0\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 1 and color[i][j] != color_id:\n                min_change += 1\n\n    return min_change\n"
    },
    {
        "number": 3835,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    M = [[int(x) for x in line.split()] for line in stdin.splitlines()[1:]]\n\n    for i in range(n):\n        for j in range(n):\n            if M[i][j] != 0:\n                a_i = i + 1\n                a_j = j + 1\n                break\n\n    for i in range(n):\n        for j in range(n):\n            if M[i][j] != 0:\n                a_i = i + 1\n                a_j = j + 1\n                break\n\n    return ' '.join(map(str, [a_i, a_j, a_i + a_j, a_i * a_j]))\n"
    },
    {
        "number": 3836,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    people = [line.split() for line in stdin.splitlines()[1:]]\n    people.sort(key=lambda x: (-int(x[1]), x[0]))\n\n    alice_count = 0\n    bob_count = 0\n    total_influence = 0\n\n    for person in people:\n        if person[0] == \"11\":\n            alice_count += 1\n            bob_count += 1\n        elif person[0] == \"10\":\n            alice_count += 1\n        elif person[0] == \"01\":\n            bob_count += 1\n\n        total_influence += int(person[1])\n\n        if alice_count >= n // 2 and bob_count >= n // 2:\n            return str(total_influence)\n\n    return \"0\"\n"
    },
    {
        "number": 3837,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, s = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+m]))\n    b = list(map(int, stdin.split()[3+m:3+m+n]))\n    c = list(map(int, stdin.split()[3+m+n:]))\n\n    # Sort students by their abilities\n    students = sorted(zip(b, range(n)), reverse=True)\n\n    # Sort bugs by their complexities\n    bugs = sorted(enumerate(a), key=lambda x: x[1])\n\n    # Initialize the schedule with empty assignments\n    schedule = [None] * m\n\n    # Iterate through the bugs and assign them to the students\n    for bug_index, bug_complexity in bugs:\n        # Find the first student with the required ability\n        for student_index, student_ability in students:\n            if student_ability >= bug_complexity:\n                schedule[bug_index] = student_index\n                break\n\n    # Check if all bugs are assigned\n    if all(bug is not None for bug in schedule):\n        # Print YES and the schedule\n        print(\"YES\")\n        print(\" \".join(map(str, schedule)))\n    else:\n        # Print NO\n        print(\"NO\")\n"
    },
    {
        "number": 3838,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    q = list(map(int, stdin.split()[2:6]))\n    s = list(map(int, stdin.split()[6:10]))\n\n    if len(set(s)) != n:\n        return \"NO\"\n\n    for i in range(k):\n        if i % 2 == 0:\n            q.sort()\n            s.sort()\n        else:\n            q.sort(reverse=True)\n            s.sort(reverse=True)\n\n        if q != s:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3839,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1 1\"\n    elif n == 2:\n        return \"1 1\\n2 2\"\n    else:\n        knights = []\n        for i in range(n):\n            knights.append((i+1, i+1))\n        while True:\n            new_knights = []\n            for i in range(n):\n                for j in range(i+1, n):\n                    x1, y1 = knights[i]\n                    x2, y2 = knights[j]\n                    if abs(x1-x2) + abs(y1-y2) <= 4:\n                        new_knights.append(((x1+x2)//2, (y1+y2)//2))\n            if not new_knights:\n                break\n            knights.extend(new_knights)\n        return \"\\n\".join([\" \".join(map(str, knight)) for knight in knights])\n"
    },
    {
        "number": 3840,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return -1\n\n    moves = 0\n    x = 1\n\n    while True:\n        moves += 1\n        for i in range(x, n + 1, 2 * x + 1):\n            if a[i - 1] > 0:\n                a[i - 1] -= 1\n            else:\n                return moves\n\n        x += 1\n"
    },
    {
        "number": 3841,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, k = map(int, stdin.split())\n\n    if p % k == 0:\n        return -1\n\n    d = 0\n    while k**d <= p:\n        d += 1\n\n    a = [0] * d\n    a[d - 1] = p % k\n    for i in range(d - 2, -1, -1):\n        a[i] = (a[i + 1] * k + p) // k\n\n    return d, ' '.join(map(str, a))\n\n\ndef"
    },
    {
        "number": 3842,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p, q = map(int, stdin.split())\n    a = []\n    b = []\n    for _ in range(n):\n        a_i, b_i = map(int, input().split())\n        a.append(a_i)\n        b.append(b_i)\n\n    total_exp = sum(a)\n    total_income = sum(b)\n\n    if total_exp < p or total_income < q:\n        return \"0.000000000000000\"\n\n    days = 1\n    while total_exp < p or total_income < q:\n        total_exp = sum(a[:days])\n        total_income = sum(b[:days])\n        days += 1\n\n    return f\"{days - 1}.00000000000000\"\n"
    },
    {
        "number": 3843,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    result = 0\n    for i in range(n):\n        for j in range(m):\n            if i == 0 or j == 0:\n                result += 1\n            else:\n                result += 2\n    return str(result)\n"
    },
    {
        "number": 3844,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    while len(a) > 1:\n        min_num = min(a)\n        a = [num for num in a if num >= min_num]\n        if len(a) == 1:\n            return \"Conan\"\n\n    return \"Agasa\"\n"
    },
    {
        "number": 3845,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    A, B = map(int, stdin.split())\n    h = 3\n    w = 3\n    grid = [['.'] * w for _ in range(h)]\n\n    def dfs(x, y, color):\n        if x < 0 or x >= h or y < 0 or y >= w or grid[x][y] != '.':\n            return\n        grid[x][y] = color\n        dfs(x - 1, y, color)\n        dfs(x + 1, y, color)\n        dfs(x, y - 1, color)\n        dfs(x, y + 1, color)\n\n    dfs(0, 0, 'W')\n    dfs(1, 1, 'B')\n\n    return f\"{h} {w}\\n{''.join([''.join(row) for row in grid])}\"\n"
    },
    {
        "number": 3846,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    participants = set(range(1, n + 1))\n    leaders = set()\n    for line in stdin.split('\\n')[1:]:\n        if line.startswith('+'):\n            id = int(line[2:])\n            leaders.add(id)\n            participants.discard(id)\n        elif line.startswith('-'):\n            id = int(line[2:])\n            leaders.discard(id)\n            participants.add(id)\n    if not leaders:\n        return \"0\\n\"\n    return f\"{len(leaders)}\\n\" + \" \".join(map(str, sorted(leaders))) + \"\\n\"\n"
    },
    {
        "number": 3847,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, a, b, x = input_processing(stdin)\n    c = [[a[i] * b[j] for j in range(m)] for i in range(n)]\n    max_area = 0\n    for x1 in range(1, n + 1):\n        for x2 in range(x1, n + 1):\n            for y1 in range(1, m + 1):\n                for y2 in range(y1, m + 1):\n                    if (x2 - x1 + 1) * (y2 - y1 + 1) > max_area and sum_matrix(c, x1, x2, y1, y2) <= x:\n                        max_area = (x2 - x1 + 1) * (y2 - y1 + 1)\n    return str(max_area) if max_area > 0 else \"0\"\n\n\ndef"
    },
    {
        "number": 3848,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[0:2])\n    s = stdin.split()[2]\n\n    def is_tolerable(s: str) -> bool:\n        for c in s:\n            if c not in 'abcdefghijklmnopqrstuvwxyz'[:p]:\n                return False\n        for i in range(len(s) - 1):\n            if s[i:i+2] == s[i:i+2][::-1]:\n                return False\n        return True\n\n    def next_tolerable(s: str) -> str:\n        for i in range(len(s)):\n            if s[i] != 'z':\n                return s[:i] + chr(ord(s[i]) + 1) + s[i+1:]\n        return 'a' * len(s)\n\n    if is_tolerable(s):\n        next_s = next_tolerable(s)\n        if is_tolerable(next_s):\n            return next_s\n    return \"NO\"\n"
    },
    {
        "number": 3849,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    cards = input()\n\n    if n * k > 10**9:\n        return \"once again\"\n\n    if cards.count('1') > n - k + 1:\n        return \"tokitsukaze\"\n    else:\n        return \"quailty\"\n"
    },
    {
        "number": 3850,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, p = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:3+n]))\n    b = list(map(int, stdin.split()[3+n:]))\n\n    a.sort()\n    b.sort()\n\n    time = 0\n    i, j = 0, 0\n\n    while i < n and j < k:\n        if a[i] < b[j]:\n            time += a[i] - a[i-1] if i > 0 else a[i]\n            i += 1\n        else:\n            time += b[j] - b[j-1] if j > 0 else b[j]\n            j += 1\n\n    time += p - a[i-1] if i > 0 else p\n\n    return str(time)\n"
    },
    {
        "number": 3851,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a, b = map(int, input().split())\n    \n    x = min(a + b, k - a - b)\n    y = max(a + b, k - a - b)\n    \n    return f\"{x} {y}\"\n"
    },
    {
        "number": 3852,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, a = map(int, stdin.split())\n    a = sorted(a)\n    m = 0\n    while m < 2 * N:\n        x, y = random.randint(1, N), random.randint(1, N)\n        a[x - 1] += a[y - 1]\n        a = sorted(a)\n        m += 1\n    return m, [(x, y) for x, y in zip(range(1, N + 1), range(1, N + 1)) if a[x - 1] > a[y - 1]]\n"
    },
    {
        "number": 3853,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_power_of_two(n: int) -> bool:\n        return n > 0 and (n & (n - 1)) == 0\n\n    def smallest_power_of_two(n: int) -> int:\n        return n.bit_length() - 1\n\n    def can_fit_inside(outer_side: int, inner_side: int) -> bool:\n        return outer_side > inner_side\n\n    def smallest_magical_box(boxes: list[tuple[int, int]]) -> int:\n        max_side = max(boxes, key=lambda x: x[0])[0]\n        return smallest_power_of_two(max_side)\n\n    def main(n: int, boxes: list[tuple[int, int]]) -> int:\n        magical_boxes = [(2 ** k, a) for k, a in boxes]\n        smallest_side = smallest_magical_box(magical_boxes)\n        return smallest_side\n\n    n, *boxes = map(int, stdin.split())\n    boxes = list(zip(boxes[::2], boxes[1::2]))\n    result = main(n, boxes)\n    return str(result)\n"
    },
    {
        "number": 3854,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    coins = list(map(int, stdin.split()[2:]))\n    coins.sort(reverse=True)\n    q = 0\n    for i in range(n):\n        if coins[i] > k:\n            continue\n        k -= coins[i]\n        q += 1\n    if q == 0:\n        return \"0\\n\"\n    result = []\n    for i in range(q):\n        result.append(k)\n        k += 1\n    return f\"{q}\\n{' '.join(map(str, result))}\\n\"\n"
    },
    {
        "number": 3855,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"1\"\n    elif n == 2:\n        return \"2\"\n    else:\n        return \"3\"\n"
    },
    {
        "number": 3856,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    w = []\n    h = []\n    for i in range(1, n+1):\n        w.append(int(stdin.splitlines()[i].split()[0]))\n        h.append(int(stdin.splitlines()[i].split()[1]))\n    W = sum(w)\n    H = max(h)\n    if n % 2 == 0:\n        return W * H\n    else:\n        return W * H - min(w) * H\n"
    },
    {
        "number": 3857,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x = list(map(int, stdin.splitlines()[1].split()))\n\n    piles = 1\n    for i in range(n):\n        if x[i] == 0:\n            continue\n        if i > 0 and x[i] > x[i - 1]:\n            piles += 1\n        elif i > 0 and x[i] < x[i - 1]:\n            piles = max(piles - 1, 1)\n\n    return str(piles)\n"
    },
    {
        "number": 3858,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:N+1]]\n    points.sort()\n\n    def convex_hull(points):\n        def cross(o, a, b):\n            return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n        points.sort()\n        l, r = 0, 1\n        while r < N:\n            while cross(points[l], points[r], points[N-1]) <= 0:\n                l += 1\n            r += 1\n        return points[:l+1]\n\n    def score(points):\n        hull = convex_hull(points)\n        n = sum(1 for p in points if p in hull)\n        return 2**(n-len(points))\n\n    scores = [score(points[i:i+N:N//2]) for i in range(N//2)]\n    return sum(scores) % 998244353\n"
    },
    {
        "number": 3859,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    c_i = [0] * (2 * N)\n    a_i = [0] * (2 * N)\n\n    for i in range(2 * N):\n        c_i[i], a_i[i] = stdin.split('\\n')[i + 1].split()\n        a_i[i] = int(a_i[i])\n\n    # Initialize the number of operations required\n    operations = 0\n\n    # Iterate through the balls\n    for i in range(1, 2 * N - 1):\n        # If the current ball is white and the next ball is black, swap them\n        if c_i[i] == 'W' and c_i[i + 1] == 'B':\n            operations += 1\n            c_i[i], c_i[i + 1] = c_i[i + 1], c_i[i]\n            a_i[i], a_i[i + 1] = a_i[i + 1], a_i[i]\n\n        # If the current ball is black and the next ball is white, swap them\n        elif c_i[i] == 'B' and c_i[i + 1] == 'W':\n            operations += 1\n            c_i[i], c_i[i + 1] = c_i[i + 1], c_i[i]\n            a_i[i], a_i[i + 1] = a_i[i + 1], a_i[i]\n\n    # Print the minimum number of operations required\n    return str(operations)\n"
    },
    {
        "number": 3860,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    b, g, n = map(int, stdin.split())\n    return min(i for i in range(n+1) if i*(b+g-n) <= n*(b+g-i))\n"
    },
    {
        "number": 3861,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n\n    max_num = -1\n    for num in arr:\n        if num > max_num and not is_perfect_square(num):\n            max_num = num\n\n    return str(max_num)\n\n\ndef"
    },
    {
        "number": 3862,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    min_liters = float('inf')\n\n    for i in range(k):\n        for j in range(i + 1, k):\n            for l in range(j + 1, k):\n                if a[i] + a[j] + a[l] == n:\n                    min_liters = min(min_liters, a[i] + a[j] + a[l])\n\n    if min_liters == float('inf'):\n        return -1\n    else:\n        return min_liters\n"
    },
    {
        "number": 3863,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    MOD = 10**9 + 7\n\n    def count_palindromes(n: int, k: int) -> int:\n        if n % 2 == 0:\n            return k * (k + 1) // 2\n        else:\n            return k * (k + 1) // 2 * (k // 2 + 1)\n\n    def count_permutations(n: int, k: int) -> int:\n        if n == 1:\n            return 1\n        return k * count_permutations(n - 1, k)\n\n    palindromes = count_palindromes(N, K)\n    permutations = count_permutations(N, K)\n    result = (palindromes * permutations) % MOD\n\n    return str(result)\n"
    },
    {
        "number": 3864,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    expected_black_stones = 3 // 2\n    return str(expected_black_stones).zfill(9)\n"
    },
    {
        "number": 3865,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = int(stdin)\n    if a == 2:\n        return \"6\"\n    elif a == 3:\n        return \"6669\"\n    elif a == 10:\n        return \"-1\"\n    else:\n        n = 1\n        while True:\n            digits = [int(d) for d in str(n)]\n            if sum(digits) < a:\n                return str(n)\n            n += 1\n"
    },
    {
        "number": 3866,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n % 2 == 0:\n        a = [i for i in range(n)]\n        b = [i for i in range(n)]\n        c = [i for i in range(n)]\n        a.sort()\n        b.sort(reverse=True)\n        c.sort(key=lambda x: x % 2)\n        return \" \".join(map(str, a)) + \"\\n\" + \" \".join(map(str, b)) + \"\\n\" + \" \".join(map(str, c))\n    else:\n        return -1\n\n\ninput_str = \"5\\n\"\nprint(solution(input_str))\n\ninput_str = \"2\\n\"\nprint(solution(input_str)) "
    },
    {
        "number": 3867,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:-1]]\n    sequence = list(map(int, stdin.splitlines()[-1].split()))\n\n    adj_list = [[] for _ in range(n)]\n    for edge in edges:\n        adj_list[edge[0] - 1].append(edge[1] - 1)\n        adj_list[edge[1] - 1].append(edge[0] - 1)\n\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n\n    bfs_sequence = []\n    while queue:\n        v = queue.pop(0)\n        bfs_sequence.append(v)\n        for u in adj_list[v]:\n            if not visited[u]:\n                visited[u] = True\n                queue.append(u)\n\n    if set(bfs_sequence) == set(sequence):\n        return \"Yes\"\n    else:\n        return \"No\"\n"
    },
    {
        "number": 3868,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    flights = [list(map(int, stdin.split()[3:])) for _ in range(m)]\n\n    # Create a graph to represent the flights\n    graph = [[] for _ in range(n + 1)]\n    for flight in flights:\n        graph[flight[2]].append((flight[1], flight[3]))\n        graph[flight[3]].append((flight[0], flight[3]))\n\n    # Initialize the distance and parent arrays\n    distance = [float('inf')] * (n + 1)\n    parent = [-1] * (n + 1)\n    distance[0] = 0\n\n    # Perform Dijkstra's algorithm to find the shortest path to each city\n    for _ in range(n):\n        current = min(range(n + 1), key=lambda x: distance[x] if distance[x] != float('inf') else n + 1)\n        if distance[current] == n + 1:\n            break\n        for neighbor, cost in graph[current]:\n            new_distance = distance[current] + cost\n            if new_distance < distance[neighbor]:\n                distance[neighbor] = new_distance\n                parent[neighbor] = current\n\n    # Check if it is possible to gather everybody in Metropolis for k days\n    if any(distance[i] == float('inf') for i in range(1, n + 1)):\n        return \"-1\"\n\n    # Calculate the total cost of gathering everybody in Metropolis for k days\n    total_cost = sum(distance[i] for i in range(1, n + 1))\n\n    # Calculate the total cost of sending everybody back home\n    for i in range(1, n + 1):\n        if parent[i] == 0:\n            total_cost += distance[i]\n\n    return total_cost\n"
    },
    {
        "number": 3869,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    w, h, alpha = map(int, stdin.split())\n    alpha = alpha * 3.14159 / 180\n    x = w / 2 * (1 - (1 - 2 * alpha / (2 * 3.14159)) ** 0.5)\n    y = h / 2 * (1 - (1 - 2 * alpha / (2 * 3.14159)) ** 0.5)\n    area = x * y\n    return str(area)\n"
    },
    {
        "number": 3870,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, input().split())\n    jiro_cards = []\n    for _ in range(n):\n        position, strength = input().split()\n        jiro_cards.append((position, int(strength)))\n    ciel_cards = []\n    for _ in range(m):\n        strength = int(input())\n        ciel_cards.append(strength)\n\n    def attack(ciel_card, jiro_cards):\n        max_damage = 0\n        for jiro_card in jiro_cards:\n            if jiro_card[0] == \"ATK\":\n                if ciel_card >= jiro_card[1]:\n                    max_damage = max(max_damage, ciel_card - jiro_card[1])\n        return max_damage\n\n    max_damage = 0\n    for ciel_card in ciel_cards:\n        jiro_cards_copy = jiro_cards.copy()\n        while jiro_cards_copy:\n            if jiro_cards_copy[0][0] == \"ATK\":\n                damage = attack(ciel_card, jiro_cards_copy)\n                max_damage = max(max_damage, damage)\n                jiro_cards_copy.pop(0)\n            else:\n                jiro_cards_copy.pop(0)\n    return max_damage\n"
    },
    {
        "number": 3871,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    l = list(map(int, stdin.split()[2:2+n]))\n    s = list(map(int, stdin.split()[2+n:2+n+n]))\n    c = list(map(int, stdin.split()[2+n+n:]))\n\n    # Sort candidates by aggressiveness level\n    candidates = sorted(zip(l, s), key=lambda x: x[0])\n\n    # Initialize variables\n    total_profit = 0\n    total_cost = 0\n    accepted_candidates = set()\n\n    # Iterate through candidates\n    for i, (l_i, s_i) in enumerate(candidates):\n        # Check if candidate is already accepted\n        if l_i in accepted_candidates:\n            continue\n\n        # Calculate revenue for this candidate\n        revenue = sum(c[l_i-1])\n\n        # Calculate cost for this candidate\n        cost = s_i\n\n        # Calculate profit for this candidate\n        profit = revenue - cost\n\n        # Update total profit and cost\n        total_profit += profit\n        total_cost += cost\n\n        # Add candidate to accepted candidates\n        accepted_candidates.add(l_i)\n\n    # Calculate final profit\n    final_profit = total_profit - total_cost\n\n    return final_profit"
    },
    {
        "number": 3872,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_strings = stdin.split(\"\\n\")\n    string_a = input_strings[0]\n    string_b = input_strings[1]\n\n    if len(string_a) != len(string_b):\n        return \"NO\"\n\n    for i in range(len(string_a) // 2):\n        a_1 = string_a[:i]\n        a_2 = string_a[i:]\n        b_1 = string_b[:i]\n        b_2 = string_b[i:]\n\n        if (a_1 == b_1 and a_2 == b_2) or (a_1 == b_2 and a_2 == b_1):\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3873,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    if n == 1:\n        return \"YES\\n1 2\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3874,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    files = stdin.split('\\n')[1:-1]\n    indices = list(map(int, stdin.split()[-m:]))\n\n    def is_match(pattern, filename):\n        if len(pattern) != len(filename):\n            return False\n        for p, f in zip(pattern, filename):\n            if p == '?':\n                continue\n            if p != f:\n                return False\n        return True\n\n    def find_pattern():\n        for i in range(1, n + 1):\n            if i not in indices:\n                pattern = '?' * len(files[i - 1])\n                for j in range(1, n + 1):\n                    if is_match(pattern, files[j - 1]):\n                        return pattern\n        return None\n\n    pattern = find_pattern()\n    if pattern:\n        return \"Yes\\n\" + pattern\n    else:\n        return \"No\"\n"
    },
    {
        "number": 3875,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split(\"\\n\")[0])\n    A = list(map(int, stdin.split(\"\\n\")[1].split()))\n\n    def lis(X):\n        tails = [0] * N\n        size = 0\n        for x in X:\n            i, j = 0, size\n            while i != j:\n                mid = (i + j) // 2\n                if tails[mid] < x:\n                    i = mid + 1\n                else:\n                    j = mid\n            tails[i] = x\n            size = max(size, i + 1)\n        return size\n\n    def expected_length(N, A):\n        total = 0\n        for i in range(1, N + 1):\n            total += lis([A[j] for j in range(i)]) * (i - 1)\n        return total % (1000000007)\n\n    return str(expected_length(N, A))\n"
    },
    {
        "number": 3876,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:-1]]\n    edges.sort(key=lambda x: x[1])\n\n    def dfs(u: int, parent: int, visited: set[int], pairs: list[tuple[int, int]]) -> None:\n        visited.add(u)\n        for v in range(1, N + 1):\n            if v not in visited and (parent is None or v != parent):\n                if v > u:\n                    dfs(v, u, visited, pairs)\n                else:\n                    dfs(v, None, visited, pairs)\n                pairs.append((u, v))\n\n    pairs = []\n    dfs(1, None, set(), pairs)\n\n    count = 0\n    for i in range(len(pairs)):\n        for j in range(i + 1, len(pairs)):\n            u, v = pairs[i]\n            w, x = pairs[j]\n            if u == w or u == x or v == w or v == x:\n                continue\n            path = []\n            for edge in edges:\n                if edge[0] == u and edge[1] == v:\n                    path.append(edge)\n                elif edge[0] == v and edge[1] == u:\n                    path.append(edge)\n                elif edge[0] == w and edge[1] == x:\n                    path.append(edge)\n                elif edge[0] == x and edge[1] == w:\n                    path.append(edge)\n            if len(path) == 0:\n                continue\n            ribbon = False\n            for edge in path:\n                if edge[0] == u and edge[1] == v:\n                    ribbon = True\n                    break\n            if ribbon:\n                count += 1\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3877,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, l, r = map(int, stdin.split())\n    final_list = [n]\n    while n > 1:\n        n = n // 2 + n % 2 + n // 2\n        final_list.append(n)\n    ones_count = sum(final_list[l-1:r])\n    return str(ones_count)\n"
    },
    {
        "number": 3878,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def bfs(graph, start):\n        queue = [start]\n        visited = set()\n        visited.add(start)\n        while queue:\n            current = queue.pop(0)\n            for neighbor in graph[current]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        return visited\n\n    def find_min_steps(n, m, edges):\n        graph = [[] for _ in range(n + 1)]\n        for u, v in edges:\n            graph[u].append(v)\n            graph[v].append(u)\n\n        min_steps = 0\n        selected_guests = []\n        for i in range(1, n + 1):\n            friends = bfs(graph, i)\n            if len(friends) == n:\n                min_steps += 1\n                selected_guests.append(i)\n                for j in range(1, n + 1):\n                    if j not in friends:\n                        graph[j].remove(i)\n                        graph[i].remove(j)\n            else:\n                break\n\n        return min_steps, selected_guests\n\n    n, m = map(int, stdin.split()[:2])\n    edges = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m + 1]]\n\n    min_steps, selected_guests = find_min_steps(n, m, edges)\n    output = f\"{min_steps}\\n\"\n    output += \" \".join(map(str, selected_guests))\n    return output\n"
    },
    {
        "number": 3879,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    bids = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_possible(bids):\n        def can_double(bid):\n            return bid % 2 == 0\n\n        def can_triple(bid):\n            return bid % 3 == 0\n\n        def can_double_triple(bid):\n            return can_double(bid) and can_triple(bid)\n\n        def can_double_double(bid):\n            return can_double(bid) and can_double(bid)\n\n        def can_triple_triple(bid):\n            return can_triple(bid) and can_triple(bid)\n\n        def can_double_triple_double(bid):\n            return can_double(bid) and can_triple(bid) and can_double(bid)\n\n        def can_triple_double_triple(bid):\n            return can_triple(bid) and can_double(bid) and can_triple(bid)\n\n        def can_double_double_triple(bid):\n            return can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_triple_double_double(bid):\n            return can_triple(bid) and can_double(bid) and can_double(bid)\n\n        def can_double_triple_triple(bid):\n            return can_double(bid) and can_triple(bid) and can_triple(bid)\n\n        def can_triple_double_double_triple(bid):\n            return can_triple(bid) and can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_double_double_double_triple(bid):\n            return can_double(bid) and can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_double_triple_double_double(bid):\n            return can_double(bid) and can_triple(bid) and can_double(bid) and can_double(bid)\n\n        def can_triple_double_double_double(bid):\n            return can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid)\n\n        def can_double_triple_double_double_triple(bid):\n            return can_double(bid) and can_triple(bid) and can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_triple_double_double_double_triple(bid):\n            return can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_double_triple_double_double_double(bid):\n            return can_double(bid) and can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid)\n\n        def can_triple_double_double_double_double(bid):\n            return can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid) and can_double(bid)\n\n        def can_double_triple_double_double_double_triple(bid):\n            return can_double(bid) and can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_triple_double_double_double_double_triple(bid):\n            return can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid) and can_double(bid) and can_triple(bid)\n\n        def can_double_triple_double_double_double_double(bid):\n            return can_double(bid) and can_triple(bid) and can_double(bid) and can_double(bid) and can_double(bid) and can_double(bid)\n\n        def can_triple_double_double_double_double_double("
    },
    {
        "number": 3880,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    array = list(map(int, stdin.splitlines()[1].split()))\n\n    max_sum = sum(array)\n    for i in range(n):\n        max_sum = max(max_sum, sum(array[:i] + [-array[i]] + array[i+1:]))\n\n    return str(max_sum)\n"
    },
    {
        "number": 3881,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[0:2])\n    operations = [tuple(stdin.split()[2*i:2*i+2]) for i in range(q)]\n\n    def compress(s: str) -> str:\n        for a, b in operations:\n            if s.startswith(a):\n                return s[2:] + b\n        return s\n\n    def count_strings(n: int) -> int:\n        if n == 1:\n            return 1\n        count = 0\n        for s in ['a', 'b', 'c', 'd', 'e', 'f']:\n            count += count_strings(n - 1)\n        return count\n\n    return count_strings(n)\n"
    },
    {
        "number": 3882,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 3\n    else:\n        return (n * (n - 1)) // 2\n\n\ninput_str = input()\nresult = solution(input_str)\nprint(result % (10**9 + 7)) "
    },
    {
        "number": 3883,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    x = 0\n    while True:\n        if (2 * x + 1) * x == 3 * (x ** 2) + 2 * x * b:\n            return f\"{x:.12f}\"\n        x += 1\n    return \"-1\"\n"
    },
    {
        "number": 3884,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.splitlines()[0].split())\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    fuel_used = 0\n    for i in range(n - 2):\n        fuel_used += a[i] * m + b[i] * m\n        m -= a[i] * m + b[i] * m\n\n    if m > 0:\n        fuel_used += a[-1] * m + b[-1] * m\n\n    if fuel_used <= 10**9:\n        return fuel_used\n    else:\n        return -1\n"
    },
    {
        "number": 3885,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    if n == 1:\n        return \"0\"\n    elif n == 2:\n        return \"1\"\n    else:\n        return str((n * (n - 1)) // 2)\n\n\ninput_str = \"10\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3886,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    q = int(stdin.splitlines()[0])\n    answers = []\n    for i in range(1, q + 1):\n        n, k = map(int, stdin.splitlines()[i].split())\n        if n == 0:\n            answers.append('.')\n        else:\n            f_n = \"What are you doing at the end of the world? Are you busy? Will you save us?\"\n            for j in range(n - 1):\n                f_n = f\"What are you doing while sending \\\"{f_n}\\\"? Are you busy? Will you send \\\"{f_n}\\\"?\"\n            if k > len(f_n):\n                answers.append('.')\n            else:\n                answers.append(f_n[k - 1])\n    return ''.join(answers)\n"
    },
    {
        "number": 3887,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    rebus = stdin.strip().split()\n    n = int(rebus[-1])\n    rebus = rebus[:-1]\n\n    if n < 1 or n > 1000000:\n        return \"Impossible\"\n\n    for i in range(len(rebus)):\n        if rebus[i] == \"?\":\n            rebus[i] = str(n)\n            n -= 1\n\n    if n != 0:\n        return \"Impossible\"\n\n    return \"Possible\\n\" + \" \".join(rebus)\n"
    },
    {
        "number": 3888,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    matrix = [[0 for _ in range(N)] for _ in range(N)]\n\n    for i in range(1, N + 1):\n        row = stdin[i].split()\n        for j in range(1, N + 1):\n            matrix[i - 1][j - 1] = int(row[j - 1])\n\n    count = [0, 0, 0]\n    for i in range(N):\n        for j in range(N):\n            if matrix[i][j] == 0:\n                count[0] += 1\n            elif matrix[i][j] == 1:\n                count[1] += 1\n            else:\n                count[2] += 1\n\n    return f\"{count[0]} {count[1]} {count[2]}\"\n"
    },
    {
        "number": 3889,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    colors = {}\n    for c in s:\n        if c in colors:\n            colors[c] += 1\n        else:\n            colors[c] = 1\n\n    for c in colors:\n        if colors[c] > 1:\n            return \"Yes\"\n\n    return \"No\"\n"
    },
    {
        "number": 3890,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    mod = 1000000007\n    MOD = 10**9 + 7\n\n    def count_ways(n, k):\n        if k == 0:\n            return 1\n        if k == 1:\n            return 1\n        if k > n:\n            return 0\n\n        dp = [0] * (n + 1)\n        dp[1] = 1\n        dp[2] = 1\n\n        for i in range(3, n + 1):\n            dp[i] = (dp[i - 1] + dp[i - 2]) % MOD\n\n        result = 0\n        for i in range(k, n + 1):\n            result = (result + dp[i]) % MOD\n\n        return result\n\n    return str((count_ways(n, k) * pow(2, n - k, mod)) % mod)\n"
    },
    {
        "number": 3891,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    table = [list(line) for line in stdin.split('\\n')[1:n+1]]\n\n    for i in range(n):\n        for j in range(m):\n            if table[i][j] == 'B':\n                square_size = 1\n                while i - square_size >= 0 and table[i - square_size][j] == 'B':\n                    square_size += 1\n                while i + square_size < n and table[i + square_size][j] == 'B':\n                    square_size += 1\n                while j - square_size >= 0 and table[i][j - square_size] == 'B':\n                    square_size += 1\n                while j + square_size < m and table[i][j + square_size] == 'B':\n                    square_size += 1\n                return str(i + square_size // 2) + ' ' + str(j + square_size // 2)"
    },
    {
        "number": 3892,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    a = [int(x) for x in stdin.split()[2:2+m]]\n    b = [int(x) for x in stdin.split()[2+m:]]\n    \n    # Initialize the minimum time for each station\n    min_time = [0] * (n+1)\n    \n    # Iterate through the candies and update the minimum time for each station\n    for i in range(m):\n        min_time[a[i]] += 1\n        min_time[b[i]] += 1\n    \n    # Iterate through the stations and calculate the minimum time for each station\n    for i in range(1, n+1):\n        min_time[i] += min_time[i-1]\n    \n    # Print the minimum time for each station\n    return ' '.join(map(str, min_time[1:]))"
    },
    {
        "number": 3893,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    x_1, y_1, x_2, y_2, n = map(int, stdin.split())\n    roads = []\n    for _ in range(n):\n        a, b, c = map(int, input().split())\n        roads.append((a, b, c))\n\n    def distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n\n    def is_on_line(x, y, a, b, c):\n        return a * x + b * y + c == 0\n\n    def is_intersection(x1, y1, x2, y2, a, b, c):\n        return is_on_line(x1, y1, a, b, c) and is_on_line(x2, y2, a, b, c)\n\n    def get_block(x, y):\n        for i, (a, b, c) in enumerate(roads):\n            if is_on_line(x, y, a, b, c):\n                return i\n        return -1\n\n    block_1 = get_block(x_1, y_1)\n    block_2 = get_block(x_2, y_2)\n\n    if block_1 == -1 or block_2 == -1:\n        return \"Impossible\"\n\n    if block_1 == block_2:\n        return 0\n\n    min_steps = float('inf')\n    for i in range(n):\n        if i == block_1 or i == block_2:\n            continue\n        for j in range(n):\n            if j == block_1 or j == block_2 or j == i:\n                continue\n            for k in range(n):\n                if k == block_1 or k == block_2 or k == i or k == j:\n                    continue\n                steps = distance(x_1, y_1, x_2, y_2) + distance(x_1, y_1, x_2, y_2) + distance(x_1, y_1, x_2, y_2)\n                if steps < min_steps:\n                    min_steps = steps\n\n    return min_steps\n"
    },
    {
        "number": 3894,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # Initialize the game state\n    game_state = [0] * n\n    for i in range(n):\n        game_state[i] = a[i]\n\n    # Find the winner\n    while True:\n        # Kevin's turn\n        kevin_turn = True\n        while sum(game_state) > 0:\n            # Find the pile with the minimum number of cows\n            min_pile = min(range(n), key=lambda i: game_state[i])\n\n            # Remove a cow from the chosen pile\n            game_state[min_pile] -= 1\n\n            # If the pile is empty, remove it\n            if game_state[min_pile] == 0:\n                game_state.pop(min_pile)\n                n -= 1\n\n            # If the pile has even size 2\u00b7x, replace it with k piles of x cows each\n            if game_state[min_pile] % 2 == 0 and game_state[min_pile] // 2 > 0:\n                for _ in range(k):\n                    game_state.insert(min_pile, game_state[min_pile] // 2)\n                    n += 1\n\n        # If Kevin wins, return Kevin as the winner\n        if sum(game_state) == 0:\n            return \"Kevin\"\n\n        # Nicky's turn\n        kevin_turn = False\n        while sum(game_state) > 0:\n            # Find the pile with the minimum number of cows\n            min_pile = min(range(n), key=lambda i: game_state[i])\n\n            # Remove a cow from the chosen pile\n            game_state[min_pile] -= 1\n\n            # If the pile is empty, remove it\n            if game_state[min_pile] == 0:\n                game_state.pop(min_pile)\n                n -= 1\n\n            # If the pile has even size 2\u00b7x, replace it with k piles of x cows each\n            if game_state[min_pile] % 2 == 0 and game_state[min_pile] // 2 > 0:\n                for _ in range(k):\n                    game_state.insert(min_pile, game_state[min_pile] // 2)\n                    n += 1\n\n        # If Nicky wins, return Nicky as the winner\n        if sum(game_state) == 0:\n            return \"Nicky\""
    },
    {
        "number": 3895,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split('\\n')[0])\n    f_values = list(map(int, stdin.split('\\n')[1].split()))\n\n    def is_valid(m: int) -> bool:\n        for i in range(1, n + 1):\n            if not any(g(i) == i for g in gs):\n                return False\n        return True\n\n    def find_g(m: int) -> list:\n        gs = []\n        for i in range(1, n + 1):\n            g = lambda x: (i * x) % m + 1\n            gs.append(g)\n        return gs\n\n    def find_h(m: int) -> list:\n        hs = []\n        for i in range(1, m + 1):\n            h = lambda x: (f(x) * i) % m + 1\n            hs.append(h)\n        return hs\n\n    def find_answer(m: int) -> tuple:\n        gs = find_g(m)\n        hs = find_h(m)\n        for i in range(1, n + 1):\n            if not any(g(i) == i for g in gs):\n                return None\n        return (m, [g(i) for i in range(1, n + 1)], [h(i) for i in range(1, m + 1)])\n\n    for m in range(1, n + 1):\n        if is_valid(m):\n            answer = find_answer(m)\n            if answer:\n                return '\\n'.join(map(str, answer))\n\n    return \"-1\"\n"
    },
    {
        "number": 3896,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = len(stdin)\n    complexity = 0\n    for i in range(n):\n        if stdin[i] == '1':\n            complexity += 2**(n-i-1)\n    return complexity % (10**9 + 7)\n"
    },
    {
        "number": 3897,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.split(\"\\n\")[0])\n    a = list(map(int, stdin.split(\"\\n\")[1].split()))\n    m = 1\n    for i in range(n):\n        m *= a[i]\n    mod = 1000000007\n    k = 1\n    for i in range(1, m+1):\n        if i % a[0] == 0:\n            j = i\n            l = 1\n            while j % a[l] == 0:\n                j //= a[l]\n                l += 1\n            if l == n:\n                k = (k * pow(a[0], n-1, mod)) % mod\n    return str(k)\n"
    },
    {
        "number": 3898,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    b = list(map(int, stdin.splitlines()[2].split()))\n\n    # Check if the desired statues are reachable from the empty pedestal\n    visited = [False] * n\n    queue = [0]\n    visited[0] = True\n\n    while queue:\n        current = queue.pop(0)\n        for i in range(1, n):\n            if not visited[i] and a[current] == i:\n                visited[i] = True\n                queue.append(i)\n\n    if all(visited[i] for i in b):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3899,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def compute_power(tasks: list) -> float:\n        total_power = sum(tasks)\n        total_processors = sum(b for _, b in tasks)\n        return total_power / total_processors\n\n    def assign_tasks(tasks: list, computers: int) -> list:\n        tasks.sort(key=lambda x: x[1], reverse=True)\n        assigned_tasks = [[] for _ in range(computers)]\n        for task, b in tasks:\n            for i, assigned in enumerate(assigned_tasks):\n                if len(assigned) < 2:\n                    assigned.append((task, b))\n                    break\n        return assigned_tasks\n\n    def execute_tasks(tasks: list) -> float:\n        total_power = 0\n        for task, b in tasks:\n            total_power += task * b\n        return total_power\n\n    def is_blown_up(tasks: list, threshold: float) -> bool:\n        return compute_power(tasks) > threshold\n\n    def find_lowest_threshold(tasks: list, computers: int) -> int:\n        assigned_tasks = assign_tasks(tasks, computers)\n        first_round_power = sum(execute_tasks(assigned_tasks[i]) for i in range(computers))\n        second_round_power = sum(execute_tasks(assigned_tasks[i]) for i in range(computers) if len(assigned_tasks[i]) == 2)\n        total_power = first_round_power + second_round_power\n        return total_power\n\n    n, *tasks = map(int, stdin.split())\n    a = tasks[:n]\n    b = tasks[n:]\n    tasks = list(zip(a, b))\n    threshold = 1000\n    while is_blown_up(tasks, threshold / 1000):\n        threshold += 1\n    return int(threshold)\n"
    },
    {
        "number": 3900,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, p = map(int, stdin.split()[:2])\n    coders = [set(map(int, stdin.split()[2:])) for _ in range(n)]\n\n    def count_agreements(suspects):\n        return sum(1 for coder in coders if suspects.issubset(coder))\n\n    def count_ways(suspects):\n        return sum(1 for i in range(n) for j in range(i+1, n) if count_agreements({i, j}) >= p)\n\n    return str(count_ways(set()))\n"
    },
    {
        "number": 3901,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def is_possible(a):\n        for i in range(len(a) - 1):\n            if a[i] == 1 or a[i + 1] == 1:\n                continue\n            if gcd(a[i], a[i + 1]) != 1:\n                return False\n        return True\n\n    def min_operations(a):\n        count = 0\n        for i in range(len(a) - 1):\n            if a[i] == 1 or a[i + 1] == 1:\n                continue\n            g = gcd(a[i], a[i + 1])\n            if g != 1:\n                a[i] = 1\n                a[i + 1] = 1\n                count += 1\n        return count\n\n    if is_possible(a):\n        return str(min_operations(a))\n    else:\n        return \"-1\"\n"
    },
    {
        "number": 3902,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_valid_suffix(suffix: str, root: str) -> bool:\n        if len(suffix) == 2:\n            return root[-2] != suffix[0] and root[-3] != suffix[1]\n        elif len(suffix) == 3:\n            return root[-3] != suffix[0] and root[-4] != suffix[1] and root[-5] != suffix[2]\n        else:\n            return False\n\n    def find_suffixes(root: str) -> set:\n        suffixes = set()\n        for i in range(len(root) - 2):\n            if is_valid_suffix(root[i:], root):\n                suffixes.add(root[i:])\n        return suffixes\n\n    s = stdin.strip()\n    root = s[:-1]\n    suffixes = find_suffixes(root)\n    k = len(suffixes)\n    result = [str(suffix) for suffix in sorted(suffixes)]\n\n    return f\"{k}\\n\" + \"\\n\".join(result)\n"
    },
    {
        "number": 3903,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0].split(','))\n    map_matrix = [list(line) for line in stdin.split('\\n')[1:]]\n\n    def dfs(x, y, state):\n        if x < 0 or x >= n or y < 0 or y >= m or map_matrix[x][y] != str(state):\n            return False\n        map_matrix[x][y] = '.'\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if dfs(x + dx, y + dy, state):\n                return True\n        return False\n\n    def bfs(x, y, state):\n        queue = [(x, y)]\n        visited = set()\n        while queue:\n            x, y = queue.pop(0)\n            if (x, y) in visited:\n                continue\n            visited.add((x, y))\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < n and 0 <= ny < m and map_matrix[nx][ny] == str(state):\n                    queue.append((nx, ny))\n        return visited\n\n    def build_road():\n        visited = set()\n        for i in range(n):\n            for j in range(m):\n                if map_matrix[i][j] in '123':\n                    visited.update(bfs(i, j, int(map_matrix[i][j])))\n        return visited\n\n    def connect_states():\n        visited = set()\n        for i in range(n):\n            for j in range(m):\n                if map_matrix[i][j] in '123':\n                    visited.update(dfs(i, j, int(map_matrix[i][j])))\n        return visited\n\n    if connect_states() == build_road():\n        return len(build_road())\n    else:\n        return -1\n"
    },
    {
        "number": 3904,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    sequence = stdin.splitlines()[1]\n\n    if n % 2 != 0:\n        return -1\n\n    stack = []\n    for char in sequence:\n        if char == '(':\n            stack.append(char)\n        else:\n            if not stack:\n                return -1\n            stack.pop()\n\n    if stack:\n        return -1\n\n    reorder_time = 0\n    for i in range(n // 2):\n        reorder_time += 2 * i\n\n    return reorder_time\n"
    },
    {
        "number": 3905,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, h = map(int, stdin.split()[:3])\n    u = list(map(int, stdin.split()[3:]))\n    c = [list(map(int, stdin.split()[i+3:i+5])) for i in range(0, m*2, 2)]\n\n    # Find the minimum number of data centers that have to be included in an experiment\n    k = 1\n    for i in range(n):\n        if u[i] == h - 1:\n            k += 1\n\n    # Print the minimum possible number of data centers k\n    print(k)\n\n    # Find the indices of data centers whose maintenance time will be shifted by one hour later\n    x = []\n    for i in range(n):\n        if u[i] == h - 1:\n            x.append(i+1)\n\n    # Print k distinct integers x_1, x_2, ..., x_{k} (1 \u2264 x_{i} \u2264 n)\n    print(\" \".join(map(str, x)))"
    },
    {
        "number": 3906,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split())\n    mod = 10**9 + 7\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(1, n + 1):\n        for j in range(1, m + 1):\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1]\n            dp[i][j] %= mod\n    return dp[n][m]\n\n\ninput_str = \"2 3\"\noutput_str = str(solution(input_str))\nprint(output_str) "
    },
    {
        "number": 3907,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    coupons = [tuple(map(int, stdin.split()[2 * i + 2:2 * i + 4])) for i in range(m)]\n    coupons.sort(key=lambda x: x[0])\n\n    def find_position(x, a):\n        left, right = 0, len(a) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if a[mid] == x:\n                return mid\n            elif a[mid] < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        return -1\n\n    def is_valid(x, y, a):\n        position = find_position(x, a)\n        if position == -1:\n            return False\n        return a[position] == x or a[position] == y or a[position] + 1 == x or a[position] + 1 == y\n\n    def build_array(coupons):\n        a = [0] * n\n        for i in range(m):\n            q, w = coupons[i]\n            for j in range(n):\n                if a[j] == 0 and is_valid(q, q + 1, a):\n                    a[j] = q\n                    break\n                elif a[j] == 0 and is_valid(q, q - 1, a):\n                    a[j] = q - 1\n                    break\n                elif a[j] == 0 and is_valid(q + 1, q + 2, a):\n                    a[j] = q + 1\n                    break\n                elif a[j] == 0 and is_valid(q - 1, q, a):\n                    a[j] = q - 1\n                    break\n        return a\n\n    a = build_array(coupons)\n    return sum(c[1] for c in coupons if c[0] in a)\n"
    },
    {
        "number": 3908,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for d in range(1, n):\n        for i in range(n - d):\n            j = i + d\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if dp[i][j] > 1:\n                count += 1\n    return count\n"
    },
    {
        "number": 3909,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    coins = [1, 3, 9, 27, 81, 243, 729, 2187, 6561, 19683, 59049, 177147, 531441, 1594323, 4782969, 14348907, 43349443, 130703181, 380303717, 1028472077, 2986111263, 8159229449, 24585200187, 68719476735, 182568294881, 532111738799, 1511121007087, 4052739537881, 11699425222501, 30601757416119, 86700240819673, 245852001873029, 687194767352533, 1825682948813797, 5321117387992683, 15111210070871411, 40527395378810509, 1169942522250118013, 3060175741611899677, 8670024081967342981, 245852001873029227203, 687194767352533022081, 182568294881379704441, 5321117387992683118739, 15111210070871411064677, 40527395378810509220261, 116994252225011801338319, 306017574161189967742061, 86700240819673429811199, 245852001873029227203201, 687194767352533022081119, 1825682948813797044411199, 5321117387992683118739391, 15111210070871411064677399, 40527395378810509220261199, 116994252225011801338319391, 306017574161189967742061199, 8670024081967342981119939, 245852001873029227203201199, 687194767352533022081119391, 1825682948813797"
    },
    {
        "number": 3910,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    pairs = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def is_valid(food_types):\n        for i in range(n):\n            if pairs[i][0] == pairs[i][1]:\n                return False\n            if food_types[pairs[i][0] - 1] == food_types[pairs[i][1] - 1]:\n                return False\n        for i in range(n - 1):\n            if food_types[pairs[i][0] - 1] == food_types[pairs[i + 1][0] - 1] and food_types[pairs[i][1] - 1] == food_types[pairs[i + 1][1] - 1]:\n                return False\n        return True\n\n    def find_food_types():\n        food_types = [1] * (2 * n)\n        for i in range(n):\n            food_types[pairs[i][0] - 1] = 1\n            food_types[pairs[i][1] - 1] = 2\n        return food_types\n\n    food_types = find_food_types()\n    if is_valid(food_types):\n        return '\\n'.join(str(food_types[pairs[i][0] - 1]) + ' ' + str(food_types[pairs[i][1] - 1]) for i in range(n))\n    else:\n        return -1\n"
    },
    {
        "number": 3911,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    row = [1]\n    for i in range(n - 1):\n        if row[-1] == row[-2]:\n            row[-2:] = [row[-1] + 1]\n        else:\n            row.append(row[-1])\n    return \" \".join(map(str, row))\n\n\ninput_str = \"8\\n\"\noutput_str = solution(input_str)\nprint(output_str) "
    },
    {
        "number": 3912,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    s = stdin.splitlines()[1]\n\n    def is_palindrome(s: str) -> bool:\n        return s == s[::-1]\n\n    def palindrome_parts(s: str) -> int:\n        n = len(s)\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                if is_palindrome(s[i:j]):\n                    count += 1\n        return count\n\n    def min_palindrome_parts(s: str) -> int:\n        n = len(s)\n        count = 0\n        for i in range(1, n):\n            if is_palindrome(s[:i]):\n                count += 1\n        return count\n\n    k = min_palindrome_parts(s)\n    palindromes = []\n    for i in range(1, n):\n        if is_palindrome(s[:i]):\n            palindromes.append(s[:i])\n    for i in range(n - 1, 0, -1):\n        if is_palindrome(s[:i]):\n            palindromes.append(s[:i])\n    palindromes.append(s)\n\n    return f\"{k}\\n{' '.join(palindromes)}\"\n"
    },
    {
        "number": 3913,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    revealed = stdin.splitlines()[1]\n    words = stdin.splitlines()[2:]\n\n    revealed_letters = [letter for letter in revealed if letter != \"*\"]\n    hidden_word = [letter for word in words for letter in word if letter not in revealed_letters]\n\n    if not hidden_word:\n        return \"0\"\n\n    hidden_word = hidden_word[0]\n    revealed_positions = [i for i, letter in enumerate(revealed) if letter != \"*\"]\n\n    possible_letters = [letter for letter in hidden_word if hidden_word.count(letter) == 1 and letter not in revealed_letters]\n\n    if not possible_letters:\n        return \"0\"\n\n    for letter in possible_letters:\n        if letter not in revealed_letters:\n            return \"1\"\n\n    return \"0\"\n"
    },
    {
        "number": 3914,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, d, b = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n    assert len(a) == n\n    assert sum(a) == n * b\n\n    x1 = 0\n    x2 = 0\n\n    for i in range(n):\n        if a[i] != b:\n            x1 += 1\n\n    for i in range(n - 1, n - d - 1, -1):\n        if a[i] != b:\n            x2 += 1\n\n    return min(x1, x2)\n"
    },
    {
        "number": 3915,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    p, q = map(int, stdin.split())\n    A = p / q\n    if A < 1 / 42:\n        return \"Palindromic tree is better than splay tree\"\n\n    def is_prime(n: int) -> bool:\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    def is_palindrome(n: int) -> bool:\n        return str(n) == str(n)[::-1]\n\n    def count_primes(n: int) -> int:\n        return sum(1 for i in range(2, n + 1) if is_prime(i))\n\n    def count_palindromes(n: int) -> int:\n        return sum(1 for i in range(1, n + 1) if is_palindrome(i))\n\n    n = 1\n    while count_primes(n) <= A * count_palindromes(n):\n        n += 1\n\n    return n - 1\n"
    },
    {
        "number": 3916,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    k = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def lowest_prime_divisor(num: int) -> int:\n        for i in range(2, num + 1):\n            if num % i == 0 and is_prime(i):\n                return i\n        return 1\n\n    def distance(node1: int, node2: int) -> int:\n        path_length = 0\n        while node1 != node2:\n            path_length += 1\n            node1 = node1 // lowest_prime_divisor(node1)\n        return path_length\n\n    emotion_samples_node = 1\n    for i in range(1, n + 1):\n        emotion_samples_node *= k[i - 1]\n\n    total_path_length = 0\n    for i in range(1, n + 1):\n        total_path_length += distance(k[i - 1]!, emotion_samples_node)\n\n    return total_path_length"
    },
    {
        "number": 3917,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def g(i, j):\n        sum = 0\n        for k in range(min(i, j) + 1, max(i, j) + 1):\n            sum += a[k]\n        return sum\n\n    min_f = float('inf')\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i != j:\n                f = (i - j) ** 2 + g(i, j) ** 2\n                if f < min_f:\n                    min_f = f\n\n    return str(min_f)\n"
    },
    {
        "number": 3918,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k_1, k_2 = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:n+3]))\n    b = list(map(int, stdin.split()[n+3:]))\n\n    def update_array(array, k, sign):\n        for _ in range(k):\n            min_index = a.index(min(array))\n            array[min_index] += sign\n\n    update_array(a, k_1, 1)\n    update_array(b, k_2, 1)\n\n    error = sum((a[i] - b[i]) ** 2 for i in range(n))\n\n    return str(error)\n"
    },
    {
        "number": 3919,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M = map(int, stdin.split()[:2])\n    S = stdin.split()[2]\n    l_r = [list(map(int, stdin.split()[3:][i:i+2])) for i in range(3, 3*(M+1), 3)]\n\n    def count_possible_values(S, l_r):\n        def permute(S, l, r):\n            S = list(S)\n            S[l:r+1] = S[l:r+1][::-1]\n            return ''.join(S)\n\n        def count_permutations(S, l_r):\n            count = 1\n            for l, r in l_r:\n                S = permute(S, l, r)\n                count *= 2\n            return count\n\n        return count_permutations(S, l_r) % 1000000007\n\n    return str(count_possible_values(S, l_r))\n"
    },
    {
        "number": 3920,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a = list(map(int, stdin.split()))\n    n = len(a)\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            for k in range(j+1, n):\n                if a[i]**2 + a[j]**2 == a[k]**2:\n                    count += 1\n    return str(count)\n"
    },
    {
        "number": 3921,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_good(x):\n        for i in range(len(x) - 1):\n            if x[i] >= x[i] + 1 or gcd(x[i], x[i] + 1) <= 1:\n                return False\n        return True\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    max_length = 0\n    for i in range(1, n + 1):\n        for j in range(i, n + 1):\n            if is_good(a[i - 1:j]):\n                max_length = max(max_length, j - i + 1)\n\n    return str(max_length)\n"
    },
    {
        "number": 3922,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def expand_shortcuts(moves: str) -> str:\n        moves = moves.upper()\n        while True:\n            new_moves = moves.replace('T', 'lddrr')\n            if new_moves == moves:\n                break\n            moves = new_moves\n        return moves\n\n    def is_valid_move(move: str, organs: list) -> bool:\n        if move == 'u':\n            return organs[0] == 'E'\n        elif move == 'd':\n            return organs[-1] == 'E'\n        elif move == 'l':\n            return organs[organs.index('E') - 1] == 'E'\n        elif move == 'r':\n            return organs[organs.index('E') + 1] == 'E'\n        else:\n            return False\n\n    def find_valid_moves(organs: list) -> str:\n        valid_moves = ''\n        for move in ['u', 'd', 'l', 'r']:\n            if is_valid_move(move, organs):\n                valid_moves += move\n        return valid_moves\n\n    def is_complete(organs: list) -> bool:\n        return all(organ != 'E' for organ in organs)\n\n    def place_organs(organs: list, moves: str) -> list:\n        for move in moves:\n            if move == 'u':\n                organs[0], organs[1] = organs[1], organs[0]\n            elif move == 'd':\n                organs[-1], organs[-2] = organs[-2], organs[-1]\n            elif move == 'l':\n                organs[organs.index('E') - 1], organs[organs.index('E')] = organs[organs.index('E')], organs[organs.index('E') - 1]\n            elif move == 'r':\n                organs[organs.index('E')], organs[organs.index('E') + 1] = organs[organs.index('E') + 1], organs[organs.index('E')]\n        return organs\n\n    def main(stdin: str) -> str:\n        cases = int(stdin.split('\\n')[0])\n        output = []\n\n        for _ in range(cases):\n            k = int(stdin.split('\\n')[1])\n            organs = stdin.split('\\n')[2:4]\n            organs = [organ.split() for organ in organs]\n            organs = [list(map(int, organ)) for organ in organs]\n            organs = [str(organ[0]) for organ in organs]\n\n            if k == 1:\n                organs = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '90', '91', '9"
    },
    {
        "number": 3923,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, A, B = map(int, stdin.split())\n    P = list(range(1, N+1))\n    def f(i, j):\n        if j == 1:\n            return P[i-1]\n        else:\n            return f(P[i-1], j-1)\n    def g(i):\n        j = 1\n        while f(i, j) != i:\n            j += 1\n        return j\n    for i in range(1, N+1):\n        if g(i) == A or g(i) == B:\n            return ' '.join(map(str, P))\n    return -1\n"
    },
    {
        "number": 3924,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    bags = 0\n    for i in range(n):\n        if a[i] > 0:\n            bags += (a[i] + k - 1) // k\n\n    return str(bags)\n"
    },
    {
        "number": 3925,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                dp[i][j] = 1\n            else:\n                for k in range(i, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j])\n    return dp[0][n-1]\n"
    },
    {
        "number": 3926,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, r, c, x, y = map(int, stdin.split())\n    labyrinth = [input() for _ in range(n)]\n\n    def is_valid(row, col):\n        return 0 <= row < n and 0 <= col < m and labyrinth[row][col] == '.'\n\n    def dfs(row, col, visited):\n        if not is_valid(row, col):\n            return 0\n        if visited[row][col]:\n            return 0\n        visited[row][col] = True\n\n        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            if x >= abs(dr) and y >= abs(dc):\n                dfs(row + dr, col + dc, visited)\n\n        return 1\n\n    visited = [[False for _ in range(m)] for _ in range(n)]\n    count = 0\n\n    for i in range(n):\n        for j in range(m):\n            if labyrinth[i][j] == '.' and not visited[i][j]:\n                count += dfs(i, j, visited)\n\n    return str(count)\n"
    },
    {
        "number": 3927,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    weights = list(map(int, stdin.splitlines()[1].split()))\n    weights.sort()\n\n    k = 2\n    m = sum(weights) // k\n\n    count = 0\n    for i in range(n - k + 1):\n        if sum(weights[i:i + k]) == m:\n            count += 1\n            break\n\n    return count\n"
    },
    {
        "number": 3928,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b = map(int, stdin.split()[:3])\n    s = stdin.split()[3]\n\n    dp = [0] * (n + 1)\n    for i in range(1, n + 1):\n        dp[i] = dp[i - 1] + a\n        for j in range(i - 1, 0, -1):\n            if s[i - 1] == s[j - 1]:\n                dp[i] = min(dp[i], dp[j - 1] + b)\n\n    return dp[n]\n"
    },
    {
        "number": 3929,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, K = map(int, stdin.split())\n    mod = 10**9 + 7\n    count = 0\n    for i in range(1, N+1):\n        if i == K:\n            count += 1\n        if i == N:\n            count += 1\n    return count % mod\n"
    },
    {
        "number": 3930,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def count_powers(total_affection, k):\n        if total_affection == 0:\n            return 1\n        count = 0\n        for i in range(1, total_affection + 1):\n            if i ** k <= total_affection:\n                count += count_powers(total_affection - i, k)\n        return count\n\n    total_affection = sum(a)\n    return count_powers(total_affection, k)\n"
    },
    {
        "number": 3931,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, k, f = map(int, stdin.split()[:5])\n    trips = stdin.split()[5:]\n    if k == 0:\n        return a * n\n    else:\n        card_cost = f\n        trip_cost = a\n        total_cost = 0\n        cards_used = 0\n        for i in range(0, len(trips), 2):\n            start, finish = trips[i], trips[i+1]\n            if start == finish:\n                trip_cost = b\n            if cards_used < k:\n                total_cost += trip_cost\n                cards_used += 1\n            else:\n                total_cost += trip_cost - card_cost\n        return total_cost\n"
    },
    {
        "number": 3932,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    c = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_valid_tree(c):\n        if len(c) == 1:\n            return True\n        for i in range(1, len(c)):\n            if c[i] < 2:\n                return False\n        return True\n\n    if is_valid_tree(c):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3933,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    temperatures = list(map(int, stdin.splitlines()[1].split()))\n\n    if n == 1:\n        return str(temperatures[0])\n\n    if temperatures[0] == temperatures[1]:\n        return str(temperatures[0])\n\n    if temperatures[1] - temperatures[0] == temperatures[2] - temperatures[1]:\n        return str(temperatures[0] + (n + 1) * (temperatures[1] - temperatures[0]))\n    else:\n        return str(temperatures[-1])\n"
    },
    {
        "number": 3934,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    edges = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    def dfs(node, parent, depth, graph, visited, values):\n        visited[node] = True\n        for child in graph[node]:\n            if child != parent:\n                dfs(child, node, depth + 1, graph, visited, values)\n                values[child] = values[node] + values[child]\n\n    graph = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    values = [0] * (n + 1)\n    dfs(1, -1, 0, graph, visited, values)\n\n    for i in range(2, n + 1):\n        if not visited[i]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3935,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    B = list(map(int, stdin.splitlines()[1].split()))\n\n    def bipartite(B):\n        graph = defaultdict(set)\n        for i in range(len(B)):\n            for j in range(i + 1, len(B)):\n                if abs(B[i] - B[j]) in B:\n                    graph[i].add(j)\n                    graph[j].add(i)\n        return graph\n\n    def dfs(graph, visited, vertex, color):\n        visited[vertex] = color\n        for neighbor in graph[vertex]:\n            if visited[neighbor] == color:\n                return False\n            if visited[neighbor] == -1:\n                if not dfs(graph, visited, neighbor, -color):\n                    return False\n        return True\n\n    graph = bipartite(B)\n    visited = [-1] * len(B)\n    color = 0\n    for i in range(len(B)):\n        if visited[i] == -1:\n            if not dfs(graph, visited, i, color):\n                color ^= 1\n                visited = [-1] * len(B)\n                for j in range(len(B)):\n                    if visited[j] == -1:\n                        if dfs(graph, visited, j, color):\n                            B.remove(B[j])\n                            break\n                break\n\n    return len(B), B\n"
    },
    {
        "number": 3936,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin[0])\n    S_1 = stdin[1]\n    S_2 = stdin[2]\n\n    def paint_dominoes(dominoes, colors):\n        if not dominoes:\n            return 1\n        count = 0\n        for i in range(len(dominoes)):\n            if i == 0 or dominoes[i] != dominoes[i - 1]:\n                for color in colors:\n                    count += paint_dominoes(dominoes[i + 1:], colors - {color})\n        return count % 1000000007\n\n    colors = set(\"red\", \"cyan\", \"green\")\n    dominoes = [S_1[i] + S_2[i] for i in range(N)]\n    return paint_dominoes(dominoes, colors)\n"
    },
    {
        "number": 3937,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n    for i in range(1, n + 1):\n        for j in range(1, m - k + 2):\n            if all(GCD(i, j + l - 1) == a[l - 1] for l in range(1, k + 1)):\n                return \"YES\"\n    return \"NO\"\n\ndef"
    },
    {
        "number": 3938,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    black_rectangles = [tuple(map(int, stdin.split()[2*i:2*i+4])) for i in range(m)]\n\n    def min_cost(x1, y1, x2, y2):\n        h, w = abs(x2 - x1) + 1, abs(y2 - y1) + 1\n        return min(h, w)\n\n    total_cost = 0\n    for x1, y1, x2, y2 in black_rectangles:\n        total_cost += min_cost(x1, y1, x2, y2)\n\n    return str(total_cost)\n"
    },
    {
        "number": 3939,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    t = int(stdin.split('\\n')[0])\n    output = []\n    for _ in range(t):\n        n, k = map(int, stdin.split('\\n')[1].split())\n        a = list(map(int, stdin.split('\\n')[2].split()))\n        median = sorted(a)[n // 2]\n        if k == median:\n            output.append('yes')\n        else:\n            output.append('no')\n        stdin = '\\n'.join(stdin.split('\\n')[3:])\n    return '\\n'.join(output)\n"
    },
    {
        "number": 3940,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    subarrays = [tuple(map(int, stdin.split()[2:4])) for _ in range(m)]\n\n    a = [0] * n\n    mex = 0\n\n    for l, r in subarrays:\n        for i in range(l, r + 1):\n            if a[i] == 0:\n                a[i] = mex\n                mex += 1\n\n    max_mex = max(a)\n\n    return str(max_mex) + '\\n' + ' '.join(map(str, a))\n"
    },
    {
        "number": 3941,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    rooms = list(map(int, stdin.split()[2:2+n]))\n    switches = [list(map(int, stdin.split()[2+n+i::2])) for i in range(m)]\n\n    # Check if it's possible to unlock all doors at the same time\n    for switch in switches:\n        doors = set()\n        for room in switch:\n            doors.add(room)\n        if len(doors) == n:\n            return \"YES\"\n\n    return \"NO\"\n"
    },
    {
        "number": 3942,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.strip()\n    n = len(s)\n    dp = [0] * n\n    for i in range(n):\n        if s[i] == '(':\n            dp[i] = 1\n        elif s[i] == ')':\n            dp[i] = 0\n        else:\n            if i == 0:\n                dp[i] = 0\n            else:\n                dp[i] = dp[i-1]\n    for i in range(n):\n        if s[i] == '#':\n            if dp[i] == 0:\n                print(1)\n            else:\n                print(dp[i])\n    return\n"
    },
    {
        "number": 3943,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    a, b = map(int, stdin.split())\n    if a == 0 and b == 0:\n        return \"0\\n\"\n    if a == 0:\n        return f\"{b**2}\\n{'x'*b}\"\n    if b == 0:\n        return f\"{a**2}\\n{'o'*a}\"\n    score = 0\n    o_count = 0\n    x_count = 0\n    deck = []\n    for i in range(a+b):\n        if i < a:\n            deck.append('o')\n            o_count += 1\n        else:\n            deck.append('x')\n            x_count += 1\n    for i in range(1, a+b):\n        if deck[i] == deck[i-1]:\n            continue\n        if deck[i] == 'o':\n            score += o_count**2\n            o_count = 1\n        else:\n            score -= x_count**2\n            x_count = 1\n    score += o_count**2\n    score += x_count**2\n    return f\"{score}\\n{''.join(deck)}\"\n"
    },
    {
        "number": 3944,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N, M, K = map(int, stdin.split())\n    count = 0\n\n    for i in range(3):\n        for j in range(3):\n            for k in range(3):\n                if (i == 0 and j == 0 and k == 0) or (i == 1 and j == 1 and k == 1):\n                    continue\n                count += 3**(N - i) * 3**(M - j) * 3**(K - k)\n\n    return str(count % (10**9 + 7))\n"
    },
    {
        "number": 3945,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    heights = [list(map(int, stdin.split()[2:]))]\n    for _ in range(n-1):\n        heights.append(list(map(int, input().split())))\n    for i in range(n):\n        for j in range(m):\n            heights[i][j] = min(heights[i][j], heights[i][m-j-1], heights[n-i-1][j], heights[n-i-1][m-j-1])\n    for i in range(n):\n        for j in range(m):\n            print(heights[i][j], end=' ')\n    return '\\n'\n"
    },
    {
        "number": 3946,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:n+2]))\n    w = list(map(int, stdin.split()[n+2:]))\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def mod_inverse(a, m):\n        def egcd(a, b):\n            if a == 0:\n                return (b, 0, 1)\n            else:\n                g, y, x = egcd(b % a, a)\n                return (g, x - (b // a) * y, y)\n\n        g, x, _ = egcd(a, m)\n        if g != 1:\n            raise Exception(\"Inverse doesn't exist\")\n        else:\n            return x % m\n\n    def mod_pow(base, exponent, modulus):\n        if modulus == 1:\n            return 0\n        result = 1\n        while exponent > 0:\n            if exponent % 2 == 1:\n                result = (result * base) % modulus\n            base = (base * base) % modulus\n            exponent = exponent // 2\n        return result\n\n    def get_expected_weight(w):\n        total_weight = sum(w)\n        if total_weight > 998244352 - m:\n            raise Exception(\"Sum of weights exceeds the limit\")\n\n        expected_weights = []\n        for i in range(n):\n            if a[i] == 1:\n                expected_weights.append(w[i] + m)\n            else:\n                expected_weights.append(w[i] - m)\n\n        return expected_weights\n\n    expected_weights = get_expected_weight(w)\n\n    result = []\n    for weight in expected_weights:\n        p = 998244353\n        q = weight\n        r = 0\n        while gcd(p, q) != 1:\n            p -= 1\n        r = mod_pow(p, q, p)\n        result.append(r)\n\n    return \"\\n\".join(map(str, result))\n"
    },
    {
        "number": 3947,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    arr = list(map(int, stdin.splitlines()[1].split()))\n    max_points = 0\n\n    for i in range(n):\n        if i == 0:\n            if i + 1 < n:\n                max_points += min(arr[i], arr[i + 1])\n        elif i == n - 1:\n            if i - 1 >= 0:\n                max_points += min(arr[i], arr[i - 1])\n        else:\n            max_points += min(arr[i], arr[i - 1], arr[i + 1])\n\n    return str(max_points)\n"
    },
    {
        "number": 3948,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n-1):\n        u, v = map(int, input().split())\n        graph[u-1].append(v-1)\n        graph[v-1].append(u-1)\n\n    def dfs(v: int, parent: int) -> bool:\n        center = -1\n        for u in graph[v]:\n            if u != parent:\n                if center == -1:\n                    center = u\n                else:\n                    return False\n        if center == -1:\n            return False\n        for u in graph[v]:\n            if u != parent:\n                if not dfs(u, v):\n                    return False\n        return True\n\n    return \"Yes\" if dfs(0, -1) else \"No\"\n"
    },
    {
        "number": 3949,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    coloring = stdin.split()[2:]\n    coloring = [list(row) for row in coloring]\n\n    def is_valid_placement(north_magnets, south_magnets):\n        for i in range(n):\n            if south_magnets[i] == 0:\n                return False\n            for j in range(m):\n                if coloring[i][j] == '#':\n                    if north_magnets[i][j] == 0:\n                        return False\n        return True\n\n    def move_north_magnet(north_magnets, south_magnets, i, j):\n        if south_magnets[i] == 0:\n            return False\n        if north_magnets[i][j] == 0:\n            return False\n        if i == 0 or j == 0 or i == n - 1 or j == m - 1:\n            return False\n        if north_magnets[i - 1][j] == 0 and north_magnets[i + 1][j] == 0 and north_magnets[i][j - 1] == 0 and north_magnets[i][j + 1] == 0:\n            return False\n        north_magnets[i][j] -= 1\n        south_magnets[i] -= 1\n        return True\n\n    north_magnets = [[0 for j in range(m)] for i in range(n)]\n    south_magnets = [0 for i in range(n)]\n\n    for i in range(n):\n        for j in range(m):\n            if coloring[i][j] == '#':\n                north_magnets[i][j] = 1\n\n    min_north_magnets = 0\n    for i in range(n):\n        for j in range(m):\n            if south_magnets[i] > 0 and north_magnets[i][j] > 0:\n                min_north_magnets += 1\n\n    if is_valid_placement(north_magnets, south_magnets):\n        return min_north_magnets\n    else:\n        return -1\n"
    },
    {
        "number": 3950,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, q = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    result = [0] * n\n\n    def can_obtain(a, result):\n        for i in range(n):\n            if a[i] != result[i]:\n                return False\n        return True\n\n    def restore_array(a, result):\n        for i in range(n):\n            if a[i] != result[i]:\n                result[i] = a[i]\n\n    for i in range(q):\n        l, r = map(int, input().split())\n        for j in range(l - 1, r):\n            result[j] = i + 1\n\n        if can_obtain(a, result):\n            return \"YES\\n\" + \" \".join(map(str, result))\n\n    return \"NO\"\n"
    },
    {
        "number": 3951,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    gcd_table = list(map(int, stdin.splitlines()[1].split()))\n\n    # Create a dictionary to store the indices of the elements in the array\n    indices = {}\n    for i in range(n):\n        indices[gcd_table[i]] = i\n\n    # Create a new array and fill it with the elements from the GCD table\n    a = [0] * n\n    for i in range(n):\n        a[indices[i]] = i\n\n    return \" \".join(map(str, a))\n"
    },
    {
        "number": 3952,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    points = [tuple(map(int, line.split())) for line in stdin.splitlines()[1:]]\n    points.sort()\n\n    def count_sets(points, l, r, a):\n        count = 0\n        i = 0\n        for x, y in points:\n            if x < l:\n                continue\n            if x > r:\n                break\n            if y > a:\n                count += 1\n            i += 1\n        return count\n\n    l, r, a = map(int, input().split())\n    return count_sets(points, l, r, a)\n"
    },
    {
        "number": 3953,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    grid = [list(line) for line in stdin.splitlines()[1:]]\n\n    def purify(cell):\n        row, col = cell\n        for i in range(n):\n            if grid[i][col] == 'E':\n                grid[i][col] = '.'\n        for j in range(n):\n            if grid[row][j] == 'E':\n                grid[row][j] = '.'\n\n    def is_evil(cell):\n        row, col = cell\n        return grid[row][col] == 'E'\n\n    def count_evil():\n        return sum(row.count('E') for row in grid)\n\n    def min_purify():\n        min_spells = float('inf')\n        for i in range(n):\n            for j in range(n):\n                if is_evil((i, j)):\n                    purify((i, j))\n                    min_spells = min(min_spells, count_evil())\n                    purify((i, j))  # revert the purification\n        return min_spells\n\n    if min_purify() == float('inf'):\n        return -1\n    else:\n        return '\\n'.join(f'{i + 1} {j + 1}' for i in range(n) for j in range(n) if is_evil((i, j)))\n"
    },
    {
        "number": 3954,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    def f(a, l, r):\n        return sum(a[i] for i in range(l, r+1))\n\n    def m(a):\n        return max(f(a, l, r) for l in range(1, n+1) for r in range(l, n+1))\n\n    max_m = m(a)\n    for i in range(k):\n        for j in range(i+1, n):\n            a[i], a[j] = a[j], a[i]\n            max_m = max(max_m, m(a))\n            a[i], a[j] = a[j], a[i]\n\n    return str(max_m)\n"
    },
    {
        "number": 3955,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k, x = map(int, stdin.split()[:3])\n    a = list(map(int, stdin.split()[3:]))\n\n    max_value = 0\n    for i in range(n):\n        max_value |= a[i]\n\n    for i in range(k):\n        max_value = max_value | (max_value * x)\n\n    return str(max_value)\n"
    },
    {
        "number": 3956,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    K, N = map(int, stdin.split())\n    MOD = 998244353\n\n    def count_combinations(sides: int, target: int) -> int:\n        if sides == 1:\n            return 1 if target == 1 else 0\n        if target == 1:\n            return 1\n        count = 0\n        for i in range(1, sides + 1):\n            count += count_combinations(sides - 1, target - i)\n            count %= MOD\n        return count\n\n    result = []\n    for i in range(2, 2 * K + 1):\n        count = 0\n        for sides in range(1, K + 1):\n            count += count_combinations(sides, i)\n            count %= MOD\n        result.append(count)\n\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3957,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[:2])\n    u = list(map(int, stdin.split()[2:2*k+2]))\n    roads = [tuple(map(int, stdin.split()[2*k+2+i:2*k+4+i])) for i in range(n-1)]\n\n    def distance(u1, u2):\n        for road in roads:\n            if u1 in road and u2 in road:\n                return road[0] + road[1]\n        return 0\n\n    pairs = []\n    for i in range(k):\n        pairs.append((u[2*i], u[2*i+1]))\n\n    max_distance = 0\n    for pair1 in pairs:\n        for pair2 in pairs:\n            if pair1 != pair2:\n                max_distance = max(max_distance, distance(pair1[0], pair2[0]) + distance(pair1[1], pair2[1]))\n\n    return max_distance\n"
    },
    {
        "number": 3958,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_zebra(sequence: str) -> bool:\n        for i in range(len(sequence) // 2):\n            if sequence[i] != sequence[-i - 1]:\n                return False\n        return True\n\n    def find_zebra_subsequences(sequence: str) -> List[Tuple[int, List[int]]]:\n        subsequences = []\n        current_subsequence = []\n        for i, day in enumerate(sequence, start=1):\n            current_subsequence.append(i)\n            if day == '0':\n                if is_zebra(current_subsequence):\n                    subsequences.append((len(current_subsequence), current_subsequence))\n                current_subsequence = []\n        return subsequences\n\n    def print_subsequences(subsequences: List[Tuple[int, List[int]]]) -> str:\n        result = str(len(subsequences)) + '\\n'\n        for subsequence in subsequences:\n            result += str(subsequence[0]) + ' ' + ' '.join(map(str, subsequence[1])) + '\\n'\n        return result\n\n    sequence = stdin.strip()\n    subsequences = find_zebra_subsequences(sequence)\n    if not subsequences:\n        return '-1\\n'\n    return print_subsequences(subsequences)\n"
    },
    {
        "number": 3959,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    gyms = [list(map(int, stdin.split()[2:])) for _ in range(n)]\n\n    def count_pokemons(gym_pokemons):\n        pokemons = [0] * m\n        for pokemon_type in gym_pokemons:\n            pokemons[pokemon_type - 1] += 1\n        return pokemons\n\n    def is_valid_evolution(pokemons, evolution_plan):\n        for i in range(m):\n            if pokemons[i] != 0 and pokemons[evolution_plan[i] - 1] == 0:\n                return False\n        return True\n\n    def count_valid_evolutions(pokemons, evolution_plan):\n        valid_evolutions = 1\n        for i in range(m):\n            if pokemons[i] > 0:\n                valid_evolutions *= pokemons[i]\n        return valid_evolutions\n\n    def count_valid_evolution_plans(gym_pokemons):\n        pokemons = count_pokemons(gym_pokemons)\n        valid_evolutions = 1\n        for i in range(m):\n            valid_evolutions *= pokemons[i]\n        return valid_evolutions\n\n    total_valid_evolutions = 1\n    for gym_pokemons in gyms:\n        total_valid_evolutions *= count_valid_evolution_plans(gym_pokemons)\n\n    return str(total_valid_evolutions % (10**9 + 7))\n"
    },
    {
        "number": 3960,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def f(l, r):\n        return sum(abs(a[i] - a[i + 1]) * (-1) ** (i - l) for i in range(l, r - 1))\n\n    max_f = 0\n    for l in range(n):\n        for r in range(l + 1, n + 1):\n            max_f = max(max_f, f(l, r))\n\n    return str(max_f)\n"
    },
    {
        "number": 3961,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    p = list(map(int, stdin.splitlines()[1].split()))\n\n    def count_crosses(i: int) -> int:\n        if i == 1:\n            return 1\n        return count_crosses(i - 1) + p[i - 1]\n\n    def count_moves(i: int) -> int:\n        if i == n:\n            return 0\n        crosses = count_crosses(i)\n        if crosses % 2 == 1:\n            return count_moves(i + 1) + 1\n        else:\n            return count_moves(i + 1)\n\n    return str(count_moves(1) % (10**9 + 7))\n"
    },
    {
        "number": 3962,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    l_r = [list(map(int, line.split())) for line in stdin.splitlines()[1:]]\n\n    # Calculate the maximum number of chairs needed for each guest\n    max_chairs = [max(l_r[i][0], l_r[i][1]) for i in range(n)]\n\n    # Calculate the total number of chairs needed\n    total_chairs = sum(max_chairs)\n\n    # Calculate the minimum number of chairs needed\n    min_chairs = max(max_chairs)\n\n    # Check if there are any chairs that can be shared between guests\n    for i in range(n):\n        for j in range(i + 1, n):\n            if max_chairs[i] + max_chairs[j] <= total_chairs:\n                min_chairs = min(min_chairs, max_chairs[i] + max_chairs[j])\n\n    return str(min_chairs)\n"
    },
    {
        "number": 3963,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, a, b, m = map(int, stdin.split())\n    a = list(map(int, stdin.split()))\n    b = list(map(int, stdin.split()))\n\n    def count_ways(n, m, a, b):\n        if m == 0:\n            return 1\n        if n == 0:\n            return 0\n        if m < 0:\n            return 0\n\n        count = 0\n        for i in range(1, n + 1):\n            if b[i - 1] > 0:\n                count += count_ways(n - 1, m - a[i - 1], a, b)\n                count %= (10**9 + 7)\n                b[i - 1] -= 1\n\n        return count\n\n    return str(count_ways(n, m, a, b))\n"
    },
    {
        "number": 3964,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, b, mod = map(int, stdin.split()[:4])\n    a = list(map(int, stdin.split()[4:]))\n\n    def count_bugs(plan):\n        return sum(a[i] * plan[i] for i in range(n))\n\n    def count_lines(plan):\n        return sum(plan)\n\n    def is_good(plan):\n        return count_bugs(plan) <= b\n\n    def count_good_plans(plan):\n        if count_lines(plan) > m:\n            return 0\n        if count_lines(plan) == m:\n            return 1\n        return count_good_plans(plan + [1]) + count_good_plans(plan + [0])\n\n    def count_good_plans_mod(plan):\n        return count_good_plans(plan) % mod\n\n    def count_good_plans_mod_recursive(plan, count):\n        if count_lines(plan) > m:\n            return 0\n        if count_lines(plan) == m:\n            return count_bugs(plan) <= b\n        return count_good_plans_mod_recursive(plan + [1], count + 1) + count_good_plans_mod_recursive(plan + [0], count + 1)\n\n    # plan = [0] * n\n    # count = count_good_plans_mod_recursive(plan, 0)\n    # print(count)\n\n    plan = [0] * n\n    count = count_good_plans(plan)\n    print(count)\n"
    },
    {
        "number": 3965,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, *verse_pattern = map(int, stdin.split())\n    text = stdin.split('\\n')[1:]\n\n    def count_syllables(word: str) -> int:\n        vowels = 'aeiouy'\n        syllables = 0\n        for i in range(len(word)):\n            if word[i] in vowels:\n                syllables += 1\n                j = i + 1\n                while j < len(word) and word[j] not in vowels:\n                    j += 1\n                i = j\n        return syllables\n\n    for i in range(n):\n        line = text[i]\n        words = line.split()\n        syllables = 0\n        for word in words:\n            if any(char in 'aeiouy' for char in word):\n                syllables += count_syllables(word)\n        if syllables != verse_pattern[i]:\n            return \"NO\"\n\n    return \"YES\"\n"
    },
    {
        "number": 3966,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    numbers = list(map(int, stdin.splitlines()[1].split()))\n\n    score = 0\n    while numbers:\n        if len(numbers) == 1:\n            numbers.pop()\n        else:\n            score += sum(numbers)\n            mid = len(numbers) // 2\n            left, right = numbers[:mid], numbers[mid:]\n            numbers = left + right\n\n    return str(score)\n"
    },
    {
        "number": 3967,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    a = list(map(int, stdin.split()[2:]))\n    d = 1\n    total_length = 0\n    while total_length < k:\n        total_length = sum(min(a[i], d) for i in range(n))\n        d += 1\n    return d - 1\n"
    },
    {
        "number": 3968,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    N, D, C = map(int, input_list[0].split())\n    infected_indices = list(map(int, input_list[1].split()))\n    entry_exit_times = [list(map(int, input_list[i].split())) for i in range(2, N+2)]\n\n    def is_infected(person_index: int) -> bool:\n        for i in range(len(entry_exit_times)):\n            if entry_exit_times[i][0] <= person_index <= entry_exit_times[i][1]:\n                return True\n        return False\n\n    def is_in_contact(person_index: int, other_person_index: int) -> bool:\n        for i in range(len(entry_exit_times)):\n            if entry_exit_times[i][0] <= person_index <= entry_exit_times[i][1] and entry_exit_times[i][0] <= other_person_index <= entry_exit_times[i][1]:\n                return True\n        return False\n\n    infected_people = set(infected_indices)\n    infected_after_D = set()\n\n    for day in range(1, D+1):\n        new_infected_people = set()\n        for person_index in range(1, N+1):\n            if is_infected(person_index) and not is_in_contact(person_index, person_index):\n                new_infected_people.add(person_index)\n            for other_person_index in range(1, N+1):\n                if is_in_contact(person_index, other_person_index) and is_infected(other_person_index) and not is_in_contact(person_index, other_person_index):\n                    new_infected_people.add(person_index)\n        infected_after_D.update(new_infected_people)\n        infected_people = new_infected_people\n\n    return ' '.join(map(str, sorted(infected_after_D)))"
    },
    {
        "number": 3969,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    plants = [tuple(map(float, line.split())) for line in stdin.split('\\n')[1:n+1]]\n    borders = sorted(plants, key=lambda x: x[1])\n    borders = [(i, borders[i-1][1] + 1) for i in range(1, m)]\n    borders.append((m, 0))\n    borders.sort(key=lambda x: x[1])\n    borders = [b[0] for b in borders]\n    replants = 0\n    for i in range(1, m):\n        if borders[i] != i:\n            replants += 1\n    return str(replants)\n"
    },
    {
        "number": 3970,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split()[0:2])\n    nums = list(map(int, stdin.split()[2:]))\n\n    max_subset_size = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if nums[j] % nums[i] == 0:\n                max_subset_size = max(max_subset_size, j - i + 1)\n\n    return str(max_subset_size)\n"
    },
    {
        "number": 3971,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    points = 0\n    for i in range(n):\n        if a[i] - 1 in a:\n            a.remove(a[i] - 1)\n            points += 1\n        if a[i] + 1 in a:\n            a.remove(a[i] + 1)\n            points += 1\n    return points\n"
    },
    {
        "number": 3972,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.strip())\n    MOD = 10**9 + 7\n\n    def count_sequences(n: int) -> int:\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            return (count_sequences(n - 1) + count_sequences(n - 2)) % MOD\n\n    def count_sequences_with_condition(n: int) -> int:\n        if n == 1:\n            return 1\n        elif n == 2:\n            return 2\n        else:\n            count = count_sequences_with_condition(n - 1) + count_sequences_with_condition(n - 2)\n            count = (count + count_sequences(n - 1)) % MOD\n            return count\n\n    count = count_sequences_with_condition(n)\n    return str(count)\n"
    },
    {
        "number": 3973,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n\n    # Initialize variables\n    min_presses = float('inf')\n    x = 1\n\n    # Iterate through all possible favorite brightness levels\n    for i in range(1, m + 1):\n        # Calculate the number of presses for this favorite brightness level\n        presses = 0\n        for j in range(n):\n            if a[j] == 1:\n                presses += 1\n            elif a[j] == i:\n                presses += 1\n            else:\n                presses += 2\n\n        # Update the minimum number of presses\n        if presses < min_presses:\n            min_presses = presses\n            x = i\n\n    return min_presses"
    },
    {
        "number": 3974,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    count = 0\n    for char in stdin:\n        if char == '+':\n            count += 1\n        elif char == '-':\n            count -= 1\n    return count\n"
    },
    {
        "number": 3975,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    scheme = stdin.splitlines()[1:]\n\n    # Create a dictionary to store the logical scheme\n    scheme_dict = {}\n    for vertex in scheme:\n        vertex_type, *vertex_values = vertex.split()\n        if vertex_type == \"IN\":\n            scheme_dict[int(vertex_values[0])] = int(vertex_values[1])\n        else:\n            scheme_dict[int(vertex_values[0])] = (vertex_type, [int(v) for v in vertex_values[1:]])\n\n    # Determine the output for each input\n    output = []\n    for i in range(1, n + 1):\n        if i in scheme_dict:\n            vertex_type, vertex_values = scheme_dict[i]\n            if vertex_type == \"IN\":\n                output.append(str(vertex_values))\n            else:\n                input_values = [scheme_dict[v][1] if v in scheme_dict else \"IN\" for v in vertex_values]\n                if vertex_type == \"AND\":\n                    output.append(str(int(all(input_values))))\n                elif vertex_type == \"OR\":\n                    output.append(str(int(any(input_values))))\n                elif vertex_type == \"XOR\":\n                    output.append(str(int(sum(input_values) == 1)))\n                elif vertex_type == \"NOT\":\n                    output.append(str(int(not input_values[0])))\n        else:\n            output.append(\"0\")\n\n    return \"\".join(output)\n"
    },
    {
        "number": 3976,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.split('\\n')\n    n, m, p = map(int, input_list[0].split())\n    a = list(map(int, input_list[1].split()))\n    b = list(map(int, input_list[2].split()))\n\n    valid_qs = []\n    for i in range(1, n + 1):\n        if a[i - 1] + (m - 1) * p <= a[i - 1] + m * p:\n            valid_qs.append(i)\n\n    result = len(valid_qs)\n    if result > 0:\n        valid_qs.sort()\n        result_str = ' '.join(map(str, valid_qs))\n    else:\n        result_str = ''\n\n    return f'{result}\\n{result_str}'\n"
    },
    {
        "number": 3977,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    input_list = stdin.splitlines()\n    n, m, k = map(int, input_list[0].split())\n    c = list(map(int, input_list[1].split()))\n    edges = [tuple(map(int, input_list[i].split())) for i in range(2, len(input_list))]\n\n    # Check if the graph is stable\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) in edges or (j, i) in edges:\n                return \"0\"\n\n    # Check if the graph is simple\n    for edge in edges:\n        if edge[0] == edge[1]:\n            return \"0\"\n\n    # Check if the graph is connected\n    visited = [False] * (n + 1)\n    queue = [1]\n    visited[1] = True\n    while queue:\n        node = queue.pop(0)\n        for edge in edges:\n            if not visited[edge[0]] and edge[1] == node:\n                queue.append(edge[0])\n                visited[edge[0]] = True\n            elif not visited[edge[1]] and edge[0] == node:\n                queue.append(edge[1])\n                visited[edge[1]] = True\n\n    if not all(visited):\n        return \"0\"\n\n    # Check if the graph is connected to the special nodes\n    for i in range(1, k + 1):\n        if not visited[c[i - 1]]:\n            return \"0\"\n\n    # Add edges to the graph\n    max_edges = 0\n    for i in range(1, n + 1):\n        for j in range(i + 1, n + 1):\n            if (i, j) not in edges and (j, i) not in edges:\n                max_edges += 1\n\n    return str(max_edges)\n"
    },
    {
        "number": 3978,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def is_valid(color, elements):\n        return all(element % color[0] == 0 for element in elements)\n\n    def min_colors(a):\n        colors = set()\n        for element in a:\n            for color in colors:\n                if is_valid(color, [element]):\n                    break\n            else:\n                colors.add((element,))\n        return colors\n\n    colors = min_colors(a)\n    return len(colors)\n"
    },
    {
        "number": 3979,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_lexicographically_ordered(words: List[str]) -> bool:\n        for i in range(len(words) - 1):\n            for j in range(len(words[i])):\n                if words[i][j] > words[i + 1][j]:\n                    return False\n                if words[i][j] < words[i + 1][j]:\n                    break\n        return True\n\n    def capitalize_letters(words: List[str], letters: Set[int]) -> List[str]:\n        capitalized_words = []\n        for word in words:\n            capitalized_word = \"\"\n            for letter in word:\n                if int(letter) in letters:\n                    capitalized_word += str(int(letter) + 1)\n                else:\n                    capitalized_word += letter\n            capitalized_words.append(capitalized_word)\n        return capitalized_words\n\n    def find_capitalization(words: List[str]) -> Tuple[bool, int, Set[int]]:\n        n = len(words)\n        m = len(words[0])\n        letters = set(range(1, m + 1))\n        k = 0\n        result = False\n\n        while k < len(letters):\n            capitalized_words = capitalize_letters(words, letters)\n            if is_lexicographically_ordered(capitalized_words):\n                result = True\n                break\n            else:\n                k += 1\n                letters.remove(k)\n\n        if result:\n            return result, k, letters\n        else:\n            return result, 0, set()\n\n    def main(stdin: str) -> str:\n        n, m = map(int, stdin.split()[:2])\n        words = [stdin.split()[i] for i in range(2, 2 + n * (m + 1), m + 1)]\n\n        result, k, letters = find_capitalization(words)\n\n        if result:\n            return \"Yes\\n{}\\n{}\".format(k, \" \".join(map(str, sorted(letters))))\n        else:\n            return \"No\"\n\n    return main(stdin)\n"
    },
    {
        "number": 3980,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin)\n    max_beauty = 0\n    max_permutation = []\n    for p in itertools.permutations(range(n+1)):\n        beauty = sum(p[i] ^ i for i in range(n+1))\n        if beauty > max_beauty:\n            max_beauty = beauty\n            max_permutation = p\n    return f\"{max_beauty}\\n{' '.join(map(str, max_permutation))}\"\n"
    },
    {
        "number": 3981,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[:2])\n    points1 = [tuple(map(int, input().split())) for _ in range(n)]\n    points2 = [tuple(map(int, input().split())) for _ in range(m)]\n\n    def rotate(x, y, theta):\n        return x * cos(theta) - y * sin(theta), x * sin(theta) + y * cos(theta)\n\n    def shift(x, y, a, b):\n        return x + a, y + b\n\n    def combine_power_sources(points1, points2):\n        points = set(points1 + points2)\n        while True:\n            new_points = set()\n            for k in range(1, n + m):\n                for point in points:\n                    new_point = tuple(shift(*point, a=k * (n + m - 1) / (n + m), b=k * (n + m - 1) / (n + m)))\n                    new_points.add(new_point)\n            if points == new_points:\n                return new_points\n            points = new_points\n\n    def is_safe(points1, points2):\n        points = combine_power_sources(points1, points2)\n        for point in points:\n            if point in points1 or point in points2:\n                return False\n        return True\n\n    if is_safe(points1, points2):\n        return \"YES\"\n    else:\n        return \"NO\"\n"
    },
    {
        "number": 3982,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    m, S = map(int, stdin.split())\n    mod = 10**9 + 7\n    result = [1]\n    for c in S:\n        if c == '0':\n            result.append((result[-1] * 3) % mod)\n        else:\n            result.append((result[-1] * 5) % mod)\n    return '\\n'.join(map(str, result))\n"
    },
    {
        "number": 3983,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    T = int(stdin)\n    output = []\n    for _ in range(T):\n        N, M = map(int, input().split())\n        adj_list = [[] for _ in range(N+1)]\n        for _ in range(M):\n            a, b = map(int, input().split())\n            adj_list[a].append(b)\n            adj_list[b].append(a)\n        if N == 1 or N == 2:\n            output.append(\"First\")\n        else:\n            output.append(\"Second\")\n    return \"\\n\".join(output)\n"
    },
    {
        "number": 3984,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    s = stdin.split('\\n')[0]\n    n = len(s)\n    for k in range(n):\n        l, r = k, k\n        while l > 0 and r < n-1 and (s[l-1] > s[r+1] or (s[l-1] == s[r+1] and l > 1 and s[l-2] > s[r+1])):\n            l -= 1\n        while l < n-1 and r < n-1 and (s[l+1] < s[r+1] or (s[l+1] == s[r+1] and r < n-2 and s[l+1] < s[r+2])):\n            r += 1\n        if l == k and r == k:\n            print(\"Mike\")\n        else:\n            print(\"Ann\")\n"
    },
    {
        "number": 3985,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def is_good_pair(i, j):\n        return i + j == 2 * k and 1 <= i < j <= n\n\n    def perform_operation(i, j, v):\n        a[i] //= v\n        a[j] //= v\n\n    n, m = map(int, stdin.split()[:2])\n    a = list(map(int, stdin.split()[2:]))\n    k = 0\n    max_operations = 0\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_good_pair(i, j):\n                k = (i + j) // 2\n                max_operations += 1\n\n    for line in stdin.split('\\n')[2:]:\n        i, j = map(int, line.split())\n        if is_good_pair(i - 1, j - 1):\n            perform_operation(i - 1, j - 1, 2)\n            max_operations -= 1\n\n    return max_operations\n"
    },
    {
        "number": 3986,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    if k > n:\n        return \"-1\"\n    if k == n:\n        return \"a\" * n\n    if k == 1:\n        return \"a\" * (n - 1) + \"b\"\n    if k == 2:\n        return \"a\" * (n - 2) + \"bc\"\n    if k == n - 1:\n        return \"a\" * (n - 1) + \"b\"\n    if k == n - 2:\n        return \"a\" * (n - 2) + \"bc\"\n    if k == n - 3:\n        return \"a\" * (n - 3) + \"bcd\"\n    if k == n - 4:\n        return \"a\" * (n - 4) + \"bcde\"\n    if k == n - 5:\n        return \"a\" * (n - 5) + \"bcdef\"\n    if k == n - 6:\n        return \"a\" * (n - 6) + \"bcdefg\"\n    if k == n - 7:\n        return \"a\" * (n - 7) + \"bcdefgh\"\n    if k == n - 8:\n        return \"a\" * (n - 8) + \"bcdefghi\"\n    if k == n - 9:\n        return \"a\" * (n - 9) + \"bcdefghij\"\n    if k == n - 10:\n        return \"a\" * (n - 10) + \"bcdefghijk\"\n    if k == n - 11:\n        return \"a\" * (n - 11) + \"bcdefghijkl\"\n    if k == n - 12:\n        return \"a\" * (n - 12) + \"bcdefghijklm\"\n    if k == n - 13:\n        return \"a\" * (n - 13) + \"bcdefghijklmn\"\n    if k == n - 14:\n        return \"a\" * (n - 14) + \"bcdefghijklmno\"\n    if k == n - 15:\n        return \"a\" * (n - 15) + \"bcdefghijklmnop\"\n    if k == n - 16:\n        return \"a\" * (n - 16) + \"bcdefghijklmnopq\"\n    if k == n - 17:\n        return \"a\" * (n - 17) + \"bcdefghijklmnopqr\"\n    if k == n - 18:\n        return \"a\" * (n - 18) + \"bcdefghijklmnopqrs\"\n    if k == n - 19:\n        return \"a\" * (n - 19) + \"bcdefghijklmnopqrst\"\n    if k == n - 20:\n        return \"a\" * (n - 20) + \"bcdefghijklmnopqrstu\"\n    if k == n - 21:\n        return \"a\" * (n - 21) + \"bcdefghijklmnopqrstuv\"\n    if k == n - 22:\n        return \"a\" * (n - 22) + \"bcdefghijklmnopqrstuva\"\n    if k == n - 23:\n        return \"a\" * (n - 23) + \"bcdefghijklmnopqrstuvw\"\n    if k == n - 24:\n        return \"a\" * (n - 24) + \"bcdefghijklmnopqrstuvwx\"\n    if k == n - 25:\n        return \"a\" * (n - 25) + \"bcdefghijklmnopqrstuvwxy\"\n    if k == n - 26:\n        return \"a\" * (n - 26) + \"bcdefghijklmnopqrstuvwxyz\"\n    return \"a\" * (n - 1) + \"b\" * (k - n + 1)\n"
    },
    {
        "number": 3987,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    def longest_non_decreasing_subsequence(a):\n        dp = [1] * n\n        for i in range(1, n):\n            for j in range(i):\n                if a[i] > a[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    def reverse_sequence(a, l, r):\n        for i in range(l, (l + r) // 2):\n            a[i], a[r - (i - l)] = a[r - (i - l)], a[i]\n\n    max_length = 0\n    for l in range(1, n):\n        for r in range(l, n):\n            reverse_sequence(a, l, r + 1)\n            max_length = max(max_length, longest_non_decreasing_subsequence(a))\n            reverse_sequence(a, l, r + 1)\n\n    return str(max_length)\n"
    },
    {
        "number": 3988,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    def dfs(node, visited, plan, reachable):\n        visited[node] = True\n        plan[node] = True\n        reachable[0] += 1\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, visited, plan, reachable)\n\n    n, m, s = map(int, stdin.split()[:3])\n    graph = [[] for _ in range(n + 1)]\n    for i in range(m):\n        t, u, v = map(int, stdin.split()[i * 3 + 3:(i + 1) * 3 + 3])\n        if t == 1:\n            graph[u].append(v)\n            graph[v].append(u)\n        else:\n            graph[u].append(v)\n            graph[v].append(u)\n\n    visited = [False] * (n + 1)\n    plan1 = [False] * (n + 1)\n    plan2 = [False] * (n + 1)\n    reachable1 = [0]\n    reachable2 = [0]\n\n    dfs(s, visited, plan1, reachable1)\n    dfs(s, visited, plan2, reachable2)\n\n    plan1[s] = True\n    plan2[s] = True\n\n    for i in range(1, n + 1):\n        if not visited[i]:\n            dfs(i, visited, plan1, reachable1)\n            dfs(i, visited, plan2, reachable2)\n\n    plan1 = [str(i) for i in plan1]\n    plan2 = [str(i) for i in plan2]\n\n    plan1 = ''.join(plan1)\n    plan2 = ''.join(plan2)\n\n    return f\"{reachable1[0]}\\n{plan1}\\n{reachable2[0]}\\n{plan2}\"\n"
    },
    {
        "number": 3989,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    digits = [int(d) for d in stdin]\n    digits.sort()\n    if digits == [1, 6, 8, 9]:\n        return \"1869\"\n    elif digits == [1, 6, 8, 9, 0]:\n        return \"18690\"\n    else:\n        return \"0\"\n"
    },
    {
        "number": 3990,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m = map(int, stdin.split()[0:2])\n    railways = [tuple(map(int, line.split())) for line in stdin.split('\\n')[1:m+1]]\n    graph = [[] for _ in range(n+1)]\n    for u, v in railways:\n        graph[u].append(v)\n        graph[v].append(u)\n    visited = [False] * (n+1)\n    def dfs(node, time):\n        if visited[node]:\n            return time\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                time = dfs(neighbor, time)\n        return time\n    time_train = dfs(1, 0)\n    time_bus = dfs(1, 0)\n    if time_train == -1 or time_bus == -1:\n        return -1\n    return max(time_train, time_bus)\n"
    },
    {
        "number": 3991,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    x = list(map(int, stdin.splitlines()[1].split()))\n\n    mod = 10**9 + 7\n\n    def max_distance(a):\n        return max(abs(x[i] - x[j]) for i in a for j in a if i != j)\n\n    def subsets(a):\n        return chain.from_iterable(combinations(a, r) for r in range(1, len(a) + 1))\n\n    answer = sum(max_distance(a) for a in subsets(range(n))) % mod\n\n    return str(answer)\n"
    },
    {
        "number": 3992,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n\n    for i in range(n):\n        if a[i] > 0:\n            break\n    else:\n        return -1\n\n    k = 1\n    for i in range(n):\n        if a[i] % k == 0:\n            k = a[i]\n        else:\n            k = gcd(k, a[i])\n\n    if k == 1:\n        return -1\n\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def lcm(a, b):\n        return a * b // gcd(a, b)\n\n    def min_seconds(n, a, k):\n        if n == 1:\n            return 0\n        if a[n - 1] % k == 0:\n            return min_seconds(n - 1, a, k)\n        else:\n            return min_seconds(n - 1, a, k) + 1\n\n    return min_seconds(n, a, k)\n"
    },
    {
        "number": 3993,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, m, k = map(int, stdin.split()[:3])\n    p = list(map(int, stdin.split()[3:]))\n\n    def find_special_page(page_indices):\n        for i in range(len(page_indices)):\n            if page_indices[i] in p:\n                return i\n        return -1\n\n    def move_items(page_indices, start_index):\n        for i in range(start_index, len(page_indices)):\n            if page_indices[i] in p:\n                page_indices.pop(i)\n                page_indices.insert(i - 1, page_indices.pop(i))\n                return i\n        return -1\n\n    num_operations = 0\n    page_indices = list(range(1, n + 1))\n\n    while True:\n        special_page_index = find_special_page(page_indices)\n        if special_page_index == -1:\n            break\n\n        num_operations += 1\n        page_indices = page_indices[:special_page_index + 1]\n        page_indices = page_indices[:k] + [0] * (k - len(page_indices))\n\n        while True:\n            start_index = move_items(page_indices, 0)\n            if start_index == -1:\n                break\n\n    return str(num_operations)\n"
    },
    {
        "number": 3994,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin[0])\n    lights = stdin[1].split()\n    max_on = 0\n\n    for i in range(n):\n        a, b = map(int, stdin[i+2].split())\n        current_on = 0\n        for j in range(b, n*a, a):\n            if lights[j] == '1':\n                current_on += 1\n            if current_on > max_on:\n                max_on = current_on\n\n    return str(max_on)\n"
    },
    {
        "number": 3995,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n, k = map(int, stdin.split())\n    s = \"01\" * (n // 2)\n    if n % 2 == 1:\n        s += \"0\" if k % 2 == 0 else \"1\"\n    return s\n"
    },
    {
        "number": 3996,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    k, *a = map(int, stdin.split())\n    n = 1\n    for i in range(k):\n        n *= a[i]\n    p, q = 1, 1\n    for i in range(k):\n        p *= a[i]\n        q *= n // a[i]\n    p, q = p % (10**9 + 7), q % (10**9 + 7)\n    return f\"{p}/{q}\"\n"
    },
    {
        "number": 3997,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    a = list(map(int, stdin.splitlines()[1].split()))\n    p = [list(map(int, line.split())) for line in stdin.splitlines()[2:]]\n\n    def dfs(v, parent):\n        count = 1\n        for u, w in p:\n            if u == v:\n                count += dfs(u, v) * w\n        return count\n\n    result = [0] * n\n    for i in range(n):\n        result[i] = dfs(i + 1, -1)\n\n    return ' '.join(map(str, result))\n"
    },
    {
        "number": 3998,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    n = int(stdin.splitlines()[0])\n    r = list(map(int, stdin.splitlines()[1].split()))\n\n    def update_rating(i, j, k):\n        nonlocal r\n        r[i] -= k\n        r[j] -= k\n        r[k] -= k\n\n    def is_valid_party(party):\n        return len(party) >= 2 and len(party) <= 5\n\n    def is_valid_match(i, j):\n        return i != j and r[i] != r[j]\n\n    def play_match(i, j):\n        nonlocal r\n        if r[i] > r[j]:\n            update_rating(i, j, i)\n        elif r[i] < r[j]:\n            update_rating(i, j, j)\n        else:\n            update_rating(i, j, i)\n            update_rating(i, j, j)\n\n    def find_best_match(i, party):\n        best_match = None\n        best_rating = -1\n        for j in range(n):\n            if j not in party and is_valid_match(i, j):\n                if r[i] > r[j] and r[i] - r[j] > best_rating:\n                    best_match = j\n                    best_rating = r[i] - r[j]\n                elif r[i] < r[j] and r[j] - r[i] > best_rating:\n                    best_match = j\n                    best_rating = r[j] - r[i]\n        return best_match, best_rating\n\n    t = 0\n    while max(r) != min(r):\n        t += 1\n        if t > 10**4:\n            break\n\n        party = set(range(n))\n        while is_valid_party(party):\n            i = party.pop()\n            j = party.pop()\n            play_match(i, j)\n            party.add(i)\n            party.add(j)\n\n        for i in range(n):\n            best_match, best_rating = find_best_match(i, party)\n            if best_match is not None:\n                play_match(i, best_match)\n                party.remove(best_match)\n\n    return max(r), t, \"\\n\".join([\"\".join([\"1\" if i in party else \"0\" for i in range(n)]) for _ in range(t)])\n\n\ninput_data = \"\"\"5\n4 5 1 7 4\n\"\"\"\n\noutput_data = \"\"\"1\n8\n01010\n00011\n01010\n10010\n00011\n11000\n00011\n11000\n\"\"\"\n\nprint(solution(input_data))\nprint(output_data) "
    },
    {
        "number": 3999,
        "checkpoint": "7B",
        "pass": 0,
        "answer": "def solution(stdin: str) -> str:\n    N = int(stdin.split('\\n')[0])\n    colors = [list(map(int, stdin.split('\\n')[i].split())) for i in range(1, N+1)]\n\n    def rotate(colors):\n        return [[colors[j][i] for j in range(N)] for i in range(N)]\n\n    def is_same(colors1, colors2):\n        for i in range(N):\n            for j in range(N):\n                if colors1[i][j] != colors2[i][j]:\n                    return False\n        return True\n\n    def count_cubes(colors):\n        count = 0\n        for i in range(4):\n            rotated_colors = rotate(colors)\n            if not is_same(colors, rotated_colors):\n                count += 1\n            colors = rotated_colors\n        return count\n\n    return str(count_cubes(colors))"
    }
]